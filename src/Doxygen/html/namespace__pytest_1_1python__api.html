<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: _pytest.python_api Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace__pytest.html">_pytest</a></li><li class="navelem"><a class="el" href="namespace__pytest_1_1python__api.html">python_api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">_pytest.python_api Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1python__api_1_1_approx_base.html">ApproxBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1python__api_1_1_approx_decimal.html">ApproxDecimal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1python__api_1_1_approx_mapping.html">ApproxMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1python__api_1_1_approx_numpy.html">ApproxNumpy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1python__api_1_1_approx_scalar.html">ApproxScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1python__api_1_1_approx_sequence_like.html">ApproxSequenceLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1python__api_1_1_raises_context.html">RaisesContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae3652289948722b65f579a2e5218c59d" id="r_ae3652289948722b65f579a2e5218c59d"><td class="memItemLeft" align="right" valign="top">TypeError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#ae3652289948722b65f579a2e5218c59d">_non_numeric_type_error</a> (value, Optional[str] at)</td></tr>
<tr class="separator:ae3652289948722b65f579a2e5218c59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e879cf2c61d0254c5920304eb47a19" id="r_ab5e879cf2c61d0254c5920304eb47a19"><td class="memItemLeft" align="right" valign="top">List[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#ab5e879cf2c61d0254c5920304eb47a19">_compare_approx</a> (object full_object, Sequence[Tuple[str, str, str]] message_data, int number_of_elements, Sequence[object] different_ids, float max_abs_diff, float max_rel_diff)</td></tr>
<tr class="separator:ab5e879cf2c61d0254c5920304eb47a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057fdd40ceeee1c6f700c6bb84eba771" id="r_a057fdd40ceeee1c6f700c6bb84eba771"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#a057fdd40ceeee1c6f700c6bb84eba771">_recursive_sequence_map</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, x)</td></tr>
<tr class="separator:a057fdd40ceeee1c6f700c6bb84eba771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac6917455bfd8a96e54d4173a95fdc0" id="r_a3ac6917455bfd8a96e54d4173a95fdc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class__pytest_1_1python__api_1_1_approx_base.html">ApproxBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#a3ac6917455bfd8a96e54d4173a95fdc0">approx</a> (expected, rel=None, abs=None, bool nan_ok=False)</td></tr>
<tr class="separator:a3ac6917455bfd8a96e54d4173a95fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8360978cd078ead51dfdc2ab97bf060f" id="r_a8360978cd078ead51dfdc2ab97bf060f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#a8360978cd078ead51dfdc2ab97bf060f">_is_numpy_array</a> (object obj)</td></tr>
<tr class="separator:a8360978cd078ead51dfdc2ab97bf060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89460c9b793634a25d4f78ed283c29f" id="r_ac89460c9b793634a25d4f78ed283c29f"><td class="memItemLeft" align="right" valign="top">Optional[&quot;ndarray&quot;]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#ac89460c9b793634a25d4f78ed283c29f">_as_numpy_array</a> (object obj)</td></tr>
<tr class="separator:ac89460c9b793634a25d4f78ed283c29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a5aeee0ba0023b027c2c1fc32ab083" id="r_ad7a5aeee0ba0023b027c2c1fc32ab083"><td class="memItemLeft" align="right" valign="top">&quot;RaisesContext[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>]&quot;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#ad7a5aeee0ba0023b027c2c1fc32ab083">raises</a> (Union[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], Tuple[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>],...]] expected_exception, *Optional[Union[str, Pattern[str]]] match=...)</td></tr>
<tr class="separator:ad7a5aeee0ba0023b027c2c1fc32ab083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b36881bf9cd6d4ffbd08332fb33f4c" id="r_ab5b36881bf9cd6d4ffbd08332fb33f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class__pytest_1_1__code_1_1code_1_1_exception_info.html">_pytest._code.ExceptionInfo</a>[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#ab5b36881bf9cd6d4ffbd08332fb33f4c">raises</a> (Union[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], Tuple[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>],...]] expected_exception, Callable[..., Any] <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *Any args, **Any kwargs)</td></tr>
<tr class="separator:ab5b36881bf9cd6d4ffbd08332fb33f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c153cc71cc69c88b8598d01d536ce41" id="r_a5c153cc71cc69c88b8598d01d536ce41"><td class="memItemLeft" align="right" valign="top">Union[&quot;RaisesContext[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>]&quot;, _pytest._code.ExceptionInfo[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#a5c153cc71cc69c88b8598d01d536ce41">raises</a> (Union[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], Tuple[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>],...]] expected_exception, *Any args, **Any kwargs)</td></tr>
<tr class="separator:a5c153cc71cc69c88b8598d01d536ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1f5b9d9a73c83e63ee48bf48a2dee8bc" id="r_a1f5b9d9a73c83e63ee48bf48a2dee8bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a> = TypeVar(&quot;E&quot;, bound=BaseException)</td></tr>
<tr class="separator:a1f5b9d9a73c83e63ee48bf48a2dee8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2886969654e2d5834bbd25a8acd70bfe" id="r_a2886969654e2d5834bbd25a8acd70bfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1python__api.html#a2886969654e2d5834bbd25a8acd70bfe">Exception</a></td></tr>
<tr class="separator:a2886969654e2d5834bbd25a8acd70bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac89460c9b793634a25d4f78ed283c29f" name="ac89460c9b793634a25d4f78ed283c29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89460c9b793634a25d4f78ed283c29f">&#9670;&#160;</a></span>_as_numpy_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[&quot;ndarray&quot;] _pytest.python_api._as_numpy_array </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return an ndarray if the given object is implicitly convertible to ndarray,
and numpy is already imported, otherwise None.
</pre> <div class="fragment"><div class="line"><span class="lineno">  755</span><span class="keyword">def </span>_as_numpy_array(obj: object) -&gt; Optional[<span class="stringliteral">&quot;ndarray&quot;</span>]:</div>
<div class="line"><span class="lineno">  756</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    Return an ndarray if the given object is implicitly convertible to ndarray,</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    and numpy is already imported, otherwise None.</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  760</span>    <span class="keyword">import</span> sys</div>
<div class="line"><span class="lineno">  761</span> </div>
<div class="line"><span class="lineno">  762</span>    np: Any = sys.modules.get(<span class="stringliteral">&quot;numpy&quot;</span>)</div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">if</span> np <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  764</span>        <span class="comment"># avoid infinite recursion on numpy scalars, which have __array__</span></div>
<div class="line"><span class="lineno">  765</span>        <span class="keywordflow">if</span> np.isscalar(obj):</div>
<div class="line"><span class="lineno">  766</span>            <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  767</span>        <span class="keywordflow">elif</span> isinstance(obj, np.ndarray):</div>
<div class="line"><span class="lineno">  768</span>            <span class="keywordflow">return</span> obj</div>
<div class="line"><span class="lineno">  769</span>        <span class="keywordflow">elif</span> hasattr(obj, <span class="stringliteral">&quot;__array__&quot;</span>) <span class="keywordflow">or</span> hasattr(<span class="stringliteral">&quot;obj&quot;</span>, <span class="stringliteral">&quot;__array_interface__&quot;</span>):</div>
<div class="line"><span class="lineno">  770</span>            <span class="keywordflow">return</span> np.asarray(obj)</div>
<div class="line"><span class="lineno">  771</span>    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  772</span> </div>
<div class="line"><span class="lineno">  773</span> </div>
<div class="line"><span class="lineno">  774</span><span class="comment"># builtin pytest.raises helper</span></div>
<div class="line"><span class="lineno">  775</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5e879cf2c61d0254c5920304eb47a19" name="ab5e879cf2c61d0254c5920304eb47a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e879cf2c61d0254c5920304eb47a19">&#9670;&#160;</a></span>_compare_approx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> List[str] _pytest.python_api._compare_approx </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>full_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Tuple[str, str, str]]&#160;</td>
          <td class="paramname"><em>message_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[object]&#160;</td>
          <td class="paramname"><em>different_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_abs_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_rel_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   50</span>) -&gt; List[str]:</div>
<div class="line"><span class="lineno">   51</span>    message_list = list(message_data)</div>
<div class="line"><span class="lineno">   52</span>    message_list.insert(0, (<span class="stringliteral">&quot;Index&quot;</span>, <span class="stringliteral">&quot;Obtained&quot;</span>, <span class="stringliteral">&quot;Expected&quot;</span>))</div>
<div class="line"><span class="lineno">   53</span>    max_sizes = [0, 0, 0]</div>
<div class="line"><span class="lineno">   54</span>    <span class="keywordflow">for</span> index, obtained, expected <span class="keywordflow">in</span> message_list:</div>
<div class="line"><span class="lineno">   55</span>        max_sizes[0] = max(max_sizes[0], len(index))</div>
<div class="line"><span class="lineno">   56</span>        max_sizes[1] = max(max_sizes[1], len(obtained))</div>
<div class="line"><span class="lineno">   57</span>        max_sizes[2] = max(max_sizes[2], len(expected))</div>
<div class="line"><span class="lineno">   58</span>    explanation = [</div>
<div class="line"><span class="lineno">   59</span>        f<span class="stringliteral">&quot;comparison failed. Mismatched elements: {len(different_ids)} / {number_of_elements}:&quot;</span>,</div>
<div class="line"><span class="lineno">   60</span>        f<span class="stringliteral">&quot;Max absolute difference: {max_abs_diff}&quot;</span>,</div>
<div class="line"><span class="lineno">   61</span>        f<span class="stringliteral">&quot;Max relative difference: {max_rel_diff}&quot;</span>,</div>
<div class="line"><span class="lineno">   62</span>    ] + [</div>
<div class="line"><span class="lineno">   63</span>        f<span class="stringliteral">&quot;{indexes:&lt;{max_sizes[0]}} | {obtained:&lt;{max_sizes[1]}} | {expected:&lt;{max_sizes[2]}}&quot;</span></div>
<div class="line"><span class="lineno">   64</span>        <span class="keywordflow">for</span> indexes, obtained, expected <span class="keywordflow">in</span> message_list</div>
<div class="line"><span class="lineno">   65</span>    ]</div>
<div class="line"><span class="lineno">   66</span>    <span class="keywordflow">return</span> explanation</div>
<div class="line"><span class="lineno">   67</span> </div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span><span class="comment"># builtin pytest.approx helper</span></div>
<div class="line"><span class="lineno">   70</span> </div>
<div class="line"><span class="lineno">   71</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8360978cd078ead51dfdc2ab97bf060f" name="a8360978cd078ead51dfdc2ab97bf060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8360978cd078ead51dfdc2ab97bf060f">&#9670;&#160;</a></span>_is_numpy_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.python_api._is_numpy_array </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return true if the given object is implicitly convertible to ndarray,
and numpy is already imported.
</pre> <div class="fragment"><div class="line"><span class="lineno">  747</span><span class="keyword">def </span>_is_numpy_array(obj: object) -&gt; bool:</div>
<div class="line"><span class="lineno">  748</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    Return true if the given object is implicitly convertible to ndarray,</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    and numpy is already imported.</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  752</span>    <span class="keywordflow">return</span> _as_numpy_array(obj) <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  753</span> </div>
<div class="line"><span class="lineno">  754</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3652289948722b65f579a2e5218c59d" name="ae3652289948722b65f579a2e5218c59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3652289948722b65f579a2e5218c59d">&#9670;&#160;</a></span>_non_numeric_type_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> TypeError _pytest.python_api._non_numeric_type_error </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str]&#160;</td>
          <td class="paramname"><em>at</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   34</span><span class="keyword">def </span>_non_numeric_type_error(value, at: Optional[str]) -&gt; TypeError:</div>
<div class="line"><span class="lineno">   35</span>    at_str = f<span class="stringliteral">&quot; at {at}&quot;</span> <span class="keywordflow">if</span> at <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">   36</span>    <span class="keywordflow">return</span> TypeError(</div>
<div class="line"><span class="lineno">   37</span>        <span class="stringliteral">&quot;cannot make approximate comparisons to non-numeric values: {!r} {}&quot;</span>.format(</div>
<div class="line"><span class="lineno">   38</span>            value, at_str</div>
<div class="line"><span class="lineno">   39</span>        )</div>
<div class="line"><span class="lineno">   40</span>    )</div>
<div class="line"><span class="lineno">   41</span> </div>
<div class="line"><span class="lineno">   42</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a057fdd40ceeee1c6f700c6bb84eba771" name="a057fdd40ceeee1c6f700c6bb84eba771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057fdd40ceeee1c6f700c6bb84eba771">&#9670;&#160;</a></span>_recursive_sequence_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.python_api._recursive_sequence_map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Recursively map a function over a sequence of arbitrary depth</pre> <div class="fragment"><div class="line"><span class="lineno">  136</span><span class="keyword">def </span>_recursive_sequence_map(f, x):</div>
<div class="line"><span class="lineno">  137</span>    <span class="stringliteral">&quot;&quot;&quot;Recursively map a function over a sequence of arbitrary depth&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  138</span>    <span class="keywordflow">if</span> isinstance(x, (list, tuple)):</div>
<div class="line"><span class="lineno">  139</span>        seq_type = type(x)</div>
<div class="line"><span class="lineno">  140</span>        <span class="keywordflow">return</span> seq_type(_recursive_sequence_map(f, xi) <span class="keywordflow">for</span> xi <span class="keywordflow">in</span> x)</div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  142</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(x)</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_af01a903df7bdb7a494f5827e45bf3a2a"><div class="ttname"><a href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a></div><div class="ttdeci">void int int int int npy_complex64 int int npy_complex64 float float npy_complex64 npy_complex64 * f</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:262</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ac6917455bfd8a96e54d4173a95fdc0" name="a3ac6917455bfd8a96e54d4173a95fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac6917455bfd8a96e54d4173a95fdc0">&#9670;&#160;</a></span>approx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="class__pytest_1_1python__api_1_1_approx_base.html">ApproxBase</a> _pytest.python_api.approx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>abs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>nan_ok</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assert that two numbers (or two ordered sequences of numbers) are equal to each other
within some tolerance.

Due to the :doc:`python:tutorial/floatingpoint`, numbers that we
would intuitively expect to be equal are not always so::

    &gt;&gt;&gt; 0.1 + 0.2 == 0.3
    False

This problem is commonly encountered when writing tests, e.g. when making
sure that floating-point values are what you expect them to be.  One way to
deal with this problem is to assert that two floating-point numbers are
equal to within some appropriate tolerance::

    &gt;&gt;&gt; abs((0.1 + 0.2) - 0.3) &lt; 1e-6
    True

However, comparisons like this are tedious to write and difficult to
understand.  Furthermore, absolute comparisons like the one above are
usually discouraged because there's no tolerance that works well for all
situations.  ``1e-6`` is good for numbers around ``1``, but too small for
very big numbers and too big for very small ones.  It's better to express
the tolerance as a fraction of the expected value, but relative comparisons
like that are even more difficult to write correctly and concisely.

The ``approx`` class performs floating-point comparisons using a syntax
that's as intuitive as possible::

    &gt;&gt;&gt; from pytest import approx
    &gt;&gt;&gt; 0.1 + 0.2 == approx(0.3)
    True

The same syntax also works for ordered sequences of numbers::

    &gt;&gt;&gt; (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
    True

``numpy`` arrays::

    &gt;&gt;&gt; import numpy as np                                                          # doctest: +SKIP
    &gt;&gt;&gt; np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP
    True

And for a ``numpy`` array against a scalar::

    &gt;&gt;&gt; import numpy as np                                         # doctest: +SKIP
    &gt;&gt;&gt; np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP
    True

Only ordered sequences are supported, because ``approx`` needs
to infer the relative position of the sequences without ambiguity. This means
``sets`` and other unordered sequences are not supported.

Finally, dictionary *values* can also be compared::

    &gt;&gt;&gt; {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
    True

The comparison will be true if both mappings have the same keys and their
respective values match the expected tolerances.

**Tolerances**

By default, ``approx`` considers numbers within a relative tolerance of
``1e-6`` (i.e. one part in a million) of its expected value to be equal.
This treatment would lead to surprising results if the expected value was
``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.
To handle this case less surprisingly, ``approx`` also considers numbers
within an absolute tolerance of ``1e-12`` of its expected value to be
equal.  Infinity and NaN are special cases.  Infinity is only considered
equal to itself, regardless of the relative tolerance.  NaN is not
considered equal to anything by default, but you can make it be equal to
itself by setting the ``nan_ok`` argument to True.  (This is meant to
facilitate comparing arrays that use NaN to mean "no data".)

Both the relative and absolute tolerances can be changed by passing
arguments to the ``approx`` constructor::

    &gt;&gt;&gt; 1.0001 == approx(1)
    False
    &gt;&gt;&gt; 1.0001 == approx(1, rel=1e-3)
    True
    &gt;&gt;&gt; 1.0001 == approx(1, abs=1e-3)
    True

If you specify ``abs`` but not ``rel``, the comparison will not consider
the relative tolerance at all.  In other words, two numbers that are within
the default relative tolerance of ``1e-6`` will still be considered unequal
if they exceed the specified absolute tolerance.  If you specify both
``abs`` and ``rel``, the numbers will be considered equal if either
tolerance is met::

    &gt;&gt;&gt; 1 + 1e-8 == approx(1)
    True
    &gt;&gt;&gt; 1 + 1e-8 == approx(1, abs=1e-12)
    False
    &gt;&gt;&gt; 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
    True

You can also use ``approx`` to compare nonnumeric types, or dicts and
sequences containing nonnumeric types, in which case it falls back to
strict equality. This can be useful for comparing dicts and sequences that
can contain optional values::

    &gt;&gt;&gt; {"required": 1.0000005, "optional": None} == approx({"required": 1, "optional": None})
    True
    &gt;&gt;&gt; [None, 1.0000005] == approx([None,1])
    True
    &gt;&gt;&gt; ["foo", 1.0000005] == approx([None,1])
    False

If you're thinking about using ``approx``, then you might want to know how
it compares to other good ways of comparing floating-point numbers.  All of
these algorithms are based on relative and absolute tolerances and should
agree for the most part, but they do have meaningful differences:

- ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative
  tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute
  tolerance is met.  Because the relative tolerance is calculated w.r.t.
  both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor
  ``b`` is a "reference value").  You have to specify an absolute tolerance
  if you want to compare to ``0.0`` because there is no tolerance by
  default.  More information: :py:func:`math.isclose`.

- ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference
  between ``a`` and ``b`` is less that the sum of the relative tolerance
  w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance
  is only calculated w.r.t. ``b``, this test is asymmetric and you can
  think of ``b`` as the reference value.  Support for comparing sequences
  is provided by :py:func:`numpy.allclose`.  More information:
  :std:doc:`numpy:reference/generated/numpy.isclose`.

- ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``
  are within an absolute tolerance of ``1e-7``.  No relative tolerance is
  considered , so this function is not appropriate for very large or very
  small numbers.  Also, it's only available in subclasses of ``unittest.TestCase``
  and it's ugly because it doesn't follow PEP8.  More information:
  :py:meth:`unittest.TestCase.assertAlmostEqual`.

- ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative
  tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.
  Because the relative tolerance is only calculated w.r.t. ``b``, this test
  is asymmetric and you can think of ``b`` as the reference value.  In the
  special case that you explicitly specify an absolute tolerance but not a
  relative tolerance, only the absolute tolerance is considered.

.. note::

    ``approx`` can handle numpy arrays, but we recommend the
    specialised test helpers in :std:doc:`numpy:reference/routines.testing`
    if you need support for comparisons, NaNs, or ULP-based tolerances.

    To match strings using regex, you can use
    `Matches &lt;https://github.com/asottile/re-assert#re_assertmatchespattern-str-args-kwargs&gt;`_
    from the
    `re_assert package &lt;https://github.com/asottile/re-assert&gt;`_.

.. warning::

   .. versionchanged:: 3.2

   In order to avoid inconsistent behavior, :py:exc:`TypeError` is
   raised for ``&gt;``, ``&gt;=``, ``&lt;`` and ``&lt;=`` comparisons.
   The example below illustrates the problem::

       assert approx(0.1) &gt; 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)
       assert 0.1 + 1e-10 &gt; approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)

   In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``
   to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to
   comparison. This is because the call hierarchy of rich comparisons
   follows a fixed behavior. More information: :py:meth:`object.__ge__`

.. versionchanged:: 3.7.1
   ``approx`` raises ``TypeError`` when it encounters a dict value or
   sequence element of nonnumeric type.

.. versionchanged:: 6.1.0
   ``approx`` falls back to strict equality for nonnumeric types instead
   of raising ``TypeError``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  520</span><span class="keyword">def </span>approx(expected, rel=None, abs=None, nan_ok: bool = <span class="keyword">False</span>) -&gt; ApproxBase:</div>
<div class="line"><span class="lineno">  521</span>    <span class="stringliteral">&quot;&quot;&quot;Assert that two numbers (or two ordered sequences of numbers) are equal to each other</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    within some tolerance.</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    Due to the :doc:`python:tutorial/floatingpoint`, numbers that we</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    would intuitively expect to be equal are not always so::</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        &gt;&gt;&gt; 0.1 + 0.2 == 0.3</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    This problem is commonly encountered when writing tests, e.g. when making</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    sure that floating-point values are what you expect them to be.  One way to</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    deal with this problem is to assert that two floating-point numbers are</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    equal to within some appropriate tolerance::</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        &gt;&gt;&gt; abs((0.1 + 0.2) - 0.3) &lt; 1e-6</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    However, comparisons like this are tedious to write and difficult to</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    understand.  Furthermore, absolute comparisons like the one above are</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    usually discouraged because there&#39;s no tolerance that works well for all</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    situations.  ``1e-6`` is good for numbers around ``1``, but too small for</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    very big numbers and too big for very small ones.  It&#39;s better to express</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    the tolerance as a fraction of the expected value, but relative comparisons</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    like that are even more difficult to write correctly and concisely.</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    The ``approx`` class performs floating-point comparisons using a syntax</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    that&#39;s as intuitive as possible::</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        &gt;&gt;&gt; from pytest import approx</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        &gt;&gt;&gt; 0.1 + 0.2 == approx(0.3)</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    The same syntax also works for ordered sequences of numbers::</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">        &gt;&gt;&gt; (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    ``numpy`` arrays::</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">        &gt;&gt;&gt; import numpy as np                                                          # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">        &gt;&gt;&gt; np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    And for a ``numpy`` array against a scalar::</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">        &gt;&gt;&gt; import numpy as np                                         # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        &gt;&gt;&gt; np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    Only ordered sequences are supported, because ``approx`` needs</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    to infer the relative position of the sequences without ambiguity. This means</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    ``sets`` and other unordered sequences are not supported.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    Finally, dictionary *values* can also be compared::</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        &gt;&gt;&gt; {&#39;a&#39;: 0.1 + 0.2, &#39;b&#39;: 0.2 + 0.4} == approx({&#39;a&#39;: 0.3, &#39;b&#39;: 0.6})</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    The comparison will be true if both mappings have the same keys and their</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    respective values match the expected tolerances.</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    **Tolerances**</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    By default, ``approx`` considers numbers within a relative tolerance of</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    ``1e-6`` (i.e. one part in a million) of its expected value to be equal.</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    This treatment would lead to surprising results if the expected value was</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    To handle this case less surprisingly, ``approx`` also considers numbers</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    within an absolute tolerance of ``1e-12`` of its expected value to be</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    equal.  Infinity and NaN are special cases.  Infinity is only considered</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    equal to itself, regardless of the relative tolerance.  NaN is not</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    considered equal to anything by default, but you can make it be equal to</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    itself by setting the ``nan_ok`` argument to True.  (This is meant to</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    facilitate comparing arrays that use NaN to mean &quot;no data&quot;.)</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    Both the relative and absolute tolerances can be changed by passing</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    arguments to the ``approx`` constructor::</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        &gt;&gt;&gt; 1.0001 == approx(1)</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        &gt;&gt;&gt; 1.0001 == approx(1, rel=1e-3)</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">        &gt;&gt;&gt; 1.0001 == approx(1, abs=1e-3)</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    If you specify ``abs`` but not ``rel``, the comparison will not consider</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    the relative tolerance at all.  In other words, two numbers that are within</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    the default relative tolerance of ``1e-6`` will still be considered unequal</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    if they exceed the specified absolute tolerance.  If you specify both</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    ``abs`` and ``rel``, the numbers will be considered equal if either</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    tolerance is met::</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">        &gt;&gt;&gt; 1 + 1e-8 == approx(1)</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        &gt;&gt;&gt; 1 + 1e-8 == approx(1, abs=1e-12)</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">        &gt;&gt;&gt; 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    You can also use ``approx`` to compare nonnumeric types, or dicts and</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    sequences containing nonnumeric types, in which case it falls back to</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    strict equality. This can be useful for comparing dicts and sequences that</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    can contain optional values::</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        &gt;&gt;&gt; {&quot;required&quot;: 1.0000005, &quot;optional&quot;: None} == approx({&quot;required&quot;: 1, &quot;optional&quot;: None})</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">        &gt;&gt;&gt; [None, 1.0000005] == approx([None,1])</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">        &gt;&gt;&gt; [&quot;foo&quot;, 1.0000005] == approx([None,1])</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    If you&#39;re thinking about using ``approx``, then you might want to know how</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    it compares to other good ways of comparing floating-point numbers.  All of</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    these algorithms are based on relative and absolute tolerances and should</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    agree for the most part, but they do have meaningful differences:</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">      tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">      tolerance is met.  Because the relative tolerance is calculated w.r.t.</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">      both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">      ``b`` is a &quot;reference value&quot;).  You have to specify an absolute tolerance</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">      if you want to compare to ``0.0`` because there is no tolerance by</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">      default.  More information: :py:func:`math.isclose`.</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">      between ``a`` and ``b`` is less that the sum of the relative tolerance</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">      w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">      is only calculated w.r.t. ``b``, this test is asymmetric and you can</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">      think of ``b`` as the reference value.  Support for comparing sequences</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">      is provided by :py:func:`numpy.allclose`.  More information:</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">      :std:doc:`numpy:reference/generated/numpy.isclose`.</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">      are within an absolute tolerance of ``1e-7``.  No relative tolerance is</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">      considered , so this function is not appropriate for very large or very</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">      small numbers.  Also, it&#39;s only available in subclasses of ``unittest.TestCase``</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">      and it&#39;s ugly because it doesn&#39;t follow PEP8.  More information:</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">      :py:meth:`unittest.TestCase.assertAlmostEqual`.</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">      tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">      Because the relative tolerance is only calculated w.r.t. ``b``, this test</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">      is asymmetric and you can think of ``b`` as the reference value.  In the</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">      special case that you explicitly specify an absolute tolerance but not a</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">      relative tolerance, only the absolute tolerance is considered.</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    .. note::</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">        ``approx`` can handle numpy arrays, but we recommend the</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        specialised test helpers in :std:doc:`numpy:reference/routines.testing`</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        if you need support for comparisons, NaNs, or ULP-based tolerances.</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">        To match strings using regex, you can use</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">        `Matches &lt;https://github.com/asottile/re-assert#re_assertmatchespattern-str-args-kwargs&gt;`_</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">        from the</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">        `re_assert package &lt;https://github.com/asottile/re-assert&gt;`_.</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    .. warning::</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">       .. versionchanged:: 3.2</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">       In order to avoid inconsistent behavior, :py:exc:`TypeError` is</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">       raised for ``&gt;``, ``&gt;=``, ``&lt;`` and ``&lt;=`` comparisons.</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">       The example below illustrates the problem::</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">           assert approx(0.1) &gt; 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">           assert 0.1 + 1e-10 &gt; approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">       In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">       to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">       comparison. This is because the call hierarchy of rich comparisons</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">       follows a fixed behavior. More information: :py:meth:`object.__ge__`</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    .. versionchanged:: 3.7.1</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">       ``approx`` raises ``TypeError`` when it encounters a dict value or</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">       sequence element of nonnumeric type.</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    .. versionchanged:: 6.1.0</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">       ``approx`` falls back to strict equality for nonnumeric types instead</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">       of raising ``TypeError``.</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <span class="comment"># Delegate the comparison to a class that knows how to deal with the type</span></div>
<div class="line"><span class="lineno">  704</span>    <span class="comment"># of the expected value (e.g. int, float, list, dict, numpy.array, etc).</span></div>
<div class="line"><span class="lineno">  705</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  706</span>    <span class="comment"># The primary responsibility of these classes is to implement ``__eq__()``</span></div>
<div class="line"><span class="lineno">  707</span>    <span class="comment"># and ``__repr__()``.  The former is used to actually check if some</span></div>
<div class="line"><span class="lineno">  708</span>    <span class="comment"># &quot;actual&quot; value is equivalent to the given expected value within the</span></div>
<div class="line"><span class="lineno">  709</span>    <span class="comment"># allowed tolerance.  The latter is used to show the user the expected</span></div>
<div class="line"><span class="lineno">  710</span>    <span class="comment"># value and tolerance, in the case that a test failed.</span></div>
<div class="line"><span class="lineno">  711</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  712</span>    <span class="comment"># The actual logic for making approximate comparisons can be found in</span></div>
<div class="line"><span class="lineno">  713</span>    <span class="comment"># ApproxScalar, which is used to compare individual numbers.  All of the</span></div>
<div class="line"><span class="lineno">  714</span>    <span class="comment"># other Approx classes eventually delegate to this class.  The ApproxBase</span></div>
<div class="line"><span class="lineno">  715</span>    <span class="comment"># class provides some convenient methods and overloads, but isn&#39;t really</span></div>
<div class="line"><span class="lineno">  716</span>    <span class="comment"># essential.</span></div>
<div class="line"><span class="lineno">  717</span> </div>
<div class="line"><span class="lineno">  718</span>    __tracebackhide__ = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  719</span> </div>
<div class="line"><span class="lineno">  720</span>    <span class="keywordflow">if</span> isinstance(expected, Decimal):</div>
<div class="line"><span class="lineno">  721</span>        cls: Type[ApproxBase] = ApproxDecimal</div>
<div class="line"><span class="lineno">  722</span>    <span class="keywordflow">elif</span> isinstance(expected, Mapping):</div>
<div class="line"><span class="lineno">  723</span>        cls = ApproxMapping</div>
<div class="line"><span class="lineno">  724</span>    <span class="keywordflow">elif</span> _is_numpy_array(expected):</div>
<div class="line"><span class="lineno">  725</span>        expected = _as_numpy_array(expected)</div>
<div class="line"><span class="lineno">  726</span>        cls = ApproxNumpy</div>
<div class="line"><span class="lineno">  727</span>    <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno">  728</span>        hasattr(expected, <span class="stringliteral">&quot;__getitem__&quot;</span>)</div>
<div class="line"><span class="lineno">  729</span>        <span class="keywordflow">and</span> isinstance(expected, Sized)</div>
<div class="line"><span class="lineno">  730</span>        <span class="comment"># Type ignored because the error is wrong -- not unreachable.</span></div>
<div class="line"><span class="lineno">  731</span>        <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(expected, STRING_TYPES)  <span class="comment"># type: ignore[unreachable]</span></div>
<div class="line"><span class="lineno">  732</span>    ):</div>
<div class="line"><span class="lineno">  733</span>        cls = ApproxSequenceLike</div>
<div class="line"><span class="lineno">  734</span>    <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno">  735</span>        isinstance(expected, Collection)</div>
<div class="line"><span class="lineno">  736</span>        <span class="comment"># Type ignored because the error is wrong -- not unreachable.</span></div>
<div class="line"><span class="lineno">  737</span>        <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(expected, STRING_TYPES)  <span class="comment"># type: ignore[unreachable]</span></div>
<div class="line"><span class="lineno">  738</span>    ):</div>
<div class="line"><span class="lineno">  739</span>        msg = f<span class="stringliteral">&quot;pytest.approx() only supports ordered sequences, but got: {repr(expected)}&quot;</span></div>
<div class="line"><span class="lineno">  740</span>        <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno">  741</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  742</span>        cls = ApproxScalar</div>
<div class="line"><span class="lineno">  743</span> </div>
<div class="line"><span class="lineno">  744</span>    <span class="keywordflow">return</span> cls(expected, rel, abs, nan_ok)</div>
<div class="line"><span class="lineno">  745</span> </div>
<div class="line"><span class="lineno">  746</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c153cc71cc69c88b8598d01d536ce41" name="a5c153cc71cc69c88b8598d01d536ce41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c153cc71cc69c88b8598d01d536ce41">&#9670;&#160;</a></span>raises() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[&quot;RaisesContext[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>]&quot;, _pytest._code.ExceptionInfo[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>]] _pytest.python_api.raises </td>
          <td>(</td>
          <td class="paramtype">Union[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], Tuple[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], ...]]&#160;</td>
          <td class="paramname"><em>expected_exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Any&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assert that a code block/function call raises an exception.

:param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:
    The excpected exception type, or a tuple if one of multiple possible
    exception types are excepted.
:kwparam str | typing.Pattern[str] | None match:
    If specified, a string containing a regular expression,
    or a regular expression object, that is tested against the string
    representation of the exception using :func:`re.search`.

    To match a literal string that may contain :ref:`special characters
    &lt;re-syntax&gt;`, the pattern can first be escaped with :func:`re.escape`.

    (This is only used when :py:func:`pytest.raises` is used as a context manager,
    and passed through to the function otherwise.
    When using :py:func:`pytest.raises` as a function, you can use:
    ``pytest.raises(Exc, func, match="passed on").match("my pattern")``.)

.. currentmodule:: _pytest._code

Use ``pytest.raises`` as a context manager, which will capture the exception of the given
type::

    &gt;&gt;&gt; import pytest
    &gt;&gt;&gt; with pytest.raises(ZeroDivisionError):
    ...    1/0

If the code block does not raise the expected exception (``ZeroDivisionError`` in the example
above), or no exception at all, the check will fail instead.

You can also use the keyword argument ``match`` to assert that the
exception matches a text or regex::

    &gt;&gt;&gt; with pytest.raises(ValueError, match='must be 0 or None'):
    ...     raise ValueError("value must be 0 or None")

    &gt;&gt;&gt; with pytest.raises(ValueError, match=r'must be \d+$'):
    ...     raise ValueError("value must be 42")

The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the
details of the captured exception::

    &gt;&gt;&gt; with pytest.raises(ValueError) as exc_info:
    ...     raise ValueError("value must be 42")
    &gt;&gt;&gt; assert exc_info.type is ValueError
    &gt;&gt;&gt; assert exc_info.value.args[0] == "value must be 42"

.. note::

   When using ``pytest.raises`` as a context manager, it's worthwhile to
   note that normal context manager rules apply and that the exception
   raised *must* be the final line in the scope of the context manager.
   Lines of code after that, within the scope of the context manager will
   not be executed. For example::

       &gt;&gt;&gt; value = 15
       &gt;&gt;&gt; with pytest.raises(ValueError) as exc_info:
       ...     if value &gt; 10:
       ...         raise ValueError("value must be &lt;= 10")
       ...     assert exc_info.type is ValueError  # this will not execute

   Instead, the following approach must be taken (note the difference in
   scope)::

       &gt;&gt;&gt; with pytest.raises(ValueError) as exc_info:
       ...     if value &gt; 10:
       ...         raise ValueError("value must be &lt;= 10")
       ...
       &gt;&gt;&gt; assert exc_info.type is ValueError

**Using with** ``pytest.mark.parametrize``

When using :ref:`pytest.mark.parametrize ref`
it is possible to parametrize tests such that
some runs raise an exception and others do not.

See :ref:`parametrizing_conditional_raising` for an example.

**Legacy form**

It is possible to specify a callable by passing a to-be-called lambda::

    &gt;&gt;&gt; raises(ZeroDivisionError, lambda: 1/0)
    &lt;ExceptionInfo ...&gt;

or you can specify an arbitrary callable with arguments::

    &gt;&gt;&gt; def f(x): return 1/x
    ...
    &gt;&gt;&gt; raises(ZeroDivisionError, f, 0)
    &lt;ExceptionInfo ...&gt;
    &gt;&gt;&gt; raises(ZeroDivisionError, f, x=0)
    &lt;ExceptionInfo ...&gt;

The form above is fully supported but discouraged for new code because the
context manager form is regarded as more readable and less error-prone.

.. note::
    Similar to caught exception objects in Python, explicitly clearing
    local references to returned ``ExceptionInfo`` objects can
    help the Python interpreter speed up its garbage collection.

    Clearing those references breaks a reference cycle
    (``ExceptionInfo`` --&gt; caught exception --&gt; frame stack raising
    the exception --&gt; current frame stack --&gt; local variables --&gt;
    ``ExceptionInfo``) which makes Python keep all objects referenced
    from that cycle (including all local variables in the current
    frame) alive until the next cyclic garbage collection run.
    More detailed information can be found in the official Python
    documentation for :ref:`the try statement &lt;python:try&gt;`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  800</span>) -&gt; Union[<span class="stringliteral">&quot;RaisesContext[E]&quot;</span>, <a class="code hl_class" href="class__pytest_1_1__code_1_1code_1_1_exception_info.html">_pytest._code.ExceptionInfo</a>[E]]:</div>
<div class="line"><span class="lineno">  801</span>    <span class="stringliteral">r&quot;&quot;&quot;Assert that a code block/function call raises an exception.</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    :param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        The excpected exception type, or a tuple if one of multiple possible</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        exception types are excepted.</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    :kwparam str | typing.Pattern[str] | None match:</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        If specified, a string containing a regular expression,</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        or a regular expression object, that is tested against the string</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        representation of the exception using :func:`re.search`.</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        To match a literal string that may contain :ref:`special characters</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">        &lt;re-syntax&gt;`, the pattern can first be escaped with :func:`re.escape`.</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">        (This is only used when :py:func:`pytest.raises` is used as a context manager,</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">        and passed through to the function otherwise.</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">        When using :py:func:`pytest.raises` as a function, you can use:</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        ``pytest.raises(Exc, func, match=&quot;passed on&quot;).match(&quot;my pattern&quot;)``.)</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    .. currentmodule:: _pytest._code</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    Use ``pytest.raises`` as a context manager, which will capture the exception of the given</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    type::</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        &gt;&gt;&gt; import pytest</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">        &gt;&gt;&gt; with pytest.raises(ZeroDivisionError):</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        ...    1/0</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    above), or no exception at all, the check will fail instead.</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    You can also use the keyword argument ``match`` to assert that the</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    exception matches a text or regex::</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        &gt;&gt;&gt; with pytest.raises(ValueError, match=&#39;must be 0 or None&#39;):</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">        ...     raise ValueError(&quot;value must be 0 or None&quot;)</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">        &gt;&gt;&gt; with pytest.raises(ValueError, match=r&#39;must be \d+$&#39;):</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">        ...     raise ValueError(&quot;value must be 42&quot;)</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    details of the captured exception::</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        &gt;&gt;&gt; with pytest.raises(ValueError) as exc_info:</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        ...     raise ValueError(&quot;value must be 42&quot;)</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        &gt;&gt;&gt; assert exc_info.type is ValueError</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">        &gt;&gt;&gt; assert exc_info.value.args[0] == &quot;value must be 42&quot;</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    .. note::</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">       When using ``pytest.raises`` as a context manager, it&#39;s worthwhile to</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">       note that normal context manager rules apply and that the exception</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">       raised *must* be the final line in the scope of the context manager.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">       Lines of code after that, within the scope of the context manager will</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">       not be executed. For example::</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">           &gt;&gt;&gt; value = 15</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">           &gt;&gt;&gt; with pytest.raises(ValueError) as exc_info:</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">           ...     if value &gt; 10:</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">           ...         raise ValueError(&quot;value must be &lt;= 10&quot;)</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">           ...     assert exc_info.type is ValueError  # this will not execute</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">       Instead, the following approach must be taken (note the difference in</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">       scope)::</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">           &gt;&gt;&gt; with pytest.raises(ValueError) as exc_info:</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">           ...     if value &gt; 10:</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">           ...         raise ValueError(&quot;value must be &lt;= 10&quot;)</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">           ...</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">           &gt;&gt;&gt; assert exc_info.type is ValueError</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    **Using with** ``pytest.mark.parametrize``</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    When using :ref:`pytest.mark.parametrize ref`</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    it is possible to parametrize tests such that</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    some runs raise an exception and others do not.</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    See :ref:`parametrizing_conditional_raising` for an example.</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    **Legacy form**</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    It is possible to specify a callable by passing a to-be-called lambda::</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">        &gt;&gt;&gt; raises(ZeroDivisionError, lambda: 1/0)</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">        &lt;ExceptionInfo ...&gt;</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    or you can specify an arbitrary callable with arguments::</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        &gt;&gt;&gt; def f(x): return 1/x</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">        &gt;&gt;&gt; raises(ZeroDivisionError, f, 0)</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">        &lt;ExceptionInfo ...&gt;</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">        &gt;&gt;&gt; raises(ZeroDivisionError, f, x=0)</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">        &lt;ExceptionInfo ...&gt;</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    The form above is fully supported but discouraged for new code because the</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    context manager form is regarded as more readable and less error-prone.</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    .. note::</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">        Similar to caught exception objects in Python, explicitly clearing</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">        local references to returned ``ExceptionInfo`` objects can</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">        help the Python interpreter speed up its garbage collection.</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">        Clearing those references breaks a reference cycle</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">        (``ExceptionInfo`` --&gt; caught exception --&gt; frame stack raising</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">        the exception --&gt; current frame stack --&gt; local variables --&gt;</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">        ``ExceptionInfo``) which makes Python keep all objects referenced</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        from that cycle (including all local variables in the current</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">        frame) alive until the next cyclic garbage collection run.</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        More detailed information can be found in the official Python</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        documentation for :ref:`the try statement &lt;python:try&gt;`.</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  912</span>    __tracebackhide__ = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  913</span> </div>
<div class="line"><span class="lineno">  914</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> expected_exception:</div>
<div class="line"><span class="lineno">  915</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  916</span>            f<span class="stringliteral">&quot;Expected an exception type or a tuple of exception types, but got `{expected_exception!r}`. &quot;</span></div>
<div class="line"><span class="lineno">  917</span>            f<span class="stringliteral">&quot;Raising exceptions is already understood as failing the test, so you don&#39;t need &quot;</span></div>
<div class="line"><span class="lineno">  918</span>            f<span class="stringliteral">&quot;any special code to say &#39;this should never raise an exception&#39;.&quot;</span></div>
<div class="line"><span class="lineno">  919</span>        )</div>
<div class="line"><span class="lineno">  920</span>    <span class="keywordflow">if</span> isinstance(expected_exception, type):</div>
<div class="line"><span class="lineno">  921</span>        excepted_exceptions: Tuple[Type[E], ...] = (expected_exception,)</div>
<div class="line"><span class="lineno">  922</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  923</span>        excepted_exceptions = expected_exception</div>
<div class="line"><span class="lineno">  924</span>    <span class="keywordflow">for</span> exc <span class="keywordflow">in</span> excepted_exceptions:</div>
<div class="line"><span class="lineno">  925</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(exc, type) <span class="keywordflow">or</span> <span class="keywordflow">not</span> issubclass(exc, BaseException):</div>
<div class="line"><span class="lineno">  926</span>            msg = <span class="stringliteral">&quot;expected exception must be a BaseException type, not {}&quot;</span>  <span class="comment"># type: ignore[unreachable]</span></div>
<div class="line"><span class="lineno">  927</span>            not_a = exc.__name__ <span class="keywordflow">if</span> isinstance(exc, type) <span class="keywordflow">else</span> type(exc).__name__</div>
<div class="line"><span class="lineno">  928</span>            <span class="keywordflow">raise</span> TypeError(msg.format(not_a))</div>
<div class="line"><span class="lineno">  929</span> </div>
<div class="line"><span class="lineno">  930</span>    message = f<span class="stringliteral">&quot;DID NOT RAISE {expected_exception}&quot;</span></div>
<div class="line"><span class="lineno">  931</span> </div>
<div class="line"><span class="lineno">  932</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> args:</div>
<div class="line"><span class="lineno">  933</span>        match: Optional[Union[str, Pattern[str]]] = kwargs.pop(<span class="stringliteral">&quot;match&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  934</span>        <span class="keywordflow">if</span> kwargs:</div>
<div class="line"><span class="lineno">  935</span>            msg = <span class="stringliteral">&quot;Unexpected keyword arguments passed to pytest.raises: &quot;</span></div>
<div class="line"><span class="lineno">  936</span>            msg += <span class="stringliteral">&quot;, &quot;</span>.join(sorted(kwargs))</div>
<div class="line"><span class="lineno">  937</span>            msg += <span class="stringliteral">&quot;\nUse context-manager form instead?&quot;</span></div>
<div class="line"><span class="lineno">  938</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno">  939</span>        <span class="keywordflow">return</span> RaisesContext(expected_exception, message, match)</div>
<div class="line"><span class="lineno">  940</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  941</span>        func = args[0]</div>
<div class="line"><span class="lineno">  942</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(func):</div>
<div class="line"><span class="lineno">  943</span>            <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;{func!r} object (type: {type(func)}) must be callable&quot;</span>)</div>
<div class="line"><span class="lineno">  944</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  945</span>            <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(*args[1:], **kwargs)</div>
<div class="line"><span class="lineno">  946</span>        <span class="keywordflow">except</span> expected_exception <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  947</span>            <span class="comment"># We just caught the exception - there is a traceback.</span></div>
<div class="line"><span class="lineno">  948</span>            <span class="keyword">assert</span> e.__traceback__ <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  949</span>            <span class="keywordflow">return</span> _pytest._code.ExceptionInfo.from_exc_info(</div>
<div class="line"><span class="lineno">  950</span>                (type(e), e, e.__traceback__)</div>
<div class="line"><span class="lineno">  951</span>            )</div>
<div class="line"><span class="lineno">  952</span>    fail(message)</div>
<div class="line"><span class="lineno">  953</span> </div>
<div class="line"><span class="lineno">  954</span> </div>
<div class="line"><span class="lineno">  955</span><span class="comment"># This doesn&#39;t work with mypy for now. Use fail.Exception instead.</span></div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
<div class="ttc" id="aclass__pytest_1_1__code_1_1code_1_1_exception_info_html"><div class="ttname"><a href="class__pytest_1_1__code_1_1code_1_1_exception_info.html">_pytest._code.code.ExceptionInfo</a></div><div class="ttdef"><b>Definition</b> code.py:449</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7a5aeee0ba0023b027c2c1fc32ab083" name="ad7a5aeee0ba0023b027c2c1fc32ab083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a5aeee0ba0023b027c2c1fc32ab083">&#9670;&#160;</a></span>raises() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> &quot;RaisesContext[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>]&quot; _pytest.python_api.raises </td>
          <td>(</td>
          <td class="paramtype">Union[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], Tuple[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], ...]]&#160;</td>
          <td class="paramname"><em>expected_exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[Union[str, Pattern[str]]] &#160;</td>
          <td class="paramname"><em>match</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  784</span>) -&gt; <span class="stringliteral">&quot;RaisesContext[E]&quot;</span>:</div>
<div class="line"><span class="lineno">  785</span>    ...</div>
<div class="line"><span class="lineno">  786</span> </div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5b36881bf9cd6d4ffbd08332fb33f4c" name="ab5b36881bf9cd6d4ffbd08332fb33f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b36881bf9cd6d4ffbd08332fb33f4c">&#9670;&#160;</a></span>raises() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="class__pytest_1_1__code_1_1code_1_1_exception_info.html">_pytest._code.ExceptionInfo</a>[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>] _pytest.python_api.raises </td>
          <td>(</td>
          <td class="paramtype">Union[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], Tuple[Type[<a class="el" href="namespace__pytest_1_1python__api.html#a1f5b9d9a73c83e63ee48bf48a2dee8bc">E</a>], ...]]&#160;</td>
          <td class="paramname"><em>expected_exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Any]&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Any&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  794</span>) -&gt; <a class="code hl_class" href="class__pytest_1_1__code_1_1code_1_1_exception_info.html">_pytest._code.ExceptionInfo</a>[E]:</div>
<div class="line"><span class="lineno">  795</span>    ...</div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1f5b9d9a73c83e63ee48bf48a2dee8bc" name="a1f5b9d9a73c83e63ee48bf48a2dee8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5b9d9a73c83e63ee48bf48a2dee8bc">&#9670;&#160;</a></span>E</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.python_api.E = TypeVar(&quot;E&quot;, bound=BaseException)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2886969654e2d5834bbd25a8acd70bfe" name="a2886969654e2d5834bbd25a8acd70bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2886969654e2d5834bbd25a8acd70bfe">&#9670;&#160;</a></span>Exception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.python_api.Exception</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
