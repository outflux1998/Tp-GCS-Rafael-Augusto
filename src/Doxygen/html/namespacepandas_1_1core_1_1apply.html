<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.apply Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1apply.html">apply</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.apply Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_apply.html">Apply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_frame_apply.html">FrameApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_frame_column_apply.html">FrameColumnApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_frame_row_apply.html">FrameRowApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_group_by_apply.html">GroupByApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_n_d_frame_apply.html">NDFrameApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_resampler_window_apply.html">ResamplerWindowApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1apply_1_1_series_apply.html">SeriesApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc6275115a8b6f69239e5f98a2ac12a4" id="r_acc6275115a8b6f69239e5f98a2ac12a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1apply_1_1_frame_apply.html">FrameApply</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#acc6275115a8b6f69239e5f98a2ac12a4">frame_apply</a> (DataFrame obj, AggFuncType <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, Axis axis=0, bool raw=False, str|None result_type=None, args=None, kwargs=None)</td></tr>
<tr class="separator:acc6275115a8b6f69239e5f98a2ac12a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593a7b38eee91f9332eb527c3cad8576" id="r_a593a7b38eee91f9332eb527c3cad8576"><td class="memItemLeft" align="right" valign="top">tuple[bool, AggFuncType|None, list[str]|None, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#a593a7b38eee91f9332eb527c3cad8576">reconstruct_func</a> (AggFuncType|None <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, **kwargs)</td></tr>
<tr class="separator:a593a7b38eee91f9332eb527c3cad8576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72420b66d3d3a68d5785d5238a269aa" id="r_ab72420b66d3d3a68d5785d5238a269aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#ab72420b66d3d3a68d5785d5238a269aa">is_multi_agg_with_relabel</a> (**kwargs)</td></tr>
<tr class="separator:ab72420b66d3d3a68d5785d5238a269aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ed9fb82a317c825e54aac638be9030" id="r_af3ed9fb82a317c825e54aac638be9030"><td class="memItemLeft" align="right" valign="top">tuple[dict, list[str], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#af3ed9fb82a317c825e54aac638be9030">normalize_keyword_aggregation</a> (dict kwargs)</td></tr>
<tr class="separator:af3ed9fb82a317c825e54aac638be9030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad562c053905e8fc7d7073d851e8f308a" id="r_ad562c053905e8fc7d7073d851e8f308a"><td class="memItemLeft" align="right" valign="top">Sequence[tuple[Any, Any]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#ad562c053905e8fc7d7073d851e8f308a">_make_unique_kwarg_list</a> (Sequence[tuple[Any, Any]] seq)</td></tr>
<tr class="separator:ad562c053905e8fc7d7073d851e8f308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572f9f92d9ffff4667bc4bb2f0708cff" id="r_a572f9f92d9ffff4667bc4bb2f0708cff"><td class="memItemLeft" align="right" valign="top">dict[Hashable, Series]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#a572f9f92d9ffff4667bc4bb2f0708cff">relabel_result</a> (DataFrame|Series result, dict[str, list[Callable|str]] <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, Iterable[Hashable] columns, Iterable[int] <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>)</td></tr>
<tr class="separator:a572f9f92d9ffff4667bc4bb2f0708cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7188c8cf8013009da186e4f04e9edfbb" id="r_a7188c8cf8013009da186e4f04e9edfbb"><td class="memItemLeft" align="right" valign="top">Sequence[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#a7188c8cf8013009da186e4f04e9edfbb">_managle_lambda_list</a> (Sequence[Any] aggfuncs)</td></tr>
<tr class="separator:a7188c8cf8013009da186e4f04e9edfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d3b98fd771ce19d1d3cfdae0ab5623" id="r_a92d3b98fd771ce19d1d3cfdae0ab5623"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#a92d3b98fd771ce19d1d3cfdae0ab5623">maybe_mangle_lambdas</a> (Any agg_spec)</td></tr>
<tr class="separator:a92d3b98fd771ce19d1d3cfdae0ab5623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432f2473b653042571d7e8e9bc2ae42a" id="r_a432f2473b653042571d7e8e9bc2ae42a"><td class="memItemLeft" align="right" valign="top">tuple[list[str], list[str|Callable[..., Any]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#a432f2473b653042571d7e8e9bc2ae42a">validate_func_kwargs</a> (dict kwargs)</td></tr>
<tr class="separator:a432f2473b653042571d7e8e9bc2ae42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa116995ff61ef4fed4bd2f7036d6ce42" id="r_aa116995ff61ef4fed4bd2f7036d6ce42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1apply.html#aa116995ff61ef4fed4bd2f7036d6ce42">ResType</a> = Dict[int, Any]</td></tr>
<tr class="separator:aa116995ff61ef4fed4bd2f7036d6ce42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad562c053905e8fc7d7073d851e8f308a" name="ad562c053905e8fc7d7073d851e8f308a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad562c053905e8fc7d7073d851e8f308a">&#9670;&#160;</a></span>_make_unique_kwarg_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Sequence[tuple[Any, Any]] pandas.core.apply._make_unique_kwarg_list </td>
          <td>(</td>
          <td class="paramtype">Sequence[tuple[Any, Any]]
&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Uniquify aggfunc name of the pairs in the order list

Examples:
--------
&gt;&gt;&gt; kwarg_list = [('a', '&lt;lambda&gt;'), ('a', '&lt;lambda&gt;'), ('b', '&lt;lambda&gt;')]
&gt;&gt;&gt; _make_unique_kwarg_list(kwarg_list)
[('a', '&lt;lambda&gt;_0'), ('a', '&lt;lambda&gt;_1'), ('b', '&lt;lambda&gt;')]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1374</span>) -&gt; Sequence[tuple[Any, Any]]:</div>
<div class="line"><span class="lineno"> 1375</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    Uniquify aggfunc name of the pairs in the order list</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">    Examples:</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    &gt;&gt;&gt; kwarg_list = [(&#39;a&#39;, &#39;&lt;lambda&gt;&#39;), (&#39;a&#39;, &#39;&lt;lambda&gt;&#39;), (&#39;b&#39;, &#39;&lt;lambda&gt;&#39;)]</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    &gt;&gt;&gt; _make_unique_kwarg_list(kwarg_list)</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    [(&#39;a&#39;, &#39;&lt;lambda&gt;_0&#39;), (&#39;a&#39;, &#39;&lt;lambda&gt;_1&#39;), (&#39;b&#39;, &#39;&lt;lambda&gt;&#39;)]</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1384</span>    <span class="keywordflow">return</span> [</div>
<div class="line"><span class="lineno"> 1385</span>        (pair[0], <span class="stringliteral">&quot;_&quot;</span>.join([pair[1], str(seq[:i].count(pair))]))</div>
<div class="line"><span class="lineno"> 1386</span>        <span class="keywordflow">if</span> seq.count(pair) &gt; 1</div>
<div class="line"><span class="lineno"> 1387</span>        <span class="keywordflow">else</span> pair</div>
<div class="line"><span class="lineno"> 1388</span>        <span class="keywordflow">for</span> i, pair <span class="keywordflow">in</span> enumerate(seq)</div>
<div class="line"><span class="lineno"> 1389</span>    ]</div>
<div class="line"><span class="lineno"> 1390</span> </div>
<div class="line"><span class="lineno"> 1391</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7188c8cf8013009da186e4f04e9edfbb" name="a7188c8cf8013009da186e4f04e9edfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7188c8cf8013009da186e4f04e9edfbb">&#9670;&#160;</a></span>_managle_lambda_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Sequence[Any] pandas.core.apply._managle_lambda_list </td>
          <td>(</td>
          <td class="paramtype">Sequence[Any]&#160;</td>
          <td class="paramname"><em>aggfuncs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Possibly mangle a list of aggfuncs.

Parameters
----------
aggfuncs : Sequence

Returns
-------
mangled: list-like
    A new AggSpec sequence, where lambdas have been converted
    to have unique names.

Notes
-----
If just one aggfunc is passed, the name will not be mangled.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1475</span><span class="keyword">def </span>_managle_lambda_list(aggfuncs: Sequence[Any]) -&gt; Sequence[Any]:</div>
<div class="line"><span class="lineno"> 1476</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">    Possibly mangle a list of aggfuncs.</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">    aggfuncs : Sequence</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">    mangled: list-like</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">        A new AggSpec sequence, where lambdas have been converted</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">        to have unique names.</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">    If just one aggfunc is passed, the name will not be mangled.</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1493</span>    <span class="keywordflow">if</span> len(aggfuncs) &lt;= 1:</div>
<div class="line"><span class="lineno"> 1494</span>        <span class="comment"># don&#39;t mangle for .agg([lambda x: .])</span></div>
<div class="line"><span class="lineno"> 1495</span>        <span class="keywordflow">return</span> aggfuncs</div>
<div class="line"><span class="lineno"> 1496</span>    i = 0</div>
<div class="line"><span class="lineno"> 1497</span>    mangled_aggfuncs = []</div>
<div class="line"><span class="lineno"> 1498</span>    <span class="keywordflow">for</span> aggfunc <span class="keywordflow">in</span> aggfuncs:</div>
<div class="line"><span class="lineno"> 1499</span>        <span class="keywordflow">if</span> com.get_callable_name(aggfunc) == <span class="stringliteral">&quot;&lt;lambda&gt;&quot;</span>:</div>
<div class="line"><span class="lineno"> 1500</span>            aggfunc = partial(aggfunc)</div>
<div class="line"><span class="lineno"> 1501</span>            aggfunc.__name__ = f<span class="stringliteral">&quot;&lt;lambda_{i}&gt;&quot;</span></div>
<div class="line"><span class="lineno"> 1502</span>            i += 1</div>
<div class="line"><span class="lineno"> 1503</span>        mangled_aggfuncs.append(aggfunc)</div>
<div class="line"><span class="lineno"> 1504</span> </div>
<div class="line"><span class="lineno"> 1505</span>    <span class="keywordflow">return</span> mangled_aggfuncs</div>
<div class="line"><span class="lineno"> 1506</span> </div>
<div class="line"><span class="lineno"> 1507</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acc6275115a8b6f69239e5f98a2ac12a4" name="acc6275115a8b6f69239e5f98a2ac12a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6275115a8b6f69239e5f98a2ac12a4">&#9670;&#160;</a></span>frame_apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1apply_1_1_frame_apply.html">FrameApply</a> pandas.core.apply.frame_apply </td>
          <td>(</td>
          <td class="paramtype">DataFrame&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AggFuncType&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Axis &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raw</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>result_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">construct and return a row or column based frame apply object</pre> <div class="fragment"><div class="line"><span class="lineno">   87</span>) -&gt; FrameApply:</div>
<div class="line"><span class="lineno">   88</span>    <span class="stringliteral">&quot;&quot;&quot;construct and return a row or column based frame apply object&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   89</span>    axis = obj._get_axis_number(axis)</div>
<div class="line"><span class="lineno">   90</span>    klass: type[FrameApply]</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">if</span> axis == 0:</div>
<div class="line"><span class="lineno">   92</span>        klass = FrameRowApply</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">elif</span> axis == 1:</div>
<div class="line"><span class="lineno">   94</span>        klass = FrameColumnApply</div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="line"><span class="lineno">   96</span>    <span class="keywordflow">return</span> klass(</div>
<div class="line"><span class="lineno">   97</span>        obj,</div>
<div class="line"><span class="lineno">   98</span>        func,</div>
<div class="line"><span class="lineno">   99</span>        raw=raw,</div>
<div class="line"><span class="lineno">  100</span>        result_type=result_type,</div>
<div class="line"><span class="lineno">  101</span>        args=args,</div>
<div class="line"><span class="lineno">  102</span>        kwargs=kwargs,</div>
<div class="line"><span class="lineno">  103</span>    )</div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab72420b66d3d3a68d5785d5238a269aa" name="ab72420b66d3d3a68d5785d5238a269aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72420b66d3d3a68d5785d5238a269aa">&#9670;&#160;</a></span>is_multi_agg_with_relabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.apply.is_multi_agg_with_relabel </td>
          <td>(</td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether kwargs passed to .agg look like multi-agg with relabeling.

Parameters
----------
**kwargs : dict

Returns
-------
bool

Examples
--------
&gt;&gt;&gt; is_multi_agg_with_relabel(a="max")
False
&gt;&gt;&gt; is_multi_agg_with_relabel(a_max=("a", "max"), a_min=("a", "min"))
True
&gt;&gt;&gt; is_multi_agg_with_relabel()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1287</span><span class="keyword">def </span>is_multi_agg_with_relabel(**kwargs) -&gt; bool:</div>
<div class="line"><span class="lineno"> 1288</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    Check whether kwargs passed to .agg look like multi-agg with relabeling.</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    **kwargs : dict</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    bool</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    &gt;&gt;&gt; is_multi_agg_with_relabel(a=&quot;max&quot;)</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    &gt;&gt;&gt; is_multi_agg_with_relabel(a_max=(&quot;a&quot;, &quot;max&quot;), a_min=(&quot;a&quot;, &quot;min&quot;))</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    &gt;&gt;&gt; is_multi_agg_with_relabel()</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1308</span>    <span class="keywordflow">return</span> all(isinstance(v, tuple) <span class="keywordflow">and</span> len(v) == 2 <span class="keywordflow">for</span> v <span class="keywordflow">in</span> kwargs.values()) <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno"> 1309</span>        len(kwargs) &gt; 0</div>
<div class="line"><span class="lineno"> 1310</span>    )</div>
<div class="line"><span class="lineno"> 1311</span> </div>
<div class="line"><span class="lineno"> 1312</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a92d3b98fd771ce19d1d3cfdae0ab5623" name="a92d3b98fd771ce19d1d3cfdae0ab5623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d3b98fd771ce19d1d3cfdae0ab5623">&#9670;&#160;</a></span>maybe_mangle_lambdas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pandas.core.apply.maybe_mangle_lambdas </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>agg_spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make new lambdas with unique names.

Parameters
----------
agg_spec : Any
    An argument to GroupBy.agg.
    Non-dict-like `agg_spec` are pass through as is.
    For dict-like `agg_spec` a new spec is returned
    with name-mangled lambdas.

Returns
-------
mangled : Any
    Same type as the input.

Examples
--------
&gt;&gt;&gt; maybe_mangle_lambdas('sum')
'sum'
&gt;&gt;&gt; maybe_mangle_lambdas([lambda: 1, lambda: 2])  # doctest: +SKIP
[&lt;function __main__.&lt;lambda_0&gt;,
 &lt;function pandas...._make_lambda.&lt;locals&gt;.f(*args, **kwargs)&gt;]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1508</span><span class="keyword">def </span>maybe_mangle_lambdas(agg_spec: Any) -&gt; Any:</div>
<div class="line"><span class="lineno"> 1509</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    Make new lambdas with unique names.</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">    agg_spec : Any</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">        An argument to GroupBy.agg.</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        Non-dict-like `agg_spec` are pass through as is.</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">        For dict-like `agg_spec` a new spec is returned</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">        with name-mangled lambdas.</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    mangled : Any</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        Same type as the input.</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">    &gt;&gt;&gt; maybe_mangle_lambdas(&#39;sum&#39;)</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    &#39;sum&#39;</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">    &gt;&gt;&gt; maybe_mangle_lambdas([lambda: 1, lambda: 2])  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    [&lt;function __main__.&lt;lambda_0&gt;,</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">     &lt;function pandas...._make_lambda.&lt;locals&gt;.f(*args, **kwargs)&gt;]</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1533</span>    is_dict = is_dict_like(agg_spec)</div>
<div class="line"><span class="lineno"> 1534</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (is_dict <span class="keywordflow">or</span> is_list_like(agg_spec)):</div>
<div class="line"><span class="lineno"> 1535</span>        <span class="keywordflow">return</span> agg_spec</div>
<div class="line"><span class="lineno"> 1536</span>    mangled_aggspec = type(agg_spec)()  <span class="comment"># dict or OrderedDict</span></div>
<div class="line"><span class="lineno"> 1537</span> </div>
<div class="line"><span class="lineno"> 1538</span>    <span class="keywordflow">if</span> is_dict:</div>
<div class="line"><span class="lineno"> 1539</span>        <span class="keywordflow">for</span> key, aggfuncs <span class="keywordflow">in</span> agg_spec.items():</div>
<div class="line"><span class="lineno"> 1540</span>            <span class="keywordflow">if</span> is_list_like(aggfuncs) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_dict_like(aggfuncs):</div>
<div class="line"><span class="lineno"> 1541</span>                mangled_aggfuncs = _managle_lambda_list(aggfuncs)</div>
<div class="line"><span class="lineno"> 1542</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1543</span>                mangled_aggfuncs = aggfuncs</div>
<div class="line"><span class="lineno"> 1544</span> </div>
<div class="line"><span class="lineno"> 1545</span>            mangled_aggspec[key] = mangled_aggfuncs</div>
<div class="line"><span class="lineno"> 1546</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1547</span>        mangled_aggspec = _managle_lambda_list(agg_spec)</div>
<div class="line"><span class="lineno"> 1548</span> </div>
<div class="line"><span class="lineno"> 1549</span>    <span class="keywordflow">return</span> mangled_aggspec</div>
<div class="line"><span class="lineno"> 1550</span> </div>
<div class="line"><span class="lineno"> 1551</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af3ed9fb82a317c825e54aac638be9030" name="af3ed9fb82a317c825e54aac638be9030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ed9fb82a317c825e54aac638be9030">&#9670;&#160;</a></span>normalize_keyword_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[dict, list[str], npt.NDArray[np.intp]] pandas.core.apply.normalize_keyword_aggregation </td>
          <td>(</td>
          <td class="paramtype">dict&#160;</td>
          <td class="paramname"><em>kwargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Normalize user-provided "named aggregation" kwargs.
Transforms from the new ``Mapping[str, NamedAgg]`` style kwargs
to the old Dict[str, List[scalar]]].

Parameters
----------
kwargs : dict

Returns
-------
aggspec : dict
    The transformed kwargs.
columns : List[str]
    The user-provided keys.
col_idx_order : List[int]
    List of columns indices.

Examples
--------
&gt;&gt;&gt; normalize_keyword_aggregation({"output": ("input", "sum")})
(defaultdict(&lt;class 'list'&gt;, {'input': ['sum']}), ('output',), array([0]))
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1315</span>) -&gt; tuple[dict, list[str], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 1316</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    Normalize user-provided &quot;named aggregation&quot; kwargs.</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">    Transforms from the new ``Mapping[str, NamedAgg]`` style kwargs</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    to the old Dict[str, List[scalar]]].</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    kwargs : dict</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    aggspec : dict</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">        The transformed kwargs.</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">    columns : List[str]</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">        The user-provided keys.</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    col_idx_order : List[int]</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">        List of columns indices.</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    &gt;&gt;&gt; normalize_keyword_aggregation({&quot;output&quot;: (&quot;input&quot;, &quot;sum&quot;)})</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    (defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;input&#39;: [&#39;sum&#39;]}), (&#39;output&#39;,), array([0]))</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1339</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1base.html">pandas.core.indexes.base</a> <span class="keyword">import</span> Index</div>
<div class="line"><span class="lineno"> 1340</span> </div>
<div class="line"><span class="lineno"> 1341</span>    <span class="comment"># Normalize the aggregation functions as Mapping[column, List[func]],</span></div>
<div class="line"><span class="lineno"> 1342</span>    <span class="comment"># process normally, then fixup the names.</span></div>
<div class="line"><span class="lineno"> 1343</span>    <span class="comment"># TODO: aggspec type: typing.Dict[str, List[AggScalar]]</span></div>
<div class="line"><span class="lineno"> 1344</span>    <span class="comment"># May be hitting https://github.com/python/mypy/issues/5958</span></div>
<div class="line"><span class="lineno"> 1345</span>    <span class="comment"># saying it doesn&#39;t have an attribute __name__</span></div>
<div class="line"><span class="lineno"> 1346</span>    aggspec: DefaultDict = defaultdict(list)</div>
<div class="line"><span class="lineno"> 1347</span>    order = []</div>
<div class="line"><span class="lineno"> 1348</span>    columns, pairs = list(zip(*kwargs.items()))</div>
<div class="line"><span class="lineno"> 1349</span> </div>
<div class="line"><span class="lineno"> 1350</span>    <span class="keywordflow">for</span> column, aggfunc <span class="keywordflow">in</span> pairs:</div>
<div class="line"><span class="lineno"> 1351</span>        aggspec[column].append(aggfunc)</div>
<div class="line"><span class="lineno"> 1352</span>        order.append((column, com.get_callable_name(aggfunc) <span class="keywordflow">or</span> aggfunc))</div>
<div class="line"><span class="lineno"> 1353</span> </div>
<div class="line"><span class="lineno"> 1354</span>    <span class="comment"># uniquify aggfunc name if duplicated in order list</span></div>
<div class="line"><span class="lineno"> 1355</span>    uniquified_order = _make_unique_kwarg_list(order)</div>
<div class="line"><span class="lineno"> 1356</span> </div>
<div class="line"><span class="lineno"> 1357</span>    <span class="comment"># GH 25719, due to aggspec will change the order of assigned columns in aggregation</span></div>
<div class="line"><span class="lineno"> 1358</span>    <span class="comment"># uniquified_aggspec will store uniquified order list and will compare it with order</span></div>
<div class="line"><span class="lineno"> 1359</span>    <span class="comment"># based on index</span></div>
<div class="line"><span class="lineno"> 1360</span>    aggspec_order = [</div>
<div class="line"><span class="lineno"> 1361</span>        (column, com.get_callable_name(aggfunc) <span class="keywordflow">or</span> aggfunc)</div>
<div class="line"><span class="lineno"> 1362</span>        <span class="keywordflow">for</span> column, aggfuncs <span class="keywordflow">in</span> aggspec.items()</div>
<div class="line"><span class="lineno"> 1363</span>        <span class="keywordflow">for</span> aggfunc <span class="keywordflow">in</span> aggfuncs</div>
<div class="line"><span class="lineno"> 1364</span>    ]</div>
<div class="line"><span class="lineno"> 1365</span>    uniquified_aggspec = _make_unique_kwarg_list(aggspec_order)</div>
<div class="line"><span class="lineno"> 1366</span> </div>
<div class="line"><span class="lineno"> 1367</span>    <span class="comment"># get the new index of columns by comparison</span></div>
<div class="line"><span class="lineno"> 1368</span>    col_idx_order = Index(uniquified_aggspec).get_indexer(uniquified_order)</div>
<div class="line"><span class="lineno"> 1369</span>    <span class="keywordflow">return</span> aggspec, columns, col_idx_order</div>
<div class="line"><span class="lineno"> 1370</span> </div>
<div class="line"><span class="lineno"> 1371</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1indexes_1_1base_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1indexes_1_1base.html">pandas.core.indexes.base</a></div><div class="ttdef"><b>Definition</b> base.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a593a7b38eee91f9332eb527c3cad8576" name="a593a7b38eee91f9332eb527c3cad8576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593a7b38eee91f9332eb527c3cad8576">&#9670;&#160;</a></span>reconstruct_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[bool, AggFuncType | None, list[str] | None, npt.NDArray[np.intp] | None] pandas.core.apply.reconstruct_func </td>
          <td>(</td>
          <td class="paramtype">AggFuncType | None&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This is the internal function to reconstruct func given if there is relabeling
or not and also normalize the keyword to get new order of columns.

If named aggregation is applied, `func` will be None, and kwargs contains the
column and aggregation function information to be parsed;
If named aggregation is not applied, `func` is either string (e.g. 'min') or
Callable, or list of them (e.g. ['min', np.max]), or the dictionary of column name
and str/Callable/list of them (e.g. {'A': 'min'}, or {'A': [np.min, lambda x: x]})

If relabeling is True, will return relabeling, reconstructed func, column
names, and the reconstructed order of columns.
If relabeling is False, the columns and order will be None.

Parameters
----------
func: agg function (e.g. 'min' or Callable) or list of agg functions
    (e.g. ['min', np.max]) or dictionary (e.g. {'A': ['min', np.max]}).
**kwargs: dict, kwargs used in is_multi_agg_with_relabel and
    normalize_keyword_aggregation function for relabelling

Returns
-------
relabelling: bool, if there is relabelling or not
func: normalized and mangled func
columns: list of column names
order: array of columns indices

Examples
--------
&gt;&gt;&gt; reconstruct_func(None, **{"foo": ("col", "min")})
(True, defaultdict(&lt;class 'list'&gt;, {'col': ['min']}), ('foo',), array([0]))

&gt;&gt;&gt; reconstruct_func("min")
(False, 'min', None, None)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1227</span>) -&gt; tuple[bool, AggFuncType | <span class="keywordtype">None</span>, list[str] | <span class="keywordtype">None</span>, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 1228</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    This is the internal function to reconstruct func given if there is relabeling</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">    or not and also normalize the keyword to get new order of columns.</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    If named aggregation is applied, `func` will be None, and kwargs contains the</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">    column and aggregation function information to be parsed;</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">    If named aggregation is not applied, `func` is either string (e.g. &#39;min&#39;) or</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    Callable, or list of them (e.g. [&#39;min&#39;, np.max]), or the dictionary of column name</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    and str/Callable/list of them (e.g. {&#39;A&#39;: &#39;min&#39;}, or {&#39;A&#39;: [np.min, lambda x: x]})</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    If relabeling is True, will return relabeling, reconstructed func, column</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">    names, and the reconstructed order of columns.</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    If relabeling is False, the columns and order will be None.</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    func: agg function (e.g. &#39;min&#39; or Callable) or list of agg functions</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">        (e.g. [&#39;min&#39;, np.max]) or dictionary (e.g. {&#39;A&#39;: [&#39;min&#39;, np.max]}).</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    **kwargs: dict, kwargs used in is_multi_agg_with_relabel and</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">        normalize_keyword_aggregation function for relabelling</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">    relabelling: bool, if there is relabelling or not</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    func: normalized and mangled func</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">    columns: list of column names</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    order: array of columns indices</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    &gt;&gt;&gt; reconstruct_func(None, **{&quot;foo&quot;: (&quot;col&quot;, &quot;min&quot;)})</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    (True, defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;col&#39;: [&#39;min&#39;]}), (&#39;foo&#39;,), array([0]))</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    &gt;&gt;&gt; reconstruct_func(&quot;min&quot;)</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">    (False, &#39;min&#39;, None, None)</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1264</span>    relabeling = func <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> is_multi_agg_with_relabel(**kwargs)</div>
<div class="line"><span class="lineno"> 1265</span>    columns: list[str] | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1266</span>    order: npt.NDArray[np.intp] | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1267</span> </div>
<div class="line"><span class="lineno"> 1268</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> relabeling:</div>
<div class="line"><span class="lineno"> 1269</span>        <span class="keywordflow">if</span> isinstance(func, list) <span class="keywordflow">and</span> len(func) &gt; len(set(func)):</div>
<div class="line"><span class="lineno"> 1270</span> </div>
<div class="line"><span class="lineno"> 1271</span>            <span class="comment"># GH 28426 will raise error if duplicated function names are used and</span></div>
<div class="line"><span class="lineno"> 1272</span>            <span class="comment"># there is no reassigned name</span></div>
<div class="line"><span class="lineno"> 1273</span>            <span class="keywordflow">raise</span> SpecificationError(</div>
<div class="line"><span class="lineno"> 1274</span>                <span class="stringliteral">&quot;Function names must be unique if there is no new column names &quot;</span></div>
<div class="line"><span class="lineno"> 1275</span>                <span class="stringliteral">&quot;assigned&quot;</span></div>
<div class="line"><span class="lineno"> 1276</span>            )</div>
<div class="line"><span class="lineno"> 1277</span>        <span class="keywordflow">elif</span> func <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1278</span>            <span class="comment"># nicer error message</span></div>
<div class="line"><span class="lineno"> 1279</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Must provide &#39;func&#39; or tuples of &#39;(column, aggfunc).&quot;</span>)</div>
<div class="line"><span class="lineno"> 1280</span> </div>
<div class="line"><span class="lineno"> 1281</span>    <span class="keywordflow">if</span> relabeling:</div>
<div class="line"><span class="lineno"> 1282</span>        func, columns, order = normalize_keyword_aggregation(kwargs)</div>
<div class="line"><span class="lineno"> 1283</span> </div>
<div class="line"><span class="lineno"> 1284</span>    <span class="keywordflow">return</span> relabeling, func, columns, order</div>
<div class="line"><span class="lineno"> 1285</span> </div>
<div class="line"><span class="lineno"> 1286</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a572f9f92d9ffff4667bc4bb2f0708cff" name="a572f9f92d9ffff4667bc4bb2f0708cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572f9f92d9ffff4667bc4bb2f0708cff">&#9670;&#160;</a></span>relabel_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[Hashable, Series] pandas.core.apply.relabel_result </td>
          <td>(</td>
          <td class="paramtype">DataFrame | Series&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, list[Callable | str]]&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[Hashable]&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[int]&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Internal function to reorder result if relabelling is True for
dataframe.agg, and return the reordered result in dict.

Parameters:
----------
result: Result from aggregation
func: Dict of (column name, funcs)
columns: New columns name for relabelling
order: New order for relabelling

Examples:
---------
&gt;&gt;&gt; result = DataFrame({"A": [np.nan, 2, np.nan],
...       "C": [6, np.nan, np.nan], "B": [np.nan, 4, 2.5]})  # doctest: +SKIP
&gt;&gt;&gt; funcs = {"A": ["max"], "C": ["max"], "B": ["mean", "min"]}
&gt;&gt;&gt; columns = ("foo", "aab", "bar", "dat")
&gt;&gt;&gt; order = [0, 1, 2, 3]
&gt;&gt;&gt; _relabel_result(result, func, columns, order)  # doctest: +SKIP
dict(A=Series([2.0, NaN, NaN, NaN], index=["foo", "aab", "bar", "dat"]),
     C=Series([NaN, 6.0, NaN, NaN], index=["foo", "aab", "bar", "dat"]),
     B=Series([NaN, NaN, 2.5, 4.0], index=["foo", "aab", "bar", "dat"]))
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1397</span>) -&gt; dict[Hashable, Series]:</div>
<div class="line"><span class="lineno"> 1398</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">    Internal function to reorder result if relabelling is True for</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    dataframe.agg, and return the reordered result in dict.</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    Parameters:</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    result: Result from aggregation</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    func: Dict of (column name, funcs)</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    columns: New columns name for relabelling</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    order: New order for relabelling</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    Examples:</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    ---------</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    &gt;&gt;&gt; result = DataFrame({&quot;A&quot;: [np.nan, 2, np.nan],</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">    ...       &quot;C&quot;: [6, np.nan, np.nan], &quot;B&quot;: [np.nan, 4, 2.5]})  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    &gt;&gt;&gt; funcs = {&quot;A&quot;: [&quot;max&quot;], &quot;C&quot;: [&quot;max&quot;], &quot;B&quot;: [&quot;mean&quot;, &quot;min&quot;]}</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    &gt;&gt;&gt; columns = (&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;)</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">    &gt;&gt;&gt; order = [0, 1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">    &gt;&gt;&gt; _relabel_result(result, func, columns, order)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    dict(A=Series([2.0, NaN, NaN, NaN], index=[&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;]),</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">         C=Series([NaN, 6.0, NaN, NaN], index=[&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;]),</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">         B=Series([NaN, NaN, 2.5, 4.0], index=[&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;]))</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1421</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1base.html">pandas.core.indexes.base</a> <span class="keyword">import</span> Index</div>
<div class="line"><span class="lineno"> 1422</span> </div>
<div class="line"><span class="lineno"> 1423</span>    reordered_indexes = [</div>
<div class="line"><span class="lineno"> 1424</span>        pair[0] <span class="keywordflow">for</span> pair <span class="keywordflow">in</span> sorted(zip(columns, order), key=<span class="keyword">lambda</span> t: t[1])</div>
<div class="line"><span class="lineno"> 1425</span>    ]</div>
<div class="line"><span class="lineno"> 1426</span>    reordered_result_in_dict: dict[Hashable, Series] = {}</div>
<div class="line"><span class="lineno"> 1427</span>    idx = 0</div>
<div class="line"><span class="lineno"> 1428</span> </div>
<div class="line"><span class="lineno"> 1429</span>    reorder_mask = <span class="keywordflow">not</span> isinstance(result, ABCSeries) <span class="keywordflow">and</span> len(result.columns) &gt; 1</div>
<div class="line"><span class="lineno"> 1430</span>    <span class="keywordflow">for</span> col, fun <span class="keywordflow">in</span> func.items():</div>
<div class="line"><span class="lineno"> 1431</span>        s = result[col].dropna()</div>
<div class="line"><span class="lineno"> 1432</span> </div>
<div class="line"><span class="lineno"> 1433</span>        <span class="comment"># In the `_aggregate`, the callable names are obtained and used in `result`, and</span></div>
<div class="line"><span class="lineno"> 1434</span>        <span class="comment"># these names are ordered alphabetically. e.g.</span></div>
<div class="line"><span class="lineno"> 1435</span>        <span class="comment">#           C2   C1</span></div>
<div class="line"><span class="lineno"> 1436</span>        <span class="comment"># &lt;lambda&gt;   1  NaN</span></div>
<div class="line"><span class="lineno"> 1437</span>        <span class="comment"># amax     NaN  4.0</span></div>
<div class="line"><span class="lineno"> 1438</span>        <span class="comment"># max      NaN  4.0</span></div>
<div class="line"><span class="lineno"> 1439</span>        <span class="comment"># sum     18.0  6.0</span></div>
<div class="line"><span class="lineno"> 1440</span>        <span class="comment"># Therefore, the order of functions for each column could be shuffled</span></div>
<div class="line"><span class="lineno"> 1441</span>        <span class="comment"># accordingly so need to get the callable name if it is not parsed names, and</span></div>
<div class="line"><span class="lineno"> 1442</span>        <span class="comment"># reorder the aggregated result for each column.</span></div>
<div class="line"><span class="lineno"> 1443</span>        <span class="comment"># e.g. if df.agg(c1=(&quot;C2&quot;, sum), c2=(&quot;C2&quot;, lambda x: min(x))), correct order is</span></div>
<div class="line"><span class="lineno"> 1444</span>        <span class="comment"># [sum, &lt;lambda&gt;], but in `result`, it will be [&lt;lambda&gt;, sum], and we need to</span></div>
<div class="line"><span class="lineno"> 1445</span>        <span class="comment"># reorder so that aggregated values map to their functions regarding the order.</span></div>
<div class="line"><span class="lineno"> 1446</span> </div>
<div class="line"><span class="lineno"> 1447</span>        <span class="comment"># However there is only one column being used for aggregation, not need to</span></div>
<div class="line"><span class="lineno"> 1448</span>        <span class="comment"># reorder since the index is not sorted, and keep as is in `funcs`, e.g.</span></div>
<div class="line"><span class="lineno"> 1449</span>        <span class="comment">#         A</span></div>
<div class="line"><span class="lineno"> 1450</span>        <span class="comment"># min   1.0</span></div>
<div class="line"><span class="lineno"> 1451</span>        <span class="comment"># mean  1.5</span></div>
<div class="line"><span class="lineno"> 1452</span>        <span class="comment"># mean  1.5</span></div>
<div class="line"><span class="lineno"> 1453</span>        <span class="keywordflow">if</span> reorder_mask:</div>
<div class="line"><span class="lineno"> 1454</span>            fun = [</div>
<div class="line"><span class="lineno"> 1455</span>                com.get_callable_name(f) <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(f, str) <span class="keywordflow">else</span> f <span class="keywordflow">for</span> f <span class="keywordflow">in</span> fun</div>
<div class="line"><span class="lineno"> 1456</span>            ]</div>
<div class="line"><span class="lineno"> 1457</span>            col_idx_order = Index(s.index).get_indexer(fun)</div>
<div class="line"><span class="lineno"> 1458</span>            s = s[col_idx_order]</div>
<div class="line"><span class="lineno"> 1459</span> </div>
<div class="line"><span class="lineno"> 1460</span>        <span class="comment"># assign the new user-provided &quot;named aggregation&quot; as index names, and reindex</span></div>
<div class="line"><span class="lineno"> 1461</span>        <span class="comment"># it based on the whole user-provided names.</span></div>
<div class="line"><span class="lineno"> 1462</span>        s.index = reordered_indexes[idx : idx + len(fun)]</div>
<div class="line"><span class="lineno"> 1463</span>        reordered_result_in_dict[col] = s.reindex(columns, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1464</span>        idx = idx + len(fun)</div>
<div class="line"><span class="lineno"> 1465</span>    <span class="keywordflow">return</span> reordered_result_in_dict</div>
<div class="line"><span class="lineno"> 1466</span> </div>
<div class="line"><span class="lineno"> 1467</span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="comment"># TODO: Can&#39;t use, because mypy doesn&#39;t like us setting __name__</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="comment">#   error: &quot;partial[Any]&quot; has no attribute &quot;__name__&quot;</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="comment"># the type is:</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="comment">#   typing.Sequence[Callable[..., ScalarResult]]</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="comment">#     -&gt; typing.Sequence[Callable[..., ScalarResult]]:</span></div>
<div class="line"><span class="lineno"> 1473</span> </div>
<div class="line"><span class="lineno"> 1474</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a432f2473b653042571d7e8e9bc2ae42a" name="a432f2473b653042571d7e8e9bc2ae42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432f2473b653042571d7e8e9bc2ae42a">&#9670;&#160;</a></span>validate_func_kwargs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[list[str], list[str | Callable[..., Any]]] pandas.core.apply.validate_func_kwargs </td>
          <td>(</td>
          <td class="paramtype">dict&#160;</td>
          <td class="paramname"><em>kwargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates types of user-provided "named aggregation" kwargs.
`TypeError` is raised if aggfunc is not `str` or callable.

Parameters
----------
kwargs : dict

Returns
-------
columns : List[str]
    List of user-provied keys.
func : List[Union[str, callable[...,Any]]]
    List of user-provided aggfuncs

Examples
--------
&gt;&gt;&gt; validate_func_kwargs({'one': 'min', 'two': 'max'})
(['one', 'two'], ['min', 'max'])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1554</span>) -&gt; tuple[list[str], list[str | Callable[..., Any]]]:</div>
<div class="line"><span class="lineno"> 1555</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    Validates types of user-provided &quot;named aggregation&quot; kwargs.</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    `TypeError` is raised if aggfunc is not `str` or callable.</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    kwargs : dict</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">    columns : List[str]</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">        List of user-provied keys.</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">    func : List[Union[str, callable[...,Any]]]</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral">        List of user-provided aggfuncs</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    &gt;&gt;&gt; validate_func_kwargs({&#39;one&#39;: &#39;min&#39;, &#39;two&#39;: &#39;max&#39;})</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral">    ([&#39;one&#39;, &#39;two&#39;], [&#39;min&#39;, &#39;max&#39;])</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1575</span>    tuple_given_message = <span class="stringliteral">&quot;func is expected but received {} in **kwargs.&quot;</span></div>
<div class="line"><span class="lineno"> 1576</span>    columns = list(kwargs)</div>
<div class="line"><span class="lineno"> 1577</span>    func = []</div>
<div class="line"><span class="lineno"> 1578</span>    <span class="keywordflow">for</span> col_func <span class="keywordflow">in</span> kwargs.values():</div>
<div class="line"><span class="lineno"> 1579</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (isinstance(col_func, str) <span class="keywordflow">or</span> callable(col_func)):</div>
<div class="line"><span class="lineno"> 1580</span>            <span class="keywordflow">raise</span> TypeError(tuple_given_message.format(type(col_func).__name__))</div>
<div class="line"><span class="lineno"> 1581</span>        func.append(col_func)</div>
<div class="line"><span class="lineno"> 1582</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> columns:</div>
<div class="line"><span class="lineno"> 1583</span>        no_arg_message = <span class="stringliteral">&quot;Must provide &#39;func&#39; or named aggregation **kwargs.&quot;</span></div>
<div class="line"><span class="lineno"> 1584</span>        <span class="keywordflow">raise</span> TypeError(no_arg_message)</div>
<div class="line"><span class="lineno"> 1585</span>    <span class="keywordflow">return</span> columns, func</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa116995ff61ef4fed4bd2f7036d6ce42" name="aa116995ff61ef4fed4bd2f7036d6ce42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa116995ff61ef4fed4bd2f7036d6ce42">&#9670;&#160;</a></span>ResType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.apply.ResType = Dict[int, Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
