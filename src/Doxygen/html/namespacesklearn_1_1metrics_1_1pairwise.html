<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.metrics.pairwise Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1metrics.html">metrics</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html">pairwise</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sklearn.metrics.pairwise Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad26d69f9e95b50a311ada7f44259fe3a" id="r_ad26d69f9e95b50a311ada7f44259fe3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#ad26d69f9e95b50a311ada7f44259fe3a">_return_float_dtype</a> (X, Y)</td></tr>
<tr class="separator:ad26d69f9e95b50a311ada7f44259fe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeca81e0a9c505d4db97716bba20f96" id="r_a5eeca81e0a9c505d4db97716bba20f96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a5eeca81e0a9c505d4db97716bba20f96">check_pairwise_arrays</a> (X, Y, *precomputed=False, dtype=None, accept_sparse=&quot;csr&quot;, force_all_finite=True, copy=False)</td></tr>
<tr class="separator:a5eeca81e0a9c505d4db97716bba20f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ef0b68662729cbb433e3870d8fb526" id="r_a05ef0b68662729cbb433e3870d8fb526"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a05ef0b68662729cbb433e3870d8fb526">check_paired_arrays</a> (X, Y)</td></tr>
<tr class="separator:a05ef0b68662729cbb433e3870d8fb526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3204eff491cab671ef18548454b65f37" id="r_a3204eff491cab671ef18548454b65f37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a3204eff491cab671ef18548454b65f37">euclidean_distances</a> (X, Y=None, *Y_norm_squared=None, squared=False, X_norm_squared=None)</td></tr>
<tr class="separator:a3204eff491cab671ef18548454b65f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50323fbe48ef3914754d468794e43d5" id="r_ac50323fbe48ef3914754d468794e43d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#ac50323fbe48ef3914754d468794e43d5">_euclidean_distances</a> (X, Y, X_norm_squared=None, Y_norm_squared=None, squared=False)</td></tr>
<tr class="separator:ac50323fbe48ef3914754d468794e43d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffaeaa692c4ec5f5f3513dae00b6b9a" id="r_a2ffaeaa692c4ec5f5f3513dae00b6b9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a2ffaeaa692c4ec5f5f3513dae00b6b9a">nan_euclidean_distances</a> (X, Y=None, *squared=False, missing_values=np.nan, copy=True)</td></tr>
<tr class="separator:a2ffaeaa692c4ec5f5f3513dae00b6b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735ea9f0b2415c09f5c0029c0f3d4dbf" id="r_a735ea9f0b2415c09f5c0029c0f3d4dbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a735ea9f0b2415c09f5c0029c0f3d4dbf">_euclidean_distances_upcast</a> (X, XX=None, Y=None, YY=None, batch_size=None)</td></tr>
<tr class="separator:a735ea9f0b2415c09f5c0029c0f3d4dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d0afb3455b11842415cca5dc3ca97e" id="r_ae9d0afb3455b11842415cca5dc3ca97e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#ae9d0afb3455b11842415cca5dc3ca97e">_argmin_min_reduce</a> (dist, start)</td></tr>
<tr class="separator:ae9d0afb3455b11842415cca5dc3ca97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed5c2a175b7e339f899b651e2c075f1" id="r_a9ed5c2a175b7e339f899b651e2c075f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a9ed5c2a175b7e339f899b651e2c075f1">_argmin_reduce</a> (dist, start)</td></tr>
<tr class="separator:a9ed5c2a175b7e339f899b651e2c075f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f1b6da5129c0f84504a08145190775" id="r_a76f1b6da5129c0f84504a08145190775"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a76f1b6da5129c0f84504a08145190775">pairwise_distances_argmin_min</a> (X, Y, *axis=1, metric=&quot;euclidean&quot;, metric_kwargs=None)</td></tr>
<tr class="separator:a76f1b6da5129c0f84504a08145190775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d611a0cef1e72b4de7c2f59af1afe9a" id="r_a0d611a0cef1e72b4de7c2f59af1afe9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a0d611a0cef1e72b4de7c2f59af1afe9a">pairwise_distances_argmin</a> (X, Y, *axis=1, metric=&quot;euclidean&quot;, metric_kwargs=None)</td></tr>
<tr class="separator:a0d611a0cef1e72b4de7c2f59af1afe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99876a97ceaba6938d9a4bc174e8f06a" id="r_a99876a97ceaba6938d9a4bc174e8f06a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a99876a97ceaba6938d9a4bc174e8f06a">haversine_distances</a> (X, Y=None)</td></tr>
<tr class="separator:a99876a97ceaba6938d9a4bc174e8f06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fb85a2fbacef383e08758df9d2f47b" id="r_a54fb85a2fbacef383e08758df9d2f47b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a54fb85a2fbacef383e08758df9d2f47b">manhattan_distances</a> (X, Y=None, *sum_over_features=&quot;deprecated&quot;)</td></tr>
<tr class="separator:a54fb85a2fbacef383e08758df9d2f47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97a1aa563d8a29eb417b12c4e811620" id="r_ae97a1aa563d8a29eb417b12c4e811620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#ae97a1aa563d8a29eb417b12c4e811620">cosine_distances</a> (X, Y=None)</td></tr>
<tr class="separator:ae97a1aa563d8a29eb417b12c4e811620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ec59a5d820f4c1bbb103dee4f42df8" id="r_a33ec59a5d820f4c1bbb103dee4f42df8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a33ec59a5d820f4c1bbb103dee4f42df8">paired_euclidean_distances</a> (X, Y)</td></tr>
<tr class="separator:a33ec59a5d820f4c1bbb103dee4f42df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a3f94164bf717e7a510c0a305a6ec0" id="r_a97a3f94164bf717e7a510c0a305a6ec0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a97a3f94164bf717e7a510c0a305a6ec0">paired_manhattan_distances</a> (X, Y)</td></tr>
<tr class="separator:a97a3f94164bf717e7a510c0a305a6ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924b16b18a34cbc510c1d5fce54adb8c" id="r_a924b16b18a34cbc510c1d5fce54adb8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a924b16b18a34cbc510c1d5fce54adb8c">paired_cosine_distances</a> (X, Y)</td></tr>
<tr class="separator:a924b16b18a34cbc510c1d5fce54adb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f2c5682aaed539eec6bde7946d495" id="r_acb9f2c5682aaed539eec6bde7946d495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#acb9f2c5682aaed539eec6bde7946d495">paired_distances</a> (X, Y, *metric=&quot;euclidean&quot;, **kwds)</td></tr>
<tr class="separator:acb9f2c5682aaed539eec6bde7946d495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceabe6742da2d54c397aa5aa8bb9be2" id="r_abceabe6742da2d54c397aa5aa8bb9be2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#abceabe6742da2d54c397aa5aa8bb9be2">linear_kernel</a> (X, Y=None, dense_output=True)</td></tr>
<tr class="separator:abceabe6742da2d54c397aa5aa8bb9be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e13f5fedc89170766a4c72906ea889" id="r_a43e13f5fedc89170766a4c72906ea889"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a43e13f5fedc89170766a4c72906ea889">polynomial_kernel</a> (X, Y=None, degree=3, gamma=None, coef0=1)</td></tr>
<tr class="separator:a43e13f5fedc89170766a4c72906ea889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6db26d255e118102602ae499bc84d66" id="r_af6db26d255e118102602ae499bc84d66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#af6db26d255e118102602ae499bc84d66">sigmoid_kernel</a> (X, Y=None, gamma=None, coef0=1)</td></tr>
<tr class="separator:af6db26d255e118102602ae499bc84d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5e7b70ceb87ee2e1550f6f9e426f21" id="r_abb5e7b70ceb87ee2e1550f6f9e426f21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#abb5e7b70ceb87ee2e1550f6f9e426f21">rbf_kernel</a> (X, Y=None, gamma=None)</td></tr>
<tr class="separator:abb5e7b70ceb87ee2e1550f6f9e426f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0265ee042d09f3a514564e2e86d349a3" id="r_a0265ee042d09f3a514564e2e86d349a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a0265ee042d09f3a514564e2e86d349a3">laplacian_kernel</a> (X, Y=None, gamma=None)</td></tr>
<tr class="separator:a0265ee042d09f3a514564e2e86d349a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3e46306103c1b7c394d6236360960c" id="r_a1c3e46306103c1b7c394d6236360960c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a1c3e46306103c1b7c394d6236360960c">cosine_similarity</a> (X, Y=None, dense_output=True)</td></tr>
<tr class="separator:a1c3e46306103c1b7c394d6236360960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79a81af6e4ad0fbd4a8e40498ebf2bd" id="r_aa79a81af6e4ad0fbd4a8e40498ebf2bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#aa79a81af6e4ad0fbd4a8e40498ebf2bd">additive_chi2_kernel</a> (X, Y=None)</td></tr>
<tr class="separator:aa79a81af6e4ad0fbd4a8e40498ebf2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada08aa64e7efa1f43111a82fb315d9ab" id="r_ada08aa64e7efa1f43111a82fb315d9ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#ada08aa64e7efa1f43111a82fb315d9ab">chi2_kernel</a> (X, Y=None, gamma=1.0)</td></tr>
<tr class="separator:ada08aa64e7efa1f43111a82fb315d9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e4e07bc5d8095cd44d095cb8073eb3" id="r_aa4e4e07bc5d8095cd44d095cb8073eb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#aa4e4e07bc5d8095cd44d095cb8073eb3">distance_metrics</a> ()</td></tr>
<tr class="separator:aa4e4e07bc5d8095cd44d095cb8073eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50e64652ef2315eddf4a798919a1150" id="r_aa50e64652ef2315eddf4a798919a1150"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#aa50e64652ef2315eddf4a798919a1150">_dist_wrapper</a> (dist_func, dist_matrix, slice_, *args, **kwargs)</td></tr>
<tr class="separator:aa50e64652ef2315eddf4a798919a1150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064dd93ce7af42456ee77f961cf41758" id="r_a064dd93ce7af42456ee77f961cf41758"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a064dd93ce7af42456ee77f961cf41758">_parallel_pairwise</a> (X, Y, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, n_jobs, **kwds)</td></tr>
<tr class="separator:a064dd93ce7af42456ee77f961cf41758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f424c7237174b2ed7bce510860bde" id="r_a824f424c7237174b2ed7bce510860bde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a824f424c7237174b2ed7bce510860bde">_pairwise_callable</a> (X, Y, metric, force_all_finite=True, **kwds)</td></tr>
<tr class="separator:a824f424c7237174b2ed7bce510860bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51cff9fa199c454aa503ad4192d10fc" id="r_ac51cff9fa199c454aa503ad4192d10fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#ac51cff9fa199c454aa503ad4192d10fc">_check_chunk_size</a> (reduced, chunk_size)</td></tr>
<tr class="separator:ac51cff9fa199c454aa503ad4192d10fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de75fb9fea808090b4cd2fdd739e52d" id="r_a3de75fb9fea808090b4cd2fdd739e52d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a3de75fb9fea808090b4cd2fdd739e52d">_precompute_metric_params</a> (X, Y, metric=None, **kwds)</td></tr>
<tr class="separator:a3de75fb9fea808090b4cd2fdd739e52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a5a8588a65ce06fb75eb36d54e1e9b" id="r_aa9a5a8588a65ce06fb75eb36d54e1e9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#aa9a5a8588a65ce06fb75eb36d54e1e9b">pairwise_distances_chunked</a> (X, Y=None, *reduce_func=None, metric=&quot;euclidean&quot;, n_jobs=None, working_memory=None, **kwds)</td></tr>
<tr class="separator:aa9a5a8588a65ce06fb75eb36d54e1e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1df754e9a97fe2a197968b34999e27" id="r_aea1df754e9a97fe2a197968b34999e27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#aea1df754e9a97fe2a197968b34999e27">pairwise_distances</a> (X, Y=None, metric=&quot;euclidean&quot;, *n_jobs=None, force_all_finite=True, **kwds)</td></tr>
<tr class="separator:aea1df754e9a97fe2a197968b34999e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93c078e291ecf01cfad88c8a6b6d6cd" id="r_aa93c078e291ecf01cfad88c8a6b6d6cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#aa93c078e291ecf01cfad88c8a6b6d6cd">kernel_metrics</a> ()</td></tr>
<tr class="separator:aa93c078e291ecf01cfad88c8a6b6d6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dfe23a75eb37809d2ca4a73053cf0c" id="r_a63dfe23a75eb37809d2ca4a73053cf0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a63dfe23a75eb37809d2ca4a73053cf0c">pairwise_kernels</a> (X, Y=None, metric=&quot;linear&quot;, *filter_params=False, n_jobs=None, **kwds)</td></tr>
<tr class="separator:a63dfe23a75eb37809d2ca4a73053cf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aedd1a704e6ae40bef4615b0a68182c8e" id="r_aedd1a704e6ae40bef4615b0a68182c8e"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#aedd1a704e6ae40bef4615b0a68182c8e">PAIRED_DISTANCES</a></td></tr>
<tr class="separator:aedd1a704e6ae40bef4615b0a68182c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6318e9b211cca80a664e66d03ce217ee" id="r_a6318e9b211cca80a664e66d03ce217ee"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a6318e9b211cca80a664e66d03ce217ee">PAIRWISE_DISTANCE_FUNCTIONS</a></td></tr>
<tr class="separator:a6318e9b211cca80a664e66d03ce217ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cb016eedfbee5454a2f62a587d5c4a" id="r_a00cb016eedfbee5454a2f62a587d5c4a"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a00cb016eedfbee5454a2f62a587d5c4a">_VALID_METRICS</a></td></tr>
<tr class="separator:a00cb016eedfbee5454a2f62a587d5c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9672ff97d09bd0f0902492b41f49617f" id="r_a9672ff97d09bd0f0902492b41f49617f"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a9672ff97d09bd0f0902492b41f49617f">_NAN_METRICS</a> = [&quot;nan_euclidean&quot;]</td></tr>
<tr class="separator:a9672ff97d09bd0f0902492b41f49617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138062df624ab0d52e9da2424739e7b" id="r_ad138062df624ab0d52e9da2424739e7b"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#ad138062df624ab0d52e9da2424739e7b">PAIRWISE_BOOLEAN_FUNCTIONS</a></td></tr>
<tr class="separator:ad138062df624ab0d52e9da2424739e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5250b388161c58372f80b0d3263a2ad1" id="r_a5250b388161c58372f80b0d3263a2ad1"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a5250b388161c58372f80b0d3263a2ad1">PAIRWISE_KERNEL_FUNCTIONS</a></td></tr>
<tr class="separator:a5250b388161c58372f80b0d3263a2ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be78123081bcdd32773380e0cf917e5" id="r_a9be78123081bcdd32773380e0cf917e5"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1pairwise.html#a9be78123081bcdd32773380e0cf917e5">KERNEL_PARAMS</a></td></tr>
<tr class="separator:a9be78123081bcdd32773380e0cf917e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae9d0afb3455b11842415cca5dc3ca97e" name="ae9d0afb3455b11842415cca5dc3ca97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d0afb3455b11842415cca5dc3ca97e">&#9670;&#160;</a></span>_argmin_min_reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._argmin_min_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  577</span><span class="keyword">def </span>_argmin_min_reduce(dist, start):</div>
<div class="line"><span class="lineno">  578</span>    <span class="comment"># `start` is specified in the signature but not used. This is because the higher</span></div>
<div class="line"><span class="lineno">  579</span>    <span class="comment"># order `pairwise_distances_chunked` function needs reduction functions that are</span></div>
<div class="line"><span class="lineno">  580</span>    <span class="comment"># passed as argument to have a two arguments signature.</span></div>
<div class="line"><span class="lineno">  581</span>    indices = dist.argmin(axis=1)</div>
<div class="line"><span class="lineno">  582</span>    values = dist[np.arange(dist.shape[0]), indices]</div>
<div class="line"><span class="lineno">  583</span>    <span class="keywordflow">return</span> indices, values</div>
<div class="line"><span class="lineno">  584</span> </div>
<div class="line"><span class="lineno">  585</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ed5c2a175b7e339f899b651e2c075f1" name="a9ed5c2a175b7e339f899b651e2c075f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed5c2a175b7e339f899b651e2c075f1">&#9670;&#160;</a></span>_argmin_reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._argmin_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  586</span><span class="keyword">def </span>_argmin_reduce(dist, start):</div>
<div class="line"><span class="lineno">  587</span>    <span class="comment"># `start` is specified in the signature but not used. This is because the higher</span></div>
<div class="line"><span class="lineno">  588</span>    <span class="comment"># order `pairwise_distances_chunked` function needs reduction functions that are</span></div>
<div class="line"><span class="lineno">  589</span>    <span class="comment"># passed as argument to have a two arguments signature.</span></div>
<div class="line"><span class="lineno">  590</span>    <span class="keywordflow">return</span> dist.argmin(axis=1)</div>
<div class="line"><span class="lineno">  591</span> </div>
<div class="line"><span class="lineno">  592</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac51cff9fa199c454aa503ad4192d10fc" name="ac51cff9fa199c454aa503ad4192d10fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51cff9fa199c454aa503ad4192d10fc">&#9670;&#160;</a></span>_check_chunk_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._check_chunk_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reduced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Checks chunk is a sequence of expected size or a tuple of same.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1661</span><span class="keyword">def </span>_check_chunk_size(reduced, chunk_size):</div>
<div class="line"><span class="lineno"> 1662</span>    <span class="stringliteral">&quot;&quot;&quot;Checks chunk is a sequence of expected size or a tuple of same.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1663</span>    <span class="keywordflow">if</span> reduced <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1664</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1665</span>    is_tuple = isinstance(reduced, tuple)</div>
<div class="line"><span class="lineno"> 1666</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_tuple:</div>
<div class="line"><span class="lineno"> 1667</span>        reduced = (reduced,)</div>
<div class="line"><span class="lineno"> 1668</span>    <span class="keywordflow">if</span> any(isinstance(r, tuple) <span class="keywordflow">or</span> <span class="keywordflow">not</span> hasattr(r, <span class="stringliteral">&quot;__iter__&quot;</span>) <span class="keywordflow">for</span> r <span class="keywordflow">in</span> reduced):</div>
<div class="line"><span class="lineno"> 1669</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1670</span>            <span class="stringliteral">&quot;reduce_func returned %r. Expected sequence(s) of length %d.&quot;</span></div>
<div class="line"><span class="lineno"> 1671</span>            % (reduced <span class="keywordflow">if</span> is_tuple <span class="keywordflow">else</span> reduced[0], chunk_size)</div>
<div class="line"><span class="lineno"> 1672</span>        )</div>
<div class="line"><span class="lineno"> 1673</span>    <span class="keywordflow">if</span> any(_num_samples(r) != chunk_size <span class="keywordflow">for</span> r <span class="keywordflow">in</span> reduced):</div>
<div class="line"><span class="lineno"> 1674</span>        actual_size = tuple(_num_samples(r) <span class="keywordflow">for</span> r <span class="keywordflow">in</span> reduced)</div>
<div class="line"><span class="lineno"> 1675</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1676</span>            <span class="stringliteral">&quot;reduce_func returned object of length %s. &quot;</span></div>
<div class="line"><span class="lineno"> 1677</span>            <span class="stringliteral">&quot;Expected same length as input: %d.&quot;</span></div>
<div class="line"><span class="lineno"> 1678</span>            % (actual_size <span class="keywordflow">if</span> is_tuple <span class="keywordflow">else</span> actual_size[0], chunk_size)</div>
<div class="line"><span class="lineno"> 1679</span>        )</div>
<div class="line"><span class="lineno"> 1680</span> </div>
<div class="line"><span class="lineno"> 1681</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa50e64652ef2315eddf4a798919a1150" name="aa50e64652ef2315eddf4a798919a1150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50e64652ef2315eddf4a798919a1150">&#9670;&#160;</a></span>_dist_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._dist_wrapper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slice_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Write in-place to a slice of a distance matrix.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1565</span><span class="keyword">def </span>_dist_wrapper(dist_func, dist_matrix, slice_, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 1566</span>    <span class="stringliteral">&quot;&quot;&quot;Write in-place to a slice of a distance matrix.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1567</span>    dist_matrix[:, slice_] = dist_func(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 1568</span> </div>
<div class="line"><span class="lineno"> 1569</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac50323fbe48ef3914754d468794e43d5" name="ac50323fbe48ef3914754d468794e43d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50323fbe48ef3914754d468794e43d5">&#9670;&#160;</a></span>_euclidean_distances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._euclidean_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X_norm_squared</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y_norm_squared</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>squared</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computational part of euclidean_distances

Assumes inputs are already checked.

If norms are passed as float32, they are unused. If arrays are passed as
float32, norms needs to be recomputed on upcast chunks.
TODO: use a float64 accumulator in row_norms to avoid the latter.
</pre> <div class="fragment"><div class="line"><span class="lineno">  331</span><span class="keyword">def </span>_euclidean_distances(X, Y, X_norm_squared=None, Y_norm_squared=None, squared=False):</div>
<div class="line"><span class="lineno">  332</span>    <span class="stringliteral">&quot;&quot;&quot;Computational part of euclidean_distances</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    Assumes inputs are already checked.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    If norms are passed as float32, they are unused. If arrays are passed as</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    float32, norms needs to be recomputed on upcast chunks.</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    TODO: use a float64 accumulator in row_norms to avoid the latter.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordflow">if</span> X_norm_squared <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  341</span>        <span class="keywordflow">if</span> X_norm_squared.dtype == np.float32:</div>
<div class="line"><span class="lineno">  342</span>            XX = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  343</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  344</span>            XX = X_norm_squared.reshape(-1, 1)</div>
<div class="line"><span class="lineno">  345</span>    <span class="keywordflow">elif</span> X.dtype == np.float32:</div>
<div class="line"><span class="lineno">  346</span>        XX = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  348</span>        XX = row_norms(X, squared=<span class="keyword">True</span>)[:, np.newaxis]</div>
<div class="line"><span class="lineno">  349</span> </div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> X:</div>
<div class="line"><span class="lineno">  351</span>        YY = <span class="keywordtype">None</span> <span class="keywordflow">if</span> XX <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> XX.T</div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  353</span>        <span class="keywordflow">if</span> Y_norm_squared <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  354</span>            <span class="keywordflow">if</span> Y_norm_squared.dtype == np.float32:</div>
<div class="line"><span class="lineno">  355</span>                YY = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  356</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  357</span>                YY = Y_norm_squared.reshape(1, -1)</div>
<div class="line"><span class="lineno">  358</span>        <span class="keywordflow">elif</span> Y.dtype == np.float32:</div>
<div class="line"><span class="lineno">  359</span>            YY = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  360</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  361</span>            YY = row_norms(Y, squared=<span class="keyword">True</span>)[np.newaxis, :]</div>
<div class="line"><span class="lineno">  362</span> </div>
<div class="line"><span class="lineno">  363</span>    <span class="keywordflow">if</span> X.dtype == np.float32:</div>
<div class="line"><span class="lineno">  364</span>        <span class="comment"># To minimize precision issues with float32, we compute the distance</span></div>
<div class="line"><span class="lineno">  365</span>        <span class="comment"># matrix on chunks of X and Y upcast to float64</span></div>
<div class="line"><span class="lineno">  366</span>        distances = _euclidean_distances_upcast(X, XX, Y, YY)</div>
<div class="line"><span class="lineno">  367</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  368</span>        <span class="comment"># if dtype is already float64, no need to chunk and upcast</span></div>
<div class="line"><span class="lineno">  369</span>        distances = -2 * safe_sparse_dot(X, Y.T, dense_output=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  370</span>        distances += XX</div>
<div class="line"><span class="lineno">  371</span>        distances += YY</div>
<div class="line"><span class="lineno">  372</span>    np.maximum(distances, 0, out=distances)</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>    <span class="comment"># Ensure that distances between vectors and themselves are set to 0.0.</span></div>
<div class="line"><span class="lineno">  375</span>    <span class="comment"># This may not be the case due to floating point rounding errors.</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y:</div>
<div class="line"><span class="lineno">  377</span>        np.fill_diagonal(distances, 0)</div>
<div class="line"><span class="lineno">  378</span> </div>
<div class="line"><span class="lineno">  379</span>    <span class="keywordflow">return</span> distances <span class="keywordflow">if</span> squared <span class="keywordflow">else</span> np.sqrt(distances, out=distances)</div>
<div class="line"><span class="lineno">  380</span> </div>
<div class="line"><span class="lineno">  381</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a735ea9f0b2415c09f5c0029c0f3d4dbf" name="a735ea9f0b2415c09f5c0029c0f3d4dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735ea9f0b2415c09f5c0029c0f3d4dbf">&#9670;&#160;</a></span>_euclidean_distances_upcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._euclidean_distances_upcast </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>XX</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>YY</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Euclidean distances between X and Y.

Assumes X and Y have float32 dtype.
Assumes XX and YY have float64 dtype or are None.

X and Y are upcast to float64 by chunks, which size is chosen to limit
memory increase by approximately 10% (at least 10MiB).
</pre> <div class="fragment"><div class="line"><span class="lineno">  504</span><span class="keyword">def </span>_euclidean_distances_upcast(X, XX=None, Y=None, YY=None, batch_size=None):</div>
<div class="line"><span class="lineno">  505</span>    <span class="stringliteral">&quot;&quot;&quot;Euclidean distances between X and Y.</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    Assumes X and Y have float32 dtype.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    Assumes XX and YY have float64 dtype or are None.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    X and Y are upcast to float64 by chunks, which size is chosen to limit</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    memory increase by approximately 10% (at least 10MiB).</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  513</span>    n_samples_X = X.shape[0]</div>
<div class="line"><span class="lineno">  514</span>    n_samples_Y = Y.shape[0]</div>
<div class="line"><span class="lineno">  515</span>    n_features = X.shape[1]</div>
<div class="line"><span class="lineno">  516</span> </div>
<div class="line"><span class="lineno">  517</span>    distances = np.empty((n_samples_X, n_samples_Y), dtype=np.float32)</div>
<div class="line"><span class="lineno">  518</span> </div>
<div class="line"><span class="lineno">  519</span>    <span class="keywordflow">if</span> batch_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  520</span>        x_density = X.nnz / np.prod(X.shape) <span class="keywordflow">if</span> issparse(X) <span class="keywordflow">else</span> 1</div>
<div class="line"><span class="lineno">  521</span>        y_density = Y.nnz / np.prod(Y.shape) <span class="keywordflow">if</span> issparse(Y) <span class="keywordflow">else</span> 1</div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span>        <span class="comment"># Allow 10% more memory than X, Y and the distance matrix take (at</span></div>
<div class="line"><span class="lineno">  524</span>        <span class="comment"># least 10MiB)</span></div>
<div class="line"><span class="lineno">  525</span>        maxmem = max(</div>
<div class="line"><span class="lineno">  526</span>            (</div>
<div class="line"><span class="lineno">  527</span>                (x_density * n_samples_X + y_density * n_samples_Y) * n_features</div>
<div class="line"><span class="lineno">  528</span>                + (x_density * n_samples_X * y_density * n_samples_Y)</div>
<div class="line"><span class="lineno">  529</span>            )</div>
<div class="line"><span class="lineno">  530</span>            / 10,</div>
<div class="line"><span class="lineno">  531</span>            10 * 2**17,</div>
<div class="line"><span class="lineno">  532</span>        )</div>
<div class="line"><span class="lineno">  533</span> </div>
<div class="line"><span class="lineno">  534</span>        <span class="comment"># The increase amount of memory in 8-byte blocks is:</span></div>
<div class="line"><span class="lineno">  535</span>        <span class="comment"># - x_density * batch_size * n_features (copy of chunk of X)</span></div>
<div class="line"><span class="lineno">  536</span>        <span class="comment"># - y_density * batch_size * n_features (copy of chunk of Y)</span></div>
<div class="line"><span class="lineno">  537</span>        <span class="comment"># - batch_size * batch_size (chunk of distance matrix)</span></div>
<div class="line"><span class="lineno">  538</span>        <span class="comment"># Hence x² + (xd+yd)kx = M, where x=batch_size, k=n_features, M=maxmem</span></div>
<div class="line"><span class="lineno">  539</span>        <span class="comment">#                                 xd=x_density and yd=y_density</span></div>
<div class="line"><span class="lineno">  540</span>        tmp = (x_density + y_density) * n_features</div>
<div class="line"><span class="lineno">  541</span>        batch_size = (-tmp + np.sqrt(tmp**2 + 4 * maxmem)) / 2</div>
<div class="line"><span class="lineno">  542</span>        batch_size = max(int(batch_size), 1)</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  544</span>    x_batches = gen_batches(n_samples_X, batch_size)</div>
<div class="line"><span class="lineno">  545</span> </div>
<div class="line"><span class="lineno">  546</span>    <span class="keywordflow">for</span> i, x_slice <span class="keywordflow">in</span> enumerate(x_batches):</div>
<div class="line"><span class="lineno">  547</span>        X_chunk = X[x_slice].astype(np.float64)</div>
<div class="line"><span class="lineno">  548</span>        <span class="keywordflow">if</span> XX <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  549</span>            XX_chunk = row_norms(X_chunk, squared=<span class="keyword">True</span>)[:, np.newaxis]</div>
<div class="line"><span class="lineno">  550</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  551</span>            XX_chunk = XX[x_slice]</div>
<div class="line"><span class="lineno">  552</span> </div>
<div class="line"><span class="lineno">  553</span>        y_batches = gen_batches(n_samples_Y, batch_size)</div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span>        <span class="keywordflow">for</span> j, y_slice <span class="keywordflow">in</span> enumerate(y_batches):</div>
<div class="line"><span class="lineno">  556</span>            <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y <span class="keywordflow">and</span> j &lt; i:</div>
<div class="line"><span class="lineno">  557</span>                <span class="comment"># when X is Y the distance matrix is symmetric so we only need</span></div>
<div class="line"><span class="lineno">  558</span>                <span class="comment"># to compute half of it.</span></div>
<div class="line"><span class="lineno">  559</span>                d = distances[y_slice, x_slice].T</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  562</span>                Y_chunk = Y[y_slice].astype(np.float64)</div>
<div class="line"><span class="lineno">  563</span>                <span class="keywordflow">if</span> YY <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  564</span>                    YY_chunk = row_norms(Y_chunk, squared=<span class="keyword">True</span>)[np.newaxis, :]</div>
<div class="line"><span class="lineno">  565</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  566</span>                    YY_chunk = YY[:, y_slice]</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>                d = -2 * safe_sparse_dot(X_chunk, Y_chunk.T, dense_output=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  569</span>                d += XX_chunk</div>
<div class="line"><span class="lineno">  570</span>                d += YY_chunk</div>
<div class="line"><span class="lineno">  571</span> </div>
<div class="line"><span class="lineno">  572</span>            distances[x_slice, y_slice] = d.astype(np.float32, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  573</span> </div>
<div class="line"><span class="lineno">  574</span>    <span class="keywordflow">return</span> distances</div>
<div class="line"><span class="lineno">  575</span> </div>
<div class="line"><span class="lineno">  576</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a824f424c7237174b2ed7bce510860bde" name="a824f424c7237174b2ed7bce510860bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824f424c7237174b2ed7bce510860bde">&#9670;&#160;</a></span>_pairwise_callable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._pairwise_callable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_all_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Handle the callable case for pairwise_{distances,kernels}.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1597</span><span class="keyword">def </span>_pairwise_callable(X, Y, metric, force_all_finite=True, **kwds):</div>
<div class="line"><span class="lineno"> 1598</span>    <span class="stringliteral">&quot;&quot;&quot;Handle the callable case for pairwise_{distances,kernels}.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1599</span>    X, Y = check_pairwise_arrays(X, Y, force_all_finite=force_all_finite)</div>
<div class="line"><span class="lineno"> 1600</span> </div>
<div class="line"><span class="lineno"> 1601</span>    <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y:</div>
<div class="line"><span class="lineno"> 1602</span>        <span class="comment"># Only calculate metric for upper triangle</span></div>
<div class="line"><span class="lineno"> 1603</span>        out = np.zeros((X.shape[0], Y.shape[0]), dtype=<span class="stringliteral">&quot;float&quot;</span>)</div>
<div class="line"><span class="lineno"> 1604</span>        iterator = itertools.combinations(range(X.shape[0]), 2)</div>
<div class="line"><span class="lineno"> 1605</span>        <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> iterator:</div>
<div class="line"><span class="lineno"> 1606</span>            out[i, j] = metric(X[i], Y[j], **kwds)</div>
<div class="line"><span class="lineno"> 1607</span> </div>
<div class="line"><span class="lineno"> 1608</span>        <span class="comment"># Make symmetric</span></div>
<div class="line"><span class="lineno"> 1609</span>        <span class="comment"># NB: out += out.T will produce incorrect results</span></div>
<div class="line"><span class="lineno"> 1610</span>        out = out + out.T</div>
<div class="line"><span class="lineno"> 1611</span> </div>
<div class="line"><span class="lineno"> 1612</span>        <span class="comment"># Calculate diagonal</span></div>
<div class="line"><span class="lineno"> 1613</span>        <span class="comment"># NB: nonzero diagonals are allowed for both metrics and kernels</span></div>
<div class="line"><span class="lineno"> 1614</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(X.shape[0]):</div>
<div class="line"><span class="lineno"> 1615</span>            x = X[i]</div>
<div class="line"><span class="lineno"> 1616</span>            out[i, i] = metric(x, x, **kwds)</div>
<div class="line"><span class="lineno"> 1617</span> </div>
<div class="line"><span class="lineno"> 1618</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1619</span>        <span class="comment"># Calculate all cells</span></div>
<div class="line"><span class="lineno"> 1620</span>        out = np.empty((X.shape[0], Y.shape[0]), dtype=<span class="stringliteral">&quot;float&quot;</span>)</div>
<div class="line"><span class="lineno"> 1621</span>        iterator = itertools.product(range(X.shape[0]), range(Y.shape[0]))</div>
<div class="line"><span class="lineno"> 1622</span>        <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> iterator:</div>
<div class="line"><span class="lineno"> 1623</span>            out[i, j] = metric(X[i], Y[j], **kwds)</div>
<div class="line"><span class="lineno"> 1624</span> </div>
<div class="line"><span class="lineno"> 1625</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1626</span> </div>
<div class="line"><span class="lineno"> 1627</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a064dd93ce7af42456ee77f961cf41758" name="a064dd93ce7af42456ee77f961cf41758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064dd93ce7af42456ee77f961cf41758">&#9670;&#160;</a></span>_parallel_pairwise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._parallel_pairwise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Break the pairwise matrix in n_jobs even slices
and compute them in parallel.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1570</span><span class="keyword">def </span>_parallel_pairwise(X, Y, func, n_jobs, **kwds):</div>
<div class="line"><span class="lineno"> 1571</span>    <span class="stringliteral">&quot;&quot;&quot;Break the pairwise matrix in n_jobs even slices</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    and compute them in parallel.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1573</span> </div>
<div class="line"><span class="lineno"> 1574</span>    <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1575</span>        Y = X</div>
<div class="line"><span class="lineno"> 1576</span>    X, Y, dtype = _return_float_dtype(X, Y)</div>
<div class="line"><span class="lineno"> 1577</span> </div>
<div class="line"><span class="lineno"> 1578</span>    <span class="keywordflow">if</span> effective_n_jobs(n_jobs) == 1:</div>
<div class="line"><span class="lineno"> 1579</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(X, Y, **kwds)</div>
<div class="line"><span class="lineno"> 1580</span> </div>
<div class="line"><span class="lineno"> 1581</span>    <span class="comment"># enforce a threading backend to prevent data communication overhead</span></div>
<div class="line"><span class="lineno"> 1582</span>    fd = delayed(_dist_wrapper)</div>
<div class="line"><span class="lineno"> 1583</span>    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order=<span class="stringliteral">&quot;F&quot;</span>)</div>
<div class="line"><span class="lineno"> 1584</span>    Parallel(backend=<span class="stringliteral">&quot;threading&quot;</span>, n_jobs=n_jobs)(</div>
<div class="line"><span class="lineno"> 1585</span>        fd(func, ret, s, X, Y[s], **kwds)</div>
<div class="line"><span class="lineno"> 1586</span>        <span class="keywordflow">for</span> s <span class="keywordflow">in</span> gen_even_slices(_num_samples(Y), effective_n_jobs(n_jobs))</div>
<div class="line"><span class="lineno"> 1587</span>    )</div>
<div class="line"><span class="lineno"> 1588</span> </div>
<div class="line"><span class="lineno"> 1589</span>    <span class="keywordflow">if</span> (X <span class="keywordflow">is</span> Y <span class="keywordflow">or</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> func <span class="keywordflow">is</span> euclidean_distances:</div>
<div class="line"><span class="lineno"> 1590</span>        <span class="comment"># zeroing diagonal for euclidean norm.</span></div>
<div class="line"><span class="lineno"> 1591</span>        <span class="comment"># TODO: do it also for other norms.</span></div>
<div class="line"><span class="lineno"> 1592</span>        np.fill_diagonal(ret, 0)</div>
<div class="line"><span class="lineno"> 1593</span> </div>
<div class="line"><span class="lineno"> 1594</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 1595</span> </div>
<div class="line"><span class="lineno"> 1596</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3de75fb9fea808090b4cd2fdd739e52d" name="a3de75fb9fea808090b4cd2fdd739e52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de75fb9fea808090b4cd2fdd739e52d">&#9670;&#160;</a></span>_precompute_metric_params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._precompute_metric_params </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Precompute data-derived metric parameters if not provided.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1682</span><span class="keyword">def </span>_precompute_metric_params(X, Y, metric=None, **kwds):</div>
<div class="line"><span class="lineno"> 1683</span>    <span class="stringliteral">&quot;&quot;&quot;Precompute data-derived metric parameters if not provided.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1684</span>    <span class="keywordflow">if</span> metric == <span class="stringliteral">&quot;seuclidean&quot;</span> <span class="keywordflow">and</span> <span class="stringliteral">&quot;V&quot;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> kwds:</div>
<div class="line"><span class="lineno"> 1685</span>        <span class="comment"># There is a bug in scipy &lt; 1.5 that will cause a crash if</span></div>
<div class="line"><span class="lineno"> 1686</span>        <span class="comment"># X.dtype != np.double (float64). See PR #15730</span></div>
<div class="line"><span class="lineno"> 1687</span>        dtype = np.float64 <span class="keywordflow">if</span> sp_version &lt; parse_version(<span class="stringliteral">&quot;1.5&quot;</span>) <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1688</span>        <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y:</div>
<div class="line"><span class="lineno"> 1689</span>            V = np.var(X, axis=0, ddof=1, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1690</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1691</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1692</span>                <span class="stringliteral">&quot;The &#39;V&#39; parameter is required for the seuclidean metric &quot;</span></div>
<div class="line"><span class="lineno"> 1693</span>                <span class="stringliteral">&quot;when Y is passed.&quot;</span></div>
<div class="line"><span class="lineno"> 1694</span>            )</div>
<div class="line"><span class="lineno"> 1695</span>        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;V&quot;</span>: V}</div>
<div class="line"><span class="lineno"> 1696</span>    <span class="keywordflow">if</span> metric == <span class="stringliteral">&quot;mahalanobis&quot;</span> <span class="keywordflow">and</span> <span class="stringliteral">&quot;VI&quot;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> kwds:</div>
<div class="line"><span class="lineno"> 1697</span>        <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y:</div>
<div class="line"><span class="lineno"> 1698</span>            VI = np.linalg.inv(np.cov(X.T)).T</div>
<div class="line"><span class="lineno"> 1699</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1700</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1701</span>                <span class="stringliteral">&quot;The &#39;VI&#39; parameter is required for the mahalanobis metric &quot;</span></div>
<div class="line"><span class="lineno"> 1702</span>                <span class="stringliteral">&quot;when Y is passed.&quot;</span></div>
<div class="line"><span class="lineno"> 1703</span>            )</div>
<div class="line"><span class="lineno"> 1704</span>        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;VI&quot;</span>: VI}</div>
<div class="line"><span class="lineno"> 1705</span>    <span class="keywordflow">return</span> {}</div>
<div class="line"><span class="lineno"> 1706</span> </div>
<div class="line"><span class="lineno"> 1707</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad26d69f9e95b50a311ada7f44259fe3a" name="ad26d69f9e95b50a311ada7f44259fe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26d69f9e95b50a311ada7f44259fe3a">&#9670;&#160;</a></span>_return_float_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise._return_float_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">1. If dtype of X and Y is float32, then dtype float32 is returned.
2. Else dtype float is returned.
</pre> <div class="fragment"><div class="line"><span class="lineno">   39</span><span class="keyword">def </span>_return_float_dtype(X, Y):</div>
<div class="line"><span class="lineno">   40</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    1. If dtype of X and Y is float32, then dtype float32 is returned.</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    2. Else dtype float is returned.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   44</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> issparse(X) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(X, np.ndarray):</div>
<div class="line"><span class="lineno">   45</span>        X = np.asarray(X)</div>
<div class="line"><span class="lineno">   46</span> </div>
<div class="line"><span class="lineno">   47</span>    <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   48</span>        Y_dtype = X.dtype</div>
<div class="line"><span class="lineno">   49</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> issparse(Y) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(Y, np.ndarray):</div>
<div class="line"><span class="lineno">   50</span>        Y = np.asarray(Y)</div>
<div class="line"><span class="lineno">   51</span>        Y_dtype = Y.dtype</div>
<div class="line"><span class="lineno">   52</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   53</span>        Y_dtype = Y.dtype</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">if</span> X.dtype == Y_dtype == np.float32:</div>
<div class="line"><span class="lineno">   56</span>        dtype = np.float32</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   58</span>        dtype = float</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>    <span class="keywordflow">return</span> X, Y, dtype</div>
<div class="line"><span class="lineno">   61</span> </div>
<div class="line"><span class="lineno">   62</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa79a81af6e4ad0fbd4a8e40498ebf2bd" name="aa79a81af6e4ad0fbd4a8e40498ebf2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79a81af6e4ad0fbd4a8e40498ebf2bd">&#9670;&#160;</a></span>additive_chi2_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.additive_chi2_kernel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the additive chi-squared kernel between observations in X and Y.

The chi-squared kernel is computed between each pair of rows in X and Y.  X
and Y have to be non-negative. This kernel is most commonly applied to
histograms.

The chi-squared kernel is given by::

    k(x, y) = -Sum [(x - y)^2 / (x + y)]

It can be interpreted as a weighted difference per entry.

Read more in the :ref:`User Guide &lt;chi2_kernel&gt;`.

Parameters
----------
X : array-like of shape (n_samples_X, n_features)
    A feature array.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. If `None`, uses `Y=X`.

Returns
-------
kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)
    The kernel matrix.

See Also
--------
chi2_kernel : The exponentiated version of the kernel, which is usually
    preferable.
sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
    to this kernel.

Notes
-----
As the negative of a distance, this kernel is only conditionally positive
definite.

References
----------
* Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
  Local features and kernels for classification of texture and object
  categories: A comprehensive study
  International Journal of Computer Vision 2007
  https://hal.archives-ouvertes.fr/hal-00171412/document
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1406</span><span class="keyword">def </span>additive_chi2_kernel(X, Y=None):</div>
<div class="line"><span class="lineno"> 1407</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the additive chi-squared kernel between observations in X and Y.</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    The chi-squared kernel is computed between each pair of rows in X and Y.  X</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    and Y have to be non-negative. This kernel is most commonly applied to</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    histograms.</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    The chi-squared kernel is given by::</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">        k(x, y) = -Sum [(x - y)^2 / (x + y)]</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    It can be interpreted as a weighted difference per entry.</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;chi2_kernel&gt;`.</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    X : array-like of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">    kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">        The kernel matrix.</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">    chi2_kernel : The exponentiated version of the kernel, which is usually</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">        preferable.</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">        to this kernel.</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    As the negative of a distance, this kernel is only conditionally positive</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    definite.</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">    * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">      Local features and kernels for classification of texture and object</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">      categories: A comprehensive study</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">      International Journal of Computer Vision 2007</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">      https://hal.archives-ouvertes.fr/hal-00171412/document</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1454</span>    <span class="keywordflow">if</span> issparse(X) <span class="keywordflow">or</span> issparse(Y):</div>
<div class="line"><span class="lineno"> 1455</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;additive_chi2 does not support sparse matrices.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1456</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1457</span>    <span class="keywordflow">if</span> (X &lt; 0).any():</div>
<div class="line"><span class="lineno"> 1458</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;X contains negative values.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1459</span>    <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> <span class="keywordflow">not</span> X <span class="keywordflow">and</span> (Y &lt; 0).any():</div>
<div class="line"><span class="lineno"> 1460</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Y contains negative values.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1461</span> </div>
<div class="line"><span class="lineno"> 1462</span>    result = np.zeros((X.shape[0], Y.shape[0]), dtype=X.dtype)</div>
<div class="line"><span class="lineno"> 1463</span>    _chi2_kernel_fast(X, Y, result)</div>
<div class="line"><span class="lineno"> 1464</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1465</span> </div>
<div class="line"><span class="lineno"> 1466</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a05ef0b68662729cbb433e3870d8fb526" name="a05ef0b68662729cbb433e3870d8fb526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ef0b68662729cbb433e3870d8fb526">&#9670;&#160;</a></span>check_paired_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.check_paired_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set X and Y appropriately and checks inputs for paired distances.

All paired distance metrics should use this function first to assert that
the given parameters are correct and safe to use.

Specifically, this function first ensures that both X and Y are arrays,
then checks that they are at least two dimensional while ensuring that
their elements are floats. Finally, the function checks that the size
of the dimensions of the two arrays are equal.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples_X, n_features)

Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)

Returns
-------
safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features)
    An array equal to X, guaranteed to be a numpy array.

safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)
    An array equal to Y if Y was not None, guaranteed to be a numpy array.
    If Y was None, safe_Y will be a pointer to X.
</pre> <div class="fragment"><div class="line"><span class="lineno">  188</span><span class="keyword">def </span>check_paired_arrays(X, Y):</div>
<div class="line"><span class="lineno">  189</span>    <span class="stringliteral">&quot;&quot;&quot;Set X and Y appropriately and checks inputs for paired distances.</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    All paired distance metrics should use this function first to assert that</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    the given parameters are correct and safe to use.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    Specifically, this function first ensures that both X and Y are arrays,</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    then checks that they are at least two dimensional while ensuring that</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    their elements are floats. Finally, the function checks that the size</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    of the dimensions of the two arrays are equal.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        An array equal to X, guaranteed to be a numpy array.</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        An array equal to Y if Y was not None, guaranteed to be a numpy array.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        If Y was None, safe_Y will be a pointer to X.</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  214</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno">  215</span>    <span class="keywordflow">if</span> X.shape != Y.shape:</div>
<div class="line"><span class="lineno">  216</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  217</span>            <span class="stringliteral">&quot;X and Y should be of same shape. They were respectively %r and %r long.&quot;</span></div>
<div class="line"><span class="lineno">  218</span>            % (X.shape, Y.shape)</div>
<div class="line"><span class="lineno">  219</span>        )</div>
<div class="line"><span class="lineno">  220</span>    <span class="keywordflow">return</span> X, Y</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span><span class="comment"># Pairwise distances</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5eeca81e0a9c505d4db97716bba20f96" name="a5eeca81e0a9c505d4db97716bba20f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeca81e0a9c505d4db97716bba20f96">&#9670;&#160;</a></span>check_pairwise_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.check_pairwise_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>precomputed</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accept_sparse</em> = <code>&quot;csr&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_all_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set X and Y appropriately and checks inputs.

If Y is None, it is set as a pointer to X (i.e. not a copy).
If Y is given, this does not happen.
All distance metrics should use this function first to assert that the
given parameters are correct and safe to use.

Specifically, this function first ensures that both X and Y are arrays,
then checks that they are at least two dimensional while ensuring that
their elements are floats (or dtype if provided). Finally, the function
checks that the size of the second dimension of the two arrays is equal, or
the equivalent check for a precomputed distance matrix.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples_X, n_features)

Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)

precomputed : bool, default=False
    True if X is to be treated as precomputed distances to the samples in
    Y.

dtype : str, type, list of type, default=None
    Data type required for X and Y. If None, the dtype will be an
    appropriate float type selected by _return_float_dtype.

    .. versionadded:: 0.18

accept_sparse : str, bool or list/tuple of str, default='csr'
    String[s] representing allowed sparse matrix formats, such as 'csc',
    'csr', etc. If the input is sparse but not in the allowed format,
    it will be converted to the first listed format. True allows the input
    to be any format. False means that a sparse matrix input will
    raise an error.

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in array. The
    possibilities are:

    - True: Force all values of array to be finite.
    - False: accepts np.inf, np.nan, pd.NA in array.
    - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
      cannot be infinite.

    .. versionadded:: 0.22
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`.

copy : bool, default=False
    Whether a forced copy will be triggered. If copy=False, a copy might
    be triggered by a conversion.

    .. versionadded:: 0.22

Returns
-------
safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features)
    An array equal to X, guaranteed to be a numpy array.

safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)
    An array equal to Y if Y was not None, guaranteed to be a numpy array.
    If Y was None, safe_Y will be a pointer to X.
</pre> <div class="fragment"><div class="line"><span class="lineno">   72</span>):</div>
<div class="line"><span class="lineno">   73</span>    <span class="stringliteral">&quot;&quot;&quot;Set X and Y appropriately and checks inputs.</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    If Y is None, it is set as a pointer to X (i.e. not a copy).</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    If Y is given, this does not happen.</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    All distance metrics should use this function first to assert that the</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    given parameters are correct and safe to use.</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    Specifically, this function first ensures that both X and Y are arrays,</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    then checks that they are at least two dimensional while ensuring that</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    their elements are floats (or dtype if provided). Finally, the function</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    checks that the size of the second dimension of the two arrays is equal, or</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    the equivalent check for a precomputed distance matrix.</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    precomputed : bool, default=False</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        True if X is to be treated as precomputed distances to the samples in</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        Y.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    dtype : str, type, list of type, default=None</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        Data type required for X and Y. If None, the dtype will be an</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        appropriate float type selected by _return_float_dtype.</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        .. versionadded:: 0.18</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    accept_sparse : str, bool or list/tuple of str, default=&#39;csr&#39;</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        String[s] representing allowed sparse matrix formats, such as &#39;csc&#39;,</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        &#39;csr&#39;, etc. If the input is sparse but not in the allowed format,</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        it will be converted to the first listed format. True allows the input</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        to be any format. False means that a sparse matrix input will</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        raise an error.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    force_all_finite : bool or &#39;allow-nan&#39;, default=True</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        Whether to raise an error on np.inf, np.nan, pd.NA in array. The</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        possibilities are:</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        - True: Force all values of array to be finite.</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        - False: accepts np.inf, np.nan, pd.NA in array.</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        - &#39;allow-nan&#39;: accepts only np.nan and pd.NA values in array. Values</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">          cannot be infinite.</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        .. versionadded:: 0.22</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">           ``force_all_finite`` accepts the string ``&#39;allow-nan&#39;``.</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        .. versionchanged:: 0.23</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">           Accepts `pd.NA` and converts it into `np.nan`.</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    copy : bool, default=False</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        Whether a forced copy will be triggered. If copy=False, a copy might</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        be triggered by a conversion.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        .. versionadded:: 0.22</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">        An array equal to X, guaranteed to be a numpy array.</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        An array equal to Y if Y was not None, guaranteed to be a numpy array.</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        If Y was None, safe_Y will be a pointer to X.</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  139</span>    X, Y, dtype_float = _return_float_dtype(X, Y)</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>    estimator = <span class="stringliteral">&quot;check_pairwise_arrays&quot;</span></div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  143</span>        dtype = dtype_float</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> X <span class="keywordflow">or</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  146</span>        X = Y = check_array(</div>
<div class="line"><span class="lineno">  147</span>            X,</div>
<div class="line"><span class="lineno">  148</span>            accept_sparse=accept_sparse,</div>
<div class="line"><span class="lineno">  149</span>            dtype=dtype,</div>
<div class="line"><span class="lineno">  150</span>            copy=copy,</div>
<div class="line"><span class="lineno">  151</span>            force_all_finite=force_all_finite,</div>
<div class="line"><span class="lineno">  152</span>            estimator=estimator,</div>
<div class="line"><span class="lineno">  153</span>        )</div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  155</span>        X = check_array(</div>
<div class="line"><span class="lineno">  156</span>            X,</div>
<div class="line"><span class="lineno">  157</span>            accept_sparse=accept_sparse,</div>
<div class="line"><span class="lineno">  158</span>            dtype=dtype,</div>
<div class="line"><span class="lineno">  159</span>            copy=copy,</div>
<div class="line"><span class="lineno">  160</span>            force_all_finite=force_all_finite,</div>
<div class="line"><span class="lineno">  161</span>            estimator=estimator,</div>
<div class="line"><span class="lineno">  162</span>        )</div>
<div class="line"><span class="lineno">  163</span>        Y = check_array(</div>
<div class="line"><span class="lineno">  164</span>            Y,</div>
<div class="line"><span class="lineno">  165</span>            accept_sparse=accept_sparse,</div>
<div class="line"><span class="lineno">  166</span>            dtype=dtype,</div>
<div class="line"><span class="lineno">  167</span>            copy=copy,</div>
<div class="line"><span class="lineno">  168</span>            force_all_finite=force_all_finite,</div>
<div class="line"><span class="lineno">  169</span>            estimator=estimator,</div>
<div class="line"><span class="lineno">  170</span>        )</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordflow">if</span> precomputed:</div>
<div class="line"><span class="lineno">  173</span>        <span class="keywordflow">if</span> X.shape[1] != Y.shape[0]:</div>
<div class="line"><span class="lineno">  174</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  175</span>                <span class="stringliteral">&quot;Precomputed metric requires shape &quot;</span></div>
<div class="line"><span class="lineno">  176</span>                <span class="stringliteral">&quot;(n_queries, n_indexed). Got (%d, %d) &quot;</span></div>
<div class="line"><span class="lineno">  177</span>                <span class="stringliteral">&quot;for %d indexed.&quot;</span> % (X.shape[0], X.shape[1], Y.shape[0])</div>
<div class="line"><span class="lineno">  178</span>            )</div>
<div class="line"><span class="lineno">  179</span>    <span class="keywordflow">elif</span> X.shape[1] != Y.shape[1]:</div>
<div class="line"><span class="lineno">  180</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  181</span>            <span class="stringliteral">&quot;Incompatible dimension for X and Y matrices: &quot;</span></div>
<div class="line"><span class="lineno">  182</span>            <span class="stringliteral">&quot;X.shape[1] == %d while Y.shape[1] == %d&quot;</span> % (X.shape[1], Y.shape[1])</div>
<div class="line"><span class="lineno">  183</span>        )</div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span>    <span class="keywordflow">return</span> X, Y</div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ada08aa64e7efa1f43111a82fb315d9ab" name="ada08aa64e7efa1f43111a82fb315d9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada08aa64e7efa1f43111a82fb315d9ab">&#9670;&#160;</a></span>chi2_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.chi2_kernel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the exponential chi-squared kernel between X and Y.

The chi-squared kernel is computed between each pair of rows in X and Y.  X
and Y have to be non-negative. This kernel is most commonly applied to
histograms.

The chi-squared kernel is given by::

    k(x, y) = exp(-gamma Sum [(x - y)^2 / (x + y)])

It can be interpreted as a weighted difference per entry.

Read more in the :ref:`User Guide &lt;chi2_kernel&gt;`.

Parameters
----------
X : array-like of shape (n_samples_X, n_features)
    A feature array.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. If `None`, uses `Y=X`.

gamma : float, default=1
    Scaling parameter of the chi2 kernel.

Returns
-------
kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)
    The kernel matrix.

See Also
--------
additive_chi2_kernel : The additive version of this kernel.
sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
    to the additive version of this kernel.

References
----------
* Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
  Local features and kernels for classification of texture and object
  categories: A comprehensive study
  International Journal of Computer Vision 2007
  https://hal.archives-ouvertes.fr/hal-00171412/document
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1467</span><span class="keyword">def </span>chi2_kernel(X, Y=None, gamma=1.0):</div>
<div class="line"><span class="lineno"> 1468</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the exponential chi-squared kernel between X and Y.</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">    The chi-squared kernel is computed between each pair of rows in X and Y.  X</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">    and Y have to be non-negative. This kernel is most commonly applied to</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    histograms.</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">    The chi-squared kernel is given by::</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">        k(x, y) = exp(-gamma Sum [(x - y)^2 / (x + y)])</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">    It can be interpreted as a weighted difference per entry.</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;chi2_kernel&gt;`.</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">    X : array-like of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">    gamma : float, default=1</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">        Scaling parameter of the chi2 kernel.</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">    kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">        The kernel matrix.</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">    additive_chi2_kernel : The additive version of this kernel.</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">        to the additive version of this kernel.</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">    * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">      Local features and kernels for classification of texture and object</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">      categories: A comprehensive study</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">      International Journal of Computer Vision 2007</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">      https://hal.archives-ouvertes.fr/hal-00171412/document</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1512</span>    K = additive_chi2_kernel(X, Y)</div>
<div class="line"><span class="lineno"> 1513</span>    K *= gamma</div>
<div class="line"><span class="lineno"> 1514</span>    <span class="keywordflow">return</span> np.exp(K, K)</div>
<div class="line"><span class="lineno"> 1515</span> </div>
<div class="line"><span class="lineno"> 1516</span> </div>
<div class="line"><span class="lineno"> 1517</span><span class="comment"># Helper functions - distance</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae97a1aa563d8a29eb417b12c4e811620" name="ae97a1aa563d8a29eb417b12c4e811620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97a1aa563d8a29eb417b12c4e811620">&#9670;&#160;</a></span>cosine_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.cosine_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute cosine distance between samples in X and Y.

Cosine distance is defined as 1.0 minus the cosine similarity.

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples_X, n_features)
    Matrix `X`.

Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \
        default=None
    Matrix `Y`.

Returns
-------
distance matrix : ndarray of shape (n_samples_X, n_samples_Y)
    Returns the cosine distance between samples in X and Y.

See Also
--------
cosine_similarity : Compute cosine similarity between samples in X and Y.
scipy.spatial.distance.cosine : Dense matrices only.
</pre> <div class="fragment"><div class="line"><span class="lineno">  973</span><span class="keyword">def </span>cosine_distances(X, Y=None):</div>
<div class="line"><span class="lineno">  974</span>    <span class="stringliteral">&quot;&quot;&quot;Compute cosine distance between samples in X and Y.</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    Cosine distance is defined as 1.0 minus the cosine similarity.</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">        Matrix `X`.</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">            default=None</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">        Matrix `Y`.</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    distance matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">        Returns the cosine distance between samples in X and Y.</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    cosine_similarity : Compute cosine similarity between samples in X and Y.</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    scipy.spatial.distance.cosine : Dense matrices only.</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  999</span>    <span class="comment"># 1.0 - cosine_similarity(X, Y) without copy</span></div>
<div class="line"><span class="lineno"> 1000</span>    S = cosine_similarity(X, Y)</div>
<div class="line"><span class="lineno"> 1001</span>    S *= -1</div>
<div class="line"><span class="lineno"> 1002</span>    S += 1</div>
<div class="line"><span class="lineno"> 1003</span>    np.clip(S, 0, 2, out=S)</div>
<div class="line"><span class="lineno"> 1004</span>    <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y <span class="keywordflow">or</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1005</span>        <span class="comment"># Ensure that distances between vectors and themselves are set to 0.0.</span></div>
<div class="line"><span class="lineno"> 1006</span>        <span class="comment"># This may not be the case due to floating point rounding errors.</span></div>
<div class="line"><span class="lineno"> 1007</span>        S[np.diag_indices_from(S)] = 0.0</div>
<div class="line"><span class="lineno"> 1008</span>    <span class="keywordflow">return</span> S</div>
<div class="line"><span class="lineno"> 1009</span> </div>
<div class="line"><span class="lineno"> 1010</span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="comment"># Paired distances</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c3e46306103c1b7c394d6236360960c" name="a1c3e46306103c1b7c394d6236360960c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3e46306103c1b7c394d6236360960c">&#9670;&#160;</a></span>cosine_similarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.cosine_similarity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dense_output</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute cosine similarity between samples in X and Y.

Cosine similarity, or the cosine kernel, computes similarity as the
normalized dot product of X and Y:

    K(X, Y) = &lt;X, Y&gt; / (||X||*||Y||)

On L2-normalized data, this function is equivalent to linear_kernel.

Read more in the :ref:`User Guide &lt;cosine_similarity&gt;`.

Parameters
----------
X : {ndarray, sparse matrix} of shape (n_samples_X, n_features)
    Input data.

Y : {ndarray, sparse matrix} of shape (n_samples_Y, n_features), \
        default=None
    Input data. If ``None``, the output will be the pairwise
    similarities between all samples in ``X``.

dense_output : bool, default=True
    Whether to return dense output even when the input is sparse. If
    ``False``, the output is sparse if both input arrays are sparse.

    .. versionadded:: 0.17
       parameter ``dense_output`` for dense output.

Returns
-------
kernel matrix : ndarray of shape (n_samples_X, n_samples_Y)
    Returns the cosine similarity between samples in X and Y.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1357</span><span class="keyword">def </span>cosine_similarity(X, Y=None, dense_output=True):</div>
<div class="line"><span class="lineno"> 1358</span>    <span class="stringliteral">&quot;&quot;&quot;Compute cosine similarity between samples in X and Y.</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    Cosine similarity, or the cosine kernel, computes similarity as the</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    normalized dot product of X and Y:</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">        K(X, Y) = &lt;X, Y&gt; / (||X||*||Y||)</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    On L2-normalized data, this function is equivalent to linear_kernel.</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;cosine_similarity&gt;`.</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    X : {ndarray, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    Y : {ndarray, sparse matrix} of shape (n_samples_Y, n_features), \</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">            default=None</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">        Input data. If ``None``, the output will be the pairwise</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">        similarities between all samples in ``X``.</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    dense_output : bool, default=True</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">        Whether to return dense output even when the input is sparse. If</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">        ``False``, the output is sparse if both input arrays are sparse.</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">        .. versionadded:: 0.17</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">           parameter ``dense_output`` for dense output.</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    kernel matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">        Returns the cosine similarity between samples in X and Y.</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1391</span>    <span class="comment"># to avoid recursive import</span></div>
<div class="line"><span class="lineno"> 1392</span> </div>
<div class="line"><span class="lineno"> 1393</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1394</span> </div>
<div class="line"><span class="lineno"> 1395</span>    X_normalized = normalize(X, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1396</span>    <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y:</div>
<div class="line"><span class="lineno"> 1397</span>        Y_normalized = X_normalized</div>
<div class="line"><span class="lineno"> 1398</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1399</span>        Y_normalized = normalize(Y, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1400</span> </div>
<div class="line"><span class="lineno"> 1401</span>    K = safe_sparse_dot(X_normalized, Y_normalized.T, dense_output=dense_output)</div>
<div class="line"><span class="lineno"> 1402</span> </div>
<div class="line"><span class="lineno"> 1403</span>    <span class="keywordflow">return</span> K</div>
<div class="line"><span class="lineno"> 1404</span> </div>
<div class="line"><span class="lineno"> 1405</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4e4e07bc5d8095cd44d095cb8073eb3" name="aa4e4e07bc5d8095cd44d095cb8073eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e4e07bc5d8095cd44d095cb8073eb3">&#9670;&#160;</a></span>distance_metrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.distance_metrics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Valid metrics for pairwise_distances.

This function simply returns the valid pairwise distance metrics.
It exists to allow for a description of the mapping for
each of the valid strings.

The valid distance metrics, and the function they map to, are:

=============== ========================================
metric          Function
=============== ========================================
'cityblock'     metrics.pairwise.manhattan_distances
'cosine'        metrics.pairwise.cosine_distances
'euclidean'     metrics.pairwise.euclidean_distances
'haversine'     metrics.pairwise.haversine_distances
'l1'            metrics.pairwise.manhattan_distances
'l2'            metrics.pairwise.euclidean_distances
'manhattan'     metrics.pairwise.manhattan_distances
'nan_euclidean' metrics.pairwise.nan_euclidean_distances
=============== ========================================

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Returns
-------
distance_metrics : dict
    Returns valid metrics for pairwise_distances.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1533</span><span class="keyword">def </span>distance_metrics():</div>
<div class="line"><span class="lineno"> 1534</span>    <span class="stringliteral">&quot;&quot;&quot;Valid metrics for pairwise_distances.</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">    This function simply returns the valid pairwise distance metrics.</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    It exists to allow for a description of the mapping for</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    each of the valid strings.</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    The valid distance metrics, and the function they map to, are:</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    =============== ========================================</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    metric          Function</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    =============== ========================================</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    &#39;cityblock&#39;     metrics.pairwise.manhattan_distances</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">    &#39;cosine&#39;        metrics.pairwise.cosine_distances</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    &#39;euclidean&#39;     metrics.pairwise.euclidean_distances</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    &#39;haversine&#39;     metrics.pairwise.haversine_distances</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    &#39;l1&#39;            metrics.pairwise.manhattan_distances</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    &#39;l2&#39;            metrics.pairwise.euclidean_distances</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    &#39;manhattan&#39;     metrics.pairwise.manhattan_distances</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    &#39;nan_euclidean&#39; metrics.pairwise.nan_euclidean_distances</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    =============== ========================================</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    distance_metrics : dict</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">        Returns valid metrics for pairwise_distances.</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1562</span>    <span class="keywordflow">return</span> PAIRWISE_DISTANCE_FUNCTIONS</div>
<div class="line"><span class="lineno"> 1563</span> </div>
<div class="line"><span class="lineno"> 1564</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3204eff491cab671ef18548454b65f37" name="a3204eff491cab671ef18548454b65f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3204eff491cab671ef18548454b65f37">&#9670;&#160;</a></span>euclidean_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.euclidean_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>Y_norm_squared</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>squared</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X_norm_squared</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the distance matrix between each pair from a vector array X and Y.

For efficiency reasons, the euclidean distance between a pair of row
vector x and y is computed as::

    dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y))

This formulation has two advantages over other ways of computing distances.
First, it is computationally efficient when dealing with sparse data.
Second, if one argument varies but the other remains unchanged, then
`dot(x, x)` and/or `dot(y, y)` can be pre-computed.

However, this is not the most precise way of doing this computation,
because this equation potentially suffers from "catastrophic cancellation".
Also, the distance matrix returned by this function may not be exactly
symmetric as required by, e.g., ``scipy.spatial.distance`` functions.

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples_X, n_features)
    An array where each row is a sample and each column is a feature.

Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \
        default=None
    An array where each row is a sample and each column is a feature.
    If `None`, method uses `Y=X`.

Y_norm_squared : array-like of shape (n_samples_Y,) or (n_samples_Y, 1) \
        or (1, n_samples_Y), default=None
    Pre-computed dot-products of vectors in Y (e.g.,
    ``(Y**2).sum(axis=1)``)
    May be ignored in some cases, see the note below.

squared : bool, default=False
    Return squared Euclidean distances.

X_norm_squared : array-like of shape (n_samples_X,) or (n_samples_X, 1) \
        or (1, n_samples_X), default=None
    Pre-computed dot-products of vectors in X (e.g.,
    ``(X**2).sum(axis=1)``)
    May be ignored in some cases, see the note below.

Returns
-------
distances : ndarray of shape (n_samples_X, n_samples_Y)
    Returns the distances between the row vectors of `X`
    and the row vectors of `Y`.

See Also
--------
paired_distances : Distances betweens pairs of elements of X and Y.

Notes
-----
To achieve a better accuracy, `X_norm_squared` and `Y_norm_squared` may be
unused if they are passed as `np.float32`.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics.pairwise import euclidean_distances
&gt;&gt;&gt; X = [[0, 1], [1, 1]]
&gt;&gt;&gt; # distance between rows of X
&gt;&gt;&gt; euclidean_distances(X, X)
array([[0., 1.],
       [1., 0.]])
&gt;&gt;&gt; # get distance to origin
&gt;&gt;&gt; euclidean_distances(X, [[0, 0]])
array([[1.        ],
       [1.41421356]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  226</span>):</div>
<div class="line"><span class="lineno">  227</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Compute the distance matrix between each pair from a vector array X and Y.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    For efficiency reasons, the euclidean distance between a pair of row</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    vector x and y is computed as::</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y))</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    This formulation has two advantages over other ways of computing distances.</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    First, it is computationally efficient when dealing with sparse data.</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    Second, if one argument varies but the other remains unchanged, then</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    `dot(x, x)` and/or `dot(y, y)` can be pre-computed.</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    However, this is not the most precise way of doing this computation,</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    because this equation potentially suffers from &quot;catastrophic cancellation&quot;.</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    Also, the distance matrix returned by this function may not be exactly</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    symmetric as required by, e.g., ``scipy.spatial.distance`` functions.</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">            default=None</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">        If `None`, method uses `Y=X`.</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    Y_norm_squared : array-like of shape (n_samples_Y,) or (n_samples_Y, 1) \</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">            or (1, n_samples_Y), default=None</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        Pre-computed dot-products of vectors in Y (e.g.,</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        ``(Y**2).sum(axis=1)``)</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        May be ignored in some cases, see the note below.</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    squared : bool, default=False</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">        Return squared Euclidean distances.</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    X_norm_squared : array-like of shape (n_samples_X,) or (n_samples_X, 1) \</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">            or (1, n_samples_X), default=None</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        Pre-computed dot-products of vectors in X (e.g.,</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">        ``(X**2).sum(axis=1)``)</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">        May be ignored in some cases, see the note below.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    distances : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        Returns the distances between the row vectors of `X`</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        and the row vectors of `Y`.</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    paired_distances : Distances betweens pairs of elements of X and Y.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    To achieve a better accuracy, `X_norm_squared` and `Y_norm_squared` may be</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    unused if they are passed as `np.float32`.</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics.pairwise import euclidean_distances</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 1], [1, 1]]</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    &gt;&gt;&gt; # distance between rows of X</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    &gt;&gt;&gt; euclidean_distances(X, X)</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    array([[0., 1.],</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">           [1., 0.]])</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    &gt;&gt;&gt; # get distance to origin</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    &gt;&gt;&gt; euclidean_distances(X, [[0, 0]])</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    array([[1.        ],</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">           [1.41421356]])</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  300</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>    <span class="keywordflow">if</span> X_norm_squared <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  303</span>        X_norm_squared = check_array(X_norm_squared, ensure_2d=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  304</span>        original_shape = X_norm_squared.shape</div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordflow">if</span> X_norm_squared.shape == (X.shape[0],):</div>
<div class="line"><span class="lineno">  306</span>            X_norm_squared = X_norm_squared.reshape(-1, 1)</div>
<div class="line"><span class="lineno">  307</span>        <span class="keywordflow">if</span> X_norm_squared.shape == (1, X.shape[0]):</div>
<div class="line"><span class="lineno">  308</span>            X_norm_squared = X_norm_squared.T</div>
<div class="line"><span class="lineno">  309</span>        <span class="keywordflow">if</span> X_norm_squared.shape != (X.shape[0], 1):</div>
<div class="line"><span class="lineno">  310</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  311</span>                f<span class="stringliteral">&quot;Incompatible dimensions for X of shape {X.shape} and &quot;</span></div>
<div class="line"><span class="lineno">  312</span>                f<span class="stringliteral">&quot;X_norm_squared of shape {original_shape}.&quot;</span></div>
<div class="line"><span class="lineno">  313</span>            )</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>    <span class="keywordflow">if</span> Y_norm_squared <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  316</span>        Y_norm_squared = check_array(Y_norm_squared, ensure_2d=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  317</span>        original_shape = Y_norm_squared.shape</div>
<div class="line"><span class="lineno">  318</span>        <span class="keywordflow">if</span> Y_norm_squared.shape == (Y.shape[0],):</div>
<div class="line"><span class="lineno">  319</span>            Y_norm_squared = Y_norm_squared.reshape(1, -1)</div>
<div class="line"><span class="lineno">  320</span>        <span class="keywordflow">if</span> Y_norm_squared.shape == (Y.shape[0], 1):</div>
<div class="line"><span class="lineno">  321</span>            Y_norm_squared = Y_norm_squared.T</div>
<div class="line"><span class="lineno">  322</span>        <span class="keywordflow">if</span> Y_norm_squared.shape != (1, Y.shape[0]):</div>
<div class="line"><span class="lineno">  323</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  324</span>                f<span class="stringliteral">&quot;Incompatible dimensions for Y of shape {Y.shape} and &quot;</span></div>
<div class="line"><span class="lineno">  325</span>                f<span class="stringliteral">&quot;Y_norm_squared of shape {original_shape}.&quot;</span></div>
<div class="line"><span class="lineno">  326</span>            )</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span>    <span class="keywordflow">return</span> _euclidean_distances(X, Y, X_norm_squared, Y_norm_squared, squared)</div>
<div class="line"><span class="lineno">  329</span> </div>
<div class="line"><span class="lineno">  330</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a99876a97ceaba6938d9a4bc174e8f06a" name="a99876a97ceaba6938d9a4bc174e8f06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99876a97ceaba6938d9a4bc174e8f06a">&#9670;&#160;</a></span>haversine_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.haversine_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Haversine distance between samples in X and Y.

The Haversine (or great circle) distance is the angular distance between
two points on the surface of a sphere. The first coordinate of each point
is assumed to be the latitude, the second is the longitude, given
in radians. The dimension of the data must be 2.

.. math::
   D(x, y) = 2\\arcsin[\\sqrt{\\sin^2((x1 - y1) / 2)
                            + \\cos(x1)\\cos(y1)\\sin^2((x2 - y2) / 2)}]

Parameters
----------
X : array-like of shape (n_samples_X, 2)
    A feature array.

Y : array-like of shape (n_samples_Y, 2), default=None
    An optional second feature array. If `None`, uses `Y=X`.

Returns
-------
distance : ndarray of shape (n_samples_X, n_samples_Y)
    The distance matrix.

Notes
-----
As the Earth is nearly spherical, the haversine formula provides a good
approximation of the distance between two points of the Earth surface, with
a less than 1% error on average.

Examples
--------
We want to calculate the distance between the Ezeiza Airport
(Buenos Aires, Argentina) and the Charles de Gaulle Airport (Paris,
France).

&gt;&gt;&gt; from sklearn.metrics.pairwise import haversine_distances
&gt;&gt;&gt; from math import radians
&gt;&gt;&gt; bsas = [-34.83333, -58.5166646]
&gt;&gt;&gt; paris = [49.0083899664, 2.53844117956]
&gt;&gt;&gt; bsas_in_radians = [radians(_) for _ in bsas]
&gt;&gt;&gt; paris_in_radians = [radians(_) for _ in paris]
&gt;&gt;&gt; result = haversine_distances([bsas_in_radians, paris_in_radians])
&gt;&gt;&gt; result * 6371000/1000  # multiply by Earth radius to get kilometers
array([[    0.        , 11099.54035582],
       [11099.54035582,     0.        ]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  829</span><span class="keyword">def </span>haversine_distances(X, Y=None):</div>
<div class="line"><span class="lineno">  830</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the Haversine distance between samples in X and Y.</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    The Haversine (or great circle) distance is the angular distance between</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    two points on the surface of a sphere. The first coordinate of each point</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    is assumed to be the latitude, the second is the longitude, given</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    in radians. The dimension of the data must be 2.</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">       D(x, y) = 2\\arcsin[\\sqrt{\\sin^2((x1 - y1) / 2)</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">                                + \\cos(x1)\\cos(y1)\\sin^2((x2 - y2) / 2)}]</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">    X : array-like of shape (n_samples_X, 2)</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    Y : array-like of shape (n_samples_Y, 2), default=None</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    distance : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">        The distance matrix.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    As the Earth is nearly spherical, the haversine formula provides a good</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    approximation of the distance between two points of the Earth surface, with</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    a less than 1% error on average.</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    We want to calculate the distance between the Ezeiza Airport</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    (Buenos Aires, Argentina) and the Charles de Gaulle Airport (Paris,</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    France).</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics.pairwise import haversine_distances</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    &gt;&gt;&gt; from math import radians</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    &gt;&gt;&gt; bsas = [-34.83333, -58.5166646]</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    &gt;&gt;&gt; paris = [49.0083899664, 2.53844117956]</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    &gt;&gt;&gt; bsas_in_radians = [radians(_) for _ in bsas]</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    &gt;&gt;&gt; paris_in_radians = [radians(_) for _ in paris]</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    &gt;&gt;&gt; result = haversine_distances([bsas_in_radians, paris_in_radians])</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    &gt;&gt;&gt; result * 6371000/1000  # multiply by Earth radius to get kilometers</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    array([[    0.        , 11099.54035582],</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">           [11099.54035582,     0.        ]])</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  877</span>    <span class="keyword">from</span> ..metrics <span class="keyword">import</span> DistanceMetric</div>
<div class="line"><span class="lineno">  878</span> </div>
<div class="line"><span class="lineno">  879</span>    <span class="keywordflow">return</span> DistanceMetric.get_metric(<span class="stringliteral">&quot;haversine&quot;</span>).pairwise(X, Y)</div>
<div class="line"><span class="lineno">  880</span> </div>
<div class="line"><span class="lineno">  881</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa93c078e291ecf01cfad88c8a6b6d6cd" name="aa93c078e291ecf01cfad88c8a6b6d6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93c078e291ecf01cfad88c8a6b6d6cd">&#9670;&#160;</a></span>kernel_metrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.kernel_metrics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Valid metrics for pairwise_kernels.

This function simply returns the valid pairwise distance metrics.
It exists, however, to allow for a verbose description of the mapping for
each of the valid strings.

The valid distance metrics, and the function they map to, are:
  ===============   ========================================
  metric            Function
  ===============   ========================================
  'additive_chi2'   sklearn.pairwise.additive_chi2_kernel
  'chi2'            sklearn.pairwise.chi2_kernel
  'linear'          sklearn.pairwise.linear_kernel
  'poly'            sklearn.pairwise.polynomial_kernel
  'polynomial'      sklearn.pairwise.polynomial_kernel
  'rbf'             sklearn.pairwise.rbf_kernel
  'laplacian'       sklearn.pairwise.laplacian_kernel
  'sigmoid'         sklearn.pairwise.sigmoid_kernel
  'cosine'          sklearn.pairwise.cosine_similarity
  ===============   ========================================

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Returns
-------
kernal_metrics : dict
    Returns valid metrics for pairwise_kernels.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2071</span><span class="keyword">def </span>kernel_metrics():</div>
<div class="line"><span class="lineno"> 2072</span>    <span class="stringliteral">&quot;&quot;&quot;Valid metrics for pairwise_kernels.</span></div>
<div class="line"><span class="lineno"> 2073</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2074</span><span class="stringliteral">    This function simply returns the valid pairwise distance metrics.</span></div>
<div class="line"><span class="lineno"> 2075</span><span class="stringliteral">    It exists, however, to allow for a verbose description of the mapping for</span></div>
<div class="line"><span class="lineno"> 2076</span><span class="stringliteral">    each of the valid strings.</span></div>
<div class="line"><span class="lineno"> 2077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2078</span><span class="stringliteral">    The valid distance metrics, and the function they map to, are:</span></div>
<div class="line"><span class="lineno"> 2079</span><span class="stringliteral">      ===============   ========================================</span></div>
<div class="line"><span class="lineno"> 2080</span><span class="stringliteral">      metric            Function</span></div>
<div class="line"><span class="lineno"> 2081</span><span class="stringliteral">      ===============   ========================================</span></div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">      &#39;additive_chi2&#39;   sklearn.pairwise.additive_chi2_kernel</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral">      &#39;chi2&#39;            sklearn.pairwise.chi2_kernel</span></div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">      &#39;linear&#39;          sklearn.pairwise.linear_kernel</span></div>
<div class="line"><span class="lineno"> 2085</span><span class="stringliteral">      &#39;poly&#39;            sklearn.pairwise.polynomial_kernel</span></div>
<div class="line"><span class="lineno"> 2086</span><span class="stringliteral">      &#39;polynomial&#39;      sklearn.pairwise.polynomial_kernel</span></div>
<div class="line"><span class="lineno"> 2087</span><span class="stringliteral">      &#39;rbf&#39;             sklearn.pairwise.rbf_kernel</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral">      &#39;laplacian&#39;       sklearn.pairwise.laplacian_kernel</span></div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral">      &#39;sigmoid&#39;         sklearn.pairwise.sigmoid_kernel</span></div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral">      &#39;cosine&#39;          sklearn.pairwise.cosine_similarity</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">      ===============   ========================================</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">    kernal_metrics : dict</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral">        Returns valid metrics for pairwise_kernels.</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2100</span>    <span class="keywordflow">return</span> PAIRWISE_KERNEL_FUNCTIONS</div>
<div class="line"><span class="lineno"> 2101</span> </div>
<div class="line"><span class="lineno"> 2102</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0265ee042d09f3a514564e2e86d349a3" name="a0265ee042d09f3a514564e2e86d349a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0265ee042d09f3a514564e2e86d349a3">&#9670;&#160;</a></span>laplacian_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.laplacian_kernel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the laplacian kernel between X and Y.

The laplacian kernel is defined as::

    K(x, y) = exp(-gamma ||x-y||_1)

for each pair of rows x in X and y in Y.
Read more in the :ref:`User Guide &lt;laplacian_kernel&gt;`.

.. versionadded:: 0.17

Parameters
----------
X : ndarray of shape (n_samples_X, n_features)
    A feature array.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. If `None`, uses `Y=X`.

gamma : float, default=None
    If None, defaults to 1.0 / n_features.

Returns
-------
kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)
    The kernel matrix.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1320</span><span class="keyword">def </span>laplacian_kernel(X, Y=None, gamma=None):</div>
<div class="line"><span class="lineno"> 1321</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the laplacian kernel between X and Y.</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    The laplacian kernel is defined as::</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">        K(x, y) = exp(-gamma ||x-y||_1)</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    for each pair of rows x in X and y in Y.</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;laplacian_kernel&gt;`.</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    .. versionadded:: 0.17</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    gamma : float, default=None</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        If None, defaults to 1.0 / n_features.</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">        The kernel matrix.</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1348</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1349</span>    <span class="keywordflow">if</span> gamma <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1350</span>        gamma = 1.0 / X.shape[1]</div>
<div class="line"><span class="lineno"> 1351</span> </div>
<div class="line"><span class="lineno"> 1352</span>    K = -gamma * manhattan_distances(X, Y)</div>
<div class="line"><span class="lineno"> 1353</span>    np.exp(K, K)  <span class="comment"># exponentiate K in-place</span></div>
<div class="line"><span class="lineno"> 1354</span>    <span class="keywordflow">return</span> K</div>
<div class="line"><span class="lineno"> 1355</span> </div>
<div class="line"><span class="lineno"> 1356</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abceabe6742da2d54c397aa5aa8bb9be2" name="abceabe6742da2d54c397aa5aa8bb9be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abceabe6742da2d54c397aa5aa8bb9be2">&#9670;&#160;</a></span>linear_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.linear_kernel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dense_output</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the linear kernel between X and Y.

Read more in the :ref:`User Guide &lt;linear_kernel&gt;`.

Parameters
----------
X : ndarray of shape (n_samples_X, n_features)
    A feature array.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. If `None`, uses `Y=X`.

dense_output : bool, default=True
    Whether to return dense output even when the input is sparse. If
    ``False``, the output is sparse if both input arrays are sparse.

    .. versionadded:: 0.20

Returns
-------
Gram matrix : ndarray of shape (n_samples_X, n_samples_Y)
    The Gram matrix of the linear kernel, i.e. `X @ Y.T`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1178</span><span class="keyword">def </span>linear_kernel(X, Y=None, dense_output=True):</div>
<div class="line"><span class="lineno"> 1179</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    Compute the linear kernel between X and Y.</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;linear_kernel&gt;`.</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    dense_output : bool, default=True</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">        Whether to return dense output even when the input is sparse. If</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">        ``False``, the output is sparse if both input arrays are sparse.</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    Gram matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">        The Gram matrix of the linear kernel, i.e. `X @ Y.T`.</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1203</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1204</span>    <span class="keywordflow">return</span> safe_sparse_dot(X, Y.T, dense_output=dense_output)</div>
<div class="line"><span class="lineno"> 1205</span> </div>
<div class="line"><span class="lineno"> 1206</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a54fb85a2fbacef383e08758df9d2f47b" name="a54fb85a2fbacef383e08758df9d2f47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fb85a2fbacef383e08758df9d2f47b">&#9670;&#160;</a></span>manhattan_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.manhattan_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>sum_over_features</em> = <code>&quot;deprecated&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the L1 distances between the vectors in X and Y.

With sum_over_features equal to False it returns the componentwise
distances.

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : array-like of shape (n_samples_X, n_features)
    An array where each row is a sample and each column is a feature.

Y : array-like of shape (n_samples_Y, n_features), default=None
    An array where each row is a sample and each column is a feature.
    If `None`, method uses `Y=X`.

sum_over_features : bool, default=True
    If True the function returns the pairwise distance matrix
    else it returns the componentwise L1 pairwise-distances.
    Not supported for sparse matrix inputs.

    .. deprecated:: 1.2
        ``sum_over_features`` was deprecated in version 1.2 and will be removed in
        1.4.

Returns
-------
D : ndarray of shape (n_samples_X * n_samples_Y, n_features) or \
        (n_samples_X, n_samples_Y)
    If sum_over_features is False shape is
    (n_samples_X * n_samples_Y, n_features) and D contains the
    componentwise L1 pairwise-distances (ie. absolute difference),
    else shape is (n_samples_X, n_samples_Y) and D contains
    the pairwise L1 distances.

Notes
-----
When X and/or Y are CSR sparse matrices and they are not already
in canonical format, this function modifies them in-place to
make them canonical.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics.pairwise import manhattan_distances
&gt;&gt;&gt; manhattan_distances([[3]], [[3]])
array([[0.]])
&gt;&gt;&gt; manhattan_distances([[3]], [[2]])
array([[1.]])
&gt;&gt;&gt; manhattan_distances([[2]], [[3]])
array([[1.]])
&gt;&gt;&gt; manhattan_distances([[1, 2], [3, 4]],\
     [[1, 2], [0, 3]])
array([[0., 2.],
       [4., 4.]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  882</span><span class="keyword">def </span>manhattan_distances(X, Y=None, *, sum_over_features=&quot;deprecated&quot;):</div>
<div class="line"><span class="lineno">  883</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the L1 distances between the vectors in X and Y.</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    With sum_over_features equal to False it returns the componentwise</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    distances.</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    X : array-like of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    Y : array-like of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">        If `None`, method uses `Y=X`.</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    sum_over_features : bool, default=True</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">        If True the function returns the pairwise distance matrix</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">        else it returns the componentwise L1 pairwise-distances.</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">        Not supported for sparse matrix inputs.</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">        .. deprecated:: 1.2</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">            ``sum_over_features`` was deprecated in version 1.2 and will be removed in</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">            1.4.</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    D : ndarray of shape (n_samples_X * n_samples_Y, n_features) or \</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">            (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        If sum_over_features is False shape is</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        (n_samples_X * n_samples_Y, n_features) and D contains the</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        componentwise L1 pairwise-distances (ie. absolute difference),</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">        else shape is (n_samples_X, n_samples_Y) and D contains</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">        the pairwise L1 distances.</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    When X and/or Y are CSR sparse matrices and they are not already</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    in canonical format, this function modifies them in-place to</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    make them canonical.</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics.pairwise import manhattan_distances</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    &gt;&gt;&gt; manhattan_distances([[3]], [[3]])</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    array([[0.]])</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    &gt;&gt;&gt; manhattan_distances([[3]], [[2]])</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    array([[1.]])</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    &gt;&gt;&gt; manhattan_distances([[2]], [[3]])</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    array([[1.]])</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    &gt;&gt;&gt; manhattan_distances([[1, 2], [3, 4]],\</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">         [[1, 2], [0, 3]])</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    array([[0., 2.],</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">           [4., 4.]])</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  938</span>    <span class="comment"># TODO(1.4): remove sum_over_features</span></div>
<div class="line"><span class="lineno">  939</span>    <span class="keywordflow">if</span> sum_over_features != <span class="stringliteral">&quot;deprecated&quot;</span>:</div>
<div class="line"><span class="lineno">  940</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  941</span>            <span class="stringliteral">&quot;`sum_over_features` is deprecated in version 1.2 and will be&quot;</span></div>
<div class="line"><span class="lineno">  942</span>            <span class="stringliteral">&quot; removed in version 1.4.&quot;</span>,</div>
<div class="line"><span class="lineno">  943</span>            FutureWarning,</div>
<div class="line"><span class="lineno">  944</span>        )</div>
<div class="line"><span class="lineno">  945</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  946</span>        sum_over_features = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  947</span> </div>
<div class="line"><span class="lineno">  948</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno">  949</span> </div>
<div class="line"><span class="lineno">  950</span>    <span class="keywordflow">if</span> issparse(X) <span class="keywordflow">or</span> issparse(Y):</div>
<div class="line"><span class="lineno">  951</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> sum_over_features:</div>
<div class="line"><span class="lineno">  952</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  953</span>                <span class="stringliteral">&quot;sum_over_features=%r not supported for sparse matrices&quot;</span></div>
<div class="line"><span class="lineno">  954</span>                % sum_over_features</div>
<div class="line"><span class="lineno">  955</span>            )</div>
<div class="line"><span class="lineno">  956</span> </div>
<div class="line"><span class="lineno">  957</span>        X = csr_matrix(X, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  958</span>        Y = csr_matrix(Y, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  959</span>        X.sum_duplicates()  <span class="comment"># this also sorts indices in-place</span></div>
<div class="line"><span class="lineno">  960</span>        Y.sum_duplicates()</div>
<div class="line"><span class="lineno">  961</span>        D = np.zeros((X.shape[0], Y.shape[0]))</div>
<div class="line"><span class="lineno">  962</span>        _sparse_manhattan(X.data, X.indices, X.indptr, Y.data, Y.indices, Y.indptr, D)</div>
<div class="line"><span class="lineno">  963</span>        <span class="keywordflow">return</span> D</div>
<div class="line"><span class="lineno">  964</span> </div>
<div class="line"><span class="lineno">  965</span>    <span class="keywordflow">if</span> sum_over_features:</div>
<div class="line"><span class="lineno">  966</span>        <span class="keywordflow">return</span> distance.cdist(X, Y, <span class="stringliteral">&quot;cityblock&quot;</span>)</div>
<div class="line"><span class="lineno">  967</span> </div>
<div class="line"><span class="lineno">  968</span>    D = X[:, np.newaxis, :] - Y[np.newaxis, :, :]</div>
<div class="line"><span class="lineno">  969</span>    D = np.abs(D, D)</div>
<div class="line"><span class="lineno">  970</span>    <span class="keywordflow">return</span> D.reshape((-1, X.shape[1]))</div>
<div class="line"><span class="lineno">  971</span> </div>
<div class="line"><span class="lineno">  972</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ffaeaa692c4ec5f5f3513dae00b6b9a" name="a2ffaeaa692c4ec5f5f3513dae00b6b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffaeaa692c4ec5f5f3513dae00b6b9a">&#9670;&#160;</a></span>nan_euclidean_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.nan_euclidean_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>squared</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>missing_values</em> = <code>np.nan</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the euclidean distances in the presence of missing values.

Compute the euclidean distance between each pair of samples in X and Y,
where Y=X is assumed if Y=None. When calculating the distance between a
pair of samples, this formulation ignores feature coordinates with a
missing value in either sample and scales up the weight of the remaining
coordinates:

    dist(x,y) = sqrt(weight * sq. distance from present coordinates)
    where,
    weight = Total # of coordinates / # of present coordinates

For example, the distance between ``[3, na, na, 6]`` and ``[1, na, 4, 5]``
is:

    .. math::
        \\sqrt{\\frac{4}{2}((3-1)^2 + (6-5)^2)}

If all the coordinates are missing or if there are no common present
coordinates then NaN is returned for that pair.

Read more in the :ref:`User Guide &lt;metrics&gt;`.

.. versionadded:: 0.22

Parameters
----------
X : array-like of shape (n_samples_X, n_features)
    An array where each row is a sample and each column is a feature.

Y : array-like of shape (n_samples_Y, n_features), default=None
    An array where each row is a sample and each column is a feature.
    If `None`, method uses `Y=X`.

squared : bool, default=False
    Return squared Euclidean distances.

missing_values : np.nan or int, default=np.nan
    Representation of missing value.

copy : bool, default=True
    Make and use a deep copy of X and Y (if Y exists).

Returns
-------
distances : ndarray of shape (n_samples_X, n_samples_Y)
    Returns the distances between the row vectors of `X`
    and the row vectors of `Y`.

See Also
--------
paired_distances : Distances between pairs of elements of X and Y.

References
----------
* John K. Dixon, "Pattern Recognition with Partly Missing Data",
  IEEE Transactions on Systems, Man, and Cybernetics, Volume: 9, Issue:
  10, pp. 617 - 621, Oct. 1979.
  http://ieeexplore.ieee.org/abstract/document/4310090/

Examples
--------
&gt;&gt;&gt; from sklearn.metrics.pairwise import nan_euclidean_distances
&gt;&gt;&gt; nan = float("NaN")
&gt;&gt;&gt; X = [[0, 1], [1, nan]]
&gt;&gt;&gt; nan_euclidean_distances(X, X) # distance between rows of X
array([[0.        , 1.41421356],
       [1.41421356, 0.        ]])

&gt;&gt;&gt; # get distance to origin
&gt;&gt;&gt; nan_euclidean_distances(X, [[0, 0]])
array([[1.        ],
       [1.41421356]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  384</span>):</div>
<div class="line"><span class="lineno">  385</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the euclidean distances in the presence of missing values.</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    Compute the euclidean distance between each pair of samples in X and Y,</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    where Y=X is assumed if Y=None. When calculating the distance between a</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    pair of samples, this formulation ignores feature coordinates with a</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    missing value in either sample and scales up the weight of the remaining</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    coordinates:</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">        dist(x,y) = sqrt(weight * sq. distance from present coordinates)</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">        where,</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">        weight = Total # of coordinates / # of present coordinates</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    For example, the distance between ``[3, na, na, 6]`` and ``[1, na, 4, 5]``</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    is:</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">            \\sqrt{\\frac{4}{2}((3-1)^2 + (6-5)^2)}</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    If all the coordinates are missing or if there are no common present</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    coordinates then NaN is returned for that pair.</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    .. versionadded:: 0.22</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    X : array-like of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    Y : array-like of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        If `None`, method uses `Y=X`.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    squared : bool, default=False</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">        Return squared Euclidean distances.</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    missing_values : np.nan or int, default=np.nan</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">        Representation of missing value.</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    copy : bool, default=True</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        Make and use a deep copy of X and Y (if Y exists).</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    distances : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        Returns the distances between the row vectors of `X`</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        and the row vectors of `Y`.</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    paired_distances : Distances between pairs of elements of X and Y.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    * John K. Dixon, &quot;Pattern Recognition with Partly Missing Data&quot;,</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">      IEEE Transactions on Systems, Man, and Cybernetics, Volume: 9, Issue:</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">      10, pp. 617 - 621, Oct. 1979.</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">      http://ieeexplore.ieee.org/abstract/document/4310090/</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics.pairwise import nan_euclidean_distances</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    &gt;&gt;&gt; nan = float(&quot;NaN&quot;)</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 1], [1, nan]]</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    &gt;&gt;&gt; nan_euclidean_distances(X, X) # distance between rows of X</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    array([[0.        , 1.41421356],</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">           [1.41421356, 0.        ]])</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    &gt;&gt;&gt; # get distance to origin</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    &gt;&gt;&gt; nan_euclidean_distances(X, [[0, 0]])</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    array([[1.        ],</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">           [1.41421356]])</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    force_all_finite = <span class="stringliteral">&quot;allow-nan&quot;</span> <span class="keywordflow">if</span> is_scalar_nan(missing_values) <span class="keywordflow">else</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  461</span>    X, Y = check_pairwise_arrays(</div>
<div class="line"><span class="lineno">  462</span>        X, Y, accept_sparse=<span class="keyword">False</span>, force_all_finite=force_all_finite, copy=copy</div>
<div class="line"><span class="lineno">  463</span>    )</div>
<div class="line"><span class="lineno">  464</span>    <span class="comment"># Get missing mask for X</span></div>
<div class="line"><span class="lineno">  465</span>    missing_X = _get_mask(X, missing_values)</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span>    <span class="comment"># Get missing mask for Y</span></div>
<div class="line"><span class="lineno">  468</span>    missing_Y = missing_X <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> X <span class="keywordflow">else</span> _get_mask(Y, missing_values)</div>
<div class="line"><span class="lineno">  469</span> </div>
<div class="line"><span class="lineno">  470</span>    <span class="comment"># set missing values to zero</span></div>
<div class="line"><span class="lineno">  471</span>    X[missing_X] = 0</div>
<div class="line"><span class="lineno">  472</span>    Y[missing_Y] = 0</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span>    distances = euclidean_distances(X, Y, squared=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  475</span> </div>
<div class="line"><span class="lineno">  476</span>    <span class="comment"># Adjust distances for missing values</span></div>
<div class="line"><span class="lineno">  477</span>    XX = X * X</div>
<div class="line"><span class="lineno">  478</span>    YY = Y * Y</div>
<div class="line"><span class="lineno">  479</span>    distances -= np.dot(XX, missing_Y.T)</div>
<div class="line"><span class="lineno">  480</span>    distances -= np.dot(missing_X, YY.T)</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span>    np.clip(distances, 0, <span class="keywordtype">None</span>, out=distances)</div>
<div class="line"><span class="lineno">  483</span> </div>
<div class="line"><span class="lineno">  484</span>    <span class="keywordflow">if</span> X <span class="keywordflow">is</span> Y:</div>
<div class="line"><span class="lineno">  485</span>        <span class="comment"># Ensure that distances between vectors and themselves are set to 0.0.</span></div>
<div class="line"><span class="lineno">  486</span>        <span class="comment"># This may not be the case due to floating point rounding errors.</span></div>
<div class="line"><span class="lineno">  487</span>        np.fill_diagonal(distances, 0.0)</div>
<div class="line"><span class="lineno">  488</span> </div>
<div class="line"><span class="lineno">  489</span>    present_X = 1 - missing_X</div>
<div class="line"><span class="lineno">  490</span>    present_Y = present_X <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> X <span class="keywordflow">else</span> ~missing_Y</div>
<div class="line"><span class="lineno">  491</span>    present_count = np.dot(present_X, present_Y.T)</div>
<div class="line"><span class="lineno">  492</span>    distances[present_count == 0] = np.nan</div>
<div class="line"><span class="lineno">  493</span>    <span class="comment"># avoid divide by zero</span></div>
<div class="line"><span class="lineno">  494</span>    np.maximum(1, present_count, out=present_count)</div>
<div class="line"><span class="lineno">  495</span>    distances /= present_count</div>
<div class="line"><span class="lineno">  496</span>    distances *= X.shape[1]</div>
<div class="line"><span class="lineno">  497</span> </div>
<div class="line"><span class="lineno">  498</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> squared:</div>
<div class="line"><span class="lineno">  499</span>        np.sqrt(distances, out=distances)</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span>    <span class="keywordflow">return</span> distances</div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a924b16b18a34cbc510c1d5fce54adb8c" name="a924b16b18a34cbc510c1d5fce54adb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924b16b18a34cbc510c1d5fce54adb8c">&#9670;&#160;</a></span>paired_cosine_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.paired_cosine_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the paired cosine distances between X and Y.

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    An array where each row is a sample and each column is a feature.

Y : array-like of shape (n_samples, n_features)
    An array where each row is a sample and each column is a feature.

Returns
-------
distances : ndarray of shape (n_samples,)
    Returns the distances between the row vectors of `X`
    and the row vectors of `Y`, where `distances[i]` is the
    distance between `X[i]` and `Y[i]`.

Notes
-----
The cosine distance is equivalent to the half the squared
euclidean distance if each sample is normalized to unit norm.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1075</span><span class="keyword">def </span>paired_cosine_distances(X, Y):</div>
<div class="line"><span class="lineno"> 1076</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    Compute the paired cosine distances between X and Y.</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    Y : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">        An array where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    distances : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">        Returns the distances between the row vectors of `X`</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">        and the row vectors of `Y`, where `distances[i]` is the</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        distance between `X[i]` and `Y[i]`.</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    The cosine distance is equivalent to the half the squared</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    euclidean distance if each sample is normalized to unit norm.</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1101</span>    X, Y = check_paired_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1102</span>    <span class="keywordflow">return</span> 0.5 * row_norms(normalize(X) - normalize(Y), squared=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1103</span> </div>
<div class="line"><span class="lineno"> 1104</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acb9f2c5682aaed539eec6bde7946d495" name="acb9f2c5682aaed539eec6bde7946d495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9f2c5682aaed539eec6bde7946d495">&#9670;&#160;</a></span>paired_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.paired_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>metric</em> = <code>&quot;euclidean&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the paired distances between X and Y.

Compute the distances between (X[0], Y[0]), (X[1], Y[1]), etc...

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : ndarray of shape (n_samples, n_features)
    Array 1 for distance computation.

Y : ndarray of shape (n_samples, n_features)
    Array 2 for distance computation.

metric : str or callable, default="euclidean"
    The metric to use when calculating distance between instances in a
    feature array. If metric is a string, it must be one of the options
    specified in PAIRED_DISTANCES, including "euclidean",
    "manhattan", or "cosine".
    Alternatively, if metric is a callable function, it is called on each
    pair of instances (rows) and the resulting value recorded. The callable
    should take two arrays from `X` as input and return a value indicating
    the distance between them.

**kwds : dict
    Unused parameters.

Returns
-------
distances : ndarray of shape (n_samples,)
    Returns the distances between the row vectors of `X`
    and the row vectors of `Y`.

See Also
--------
pairwise_distances : Computes the distance between every pair of samples.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics.pairwise import paired_distances
&gt;&gt;&gt; X = [[0, 1], [1, 1]]
&gt;&gt;&gt; Y = [[0, 1], [2, 1]]
&gt;&gt;&gt; paired_distances(X, Y)
array([0., 1.])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1115</span><span class="keyword">def </span>paired_distances(X, Y, *, metric=&quot;euclidean&quot;, **kwds):</div>
<div class="line"><span class="lineno"> 1116</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    Compute the paired distances between X and Y.</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    Compute the distances between (X[0], Y[0]), (X[1], Y[1]), etc...</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    X : ndarray of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">        Array 1 for distance computation.</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    Y : ndarray of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">        Array 2 for distance computation.</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    metric : str or callable, default=&quot;euclidean&quot;</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">        The metric to use when calculating distance between instances in a</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">        feature array. If metric is a string, it must be one of the options</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">        specified in PAIRED_DISTANCES, including &quot;euclidean&quot;,</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">        &quot;manhattan&quot;, or &quot;cosine&quot;.</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">        Alternatively, if metric is a callable function, it is called on each</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">        pair of instances (rows) and the resulting value recorded. The callable</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">        should take two arrays from `X` as input and return a value indicating</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">        the distance between them.</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">    **kwds : dict</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">        Unused parameters.</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    distances : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">        Returns the distances between the row vectors of `X`</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">        and the row vectors of `Y`.</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    pairwise_distances : Computes the distance between every pair of samples.</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics.pairwise import paired_distances</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 1], [1, 1]]</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    &gt;&gt;&gt; Y = [[0, 1], [2, 1]]</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    &gt;&gt;&gt; paired_distances(X, Y)</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    array([0., 1.])</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1162</span> </div>
<div class="line"><span class="lineno"> 1163</span>    <span class="keywordflow">if</span> metric <span class="keywordflow">in</span> PAIRED_DISTANCES:</div>
<div class="line"><span class="lineno"> 1164</span>        func = PAIRED_DISTANCES[metric]</div>
<div class="line"><span class="lineno"> 1165</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(X, Y)</div>
<div class="line"><span class="lineno"> 1166</span>    <span class="keywordflow">elif</span> callable(metric):</div>
<div class="line"><span class="lineno"> 1167</span>        <span class="comment"># Check the matrix first (it is usually done by the metric)</span></div>
<div class="line"><span class="lineno"> 1168</span>        X, Y = check_paired_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1169</span>        distances = np.zeros(len(X))</div>
<div class="line"><span class="lineno"> 1170</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(X)):</div>
<div class="line"><span class="lineno"> 1171</span>            distances[i] = metric(X[i], Y[i])</div>
<div class="line"><span class="lineno"> 1172</span>        <span class="keywordflow">return</span> distances</div>
<div class="line"><span class="lineno"> 1173</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1174</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unknown distance %s&quot;</span> % metric)</div>
<div class="line"><span class="lineno"> 1175</span> </div>
<div class="line"><span class="lineno"> 1176</span> </div>
<div class="line"><span class="lineno"> 1177</span><span class="comment"># Kernels</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a33ec59a5d820f4c1bbb103dee4f42df8" name="a33ec59a5d820f4c1bbb103dee4f42df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ec59a5d820f4c1bbb103dee4f42df8">&#9670;&#160;</a></span>paired_euclidean_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.paired_euclidean_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the paired euclidean distances between X and Y.

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Input array/matrix X.

Y : array-like of shape (n_samples, n_features)
    Input array/matrix Y.

Returns
-------
distances : ndarray of shape (n_samples,)
    Output array/matrix containing the calculated paired euclidean
    distances.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1012</span><span class="keyword">def </span>paired_euclidean_distances(X, Y):</div>
<div class="line"><span class="lineno"> 1013</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the paired euclidean distances between X and Y.</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">        Input array/matrix X.</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    Y : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">        Input array/matrix Y.</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    distances : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">        Output array/matrix containing the calculated paired euclidean</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">        distances.</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1031</span>    X, Y = check_paired_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1032</span>    <span class="keywordflow">return</span> row_norms(X - Y)</div>
<div class="line"><span class="lineno"> 1033</span> </div>
<div class="line"><span class="lineno"> 1034</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a97a3f94164bf717e7a510c0a305a6ec0" name="a97a3f94164bf717e7a510c0a305a6ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a3f94164bf717e7a510c0a305a6ec0">&#9670;&#160;</a></span>paired_manhattan_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.paired_manhattan_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the paired L1 distances between X and Y.

Distances are calculated between (X[0], Y[0]), (X[1], Y[1]), ...,
(X[n_samples], Y[n_samples]).

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    An array-like where each row is a sample and each column is a feature.

Y : array-like of shape (n_samples, n_features)
    An array-like where each row is a sample and each column is a feature.

Returns
-------
distances : ndarray of shape (n_samples,)
    L1 paired distances between the row vectors of `X`
    and the row vectors of `Y`.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics.pairwise import paired_manhattan_distances
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.array([[1, 1, 0], [0, 1, 0], [0, 0, 1]])
&gt;&gt;&gt; Y = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])
&gt;&gt;&gt; paired_manhattan_distances(X, Y)
array([1., 2., 1.])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1035</span><span class="keyword">def </span>paired_manhattan_distances(X, Y):</div>
<div class="line"><span class="lineno"> 1036</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the paired L1 distances between X and Y.</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    Distances are calculated between (X[0], Y[0]), (X[1], Y[1]), ...,</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    (X[n_samples], Y[n_samples]).</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        An array-like where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">    Y : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">        An array-like where each row is a sample and each column is a feature.</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">    distances : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">        L1 paired distances between the row vectors of `X`</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">        and the row vectors of `Y`.</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics.pairwise import paired_manhattan_distances</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    &gt;&gt;&gt; X = np.array([[1, 1, 0], [0, 1, 0], [0, 0, 1]])</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    &gt;&gt;&gt; Y = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">    &gt;&gt;&gt; paired_manhattan_distances(X, Y)</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">    array([1., 2., 1.])</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1066</span>    X, Y = check_paired_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1067</span>    diff = X - Y</div>
<div class="line"><span class="lineno"> 1068</span>    <span class="keywordflow">if</span> issparse(diff):</div>
<div class="line"><span class="lineno"> 1069</span>        diff.data = np.abs(diff.data)</div>
<div class="line"><span class="lineno"> 1070</span>        <span class="keywordflow">return</span> np.squeeze(np.array(diff.sum(axis=1)))</div>
<div class="line"><span class="lineno"> 1071</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1072</span>        <span class="keywordflow">return</span> np.abs(diff).sum(axis=-1)</div>
<div class="line"><span class="lineno"> 1073</span> </div>
<div class="line"><span class="lineno"> 1074</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aea1df754e9a97fe2a197968b34999e27" name="aea1df754e9a97fe2a197968b34999e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1df754e9a97fe2a197968b34999e27">&#9670;&#160;</a></span>pairwise_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.pairwise_distances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>&quot;euclidean&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_all_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the distance matrix from a vector array X and optional Y.

This method takes either a vector array or a distance matrix, and returns
a distance matrix. If the input is a vector array, the distances are
computed. If the input is a distances matrix, it is returned instead.

This method provides a safe way to take a distance matrix as input, while
preserving compatibility with many other algorithms that take a vector
array.

If Y is given (default is None), then the returned matrix is the pairwise
distance between the arrays from both X and Y.

Valid values for metric are:

- From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
  'manhattan']. These metrics support sparse matrix
  inputs.
  ['nan_euclidean'] but it does not yet support sparse matrices.

- From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',
  'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
  'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']
  See the documentation for scipy.spatial.distance for details on these
  metrics. These metrics do not support sparse matrix inputs.

Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are
valid scipy.spatial.distance metrics), the scikit-learn implementation
will be used, which is faster and has support for sparse matrices (except
for 'cityblock'). For a verbose description of the metrics from
scikit-learn, see :func:`sklearn.metrics.pairwise.distance_metrics`
function.

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : ndarray of shape (n_samples_X, n_samples_X) or \
        (n_samples_X, n_features)
    Array of pairwise distances between samples, or a feature array.
    The shape of the array should be (n_samples_X, n_samples_X) if
    metric == "precomputed" and (n_samples_X, n_features) otherwise.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. Only allowed if
    metric != "precomputed".

metric : str or callable, default='euclidean'
    The metric to use when calculating distance between instances in a
    feature array. If metric is a string, it must be one of the options
    allowed by scipy.spatial.distance.pdist for its metric parameter, or
    a metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``.
    If metric is "precomputed", X is assumed to be a distance matrix.
    Alternatively, if metric is a callable function, it is called on each
    pair of instances (rows) and the resulting value recorded. The callable
    should take two arrays from X as input and return a value indicating
    the distance between them.

n_jobs : int, default=None
    The number of jobs to use for the computation. This works by breaking
    down the pairwise matrix into n_jobs even slices and computing them in
    parallel.

    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in array. Ignored
    for a metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``. The
    possibilities are:

    - True: Force all values of array to be finite.
    - False: accepts np.inf, np.nan, pd.NA in array.
    - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
      cannot be infinite.

    .. versionadded:: 0.22
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`.

**kwds : optional keyword parameters
    Any further parameters are passed directly to the distance function.
    If using a scipy.spatial.distance metric, the parameters are still
    metric dependent. See the scipy docs for usage examples.

Returns
-------
D : ndarray of shape (n_samples_X, n_samples_X) or \
        (n_samples_X, n_samples_Y)
    A distance matrix D such that D_{i, j} is the distance between the
    ith and jth vectors of the given matrix X, if Y is None.
    If Y is not None, then D_{i, j} is the distance between the ith array
    from X and the jth array from Y.

See Also
--------
pairwise_distances_chunked : Performs the same calculation as this
    function, but returns a generator of chunks of the distance matrix, in
    order to limit memory usage.
paired_distances : Computes the distances between corresponding elements
    of two arrays.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1883</span>):</div>
<div class="line"><span class="lineno"> 1884</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the distance matrix from a vector array X and optional Y.</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    This method takes either a vector array or a distance matrix, and returns</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral">    a distance matrix. If the input is a vector array, the distances are</span></div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">    computed. If the input is a distances matrix, it is returned instead.</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">    This method provides a safe way to take a distance matrix as input, while</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">    preserving compatibility with many other algorithms that take a vector</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral">    array.</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral">    If Y is given (default is None), then the returned matrix is the pairwise</span></div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    distance between the arrays from both X and Y.</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    Valid values for metric are:</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">    - From scikit-learn: [&#39;cityblock&#39;, &#39;cosine&#39;, &#39;euclidean&#39;, &#39;l1&#39;, &#39;l2&#39;,</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">      &#39;manhattan&#39;]. These metrics support sparse matrix</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">      inputs.</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">      [&#39;nan_euclidean&#39;] but it does not yet support sparse matrices.</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">    - From scipy.spatial.distance: [&#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;,</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral">      &#39;correlation&#39;, &#39;dice&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;kulsinski&#39;, &#39;mahalanobis&#39;,</span></div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">      &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;, &#39;seuclidean&#39;,</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">      &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;, &#39;yule&#39;]</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">      See the documentation for scipy.spatial.distance for details on these</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">      metrics. These metrics do not support sparse matrix inputs.</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">    Note that in the case of &#39;cityblock&#39;, &#39;cosine&#39; and &#39;euclidean&#39; (which are</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">    valid scipy.spatial.distance metrics), the scikit-learn implementation</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">    will be used, which is faster and has support for sparse matrices (except</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">    for &#39;cityblock&#39;). For a verbose description of the metrics from</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">    scikit-learn, see :func:`sklearn.metrics.pairwise.distance_metrics`</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    function.</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_samples_X) or \</span></div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">            (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral">        Array of pairwise distances between samples, or a feature array.</span></div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">        The shape of the array should be (n_samples_X, n_samples_X) if</span></div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">        metric == &quot;precomputed&quot; and (n_samples_X, n_features) otherwise.</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral">        An optional second feature array. Only allowed if</span></div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral">        metric != &quot;precomputed&quot;.</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral">    metric : str or callable, default=&#39;euclidean&#39;</span></div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">        The metric to use when calculating distance between instances in a</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral">        feature array. If metric is a string, it must be one of the options</span></div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral">        allowed by scipy.spatial.distance.pdist for its metric parameter, or</span></div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral">        a metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``.</span></div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral">        If metric is &quot;precomputed&quot;, X is assumed to be a distance matrix.</span></div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral">        Alternatively, if metric is a callable function, it is called on each</span></div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral">        pair of instances (rows) and the resulting value recorded. The callable</span></div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral">        should take two arrays from X as input and return a value indicating</span></div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral">        the distance between them.</span></div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">        The number of jobs to use for the computation. This works by breaking</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">        down the pairwise matrix into n_jobs even slices and computing them in</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">        parallel.</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno"> 1950</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno"> 1951</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1952</span><span class="stringliteral">    force_all_finite : bool or &#39;allow-nan&#39;, default=True</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral">        Whether to raise an error on np.inf, np.nan, pd.NA in array. Ignored</span></div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">        for a metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``. The</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">        possibilities are:</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral">        - True: Force all values of array to be finite.</span></div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">        - False: accepts np.inf, np.nan, pd.NA in array.</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">        - &#39;allow-nan&#39;: accepts only np.nan and pd.NA values in array. Values</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">          cannot be infinite.</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">        .. versionadded:: 0.22</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">           ``force_all_finite`` accepts the string ``&#39;allow-nan&#39;``.</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">        .. versionchanged:: 0.23</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">           Accepts `pd.NA` and converts it into `np.nan`.</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">    **kwds : optional keyword parameters</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">        Any further parameters are passed directly to the distance function.</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">        If using a scipy.spatial.distance metric, the parameters are still</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">        metric dependent. See the scipy docs for usage examples.</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">    D : ndarray of shape (n_samples_X, n_samples_X) or \</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">            (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">        A distance matrix D such that D_{i, j} is the distance between the</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">        ith and jth vectors of the given matrix X, if Y is None.</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral">        If Y is not None, then D_{i, j} is the distance between the ith array</span></div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">        from X and the jth array from Y.</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    pairwise_distances_chunked : Performs the same calculation as this</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">        function, but returns a generator of chunks of the distance matrix, in</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">        order to limit memory usage.</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral">    paired_distances : Computes the distances between corresponding elements</span></div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">        of two arrays.</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1990</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1991</span>        metric <span class="keywordflow">not</span> <span class="keywordflow">in</span> _VALID_METRICS</div>
<div class="line"><span class="lineno"> 1992</span>        <span class="keywordflow">and</span> <span class="keywordflow">not</span> callable(metric)</div>
<div class="line"><span class="lineno"> 1993</span>        <span class="keywordflow">and</span> metric != <span class="stringliteral">&quot;precomputed&quot;</span></div>
<div class="line"><span class="lineno"> 1994</span>    ):</div>
<div class="line"><span class="lineno"> 1995</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1996</span>            <span class="stringliteral">&quot;Unknown metric %s. Valid metrics are %s, or &#39;precomputed&#39;, or a callable&quot;</span></div>
<div class="line"><span class="lineno"> 1997</span>            % (metric, _VALID_METRICS)</div>
<div class="line"><span class="lineno"> 1998</span>        )</div>
<div class="line"><span class="lineno"> 1999</span> </div>
<div class="line"><span class="lineno"> 2000</span>    <span class="keywordflow">if</span> metric == <span class="stringliteral">&quot;precomputed&quot;</span>:</div>
<div class="line"><span class="lineno"> 2001</span>        X, _ = check_pairwise_arrays(</div>
<div class="line"><span class="lineno"> 2002</span>            X, Y, precomputed=<span class="keyword">True</span>, force_all_finite=force_all_finite</div>
<div class="line"><span class="lineno"> 2003</span>        )</div>
<div class="line"><span class="lineno"> 2004</span> </div>
<div class="line"><span class="lineno"> 2005</span>        whom = (</div>
<div class="line"><span class="lineno"> 2006</span>            <span class="stringliteral">&quot;`pairwise_distances`. Precomputed distance &quot;</span></div>
<div class="line"><span class="lineno"> 2007</span>            <span class="stringliteral">&quot; need to have non-negative values.&quot;</span></div>
<div class="line"><span class="lineno"> 2008</span>        )</div>
<div class="line"><span class="lineno"> 2009</span>        check_non_negative(X, whom=whom)</div>
<div class="line"><span class="lineno"> 2010</span>        <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno"> 2011</span>    <span class="keywordflow">elif</span> metric <span class="keywordflow">in</span> PAIRWISE_DISTANCE_FUNCTIONS:</div>
<div class="line"><span class="lineno"> 2012</span>        func = PAIRWISE_DISTANCE_FUNCTIONS[metric]</div>
<div class="line"><span class="lineno"> 2013</span>    <span class="keywordflow">elif</span> callable(metric):</div>
<div class="line"><span class="lineno"> 2014</span>        func = partial(</div>
<div class="line"><span class="lineno"> 2015</span>            _pairwise_callable, metric=metric, force_all_finite=force_all_finite, **kwds</div>
<div class="line"><span class="lineno"> 2016</span>        )</div>
<div class="line"><span class="lineno"> 2017</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2018</span>        <span class="keywordflow">if</span> issparse(X) <span class="keywordflow">or</span> issparse(Y):</div>
<div class="line"><span class="lineno"> 2019</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;scipy distance metrics do not support sparse matrices.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2020</span> </div>
<div class="line"><span class="lineno"> 2021</span>        dtype = bool <span class="keywordflow">if</span> metric <span class="keywordflow">in</span> PAIRWISE_BOOLEAN_FUNCTIONS <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2022</span> </div>
<div class="line"><span class="lineno"> 2023</span>        <span class="keywordflow">if</span> dtype == bool <span class="keywordflow">and</span> (X.dtype != bool <span class="keywordflow">or</span> (Y <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> Y.dtype != bool)):</div>
<div class="line"><span class="lineno"> 2024</span>            msg = <span class="stringliteral">&quot;Data was converted to boolean for metric %s&quot;</span> % metric</div>
<div class="line"><span class="lineno"> 2025</span>            warnings.warn(msg, DataConversionWarning)</div>
<div class="line"><span class="lineno"> 2026</span> </div>
<div class="line"><span class="lineno"> 2027</span>        X, Y = check_pairwise_arrays(</div>
<div class="line"><span class="lineno"> 2028</span>            X, Y, dtype=dtype, force_all_finite=force_all_finite</div>
<div class="line"><span class="lineno"> 2029</span>        )</div>
<div class="line"><span class="lineno"> 2030</span> </div>
<div class="line"><span class="lineno"> 2031</span>        <span class="comment"># precompute data-derived metric params</span></div>
<div class="line"><span class="lineno"> 2032</span>        params = _precompute_metric_params(X, Y, metric=metric, **kwds)</div>
<div class="line"><span class="lineno"> 2033</span>        kwds.update(**params)</div>
<div class="line"><span class="lineno"> 2034</span> </div>
<div class="line"><span class="lineno"> 2035</span>        <span class="keywordflow">if</span> effective_n_jobs(n_jobs) == 1 <span class="keywordflow">and</span> X <span class="keywordflow">is</span> Y:</div>
<div class="line"><span class="lineno"> 2036</span>            <span class="keywordflow">return</span> distance.squareform(distance.pdist(X, metric=metric, **kwds))</div>
<div class="line"><span class="lineno"> 2037</span>        func = partial(distance.cdist, metric=metric, **kwds)</div>
<div class="line"><span class="lineno"> 2038</span> </div>
<div class="line"><span class="lineno"> 2039</span>    <span class="keywordflow">return</span> _parallel_pairwise(X, Y, func, n_jobs, **kwds)</div>
<div class="line"><span class="lineno"> 2040</span> </div>
<div class="line"><span class="lineno"> 2041</span> </div>
<div class="line"><span class="lineno"> 2042</span><span class="comment"># These distances require boolean arrays, when using scipy.spatial.distance</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d611a0cef1e72b4de7c2f59af1afe9a" name="a0d611a0cef1e72b4de7c2f59af1afe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d611a0cef1e72b4de7c2f59af1afe9a">&#9670;&#160;</a></span>pairwise_distances_argmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.pairwise_distances_argmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>axis</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>&quot;euclidean&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute minimum distances between one point and a set of points.

This function computes for each row in X, the index of the row of Y which
is closest (according to the specified distance).

This is mostly equivalent to calling:

    pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis)

but uses much less memory, and is faster for large arrays.

This function works with dense 2D arrays only.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples_X, n_features)
    Array containing points.

Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)
    Arrays containing points.

axis : int, default=1
    Axis along which the argmin and distances are to be computed.

metric : str or callable, default="euclidean"
    Metric to use for distance computation. Any metric from scikit-learn
    or scipy.spatial.distance can be used.

    If metric is a callable function, it is called on each
    pair of instances (rows) and the resulting value recorded. The callable
    should take two arrays as input and return one value indicating the
    distance between them. This works for Scipy's metrics, but is less
    efficient than passing the metric name as a string.

    Distance matrices are not supported.

    Valid values for metric are:

    - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
      'manhattan']

    - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
      'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
      'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
      'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
      'yule']

    See the documentation for scipy.spatial.distance for details on these
    metrics.

metric_kwargs : dict, default=None
    Keyword arguments to pass to specified metric function.

Returns
-------
argmin : numpy.ndarray
    Y[argmin[i], :] is the row in Y that is closest to X[i, :].

See Also
--------
pairwise_distances : Distances between every pair of samples of X and Y.
pairwise_distances_argmin_min : Same as `pairwise_distances_argmin` but also
    returns the distances.
</pre> <div class="fragment"><div class="line"><span class="lineno">  712</span><span class="keyword">def </span>pairwise_distances_argmin(X, Y, *, axis=1, metric=&quot;euclidean&quot;, metric_kwargs=None):</div>
<div class="line"><span class="lineno">  713</span>    <span class="stringliteral">&quot;&quot;&quot;Compute minimum distances between one point and a set of points.</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    This function computes for each row in X, the index of the row of Y which</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    is closest (according to the specified distance).</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    This is mostly equivalent to calling:</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">        pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis)</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    but uses much less memory, and is faster for large arrays.</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    This function works with dense 2D arrays only.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">        Array containing points.</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">        Arrays containing points.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    axis : int, default=1</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        Axis along which the argmin and distances are to be computed.</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    metric : str or callable, default=&quot;euclidean&quot;</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">        Metric to use for distance computation. Any metric from scikit-learn</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        or scipy.spatial.distance can be used.</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">        If metric is a callable function, it is called on each</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">        pair of instances (rows) and the resulting value recorded. The callable</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        should take two arrays as input and return one value indicating the</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        distance between them. This works for Scipy&#39;s metrics, but is less</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        efficient than passing the metric name as a string.</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        Distance matrices are not supported.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        Valid values for metric are:</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        - from scikit-learn: [&#39;cityblock&#39;, &#39;cosine&#39;, &#39;euclidean&#39;, &#39;l1&#39;, &#39;l2&#39;,</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">          &#39;manhattan&#39;]</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        - from scipy.spatial.distance: [&#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;,</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">          &#39;correlation&#39;, &#39;dice&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;kulsinski&#39;,</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">          &#39;mahalanobis&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;,</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">          &#39;seuclidean&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;,</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">          &#39;yule&#39;]</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        See the documentation for scipy.spatial.distance for details on these</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        metrics.</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    metric_kwargs : dict, default=None</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        Keyword arguments to pass to specified metric function.</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    argmin : numpy.ndarray</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">        Y[argmin[i], :] is the row in Y that is closest to X[i, :].</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    pairwise_distances : Distances between every pair of samples of X and Y.</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    pairwise_distances_argmin_min : Same as `pairwise_distances_argmin` but also</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">        returns the distances.</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  777</span>    <span class="keywordflow">if</span> metric_kwargs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  778</span>        metric_kwargs = {}</div>
<div class="line"><span class="lineno">  779</span> </div>
<div class="line"><span class="lineno">  780</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno">  781</span> </div>
<div class="line"><span class="lineno">  782</span>    <span class="keywordflow">if</span> axis == 0:</div>
<div class="line"><span class="lineno">  783</span>        X, Y = Y, X</div>
<div class="line"><span class="lineno">  784</span> </div>
<div class="line"><span class="lineno">  785</span>    <span class="keywordflow">if</span> metric_kwargs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  786</span>        metric_kwargs = {}</div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    <span class="keywordflow">if</span> ArgKmin.is_usable_for(X, Y, metric):</div>
<div class="line"><span class="lineno">  789</span>        <span class="comment"># This is an adaptor for one &quot;sqeuclidean&quot; specification.</span></div>
<div class="line"><span class="lineno">  790</span>        <span class="comment"># For this backend, we can directly use &quot;sqeuclidean&quot;.</span></div>
<div class="line"><span class="lineno">  791</span>        <span class="keywordflow">if</span> metric_kwargs.get(<span class="stringliteral">&quot;squared&quot;</span>, <span class="keyword">False</span>) <span class="keywordflow">and</span> metric == <span class="stringliteral">&quot;euclidean&quot;</span>:</div>
<div class="line"><span class="lineno">  792</span>            metric = <span class="stringliteral">&quot;sqeuclidean&quot;</span></div>
<div class="line"><span class="lineno">  793</span>            metric_kwargs = {}</div>
<div class="line"><span class="lineno">  794</span> </div>
<div class="line"><span class="lineno">  795</span>        indices = ArgKmin.compute(</div>
<div class="line"><span class="lineno">  796</span>            X=X,</div>
<div class="line"><span class="lineno">  797</span>            Y=Y,</div>
<div class="line"><span class="lineno">  798</span>            k=1,</div>
<div class="line"><span class="lineno">  799</span>            metric=metric,</div>
<div class="line"><span class="lineno">  800</span>            metric_kwargs=metric_kwargs,</div>
<div class="line"><span class="lineno">  801</span>            strategy=<span class="stringliteral">&quot;auto&quot;</span>,</div>
<div class="line"><span class="lineno">  802</span>            return_distance=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  803</span>        )</div>
<div class="line"><span class="lineno">  804</span>        indices = indices.flatten()</div>
<div class="line"><span class="lineno">  805</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  806</span>        <span class="comment"># Joblib-based backend, which is used when user-defined callable</span></div>
<div class="line"><span class="lineno">  807</span>        <span class="comment"># are passed for metric.</span></div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>        <span class="comment"># This won&#39;t be used in the future once PairwiseDistancesReductions support:</span></div>
<div class="line"><span class="lineno">  810</span>        <span class="comment">#   - DistanceMetrics which work on supposedly binary data</span></div>
<div class="line"><span class="lineno">  811</span>        <span class="comment">#   - CSR-dense and dense-CSR case if &#39;euclidean&#39; in metric.</span></div>
<div class="line"><span class="lineno">  812</span> </div>
<div class="line"><span class="lineno">  813</span>        <span class="comment"># Turn off check for finiteness because this is costly and because arrays</span></div>
<div class="line"><span class="lineno">  814</span>        <span class="comment"># have already been validated.</span></div>
<div class="line"><span class="lineno">  815</span>        <span class="keyword">with</span> config_context(assume_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  816</span>            indices = np.concatenate(</div>
<div class="line"><span class="lineno">  817</span>                list(</div>
<div class="line"><span class="lineno">  818</span>                    <span class="comment"># This returns a np.ndarray generator whose arrays we need</span></div>
<div class="line"><span class="lineno">  819</span>                    <span class="comment"># to flatten into one.</span></div>
<div class="line"><span class="lineno">  820</span>                    pairwise_distances_chunked(</div>
<div class="line"><span class="lineno">  821</span>                        X, Y, reduce_func=_argmin_reduce, metric=metric, **metric_kwargs</div>
<div class="line"><span class="lineno">  822</span>                    )</div>
<div class="line"><span class="lineno">  823</span>                )</div>
<div class="line"><span class="lineno">  824</span>            )</div>
<div class="line"><span class="lineno">  825</span> </div>
<div class="line"><span class="lineno">  826</span>    <span class="keywordflow">return</span> indices</div>
<div class="line"><span class="lineno">  827</span> </div>
<div class="line"><span class="lineno">  828</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a76f1b6da5129c0f84504a08145190775" name="a76f1b6da5129c0f84504a08145190775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f1b6da5129c0f84504a08145190775">&#9670;&#160;</a></span>pairwise_distances_argmin_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.pairwise_distances_argmin_min </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>axis</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>&quot;euclidean&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute minimum distances between one point and a set of points.

This function computes for each row in X, the index of the row of Y which
is closest (according to the specified distance). The minimal distances are
also returned.

This is mostly equivalent to calling:

    (pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis),
     pairwise_distances(X, Y=Y, metric=metric).min(axis=axis))

but uses much less memory, and is faster for large arrays.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples_X, n_features)
    Array containing points.

Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)
    Array containing points.

axis : int, default=1
    Axis along which the argmin and distances are to be computed.

metric : str or callable, default='euclidean'
    Metric to use for distance computation. Any metric from scikit-learn
    or scipy.spatial.distance can be used.

    If metric is a callable function, it is called on each
    pair of instances (rows) and the resulting value recorded. The callable
    should take two arrays as input and return one value indicating the
    distance between them. This works for Scipy's metrics, but is less
    efficient than passing the metric name as a string.

    Distance matrices are not supported.

    Valid values for metric are:

    - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
      'manhattan']

    - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
      'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
      'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
      'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
      'yule']

    See the documentation for scipy.spatial.distance for details on these
    metrics.

metric_kwargs : dict, default=None
    Keyword arguments to pass to specified metric function.

Returns
-------
argmin : ndarray
    Y[argmin[i], :] is the row in Y that is closest to X[i, :].

distances : ndarray
    The array of minimum distances. `distances[i]` is the distance between
    the i-th row in X and the argmin[i]-th row in Y.

See Also
--------
pairwise_distances : Distances between every pair of samples of X and Y.
pairwise_distances_argmin : Same as `pairwise_distances_argmin_min` but only
    returns the argmins.
</pre> <div class="fragment"><div class="line"><span class="lineno">  595</span>):</div>
<div class="line"><span class="lineno">  596</span>    <span class="stringliteral">&quot;&quot;&quot;Compute minimum distances between one point and a set of points.</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    This function computes for each row in X, the index of the row of Y which</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    is closest (according to the specified distance). The minimal distances are</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    also returned.</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    This is mostly equivalent to calling:</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        (pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis),</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">         pairwise_distances(X, Y=Y, metric=metric).min(axis=axis))</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    but uses much less memory, and is faster for large arrays.</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">        Array containing points.</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features)</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        Array containing points.</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    axis : int, default=1</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        Axis along which the argmin and distances are to be computed.</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    metric : str or callable, default=&#39;euclidean&#39;</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        Metric to use for distance computation. Any metric from scikit-learn</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">        or scipy.spatial.distance can be used.</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        If metric is a callable function, it is called on each</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        pair of instances (rows) and the resulting value recorded. The callable</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">        should take two arrays as input and return one value indicating the</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">        distance between them. This works for Scipy&#39;s metrics, but is less</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">        efficient than passing the metric name as a string.</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        Distance matrices are not supported.</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">        Valid values for metric are:</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">        - from scikit-learn: [&#39;cityblock&#39;, &#39;cosine&#39;, &#39;euclidean&#39;, &#39;l1&#39;, &#39;l2&#39;,</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">          &#39;manhattan&#39;]</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        - from scipy.spatial.distance: [&#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;,</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">          &#39;correlation&#39;, &#39;dice&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;kulsinski&#39;,</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">          &#39;mahalanobis&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;,</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">          &#39;seuclidean&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;,</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">          &#39;yule&#39;]</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">        See the documentation for scipy.spatial.distance for details on these</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">        metrics.</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    metric_kwargs : dict, default=None</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        Keyword arguments to pass to specified metric function.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    argmin : ndarray</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        Y[argmin[i], :] is the row in Y that is closest to X[i, :].</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    distances : ndarray</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        The array of minimum distances. `distances[i]` is the distance between</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        the i-th row in X and the argmin[i]-th row in Y.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    pairwise_distances : Distances between every pair of samples of X and Y.</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    pairwise_distances_argmin : Same as `pairwise_distances_argmin_min` but only</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        returns the argmins.</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  664</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno">  665</span> </div>
<div class="line"><span class="lineno">  666</span>    <span class="keywordflow">if</span> axis == 0:</div>
<div class="line"><span class="lineno">  667</span>        X, Y = Y, X</div>
<div class="line"><span class="lineno">  668</span> </div>
<div class="line"><span class="lineno">  669</span>    <span class="keywordflow">if</span> metric_kwargs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  670</span>        metric_kwargs = {}</div>
<div class="line"><span class="lineno">  671</span> </div>
<div class="line"><span class="lineno">  672</span>    <span class="keywordflow">if</span> ArgKmin.is_usable_for(X, Y, metric):</div>
<div class="line"><span class="lineno">  673</span>        <span class="comment"># This is an adaptor for one &quot;sqeuclidean&quot; specification.</span></div>
<div class="line"><span class="lineno">  674</span>        <span class="comment"># For this backend, we can directly use &quot;sqeuclidean&quot;.</span></div>
<div class="line"><span class="lineno">  675</span>        <span class="keywordflow">if</span> metric_kwargs.get(<span class="stringliteral">&quot;squared&quot;</span>, <span class="keyword">False</span>) <span class="keywordflow">and</span> metric == <span class="stringliteral">&quot;euclidean&quot;</span>:</div>
<div class="line"><span class="lineno">  676</span>            metric = <span class="stringliteral">&quot;sqeuclidean&quot;</span></div>
<div class="line"><span class="lineno">  677</span>            metric_kwargs = {}</div>
<div class="line"><span class="lineno">  678</span> </div>
<div class="line"><span class="lineno">  679</span>        values, indices = ArgKmin.compute(</div>
<div class="line"><span class="lineno">  680</span>            X=X,</div>
<div class="line"><span class="lineno">  681</span>            Y=Y,</div>
<div class="line"><span class="lineno">  682</span>            k=1,</div>
<div class="line"><span class="lineno">  683</span>            metric=metric,</div>
<div class="line"><span class="lineno">  684</span>            metric_kwargs=metric_kwargs,</div>
<div class="line"><span class="lineno">  685</span>            strategy=<span class="stringliteral">&quot;auto&quot;</span>,</div>
<div class="line"><span class="lineno">  686</span>            return_distance=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  687</span>        )</div>
<div class="line"><span class="lineno">  688</span>        values = values.flatten()</div>
<div class="line"><span class="lineno">  689</span>        indices = indices.flatten()</div>
<div class="line"><span class="lineno">  690</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  691</span>        <span class="comment"># Joblib-based backend, which is used when user-defined callable</span></div>
<div class="line"><span class="lineno">  692</span>        <span class="comment"># are passed for metric.</span></div>
<div class="line"><span class="lineno">  693</span> </div>
<div class="line"><span class="lineno">  694</span>        <span class="comment"># This won&#39;t be used in the future once PairwiseDistancesReductions support:</span></div>
<div class="line"><span class="lineno">  695</span>        <span class="comment">#   - DistanceMetrics which work on supposedly binary data</span></div>
<div class="line"><span class="lineno">  696</span>        <span class="comment">#   - CSR-dense and dense-CSR case if &#39;euclidean&#39; in metric.</span></div>
<div class="line"><span class="lineno">  697</span> </div>
<div class="line"><span class="lineno">  698</span>        <span class="comment"># Turn off check for finiteness because this is costly and because arrays</span></div>
<div class="line"><span class="lineno">  699</span>        <span class="comment"># have already been validated.</span></div>
<div class="line"><span class="lineno">  700</span>        <span class="keyword">with</span> config_context(assume_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  701</span>            indices, values = zip(</div>
<div class="line"><span class="lineno">  702</span>                *pairwise_distances_chunked(</div>
<div class="line"><span class="lineno">  703</span>                    X, Y, reduce_func=_argmin_min_reduce, metric=metric, **metric_kwargs</div>
<div class="line"><span class="lineno">  704</span>                )</div>
<div class="line"><span class="lineno">  705</span>            )</div>
<div class="line"><span class="lineno">  706</span>        indices = np.concatenate(indices)</div>
<div class="line"><span class="lineno">  707</span>        values = np.concatenate(values)</div>
<div class="line"><span class="lineno">  708</span> </div>
<div class="line"><span class="lineno">  709</span>    <span class="keywordflow">return</span> indices, values</div>
<div class="line"><span class="lineno">  710</span> </div>
<div class="line"><span class="lineno">  711</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9a5a8588a65ce06fb75eb36d54e1e9b" name="aa9a5a8588a65ce06fb75eb36d54e1e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a5a8588a65ce06fb75eb36d54e1e9b">&#9670;&#160;</a></span>pairwise_distances_chunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.pairwise_distances_chunked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>reduce_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>&quot;euclidean&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>working_memory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a distance matrix chunk by chunk with optional reduction.

In cases where not all of a pairwise distance matrix needs to be
stored at once, this is used to calculate pairwise distances in
``working_memory``-sized chunks.  If ``reduce_func`` is given, it is
run on each chunk and its return values are concatenated into lists,
arrays or sparse matrices.

Parameters
----------
X : ndarray of shape (n_samples_X, n_samples_X) or \
        (n_samples_X, n_features)
    Array of pairwise distances between samples, or a feature array.
    The shape the array should be (n_samples_X, n_samples_X) if
    metric='precomputed' and (n_samples_X, n_features) otherwise.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. Only allowed if
    metric != "precomputed".

reduce_func : callable, default=None
    The function which is applied on each chunk of the distance matrix,
    reducing it to needed values.  ``reduce_func(D_chunk, start)``
    is called repeatedly, where ``D_chunk`` is a contiguous vertical
    slice of the pairwise distance matrix, starting at row ``start``.
    It should return one of: None; an array, a list, or a sparse matrix
    of length ``D_chunk.shape[0]``; or a tuple of such objects.
    Returning None is useful for in-place operations, rather than
    reductions.

    If None, pairwise_distances_chunked returns a generator of vertical
    chunks of the distance matrix.

metric : str or callable, default='euclidean'
    The metric to use when calculating distance between instances in a
    feature array. If metric is a string, it must be one of the options
    allowed by scipy.spatial.distance.pdist for its metric parameter,
    or a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
    If metric is "precomputed", X is assumed to be a distance matrix.
    Alternatively, if metric is a callable function, it is called on
    each pair of instances (rows) and the resulting value recorded.
    The callable should take two arrays from X as input and return a
    value indicating the distance between them.

n_jobs : int, default=None
    The number of jobs to use for the computation. This works by
    breaking down the pairwise matrix into n_jobs even slices and
    computing them in parallel.

    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

working_memory : int, default=None
    The sought maximum memory for temporary distance matrix chunks.
    When None (default), the value of
    ``sklearn.get_config()['working_memory']`` is used.

**kwds : optional keyword parameters
    Any further parameters are passed directly to the distance function.
    If using a scipy.spatial.distance metric, the parameters are still
    metric dependent. See the scipy docs for usage examples.

Yields
------
D_chunk : {ndarray, sparse matrix}
    A contiguous slice of distance matrix, optionally processed by
    ``reduce_func``.

Examples
--------
Without reduce_func:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import pairwise_distances_chunked
&gt;&gt;&gt; X = np.random.RandomState(0).rand(5, 3)
&gt;&gt;&gt; D_chunk = next(pairwise_distances_chunked(X))
&gt;&gt;&gt; D_chunk
array([[0.  ..., 0.29..., 0.41..., 0.19..., 0.57...],
       [0.29..., 0.  ..., 0.57..., 0.41..., 0.76...],
       [0.41..., 0.57..., 0.  ..., 0.44..., 0.90...],
       [0.19..., 0.41..., 0.44..., 0.  ..., 0.51...],
       [0.57..., 0.76..., 0.90..., 0.51..., 0.  ...]])

Retrieve all neighbors and average distance within radius r:

&gt;&gt;&gt; r = .2
&gt;&gt;&gt; def reduce_func(D_chunk, start):
...     neigh = [np.flatnonzero(d &lt; r) for d in D_chunk]
...     avg_dist = (D_chunk * (D_chunk &lt; r)).mean(axis=1)
...     return neigh, avg_dist
&gt;&gt;&gt; gen = pairwise_distances_chunked(X, reduce_func=reduce_func)
&gt;&gt;&gt; neigh, avg_dist = next(gen)
&gt;&gt;&gt; neigh
[array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])]
&gt;&gt;&gt; avg_dist
array([0.039..., 0.        , 0.        , 0.039..., 0.        ])

Where r is defined per sample, we need to make use of ``start``:

&gt;&gt;&gt; r = [.2, .4, .4, .3, .1]
&gt;&gt;&gt; def reduce_func(D_chunk, start):
...     neigh = [np.flatnonzero(d &lt; r[i])
...              for i, d in enumerate(D_chunk, start)]
...     return neigh
&gt;&gt;&gt; neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func))
&gt;&gt;&gt; neigh
[array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])]

Force row-by-row generation by reducing ``working_memory``:

&gt;&gt;&gt; gen = pairwise_distances_chunked(X, reduce_func=reduce_func,
...                                  working_memory=0)
&gt;&gt;&gt; next(gen)
[array([0, 3])]
&gt;&gt;&gt; next(gen)
[array([0, 1])]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1717</span>):</div>
<div class="line"><span class="lineno"> 1718</span>    <span class="stringliteral">&quot;&quot;&quot;Generate a distance matrix chunk by chunk with optional reduction.</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral">    In cases where not all of a pairwise distance matrix needs to be</span></div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">    stored at once, this is used to calculate pairwise distances in</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">    ``working_memory``-sized chunks.  If ``reduce_func`` is given, it is</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">    run on each chunk and its return values are concatenated into lists,</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">    arrays or sparse matrices.</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_samples_X) or \</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">            (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">        Array of pairwise distances between samples, or a feature array.</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">        The shape the array should be (n_samples_X, n_samples_X) if</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral">        metric=&#39;precomputed&#39; and (n_samples_X, n_features) otherwise.</span></div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">        An optional second feature array. Only allowed if</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral">        metric != &quot;precomputed&quot;.</span></div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">    reduce_func : callable, default=None</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">        The function which is applied on each chunk of the distance matrix,</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">        reducing it to needed values.  ``reduce_func(D_chunk, start)``</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">        is called repeatedly, where ``D_chunk`` is a contiguous vertical</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">        slice of the pairwise distance matrix, starting at row ``start``.</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">        It should return one of: None; an array, a list, or a sparse matrix</span></div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral">        of length ``D_chunk.shape[0]``; or a tuple of such objects.</span></div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">        Returning None is useful for in-place operations, rather than</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral">        reductions.</span></div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">        If None, pairwise_distances_chunked returns a generator of vertical</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral">        chunks of the distance matrix.</span></div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral">    metric : str or callable, default=&#39;euclidean&#39;</span></div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">        The metric to use when calculating distance between instances in a</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">        feature array. If metric is a string, it must be one of the options</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">        allowed by scipy.spatial.distance.pdist for its metric parameter,</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">        or a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral">        If metric is &quot;precomputed&quot;, X is assumed to be a distance matrix.</span></div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">        Alternatively, if metric is a callable function, it is called on</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">        each pair of instances (rows) and the resulting value recorded.</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">        The callable should take two arrays from X as input and return a</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">        value indicating the distance between them.</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">        The number of jobs to use for the computation. This works by</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">        breaking down the pairwise matrix into n_jobs even slices and</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">        computing them in parallel.</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    working_memory : int, default=None</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">        The sought maximum memory for temporary distance matrix chunks.</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">        When None (default), the value of</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">        ``sklearn.get_config()[&#39;working_memory&#39;]`` is used.</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">    **kwds : optional keyword parameters</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">        Any further parameters are passed directly to the distance function.</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">        If using a scipy.spatial.distance metric, the parameters are still</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">        metric dependent. See the scipy docs for usage examples.</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">    Yields</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">    D_chunk : {ndarray, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">        A contiguous slice of distance matrix, optionally processed by</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">        ``reduce_func``.</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">    Without reduce_func:</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics import pairwise_distances_chunked</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">    &gt;&gt;&gt; X = np.random.RandomState(0).rand(5, 3)</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">    &gt;&gt;&gt; D_chunk = next(pairwise_distances_chunked(X))</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">    &gt;&gt;&gt; D_chunk</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">    array([[0.  ..., 0.29..., 0.41..., 0.19..., 0.57...],</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">           [0.29..., 0.  ..., 0.57..., 0.41..., 0.76...],</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">           [0.41..., 0.57..., 0.  ..., 0.44..., 0.90...],</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">           [0.19..., 0.41..., 0.44..., 0.  ..., 0.51...],</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">           [0.57..., 0.76..., 0.90..., 0.51..., 0.  ...]])</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">    Retrieve all neighbors and average distance within radius r:</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">    &gt;&gt;&gt; r = .2</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">    &gt;&gt;&gt; def reduce_func(D_chunk, start):</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    ...     neigh = [np.flatnonzero(d &lt; r) for d in D_chunk]</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">    ...     avg_dist = (D_chunk * (D_chunk &lt; r)).mean(axis=1)</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">    ...     return neigh, avg_dist</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">    &gt;&gt;&gt; gen = pairwise_distances_chunked(X, reduce_func=reduce_func)</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">    &gt;&gt;&gt; neigh, avg_dist = next(gen)</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">    &gt;&gt;&gt; neigh</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">    [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])]</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">    &gt;&gt;&gt; avg_dist</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    array([0.039..., 0.        , 0.        , 0.039..., 0.        ])</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">    Where r is defined per sample, we need to make use of ``start``:</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">    &gt;&gt;&gt; r = [.2, .4, .4, .3, .1]</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">    &gt;&gt;&gt; def reduce_func(D_chunk, start):</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">    ...     neigh = [np.flatnonzero(d &lt; r[i])</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    ...              for i, d in enumerate(D_chunk, start)]</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">    ...     return neigh</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    &gt;&gt;&gt; neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func))</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    &gt;&gt;&gt; neigh</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])]</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    Force row-by-row generation by reducing ``working_memory``:</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    &gt;&gt;&gt; gen = pairwise_distances_chunked(X, reduce_func=reduce_func,</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    ...                                  working_memory=0)</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    &gt;&gt;&gt; next(gen)</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    [array([0, 3])]</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    &gt;&gt;&gt; next(gen)</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    [array([0, 1])]</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1836</span>    n_samples_X = _num_samples(X)</div>
<div class="line"><span class="lineno"> 1837</span>    <span class="keywordflow">if</span> metric == <span class="stringliteral">&quot;precomputed&quot;</span>:</div>
<div class="line"><span class="lineno"> 1838</span>        slices = (slice(0, n_samples_X),)</div>
<div class="line"><span class="lineno"> 1839</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1840</span>        <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1841</span>            Y = X</div>
<div class="line"><span class="lineno"> 1842</span>        <span class="comment"># We get as many rows as possible within our working_memory budget to</span></div>
<div class="line"><span class="lineno"> 1843</span>        <span class="comment"># store len(Y) distances in each row of output.</span></div>
<div class="line"><span class="lineno"> 1844</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1845</span>        <span class="comment"># Note:</span></div>
<div class="line"><span class="lineno"> 1846</span>        <span class="comment">#  - this will get at least 1 row, even if 1 row of distances will</span></div>
<div class="line"><span class="lineno"> 1847</span>        <span class="comment">#    exceed working_memory.</span></div>
<div class="line"><span class="lineno"> 1848</span>        <span class="comment">#  - this does not account for any temporary memory usage while</span></div>
<div class="line"><span class="lineno"> 1849</span>        <span class="comment">#    calculating distances (e.g. difference of vectors in manhattan</span></div>
<div class="line"><span class="lineno"> 1850</span>        <span class="comment">#    distance.</span></div>
<div class="line"><span class="lineno"> 1851</span>        chunk_n_rows = get_chunk_n_rows(</div>
<div class="line"><span class="lineno"> 1852</span>            row_bytes=8 * _num_samples(Y),</div>
<div class="line"><span class="lineno"> 1853</span>            max_n_rows=n_samples_X,</div>
<div class="line"><span class="lineno"> 1854</span>            working_memory=working_memory,</div>
<div class="line"><span class="lineno"> 1855</span>        )</div>
<div class="line"><span class="lineno"> 1856</span>        slices = gen_batches(n_samples_X, chunk_n_rows)</div>
<div class="line"><span class="lineno"> 1857</span> </div>
<div class="line"><span class="lineno"> 1858</span>    <span class="comment"># precompute data-derived metric params</span></div>
<div class="line"><span class="lineno"> 1859</span>    params = _precompute_metric_params(X, Y, metric=metric, **kwds)</div>
<div class="line"><span class="lineno"> 1860</span>    kwds.update(**params)</div>
<div class="line"><span class="lineno"> 1861</span> </div>
<div class="line"><span class="lineno"> 1862</span>    <span class="keywordflow">for</span> sl <span class="keywordflow">in</span> slices:</div>
<div class="line"><span class="lineno"> 1863</span>        <span class="keywordflow">if</span> sl.start == 0 <span class="keywordflow">and</span> sl.stop == n_samples_X:</div>
<div class="line"><span class="lineno"> 1864</span>            X_chunk = X  <span class="comment"># enable optimised paths for X is Y</span></div>
<div class="line"><span class="lineno"> 1865</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1866</span>            X_chunk = X[sl]</div>
<div class="line"><span class="lineno"> 1867</span>        D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)</div>
<div class="line"><span class="lineno"> 1868</span>        <span class="keywordflow">if</span> (X <span class="keywordflow">is</span> Y <span class="keywordflow">or</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> PAIRWISE_DISTANCE_FUNCTIONS.get(</div>
<div class="line"><span class="lineno"> 1869</span>            metric, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1870</span>        ) <span class="keywordflow">is</span> euclidean_distances:</div>
<div class="line"><span class="lineno"> 1871</span>            <span class="comment"># zeroing diagonal, taking care of aliases of &quot;euclidean&quot;,</span></div>
<div class="line"><span class="lineno"> 1872</span>            <span class="comment"># i.e. &quot;l2&quot;</span></div>
<div class="line"><span class="lineno"> 1873</span>            D_chunk.flat[sl.start :: _num_samples(X) + 1] = 0</div>
<div class="line"><span class="lineno"> 1874</span>        <span class="keywordflow">if</span> reduce_func <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1875</span>            chunk_size = D_chunk.shape[0]</div>
<div class="line"><span class="lineno"> 1876</span>            D_chunk = reduce_func(D_chunk, sl.start)</div>
<div class="line"><span class="lineno"> 1877</span>            _check_chunk_size(D_chunk, chunk_size)</div>
<div class="line"><span class="lineno"> 1878</span>        <span class="keywordflow">yield</span> D_chunk</div>
<div class="line"><span class="lineno"> 1879</span> </div>
<div class="line"><span class="lineno"> 1880</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a63dfe23a75eb37809d2ca4a73053cf0c" name="a63dfe23a75eb37809d2ca4a73053cf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dfe23a75eb37809d2ca4a73053cf0c">&#9670;&#160;</a></span>pairwise_kernels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.pairwise_kernels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>filter_params</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the kernel between arrays X and optional array Y.

This method takes either a vector array or a kernel matrix, and returns
a kernel matrix. If the input is a vector array, the kernels are
computed. If the input is a kernel matrix, it is returned instead.

This method provides a safe way to take a kernel matrix as input, while
preserving compatibility with many other algorithms that take a vector
array.

If Y is given (default is None), then the returned matrix is the pairwise
kernel between the arrays from both X and Y.

Valid values for metric are:
    ['additive_chi2', 'chi2', 'linear', 'poly', 'polynomial', 'rbf',
    'laplacian', 'sigmoid', 'cosine']

Read more in the :ref:`User Guide &lt;metrics&gt;`.

Parameters
----------
X : ndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_features)
    Array of pairwise kernels between samples, or a feature array.
    The shape of the array should be (n_samples_X, n_samples_X) if
    metric == "precomputed" and (n_samples_X, n_features) otherwise.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    A second feature array only if X has shape (n_samples_X, n_features).

metric : str or callable, default="linear"
    The metric to use when calculating kernel between instances in a
    feature array. If metric is a string, it must be one of the metrics
    in pairwise.PAIRWISE_KERNEL_FUNCTIONS.
    If metric is "precomputed", X is assumed to be a kernel matrix.
    Alternatively, if metric is a callable function, it is called on each
    pair of instances (rows) and the resulting value recorded. The callable
    should take two rows from X as input and return the corresponding
    kernel value as a single number. This means that callables from
    :mod:`sklearn.metrics.pairwise` are not allowed, as they operate on
    matrices, not single samples. Use the string identifying the kernel
    instead.

filter_params : bool, default=False
    Whether to filter invalid parameters or not.

n_jobs : int, default=None
    The number of jobs to use for the computation. This works by breaking
    down the pairwise matrix into n_jobs even slices and computing them in
    parallel.

    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

**kwds : optional keyword parameters
    Any further parameters are passed directly to the kernel function.

Returns
-------
K : ndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_samples_Y)
    A kernel matrix K such that K_{i, j} is the kernel between the
    ith and jth vectors of the given matrix X, if Y is None.
    If Y is not None, then K_{i, j} is the kernel between the ith array
    from X and the jth array from Y.

Notes
-----
If metric is 'precomputed', Y is ignored and X is returned.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2118</span>):</div>
<div class="line"><span class="lineno"> 2119</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the kernel between arrays X and optional array Y.</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">    This method takes either a vector array or a kernel matrix, and returns</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral">    a kernel matrix. If the input is a vector array, the kernels are</span></div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">    computed. If the input is a kernel matrix, it is returned instead.</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral">    This method provides a safe way to take a kernel matrix as input, while</span></div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">    preserving compatibility with many other algorithms that take a vector</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral">    array.</span></div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">    If Y is given (default is None), then the returned matrix is the pairwise</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral">    kernel between the arrays from both X and Y.</span></div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral">    Valid values for metric are:</span></div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">        [&#39;additive_chi2&#39;, &#39;chi2&#39;, &#39;linear&#39;, &#39;poly&#39;, &#39;polynomial&#39;, &#39;rbf&#39;,</span></div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral">        &#39;laplacian&#39;, &#39;sigmoid&#39;, &#39;cosine&#39;]</span></div>
<div class="line"><span class="lineno"> 2135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;metrics&gt;`.</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">        Array of pairwise kernels between samples, or a feature array.</span></div>
<div class="line"><span class="lineno"> 2142</span><span class="stringliteral">        The shape of the array should be (n_samples_X, n_samples_X) if</span></div>
<div class="line"><span class="lineno"> 2143</span><span class="stringliteral">        metric == &quot;precomputed&quot; and (n_samples_X, n_features) otherwise.</span></div>
<div class="line"><span class="lineno"> 2144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2145</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 2146</span><span class="stringliteral">        A second feature array only if X has shape (n_samples_X, n_features).</span></div>
<div class="line"><span class="lineno"> 2147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2148</span><span class="stringliteral">    metric : str or callable, default=&quot;linear&quot;</span></div>
<div class="line"><span class="lineno"> 2149</span><span class="stringliteral">        The metric to use when calculating kernel between instances in a</span></div>
<div class="line"><span class="lineno"> 2150</span><span class="stringliteral">        feature array. If metric is a string, it must be one of the metrics</span></div>
<div class="line"><span class="lineno"> 2151</span><span class="stringliteral">        in pairwise.PAIRWISE_KERNEL_FUNCTIONS.</span></div>
<div class="line"><span class="lineno"> 2152</span><span class="stringliteral">        If metric is &quot;precomputed&quot;, X is assumed to be a kernel matrix.</span></div>
<div class="line"><span class="lineno"> 2153</span><span class="stringliteral">        Alternatively, if metric is a callable function, it is called on each</span></div>
<div class="line"><span class="lineno"> 2154</span><span class="stringliteral">        pair of instances (rows) and the resulting value recorded. The callable</span></div>
<div class="line"><span class="lineno"> 2155</span><span class="stringliteral">        should take two rows from X as input and return the corresponding</span></div>
<div class="line"><span class="lineno"> 2156</span><span class="stringliteral">        kernel value as a single number. This means that callables from</span></div>
<div class="line"><span class="lineno"> 2157</span><span class="stringliteral">        :mod:`sklearn.metrics.pairwise` are not allowed, as they operate on</span></div>
<div class="line"><span class="lineno"> 2158</span><span class="stringliteral">        matrices, not single samples. Use the string identifying the kernel</span></div>
<div class="line"><span class="lineno"> 2159</span><span class="stringliteral">        instead.</span></div>
<div class="line"><span class="lineno"> 2160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">    filter_params : bool, default=False</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral">        Whether to filter invalid parameters or not.</span></div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral">        The number of jobs to use for the computation. This works by breaking</span></div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">        down the pairwise matrix into n_jobs even slices and computing them in</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">        parallel.</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral">    **kwds : optional keyword parameters</span></div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">        Any further parameters are passed directly to the kernel function.</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral">    K : ndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">        A kernel matrix K such that K_{i, j} is the kernel between the</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">        ith and jth vectors of the given matrix X, if Y is None.</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral">        If Y is not None, then K_{i, j} is the kernel between the ith array</span></div>
<div class="line"><span class="lineno"> 2182</span><span class="stringliteral">        from X and the jth array from Y.</span></div>
<div class="line"><span class="lineno"> 2183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2184</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2185</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2186</span><span class="stringliteral">    If metric is &#39;precomputed&#39;, Y is ignored and X is returned.</span></div>
<div class="line"><span class="lineno"> 2187</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2188</span>    <span class="comment"># import GPKernel locally to prevent circular imports</span></div>
<div class="line"><span class="lineno"> 2189</span>    <span class="keyword">from</span> ..gaussian_process.kernels <span class="keyword">import</span> Kernel <span class="keyword">as</span> GPKernel</div>
<div class="line"><span class="lineno"> 2190</span> </div>
<div class="line"><span class="lineno"> 2191</span>    <span class="keywordflow">if</span> metric == <span class="stringliteral">&quot;precomputed&quot;</span>:</div>
<div class="line"><span class="lineno"> 2192</span>        X, _ = check_pairwise_arrays(X, Y, precomputed=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2193</span>        <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno"> 2194</span>    <span class="keywordflow">elif</span> isinstance(metric, GPKernel):</div>
<div class="line"><span class="lineno"> 2195</span>        func = metric.__call__</div>
<div class="line"><span class="lineno"> 2196</span>    <span class="keywordflow">elif</span> metric <span class="keywordflow">in</span> PAIRWISE_KERNEL_FUNCTIONS:</div>
<div class="line"><span class="lineno"> 2197</span>        <span class="keywordflow">if</span> filter_params:</div>
<div class="line"><span class="lineno"> 2198</span>            kwds = {k: kwds[k] <span class="keywordflow">for</span> k <span class="keywordflow">in</span> kwds <span class="keywordflow">if</span> k <span class="keywordflow">in</span> KERNEL_PARAMS[metric]}</div>
<div class="line"><span class="lineno"> 2199</span>        func = PAIRWISE_KERNEL_FUNCTIONS[metric]</div>
<div class="line"><span class="lineno"> 2200</span>    <span class="keywordflow">elif</span> callable(metric):</div>
<div class="line"><span class="lineno"> 2201</span>        func = partial(_pairwise_callable, metric=metric, **kwds)</div>
<div class="line"><span class="lineno"> 2202</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2203</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unknown kernel %r&quot;</span> % metric)</div>
<div class="line"><span class="lineno"> 2204</span> </div>
<div class="line"><span class="lineno"> 2205</span>    <span class="keywordflow">return</span> _parallel_pairwise(X, Y, func, n_jobs, **kwds)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a43e13f5fedc89170766a4c72906ea889" name="a43e13f5fedc89170766a4c72906ea889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e13f5fedc89170766a4c72906ea889">&#9670;&#160;</a></span>polynomial_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.polynomial_kernel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coef0</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the polynomial kernel between X and Y.

:math:`K(X, Y) = (gamma &lt;X, Y&gt; + coef0)^{degree}`

Read more in the :ref:`User Guide &lt;polynomial_kernel&gt;`.

Parameters
----------
X : ndarray of shape (n_samples_X, n_features)
    A feature array.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. If `None`, uses `Y=X`.

degree : int, default=3
    Kernel degree.

gamma : float, default=None
    Coefficient of the vector inner product. If None, defaults to 1.0 / n_features.

coef0 : float, default=1
    Constant offset added to scaled inner product.

Returns
-------
Gram matrix : ndarray of shape (n_samples_X, n_samples_Y)
    The polynomial kernel.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1207</span><span class="keyword">def </span>polynomial_kernel(X, Y=None, degree=3, gamma=None, coef0=1):</div>
<div class="line"><span class="lineno"> 1208</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    Compute the polynomial kernel between X and Y.</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    :math:`K(X, Y) = (gamma &lt;X, Y&gt; + coef0)^{degree}`</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;polynomial_kernel&gt;`.</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">    degree : int, default=3</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">        Kernel degree.</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">    gamma : float, default=None</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">        Coefficient of the vector inner product. If None, defaults to 1.0 / n_features.</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    coef0 : float, default=1</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">        Constant offset added to scaled inner product.</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">    Gram matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">        The polynomial kernel.</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1237</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1238</span>    <span class="keywordflow">if</span> gamma <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1239</span>        gamma = 1.0 / X.shape[1]</div>
<div class="line"><span class="lineno"> 1240</span> </div>
<div class="line"><span class="lineno"> 1241</span>    K = safe_sparse_dot(X, Y.T, dense_output=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1242</span>    K *= gamma</div>
<div class="line"><span class="lineno"> 1243</span>    K += coef0</div>
<div class="line"><span class="lineno"> 1244</span>    K **= degree</div>
<div class="line"><span class="lineno"> 1245</span>    <span class="keywordflow">return</span> K</div>
<div class="line"><span class="lineno"> 1246</span> </div>
<div class="line"><span class="lineno"> 1247</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abb5e7b70ceb87ee2e1550f6f9e426f21" name="abb5e7b70ceb87ee2e1550f6f9e426f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5e7b70ceb87ee2e1550f6f9e426f21">&#9670;&#160;</a></span>rbf_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.rbf_kernel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the rbf (gaussian) kernel between X and Y.

    K(x, y) = exp(-gamma ||x-y||^2)

for each pair of rows x in X and y in Y.

Read more in the :ref:`User Guide &lt;rbf_kernel&gt;`.

Parameters
----------
X : ndarray of shape (n_samples_X, n_features)
    A feature array.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. If `None`, uses `Y=X`.

gamma : float, default=None
    If None, defaults to 1.0 / n_features.

Returns
-------
kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)
    The RBF kernel.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1285</span><span class="keyword">def </span>rbf_kernel(X, Y=None, gamma=None):</div>
<div class="line"><span class="lineno"> 1286</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the rbf (gaussian) kernel between X and Y.</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">        K(x, y) = exp(-gamma ||x-y||^2)</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    for each pair of rows x in X and y in Y.</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;rbf_kernel&gt;`.</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    gamma : float, default=None</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">        If None, defaults to 1.0 / n_features.</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    kernel_matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">        The RBF kernel.</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1310</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1311</span>    <span class="keywordflow">if</span> gamma <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1312</span>        gamma = 1.0 / X.shape[1]</div>
<div class="line"><span class="lineno"> 1313</span> </div>
<div class="line"><span class="lineno"> 1314</span>    K = euclidean_distances(X, Y, squared=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1315</span>    K *= -gamma</div>
<div class="line"><span class="lineno"> 1316</span>    np.exp(K, K)  <span class="comment"># exponentiate K in-place</span></div>
<div class="line"><span class="lineno"> 1317</span>    <span class="keywordflow">return</span> K</div>
<div class="line"><span class="lineno"> 1318</span> </div>
<div class="line"><span class="lineno"> 1319</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af6db26d255e118102602ae499bc84d66" name="af6db26d255e118102602ae499bc84d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6db26d255e118102602ae499bc84d66">&#9670;&#160;</a></span>sigmoid_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.pairwise.sigmoid_kernel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coef0</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the sigmoid kernel between X and Y.

    K(X, Y) = tanh(gamma &lt;X, Y&gt; + coef0)

Read more in the :ref:`User Guide &lt;sigmoid_kernel&gt;`.

Parameters
----------
X : ndarray of shape (n_samples_X, n_features)
    A feature array.

Y : ndarray of shape (n_samples_Y, n_features), default=None
    An optional second feature array. If `None`, uses `Y=X`.

gamma : float, default=None
    Coefficient of the vector inner product. If None, defaults to 1.0 / n_features.

coef0 : float, default=1
    Constant offset added to scaled inner product.

Returns
-------
Gram matrix : ndarray of shape (n_samples_X, n_samples_Y)
    Sigmoid kernel between two arrays.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1248</span><span class="keyword">def </span>sigmoid_kernel(X, Y=None, gamma=None, coef0=1):</div>
<div class="line"><span class="lineno"> 1249</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the sigmoid kernel between X and Y.</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">        K(X, Y) = tanh(gamma &lt;X, Y&gt; + coef0)</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;sigmoid_kernel&gt;`.</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">    X : ndarray of shape (n_samples_X, n_features)</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">        A feature array.</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    Y : ndarray of shape (n_samples_Y, n_features), default=None</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">        An optional second feature array. If `None`, uses `Y=X`.</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    gamma : float, default=None</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">        Coefficient of the vector inner product. If None, defaults to 1.0 / n_features.</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">    coef0 : float, default=1</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        Constant offset added to scaled inner product.</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    Gram matrix : ndarray of shape (n_samples_X, n_samples_Y)</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">        Sigmoid kernel between two arrays.</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1274</span>    X, Y = check_pairwise_arrays(X, Y)</div>
<div class="line"><span class="lineno"> 1275</span>    <span class="keywordflow">if</span> gamma <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1276</span>        gamma = 1.0 / X.shape[1]</div>
<div class="line"><span class="lineno"> 1277</span> </div>
<div class="line"><span class="lineno"> 1278</span>    K = safe_sparse_dot(X, Y.T, dense_output=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1279</span>    K *= gamma</div>
<div class="line"><span class="lineno"> 1280</span>    K += coef0</div>
<div class="line"><span class="lineno"> 1281</span>    np.tanh(K, K)  <span class="comment"># compute tanh in-place</span></div>
<div class="line"><span class="lineno"> 1282</span>    <span class="keywordflow">return</span> K</div>
<div class="line"><span class="lineno"> 1283</span> </div>
<div class="line"><span class="lineno"> 1284</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9672ff97d09bd0f0902492b41f49617f" name="a9672ff97d09bd0f0902492b41f49617f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9672ff97d09bd0f0902492b41f49617f">&#9670;&#160;</a></span>_NAN_METRICS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list sklearn.metrics.pairwise._NAN_METRICS = [&quot;nan_euclidean&quot;]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00cb016eedfbee5454a2f62a587d5c4a" name="a00cb016eedfbee5454a2f62a587d5c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cb016eedfbee5454a2f62a587d5c4a">&#9670;&#160;</a></span>_VALID_METRICS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list sklearn.metrics.pairwise._VALID_METRICS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;euclidean&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;l2&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;l1&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;manhattan&quot;</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;cityblock&quot;</span>,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;braycurtis&quot;</span>,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;canberra&quot;</span>,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;chebyshev&quot;</span>,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;correlation&quot;</span>,</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&quot;cosine&quot;</span>,</div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">&quot;dice&quot;</span>,</div>
<div class="line"><span class="lineno">   13</span>    <span class="stringliteral">&quot;hamming&quot;</span>,</div>
<div class="line"><span class="lineno">   14</span>    <span class="stringliteral">&quot;jaccard&quot;</span>,</div>
<div class="line"><span class="lineno">   15</span>    <span class="stringliteral">&quot;kulsinski&quot;</span>,</div>
<div class="line"><span class="lineno">   16</span>    <span class="stringliteral">&quot;mahalanobis&quot;</span>,</div>
<div class="line"><span class="lineno">   17</span>    <span class="stringliteral">&quot;matching&quot;</span>,</div>
<div class="line"><span class="lineno">   18</span>    <span class="stringliteral">&quot;minkowski&quot;</span>,</div>
<div class="line"><span class="lineno">   19</span>    <span class="stringliteral">&quot;rogerstanimoto&quot;</span>,</div>
<div class="line"><span class="lineno">   20</span>    <span class="stringliteral">&quot;russellrao&quot;</span>,</div>
<div class="line"><span class="lineno">   21</span>    <span class="stringliteral">&quot;seuclidean&quot;</span>,</div>
<div class="line"><span class="lineno">   22</span>    <span class="stringliteral">&quot;sokalmichener&quot;</span>,</div>
<div class="line"><span class="lineno">   23</span>    <span class="stringliteral">&quot;sokalsneath&quot;</span>,</div>
<div class="line"><span class="lineno">   24</span>    <span class="stringliteral">&quot;sqeuclidean&quot;</span>,</div>
<div class="line"><span class="lineno">   25</span>    <span class="stringliteral">&quot;yule&quot;</span>,</div>
<div class="line"><span class="lineno">   26</span>    <span class="stringliteral">&quot;wminkowski&quot;</span>,</div>
<div class="line"><span class="lineno">   27</span>    <span class="stringliteral">&quot;nan_euclidean&quot;</span>,</div>
<div class="line"><span class="lineno">   28</span>    <span class="stringliteral">&quot;haversine&quot;</span>,</div>
<div class="line"><span class="lineno">   29</span>]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9be78123081bcdd32773380e0cf917e5" name="a9be78123081bcdd32773380e0cf917e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be78123081bcdd32773380e0cf917e5">&#9670;&#160;</a></span>KERNEL_PARAMS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict sklearn.metrics.pairwise.KERNEL_PARAMS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;additive_chi2&quot;</span>: (),</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;chi2&quot;</span>: frozenset([<span class="stringliteral">&quot;gamma&quot;</span>]),</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;cosine&quot;</span>: (),</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;linear&quot;</span>: (),</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;poly&quot;</span>: frozenset([<span class="stringliteral">&quot;gamma&quot;</span>, <span class="stringliteral">&quot;degree&quot;</span>, <span class="stringliteral">&quot;coef0&quot;</span>]),</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;polynomial&quot;</span>: frozenset([<span class="stringliteral">&quot;gamma&quot;</span>, <span class="stringliteral">&quot;degree&quot;</span>, <span class="stringliteral">&quot;coef0&quot;</span>]),</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;rbf&quot;</span>: frozenset([<span class="stringliteral">&quot;gamma&quot;</span>]),</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;laplacian&quot;</span>: frozenset([<span class="stringliteral">&quot;gamma&quot;</span>]),</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;sigmoid&quot;</span>: frozenset([<span class="stringliteral">&quot;gamma&quot;</span>, <span class="stringliteral">&quot;coef0&quot;</span>]),</div>
<div class="line"><span class="lineno">   11</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aedd1a704e6ae40bef4615b0a68182c8e" name="aedd1a704e6ae40bef4615b0a68182c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd1a704e6ae40bef4615b0a68182c8e">&#9670;&#160;</a></span>PAIRED_DISTANCES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict sklearn.metrics.pairwise.PAIRED_DISTANCES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;cosine&quot;</span>: paired_cosine_distances,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;euclidean&quot;</span>: paired_euclidean_distances,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;l2&quot;</span>: paired_euclidean_distances,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;l1&quot;</span>: paired_manhattan_distances,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;manhattan&quot;</span>: paired_manhattan_distances,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;cityblock&quot;</span>: paired_manhattan_distances,</div>
<div class="line"><span class="lineno">    8</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad138062df624ab0d52e9da2424739e7b" name="ad138062df624ab0d52e9da2424739e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad138062df624ab0d52e9da2424739e7b">&#9670;&#160;</a></span>PAIRWISE_BOOLEAN_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list sklearn.metrics.pairwise.PAIRWISE_BOOLEAN_FUNCTIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;dice&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;jaccard&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;kulsinski&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;matching&quot;</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;rogerstanimoto&quot;</span>,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;russellrao&quot;</span>,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;sokalmichener&quot;</span>,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;sokalsneath&quot;</span>,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;yule&quot;</span>,</div>
<div class="line"><span class="lineno">   11</span>]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6318e9b211cca80a664e66d03ce217ee" name="a6318e9b211cca80a664e66d03ce217ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6318e9b211cca80a664e66d03ce217ee">&#9670;&#160;</a></span>PAIRWISE_DISTANCE_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict sklearn.metrics.pairwise.PAIRWISE_DISTANCE_FUNCTIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="comment"># If updating this dictionary, update the doc in both distance_metrics()</span></div>
<div class="line"><span class="lineno">    3</span>    <span class="comment"># and also in pairwise_distances()!</span></div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;cityblock&quot;</span>: manhattan_distances,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;cosine&quot;</span>: cosine_distances,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;euclidean&quot;</span>: euclidean_distances,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;haversine&quot;</span>: haversine_distances,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;l2&quot;</span>: euclidean_distances,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;l1&quot;</span>: manhattan_distances,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;manhattan&quot;</span>: manhattan_distances,</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&quot;precomputed&quot;</span>: <span class="keywordtype">None</span>,  <span class="comment"># HACK: precomputed is always allowed, never called</span></div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">&quot;nan_euclidean&quot;</span>: nan_euclidean_distances,</div>
<div class="line"><span class="lineno">   13</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5250b388161c58372f80b0d3263a2ad1" name="a5250b388161c58372f80b0d3263a2ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5250b388161c58372f80b0d3263a2ad1">&#9670;&#160;</a></span>PAIRWISE_KERNEL_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict sklearn.metrics.pairwise.PAIRWISE_KERNEL_FUNCTIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="comment"># If updating this dictionary, update the doc in both distance_metrics()</span></div>
<div class="line"><span class="lineno">    3</span>    <span class="comment"># and also in pairwise_distances()!</span></div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;additive_chi2&quot;</span>: additive_chi2_kernel,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;chi2&quot;</span>: chi2_kernel,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;linear&quot;</span>: linear_kernel,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;polynomial&quot;</span>: polynomial_kernel,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;poly&quot;</span>: polynomial_kernel,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;rbf&quot;</span>: rbf_kernel,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;laplacian&quot;</span>: laplacian_kernel,</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&quot;sigmoid&quot;</span>: sigmoid_kernel,</div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">&quot;cosine&quot;</span>: cosine_similarity,</div>
<div class="line"><span class="lineno">   13</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
