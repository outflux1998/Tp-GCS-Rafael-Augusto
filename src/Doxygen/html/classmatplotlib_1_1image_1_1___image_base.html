<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.image._ImageBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1image.html">image</a></li><li class="navelem"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html">_ImageBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmatplotlib_1_1image_1_1___image_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.image._ImageBase Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for matplotlib.image._ImageBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmatplotlib_1_1image_1_1___image_base.png" usemap="#matplotlib.image._5FImageBase_map" alt=""/>
  <map id="matplotlib.image._5FImageBase_map" name="matplotlib.image._5FImageBase_map">
<area href="classmatplotlib_1_1cm_1_1_scalar_mappable.html" alt="matplotlib.cm.ScalarMappable" shape="rect" coords="428,0,632,24"/>
<area href="classmatplotlib_1_1image_1_1_axes_image.html" alt="matplotlib.image.AxesImage" shape="rect" coords="107,112,311,136"/>
<area href="classmatplotlib_1_1image_1_1_bbox_image.html" alt="matplotlib.image.BboxImage" shape="rect" coords="321,112,525,136"/>
<area href="classmatplotlib_1_1image_1_1_figure_image.html" alt="matplotlib.image.FigureImage" shape="rect" coords="535,112,739,136"/>
<area href="classmatplotlib_1_1image_1_1_non_uniform_image.html" alt="matplotlib.image.NonUniformImage" shape="rect" coords="0,168,204,192"/>
<area href="classmatplotlib_1_1image_1_1_pcolor_image.html" alt="matplotlib.image.PcolorImage" shape="rect" coords="214,168,418,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0616f58ce2301abe89a1c02796478689" id="r_a0616f58ce2301abe89a1c02796478689"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a0616f58ce2301abe89a1c02796478689">__init__</a> (self, ax, <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a3684ebc12a81cc6f2599c0babd1d40af">cmap</a>=None, <a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a6f9f162e89a42975fbce66440683328a">norm</a>=None, interpolation=None, <a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#aebc786349e152a9dc981ffde5bc39795">origin</a>=None, filternorm=True, filterrad=4.0, resample=False, *interpolation_stage=None, **kwargs)</td></tr>
<tr class="separator:a0616f58ce2301abe89a1c02796478689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44c4dc0677a4858410f9d099a593b69" id="r_aa44c4dc0677a4858410f9d099a593b69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#aa44c4dc0677a4858410f9d099a593b69">__str__</a> (self)</td></tr>
<tr class="separator:aa44c4dc0677a4858410f9d099a593b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644d5d06f4a3829af7043255a8570eab" id="r_a644d5d06f4a3829af7043255a8570eab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a644d5d06f4a3829af7043255a8570eab">__getstate__</a> (self)</td></tr>
<tr class="separator:a644d5d06f4a3829af7043255a8570eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353484f615b500f383877248eec3ba47" id="r_a353484f615b500f383877248eec3ba47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a353484f615b500f383877248eec3ba47">get_size</a> (self)</td></tr>
<tr class="separator:a353484f615b500f383877248eec3ba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c6d99617d8803f499aede68f54ed2" id="r_a367c6d99617d8803f499aede68f54ed2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a367c6d99617d8803f499aede68f54ed2">set_alpha</a> (self, <a class="el" href="__blas__subroutines_8h.html#a29dda7d0819a860e921db821deb590c9">alpha</a>)</td></tr>
<tr class="separator:a367c6d99617d8803f499aede68f54ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0d6d6ffe4015e5165c20a588959ad0" id="r_aab0d6d6ffe4015e5165c20a588959ad0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#aab0d6d6ffe4015e5165c20a588959ad0">changed</a> (self)</td></tr>
<tr class="separator:aab0d6d6ffe4015e5165c20a588959ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdf642c0367e4a25069fe263d278616" id="r_adbdf642c0367e4a25069fe263d278616"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#adbdf642c0367e4a25069fe263d278616">make_image</a> (self, renderer, magnification=1.0, unsampled=False)</td></tr>
<tr class="separator:adbdf642c0367e4a25069fe263d278616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbae7e711df41da43bf1842de5fe21ec" id="r_afbae7e711df41da43bf1842de5fe21ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#afbae7e711df41da43bf1842de5fe21ec">draw</a> (self, renderer, *args, **kwargs)</td></tr>
<tr class="separator:afbae7e711df41da43bf1842de5fe21ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe60c3a610dcad050d6405e94946d59" id="r_a2fe60c3a610dcad050d6405e94946d59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a2fe60c3a610dcad050d6405e94946d59">contains</a> (self, mouseevent)</td></tr>
<tr class="separator:a2fe60c3a610dcad050d6405e94946d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba42a1aa52c957a58a127d43fb1cccaa" id="r_aba42a1aa52c957a58a127d43fb1cccaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#aba42a1aa52c957a58a127d43fb1cccaa">write_png</a> (self, fname)</td></tr>
<tr class="separator:aba42a1aa52c957a58a127d43fb1cccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627bc31fce4803fbc6e1ec6e616aa92f" id="r_a627bc31fce4803fbc6e1ec6e616aa92f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a627bc31fce4803fbc6e1ec6e616aa92f">set_data</a> (self, A)</td></tr>
<tr class="separator:a627bc31fce4803fbc6e1ec6e616aa92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea076e6bbccf18dadbd19a43c82c7183" id="r_aea076e6bbccf18dadbd19a43c82c7183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#aea076e6bbccf18dadbd19a43c82c7183">set_array</a> (self, A)</td></tr>
<tr class="separator:aea076e6bbccf18dadbd19a43c82c7183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82814068c8c2731c1205339c4d860b34" id="r_a82814068c8c2731c1205339c4d860b34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a82814068c8c2731c1205339c4d860b34">get_interpolation</a> (self)</td></tr>
<tr class="separator:a82814068c8c2731c1205339c4d860b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b99b2e1d4e4f06a22f6c01742ac5ea" id="r_a78b99b2e1d4e4f06a22f6c01742ac5ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a78b99b2e1d4e4f06a22f6c01742ac5ea">set_interpolation</a> (self, s)</td></tr>
<tr class="separator:a78b99b2e1d4e4f06a22f6c01742ac5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72f8b24b4c951a85e4bba6e555f90f0" id="r_ac72f8b24b4c951a85e4bba6e555f90f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ac72f8b24b4c951a85e4bba6e555f90f0">set_interpolation_stage</a> (self, s)</td></tr>
<tr class="separator:ac72f8b24b4c951a85e4bba6e555f90f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8acd31409e2bc7771bb8c4ed8c0e91" id="r_aed8acd31409e2bc7771bb8c4ed8c0e91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#aed8acd31409e2bc7771bb8c4ed8c0e91">can_composite</a> (self)</td></tr>
<tr class="separator:aed8acd31409e2bc7771bb8c4ed8c0e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4fb5fc7b6376cbe8ae6087df575c7c" id="r_a3d4fb5fc7b6376cbe8ae6087df575c7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a3d4fb5fc7b6376cbe8ae6087df575c7c">set_resample</a> (self, v)</td></tr>
<tr class="separator:a3d4fb5fc7b6376cbe8ae6087df575c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803a5a1f40643e11762ea0b97711d016" id="r_a803a5a1f40643e11762ea0b97711d016"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a803a5a1f40643e11762ea0b97711d016">get_resample</a> (self)</td></tr>
<tr class="separator:a803a5a1f40643e11762ea0b97711d016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db901deb5ec5bb8a23258bd96888ac9" id="r_a4db901deb5ec5bb8a23258bd96888ac9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a4db901deb5ec5bb8a23258bd96888ac9">set_filternorm</a> (self, filternorm)</td></tr>
<tr class="separator:a4db901deb5ec5bb8a23258bd96888ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5352e07e341beb11e5c8aa5a04d47e5" id="r_ae5352e07e341beb11e5c8aa5a04d47e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ae5352e07e341beb11e5c8aa5a04d47e5">get_filternorm</a> (self)</td></tr>
<tr class="separator:ae5352e07e341beb11e5c8aa5a04d47e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a209090364b3b0bd4d2e9c501017e2" id="r_a21a209090364b3b0bd4d2e9c501017e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a21a209090364b3b0bd4d2e9c501017e2">set_filterrad</a> (self, filterrad)</td></tr>
<tr class="separator:a21a209090364b3b0bd4d2e9c501017e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e62e1539c9465006a5ec0c51ee5b41" id="r_ac8e62e1539c9465006a5ec0c51ee5b41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ac8e62e1539c9465006a5ec0c51ee5b41">get_filterrad</a> (self)</td></tr>
<tr class="separator:ac8e62e1539c9465006a5ec0c51ee5b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html">matplotlib.cm.ScalarMappable</a></td></tr>
<tr class="memitem:a95c6f0fd7b24e01f755c8ea4904f0f49 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a95c6f0fd7b24e01f755c8ea4904f0f49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a95c6f0fd7b24e01f755c8ea4904f0f49">to_rgba</a> (self, x, <a class="el" href="__blas__subroutines_8h.html#a29dda7d0819a860e921db821deb590c9">alpha</a>=None, bytes=False, <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a5507985e8c38feaa3d6972f75db09f73">norm</a>=True)</td></tr>
<tr class="separator:a95c6f0fd7b24e01f755c8ea4904f0f49 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f97051f01f32a5c790efd738a309e inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a731f97051f01f32a5c790efd738a309e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a731f97051f01f32a5c790efd738a309e">get_array</a> (self)</td></tr>
<tr class="separator:a731f97051f01f32a5c790efd738a309e inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8239dea24b35d95956ec33e35d2bc47 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_ae8239dea24b35d95956ec33e35d2bc47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#ae8239dea24b35d95956ec33e35d2bc47">get_cmap</a> (self)</td></tr>
<tr class="separator:ae8239dea24b35d95956ec33e35d2bc47 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c1141a0f68fb4a166f181350b3027e inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a21c1141a0f68fb4a166f181350b3027e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a21c1141a0f68fb4a166f181350b3027e">get_clim</a> (self)</td></tr>
<tr class="separator:a21c1141a0f68fb4a166f181350b3027e inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0eced04bd0496f5186b4e587211751 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a1d0eced04bd0496f5186b4e587211751"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a1d0eced04bd0496f5186b4e587211751">set_clim</a> (self, vmin=None, vmax=None)</td></tr>
<tr class="separator:a1d0eced04bd0496f5186b4e587211751 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43d441eedafd7fcf97a5ac185825487 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_ae43d441eedafd7fcf97a5ac185825487"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#ae43d441eedafd7fcf97a5ac185825487">get_alpha</a> (self)</td></tr>
<tr class="separator:ae43d441eedafd7fcf97a5ac185825487 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc77ecb6d70b5d999f919e04a9a1068f inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_acc77ecb6d70b5d999f919e04a9a1068f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#acc77ecb6d70b5d999f919e04a9a1068f">set_cmap</a> (self, <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a3684ebc12a81cc6f2599c0babd1d40af">cmap</a>)</td></tr>
<tr class="separator:acc77ecb6d70b5d999f919e04a9a1068f inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3353fb47f1e1e9611eb1b1e24a8488 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a5b3353fb47f1e1e9611eb1b1e24a8488"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a5b3353fb47f1e1e9611eb1b1e24a8488">norm</a> (self)</td></tr>
<tr class="separator:a5b3353fb47f1e1e9611eb1b1e24a8488 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cabf4fed8f24465c40ec49dc12b0f3e inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a9cabf4fed8f24465c40ec49dc12b0f3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a9cabf4fed8f24465c40ec49dc12b0f3e">norm</a> (self, norm)</td></tr>
<tr class="separator:a9cabf4fed8f24465c40ec49dc12b0f3e inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385e06effbd3ddd162f40b9fa9860815 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a385e06effbd3ddd162f40b9fa9860815"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a385e06effbd3ddd162f40b9fa9860815">set_norm</a> (self, <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a5507985e8c38feaa3d6972f75db09f73">norm</a>)</td></tr>
<tr class="separator:a385e06effbd3ddd162f40b9fa9860815 inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630a51687457d3369b3999141644b62f inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a630a51687457d3369b3999141644b62f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a630a51687457d3369b3999141644b62f">autoscale</a> (self)</td></tr>
<tr class="separator:a630a51687457d3369b3999141644b62f inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab55e79baa02225110159c34057b05bd inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_aab55e79baa02225110159c34057b05bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#aab55e79baa02225110159c34057b05bd">autoscale_None</a> (self)</td></tr>
<tr class="separator:aab55e79baa02225110159c34057b05bd inherit pub_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aebc786349e152a9dc981ffde5bc39795" id="r_aebc786349e152a9dc981ffde5bc39795"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#aebc786349e152a9dc981ffde5bc39795">origin</a></td></tr>
<tr class="separator:aebc786349e152a9dc981ffde5bc39795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64950607e4dc75dade3a971f14c874fb" id="r_a64950607e4dc75dade3a971f14c874fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a64950607e4dc75dade3a971f14c874fb">axes</a></td></tr>
<tr class="separator:a64950607e4dc75dade3a971f14c874fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9f162e89a42975fbce66440683328a" id="r_a6f9f162e89a42975fbce66440683328a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a6f9f162e89a42975fbce66440683328a">norm</a></td></tr>
<tr class="separator:a6f9f162e89a42975fbce66440683328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4761bf7ee5af318e64311c4f0349d9" id="r_afa4761bf7ee5af318e64311c4f0349d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#afa4761bf7ee5af318e64311c4f0349d9">stale</a></td></tr>
<tr class="separator:afa4761bf7ee5af318e64311c4f0349d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html">matplotlib.cm.ScalarMappable</a></td></tr>
<tr class="memitem:a3684ebc12a81cc6f2599c0babd1d40af inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a3684ebc12a81cc6f2599c0babd1d40af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a3684ebc12a81cc6f2599c0babd1d40af">cmap</a></td></tr>
<tr class="separator:a3684ebc12a81cc6f2599c0babd1d40af inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5153949edc783718d04da55940c42186 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a5153949edc783718d04da55940c42186"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a5153949edc783718d04da55940c42186">colorbar</a></td></tr>
<tr class="separator:a5153949edc783718d04da55940c42186 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816543c416d761685ba24dc7b2e71254 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a816543c416d761685ba24dc7b2e71254"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a816543c416d761685ba24dc7b2e71254">callbacks</a></td></tr>
<tr class="separator:a816543c416d761685ba24dc7b2e71254 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5507985e8c38feaa3d6972f75db09f73 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a5507985e8c38feaa3d6972f75db09f73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a5507985e8c38feaa3d6972f75db09f73">norm</a></td></tr>
<tr class="separator:a5507985e8c38feaa3d6972f75db09f73 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7638f2b6c5b223b2b2392f0c66dbfed9 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a7638f2b6c5b223b2b2392f0c66dbfed9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a7638f2b6c5b223b2b2392f0c66dbfed9">stale</a></td></tr>
<tr class="separator:a7638f2b6c5b223b2b2392f0c66dbfed9 inherit pub_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8f3acf11a85ca1a4bb68009e2905a3a9" id="r_a8f3acf11a85ca1a4bb68009e2905a3a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a8f3acf11a85ca1a4bb68009e2905a3a9">zorder</a> = 0</td></tr>
<tr class="separator:a8f3acf11a85ca1a4bb68009e2905a3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html">matplotlib.cm.ScalarMappable</a></td></tr>
<tr class="memitem:a8fd7de7a97ab3d0543d04e7cd5783fdf inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a8fd7de7a97ab3d0543d04e7cd5783fdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a8fd7de7a97ab3d0543d04e7cd5783fdf">callbacksSM</a></td></tr>
<tr class="separator:a8fd7de7a97ab3d0543d04e7cd5783fdf inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72bd0693fd710693b37a976fe643692 inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_ad72bd0693fd710693b37a976fe643692"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#ad72bd0693fd710693b37a976fe643692">cmap_doc</a></td></tr>
<tr class="separator:ad72bd0693fd710693b37a976fe643692 inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30677005612ef1bc3e4640c20376f10 inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_ad30677005612ef1bc3e4640c20376f10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#ad30677005612ef1bc3e4640c20376f10">norm_doc</a></td></tr>
<tr class="separator:ad30677005612ef1bc3e4640c20376f10 inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71924bf998fd2c0d45b75044c461412a inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a71924bf998fd2c0d45b75044c461412a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a71924bf998fd2c0d45b75044c461412a">vmin_vmax_doc</a></td></tr>
<tr class="separator:a71924bf998fd2c0d45b75044c461412a inherit pub_static_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9be7fc614c00ccbca47edba43dbf5d2d" id="r_a9be7fc614c00ccbca47edba43dbf5d2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a9be7fc614c00ccbca47edba43dbf5d2d">_get_scalar_alpha</a> (self)</td></tr>
<tr class="separator:a9be7fc614c00ccbca47edba43dbf5d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37703ab3a1526663e95806e387775937" id="r_a37703ab3a1526663e95806e387775937"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a37703ab3a1526663e95806e387775937">_make_image</a> (self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0, unsampled=False, round_to_pixel_border=True)</td></tr>
<tr class="separator:a37703ab3a1526663e95806e387775937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58407cb939ef9c7c1b8d51825b116aab" id="r_a58407cb939ef9c7c1b8d51825b116aab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a58407cb939ef9c7c1b8d51825b116aab">_check_unsampled_image</a> (self)</td></tr>
<tr class="separator:a58407cb939ef9c7c1b8d51825b116aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmatplotlib_1_1cm_1_1_scalar_mappable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html">matplotlib.cm.ScalarMappable</a></td></tr>
<tr class="memitem:a377a9a7390e23503dee28ccfb3940998 inherit pro_methods_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a377a9a7390e23503dee28ccfb3940998"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a377a9a7390e23503dee28ccfb3940998">_scale_norm</a> (self, <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a5507985e8c38feaa3d6972f75db09f73">norm</a>, vmin, vmax)</td></tr>
<tr class="separator:a377a9a7390e23503dee28ccfb3940998 inherit pro_methods_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae213d94ed077248cdece4090f54880cd" id="r_ae213d94ed077248cdece4090f54880cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ae213d94ed077248cdece4090f54880cd">_imcache</a></td></tr>
<tr class="separator:ae213d94ed077248cdece4090f54880cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8eb99cb1f02cd166af6d689b5aa07e" id="r_ada8eb99cb1f02cd166af6d689b5aa07e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ada8eb99cb1f02cd166af6d689b5aa07e">_alpha</a></td></tr>
<tr class="separator:ada8eb99cb1f02cd166af6d689b5aa07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab406bea232727b6e129a7cb2981a6409" id="r_ab406bea232727b6e129a7cb2981a6409"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ab406bea232727b6e129a7cb2981a6409">_A</a></td></tr>
<tr class="separator:ab406bea232727b6e129a7cb2981a6409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f8fc1b9ab7bf26d8e339bee08da945" id="r_a35f8fc1b9ab7bf26d8e339bee08da945"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a35f8fc1b9ab7bf26d8e339bee08da945">_interpolation</a></td></tr>
<tr class="separator:a35f8fc1b9ab7bf26d8e339bee08da945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8bf4966b4172c4837933845eac5e0a" id="r_a3c8bf4966b4172c4837933845eac5e0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a3c8bf4966b4172c4837933845eac5e0a">_interpolation_stage</a></td></tr>
<tr class="separator:a3c8bf4966b4172c4837933845eac5e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22ae403e4b99cc76cd7236c3bc45fd8" id="r_ad22ae403e4b99cc76cd7236c3bc45fd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ad22ae403e4b99cc76cd7236c3bc45fd8">_resample</a></td></tr>
<tr class="separator:ad22ae403e4b99cc76cd7236c3bc45fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2907ee51b357347d70d01efbf784cafa" id="r_a2907ee51b357347d70d01efbf784cafa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#a2907ee51b357347d70d01efbf784cafa">_filternorm</a></td></tr>
<tr class="separator:a2907ee51b357347d70d01efbf784cafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3684896ed401090c2040faab891ea5c" id="r_ab3684896ed401090c2040faab891ea5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1image_1_1___image_base.html#ab3684896ed401090c2040faab891ea5c">_filterrad</a></td></tr>
<tr class="separator:ab3684896ed401090c2040faab891ea5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html">matplotlib.cm.ScalarMappable</a></td></tr>
<tr class="memitem:a0007c013b87fa5141f2328d6e190e232 inherit pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a0007c013b87fa5141f2328d6e190e232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a0007c013b87fa5141f2328d6e190e232">_A</a></td></tr>
<tr class="separator:a0007c013b87fa5141f2328d6e190e232 inherit pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34358cfb275ff47fef3cabe6e1eed3c3 inherit pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_a34358cfb275ff47fef3cabe6e1eed3c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a34358cfb275ff47fef3cabe6e1eed3c3">_norm</a></td></tr>
<tr class="separator:a34358cfb275ff47fef3cabe6e1eed3c3 inherit pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac580fc267164def90960510407f65359 inherit pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable" id="r_ac580fc267164def90960510407f65359"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#ac580fc267164def90960510407f65359">_id_norm</a></td></tr>
<tr class="separator:ac580fc267164def90960510407f65359 inherit pro_attribs_classmatplotlib_1_1cm_1_1_scalar_mappable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Base class for images.

interpolation and cmap default to their rc settings

cmap is a colors.Colormap instance
norm is a colors.Normalize instance to map luminance to 0-1

extent is data axes (left, right, bottom, top) for making image plots
registered with data plots.  Default is to label the pixel
centers with the zero-based row and column indices.

Additional kwargs are matplotlib.artist properties
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0616f58ce2301abe89a1c02796478689" name="a0616f58ce2301abe89a1c02796478689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0616f58ce2301abe89a1c02796478689">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cmap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filternorm</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filterrad</em> = <code>4.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>resample</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation_stage</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
norm : `.Normalize` (or subclass thereof) or str or None
    The normalizing object which scales data, typically into the
    interval ``[0, 1]``.
    If a `str`, a `.Normalize` subclass is dynamically generated based
    on the scale with the corresponding name.
    If *None*, *norm* defaults to a *colors.Normalize* object which
    initializes its scaling based on the first data processed.
cmap : str or `~matplotlib.colors.Colormap`
    The colormap used to map normalized data values to RGBA colors.
</pre> 
<p>Reimplemented from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a1fcc377630a7a5d799e0316a0e745b8d">matplotlib.cm.ScalarMappable</a>.</p>

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#af4b87fa8a2362bd43d19a806f5eb5b67">matplotlib.image.NonUniformImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_axes_image.html#a129dd47f1fb3d95110a1d027b2682151">matplotlib.image.AxesImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_pcolor_image.html#af2a760aa0243ea0bc001a7fd9315fd4b">matplotlib.image.PcolorImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_bbox_image.html#a45ce104144591ea267ff1d2ca0d8973a">matplotlib.image.BboxImage</a>, and <a class="el" href="classmatplotlib_1_1image_1_1_figure_image.html#ac64999655253070abecc9cd9d53028e5">matplotlib.image.FigureImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  258</span>                 ):</div>
<div class="line"><span class="lineno">  259</span>        martist.Artist.__init__(self)</div>
<div class="line"><span class="lineno">  260</span>        cm.ScalarMappable.__init__(self, norm, cmap)</div>
<div class="line"><span class="lineno">  261</span>        <span class="keywordflow">if</span> origin <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  262</span>            origin = mpl.rcParams[<span class="stringliteral">&#39;image.origin&#39;</span>]</div>
<div class="line"><span class="lineno">  263</span>        _api.check_in_list([<span class="stringliteral">&quot;upper&quot;</span>, <span class="stringliteral">&quot;lower&quot;</span>], origin=origin)</div>
<div class="line"><span class="lineno">  264</span>        self.origin = origin</div>
<div class="line"><span class="lineno">  265</span>        self.set_filternorm(filternorm)</div>
<div class="line"><span class="lineno">  266</span>        self.set_filterrad(filterrad)</div>
<div class="line"><span class="lineno">  267</span>        self.set_interpolation(interpolation)</div>
<div class="line"><span class="lineno">  268</span>        self.set_interpolation_stage(interpolation_stage)</div>
<div class="line"><span class="lineno">  269</span>        self.set_resample(resample)</div>
<div class="line"><span class="lineno">  270</span>        self.axes = ax</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span>        self._imcache = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  273</span> </div>
<div class="line"><span class="lineno">  274</span>        self._internal_update(kwargs)</div>
<div class="line"><span class="lineno">  275</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a644d5d06f4a3829af7043255a8570eab" name="a644d5d06f4a3829af7043255a8570eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644d5d06f4a3829af7043255a8570eab">&#9670;&#160;</a></span>__getstate__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.__getstate__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  283</span>    <span class="keyword">def </span>__getstate__(self):</div>
<div class="line"><span class="lineno">  284</span>        <span class="comment"># Save some space on the pickle by not saving the cache.</span></div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">return</span> {**super().__getstate__(), <span class="stringliteral">&quot;_imcache&quot;</span>: <span class="keywordtype">None</span>}</div>
<div class="line"><span class="lineno">  286</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa44c4dc0677a4858410f9d099a593b69" name="aa44c4dc0677a4858410f9d099a593b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44c4dc0677a4858410f9d099a593b69">&#9670;&#160;</a></span>__str__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.__str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  276</span>    <span class="keyword">def </span>__str__(self):</div>
<div class="line"><span class="lineno">  277</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  278</span>            size = self.get_size()</div>
<div class="line"><span class="lineno">  279</span>            <span class="keywordflow">return</span> f<span class="stringliteral">&quot;{type(self).__name__}(size={size!r})&quot;</span></div>
<div class="line"><span class="lineno">  280</span>        <span class="keywordflow">except</span> RuntimeError:</div>
<div class="line"><span class="lineno">  281</span>            <span class="keywordflow">return</span> type(self).__name__</div>
<div class="line"><span class="lineno">  282</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a58407cb939ef9c7c1b8d51825b116aab" name="a58407cb939ef9c7c1b8d51825b116aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58407cb939ef9c7c1b8d51825b116aab">&#9670;&#160;</a></span>_check_unsampled_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._check_unsampled_image </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return whether the image is better to be drawn unsampled.

The derived class needs to override it.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_axes_image.html#a240136a78716b1298ba240aa3297a7bf">matplotlib.image.AxesImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#a528738c0fe291535fe19b4b92dd3e921">matplotlib.image.NonUniformImage</a>, and <a class="el" href="classmatplotlib_1_1image_1_1_pcolor_image.html#a2335113c412c9b9a1d3f687afe363dd1">matplotlib.image.PcolorImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  609</span>    <span class="keyword">def </span>_check_unsampled_image(self):</div>
<div class="line"><span class="lineno">  610</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">        Return whether the image is better to be drawn unsampled.</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">        The derived class needs to override it.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  615</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  616</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9be7fc614c00ccbca47edba43dbf5d2d" name="a9be7fc614c00ccbca47edba43dbf5d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be7fc614c00ccbca47edba43dbf5d2d">&#9670;&#160;</a></span>_get_scalar_alpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._get_scalar_alpha </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get a scalar alpha value to be applied to the artist as a whole.

If the alpha value is a matrix, the method returns 1.0 because pixels
have individual alpha values (see `~._ImageBase._make_image` for
details). If the alpha value is a scalar, the method returns said value
to be applied to the artist as a whole because pixels do not have
individual alpha values.
</pre> <div class="fragment"><div class="line"><span class="lineno">  308</span>    <span class="keyword">def </span>_get_scalar_alpha(self):</div>
<div class="line"><span class="lineno">  309</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        Get a scalar alpha value to be applied to the artist as a whole.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        If the alpha value is a matrix, the method returns 1.0 because pixels</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        have individual alpha values (see `~._ImageBase._make_image` for</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">        details). If the alpha value is a scalar, the method returns said value</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        to be applied to the artist as a whole because pixels do not have</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">        individual alpha values.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  318</span>        <span class="keywordflow">return</span> 1.0 <span class="keywordflow">if</span> self._alpha <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> np.ndim(self._alpha) &gt; 0 \</div>
<div class="line"><span class="lineno">  319</span>            <span class="keywordflow">else</span> self._alpha</div>
<div class="line"><span class="lineno">  320</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a37703ab3a1526663e95806e387775937" name="a37703ab3a1526663e95806e387775937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37703ab3a1526663e95806e387775937">&#9670;&#160;</a></span>_make_image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._make_image </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in_bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clip_bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>magnification</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unsampled</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>round_to_pixel_border</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Normalize, rescale, and colormap the image *A* from the given *in_bbox*
(in data space), to the given *out_bbox* (in pixel space) clipped to
the given *clip_bbox* (also in pixel space), and magnified by the
*magnification* factor.

*A* may be a greyscale image (M, N) with a dtype of float32, float64,
float128, uint16 or uint8, or an (M, N, 4) RGBA image with a dtype of
float32, float64, float128, or uint8.

If *unsampled* is True, the image will not be scaled, but an
appropriate affine transformation will be returned instead.

If *round_to_pixel_border* is True, the output image size will be
rounded to the nearest pixel boundary.  This makes the images align
correctly with the axes.  It should not be used if exact scaling is
needed, such as for `FigureImage`.

Returns
-------
image : (M, N, 4) uint8 array
    The RGBA image, resampled unless *unsampled* is True.
x, y : float
    The upper left corner where the image should be drawn, in pixel
    space.
trans : Affine2D
    The affine transformation from image to pixel space.
</pre> <div class="fragment"><div class="line"><span class="lineno">  329</span>                    unsampled=<span class="keyword">False</span>, round_to_pixel_border=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  330</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        Normalize, rescale, and colormap the image *A* from the given *in_bbox*</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        (in data space), to the given *out_bbox* (in pixel space) clipped to</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">        the given *clip_bbox* (also in pixel space), and magnified by the</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        *magnification* factor.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        *A* may be a greyscale image (M, N) with a dtype of float32, float64,</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">        float128, uint16 or uint8, or an (M, N, 4) RGBA image with a dtype of</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        float32, float64, float128, or uint8.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">        If *unsampled* is True, the image will not be scaled, but an</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">        appropriate affine transformation will be returned instead.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">        If *round_to_pixel_border* is True, the output image size will be</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">        rounded to the nearest pixel boundary.  This makes the images align</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">        correctly with the axes.  It should not be used if exact scaling is</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">        needed, such as for `FigureImage`.</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        image : (M, N, 4) uint8 array</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">            The RGBA image, resampled unless *unsampled* is True.</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        x, y : float</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">            The upper left corner where the image should be drawn, in pixel</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">            space.</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        trans : Affine2D</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">            The affine transformation from image to pixel space.</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  358</span>        <span class="keywordflow">if</span> A <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  359</span>            <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;You must first set the image &#39;</span></div>
<div class="line"><span class="lineno">  360</span>                               <span class="stringliteral">&#39;array or the image attribute&#39;</span>)</div>
<div class="line"><span class="lineno">  361</span>        <span class="keywordflow">if</span> A.size == 0:</div>
<div class="line"><span class="lineno">  362</span>            <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;_make_image must get a non-empty image. &quot;</span></div>
<div class="line"><span class="lineno">  363</span>                               <span class="stringliteral">&quot;Your Artist&#39;s draw method must filter before &quot;</span></div>
<div class="line"><span class="lineno">  364</span>                               <span class="stringliteral">&quot;this method is called.&quot;</span>)</div>
<div class="line"><span class="lineno">  365</span> </div>
<div class="line"><span class="lineno">  366</span>        clipped_bbox = Bbox.intersection(out_bbox, clip_bbox)</div>
<div class="line"><span class="lineno">  367</span> </div>
<div class="line"><span class="lineno">  368</span>        <span class="keywordflow">if</span> clipped_bbox <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  369</span>            <span class="keywordflow">return</span> <span class="keywordtype">None</span>, 0, 0, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  370</span> </div>
<div class="line"><span class="lineno">  371</span>        out_width_base = clipped_bbox.width * magnification</div>
<div class="line"><span class="lineno">  372</span>        out_height_base = clipped_bbox.height * magnification</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>        <span class="keywordflow">if</span> out_width_base == 0 <span class="keywordflow">or</span> out_height_base == 0:</div>
<div class="line"><span class="lineno">  375</span>            <span class="keywordflow">return</span> <span class="keywordtype">None</span>, 0, 0, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span>        <span class="keywordflow">if</span> self.origin == <span class="stringliteral">&#39;upper&#39;</span>:</div>
<div class="line"><span class="lineno">  378</span>            <span class="comment"># Flip the input image using a transform.  This avoids the</span></div>
<div class="line"><span class="lineno">  379</span>            <span class="comment"># problem with flipping the array, which results in a copy</span></div>
<div class="line"><span class="lineno">  380</span>            <span class="comment"># when it is converted to contiguous in the C wrapper</span></div>
<div class="line"><span class="lineno">  381</span>            t0 = Affine2D().translate(0, -A.shape[0]).scale(1, -1)</div>
<div class="line"><span class="lineno">  382</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  383</span>            t0 = IdentityTransform()</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span>        t0 += (</div>
<div class="line"><span class="lineno">  386</span>            Affine2D()</div>
<div class="line"><span class="lineno">  387</span>            .scale(</div>
<div class="line"><span class="lineno">  388</span>                in_bbox.width / A.shape[1],</div>
<div class="line"><span class="lineno">  389</span>                in_bbox.height / A.shape[0])</div>
<div class="line"><span class="lineno">  390</span>            .translate(in_bbox.x0, in_bbox.y0)</div>
<div class="line"><span class="lineno">  391</span>            + self.get_transform())</div>
<div class="line"><span class="lineno">  392</span> </div>
<div class="line"><span class="lineno">  393</span>        t = (t0</div>
<div class="line"><span class="lineno">  394</span>             + (Affine2D()</div>
<div class="line"><span class="lineno">  395</span>                .translate(-clipped_bbox.x0, -clipped_bbox.y0)</div>
<div class="line"><span class="lineno">  396</span>                .scale(magnification)))</div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span>        <span class="comment"># So that the image is aligned with the edge of the axes, we want to</span></div>
<div class="line"><span class="lineno">  399</span>        <span class="comment"># round up the output width to the next integer.  This also means</span></div>
<div class="line"><span class="lineno">  400</span>        <span class="comment"># scaling the transform slightly to account for the extra subpixel.</span></div>
<div class="line"><span class="lineno">  401</span>        <span class="keywordflow">if</span> (t.is_affine <span class="keywordflow">and</span> round_to_pixel_border <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  402</span>                (out_width_base % 1.0 != 0.0 <span class="keywordflow">or</span> out_height_base % 1.0 != 0.0)):</div>
<div class="line"><span class="lineno">  403</span>            out_width = math.ceil(out_width_base)</div>
<div class="line"><span class="lineno">  404</span>            out_height = math.ceil(out_height_base)</div>
<div class="line"><span class="lineno">  405</span>            extra_width = (out_width - out_width_base) / out_width_base</div>
<div class="line"><span class="lineno">  406</span>            extra_height = (out_height - out_height_base) / out_height_base</div>
<div class="line"><span class="lineno">  407</span>            t += Affine2D().scale(1.0 + extra_width, 1.0 + extra_height)</div>
<div class="line"><span class="lineno">  408</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  409</span>            out_width = int(out_width_base)</div>
<div class="line"><span class="lineno">  410</span>            out_height = int(out_height_base)</div>
<div class="line"><span class="lineno">  411</span>        out_shape = (out_height, out_width)</div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> unsampled:</div>
<div class="line"><span class="lineno">  414</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> (A.ndim == 2 <span class="keywordflow">or</span> A.ndim == 3 <span class="keywordflow">and</span> A.shape[-1] <span class="keywordflow">in</span> (3, 4)):</div>
<div class="line"><span class="lineno">  415</span>                <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid shape {A.shape} for image data&quot;</span>)</div>
<div class="line"><span class="lineno">  416</span>            <span class="keywordflow">if</span> A.ndim == 2 <span class="keywordflow">and</span> self._interpolation_stage != <span class="stringliteral">&#39;rgba&#39;</span>:</div>
<div class="line"><span class="lineno">  417</span>                <span class="comment"># if we are a 2D array, then we are running through the</span></div>
<div class="line"><span class="lineno">  418</span>                <span class="comment"># norm + colormap transformation.  However, in general the</span></div>
<div class="line"><span class="lineno">  419</span>                <span class="comment"># input data is not going to match the size on the screen so we</span></div>
<div class="line"><span class="lineno">  420</span>                <span class="comment"># have to resample to the correct number of pixels</span></div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span>                <span class="comment"># TODO slice input array first</span></div>
<div class="line"><span class="lineno">  423</span>                a_min = A.min()</div>
<div class="line"><span class="lineno">  424</span>                a_max = A.max()</div>
<div class="line"><span class="lineno">  425</span>                <span class="keywordflow">if</span> a_min <span class="keywordflow">is</span> np.ma.masked:  <span class="comment"># All masked; values don&#39;t matter.</span></div>
<div class="line"><span class="lineno">  426</span>                    a_min, a_max = np.int32(0), np.int32(1)</div>
<div class="line"><span class="lineno">  427</span>                <span class="keywordflow">if</span> A.dtype.kind == <span class="stringliteral">&#39;f&#39;</span>:  <span class="comment"># Float dtype: scale to same dtype.</span></div>
<div class="line"><span class="lineno">  428</span>                    scaled_dtype = np.dtype(</div>
<div class="line"><span class="lineno">  429</span>                        np.float64 <span class="keywordflow">if</span> A.dtype.itemsize &gt; 4 <span class="keywordflow">else</span> np.float32)</div>
<div class="line"><span class="lineno">  430</span>                    <span class="keywordflow">if</span> scaled_dtype.itemsize &lt; A.dtype.itemsize:</div>
<div class="line"><span class="lineno">  431</span>                        _api.warn_external(f<span class="stringliteral">&quot;Casting input data from {A.dtype}&quot;</span></div>
<div class="line"><span class="lineno">  432</span>                                           f<span class="stringliteral">&quot; to {scaled_dtype} for imshow.&quot;</span>)</div>
<div class="line"><span class="lineno">  433</span>                <span class="keywordflow">else</span>:  <span class="comment"># Int dtype, likely.</span></div>
<div class="line"><span class="lineno">  434</span>                    <span class="comment"># Scale to appropriately sized float: use float32 if the</span></div>
<div class="line"><span class="lineno">  435</span>                    <span class="comment"># dynamic range is small, to limit the memory footprint.</span></div>
<div class="line"><span class="lineno">  436</span>                    da = a_max.astype(np.float64) - a_min.astype(np.float64)</div>
<div class="line"><span class="lineno">  437</span>                    scaled_dtype = np.float64 <span class="keywordflow">if</span> da &gt; 1e8 <span class="keywordflow">else</span> np.float32</div>
<div class="line"><span class="lineno">  438</span> </div>
<div class="line"><span class="lineno">  439</span>                <span class="comment"># Scale the input data to [.1, .9].  The Agg interpolators clip</span></div>
<div class="line"><span class="lineno">  440</span>                <span class="comment"># to [0, 1] internally, and we use a smaller input scale to</span></div>
<div class="line"><span class="lineno">  441</span>                <span class="comment"># identify the interpolated points that need to be flagged as</span></div>
<div class="line"><span class="lineno">  442</span>                <span class="comment"># over/under.  This may introduce numeric instabilities in very</span></div>
<div class="line"><span class="lineno">  443</span>                <span class="comment"># broadly scaled data.</span></div>
<div class="line"><span class="lineno">  444</span> </div>
<div class="line"><span class="lineno">  445</span>                <span class="comment"># Always copy, and don&#39;t allow array subtypes.</span></div>
<div class="line"><span class="lineno">  446</span>                A_scaled = np.array(A, dtype=scaled_dtype)</div>
<div class="line"><span class="lineno">  447</span>                <span class="comment"># Clip scaled data around norm if necessary.  This is necessary</span></div>
<div class="line"><span class="lineno">  448</span>                <span class="comment"># for big numbers at the edge of float64&#39;s ability to represent</span></div>
<div class="line"><span class="lineno">  449</span>                <span class="comment"># changes.  Applying a norm first would be good, but ruins the</span></div>
<div class="line"><span class="lineno">  450</span>                <span class="comment"># interpolation of over numbers.</span></div>
<div class="line"><span class="lineno">  451</span>                self.norm.autoscale_None(A)</div>
<div class="line"><span class="lineno">  452</span>                dv = np.float64(self.norm.vmax) - np.float64(self.norm.vmin)</div>
<div class="line"><span class="lineno">  453</span>                vmid = np.float64(self.norm.vmin) + dv / 2</div>
<div class="line"><span class="lineno">  454</span>                fact = 1e7 <span class="keywordflow">if</span> scaled_dtype == np.float64 <span class="keywordflow">else</span> 1e4</div>
<div class="line"><span class="lineno">  455</span>                newmin = vmid - dv * fact</div>
<div class="line"><span class="lineno">  456</span>                <span class="keywordflow">if</span> newmin &lt; a_min:</div>
<div class="line"><span class="lineno">  457</span>                    newmin = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  458</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  459</span>                    a_min = np.float64(newmin)</div>
<div class="line"><span class="lineno">  460</span>                newmax = vmid + dv * fact</div>
<div class="line"><span class="lineno">  461</span>                <span class="keywordflow">if</span> newmax &gt; a_max:</div>
<div class="line"><span class="lineno">  462</span>                    newmax = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  463</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  464</span>                    a_max = np.float64(newmax)</div>
<div class="line"><span class="lineno">  465</span>                <span class="keywordflow">if</span> newmax <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> newmin <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  466</span>                    np.clip(A_scaled, newmin, newmax, out=A_scaled)</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>                <span class="comment"># Rescale the raw data to [offset, 1-offset] so that the</span></div>
<div class="line"><span class="lineno">  469</span>                <span class="comment"># resampling code will run cleanly.  Using dyadic numbers here</span></div>
<div class="line"><span class="lineno">  470</span>                <span class="comment"># could reduce the error, but would not fully eliminate it and</span></div>
<div class="line"><span class="lineno">  471</span>                <span class="comment"># breaks a number of tests (due to the slightly different</span></div>
<div class="line"><span class="lineno">  472</span>                <span class="comment"># error bouncing some pixels across a boundary in the (very</span></div>
<div class="line"><span class="lineno">  473</span>                <span class="comment"># quantized) colormapping step).</span></div>
<div class="line"><span class="lineno">  474</span>                offset = .1</div>
<div class="line"><span class="lineno">  475</span>                frac = .8</div>
<div class="line"><span class="lineno">  476</span>                <span class="comment"># Run vmin/vmax through the same rescaling as the raw data;</span></div>
<div class="line"><span class="lineno">  477</span>                <span class="comment"># otherwise, data values close or equal to the boundaries can</span></div>
<div class="line"><span class="lineno">  478</span>                <span class="comment"># end up on the wrong side due to floating point error.</span></div>
<div class="line"><span class="lineno">  479</span>                vmin, vmax = self.norm.vmin, self.norm.vmax</div>
<div class="line"><span class="lineno">  480</span>                <span class="keywordflow">if</span> vmin <span class="keywordflow">is</span> np.ma.masked:</div>
<div class="line"><span class="lineno">  481</span>                    vmin, vmax = a_min, a_max</div>
<div class="line"><span class="lineno">  482</span>                vrange = np.array([vmin, vmax], dtype=scaled_dtype)</div>
<div class="line"><span class="lineno">  483</span> </div>
<div class="line"><span class="lineno">  484</span>                A_scaled -= a_min</div>
<div class="line"><span class="lineno">  485</span>                vrange -= a_min</div>
<div class="line"><span class="lineno">  486</span>                <span class="comment"># .item() handles a_min/a_max being ndarray subclasses.</span></div>
<div class="line"><span class="lineno">  487</span>                a_min = a_min.astype(scaled_dtype).item()</div>
<div class="line"><span class="lineno">  488</span>                a_max = a_max.astype(scaled_dtype).item()</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>                <span class="keywordflow">if</span> a_min != a_max:</div>
<div class="line"><span class="lineno">  491</span>                    A_scaled /= ((a_max - a_min) / frac)</div>
<div class="line"><span class="lineno">  492</span>                    vrange /= ((a_max - a_min) / frac)</div>
<div class="line"><span class="lineno">  493</span>                A_scaled += offset</div>
<div class="line"><span class="lineno">  494</span>                vrange += offset</div>
<div class="line"><span class="lineno">  495</span>                <span class="comment"># resample the input data to the correct resolution and shape</span></div>
<div class="line"><span class="lineno">  496</span>                A_resampled = _resample(self, A_scaled, out_shape, t)</div>
<div class="line"><span class="lineno">  497</span>                del A_scaled  <span class="comment"># Make sure we don&#39;t use A_scaled anymore!</span></div>
<div class="line"><span class="lineno">  498</span>                <span class="comment"># Un-scale the resampled data to approximately the original</span></div>
<div class="line"><span class="lineno">  499</span>                <span class="comment"># range. Things that interpolated to outside the original range</span></div>
<div class="line"><span class="lineno">  500</span>                <span class="comment"># will still be outside, but possibly clipped in the case of</span></div>
<div class="line"><span class="lineno">  501</span>                <span class="comment"># higher order interpolation + drastically changing data.</span></div>
<div class="line"><span class="lineno">  502</span>                A_resampled -= offset</div>
<div class="line"><span class="lineno">  503</span>                vrange -= offset</div>
<div class="line"><span class="lineno">  504</span>                <span class="keywordflow">if</span> a_min != a_max:</div>
<div class="line"><span class="lineno">  505</span>                    A_resampled *= ((a_max - a_min) / frac)</div>
<div class="line"><span class="lineno">  506</span>                    vrange *= ((a_max - a_min) / frac)</div>
<div class="line"><span class="lineno">  507</span>                A_resampled += a_min</div>
<div class="line"><span class="lineno">  508</span>                vrange += a_min</div>
<div class="line"><span class="lineno">  509</span>                <span class="comment"># if using NoNorm, cast back to the original datatype</span></div>
<div class="line"><span class="lineno">  510</span>                <span class="keywordflow">if</span> isinstance(self.norm, mcolors.NoNorm):</div>
<div class="line"><span class="lineno">  511</span>                    A_resampled = A_resampled.astype(A.dtype)</div>
<div class="line"><span class="lineno">  512</span> </div>
<div class="line"><span class="lineno">  513</span>                mask = (np.where(A.mask, np.float32(np.nan), np.float32(1))</div>
<div class="line"><span class="lineno">  514</span>                        <span class="keywordflow">if</span> A.mask.shape == A.shape  <span class="comment"># nontrivial mask</span></div>
<div class="line"><span class="lineno">  515</span>                        <span class="keywordflow">else</span> np.ones_like(A, np.float32))</div>
<div class="line"><span class="lineno">  516</span>                <span class="comment"># we always have to interpolate the mask to account for</span></div>
<div class="line"><span class="lineno">  517</span>                <span class="comment"># non-affine transformations</span></div>
<div class="line"><span class="lineno">  518</span>                out_alpha = _resample(self, mask, out_shape, t, resample=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  519</span>                del mask  <span class="comment"># Make sure we don&#39;t use mask anymore!</span></div>
<div class="line"><span class="lineno">  520</span>                <span class="comment"># Agg updates out_alpha in place.  If the pixel has no image</span></div>
<div class="line"><span class="lineno">  521</span>                <span class="comment"># data it will not be updated (and still be 0 as we initialized</span></div>
<div class="line"><span class="lineno">  522</span>                <span class="comment"># it), if input data that would go into that output pixel than</span></div>
<div class="line"><span class="lineno">  523</span>                <span class="comment"># it will be `nan`, if all the input data for a pixel is good</span></div>
<div class="line"><span class="lineno">  524</span>                <span class="comment"># it will be 1, and if there is _some_ good data in that output</span></div>
<div class="line"><span class="lineno">  525</span>                <span class="comment"># pixel it will be between [0, 1] (such as a rotated image).</span></div>
<div class="line"><span class="lineno">  526</span>                out_mask = np.isnan(out_alpha)</div>
<div class="line"><span class="lineno">  527</span>                out_alpha[out_mask] = 1</div>
<div class="line"><span class="lineno">  528</span>                <span class="comment"># Apply the pixel-by-pixel alpha values if present</span></div>
<div class="line"><span class="lineno">  529</span>                alpha = self.get_alpha()</div>
<div class="line"><span class="lineno">  530</span>                <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> np.ndim(alpha) &gt; 0:</div>
<div class="line"><span class="lineno">  531</span>                    out_alpha *= _resample(self, alpha, out_shape,</div>
<div class="line"><span class="lineno">  532</span>                                           t, resample=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  533</span>                <span class="comment"># mask and run through the norm</span></div>
<div class="line"><span class="lineno">  534</span>                resampled_masked = np.ma.masked_array(A_resampled, out_mask)</div>
<div class="line"><span class="lineno">  535</span>                <span class="comment"># we have re-set the vmin/vmax to account for small errors</span></div>
<div class="line"><span class="lineno">  536</span>                <span class="comment"># that may have moved input values in/out of range</span></div>
<div class="line"><span class="lineno">  537</span>                s_vmin, s_vmax = vrange</div>
<div class="line"><span class="lineno">  538</span>                <span class="keywordflow">if</span> isinstance(self.norm, mcolors.LogNorm) <span class="keywordflow">and</span> s_vmin &lt;= 0:</div>
<div class="line"><span class="lineno">  539</span>                    <span class="comment"># Don&#39;t give 0 or negative values to LogNorm</span></div>
<div class="line"><span class="lineno">  540</span>                    s_vmin = np.finfo(scaled_dtype).eps</div>
<div class="line"><span class="lineno">  541</span>                <span class="comment"># Block the norm from sending an update signal during the</span></div>
<div class="line"><span class="lineno">  542</span>                <span class="comment"># temporary vmin/vmax change</span></div>
<div class="line"><span class="lineno">  543</span>                <span class="keyword">with</span> self.norm.callbacks.blocked(), \</div>
<div class="line"><span class="lineno">  544</span>                     cbook._setattr_cm(self.norm, vmin=s_vmin, vmax=s_vmax):</div>
<div class="line"><span class="lineno">  545</span>                    output = self.norm(resampled_masked)</div>
<div class="line"><span class="lineno">  546</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  547</span>                <span class="keywordflow">if</span> A.ndim == 2:  <span class="comment"># _interpolation_stage == &#39;rgba&#39;</span></div>
<div class="line"><span class="lineno">  548</span>                    self.norm.autoscale_None(A)</div>
<div class="line"><span class="lineno">  549</span>                    A = self.to_rgba(A)</div>
<div class="line"><span class="lineno">  550</span>                <span class="keywordflow">if</span> A.shape[2] == 3:</div>
<div class="line"><span class="lineno">  551</span>                    A = _rgb_to_rgba(A)</div>
<div class="line"><span class="lineno">  552</span>                alpha = self._get_scalar_alpha()</div>
<div class="line"><span class="lineno">  553</span>                output_alpha = _resample(  <span class="comment"># resample alpha channel</span></div>
<div class="line"><span class="lineno">  554</span>                    self, A[..., 3], out_shape, t, alpha=alpha)</div>
<div class="line"><span class="lineno">  555</span>                output = _resample(  <span class="comment"># resample rgb channels</span></div>
<div class="line"><span class="lineno">  556</span>                    self, _rgb_to_rgba(A[..., :3]), out_shape, t, alpha=alpha)</div>
<div class="line"><span class="lineno">  557</span>                output[..., 3] = output_alpha  <span class="comment"># recombine rgb and alpha</span></div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>            <span class="comment"># output is now either a 2D array of normed (int or float) data</span></div>
<div class="line"><span class="lineno">  560</span>            <span class="comment"># or an RGBA array of re-sampled input</span></div>
<div class="line"><span class="lineno">  561</span>            output = self.to_rgba(output, bytes=<span class="keyword">True</span>, norm=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  562</span>            <span class="comment"># output is now a correctly sized RGBA array of uint8</span></div>
<div class="line"><span class="lineno">  563</span> </div>
<div class="line"><span class="lineno">  564</span>            <span class="comment"># Apply alpha *after* if the input was greyscale without a mask</span></div>
<div class="line"><span class="lineno">  565</span>            <span class="keywordflow">if</span> A.ndim == 2:</div>
<div class="line"><span class="lineno">  566</span>                alpha = self._get_scalar_alpha()</div>
<div class="line"><span class="lineno">  567</span>                alpha_channel = output[:, :, 3]</div>
<div class="line"><span class="lineno">  568</span>                alpha_channel[:] = (  <span class="comment"># Assignment will cast to uint8.</span></div>
<div class="line"><span class="lineno">  569</span>                    alpha_channel.astype(np.float32) * out_alpha * alpha)</div>
<div class="line"><span class="lineno">  570</span> </div>
<div class="line"><span class="lineno">  571</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  572</span>            <span class="keywordflow">if</span> self._imcache <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  573</span>                self._imcache = self.to_rgba(A, bytes=<span class="keyword">True</span>, norm=(A.ndim == 2))</div>
<div class="line"><span class="lineno">  574</span>            output = self._imcache</div>
<div class="line"><span class="lineno">  575</span> </div>
<div class="line"><span class="lineno">  576</span>            <span class="comment"># Subset the input image to only the part that will be displayed.</span></div>
<div class="line"><span class="lineno">  577</span>            subset = TransformedBbox(clip_bbox, t0.inverted()).frozen()</div>
<div class="line"><span class="lineno">  578</span>            output = output[</div>
<div class="line"><span class="lineno">  579</span>                int(max(subset.ymin, 0)):</div>
<div class="line"><span class="lineno">  580</span>                int(min(subset.ymax + 1, output.shape[0])),</div>
<div class="line"><span class="lineno">  581</span>                int(max(subset.xmin, 0)):</div>
<div class="line"><span class="lineno">  582</span>                int(min(subset.xmax + 1, output.shape[1]))]</div>
<div class="line"><span class="lineno">  583</span> </div>
<div class="line"><span class="lineno">  584</span>            t = Affine2D().translate(</div>
<div class="line"><span class="lineno">  585</span>                int(max(subset.xmin, 0)), int(max(subset.ymin, 0))) + t</div>
<div class="line"><span class="lineno">  586</span> </div>
<div class="line"><span class="lineno">  587</span>        <span class="keywordflow">return</span> output, clipped_bbox.x0, clipped_bbox.y0, t</div>
<div class="line"><span class="lineno">  588</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aed8acd31409e2bc7771bb8c4ed8c0e91" name="aed8acd31409e2bc7771bb8c4ed8c0e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8acd31409e2bc7771bb8c4ed8c0e91">&#9670;&#160;</a></span>can_composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.can_composite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the image can be composited with its neighbors.</pre> <div class="fragment"><div class="line"><span class="lineno">  794</span>    <span class="keyword">def </span>can_composite(self):</div>
<div class="line"><span class="lineno">  795</span>        <span class="stringliteral">&quot;&quot;&quot;Return whether the image can be composited with its neighbors.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  796</span>        trans = self.get_transform()</div>
<div class="line"><span class="lineno">  797</span>        <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">  798</span>            self._interpolation != <span class="stringliteral">&#39;none&#39;</span> <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  799</span>            trans.is_affine <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  800</span>            trans.is_separable)</div>
<div class="line"><span class="lineno">  801</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aab0d6d6ffe4015e5165c20a588959ad0" name="aab0d6d6ffe4015e5165c20a588959ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0d6d6ffe4015e5165c20a588959ad0">&#9670;&#160;</a></span>changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.changed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Call this whenever the mappable is changed so observers can update.
</pre> 
<p>Reimplemented from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a5e33c4e42a59560d1e1ee6e434e73fa5">matplotlib.cm.ScalarMappable</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  321</span>    <span class="keyword">def </span>changed(self):</div>
<div class="line"><span class="lineno">  322</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">        Call this whenever the mappable is changed so observers can update.</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  325</span>        self._imcache = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  326</span>        cm.ScalarMappable.changed(self)</div>
<div class="line"><span class="lineno">  327</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fe60c3a610dcad050d6405e94946d59" name="a2fe60c3a610dcad050d6405e94946d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe60c3a610dcad050d6405e94946d59">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.contains </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mouseevent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether the mouse event occurred within the image.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_bbox_image.html#a1937437c91f6c9ca6efa152f3ce92ead">matplotlib.image.BboxImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  648</span>    <span class="keyword">def </span>contains(self, mouseevent):</div>
<div class="line"><span class="lineno">  649</span>        <span class="stringliteral">&quot;&quot;&quot;Test whether the mouse event occurred within the image.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  650</span>        inside, info = self._default_contains(mouseevent)</div>
<div class="line"><span class="lineno">  651</span>        <span class="keywordflow">if</span> inside <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  652</span>            <span class="keywordflow">return</span> inside, info</div>
<div class="line"><span class="lineno">  653</span>        <span class="comment"># 1) This doesn&#39;t work for figimage; but figimage also needs a fix</span></div>
<div class="line"><span class="lineno">  654</span>        <span class="comment">#    below (as the check cannot use x/ydata and extents).</span></div>
<div class="line"><span class="lineno">  655</span>        <span class="comment"># 2) As long as the check below uses x/ydata, we need to test axes</span></div>
<div class="line"><span class="lineno">  656</span>        <span class="comment">#    identity instead of `self.axes.contains(event)` because even if</span></div>
<div class="line"><span class="lineno">  657</span>        <span class="comment">#    axes overlap, x/ydata is only valid for event.inaxes anyways.</span></div>
<div class="line"><span class="lineno">  658</span>        <span class="keywordflow">if</span> self.axes <span class="keywordflow">is</span> <span class="keywordflow">not</span> mouseevent.inaxes:</div>
<div class="line"><span class="lineno">  659</span>            <span class="keywordflow">return</span> <span class="keyword">False</span>, {}</div>
<div class="line"><span class="lineno">  660</span>        <span class="comment"># TODO: make sure this is consistent with patch and patch</span></div>
<div class="line"><span class="lineno">  661</span>        <span class="comment"># collection on nonlinear transformed coordinates.</span></div>
<div class="line"><span class="lineno">  662</span>        <span class="comment"># TODO: consider returning image coordinates (shouldn&#39;t</span></div>
<div class="line"><span class="lineno">  663</span>        <span class="comment"># be too difficult given that the image is rectilinear</span></div>
<div class="line"><span class="lineno">  664</span>        trans = self.get_transform().inverted()</div>
<div class="line"><span class="lineno">  665</span>        x, y = trans.transform([mouseevent.x, mouseevent.y])</div>
<div class="line"><span class="lineno">  666</span>        xmin, xmax, ymin, ymax = self.get_extent()</div>
<div class="line"><span class="lineno">  667</span>        <span class="keywordflow">if</span> xmin &gt; xmax:</div>
<div class="line"><span class="lineno">  668</span>            xmin, xmax = xmax, xmin</div>
<div class="line"><span class="lineno">  669</span>        <span class="keywordflow">if</span> ymin &gt; ymax:</div>
<div class="line"><span class="lineno">  670</span>            ymin, ymax = ymax, ymin</div>
<div class="line"><span class="lineno">  671</span> </div>
<div class="line"><span class="lineno">  672</span>        <span class="keywordflow">if</span> x <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> y <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  673</span>            inside = (xmin &lt;= x &lt;= xmax) <span class="keywordflow">and</span> (ymin &lt;= y &lt;= ymax)</div>
<div class="line"><span class="lineno">  674</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  675</span>            inside = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span>        <span class="keywordflow">return</span> inside, {}</div>
<div class="line"><span class="lineno">  678</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afbae7e711df41da43bf1842de5fe21ec" name="afbae7e711df41da43bf1842de5fe21ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbae7e711df41da43bf1842de5fe21ec">&#9670;&#160;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.draw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  618</span>    <span class="keyword">def </span>draw(self, renderer, *args, **kwargs):</div>
<div class="line"><span class="lineno">  619</span>        <span class="comment"># if not visible, declare victory and return</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.get_visible():</div>
<div class="line"><span class="lineno">  621</span>            self.stale = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  622</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  623</span>        <span class="comment"># for empty images, there is nothing to draw!</span></div>
<div class="line"><span class="lineno">  624</span>        <span class="keywordflow">if</span> self.get_array().size == 0:</div>
<div class="line"><span class="lineno">  625</span>            self.stale = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  626</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  627</span>        <span class="comment"># actually render the image.</span></div>
<div class="line"><span class="lineno">  628</span>        gc = renderer.new_gc()</div>
<div class="line"><span class="lineno">  629</span>        self._set_gc_clip(gc)</div>
<div class="line"><span class="lineno">  630</span>        gc.set_alpha(self._get_scalar_alpha())</div>
<div class="line"><span class="lineno">  631</span>        gc.set_url(self.get_url())</div>
<div class="line"><span class="lineno">  632</span>        gc.set_gid(self.get_gid())</div>
<div class="line"><span class="lineno">  633</span>        <span class="keywordflow">if</span> (renderer.option_scale_image()  <span class="comment"># Renderer supports transform kwarg.</span></div>
<div class="line"><span class="lineno">  634</span>                <span class="keywordflow">and</span> self._check_unsampled_image()</div>
<div class="line"><span class="lineno">  635</span>                <span class="keywordflow">and</span> self.get_transform().is_affine):</div>
<div class="line"><span class="lineno">  636</span>            im, l, b, trans = self.make_image(renderer, unsampled=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  637</span>            <span class="keywordflow">if</span> im <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  638</span>                trans = Affine2D().scale(im.shape[1], im.shape[0]) + trans</div>
<div class="line"><span class="lineno">  639</span>                renderer.draw_image(gc, l, b, im, trans)</div>
<div class="line"><span class="lineno">  640</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  641</span>            im, l, b, trans = self.make_image(</div>
<div class="line"><span class="lineno">  642</span>                renderer, renderer.get_image_magnification())</div>
<div class="line"><span class="lineno">  643</span>            <span class="keywordflow">if</span> im <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  644</span>                renderer.draw_image(gc, l, b, im)</div>
<div class="line"><span class="lineno">  645</span>        gc.restore()</div>
<div class="line"><span class="lineno">  646</span>        self.stale = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  647</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5352e07e341beb11e5c8aa5a04d47e5" name="ae5352e07e341beb11e5c8aa5a04d47e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5352e07e341beb11e5c8aa5a04d47e5">&#9670;&#160;</a></span>get_filternorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.get_filternorm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the resize filter normalizes the weights.</pre> <div class="fragment"><div class="line"><span class="lineno">  833</span>    <span class="keyword">def </span>get_filternorm(self):</div>
<div class="line"><span class="lineno">  834</span>        <span class="stringliteral">&quot;&quot;&quot;Return whether the resize filter normalizes the weights.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  835</span>        <span class="keywordflow">return</span> self._filternorm</div>
<div class="line"><span class="lineno">  836</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8e62e1539c9465006a5ec0c51ee5b41" name="ac8e62e1539c9465006a5ec0c51ee5b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e62e1539c9465006a5ec0c51ee5b41">&#9670;&#160;</a></span>get_filterrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.get_filterrad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the filterrad setting.</pre> <div class="fragment"><div class="line"><span class="lineno">  852</span>    <span class="keyword">def </span>get_filterrad(self):</div>
<div class="line"><span class="lineno">  853</span>        <span class="stringliteral">&quot;&quot;&quot;Return the filterrad setting.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  854</span>        <span class="keywordflow">return</span> self._filterrad</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a82814068c8c2731c1205339c4d860b34" name="a82814068c8c2731c1205339c4d860b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82814068c8c2731c1205339c4d860b34">&#9670;&#160;</a></span>get_interpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.get_interpolation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the interpolation method the image uses when resizing.

One of 'antialiased', 'nearest', 'bilinear', 'bicubic', 'spline16',
'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',
'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos',
or 'none'.
</pre> <div class="fragment"><div class="line"><span class="lineno">  745</span>    <span class="keyword">def </span>get_interpolation(self):</div>
<div class="line"><span class="lineno">  746</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        Return the interpolation method the image uses when resizing.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        One of &#39;antialiased&#39;, &#39;nearest&#39;, &#39;bilinear&#39;, &#39;bicubic&#39;, &#39;spline16&#39;,</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        &#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;, &#39;kaiser&#39;, &#39;quadric&#39;,</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        &#39;catrom&#39;, &#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;, &#39;sinc&#39;, &#39;lanczos&#39;,</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        or &#39;none&#39;.</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  754</span>        <span class="keywordflow">return</span> self._interpolation</div>
<div class="line"><span class="lineno">  755</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a803a5a1f40643e11762ea0b97711d016" name="a803a5a1f40643e11762ea0b97711d016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803a5a1f40643e11762ea0b97711d016">&#9670;&#160;</a></span>get_resample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.get_resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether image resampling is used.</pre> <div class="fragment"><div class="line"><span class="lineno">  816</span>    <span class="keyword">def </span>get_resample(self):</div>
<div class="line"><span class="lineno">  817</span>        <span class="stringliteral">&quot;&quot;&quot;Return whether image resampling is used.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  818</span>        <span class="keywordflow">return</span> self._resample</div>
<div class="line"><span class="lineno">  819</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a353484f615b500f383877248eec3ba47" name="a353484f615b500f383877248eec3ba47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353484f615b500f383877248eec3ba47">&#9670;&#160;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.get_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the size of the image as tuple (numrows, numcols).</pre> <div class="fragment"><div class="line"><span class="lineno">  287</span>    <span class="keyword">def </span>get_size(self):</div>
<div class="line"><span class="lineno">  288</span>        <span class="stringliteral">&quot;&quot;&quot;Return the size of the image as tuple (numrows, numcols).&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  289</span>        <span class="keywordflow">if</span> self._A <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  290</span>            <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;You must first set the image array&#39;</span>)</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>        <span class="keywordflow">return</span> self._A.shape[:2]</div>
<div class="line"><span class="lineno">  293</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adbdf642c0367e4a25069fe263d278616" name="adbdf642c0367e4a25069fe263d278616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdf642c0367e4a25069fe263d278616">&#9670;&#160;</a></span>make_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.make_image </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>magnification</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unsampled</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Normalize, rescale, and colormap this image's data for rendering using
*renderer*, with the given *magnification*.

If *unsampled* is True, the image will not be scaled, but an
appropriate affine transformation will be returned instead.

Returns
-------
image : (M, N, 4) uint8 array
    The RGBA image, resampled unless *unsampled* is True.
x, y : float
    The upper left corner where the image should be drawn, in pixel
    space.
trans : Affine2D
    The affine transformation from image to pixel space.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_axes_image.html#a72e5bcb44ff58af24c623abe150b7cef">matplotlib.image.AxesImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#a47b061c7acf22909eaf8109e26ece5db">matplotlib.image.NonUniformImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_pcolor_image.html#ae2e2f51a1d82afff20f922870f27d3b0">matplotlib.image.PcolorImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_figure_image.html#aa6c958f3af6b8e80574016d6e653aeeb">matplotlib.image.FigureImage</a>, and <a class="el" href="classmatplotlib_1_1image_1_1_bbox_image.html#aa0635c332e5b9d8ef68e6cb02d82dadd">matplotlib.image.BboxImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  589</span>    <span class="keyword">def </span>make_image(self, renderer, magnification=1.0, unsampled=False):</div>
<div class="line"><span class="lineno">  590</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        Normalize, rescale, and colormap this image&#39;s data for rendering using</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        *renderer*, with the given *magnification*.</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        If *unsampled* is True, the image will not be scaled, but an</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        appropriate affine transformation will be returned instead.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        image : (M, N, 4) uint8 array</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">            The RGBA image, resampled unless *unsampled* is True.</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        x, y : float</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">            The upper left corner where the image should be drawn, in pixel</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">            space.</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        trans : Affine2D</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">            The affine transformation from image to pixel space.</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  607</span>        <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&#39;The make_image method must be overridden&#39;</span>)</div>
<div class="line"><span class="lineno">  608</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a367c6d99617d8803f499aede68f54ed2" name="a367c6d99617d8803f499aede68f54ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c6d99617d8803f499aede68f54ed2">&#9670;&#160;</a></span>set_alpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_alpha </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the alpha value used for blending - not supported on all backends.

Parameters
----------
alpha : float or 2D array-like or None
</pre> <div class="fragment"><div class="line"><span class="lineno">  294</span>    <span class="keyword">def </span>set_alpha(self, alpha):</div>
<div class="line"><span class="lineno">  295</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        Set the alpha value used for blending - not supported on all backends.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        alpha : float or 2D array-like or None</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  302</span>        martist.Artist._set_alpha_for_array(self, alpha)</div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordflow">if</span> np.ndim(alpha) <span class="keywordflow">not</span> <span class="keywordflow">in</span> (0, 2):</div>
<div class="line"><span class="lineno">  304</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;alpha must be a float, two-dimensional &#39;</span></div>
<div class="line"><span class="lineno">  305</span>                            <span class="stringliteral">&#39;array, or None&#39;</span>)</div>
<div class="line"><span class="lineno">  306</span>        self._imcache = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  307</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aea076e6bbccf18dadbd19a43c82c7183" name="aea076e6bbccf18dadbd19a43c82c7183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea076e6bbccf18dadbd19a43c82c7183">&#9670;&#160;</a></span>set_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retained for backwards compatibility - use set_data instead.

Parameters
----------
A : array-like
</pre> 
<p>Reimplemented from <a class="el" href="classmatplotlib_1_1cm_1_1_scalar_mappable.html#a818786760e440143472eee2f19e9aa0e">matplotlib.cm.ScalarMappable</a>.</p>

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#a32245cfae70963b916e6d8c017649e12">matplotlib.image.NonUniformImage</a>, and <a class="el" href="classmatplotlib_1_1image_1_1_pcolor_image.html#af7ed9efefcf07a582dae8112120ba953">matplotlib.image.PcolorImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  733</span>    <span class="keyword">def </span>set_array(self, A):</div>
<div class="line"><span class="lineno">  734</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        Retained for backwards compatibility - use set_data instead.</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        A : array-like</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  741</span>        <span class="comment"># This also needs to be here to override the inherited</span></div>
<div class="line"><span class="lineno">  742</span>        <span class="comment"># cm.ScalarMappable.set_array method so it is not invoked by mistake.</span></div>
<div class="line"><span class="lineno">  743</span>        self.set_data(A)</div>
<div class="line"><span class="lineno">  744</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a627bc31fce4803fbc6e1ec6e616aa92f" name="a627bc31fce4803fbc6e1ec6e616aa92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627bc31fce4803fbc6e1ec6e616aa92f">&#9670;&#160;</a></span>set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the image array.

Note that this function does *not* update the normalization used.

Parameters
----------
A : array-like or `PIL.Image.Image`
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_figure_image.html#a21e13ffb482073cc5fe130f9574748b9">matplotlib.image.FigureImage</a>, <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#a8f0e40df9fc61f77aab2d5e74106f77e">matplotlib.image.NonUniformImage</a>, and <a class="el" href="classmatplotlib_1_1image_1_1_pcolor_image.html#a21fb06396e33ac33b52d258b12ed8dcc">matplotlib.image.PcolorImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  685</span>    <span class="keyword">def </span>set_data(self, A):</div>
<div class="line"><span class="lineno">  686</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        Set the image array.</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        Note that this function does *not* update the normalization used.</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        A : array-like or `PIL.Image.Image`</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  695</span>        <span class="keywordflow">if</span> isinstance(A, <a class="code hl_class" href="class_p_i_l_1_1_image_1_1_image.html">PIL.Image.Image</a>):</div>
<div class="line"><span class="lineno">  696</span>            A = pil_to_array(A)  <span class="comment"># Needed e.g. to apply png palette.</span></div>
<div class="line"><span class="lineno">  697</span>        self._A = cbook.safe_masked_invalid(A, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>        <span class="keywordflow">if</span> (self._A.dtype != np.uint8 <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  700</span>                <span class="keywordflow">not</span> np.can_cast(self._A.dtype, float, <span class="stringliteral">&quot;same_kind&quot;</span>)):</div>
<div class="line"><span class="lineno">  701</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Image data of dtype {} cannot be converted to &quot;</span></div>
<div class="line"><span class="lineno">  702</span>                            <span class="stringliteral">&quot;float&quot;</span>.format(self._A.dtype))</div>
<div class="line"><span class="lineno">  703</span> </div>
<div class="line"><span class="lineno">  704</span>        <span class="keywordflow">if</span> self._A.ndim == 3 <span class="keywordflow">and</span> self._A.shape[-1] == 1:</div>
<div class="line"><span class="lineno">  705</span>            <span class="comment"># If just one dimension assume scalar and apply colormap</span></div>
<div class="line"><span class="lineno">  706</span>            self._A = self._A[:, :, 0]</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (self._A.ndim == 2</div>
<div class="line"><span class="lineno">  709</span>                <span class="keywordflow">or</span> self._A.ndim == 3 <span class="keywordflow">and</span> self._A.shape[-1] <span class="keywordflow">in</span> [3, 4]):</div>
<div class="line"><span class="lineno">  710</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Invalid shape {} for image data&quot;</span></div>
<div class="line"><span class="lineno">  711</span>                            .format(self._A.shape))</div>
<div class="line"><span class="lineno">  712</span> </div>
<div class="line"><span class="lineno">  713</span>        <span class="keywordflow">if</span> self._A.ndim == 3:</div>
<div class="line"><span class="lineno">  714</span>            <span class="comment"># If the input data has values outside the valid range (after</span></div>
<div class="line"><span class="lineno">  715</span>            <span class="comment"># normalisation), we issue a warning and then clip X to the bounds</span></div>
<div class="line"><span class="lineno">  716</span>            <span class="comment"># - otherwise casting wraps extreme values, hiding outliers and</span></div>
<div class="line"><span class="lineno">  717</span>            <span class="comment"># making reliable interpretation impossible.</span></div>
<div class="line"><span class="lineno">  718</span>            high = 255 <span class="keywordflow">if</span> np.issubdtype(self._A.dtype, np.integer) <span class="keywordflow">else</span> 1</div>
<div class="line"><span class="lineno">  719</span>            <span class="keywordflow">if</span> self._A.min() &lt; 0 <span class="keywordflow">or</span> high &lt; self._A.max():</div>
<div class="line"><span class="lineno">  720</span>                _log.warning(</div>
<div class="line"><span class="lineno">  721</span>                    <span class="stringliteral">&#39;Clipping input data to the valid range for imshow with &#39;</span></div>
<div class="line"><span class="lineno">  722</span>                    <span class="stringliteral">&#39;RGB data ([0..1] for floats or [0..255] for integers).&#39;</span></div>
<div class="line"><span class="lineno">  723</span>                )</div>
<div class="line"><span class="lineno">  724</span>                self._A = np.clip(self._A, 0, high)</div>
<div class="line"><span class="lineno">  725</span>            <span class="comment"># Cast unsupported integer types to uint8</span></div>
<div class="line"><span class="lineno">  726</span>            <span class="keywordflow">if</span> self._A.dtype != np.uint8 <span class="keywordflow">and</span> np.issubdtype(self._A.dtype,</div>
<div class="line"><span class="lineno">  727</span>                                                           np.integer):</div>
<div class="line"><span class="lineno">  728</span>                self._A = self._A.astype(np.uint8)</div>
<div class="line"><span class="lineno">  729</span> </div>
<div class="line"><span class="lineno">  730</span>        self._imcache = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  731</span>        self.stale = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="ttc" id="aclass_p_i_l_1_1_image_1_1_image_html"><div class="ttname"><a href="class_p_i_l_1_1_image_1_1_image.html">PIL.Image.Image</a></div><div class="ttdef"><b>Definition</b> Image.py:496</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4db901deb5ec5bb8a23258bd96888ac9" name="a4db901deb5ec5bb8a23258bd96888ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db901deb5ec5bb8a23258bd96888ac9">&#9670;&#160;</a></span>set_filternorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_filternorm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filternorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set whether the resize filter normalizes the weights.

See help for `~.Axes.imshow`.

Parameters
----------
filternorm : bool
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#a5b3a6025a8ad8d9d700482b2935fb599">matplotlib.image.NonUniformImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  820</span>    <span class="keyword">def </span>set_filternorm(self, filternorm):</div>
<div class="line"><span class="lineno">  821</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        Set whether the resize filter normalizes the weights.</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        See help for `~.Axes.imshow`.</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        filternorm : bool</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  830</span>        self._filternorm = bool(filternorm)</div>
<div class="line"><span class="lineno">  831</span>        self.stale = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  832</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a21a209090364b3b0bd4d2e9c501017e2" name="a21a209090364b3b0bd4d2e9c501017e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a209090364b3b0bd4d2e9c501017e2">&#9670;&#160;</a></span>set_filterrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_filterrad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filterrad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the resize filter radius only applicable to some
interpolation schemes -- see help for imshow

Parameters
----------
filterrad : positive float
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#a95d7eb61b14218c4b31f78b7ecd4143f">matplotlib.image.NonUniformImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  837</span>    <span class="keyword">def </span>set_filterrad(self, filterrad):</div>
<div class="line"><span class="lineno">  838</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        Set the resize filter radius only applicable to some</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        interpolation schemes -- see help for imshow</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        filterrad : positive float</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  846</span>        r = float(filterrad)</div>
<div class="line"><span class="lineno">  847</span>        <span class="keywordflow">if</span> r &lt;= 0:</div>
<div class="line"><span class="lineno">  848</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The filter radius must be a positive number&quot;</span>)</div>
<div class="line"><span class="lineno">  849</span>        self._filterrad = r</div>
<div class="line"><span class="lineno">  850</span>        self.stale = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  851</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a78b99b2e1d4e4f06a22f6c01742ac5ea" name="a78b99b2e1d4e4f06a22f6c01742ac5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b99b2e1d4e4f06a22f6c01742ac5ea">&#9670;&#160;</a></span>set_interpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_interpolation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the interpolation method the image uses when resizing.

If None, use :rc:`image.interpolation`. If 'none', the image is
shown as is without interpolating. 'none' is only supported in
agg, ps and pdf backends and will fall back to 'nearest' mode
for other backends.

Parameters
----------
s : {'antialiased', 'nearest', 'bilinear', 'bicubic', 'spline16', \
'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'catrom', \
'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos', 'none'} or None
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1image_1_1_non_uniform_image.html#a49755d34a86a22a364668981d6d53e10">matplotlib.image.NonUniformImage</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  756</span>    <span class="keyword">def </span>set_interpolation(self, s):</div>
<div class="line"><span class="lineno">  757</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">        Set the interpolation method the image uses when resizing.</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        If None, use :rc:`image.interpolation`. If &#39;none&#39;, the image is</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        shown as is without interpolating. &#39;none&#39; is only supported in</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        agg, ps and pdf backends and will fall back to &#39;nearest&#39; mode</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        for other backends.</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        s : {&#39;antialiased&#39;, &#39;nearest&#39;, &#39;bilinear&#39;, &#39;bicubic&#39;, &#39;spline16&#39;, \</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">&#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;, &#39;kaiser&#39;, &#39;quadric&#39;, &#39;catrom&#39;, \</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">&#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;, &#39;sinc&#39;, &#39;lanczos&#39;, &#39;none&#39;} or None</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  771</span>        <span class="keywordflow">if</span> s <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  772</span>            s = mpl.rcParams[<span class="stringliteral">&#39;image.interpolation&#39;</span>]</div>
<div class="line"><span class="lineno">  773</span>        s = s.lower()</div>
<div class="line"><span class="lineno">  774</span>        _api.check_in_list(_interpd_, interpolation=s)</div>
<div class="line"><span class="lineno">  775</span>        self._interpolation = s</div>
<div class="line"><span class="lineno">  776</span>        self.stale = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  777</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac72f8b24b4c951a85e4bba6e555f90f0" name="ac72f8b24b4c951a85e4bba6e555f90f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72f8b24b4c951a85e4bba6e555f90f0">&#9670;&#160;</a></span>set_interpolation_stage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_interpolation_stage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set when interpolation happens during the transform to RGBA.

Parameters
----------
s : {'data', 'rgba'} or None
    Whether to apply up/downsampling interpolation in data or rgba
    space.
</pre> <div class="fragment"><div class="line"><span class="lineno">  778</span>    <span class="keyword">def </span>set_interpolation_stage(self, s):</div>
<div class="line"><span class="lineno">  779</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">        Set when interpolation happens during the transform to RGBA.</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        s : {&#39;data&#39;, &#39;rgba&#39;} or None</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">            Whether to apply up/downsampling interpolation in data or rgba</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">            space.</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  788</span>        <span class="keywordflow">if</span> s <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  789</span>            s = <span class="stringliteral">&quot;data&quot;</span>  <span class="comment"># placeholder for maybe having rcParam</span></div>
<div class="line"><span class="lineno">  790</span>        _api.check_in_list([<span class="stringliteral">&#39;data&#39;</span>, <span class="stringliteral">&#39;rgba&#39;</span>], s=s)</div>
<div class="line"><span class="lineno">  791</span>        self._interpolation_stage = s</div>
<div class="line"><span class="lineno">  792</span>        self.stale = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  793</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d4fb5fc7b6376cbe8ae6087df575c7c" name="a3d4fb5fc7b6376cbe8ae6087df575c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4fb5fc7b6376cbe8ae6087df575c7c">&#9670;&#160;</a></span>set_resample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.set_resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set whether image resampling is used.

Parameters
----------
v : bool or None
    If None, use :rc:`image.resample`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  802</span>    <span class="keyword">def </span>set_resample(self, v):</div>
<div class="line"><span class="lineno">  803</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        Set whether image resampling is used.</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        v : bool or None</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">            If None, use :rc:`image.resample`.</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  811</span>        <span class="keywordflow">if</span> v <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  812</span>            v = mpl.rcParams[<span class="stringliteral">&#39;image.resample&#39;</span>]</div>
<div class="line"><span class="lineno">  813</span>        self._resample = v</div>
<div class="line"><span class="lineno">  814</span>        self.stale = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  815</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aba42a1aa52c957a58a127d43fb1cccaa" name="aba42a1aa52c957a58a127d43fb1cccaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba42a1aa52c957a58a127d43fb1cccaa">&#9670;&#160;</a></span>write_png()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.write_png </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write the image to png file *fname*.</pre> <div class="fragment"><div class="line"><span class="lineno">  679</span>    <span class="keyword">def </span>write_png(self, fname):</div>
<div class="line"><span class="lineno">  680</span>        <span class="stringliteral">&quot;&quot;&quot;Write the image to png file *fname*.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  681</span>        im = self.to_rgba(self._A[::-1] <span class="keywordflow">if</span> self.origin == <span class="stringliteral">&#39;lower&#39;</span> <span class="keywordflow">else</span> self._A,</div>
<div class="line"><span class="lineno">  682</span>                          bytes=<span class="keyword">True</span>, norm=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  683</span>        <a class="code hl_function" href="namespace_p_i_l_1_1_image.html#a89dde9f49b7751b60d71643e4d7a7e6e">PIL.Image.fromarray</a>(im).save(fname, format=<span class="stringliteral">&quot;png&quot;</span>)</div>
<div class="line"><span class="lineno">  684</span> </div>
<div class="ttc" id="anamespace_p_i_l_1_1_image_html_a89dde9f49b7751b60d71643e4d7a7e6e"><div class="ttname"><a href="namespace_p_i_l_1_1_image.html#a89dde9f49b7751b60d71643e4d7a7e6e">PIL.Image.fromarray</a></div><div class="ttdeci">fromarray(obj, mode=None)</div><div class="ttdef"><b>Definition</b> Image.py:3030</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab406bea232727b6e129a7cb2981a6409" name="ab406bea232727b6e129a7cb2981a6409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab406bea232727b6e129a7cb2981a6409">&#9670;&#160;</a></span>_A</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._A</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada8eb99cb1f02cd166af6d689b5aa07e" name="ada8eb99cb1f02cd166af6d689b5aa07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8eb99cb1f02cd166af6d689b5aa07e">&#9670;&#160;</a></span>_alpha</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._alpha</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2907ee51b357347d70d01efbf784cafa" name="a2907ee51b357347d70d01efbf784cafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2907ee51b357347d70d01efbf784cafa">&#9670;&#160;</a></span>_filternorm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._filternorm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3684896ed401090c2040faab891ea5c" name="ab3684896ed401090c2040faab891ea5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3684896ed401090c2040faab891ea5c">&#9670;&#160;</a></span>_filterrad</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._filterrad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae213d94ed077248cdece4090f54880cd" name="ae213d94ed077248cdece4090f54880cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae213d94ed077248cdece4090f54880cd">&#9670;&#160;</a></span>_imcache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._imcache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a35f8fc1b9ab7bf26d8e339bee08da945" name="a35f8fc1b9ab7bf26d8e339bee08da945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f8fc1b9ab7bf26d8e339bee08da945">&#9670;&#160;</a></span>_interpolation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._interpolation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c8bf4966b4172c4837933845eac5e0a" name="a3c8bf4966b4172c4837933845eac5e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8bf4966b4172c4837933845eac5e0a">&#9670;&#160;</a></span>_interpolation_stage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._interpolation_stage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad22ae403e4b99cc76cd7236c3bc45fd8" name="ad22ae403e4b99cc76cd7236c3bc45fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22ae403e4b99cc76cd7236c3bc45fd8">&#9670;&#160;</a></span>_resample</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase._resample</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64950607e4dc75dade3a971f14c874fb" name="a64950607e4dc75dade3a971f14c874fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64950607e4dc75dade3a971f14c874fb">&#9670;&#160;</a></span>axes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.axes</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f9f162e89a42975fbce66440683328a" name="a6f9f162e89a42975fbce66440683328a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9f162e89a42975fbce66440683328a">&#9670;&#160;</a></span>norm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.norm</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc786349e152a9dc981ffde5bc39795" name="aebc786349e152a9dc981ffde5bc39795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc786349e152a9dc981ffde5bc39795">&#9670;&#160;</a></span>origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.origin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa4761bf7ee5af318e64311c4f0349d9" name="afa4761bf7ee5af318e64311c4f0349d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4761bf7ee5af318e64311c4f0349d9">&#9670;&#160;</a></span>stale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.image._ImageBase.stale</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f3acf11a85ca1a4bb68009e2905a3a9" name="a8f3acf11a85ca1a4bb68009e2905a3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3acf11a85ca1a4bb68009e2905a3a9">&#9670;&#160;</a></span>zorder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int matplotlib.image._ImageBase.zorder = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/matplotlib/<a class="el" href="matplotlib_2_image_8py.html">image.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
