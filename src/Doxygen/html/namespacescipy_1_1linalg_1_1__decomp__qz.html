<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.linalg._decomp_qz Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html">_decomp_qz</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg._decomp_qz Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b3afb0e41e8b17dc4be977db7456b1e" id="r_a0b3afb0e41e8b17dc4be977db7456b1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#a0b3afb0e41e8b17dc4be977db7456b1e">_select_function</a> (sort)</td></tr>
<tr class="separator:a0b3afb0e41e8b17dc4be977db7456b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554c4f6b32e867af43f28b0a9c120a8" id="r_ac554c4f6b32e867af43f28b0a9c120a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#ac554c4f6b32e867af43f28b0a9c120a8">_lhp</a> (x, y)</td></tr>
<tr class="separator:ac554c4f6b32e867af43f28b0a9c120a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eeb57af6093bc6c3f2be94d1fc96c1" id="r_ac4eeb57af6093bc6c3f2be94d1fc96c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#ac4eeb57af6093bc6c3f2be94d1fc96c1">_rhp</a> (x, y)</td></tr>
<tr class="separator:ac4eeb57af6093bc6c3f2be94d1fc96c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb00c8ef1c8bc0a19e7a4d239cd163c6" id="r_afb00c8ef1c8bc0a19e7a4d239cd163c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#afb00c8ef1c8bc0a19e7a4d239cd163c6">_iuc</a> (x, y)</td></tr>
<tr class="separator:afb00c8ef1c8bc0a19e7a4d239cd163c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034fda9d80bdd5d5f1219cdd000646f5" id="r_a034fda9d80bdd5d5f1219cdd000646f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#a034fda9d80bdd5d5f1219cdd000646f5">_ouc</a> (x, y)</td></tr>
<tr class="separator:a034fda9d80bdd5d5f1219cdd000646f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6777d76fcf14afd4f6064fa0ca6e1709" id="r_a6777d76fcf14afd4f6064fa0ca6e1709"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#a6777d76fcf14afd4f6064fa0ca6e1709">_qz</a> (A, B, output='real', <a class="el" href="__lapack__subroutines_8h.html#a4e1966d8190ae9135204d1bda97dac14">lwork</a>=None, sort=None, overwrite_a=False, overwrite_b=False, check_finite=True)</td></tr>
<tr class="separator:a6777d76fcf14afd4f6064fa0ca6e1709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941350b16dab84c078eaa1be47e9aa86" id="r_a941350b16dab84c078eaa1be47e9aa86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#a941350b16dab84c078eaa1be47e9aa86">qz</a> (A, B, output='real', <a class="el" href="__lapack__subroutines_8h.html#a4e1966d8190ae9135204d1bda97dac14">lwork</a>=None, sort=None, overwrite_a=False, overwrite_b=False, check_finite=True)</td></tr>
<tr class="separator:a941350b16dab84c078eaa1be47e9aa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede5b0fcf5aee2fdec395c7df56a8266" id="r_aede5b0fcf5aee2fdec395c7df56a8266"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#aede5b0fcf5aee2fdec395c7df56a8266">ordqz</a> (A, B, sort='lhp', output='real', overwrite_a=False, overwrite_b=False, check_finite=True)</td></tr>
<tr class="separator:aede5b0fcf5aee2fdec395c7df56a8266"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8f04cb345ce9438d09ccc175dc20c1fa" id="r_a8f04cb345ce9438d09ccc175dc20c1fa"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__decomp__qz.html#a8f04cb345ce9438d09ccc175dc20c1fa">_double_precision</a> = ['<a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>', 'l', '<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>']</td></tr>
<tr class="separator:a8f04cb345ce9438d09ccc175dc20c1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb00c8ef1c8bc0a19e7a4d239cd163c6" name="afb00c8ef1c8bc0a19e7a4d239cd163c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb00c8ef1c8bc0a19e7a4d239cd163c6">&#9670;&#160;</a></span>_iuc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz._iuc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   51</span><span class="keyword">def </span>_iuc(x, y):</div>
<div class="line"><span class="lineno">   52</span>    out = np.empty_like(x, dtype=bool)</div>
<div class="line"><span class="lineno">   53</span>    nonzero = (y != 0)</div>
<div class="line"><span class="lineno">   54</span>    <span class="comment"># handles (x, y) = (0, 0) too</span></div>
<div class="line"><span class="lineno">   55</span>    out[~nonzero] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   56</span>    out[nonzero] = (abs(x[nonzero]/y[nonzero]) &lt; 1.0)</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac554c4f6b32e867af43f28b0a9c120a8" name="ac554c4f6b32e867af43f28b0a9c120a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac554c4f6b32e867af43f28b0a9c120a8">&#9670;&#160;</a></span>_lhp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz._lhp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   33</span><span class="keyword">def </span>_lhp(x, y):</div>
<div class="line"><span class="lineno">   34</span>    out = np.empty_like(x, dtype=bool)</div>
<div class="line"><span class="lineno">   35</span>    nonzero = (y != 0)</div>
<div class="line"><span class="lineno">   36</span>    <span class="comment"># handles (x, y) = (0, 0) too</span></div>
<div class="line"><span class="lineno">   37</span>    out[~nonzero] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   38</span>    out[nonzero] = (np.real(x[nonzero]/y[nonzero]) &lt; 0.0)</div>
<div class="line"><span class="lineno">   39</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">   40</span> </div>
<div class="line"><span class="lineno">   41</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a034fda9d80bdd5d5f1219cdd000646f5" name="a034fda9d80bdd5d5f1219cdd000646f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034fda9d80bdd5d5f1219cdd000646f5">&#9670;&#160;</a></span>_ouc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz._ouc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   60</span><span class="keyword">def </span>_ouc(x, y):</div>
<div class="line"><span class="lineno">   61</span>    out = np.empty_like(x, dtype=bool)</div>
<div class="line"><span class="lineno">   62</span>    xzero = (x == 0)</div>
<div class="line"><span class="lineno">   63</span>    yzero = (y == 0)</div>
<div class="line"><span class="lineno">   64</span>    out[xzero &amp; yzero] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   65</span>    out[~xzero &amp; yzero] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">   66</span>    out[~yzero] = (abs(x[~yzero]/y[~yzero]) &gt; 1.0)</div>
<div class="line"><span class="lineno">   67</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6777d76fcf14afd4f6064fa0ca6e1709" name="a6777d76fcf14afd4f6064fa0ca6e1709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6777d76fcf14afd4f6064fa0ca6e1709">&#9670;&#160;</a></span>_qz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz._qz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>'real'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lwork</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   71</span>        overwrite_b=<span class="keyword">False</span>, check_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">   72</span>    <span class="keywordflow">if</span> sort <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   73</span>        <span class="comment"># Disabled due to segfaults on win32, see ticket 1717.</span></div>
<div class="line"><span class="lineno">   74</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The &#39;sort&#39; input of qz() has to be None and will be &quot;</span></div>
<div class="line"><span class="lineno">   75</span>                         <span class="stringliteral">&quot;removed in a future release. Use ordqz instead.&quot;</span>)</div>
<div class="line"><span class="lineno">   76</span> </div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">if</span> output <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;real&#39;</span>, <span class="stringliteral">&#39;complex&#39;</span>, <span class="stringliteral">&#39;r&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]:</div>
<div class="line"><span class="lineno">   78</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;argument must be &#39;real&#39;, or &#39;complex&#39;&quot;</span>)</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">if</span> check_finite:</div>
<div class="line"><span class="lineno">   81</span>        a1 = asarray_chkfinite(A)</div>
<div class="line"><span class="lineno">   82</span>        b1 = asarray_chkfinite(B)</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   84</span>        a1 = np.asarray(A)</div>
<div class="line"><span class="lineno">   85</span>        b1 = np.asarray(B)</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>    a_m, a_n = a1.shape</div>
<div class="line"><span class="lineno">   88</span>    b_m, b_n = b1.shape</div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (a_m == a_n == b_m == b_n):</div>
<div class="line"><span class="lineno">   90</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Array dimensions must be square and agree&quot;</span>)</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>    typa = a1.dtype.char</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">if</span> output <span class="keywordflow">in</span> [<span class="stringliteral">&#39;complex&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>] <span class="keywordflow">and</span> typa <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;F&#39;</span>, <span class="stringliteral">&#39;D&#39;</span>]:</div>
<div class="line"><span class="lineno">   94</span>        <span class="keywordflow">if</span> typa <span class="keywordflow">in</span> _double_precision:</div>
<div class="line"><span class="lineno">   95</span>            a1 = a1.astype(<span class="stringliteral">&#39;D&#39;</span>)</div>
<div class="line"><span class="lineno">   96</span>            typa = <span class="stringliteral">&#39;D&#39;</span></div>
<div class="line"><span class="lineno">   97</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   98</span>            a1 = a1.astype(<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno">   99</span>            typa = <span class="stringliteral">&#39;F&#39;</span></div>
<div class="line"><span class="lineno">  100</span>    typb = b1.dtype.char</div>
<div class="line"><span class="lineno">  101</span>    <span class="keywordflow">if</span> output <span class="keywordflow">in</span> [<span class="stringliteral">&#39;complex&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>] <span class="keywordflow">and</span> typb <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;F&#39;</span>, <span class="stringliteral">&#39;D&#39;</span>]:</div>
<div class="line"><span class="lineno">  102</span>        <span class="keywordflow">if</span> typb <span class="keywordflow">in</span> _double_precision:</div>
<div class="line"><span class="lineno">  103</span>            b1 = b1.astype(<span class="stringliteral">&#39;D&#39;</span>)</div>
<div class="line"><span class="lineno">  104</span>            typb = <span class="stringliteral">&#39;D&#39;</span></div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  106</span>            b1 = b1.astype(<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno">  107</span>            typb = <span class="stringliteral">&#39;F&#39;</span></div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>    overwrite_a = overwrite_a <span class="keywordflow">or</span> (_datacopied(a1, A))</div>
<div class="line"><span class="lineno">  110</span>    overwrite_b = overwrite_b <span class="keywordflow">or</span> (_datacopied(b1, B))</div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span>    gges, = get_lapack_funcs((<span class="stringliteral">&#39;gges&#39;</span>,), (a1, b1))</div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span>    <span class="keywordflow">if</span> lwork <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> lwork == -1:</div>
<div class="line"><span class="lineno">  115</span>        <span class="comment"># get optimal work array size</span></div>
<div class="line"><span class="lineno">  116</span>        result = gges(<span class="keyword">lambda</span> x: <span class="keywordtype">None</span>, a1, b1, lwork=-1)</div>
<div class="line"><span class="lineno">  117</span>        lwork = result[-2][0].real.astype(np.int_)</div>
<div class="line"><span class="lineno">  118</span> </div>
<div class="line"><span class="lineno">  119</span>    sfunction = <span class="keyword">lambda</span> x: <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  120</span>    result = gges(sfunction, a1, b1, lwork=lwork, overwrite_a=overwrite_a,</div>
<div class="line"><span class="lineno">  121</span>                  overwrite_b=overwrite_b, sort_t=0)</div>
<div class="line"><span class="lineno">  122</span> </div>
<div class="line"><span class="lineno">  123</span>    info = result[-1]</div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Illegal value in argument {} of gges&quot;</span>.format(-info))</div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">elif</span> info &gt; 0 <span class="keywordflow">and</span> info &lt;= a_n:</div>
<div class="line"><span class="lineno">  127</span>        warnings.warn(<span class="stringliteral">&quot;The QZ iteration failed. (a,b) are not in Schur &quot;</span></div>
<div class="line"><span class="lineno">  128</span>                      <span class="stringliteral">&quot;form, but ALPHAR(j), ALPHAI(j), and BETA(j) should be &quot;</span></div>
<div class="line"><span class="lineno">  129</span>                      <span class="stringliteral">&quot;correct for J={},...,N&quot;</span>.format(info-1), LinAlgWarning,</div>
<div class="line"><span class="lineno">  130</span>                      stacklevel=3)</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">elif</span> info == a_n+1:</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Something other than QZ iteration failed&quot;</span>)</div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">elif</span> info == a_n+2:</div>
<div class="line"><span class="lineno">  134</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;After reordering, roundoff changed values of some &quot;</span></div>
<div class="line"><span class="lineno">  135</span>                          <span class="stringliteral">&quot;complex eigenvalues so that leading eigenvalues &quot;</span></div>
<div class="line"><span class="lineno">  136</span>                          <span class="stringliteral">&quot;in the Generalized Schur form no longer satisfy &quot;</span></div>
<div class="line"><span class="lineno">  137</span>                          <span class="stringliteral">&quot;sort=True. This could also be due to scaling.&quot;</span>)</div>
<div class="line"><span class="lineno">  138</span>    <span class="keywordflow">elif</span> info == a_n+3:</div>
<div class="line"><span class="lineno">  139</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Reordering failed in &lt;s,d,c,z&gt;tgsen&quot;</span>)</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">return</span> result, gges.typecode</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4eeb57af6093bc6c3f2be94d1fc96c1" name="ac4eeb57af6093bc6c3f2be94d1fc96c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eeb57af6093bc6c3f2be94d1fc96c1">&#9670;&#160;</a></span>_rhp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz._rhp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   42</span><span class="keyword">def </span>_rhp(x, y):</div>
<div class="line"><span class="lineno">   43</span>    out = np.empty_like(x, dtype=bool)</div>
<div class="line"><span class="lineno">   44</span>    nonzero = (y != 0)</div>
<div class="line"><span class="lineno">   45</span>    <span class="comment"># handles (x, y) = (0, 0) too</span></div>
<div class="line"><span class="lineno">   46</span>    out[~nonzero] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   47</span>    out[nonzero] = (np.real(x[nonzero]/y[nonzero]) &gt; 0.0)</div>
<div class="line"><span class="lineno">   48</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b3afb0e41e8b17dc4be977db7456b1e" name="a0b3afb0e41e8b17dc4be977db7456b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3afb0e41e8b17dc4be977db7456b1e">&#9670;&#160;</a></span>_select_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz._select_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   14</span><span class="keyword">def </span>_select_function(sort):</div>
<div class="line"><span class="lineno">   15</span>    <span class="keywordflow">if</span> callable(sort):</div>
<div class="line"><span class="lineno">   16</span>        <span class="comment"># assume the user knows what they&#39;re doing</span></div>
<div class="line"><span class="lineno">   17</span>        sfunction = sort</div>
<div class="line"><span class="lineno">   18</span>    <span class="keywordflow">elif</span> sort == <span class="stringliteral">&#39;lhp&#39;</span>:</div>
<div class="line"><span class="lineno">   19</span>        sfunction = _lhp</div>
<div class="line"><span class="lineno">   20</span>    <span class="keywordflow">elif</span> sort == <span class="stringliteral">&#39;rhp&#39;</span>:</div>
<div class="line"><span class="lineno">   21</span>        sfunction = _rhp</div>
<div class="line"><span class="lineno">   22</span>    <span class="keywordflow">elif</span> sort == <span class="stringliteral">&#39;iuc&#39;</span>:</div>
<div class="line"><span class="lineno">   23</span>        sfunction = _iuc</div>
<div class="line"><span class="lineno">   24</span>    <span class="keywordflow">elif</span> sort == <span class="stringliteral">&#39;ouc&#39;</span>:</div>
<div class="line"><span class="lineno">   25</span>        sfunction = _ouc</div>
<div class="line"><span class="lineno">   26</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   27</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;sort parameter must be None, a callable, or &quot;</span></div>
<div class="line"><span class="lineno">   28</span>                         <span class="stringliteral">&quot;one of (&#39;lhp&#39;,&#39;rhp&#39;,&#39;iuc&#39;,&#39;ouc&#39;)&quot;</span>)</div>
<div class="line"><span class="lineno">   29</span> </div>
<div class="line"><span class="lineno">   30</span>    <span class="keywordflow">return</span> sfunction</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aede5b0fcf5aee2fdec395c7df56a8266" name="aede5b0fcf5aee2fdec395c7df56a8266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede5b0fcf5aee2fdec395c7df56a8266">&#9670;&#160;</a></span>ordqz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz.ordqz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>'lhp'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>'real'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">QZ decomposition for a pair of matrices with reordering.

Parameters
----------
A : (N, N) array_like
    2-D array to decompose
B : (N, N) array_like
    2-D array to decompose
sort : {callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
    Specifies whether the upper eigenvalues should be sorted. A
    callable may be passed that, given an ordered pair ``(alpha,
    beta)`` representing the eigenvalue ``x = (alpha/beta)``,
    returns a boolean denoting whether the eigenvalue should be
    sorted to the top-left (True). For the real matrix pairs
    ``beta`` is real while ``alpha`` can be complex, and for
    complex matrix pairs both ``alpha`` and ``beta`` can be
    complex. The callable must be able to accept a NumPy
    array. Alternatively, string parameters may be used:

        - 'lhp'   Left-hand plane (x.real &lt; 0.0)
        - 'rhp'   Right-hand plane (x.real &gt; 0.0)
        - 'iuc'   Inside the unit circle (x*x.conjugate() &lt; 1.0)
        - 'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)

    With the predefined sorting functions, an infinite eigenvalue
    (i.e., ``alpha != 0`` and ``beta = 0``) is considered to lie in
    neither the left-hand nor the right-hand plane, but it is
    considered to lie outside the unit circle. For the eigenvalue
    ``(alpha, beta) = (0, 0)``, the predefined sorting functions
    all return `False`.
output : str {'real','complex'}, optional
    Construct the real or complex QZ decomposition for real matrices.
    Default is 'real'.
overwrite_a : bool, optional
    If True, the contents of A are overwritten.
overwrite_b : bool, optional
    If True, the contents of B are overwritten.
check_finite : bool, optional
    If true checks the elements of `A` and `B` are finite numbers. If
    false does no checking and passes matrix through to
    underlying algorithm.

Returns
-------
AA : (N, N) ndarray
    Generalized Schur form of A.
BB : (N, N) ndarray
    Generalized Schur form of B.
alpha : (N,) ndarray
    alpha = alphar + alphai * 1j. See notes.
beta : (N,) ndarray
    See notes.
Q : (N, N) ndarray
    The left Schur vectors.
Z : (N, N) ndarray
    The right Schur vectors.

Notes
-----
On exit, ``(ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N``, will be the
generalized eigenvalues.  ``ALPHAR(j) + ALPHAI(j)*i`` and
``BETA(j),j=1,...,N`` are the diagonals of the complex Schur form (S,T)
that would result if the 2-by-2 diagonal blocks of the real generalized
Schur form of (A,B) were further reduced to triangular form using complex
unitary transformations. If ALPHAI(j) is zero, then the jth eigenvalue is
real; if positive, then the ``j``th and ``(j+1)``st eigenvalues are a
complex conjugate pair, with ``ALPHAI(j+1)`` negative.

.. versionadded:: 0.17.0

See Also
--------
qz

Examples
--------
&gt;&gt;&gt; from scipy.linalg import ordqz
&gt;&gt;&gt; A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
&gt;&gt;&gt; B = np.array([[0, 6, 0, 0], [5, 0, 2, 1], [5, 2, 6, 6], [4, 7, 7, 7]])
&gt;&gt;&gt; AA, BB, alpha, beta, Q, Z = ordqz(A, B, sort='lhp')

Since we have sorted for left half plane eigenvalues, negatives come first

&gt;&gt;&gt; (alpha/beta).real &lt; 0
array([ True,  True, False, False], dtype=bool)</pre> <div class="fragment"><div class="line"><span class="lineno">  265</span>          overwrite_b=<span class="keyword">False</span>, check_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  266</span>    <span class="stringliteral">&quot;&quot;&quot;QZ decomposition for a pair of matrices with reordering.</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        2-D array to decompose</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    B : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">        2-D array to decompose</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    sort : {callable, &#39;lhp&#39;, &#39;rhp&#39;, &#39;iuc&#39;, &#39;ouc&#39;}, optional</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        Specifies whether the upper eigenvalues should be sorted. A</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        callable may be passed that, given an ordered pair ``(alpha,</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        beta)`` representing the eigenvalue ``x = (alpha/beta)``,</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        returns a boolean denoting whether the eigenvalue should be</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        sorted to the top-left (True). For the real matrix pairs</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        ``beta`` is real while ``alpha`` can be complex, and for</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        complex matrix pairs both ``alpha`` and ``beta`` can be</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        complex. The callable must be able to accept a NumPy</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        array. Alternatively, string parameters may be used:</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">            - &#39;lhp&#39;   Left-hand plane (x.real &lt; 0.0)</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">            - &#39;rhp&#39;   Right-hand plane (x.real &gt; 0.0)</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">            - &#39;iuc&#39;   Inside the unit circle (x*x.conjugate() &lt; 1.0)</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">            - &#39;ouc&#39;   Outside the unit circle (x*x.conjugate() &gt; 1.0)</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">        With the predefined sorting functions, an infinite eigenvalue</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        (i.e., ``alpha != 0`` and ``beta = 0``) is considered to lie in</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        neither the left-hand nor the right-hand plane, but it is</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        considered to lie outside the unit circle. For the eigenvalue</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        ``(alpha, beta) = (0, 0)``, the predefined sorting functions</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        all return `False`.</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    output : str {&#39;real&#39;,&#39;complex&#39;}, optional</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        Construct the real or complex QZ decomposition for real matrices.</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        Default is &#39;real&#39;.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    overwrite_a : bool, optional</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        If True, the contents of A are overwritten.</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    overwrite_b : bool, optional</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">        If True, the contents of B are overwritten.</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        If true checks the elements of `A` and `B` are finite numbers. If</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        false does no checking and passes matrix through to</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">        underlying algorithm.</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    AA : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        Generalized Schur form of A.</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    BB : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        Generalized Schur form of B.</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    alpha : (N,) ndarray</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        alpha = alphar + alphai * 1j. See notes.</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    beta : (N,) ndarray</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        See notes.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    Q : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        The left Schur vectors.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    Z : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        The right Schur vectors.</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    On exit, ``(ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N``, will be the</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    generalized eigenvalues.  ``ALPHAR(j) + ALPHAI(j)*i`` and</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    ``BETA(j),j=1,...,N`` are the diagonals of the complex Schur form (S,T)</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    that would result if the 2-by-2 diagonal blocks of the real generalized</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    Schur form of (A,B) were further reduced to triangular form using complex</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    unitary transformations. If ALPHAI(j) is zero, then the jth eigenvalue is</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    real; if positive, then the ``j``th and ``(j+1)``st eigenvalues are a</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    complex conjugate pair, with ``ALPHAI(j+1)`` negative.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    .. versionadded:: 0.17.0</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    qz</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import ordqz</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    &gt;&gt;&gt; B = np.array([[0, 6, 0, 0], [5, 0, 2, 1], [5, 2, 6, 6], [4, 7, 7, 7]])</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    &gt;&gt;&gt; AA, BB, alpha, beta, Q, Z = ordqz(A, B, sort=&#39;lhp&#39;)</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    Since we have sorted for left half plane eigenvalues, negatives come first</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    &gt;&gt;&gt; (alpha/beta).real &lt; 0</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    array([ True,  True, False, False], dtype=bool)</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  353</span>    (AA, BB, _, *ab, Q, Z, _, _), typ = _qz(A, B, output=output, sort=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  354</span>                                            overwrite_a=overwrite_a,</div>
<div class="line"><span class="lineno">  355</span>                                            overwrite_b=overwrite_b,</div>
<div class="line"><span class="lineno">  356</span>                                            check_finite=check_finite)</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>    <span class="keywordflow">if</span> typ == <span class="stringliteral">&#39;s&#39;</span>:</div>
<div class="line"><span class="lineno">  359</span>        alpha, beta = ab[0] + ab[1]*np.complex64(1j), ab[2]</div>
<div class="line"><span class="lineno">  360</span>    <span class="keywordflow">elif</span> typ == <span class="stringliteral">&#39;d&#39;</span>:</div>
<div class="line"><span class="lineno">  361</span>        alpha, beta = ab[0] + ab[1]*1.j, ab[2]</div>
<div class="line"><span class="lineno">  362</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  363</span>        alpha, beta = ab</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>    sfunction = _select_function(sort)</div>
<div class="line"><span class="lineno">  366</span>    select = sfunction(alpha, beta)</div>
<div class="line"><span class="lineno">  367</span> </div>
<div class="line"><span class="lineno">  368</span>    tgsen = get_lapack_funcs(<span class="stringliteral">&#39;tgsen&#39;</span>, (AA, BB))</div>
<div class="line"><span class="lineno">  369</span>    <span class="comment"># the real case needs 4n + 16 lwork</span></div>
<div class="line"><span class="lineno">  370</span>    lwork = 4*AA.shape[0] + 16 <span class="keywordflow">if</span> typ <span class="keywordflow">in</span> <span class="stringliteral">&#39;sd&#39;</span> <span class="keywordflow">else</span> 1</div>
<div class="line"><span class="lineno">  371</span>    AAA, BBB, *ab, QQ, ZZ, _, _, _, _, info = tgsen(select, AA, BB, Q, Z,</div>
<div class="line"><span class="lineno">  372</span>                                                    ijob=0,</div>
<div class="line"><span class="lineno">  373</span>                                                    lwork=lwork, liwork=1)</div>
<div class="line"><span class="lineno">  374</span> </div>
<div class="line"><span class="lineno">  375</span>    <span class="comment"># Once more for tgsen output</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">if</span> typ == <span class="stringliteral">&#39;s&#39;</span>:</div>
<div class="line"><span class="lineno">  377</span>        alpha, beta = ab[0] + ab[1]*np.complex64(1j), ab[2]</div>
<div class="line"><span class="lineno">  378</span>    <span class="keywordflow">elif</span> typ == <span class="stringliteral">&#39;d&#39;</span>:</div>
<div class="line"><span class="lineno">  379</span>        alpha, beta = ab[0] + ab[1]*1.j, ab[2]</div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  381</span>        alpha, beta = ab</div>
<div class="line"><span class="lineno">  382</span> </div>
<div class="line"><span class="lineno">  383</span>    <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno">  384</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Illegal value in argument {-info} of tgsen&quot;</span>)</div>
<div class="line"><span class="lineno">  385</span>    <span class="keywordflow">elif</span> info == 1:</div>
<div class="line"><span class="lineno">  386</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Reordering of (A, B) failed because the transformed&quot;</span></div>
<div class="line"><span class="lineno">  387</span>                         <span class="stringliteral">&quot; matrix pair (A, B) would be too far from &quot;</span></div>
<div class="line"><span class="lineno">  388</span>                         <span class="stringliteral">&quot;generalized Schur form; the problem is very &quot;</span></div>
<div class="line"><span class="lineno">  389</span>                         <span class="stringliteral">&quot;ill-conditioned. (A, B) may have been partially &quot;</span></div>
<div class="line"><span class="lineno">  390</span>                         <span class="stringliteral">&quot;reordered.&quot;</span>)</div>
<div class="line"><span class="lineno">  391</span> </div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordflow">return</span> AAA, BBB, alpha, beta, QQ, ZZ</div>
</div><!-- fragment -->
</div>
</div>
<a id="a941350b16dab84c078eaa1be47e9aa86" name="a941350b16dab84c078eaa1be47e9aa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941350b16dab84c078eaa1be47e9aa86">&#9670;&#160;</a></span>qz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._decomp_qz.qz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>'real'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lwork</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">QZ decomposition for generalized eigenvalues of a pair of matrices.

The QZ, or generalized Schur, decomposition for a pair of n-by-n
matrices (A,B) is::

    (A,B) = (Q @ AA @ Z*, Q @ BB @ Z*)

where AA, BB is in generalized Schur form if BB is upper-triangular
with non-negative diagonal and AA is upper-triangular, or for real QZ
decomposition (``output='real'``) block upper triangular with 1x1
and 2x2 blocks. In this case, the 1x1 blocks correspond to real
generalized eigenvalues and 2x2 blocks are 'standardized' by making
the corresponding elements of BB have the form::

    [ a 0 ]
    [ 0 b ]

and the pair of corresponding 2x2 blocks in AA and BB will have a complex
conjugate pair of generalized eigenvalues. If (``output='complex'``) or
A and B are complex matrices, Z' denotes the conjugate-transpose of Z.
Q and Z are unitary matrices.

Parameters
----------
A : (N, N) array_like
    2-D array to decompose
B : (N, N) array_like
    2-D array to decompose
output : {'real', 'complex'}, optional
    Construct the real or complex QZ decomposition for real matrices.
    Default is 'real'.
lwork : int, optional
    Work array size. If None or -1, it is automatically computed.
sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
    NOTE: THIS INPUT IS DISABLED FOR NOW. Use ordqz instead.

    Specifies whether the upper eigenvalues should be sorted. A callable
    may be passed that, given a eigenvalue, returns a boolean denoting
    whether the eigenvalue should be sorted to the top-left (True). For
    real matrix pairs, the sort function takes three real arguments
    (alphar, alphai, beta). The eigenvalue
    ``x = (alphar + alphai*1j)/beta``. For complex matrix pairs or
    output='complex', the sort function takes two complex arguments
    (alpha, beta). The eigenvalue ``x = (alpha/beta)``.  Alternatively,
    string parameters may be used:

        - 'lhp'   Left-hand plane (x.real &lt; 0.0)
        - 'rhp'   Right-hand plane (x.real &gt; 0.0)
        - 'iuc'   Inside the unit circle (x*x.conjugate() &lt; 1.0)
        - 'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)

    Defaults to None (no sorting).
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance)
overwrite_b : bool, optional
    Whether to overwrite data in b (may improve performance)
check_finite : bool, optional
    If true checks the elements of `A` and `B` are finite numbers. If
    false does no checking and passes matrix through to
    underlying algorithm.

Returns
-------
AA : (N, N) ndarray
    Generalized Schur form of A.
BB : (N, N) ndarray
    Generalized Schur form of B.
Q : (N, N) ndarray
    The left Schur vectors.
Z : (N, N) ndarray
    The right Schur vectors.

Notes
-----
Q is transposed versus the equivalent function in Matlab.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; A = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; B = rng.standard_normal((3, 3))

&gt;&gt;&gt; AA, BB, Q, Z = linalg.qz(A, B)
&gt;&gt;&gt; AA
array([[ 8.99591445e+00, -1.07917902e+01, -2.18309912e+00],
       [ 0.00000000e+00, -8.60837546e-01,  1.05063006e+00],
       [ 0.00000000e+00,  0.00000000e+00, -1.40584278e-15]])
&gt;&gt;&gt; BB
array([[ 0.2058989 , -0.6007898 , -0.5771396 ],
       [ 0.        ,  1.6997737 , -1.12160842],
       [ 0.        ,  0.        ,  1.76304656]])
&gt;&gt;&gt; Q
array([[ 0.10356118,  0.90697763, -0.40824829],
       [ 0.48575095,  0.31205664,  0.81649658],
       [ 0.86794072, -0.28286434, -0.40824829]])
&gt;&gt;&gt; Z
array([[ 0.78900531,  0.16010775, -0.59315776],
       [-0.21754047, -0.83009894, -0.51343148],
       [ 0.57458399, -0.53413598,  0.62012256]])

See Also
--------
ordqz
</pre> <div class="fragment"><div class="line"><span class="lineno">  145</span>       overwrite_b=<span class="keyword">False</span>, check_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  146</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    QZ decomposition for generalized eigenvalues of a pair of matrices.</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    The QZ, or generalized Schur, decomposition for a pair of n-by-n</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    matrices (A,B) is::</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        (A,B) = (Q @ AA @ Z*, Q @ BB @ Z*)</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    where AA, BB is in generalized Schur form if BB is upper-triangular</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    with non-negative diagonal and AA is upper-triangular, or for real QZ</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    decomposition (``output=&#39;real&#39;``) block upper triangular with 1x1</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    and 2x2 blocks. In this case, the 1x1 blocks correspond to real</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    generalized eigenvalues and 2x2 blocks are &#39;standardized&#39; by making</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    the corresponding elements of BB have the form::</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        [ a 0 ]</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        [ 0 b ]</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    and the pair of corresponding 2x2 blocks in AA and BB will have a complex</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    conjugate pair of generalized eigenvalues. If (``output=&#39;complex&#39;``) or</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    A and B are complex matrices, Z&#39; denotes the conjugate-transpose of Z.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    Q and Z are unitary matrices.</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        2-D array to decompose</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    B : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        2-D array to decompose</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    output : {&#39;real&#39;, &#39;complex&#39;}, optional</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        Construct the real or complex QZ decomposition for real matrices.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">        Default is &#39;real&#39;.</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    lwork : int, optional</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">        Work array size. If None or -1, it is automatically computed.</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    sort : {None, callable, &#39;lhp&#39;, &#39;rhp&#39;, &#39;iuc&#39;, &#39;ouc&#39;}, optional</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        NOTE: THIS INPUT IS DISABLED FOR NOW. Use ordqz instead.</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">        Specifies whether the upper eigenvalues should be sorted. A callable</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        may be passed that, given a eigenvalue, returns a boolean denoting</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        whether the eigenvalue should be sorted to the top-left (True). For</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        real matrix pairs, the sort function takes three real arguments</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">        (alphar, alphai, beta). The eigenvalue</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        ``x = (alphar + alphai*1j)/beta``. For complex matrix pairs or</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">        output=&#39;complex&#39;, the sort function takes two complex arguments</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">        (alpha, beta). The eigenvalue ``x = (alpha/beta)``.  Alternatively,</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">        string parameters may be used:</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">            - &#39;lhp&#39;   Left-hand plane (x.real &lt; 0.0)</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">            - &#39;rhp&#39;   Right-hand plane (x.real &gt; 0.0)</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">            - &#39;iuc&#39;   Inside the unit circle (x*x.conjugate() &lt; 1.0)</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">            - &#39;ouc&#39;   Outside the unit circle (x*x.conjugate() &gt; 1.0)</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">        Defaults to None (no sorting).</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    overwrite_a : bool, optional</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        Whether to overwrite data in a (may improve performance)</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    overwrite_b : bool, optional</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        Whether to overwrite data in b (may improve performance)</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        If true checks the elements of `A` and `B` are finite numbers. If</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">        false does no checking and passes matrix through to</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        underlying algorithm.</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    AA : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        Generalized Schur form of A.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    BB : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        Generalized Schur form of B.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    Q : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        The left Schur vectors.</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    Z : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        The right Schur vectors.</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    Q is transposed versus the equivalent function in Matlab.</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import linalg</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; A = np.arange(9).reshape((3, 3))</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &gt;&gt;&gt; B = rng.standard_normal((3, 3))</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    &gt;&gt;&gt; AA, BB, Q, Z = linalg.qz(A, B)</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    &gt;&gt;&gt; AA</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    array([[ 8.99591445e+00, -1.07917902e+01, -2.18309912e+00],</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">           [ 0.00000000e+00, -8.60837546e-01,  1.05063006e+00],</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">           [ 0.00000000e+00,  0.00000000e+00, -1.40584278e-15]])</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    &gt;&gt;&gt; BB</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    array([[ 0.2058989 , -0.6007898 , -0.5771396 ],</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">           [ 0.        ,  1.6997737 , -1.12160842],</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">           [ 0.        ,  0.        ,  1.76304656]])</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    &gt;&gt;&gt; Q</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    array([[ 0.10356118,  0.90697763, -0.40824829],</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">           [ 0.48575095,  0.31205664,  0.81649658],</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">           [ 0.86794072, -0.28286434, -0.40824829]])</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    array([[ 0.78900531,  0.16010775, -0.59315776],</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">           [-0.21754047, -0.83009894, -0.51343148],</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">           [ 0.57458399, -0.53413598,  0.62012256]])</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    ordqz</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  254</span>    <span class="comment"># output for real</span></div>
<div class="line"><span class="lineno">  255</span>    <span class="comment"># AA, BB, sdim, alphar, alphai, beta, vsl, vsr, work, info</span></div>
<div class="line"><span class="lineno">  256</span>    <span class="comment"># output for complex</span></div>
<div class="line"><span class="lineno">  257</span>    <span class="comment"># AA, BB, sdim, alpha, beta, vsl, vsr, work, info</span></div>
<div class="line"><span class="lineno">  258</span>    result, _ = _qz(A, B, output=output, lwork=lwork, sort=sort,</div>
<div class="line"><span class="lineno">  259</span>                    overwrite_a=overwrite_a, overwrite_b=overwrite_b,</div>
<div class="line"><span class="lineno">  260</span>                    check_finite=check_finite)</div>
<div class="line"><span class="lineno">  261</span>    <span class="keywordflow">return</span> result[0], result[1], result[-4], result[-3]</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8f04cb345ce9438d09ccc175dc20c1fa" name="a8f04cb345ce9438d09ccc175dc20c1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f04cb345ce9438d09ccc175dc20c1fa">&#9670;&#160;</a></span>_double_precision</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.linalg._decomp_qz._double_precision = ['<a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>', 'l', '<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>']</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
