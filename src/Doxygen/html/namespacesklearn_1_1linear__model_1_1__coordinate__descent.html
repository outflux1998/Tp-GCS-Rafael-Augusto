<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.linear_model._coordinate_descent Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1linear__model.html">linear_model</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1linear__model_1_1__coordinate__descent.html">_coordinate_descent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.linear_model._coordinate_descent Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_elastic_net.html">ElasticNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ElasticNet model.  <a href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_elastic_net.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_elastic_net_c_v.html">ElasticNetCV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_lasso.html">Lasso</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_lasso_c_v.html">LassoCV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_linear_model_c_v.html">LinearModelCV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_multi_task_elastic_net.html">MultiTaskElasticNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_multi_task_elastic_net_c_v.html">MultiTaskElasticNetCV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_multi_task_lasso.html">MultiTaskLasso</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1linear__model_1_1__coordinate__descent_1_1_multi_task_lasso_c_v.html">MultiTaskLassoCV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a401cd9902c04b523954361538181394a" id="r_a401cd9902c04b523954361538181394a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1linear__model_1_1__coordinate__descent.html#a401cd9902c04b523954361538181394a">_set_order</a> (X, y, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=&quot;C&quot;)</td></tr>
<tr class="separator:a401cd9902c04b523954361538181394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689cd4bf77e7ddc763584088f0f68618" id="r_a689cd4bf77e7ddc763584088f0f68618"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1linear__model_1_1__coordinate__descent.html#a689cd4bf77e7ddc763584088f0f68618">_alpha_grid</a> (X, y, Xy=None, l1_ratio=1.0, fit_intercept=True, <a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=1e-3, n_alphas=100, copy_X=True)</td></tr>
<tr class="memdesc:a689cd4bf77e7ddc763584088f0f68618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Paths functions.  <br /></td></tr>
<tr class="separator:a689cd4bf77e7ddc763584088f0f68618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480c334129d04e98ffe6707ce92a076" id="r_a6480c334129d04e98ffe6707ce92a076"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1linear__model_1_1__coordinate__descent.html#a6480c334129d04e98ffe6707ce92a076">lasso_path</a> (X, y, *<a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=1e-3, n_alphas=100, alphas=None, precompute=&quot;auto&quot;, Xy=None, copy_X=True, coef_init=None, verbose=False, return_n_iter=False, positive=False, **params)</td></tr>
<tr class="separator:a6480c334129d04e98ffe6707ce92a076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6befd74797b0bd286dcf01b5691975da" id="r_a6befd74797b0bd286dcf01b5691975da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1linear__model_1_1__coordinate__descent.html#a6befd74797b0bd286dcf01b5691975da">enet_path</a> (X, y, *l1_ratio=0.5, <a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=1e-3, n_alphas=100, alphas=None, precompute=&quot;auto&quot;, Xy=None, copy_X=True, coef_init=None, verbose=False, return_n_iter=False, positive=False, check_input=True, **params)</td></tr>
<tr class="separator:a6befd74797b0bd286dcf01b5691975da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7896f61f556a9b3bb8a26402303001fb" id="r_a7896f61f556a9b3bb8a26402303001fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1linear__model_1_1__coordinate__descent.html#a7896f61f556a9b3bb8a26402303001fb">_path_residuals</a> (X, y, sample_weight, train, test, fit_intercept, path, path_params, alphas=None, l1_ratio=1, X_order=None, dtype=None)</td></tr>
<tr class="separator:a7896f61f556a9b3bb8a26402303001fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a689cd4bf77e7ddc763584088f0f68618" name="a689cd4bf77e7ddc763584088f0f68618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689cd4bf77e7ddc763584088f0f68618">&#9670;&#160;</a></span>_alpha_grid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.linear_model._coordinate_descent._alpha_grid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Xy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l1_ratio</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_intercept</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_alphas</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy_X</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Paths functions. </p>
<pre class="fragment">Compute the grid of alpha values for elastic net parameter search

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data. Pass directly as Fortran-contiguous data to avoid
    unnecessary memory duplication

y : ndarray of shape (n_samples,) or (n_samples, n_outputs)
    Target values

Xy : array-like of shape (n_features,) or (n_features, n_outputs),\
     default=None
    Xy = np.dot(X.T, y) that can be precomputed.

l1_ratio : float, default=1.0
    The elastic net mixing parameter, with ``0 &lt; l1_ratio &lt;= 1``.
    For ``l1_ratio = 0`` the penalty is an L2 penalty. (currently not
    supported) ``For l1_ratio = 1`` it is an L1 penalty. For
    ``0 &lt; l1_ratio &lt;1``, the penalty is a combination of L1 and L2.

eps : float, default=1e-3
    Length of the path. ``eps=1e-3`` means that
    ``alpha_min / alpha_max = 1e-3``

n_alphas : int, default=100
    Number of alphas along the regularization path

fit_intercept : bool, default=True
    Whether to fit an intercept or not

copy_X : bool, default=True
    If ``True``, X will be copied; else, it may be overwritten.
</pre> <div class="fragment"><div class="line"><span class="lineno">   96</span>):</div>
<div class="line"><span class="lineno">   97</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the grid of alpha values for elastic net parameter search</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        Training data. Pass directly as Fortran-contiguous data to avoid</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        unnecessary memory duplication</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    y : ndarray of shape (n_samples,) or (n_samples, n_outputs)</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        Target values</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    Xy : array-like of shape (n_features,) or (n_features, n_outputs),\</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">         default=None</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        Xy = np.dot(X.T, y) that can be precomputed.</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    l1_ratio : float, default=1.0</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        The elastic net mixing parameter, with ``0 &lt; l1_ratio &lt;= 1``.</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        For ``l1_ratio = 0`` the penalty is an L2 penalty. (currently not</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        supported) ``For l1_ratio = 1`` it is an L1 penalty. For</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">        ``0 &lt; l1_ratio &lt;1``, the penalty is a combination of L1 and L2.</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    eps : float, default=1e-3</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        Length of the path. ``eps=1e-3`` means that</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        ``alpha_min / alpha_max = 1e-3``</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    n_alphas : int, default=100</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">        Number of alphas along the regularization path</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    fit_intercept : bool, default=True</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        Whether to fit an intercept or not</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    copy_X : bool, default=True</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">        If ``True``, X will be copied; else, it may be overwritten.</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">if</span> l1_ratio == 0:</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  133</span>            <span class="stringliteral">&quot;Automatic alpha grid generation is not supported for&quot;</span></div>
<div class="line"><span class="lineno">  134</span>            <span class="stringliteral">&quot; l1_ratio=0. Please supply a grid by providing &quot;</span></div>
<div class="line"><span class="lineno">  135</span>            <span class="stringliteral">&quot;your estimator with the appropriate `alphas=` &quot;</span></div>
<div class="line"><span class="lineno">  136</span>            <span class="stringliteral">&quot;argument.&quot;</span></div>
<div class="line"><span class="lineno">  137</span>        )</div>
<div class="line"><span class="lineno">  138</span>    n_samples = len(y)</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>    sparse_center = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">if</span> Xy <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  142</span>        X_sparse = sparse.isspmatrix(X)</div>
<div class="line"><span class="lineno">  143</span>        sparse_center = X_sparse <span class="keywordflow">and</span> fit_intercept</div>
<div class="line"><span class="lineno">  144</span>        X = check_array(</div>
<div class="line"><span class="lineno">  145</span>            X, accept_sparse=<span class="stringliteral">&quot;csc&quot;</span>, copy=(copy_X <span class="keywordflow">and</span> fit_intercept <span class="keywordflow">and</span> <span class="keywordflow">not</span> X_sparse)</div>
<div class="line"><span class="lineno">  146</span>        )</div>
<div class="line"><span class="lineno">  147</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> X_sparse:</div>
<div class="line"><span class="lineno">  148</span>            <span class="comment"># X can be touched inplace thanks to the above line</span></div>
<div class="line"><span class="lineno">  149</span>            X, y, _, _, _ = _preprocess_data(X, y, fit_intercept, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  150</span>        Xy = safe_sparse_dot(X.T, y, dense_output=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span>        <span class="keywordflow">if</span> sparse_center:</div>
<div class="line"><span class="lineno">  153</span>            <span class="comment"># Workaround to find alpha_max for sparse matrices.</span></div>
<div class="line"><span class="lineno">  154</span>            <span class="comment"># since we should not destroy the sparsity of such matrices.</span></div>
<div class="line"><span class="lineno">  155</span>            _, _, X_offset, _, X_scale = _preprocess_data(X, y, fit_intercept)</div>
<div class="line"><span class="lineno">  156</span>            mean_dot = X_offset * np.sum(y)</div>
<div class="line"><span class="lineno">  157</span> </div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">if</span> Xy.ndim == 1:</div>
<div class="line"><span class="lineno">  159</span>        Xy = Xy[:, np.newaxis]</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">if</span> sparse_center:</div>
<div class="line"><span class="lineno">  162</span>        <span class="keywordflow">if</span> fit_intercept:</div>
<div class="line"><span class="lineno">  163</span>            Xy -= mean_dot[:, np.newaxis]</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    alpha_max = np.sqrt(np.sum(Xy**2, axis=1)).max() / (n_samples * l1_ratio)</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>    <span class="keywordflow">if</span> alpha_max &lt;= np.finfo(float).resolution:</div>
<div class="line"><span class="lineno">  168</span>        alphas = np.empty(n_alphas)</div>
<div class="line"><span class="lineno">  169</span>        alphas.fill(np.finfo(float).resolution)</div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordflow">return</span> alphas</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordflow">return</span> np.logspace(np.log10(alpha_max * eps), np.log10(alpha_max), num=n_alphas)[</div>
<div class="line"><span class="lineno">  173</span>        ::-1</div>
<div class="line"><span class="lineno">  174</span>    ]</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7896f61f556a9b3bb8a26402303001fb" name="a7896f61f556a9b3bb8a26402303001fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7896f61f556a9b3bb8a26402303001fb">&#9670;&#160;</a></span>_path_residuals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.linear_model._coordinate_descent._path_residuals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>train</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_intercept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphas</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l1_ratio</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X_order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the MSE for the models computed by 'path'.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data.

y : array-like of shape (n_samples,) or (n_samples, n_targets)
    Target values.

sample_weight : None or array-like of shape (n_samples,)
    Sample weights.

train : list of indices
    The indices of the train set.

test : list of indices
    The indices of the test set.

path : callable
    Function returning a list of models on the path. See
    enet_path for an example of signature.

path_params : dictionary
    Parameters passed to the path function.

alphas : array-like, default=None
    Array of float that is used for cross-validation. If not
    provided, computed using 'path'.

l1_ratio : float, default=1
    float between 0 and 1 passed to ElasticNet (scaling between
    l1 and l2 penalties). For ``l1_ratio = 0`` the penalty is an
    L2 penalty. For ``l1_ratio = 1`` it is an L1 penalty. For ``0
    &lt; l1_ratio &lt; 1``, the penalty is a combination of L1 and L2.

X_order : {'F', 'C'}, default=None
    The order of the arrays expected by the path function to
    avoid memory copies.

dtype : a numpy dtype, default=None
    The dtype of the arrays expected by the path function to
    avoid memory copies.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1276</span>):</div>
<div class="line"><span class="lineno"> 1277</span>    <span class="stringliteral">&quot;&quot;&quot;Returns the MSE for the models computed by &#39;path&#39;.</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">        Training data.</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_targets)</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        Target values.</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    sample_weight : None or array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">        Sample weights.</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    train : list of indices</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">        The indices of the train set.</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    test : list of indices</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">        The indices of the test set.</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    path : callable</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">        Function returning a list of models on the path. See</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">        enet_path for an example of signature.</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    path_params : dictionary</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">        Parameters passed to the path function.</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    alphas : array-like, default=None</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">        Array of float that is used for cross-validation. If not</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">        provided, computed using &#39;path&#39;.</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    l1_ratio : float, default=1</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">        float between 0 and 1 passed to ElasticNet (scaling between</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">        l1 and l2 penalties). For ``l1_ratio = 0`` the penalty is an</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">        L2 penalty. For ``l1_ratio = 1`` it is an L1 penalty. For ``0</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">        &lt; l1_ratio &lt; 1``, the penalty is a combination of L1 and L2.</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    X_order : {&#39;F&#39;, &#39;C&#39;}, default=None</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">        The order of the arrays expected by the path function to</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">        avoid memory copies.</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    dtype : a numpy dtype, default=None</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">        The dtype of the arrays expected by the path function to</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">        avoid memory copies.</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1321</span>    X_train = X[train]</div>
<div class="line"><span class="lineno"> 1322</span>    y_train = y[train]</div>
<div class="line"><span class="lineno"> 1323</span>    X_test = X[test]</div>
<div class="line"><span class="lineno"> 1324</span>    y_test = y[test]</div>
<div class="line"><span class="lineno"> 1325</span>    <span class="keywordflow">if</span> sample_weight <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1326</span>        sw_train, sw_test = <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1327</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1328</span>        sw_train = sample_weight[train]</div>
<div class="line"><span class="lineno"> 1329</span>        sw_test = sample_weight[test]</div>
<div class="line"><span class="lineno"> 1330</span>        n_samples = X_train.shape[0]</div>
<div class="line"><span class="lineno"> 1331</span>        <span class="comment"># TLDR: Rescale sw_train to sum up to n_samples on the training set.</span></div>
<div class="line"><span class="lineno"> 1332</span>        <span class="comment"># See TLDR and long comment inside ElasticNet.fit.</span></div>
<div class="line"><span class="lineno"> 1333</span>        sw_train *= n_samples / np.sum(sw_train)</div>
<div class="line"><span class="lineno"> 1334</span>        <span class="comment"># Note: Alternatively, we could also have rescaled alpha instead</span></div>
<div class="line"><span class="lineno"> 1335</span>        <span class="comment"># of sample_weight:</span></div>
<div class="line"><span class="lineno"> 1336</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1337</span>        <span class="comment">#     alpha *= np.sum(sample_weight) / n_samples</span></div>
<div class="line"><span class="lineno"> 1338</span> </div>
<div class="line"><span class="lineno"> 1339</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> sparse.issparse(X):</div>
<div class="line"><span class="lineno"> 1340</span>        <span class="keywordflow">for</span> array, array_input <span class="keywordflow">in</span> (</div>
<div class="line"><span class="lineno"> 1341</span>            (X_train, X),</div>
<div class="line"><span class="lineno"> 1342</span>            (y_train, y),</div>
<div class="line"><span class="lineno"> 1343</span>            (X_test, X),</div>
<div class="line"><span class="lineno"> 1344</span>            (y_test, y),</div>
<div class="line"><span class="lineno"> 1345</span>        ):</div>
<div class="line"><span class="lineno"> 1346</span>            <span class="keywordflow">if</span> array.base <span class="keywordflow">is</span> <span class="keywordflow">not</span> array_input <span class="keywordflow">and</span> <span class="keywordflow">not</span> array.flags[<span class="stringliteral">&quot;WRITEABLE&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1347</span>                <span class="comment"># fancy indexing should create a writable copy but it doesn&#39;t</span></div>
<div class="line"><span class="lineno"> 1348</span>                <span class="comment"># for read-only memmaps (cf. numpy#14132).</span></div>
<div class="line"><span class="lineno"> 1349</span>                array.setflags(write=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1350</span> </div>
<div class="line"><span class="lineno"> 1351</span>    <span class="keywordflow">if</span> y.ndim == 1:</div>
<div class="line"><span class="lineno"> 1352</span>        precompute = path_params[<span class="stringliteral">&quot;precompute&quot;</span>]</div>
<div class="line"><span class="lineno"> 1353</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1354</span>        <span class="comment"># No Gram variant of multi-task exists right now.</span></div>
<div class="line"><span class="lineno"> 1355</span>        <span class="comment"># Fall back to default enet_multitask</span></div>
<div class="line"><span class="lineno"> 1356</span>        precompute = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1357</span> </div>
<div class="line"><span class="lineno"> 1358</span>    X_train, y_train, X_offset, y_offset, X_scale, precompute, Xy = _pre_fit(</div>
<div class="line"><span class="lineno"> 1359</span>        X_train,</div>
<div class="line"><span class="lineno"> 1360</span>        y_train,</div>
<div class="line"><span class="lineno"> 1361</span>        <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno"> 1362</span>        precompute,</div>
<div class="line"><span class="lineno"> 1363</span>        normalize=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1364</span>        fit_intercept=fit_intercept,</div>
<div class="line"><span class="lineno"> 1365</span>        copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1366</span>        sample_weight=sw_train,</div>
<div class="line"><span class="lineno"> 1367</span>    )</div>
<div class="line"><span class="lineno"> 1368</span> </div>
<div class="line"><span class="lineno"> 1369</span>    path_params = path_params.copy()</div>
<div class="line"><span class="lineno"> 1370</span>    path_params[<span class="stringliteral">&quot;Xy&quot;</span>] = Xy</div>
<div class="line"><span class="lineno"> 1371</span>    path_params[<span class="stringliteral">&quot;X_offset&quot;</span>] = X_offset</div>
<div class="line"><span class="lineno"> 1372</span>    path_params[<span class="stringliteral">&quot;X_scale&quot;</span>] = X_scale</div>
<div class="line"><span class="lineno"> 1373</span>    path_params[<span class="stringliteral">&quot;precompute&quot;</span>] = precompute</div>
<div class="line"><span class="lineno"> 1374</span>    path_params[<span class="stringliteral">&quot;copy_X&quot;</span>] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1375</span>    path_params[<span class="stringliteral">&quot;alphas&quot;</span>] = alphas</div>
<div class="line"><span class="lineno"> 1376</span>    <span class="comment"># needed for sparse cd solver</span></div>
<div class="line"><span class="lineno"> 1377</span>    path_params[<span class="stringliteral">&quot;sample_weight&quot;</span>] = sw_train</div>
<div class="line"><span class="lineno"> 1378</span> </div>
<div class="line"><span class="lineno"> 1379</span>    <span class="keywordflow">if</span> <span class="stringliteral">&quot;l1_ratio&quot;</span> <span class="keywordflow">in</span> path_params:</div>
<div class="line"><span class="lineno"> 1380</span>        path_params[<span class="stringliteral">&quot;l1_ratio&quot;</span>] = l1_ratio</div>
<div class="line"><span class="lineno"> 1381</span> </div>
<div class="line"><span class="lineno"> 1382</span>    <span class="comment"># Do the ordering and type casting here, as if it is done in the path,</span></div>
<div class="line"><span class="lineno"> 1383</span>    <span class="comment"># X is copied and a reference is kept here</span></div>
<div class="line"><span class="lineno"> 1384</span>    X_train = check_array(X_train, accept_sparse=<span class="stringliteral">&quot;csc&quot;</span>, dtype=dtype, order=X_order)</div>
<div class="line"><span class="lineno"> 1385</span>    alphas, coefs, _ = path(X_train, y_train, **path_params)</div>
<div class="line"><span class="lineno"> 1386</span>    del X_train, y_train</div>
<div class="line"><span class="lineno"> 1387</span> </div>
<div class="line"><span class="lineno"> 1388</span>    <span class="keywordflow">if</span> y.ndim == 1:</div>
<div class="line"><span class="lineno"> 1389</span>        <span class="comment"># Doing this so that it becomes coherent with multioutput.</span></div>
<div class="line"><span class="lineno"> 1390</span>        coefs = coefs[np.newaxis, :, :]</div>
<div class="line"><span class="lineno"> 1391</span>        y_offset = np.atleast_1d(y_offset)</div>
<div class="line"><span class="lineno"> 1392</span>        y_test = y_test[:, np.newaxis]</div>
<div class="line"><span class="lineno"> 1393</span> </div>
<div class="line"><span class="lineno"> 1394</span>    intercepts = y_offset[:, np.newaxis] - np.dot(X_offset, coefs)</div>
<div class="line"><span class="lineno"> 1395</span>    X_test_coefs = safe_sparse_dot(X_test, coefs)</div>
<div class="line"><span class="lineno"> 1396</span>    residues = X_test_coefs - y_test[:, :, np.newaxis]</div>
<div class="line"><span class="lineno"> 1397</span>    residues += intercepts</div>
<div class="line"><span class="lineno"> 1398</span>    <span class="keywordflow">if</span> sample_weight <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1399</span>        this_mse = (residues**2).mean(axis=0)</div>
<div class="line"><span class="lineno"> 1400</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1401</span>        this_mse = np.average(residues**2, weights=sw_test, axis=0)</div>
<div class="line"><span class="lineno"> 1402</span> </div>
<div class="line"><span class="lineno"> 1403</span>    <span class="keywordflow">return</span> this_mse.mean(axis=0)</div>
<div class="line"><span class="lineno"> 1404</span> </div>
<div class="line"><span class="lineno"> 1405</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a401cd9902c04b523954361538181394a" name="a401cd9902c04b523954361538181394a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401cd9902c04b523954361538181394a">&#9670;&#160;</a></span>_set_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.linear_model._coordinate_descent._set_order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;C&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Change the order of X and y if necessary.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data.

y : ndarray of shape (n_samples,)
    Target values.

order : {None, 'C', 'F'}
    If 'C', dense arrays are returned as C-ordered, sparse matrices in csr
    format. If 'F', dense arrays are return as F-ordered, sparse matrices
    in csc format.

Returns
-------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data with guaranteed order.

y : ndarray of shape (n_samples,)
    Target values with guaranteed order.
</pre> <div class="fragment"><div class="line"><span class="lineno">   40</span><span class="keyword">def </span>_set_order(X, y, order=&quot;C&quot;):</div>
<div class="line"><span class="lineno">   41</span>    <span class="stringliteral">&quot;&quot;&quot;Change the order of X and y if necessary.</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        Training data.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    y : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        Target values.</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    order : {None, &#39;C&#39;, &#39;F&#39;}</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">        If &#39;C&#39;, dense arrays are returned as C-ordered, sparse matrices in csr</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        format. If &#39;F&#39;, dense arrays are return as F-ordered, sparse matrices</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        in csc format.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        Training data with guaranteed order.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    y : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        Target values with guaranteed order.</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   64</span>    <span class="keywordflow">if</span> order <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="keywordtype">None</span>, <span class="stringliteral">&quot;C&quot;</span>, <span class="stringliteral">&quot;F&quot;</span>]:</div>
<div class="line"><span class="lineno">   65</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">   66</span>            <span class="stringliteral">&quot;Unknown value for order. Got {} instead of None, &#39;C&#39; or &#39;F&#39;.&quot;</span>.format(order)</div>
<div class="line"><span class="lineno">   67</span>        )</div>
<div class="line"><span class="lineno">   68</span>    sparse_X = sparse.issparse(X)</div>
<div class="line"><span class="lineno">   69</span>    sparse_y = sparse.issparse(y)</div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">if</span> order <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   71</span>        sparse_format = <span class="stringliteral">&quot;csc&quot;</span> <span class="keywordflow">if</span> order == <span class="stringliteral">&quot;F&quot;</span> <span class="keywordflow">else</span> <span class="stringliteral">&quot;csr&quot;</span></div>
<div class="line"><span class="lineno">   72</span>        <span class="keywordflow">if</span> sparse_X:</div>
<div class="line"><span class="lineno">   73</span>            X = X.asformat(sparse_format, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">   74</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   75</span>            X = np.asarray(X, order=order)</div>
<div class="line"><span class="lineno">   76</span>        <span class="keywordflow">if</span> sparse_y:</div>
<div class="line"><span class="lineno">   77</span>            y = y.asformat(sparse_format)</div>
<div class="line"><span class="lineno">   78</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   79</span>            y = np.asarray(y, order=order)</div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">return</span> X, y</div>
<div class="line"><span class="lineno">   81</span> </div>
<div class="line"><span class="lineno">   82</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6befd74797b0bd286dcf01b5691975da" name="a6befd74797b0bd286dcf01b5691975da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6befd74797b0bd286dcf01b5691975da">&#9670;&#160;</a></span>enet_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.linear_model._coordinate_descent.enet_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>l1_ratio</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_alphas</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphas</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>precompute</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Xy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy_X</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coef_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_n_iter</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>positive</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_input</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute elastic net path with coordinate descent.

The elastic net optimization function varies for mono and multi-outputs.

For mono-output tasks it is::

    1 / (2 * n_samples) * ||y - Xw||^2_2
    + alpha * l1_ratio * ||w||_1
    + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2

For multi-output tasks it is::

    (1 / (2 * n_samples)) * ||Y - XW||_Fro^2
    + alpha * l1_ratio * ||W||_21
    + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2

Where::

    ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

i.e. the sum of norm of each row.

Read more in the :ref:`User Guide &lt;elastic_net&gt;`.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data. Pass directly as Fortran-contiguous data to avoid
    unnecessary memory duplication. If ``y`` is mono-output then ``X``
    can be sparse.

y : {array-like, sparse matrix} of shape (n_samples,) or \
    (n_samples, n_targets)
    Target values.

l1_ratio : float, default=0.5
    Number between 0 and 1 passed to elastic net (scaling between
    l1 and l2 penalties). ``l1_ratio=1`` corresponds to the Lasso.

eps : float, default=1e-3
    Length of the path. ``eps=1e-3`` means that
    ``alpha_min / alpha_max = 1e-3``.

n_alphas : int, default=100
    Number of alphas along the regularization path.

alphas : ndarray, default=None
    List of alphas where to compute the models.
    If None alphas are set automatically.

precompute : 'auto', bool or array-like of shape \
        (n_features, n_features), default='auto'
    Whether to use a precomputed Gram matrix to speed up
    calculations. If set to ``'auto'`` let us decide. The Gram
    matrix can also be passed as argument.

Xy : array-like of shape (n_features,) or (n_features, n_targets),\
     default=None
    Xy = np.dot(X.T, y) that can be precomputed. It is useful
    only when the Gram matrix is precomputed.

copy_X : bool, default=True
    If ``True``, X will be copied; else, it may be overwritten.

coef_init : ndarray of shape (n_features, ), default=None
    The initial values of the coefficients.

verbose : bool or int, default=False
    Amount of verbosity.

return_n_iter : bool, default=False
    Whether to return the number of iterations or not.

positive : bool, default=False
    If set to True, forces coefficients to be positive.
    (Only allowed when ``y.ndim == 1``).

check_input : bool, default=True
    If set to False, the input validation checks are skipped (including the
    Gram matrix when provided). It is assumed that they are handled
    by the caller.

**params : kwargs
    Keyword arguments passed to the coordinate descent solver.

Returns
-------
alphas : ndarray of shape (n_alphas,)
    The alphas along the path where models are computed.

coefs : ndarray of shape (n_features, n_alphas) or \
        (n_targets, n_features, n_alphas)
    Coefficients along the path.

dual_gaps : ndarray of shape (n_alphas,)
    The dual gaps at the end of the optimization for each alpha.

n_iters : list of int
    The number of iterations taken by the coordinate descent optimizer to
    reach the specified tolerance for each alpha.
    (Is returned when ``return_n_iter`` is set to True).

See Also
--------
MultiTaskElasticNet : Multi-task ElasticNet model trained with L1/L2 mixed-norm \
as regularizer.
MultiTaskElasticNetCV : Multi-task L1/L2 ElasticNet with built-in cross-validation.
ElasticNet : Linear regression with combined L1 and L2 priors as regularizer.
ElasticNetCV : Elastic Net model with iterative fitting along a regularization path.

Notes
-----
For an example, see
:ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py
&lt;sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py&gt;`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  368</span>):</div>
<div class="line"><span class="lineno">  369</span>    <span class="stringliteral">&quot;&quot;&quot;Compute elastic net path with coordinate descent.</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    The elastic net optimization function varies for mono and multi-outputs.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    For mono-output tasks it is::</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        1 / (2 * n_samples) * ||y - Xw||^2_2</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        + alpha * l1_ratio * ||w||_1</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    For multi-output tasks it is::</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        (1 / (2 * n_samples)) * ||Y - XW||_Fro^2</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">        + alpha * l1_ratio * ||W||_21</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    Where::</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    i.e. the sum of norm of each row.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;elastic_net&gt;`.</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">        Training data. Pass directly as Fortran-contiguous data to avoid</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">        unnecessary memory duplication. If ``y`` is mono-output then ``X``</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        can be sparse.</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    y : {array-like, sparse matrix} of shape (n_samples,) or \</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">        (n_samples, n_targets)</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">        Target values.</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    l1_ratio : float, default=0.5</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        Number between 0 and 1 passed to elastic net (scaling between</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">        l1 and l2 penalties). ``l1_ratio=1`` corresponds to the Lasso.</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    eps : float, default=1e-3</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        Length of the path. ``eps=1e-3`` means that</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        ``alpha_min / alpha_max = 1e-3``.</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    n_alphas : int, default=100</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        Number of alphas along the regularization path.</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    alphas : ndarray, default=None</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        List of alphas where to compute the models.</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        If None alphas are set automatically.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    precompute : &#39;auto&#39;, bool or array-like of shape \</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">            (n_features, n_features), default=&#39;auto&#39;</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">        Whether to use a precomputed Gram matrix to speed up</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        calculations. If set to ``&#39;auto&#39;`` let us decide. The Gram</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">        matrix can also be passed as argument.</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    Xy : array-like of shape (n_features,) or (n_features, n_targets),\</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">         default=None</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">        Xy = np.dot(X.T, y) that can be precomputed. It is useful</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">        only when the Gram matrix is precomputed.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    copy_X : bool, default=True</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        If ``True``, X will be copied; else, it may be overwritten.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    coef_init : ndarray of shape (n_features, ), default=None</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        The initial values of the coefficients.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    verbose : bool or int, default=False</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">        Amount of verbosity.</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    return_n_iter : bool, default=False</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        Whether to return the number of iterations or not.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    positive : bool, default=False</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        If set to True, forces coefficients to be positive.</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        (Only allowed when ``y.ndim == 1``).</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    check_input : bool, default=True</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        If set to False, the input validation checks are skipped (including the</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        Gram matrix when provided). It is assumed that they are handled</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        by the caller.</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    **params : kwargs</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        Keyword arguments passed to the coordinate descent solver.</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    alphas : ndarray of shape (n_alphas,)</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">        The alphas along the path where models are computed.</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    coefs : ndarray of shape (n_features, n_alphas) or \</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">            (n_targets, n_features, n_alphas)</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">        Coefficients along the path.</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    dual_gaps : ndarray of shape (n_alphas,)</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        The dual gaps at the end of the optimization for each alpha.</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    n_iters : list of int</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        The number of iterations taken by the coordinate descent optimizer to</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        reach the specified tolerance for each alpha.</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        (Is returned when ``return_n_iter`` is set to True).</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    MultiTaskElasticNet : Multi-task ElasticNet model trained with L1/L2 mixed-norm \</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    as regularizer.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    MultiTaskElasticNetCV : Multi-task L1/L2 ElasticNet with built-in cross-validation.</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    ElasticNet : Linear regression with combined L1 and L2 priors as regularizer.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    ElasticNetCV : Elastic Net model with iterative fitting along a regularization path.</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    For an example, see</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    :ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    &lt;sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py&gt;`.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  485</span>    X_offset_param = params.pop(<span class="stringliteral">&quot;X_offset&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  486</span>    X_scale_param = params.pop(<span class="stringliteral">&quot;X_scale&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  487</span>    sample_weight = params.pop(<span class="stringliteral">&quot;sample_weight&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  488</span>    tol = params.pop(<span class="stringliteral">&quot;tol&quot;</span>, 1e-4)</div>
<div class="line"><span class="lineno">  489</span>    max_iter = params.pop(<span class="stringliteral">&quot;max_iter&quot;</span>, 1000)</div>
<div class="line"><span class="lineno">  490</span>    random_state = params.pop(<span class="stringliteral">&quot;random_state&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  491</span>    selection = params.pop(<span class="stringliteral">&quot;selection&quot;</span>, <span class="stringliteral">&quot;cyclic&quot;</span>)</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>    <span class="keywordflow">if</span> len(params) &gt; 0:</div>
<div class="line"><span class="lineno">  494</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unexpected parameters in params&quot;</span>, params.keys())</div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span>    <span class="comment"># We expect X and y to be already Fortran ordered when bypassing</span></div>
<div class="line"><span class="lineno">  497</span>    <span class="comment"># checks</span></div>
<div class="line"><span class="lineno">  498</span>    <span class="keywordflow">if</span> check_input:</div>
<div class="line"><span class="lineno">  499</span>        X = check_array(</div>
<div class="line"><span class="lineno">  500</span>            X,</div>
<div class="line"><span class="lineno">  501</span>            accept_sparse=<span class="stringliteral">&quot;csc&quot;</span>,</div>
<div class="line"><span class="lineno">  502</span>            dtype=[np.float64, np.float32],</div>
<div class="line"><span class="lineno">  503</span>            order=<span class="stringliteral">&quot;F&quot;</span>,</div>
<div class="line"><span class="lineno">  504</span>            copy=copy_X,</div>
<div class="line"><span class="lineno">  505</span>        )</div>
<div class="line"><span class="lineno">  506</span>        y = check_array(</div>
<div class="line"><span class="lineno">  507</span>            y,</div>
<div class="line"><span class="lineno">  508</span>            accept_sparse=<span class="stringliteral">&quot;csc&quot;</span>,</div>
<div class="line"><span class="lineno">  509</span>            dtype=X.dtype.type,</div>
<div class="line"><span class="lineno">  510</span>            order=<span class="stringliteral">&quot;F&quot;</span>,</div>
<div class="line"><span class="lineno">  511</span>            copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  512</span>            ensure_2d=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  513</span>        )</div>
<div class="line"><span class="lineno">  514</span>        <span class="keywordflow">if</span> Xy <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  515</span>            <span class="comment"># Xy should be a 1d contiguous array or a 2D C ordered array</span></div>
<div class="line"><span class="lineno">  516</span>            Xy = check_array(</div>
<div class="line"><span class="lineno">  517</span>                Xy, dtype=X.dtype.type, order=<span class="stringliteral">&quot;C&quot;</span>, copy=<span class="keyword">False</span>, ensure_2d=<span class="keyword">False</span></div>
<div class="line"><span class="lineno">  518</span>            )</div>
<div class="line"><span class="lineno">  519</span> </div>
<div class="line"><span class="lineno">  520</span>    n_samples, n_features = X.shape</div>
<div class="line"><span class="lineno">  521</span> </div>
<div class="line"><span class="lineno">  522</span>    multi_output = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  523</span>    <span class="keywordflow">if</span> y.ndim != 1:</div>
<div class="line"><span class="lineno">  524</span>        multi_output = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  525</span>        n_targets = y.shape[1]</div>
<div class="line"><span class="lineno">  526</span> </div>
<div class="line"><span class="lineno">  527</span>    <span class="keywordflow">if</span> multi_output <span class="keywordflow">and</span> positive:</div>
<div class="line"><span class="lineno">  528</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;positive=True is not allowed for multi-output (y.ndim != 1)&quot;</span>)</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span>    <span class="comment"># MultiTaskElasticNet does not support sparse matrices</span></div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> multi_output <span class="keywordflow">and</span> sparse.isspmatrix(X):</div>
<div class="line"><span class="lineno">  532</span>        <span class="keywordflow">if</span> X_offset_param <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  533</span>            <span class="comment"># As sparse matrices are not actually centered we need this to be passed to</span></div>
<div class="line"><span class="lineno">  534</span>            <span class="comment"># the CD solver.</span></div>
<div class="line"><span class="lineno">  535</span>            X_sparse_scaling = X_offset_param / X_scale_param</div>
<div class="line"><span class="lineno">  536</span>            X_sparse_scaling = np.asarray(X_sparse_scaling, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  537</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  538</span>            X_sparse_scaling = np.zeros(n_features, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>    <span class="comment"># X should have been passed through _pre_fit already if function is called</span></div>
<div class="line"><span class="lineno">  541</span>    <span class="comment"># from ElasticNet.fit</span></div>
<div class="line"><span class="lineno">  542</span>    <span class="keywordflow">if</span> check_input:</div>
<div class="line"><span class="lineno">  543</span>        X, y, _, _, _, precompute, Xy = _pre_fit(</div>
<div class="line"><span class="lineno">  544</span>            X,</div>
<div class="line"><span class="lineno">  545</span>            y,</div>
<div class="line"><span class="lineno">  546</span>            Xy,</div>
<div class="line"><span class="lineno">  547</span>            precompute,</div>
<div class="line"><span class="lineno">  548</span>            normalize=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  549</span>            fit_intercept=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  550</span>            copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  551</span>            check_input=check_input,</div>
<div class="line"><span class="lineno">  552</span>        )</div>
<div class="line"><span class="lineno">  553</span>    <span class="keywordflow">if</span> alphas <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  554</span>        <span class="comment"># No need to normalize of fit_intercept: it has been done</span></div>
<div class="line"><span class="lineno">  555</span>        <span class="comment"># above</span></div>
<div class="line"><span class="lineno">  556</span>        alphas = _alpha_grid(</div>
<div class="line"><span class="lineno">  557</span>            X,</div>
<div class="line"><span class="lineno">  558</span>            y,</div>
<div class="line"><span class="lineno">  559</span>            Xy=Xy,</div>
<div class="line"><span class="lineno">  560</span>            l1_ratio=l1_ratio,</div>
<div class="line"><span class="lineno">  561</span>            fit_intercept=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  562</span>            eps=eps,</div>
<div class="line"><span class="lineno">  563</span>            n_alphas=n_alphas,</div>
<div class="line"><span class="lineno">  564</span>            copy_X=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  565</span>        )</div>
<div class="line"><span class="lineno">  566</span>    <span class="keywordflow">elif</span> len(alphas) &gt; 1:</div>
<div class="line"><span class="lineno">  567</span>        alphas = np.sort(alphas)[::-1]  <span class="comment"># make sure alphas are properly ordered</span></div>
<div class="line"><span class="lineno">  568</span> </div>
<div class="line"><span class="lineno">  569</span>    n_alphas = len(alphas)</div>
<div class="line"><span class="lineno">  570</span>    dual_gaps = np.empty(n_alphas)</div>
<div class="line"><span class="lineno">  571</span>    n_iters = []</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span>    rng = check_random_state(random_state)</div>
<div class="line"><span class="lineno">  574</span>    <span class="keywordflow">if</span> selection <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;random&quot;</span>, <span class="stringliteral">&quot;cyclic&quot;</span>]:</div>
<div class="line"><span class="lineno">  575</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;selection should be either random or cyclic.&quot;</span>)</div>
<div class="line"><span class="lineno">  576</span>    random = selection == <span class="stringliteral">&quot;random&quot;</span></div>
<div class="line"><span class="lineno">  577</span> </div>
<div class="line"><span class="lineno">  578</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> multi_output:</div>
<div class="line"><span class="lineno">  579</span>        coefs = np.empty((n_features, n_alphas), dtype=X.dtype)</div>
<div class="line"><span class="lineno">  580</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  581</span>        coefs = np.empty((n_targets, n_features, n_alphas), dtype=X.dtype)</div>
<div class="line"><span class="lineno">  582</span> </div>
<div class="line"><span class="lineno">  583</span>    <span class="keywordflow">if</span> coef_init <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  584</span>        coef_ = np.zeros(coefs.shape[:-1], dtype=X.dtype, order=<span class="stringliteral">&quot;F&quot;</span>)</div>
<div class="line"><span class="lineno">  585</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  586</span>        coef_ = np.asfortranarray(coef_init, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  587</span> </div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">for</span> i, alpha <span class="keywordflow">in</span> enumerate(alphas):</div>
<div class="line"><span class="lineno">  589</span>        <span class="comment"># account for n_samples scaling in objectives between here and cd_fast</span></div>
<div class="line"><span class="lineno">  590</span>        l1_reg = alpha * l1_ratio * n_samples</div>
<div class="line"><span class="lineno">  591</span>        l2_reg = alpha * (1.0 - l1_ratio) * n_samples</div>
<div class="line"><span class="lineno">  592</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> multi_output <span class="keywordflow">and</span> sparse.isspmatrix(X):</div>
<div class="line"><span class="lineno">  593</span>            model = cd_fast.sparse_enet_coordinate_descent(</div>
<div class="line"><span class="lineno">  594</span>                w=coef_,</div>
<div class="line"><span class="lineno">  595</span>                alpha=l1_reg,</div>
<div class="line"><span class="lineno">  596</span>                beta=l2_reg,</div>
<div class="line"><span class="lineno">  597</span>                X_data=ReadonlyArrayWrapper(</div>
<div class="line"><span class="lineno">  598</span>                    X.data</div>
<div class="line"><span class="lineno">  599</span>                ),  <span class="comment"># TODO: Remove after release of Cython 3 (#23147)</span></div>
<div class="line"><span class="lineno">  600</span>                X_indices=X.indices,</div>
<div class="line"><span class="lineno">  601</span>                X_indptr=X.indptr,</div>
<div class="line"><span class="lineno">  602</span>                y=y,</div>
<div class="line"><span class="lineno">  603</span>                sample_weight=sample_weight,</div>
<div class="line"><span class="lineno">  604</span>                X_mean=X_sparse_scaling,</div>
<div class="line"><span class="lineno">  605</span>                max_iter=max_iter,</div>
<div class="line"><span class="lineno">  606</span>                tol=tol,</div>
<div class="line"><span class="lineno">  607</span>                rng=rng,</div>
<div class="line"><span class="lineno">  608</span>                random=random,</div>
<div class="line"><span class="lineno">  609</span>                positive=positive,</div>
<div class="line"><span class="lineno">  610</span>            )</div>
<div class="line"><span class="lineno">  611</span>        <span class="keywordflow">elif</span> multi_output:</div>
<div class="line"><span class="lineno">  612</span>            model = cd_fast.enet_coordinate_descent_multi_task(</div>
<div class="line"><span class="lineno">  613</span>                coef_, l1_reg, l2_reg, X, y, max_iter, tol, rng, random</div>
<div class="line"><span class="lineno">  614</span>            )</div>
<div class="line"><span class="lineno">  615</span>        <span class="keywordflow">elif</span> isinstance(precompute, np.ndarray):</div>
<div class="line"><span class="lineno">  616</span>            <span class="comment"># We expect precompute to be already Fortran ordered when bypassing</span></div>
<div class="line"><span class="lineno">  617</span>            <span class="comment"># checks</span></div>
<div class="line"><span class="lineno">  618</span>            <span class="keywordflow">if</span> check_input:</div>
<div class="line"><span class="lineno">  619</span>                precompute = check_array(precompute, dtype=X.dtype.type, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  620</span>            model = cd_fast.enet_coordinate_descent_gram(</div>
<div class="line"><span class="lineno">  621</span>                coef_,</div>
<div class="line"><span class="lineno">  622</span>                l1_reg,</div>
<div class="line"><span class="lineno">  623</span>                l2_reg,</div>
<div class="line"><span class="lineno">  624</span>                precompute,</div>
<div class="line"><span class="lineno">  625</span>                Xy,</div>
<div class="line"><span class="lineno">  626</span>                y,</div>
<div class="line"><span class="lineno">  627</span>                max_iter,</div>
<div class="line"><span class="lineno">  628</span>                tol,</div>
<div class="line"><span class="lineno">  629</span>                rng,</div>
<div class="line"><span class="lineno">  630</span>                random,</div>
<div class="line"><span class="lineno">  631</span>                positive,</div>
<div class="line"><span class="lineno">  632</span>            )</div>
<div class="line"><span class="lineno">  633</span>        <span class="keywordflow">elif</span> precompute <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno">  634</span>            model = cd_fast.enet_coordinate_descent(</div>
<div class="line"><span class="lineno">  635</span>                coef_, l1_reg, l2_reg, X, y, max_iter, tol, rng, random, positive</div>
<div class="line"><span class="lineno">  636</span>            )</div>
<div class="line"><span class="lineno">  637</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  638</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  639</span>                <span class="stringliteral">&quot;Precompute should be one of True, False, &#39;auto&#39; or array-like. Got %r&quot;</span></div>
<div class="line"><span class="lineno">  640</span>                % precompute</div>
<div class="line"><span class="lineno">  641</span>            )</div>
<div class="line"><span class="lineno">  642</span>        coef_, dual_gap_, eps_, n_iter_ = model</div>
<div class="line"><span class="lineno">  643</span>        coefs[..., i] = coef_</div>
<div class="line"><span class="lineno">  644</span>        <span class="comment"># we correct the scale of the returned dual gap, as the objective</span></div>
<div class="line"><span class="lineno">  645</span>        <span class="comment"># in cd_fast is n_samples * the objective in this docstring.</span></div>
<div class="line"><span class="lineno">  646</span>        dual_gaps[i] = dual_gap_ / n_samples</div>
<div class="line"><span class="lineno">  647</span>        n_iters.append(n_iter_)</div>
<div class="line"><span class="lineno">  648</span> </div>
<div class="line"><span class="lineno">  649</span>        <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  650</span>            <span class="keywordflow">if</span> verbose &gt; 2:</div>
<div class="line"><span class="lineno">  651</span>                print(model)</div>
<div class="line"><span class="lineno">  652</span>            <span class="keywordflow">elif</span> verbose &gt; 1:</div>
<div class="line"><span class="lineno">  653</span>                print(<span class="stringliteral">&quot;Path: %03i out of %03i&quot;</span> % (i, n_alphas))</div>
<div class="line"><span class="lineno">  654</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  655</span>                sys.stderr.write(<span class="stringliteral">&quot;.&quot;</span>)</div>
<div class="line"><span class="lineno">  656</span> </div>
<div class="line"><span class="lineno">  657</span>    <span class="keywordflow">if</span> return_n_iter:</div>
<div class="line"><span class="lineno">  658</span>        <span class="keywordflow">return</span> alphas, coefs, dual_gaps, n_iters</div>
<div class="line"><span class="lineno">  659</span>    <span class="keywordflow">return</span> alphas, coefs, dual_gaps</div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6480c334129d04e98ffe6707ce92a076" name="a6480c334129d04e98ffe6707ce92a076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6480c334129d04e98ffe6707ce92a076">&#9670;&#160;</a></span>lasso_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.linear_model._coordinate_descent.lasso_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_alphas</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphas</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>precompute</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Xy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy_X</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coef_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_n_iter</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>positive</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute Lasso path with coordinate descent.

The Lasso optimization function varies for mono and multi-outputs.

For mono-output tasks it is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

For multi-output tasks it is::

    (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21

Where::

    ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

i.e. the sum of norm of each row.

Read more in the :ref:`User Guide &lt;lasso&gt;`.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data. Pass directly as Fortran-contiguous data to avoid
    unnecessary memory duplication. If ``y`` is mono-output then ``X``
    can be sparse.

y : {array-like, sparse matrix} of shape (n_samples,) or \
    (n_samples, n_targets)
    Target values.

eps : float, default=1e-3
    Length of the path. ``eps=1e-3`` means that
    ``alpha_min / alpha_max = 1e-3``.

n_alphas : int, default=100
    Number of alphas along the regularization path.

alphas : ndarray, default=None
    List of alphas where to compute the models.
    If ``None`` alphas are set automatically.

precompute : 'auto', bool or array-like of shape \
        (n_features, n_features), default='auto'
    Whether to use a precomputed Gram matrix to speed up
    calculations. If set to ``'auto'`` let us decide. The Gram
    matrix can also be passed as argument.

Xy : array-like of shape (n_features,) or (n_features, n_targets),\
     default=None
    Xy = np.dot(X.T, y) that can be precomputed. It is useful
    only when the Gram matrix is precomputed.

copy_X : bool, default=True
    If ``True``, X will be copied; else, it may be overwritten.

coef_init : ndarray of shape (n_features, ), default=None
    The initial values of the coefficients.

verbose : bool or int, default=False
    Amount of verbosity.

return_n_iter : bool, default=False
    Whether to return the number of iterations or not.

positive : bool, default=False
    If set to True, forces coefficients to be positive.
    (Only allowed when ``y.ndim == 1``).

**params : kwargs
    Keyword arguments passed to the coordinate descent solver.

Returns
-------
alphas : ndarray of shape (n_alphas,)
    The alphas along the path where models are computed.

coefs : ndarray of shape (n_features, n_alphas) or \
        (n_targets, n_features, n_alphas)
    Coefficients along the path.

dual_gaps : ndarray of shape (n_alphas,)
    The dual gaps at the end of the optimization for each alpha.

n_iters : list of int
    The number of iterations taken by the coordinate descent optimizer to
    reach the specified tolerance for each alpha.

See Also
--------
lars_path : Compute Least Angle Regression or Lasso path using LARS
    algorithm.
Lasso : The Lasso is a linear model that estimates sparse coefficients.
LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars.
LassoCV : Lasso linear model with iterative fitting along a regularization
    path.
LassoLarsCV : Cross-validated Lasso using the LARS algorithm.
sklearn.decomposition.sparse_encode : Estimator that can be used to
    transform signals into sparse linear combination of atoms from a fixed.

Notes
-----
For an example, see
:ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py
&lt;sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py&gt;`.

To avoid unnecessary memory duplication the X argument of the fit method
should be directly passed as a Fortran-contiguous numpy array.

Note that in certain cases, the Lars solver may be significantly
faster to implement this functionality. In particular, linear
interpolation can be used to retrieve model coefficients between the
values output by lars_path

Examples
--------

Comparing lasso_path and lars_path with interpolation:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.linear_model import lasso_path
&gt;&gt;&gt; X = np.array([[1, 2, 3.1], [2.3, 5.4, 4.3]]).T
&gt;&gt;&gt; y = np.array([1, 2, 3.1])
&gt;&gt;&gt; # Use lasso_path to compute a coefficient path
&gt;&gt;&gt; _, coef_path, _ = lasso_path(X, y, alphas=[5., 1., .5])
&gt;&gt;&gt; print(coef_path)
[[0.         0.         0.46874778]
 [0.2159048  0.4425765  0.23689075]]

&gt;&gt;&gt; # Now use lars_path and 1D linear interpolation to compute the
&gt;&gt;&gt; # same path
&gt;&gt;&gt; from sklearn.linear_model import lars_path
&gt;&gt;&gt; alphas, active, coef_path_lars = lars_path(X, y, method='lasso')
&gt;&gt;&gt; from scipy import interpolate
&gt;&gt;&gt; coef_path_continuous = interpolate.interp1d(alphas[::-1],
...                                             coef_path_lars[:, ::-1])
&gt;&gt;&gt; print(coef_path_continuous([5., 1., .5]))
[[0.         0.         0.46915237]
 [0.2159048  0.4425765  0.23668876]]
</pre> <div class="fragment"><div class="line"><span class="lineno">  192</span>):</div>
<div class="line"><span class="lineno">  193</span>    <span class="stringliteral">&quot;&quot;&quot;Compute Lasso path with coordinate descent.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    The Lasso optimization function varies for mono and multi-outputs.</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    For mono-output tasks it is::</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">        (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    For multi-output tasks it is::</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    Where::</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    i.e. the sum of norm of each row.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;lasso&gt;`.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        Training data. Pass directly as Fortran-contiguous data to avoid</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        unnecessary memory duplication. If ``y`` is mono-output then ``X``</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        can be sparse.</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    y : {array-like, sparse matrix} of shape (n_samples,) or \</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">        (n_samples, n_targets)</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        Target values.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    eps : float, default=1e-3</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">        Length of the path. ``eps=1e-3`` means that</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        ``alpha_min / alpha_max = 1e-3``.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    n_alphas : int, default=100</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        Number of alphas along the regularization path.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    alphas : ndarray, default=None</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        List of alphas where to compute the models.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        If ``None`` alphas are set automatically.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    precompute : &#39;auto&#39;, bool or array-like of shape \</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">            (n_features, n_features), default=&#39;auto&#39;</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        Whether to use a precomputed Gram matrix to speed up</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        calculations. If set to ``&#39;auto&#39;`` let us decide. The Gram</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        matrix can also be passed as argument.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    Xy : array-like of shape (n_features,) or (n_features, n_targets),\</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">         default=None</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">        Xy = np.dot(X.T, y) that can be precomputed. It is useful</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        only when the Gram matrix is precomputed.</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    copy_X : bool, default=True</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        If ``True``, X will be copied; else, it may be overwritten.</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    coef_init : ndarray of shape (n_features, ), default=None</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">        The initial values of the coefficients.</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    verbose : bool or int, default=False</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        Amount of verbosity.</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    return_n_iter : bool, default=False</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        Whether to return the number of iterations or not.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    positive : bool, default=False</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        If set to True, forces coefficients to be positive.</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        (Only allowed when ``y.ndim == 1``).</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    **params : kwargs</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">        Keyword arguments passed to the coordinate descent solver.</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    alphas : ndarray of shape (n_alphas,)</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        The alphas along the path where models are computed.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    coefs : ndarray of shape (n_features, n_alphas) or \</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">            (n_targets, n_features, n_alphas)</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        Coefficients along the path.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    dual_gaps : ndarray of shape (n_alphas,)</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        The dual gaps at the end of the optimization for each alpha.</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    n_iters : list of int</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        The number of iterations taken by the coordinate descent optimizer to</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        reach the specified tolerance for each alpha.</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    lars_path : Compute Least Angle Regression or Lasso path using LARS</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        algorithm.</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    Lasso : The Lasso is a linear model that estimates sparse coefficients.</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    LassoCV : Lasso linear model with iterative fitting along a regularization</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        path.</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    LassoLarsCV : Cross-validated Lasso using the LARS algorithm.</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    sklearn.decomposition.sparse_encode : Estimator that can be used to</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        transform signals into sparse linear combination of atoms from a fixed.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    For an example, see</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    :ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    &lt;sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py&gt;`.</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    To avoid unnecessary memory duplication the X argument of the fit method</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    should be directly passed as a Fortran-contiguous numpy array.</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    Note that in certain cases, the Lars solver may be significantly</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    faster to implement this functionality. In particular, linear</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    interpolation can be used to retrieve model coefficients between the</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    values output by lars_path</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    Comparing lasso_path and lars_path with interpolation:</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.linear_model import lasso_path</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    &gt;&gt;&gt; X = np.array([[1, 2, 3.1], [2.3, 5.4, 4.3]]).T</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([1, 2, 3.1])</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    &gt;&gt;&gt; # Use lasso_path to compute a coefficient path</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    &gt;&gt;&gt; _, coef_path, _ = lasso_path(X, y, alphas=[5., 1., .5])</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    &gt;&gt;&gt; print(coef_path)</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    [[0.         0.         0.46874778]</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">     [0.2159048  0.4425765  0.23689075]]</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    &gt;&gt;&gt; # Now use lars_path and 1D linear interpolation to compute the</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    &gt;&gt;&gt; # same path</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.linear_model import lars_path</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    &gt;&gt;&gt; alphas, active, coef_path_lars = lars_path(X, y, method=&#39;lasso&#39;)</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import interpolate</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    &gt;&gt;&gt; coef_path_continuous = interpolate.interp1d(alphas[::-1],</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    ...                                             coef_path_lars[:, ::-1])</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    &gt;&gt;&gt; print(coef_path_continuous([5., 1., .5]))</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    [[0.         0.         0.46915237]</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">     [0.2159048  0.4425765  0.23668876]]</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  333</span>    <span class="keywordflow">return</span> enet_path(</div>
<div class="line"><span class="lineno">  334</span>        X,</div>
<div class="line"><span class="lineno">  335</span>        y,</div>
<div class="line"><span class="lineno">  336</span>        l1_ratio=1.0,</div>
<div class="line"><span class="lineno">  337</span>        eps=eps,</div>
<div class="line"><span class="lineno">  338</span>        n_alphas=n_alphas,</div>
<div class="line"><span class="lineno">  339</span>        alphas=alphas,</div>
<div class="line"><span class="lineno">  340</span>        precompute=precompute,</div>
<div class="line"><span class="lineno">  341</span>        Xy=Xy,</div>
<div class="line"><span class="lineno">  342</span>        copy_X=copy_X,</div>
<div class="line"><span class="lineno">  343</span>        coef_init=coef_init,</div>
<div class="line"><span class="lineno">  344</span>        verbose=verbose,</div>
<div class="line"><span class="lineno">  345</span>        positive=positive,</div>
<div class="line"><span class="lineno">  346</span>        return_n_iter=return_n_iter,</div>
<div class="line"><span class="lineno">  347</span>        **params,</div>
<div class="line"><span class="lineno">  348</span>    )</div>
<div class="line"><span class="lineno">  349</span> </div>
<div class="line"><span class="lineno">  350</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
