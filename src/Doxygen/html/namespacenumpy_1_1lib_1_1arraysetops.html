<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.arraysetops Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html">arraysetops</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.arraysetops Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a423224b76cf0745627a6d384d0b83356" id="r_a423224b76cf0745627a6d384d0b83356"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a423224b76cf0745627a6d384d0b83356">_ediff1d_dispatcher</a> (ary, to_end=None, to_begin=None)</td></tr>
<tr class="separator:a423224b76cf0745627a6d384d0b83356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4b297fff00959584b440ba6b2f41f4" id="r_a5a4b297fff00959584b440ba6b2f41f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a5a4b297fff00959584b440ba6b2f41f4">ediff1d</a> (ary, to_end=None, to_begin=None)</td></tr>
<tr class="separator:a5a4b297fff00959584b440ba6b2f41f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c5f42e0227bdceae77e29b7fd6a454" id="r_a66c5f42e0227bdceae77e29b7fd6a454"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a66c5f42e0227bdceae77e29b7fd6a454">_unpack_tuple</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:a66c5f42e0227bdceae77e29b7fd6a454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f00dbdf9e2c17b7ac89948e83e20082" id="r_a9f00dbdf9e2c17b7ac89948e83e20082"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a9f00dbdf9e2c17b7ac89948e83e20082">_unique_dispatcher</a> (ar, return_index=None, return_inverse=None, return_counts=None, axis=None, *equal_nan=None)</td></tr>
<tr class="separator:a9f00dbdf9e2c17b7ac89948e83e20082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4fe206d153a493f182b0afd9fca95d" id="r_add4fe206d153a493f182b0afd9fca95d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#add4fe206d153a493f182b0afd9fca95d">unique</a> (ar, return_index=False, return_inverse=False, return_counts=False, axis=None, *equal_nan=True)</td></tr>
<tr class="separator:add4fe206d153a493f182b0afd9fca95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ba2da10371b52906479e5254810ada" id="r_a24ba2da10371b52906479e5254810ada"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a24ba2da10371b52906479e5254810ada">_unique1d</a> (ar, return_index=False, return_inverse=False, return_counts=False, *equal_nan=True)</td></tr>
<tr class="separator:a24ba2da10371b52906479e5254810ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f3983bccae5763db53e4278903c81f" id="r_a96f3983bccae5763db53e4278903c81f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a96f3983bccae5763db53e4278903c81f">_intersect1d_dispatcher</a> (ar1, ar2, assume_unique=None, return_indices=None)</td></tr>
<tr class="separator:a96f3983bccae5763db53e4278903c81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf888d0107d01e180e3671bafd09d3f0" id="r_aaf888d0107d01e180e3671bafd09d3f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#aaf888d0107d01e180e3671bafd09d3f0">intersect1d</a> (ar1, ar2, assume_unique=False, return_indices=False)</td></tr>
<tr class="separator:aaf888d0107d01e180e3671bafd09d3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09428d2d8acef9ad237764e885d0a150" id="r_a09428d2d8acef9ad237764e885d0a150"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a09428d2d8acef9ad237764e885d0a150">_setxor1d_dispatcher</a> (ar1, ar2, assume_unique=None)</td></tr>
<tr class="separator:a09428d2d8acef9ad237764e885d0a150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58ba81f8f210c61f3d3de715281a33b" id="r_af58ba81f8f210c61f3d3de715281a33b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#af58ba81f8f210c61f3d3de715281a33b">setxor1d</a> (ar1, ar2, assume_unique=False)</td></tr>
<tr class="separator:af58ba81f8f210c61f3d3de715281a33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8313c441e60e8fa616a0a6e7ebc0aec1" id="r_a8313c441e60e8fa616a0a6e7ebc0aec1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a8313c441e60e8fa616a0a6e7ebc0aec1">_in1d_dispatcher</a> (ar1, ar2, assume_unique=None, invert=None, *kind=None)</td></tr>
<tr class="separator:a8313c441e60e8fa616a0a6e7ebc0aec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72219d26023281d611734ae483b1d4f" id="r_ae72219d26023281d611734ae483b1d4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#ae72219d26023281d611734ae483b1d4f">in1d</a> (ar1, ar2, assume_unique=False, invert=False, *kind=None)</td></tr>
<tr class="separator:ae72219d26023281d611734ae483b1d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa3eddbf3e0a8aee883155b49ec179c" id="r_a6fa3eddbf3e0a8aee883155b49ec179c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a6fa3eddbf3e0a8aee883155b49ec179c">_isin_dispatcher</a> (element, test_elements, assume_unique=None, invert=None, *kind=None)</td></tr>
<tr class="separator:a6fa3eddbf3e0a8aee883155b49ec179c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eca5e64fc496a00903f06a4573834f" id="r_a20eca5e64fc496a00903f06a4573834f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a20eca5e64fc496a00903f06a4573834f">isin</a> (element, test_elements, assume_unique=False, invert=False, *kind=None)</td></tr>
<tr class="separator:a20eca5e64fc496a00903f06a4573834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acc69012cad10e844f5ae3220c40105" id="r_a2acc69012cad10e844f5ae3220c40105"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a2acc69012cad10e844f5ae3220c40105">_union1d_dispatcher</a> (ar1, ar2)</td></tr>
<tr class="separator:a2acc69012cad10e844f5ae3220c40105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6ba8d6a374302588ed4bc029616bda" id="r_a4c6ba8d6a374302588ed4bc029616bda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a4c6ba8d6a374302588ed4bc029616bda">union1d</a> (ar1, ar2)</td></tr>
<tr class="separator:a4c6ba8d6a374302588ed4bc029616bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767ff1b9dcacd40e6da737fd88a5dc12" id="r_a767ff1b9dcacd40e6da737fd88a5dc12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#a767ff1b9dcacd40e6da737fd88a5dc12">_setdiff1d_dispatcher</a> (ar1, ar2, assume_unique=None)</td></tr>
<tr class="separator:a767ff1b9dcacd40e6da737fd88a5dc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada493fdbed91a81184fb11172da54f9f" id="r_ada493fdbed91a81184fb11172da54f9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#ada493fdbed91a81184fb11172da54f9f">setdiff1d</a> (ar1, ar2, assume_unique=False)</td></tr>
<tr class="separator:ada493fdbed91a81184fb11172da54f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad2ed5d82dfe2e7bee05263ba295c5d8a" id="r_ad2ed5d82dfe2e7bee05263ba295c5d8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraysetops.html#ad2ed5d82dfe2e7bee05263ba295c5d8a">array_function_dispatch</a></td></tr>
<tr class="separator:ad2ed5d82dfe2e7bee05263ba295c5d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Set operations for arrays based on sorting.

Notes
-----

For floating point arrays, inaccurate results may appear due to usual round-off
and floating point comparison issues.

Speed could be gained in some operations by an implementation of
`numpy.sort`, that can provide directly the permutation vectors, thus avoiding
calls to `numpy.argsort`.

Original author: Robert Cimrman</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a423224b76cf0745627a6d384d0b83356" name="a423224b76cf0745627a6d384d0b83356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423224b76cf0745627a6d384d0b83356">&#9670;&#160;</a></span>_ediff1d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._ediff1d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_begin</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   33</span><span class="keyword">def </span>_ediff1d_dispatcher(ary, to_end=None, to_begin=None):</div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">return</span> (ary, to_end, to_begin)</div>
<div class="line"><span class="lineno">   35</span> </div>
<div class="line"><span class="lineno">   36</span> </div>
<div class="line"><span class="lineno">   37</span><span class="preprocessor">@array_function_dispatch(_ediff1d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8313c441e60e8fa616a0a6e7ebc0aec1" name="a8313c441e60e8fa616a0a6e7ebc0aec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8313c441e60e8fa616a0a6e7ebc0aec1">&#9670;&#160;</a></span>_in1d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._in1d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invert</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  520</span>                     kind=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  521</span>    <span class="keywordflow">return</span> (ar1, ar2)</div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span> </div>
<div class="line"><span class="lineno">  524</span><span class="preprocessor">@array_function_dispatch(_in1d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a96f3983bccae5763db53e4278903c81f" name="a96f3983bccae5763db53e4278903c81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f3983bccae5763db53e4278903c81f">&#9670;&#160;</a></span>_intersect1d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._intersect1d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_indices</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  369</span>        ar1, ar2, assume_unique=<span class="keywordtype">None</span>, return_indices=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  370</span>    <span class="keywordflow">return</span> (ar1, ar2)</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span> </div>
<div class="line"><span class="lineno">  373</span><span class="preprocessor">@array_function_dispatch(_intersect1d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6fa3eddbf3e0a8aee883155b49ec179c" name="a6fa3eddbf3e0a8aee883155b49ec179c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa3eddbf3e0a8aee883155b49ec179c">&#9670;&#160;</a></span>_isin_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._isin_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>test_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invert</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  762</span>                     *, kind=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">return</span> (element, test_elements)</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span> </div>
<div class="line"><span class="lineno">  766</span><span class="preprocessor">@array_function_dispatch(_isin_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a767ff1b9dcacd40e6da737fd88a5dc12" name="a767ff1b9dcacd40e6da737fd88a5dc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767ff1b9dcacd40e6da737fd88a5dc12">&#9670;&#160;</a></span>_setdiff1d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._setdiff1d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  935</span><span class="keyword">def </span>_setdiff1d_dispatcher(ar1, ar2, assume_unique=None):</div>
<div class="line"><span class="lineno">  936</span>    <span class="keywordflow">return</span> (ar1, ar2)</div>
<div class="line"><span class="lineno">  937</span> </div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span><span class="preprocessor">@array_function_dispatch(_setdiff1d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a09428d2d8acef9ad237764e885d0a150" name="a09428d2d8acef9ad237764e885d0a150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09428d2d8acef9ad237764e885d0a150">&#9670;&#160;</a></span>_setxor1d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._setxor1d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  472</span><span class="keyword">def </span>_setxor1d_dispatcher(ar1, ar2, assume_unique=None):</div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordflow">return</span> (ar1, ar2)</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span> </div>
<div class="line"><span class="lineno">  476</span><span class="preprocessor">@array_function_dispatch(_setxor1d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2acc69012cad10e844f5ae3220c40105" name="a2acc69012cad10e844f5ae3220c40105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acc69012cad10e844f5ae3220c40105">&#9670;&#160;</a></span>_union1d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._union1d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  894</span><span class="keyword">def </span>_union1d_dispatcher(ar1, ar2):</div>
<div class="line"><span class="lineno">  895</span>    <span class="keywordflow">return</span> (ar1, ar2)</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span> </div>
<div class="line"><span class="lineno">  898</span><span class="preprocessor">@array_function_dispatch(_union1d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a24ba2da10371b52906479e5254810ada" name="a24ba2da10371b52906479e5254810ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ba2da10371b52906479e5254810ada">&#9670;&#160;</a></span>_unique1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._unique1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_index</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_inverse</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_counts</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>equal_nan</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Find the unique elements of an array, ignoring shape.
</pre> <div class="fragment"><div class="line"><span class="lineno">  324</span>              return_counts=<span class="keyword">False</span>, *, equal_nan=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  325</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    Find the unique elements of an array, ignoring shape.</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  328</span>    ar = np.asanyarray(ar).flatten()</div>
<div class="line"><span class="lineno">  329</span> </div>
<div class="line"><span class="lineno">  330</span>    optional_indices = return_index <span class="keywordflow">or</span> return_inverse</div>
<div class="line"><span class="lineno">  331</span> </div>
<div class="line"><span class="lineno">  332</span>    <span class="keywordflow">if</span> optional_indices:</div>
<div class="line"><span class="lineno">  333</span>        perm = ar.argsort(kind=<span class="stringliteral">&#39;mergesort&#39;</span> <span class="keywordflow">if</span> return_index <span class="keywordflow">else</span> <span class="stringliteral">&#39;quicksort&#39;</span>)</div>
<div class="line"><span class="lineno">  334</span>        aux = ar[perm]</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  336</span>        ar.sort()</div>
<div class="line"><span class="lineno">  337</span>        aux = ar</div>
<div class="line"><span class="lineno">  338</span>    mask = np.empty(aux.shape, dtype=np.bool_)</div>
<div class="line"><span class="lineno">  339</span>    mask[:1] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordflow">if</span> (equal_nan <span class="keywordflow">and</span> aux.shape[0] &gt; 0 <span class="keywordflow">and</span> aux.dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&quot;cfmM&quot;</span> <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  341</span>            np.isnan(aux[-1])):</div>
<div class="line"><span class="lineno">  342</span>        <span class="keywordflow">if</span> aux.dtype.kind == <span class="stringliteral">&quot;c&quot;</span>:  <span class="comment"># for complex all NaNs are considered equivalent</span></div>
<div class="line"><span class="lineno">  343</span>            aux_firstnan = np.searchsorted(np.isnan(aux), <span class="keyword">True</span>, side=<span class="stringliteral">&#39;left&#39;</span>)</div>
<div class="line"><span class="lineno">  344</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  345</span>            aux_firstnan = np.searchsorted(aux, aux[-1], side=<span class="stringliteral">&#39;left&#39;</span>)</div>
<div class="line"><span class="lineno">  346</span>        <span class="keywordflow">if</span> aux_firstnan &gt; 0:</div>
<div class="line"><span class="lineno">  347</span>            mask[1:aux_firstnan] = (</div>
<div class="line"><span class="lineno">  348</span>                aux[1:aux_firstnan] != aux[:aux_firstnan - 1])</div>
<div class="line"><span class="lineno">  349</span>        mask[aux_firstnan] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  350</span>        mask[aux_firstnan + 1:] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  351</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  352</span>        mask[1:] = aux[1:] != aux[:-1]</div>
<div class="line"><span class="lineno">  353</span> </div>
<div class="line"><span class="lineno">  354</span>    ret = (aux[mask],)</div>
<div class="line"><span class="lineno">  355</span>    <span class="keywordflow">if</span> return_index:</div>
<div class="line"><span class="lineno">  356</span>        ret += (perm[mask],)</div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">if</span> return_inverse:</div>
<div class="line"><span class="lineno">  358</span>        imask = np.cumsum(mask) - 1</div>
<div class="line"><span class="lineno">  359</span>        inv_idx = np.empty(mask.shape, dtype=np.intp)</div>
<div class="line"><span class="lineno">  360</span>        inv_idx[perm] = imask</div>
<div class="line"><span class="lineno">  361</span>        ret += (inv_idx,)</div>
<div class="line"><span class="lineno">  362</span>    <span class="keywordflow">if</span> return_counts:</div>
<div class="line"><span class="lineno">  363</span>        idx = np.concatenate(np.nonzero(mask) + ([mask.size],))</div>
<div class="line"><span class="lineno">  364</span>        ret += (np.diff(idx),)</div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f00dbdf9e2c17b7ac89948e83e20082" name="a9f00dbdf9e2c17b7ac89948e83e20082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f00dbdf9e2c17b7ac89948e83e20082">&#9670;&#160;</a></span>_unique_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._unique_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_index</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_inverse</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_counts</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>equal_nan</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  134</span>                       return_counts=<span class="keywordtype">None</span>, axis=<span class="keywordtype">None</span>, *, equal_nan=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  135</span>    <span class="keywordflow">return</span> (ar,)</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span><span class="preprocessor">@array_function_dispatch(_unique_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a66c5f42e0227bdceae77e29b7fd6a454" name="a66c5f42e0227bdceae77e29b7fd6a454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c5f42e0227bdceae77e29b7fd6a454">&#9670;&#160;</a></span>_unpack_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops._unpack_tuple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Unpacks one-element tuples for use as return values </pre> <div class="fragment"><div class="line"><span class="lineno">  125</span><span class="keyword">def </span>_unpack_tuple(x):</div>
<div class="line"><span class="lineno">  126</span>    <span class="stringliteral">&quot;&quot;&quot; Unpacks one-element tuples for use as return values &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">if</span> len(x) == 1:</div>
<div class="line"><span class="lineno">  128</span>        <span class="keywordflow">return</span> x[0]</div>
<div class="line"><span class="lineno">  129</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  130</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a4b297fff00959584b440ba6b2f41f4" name="a5a4b297fff00959584b440ba6b2f41f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4b297fff00959584b440ba6b2f41f4">&#9670;&#160;</a></span>ediff1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.ediff1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_begin</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The differences between consecutive elements of an array.

Parameters
----------
ary : array_like
    If necessary, will be flattened before the differences are taken.
to_end : array_like, optional
    Number(s) to append at the end of the returned differences.
to_begin : array_like, optional
    Number(s) to prepend at the beginning of the returned differences.

Returns
-------
ediff1d : ndarray
    The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.

See Also
--------
diff, gradient

Notes
-----
When applied to masked arrays, this function drops the mask information
if the `to_begin` and/or `to_end` parameters are used.

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])
&gt;&gt;&gt; np.ediff1d(x)
array([ 1,  2,  3, -7])

&gt;&gt;&gt; np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
array([-99,   1,   2, ...,  -7,  88,  99])

The returned array is always 1D.

&gt;&gt;&gt; y = [[1, 2, 4], [1, 6, 24]]
&gt;&gt;&gt; np.ediff1d(y)
array([ 1,  2, -3,  5, 18])</pre> <div class="fragment"><div class="line"><span class="lineno">   38</span><span class="keyword">def </span>ediff1d(ary, to_end=None, to_begin=None):</div>
<div class="line"><span class="lineno">   39</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    The differences between consecutive elements of an array.</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    ary : array_like</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        If necessary, will be flattened before the differences are taken.</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    to_end : array_like, optional</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">        Number(s) to append at the end of the returned differences.</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    to_begin : array_like, optional</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        Number(s) to prepend at the beginning of the returned differences.</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    ediff1d : ndarray</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    diff, gradient</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    When applied to masked arrays, this function drops the mask information</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    if the `to_begin` and/or `to_end` parameters are used.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    &gt;&gt;&gt; np.ediff1d(x)</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    array([ 1,  2,  3, -7])</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    &gt;&gt;&gt; np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    array([-99,   1,   2, ...,  -7,  88,  99])</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    The returned array is always 1D.</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    &gt;&gt;&gt; y = [[1, 2, 4], [1, 6, 24]]</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    &gt;&gt;&gt; np.ediff1d(y)</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    array([ 1,  2, -3,  5, 18])</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   81</span>    <span class="comment"># force a 1d array</span></div>
<div class="line"><span class="lineno">   82</span>    ary = np.asanyarray(ary).ravel()</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>    <span class="comment"># enforce that the dtype of `ary` is used for the output</span></div>
<div class="line"><span class="lineno">   85</span>    dtype_req = ary.dtype</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>    <span class="comment"># fast track default case</span></div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordflow">if</span> to_begin <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> to_end <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   89</span>        <span class="keywordflow">return</span> ary[1:] - ary[:-1]</div>
<div class="line"><span class="lineno">   90</span> </div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">if</span> to_begin <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   92</span>        l_begin = 0</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   94</span>        to_begin = np.asanyarray(to_begin)</div>
<div class="line"><span class="lineno">   95</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.can_cast(to_begin, dtype_req, casting=<span class="stringliteral">&quot;same_kind&quot;</span>):</div>
<div class="line"><span class="lineno">   96</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;dtype of `to_begin` must be compatible &quot;</span></div>
<div class="line"><span class="lineno">   97</span>                            <span class="stringliteral">&quot;with input `ary` under the `same_kind` rule.&quot;</span>)</div>
<div class="line"><span class="lineno">   98</span> </div>
<div class="line"><span class="lineno">   99</span>        to_begin = to_begin.ravel()</div>
<div class="line"><span class="lineno">  100</span>        l_begin = len(to_begin)</div>
<div class="line"><span class="lineno">  101</span> </div>
<div class="line"><span class="lineno">  102</span>    <span class="keywordflow">if</span> to_end <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  103</span>        l_end = 0</div>
<div class="line"><span class="lineno">  104</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  105</span>        to_end = np.asanyarray(to_end)</div>
<div class="line"><span class="lineno">  106</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.can_cast(to_end, dtype_req, casting=<span class="stringliteral">&quot;same_kind&quot;</span>):</div>
<div class="line"><span class="lineno">  107</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;dtype of `to_end` must be compatible &quot;</span></div>
<div class="line"><span class="lineno">  108</span>                            <span class="stringliteral">&quot;with input `ary` under the `same_kind` rule.&quot;</span>)</div>
<div class="line"><span class="lineno">  109</span> </div>
<div class="line"><span class="lineno">  110</span>        to_end = to_end.ravel()</div>
<div class="line"><span class="lineno">  111</span>        l_end = len(to_end)</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>    <span class="comment"># do the calculation in place and copy to_begin and to_end</span></div>
<div class="line"><span class="lineno">  114</span>    l_diff = max(len(ary) - 1, 0)</div>
<div class="line"><span class="lineno">  115</span>    result = np.empty(l_diff + l_begin + l_end, dtype=ary.dtype)</div>
<div class="line"><span class="lineno">  116</span>    result = ary.__array_wrap__(result)</div>
<div class="line"><span class="lineno">  117</span>    <span class="keywordflow">if</span> l_begin &gt; 0:</div>
<div class="line"><span class="lineno">  118</span>        result[:l_begin] = to_begin</div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">if</span> l_end &gt; 0:</div>
<div class="line"><span class="lineno">  120</span>        result[l_begin + l_diff:] = to_end</div>
<div class="line"><span class="lineno">  121</span>    np.subtract(ary[1:], ary[:-1], result[l_begin:l_begin + l_diff])</div>
<div class="line"><span class="lineno">  122</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  123</span> </div>
<div class="line"><span class="lineno">  124</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae72219d26023281d611734ae483b1d4f" name="ae72219d26023281d611734ae483b1d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72219d26023281d611734ae483b1d4f">&#9670;&#160;</a></span>in1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.in1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invert</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether each element of a 1-D array is also present in a second array.

Returns a boolean array the same length as `ar1` that is True
where an element of `ar1` is in `ar2` and False otherwise.

We recommend using :func:`isin` instead of `in1d` for new code.

Parameters
----------
ar1 : (M,) array_like
    Input array.
ar2 : array_like
    The values against which to test each value of `ar1`.
assume_unique : bool, optional
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
invert : bool, optional
    If True, the values in the returned array are inverted (that is,
    False where an element of `ar1` is in `ar2` and True otherwise).
    Default is False. ``np.in1d(a, b, invert=True)`` is equivalent
    to (but is faster than) ``np.invert(in1d(a, b))``.
kind : {None, 'sort', 'table'}, optional
    The algorithm to use. This will not affect the final result,
    but will affect the speed and memory use. The default, None,
    will select automatically based on memory considerations.

    * If 'sort', will use a mergesort-based approach. This will have
      a memory usage of roughly 6 times the sum of the sizes of
      `ar1` and `ar2`, not accounting for size of dtypes.
    * If 'table', will use a lookup table approach similar
      to a counting sort. This is only available for boolean and
      integer arrays. This will have a memory usage of the
      size of `ar1` plus the max-min value of `ar2`. `assume_unique`
      has no effect when the 'table' option is used.
    * If None, will automatically choose 'table' if
      the required memory allocation is less than or equal to
      6 times the sum of the sizes of `ar1` and `ar2`,
      otherwise will use 'sort'. This is done to not use
      a large amount of memory by default, even though
      'table' may be faster in most cases. If 'table' is chosen,
      `assume_unique` will have no effect.

    .. versionadded:: 1.8.0

Returns
-------
in1d : (M,) ndarray, bool
    The values `ar1[in1d]` are in `ar2`.

See Also
--------
isin                  : Version of this function that preserves the
                        shape of ar1.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----
`in1d` can be considered as an element-wise function version of the
python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly
equivalent to ``np.array([item in b for item in a])``.
However, this idea fails if `ar2` is a set, or similar (non-sequence)
container:  As ``ar2`` is converted to an array, in those cases
``asarray(ar2)`` is an object array rather than the expected array of
contained values.

Using ``kind='table'`` tends to be faster than `kind='sort'` if the
following relationship is true:
``log10(len(ar2)) &gt; (log10(max(ar2)-min(ar2)) - 2.27) / 0.927``,
but may use greater memory. The default value for `kind` will
be automatically selected based only on memory usage, so one may
manually set ``kind='table'`` if memory constraints can be relaxed.

.. versionadded:: 1.4.0

Examples
--------
&gt;&gt;&gt; test = np.array([0, 1, 2, 5, 0])
&gt;&gt;&gt; states = [0, 2]
&gt;&gt;&gt; mask = np.in1d(test, states)
&gt;&gt;&gt; mask
array([ True, False,  True, False,  True])
&gt;&gt;&gt; test[mask]
array([0, 2, 0])
&gt;&gt;&gt; mask = np.in1d(test, states, invert=True)
&gt;&gt;&gt; mask
array([False,  True, False,  True, False])
&gt;&gt;&gt; test[mask]
array([1, 5])
</pre> <div class="fragment"><div class="line"><span class="lineno">  525</span><span class="keyword">def </span>in1d(ar1, ar2, assume_unique=False, invert=False, *, kind=None):</div>
<div class="line"><span class="lineno">  526</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    Test whether each element of a 1-D array is also present in a second array.</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    Returns a boolean array the same length as `ar1` that is True</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    where an element of `ar1` is in `ar2` and False otherwise.</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    We recommend using :func:`isin` instead of `in1d` for new code.</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    ar1 : (M,) array_like</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    ar2 : array_like</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">        The values against which to test each value of `ar1`.</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    assume_unique : bool, optional</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        If True, the input arrays are both assumed to be unique, which</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        can speed up the calculation.  Default is False.</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    invert : bool, optional</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        If True, the values in the returned array are inverted (that is,</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        False where an element of `ar1` is in `ar2` and True otherwise).</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        Default is False. ``np.in1d(a, b, invert=True)`` is equivalent</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">        to (but is faster than) ``np.invert(in1d(a, b))``.</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    kind : {None, &#39;sort&#39;, &#39;table&#39;}, optional</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        The algorithm to use. This will not affect the final result,</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        but will affect the speed and memory use. The default, None,</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        will select automatically based on memory considerations.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        * If &#39;sort&#39;, will use a mergesort-based approach. This will have</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">          a memory usage of roughly 6 times the sum of the sizes of</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">          `ar1` and `ar2`, not accounting for size of dtypes.</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">        * If &#39;table&#39;, will use a lookup table approach similar</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">          to a counting sort. This is only available for boolean and</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">          integer arrays. This will have a memory usage of the</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">          size of `ar1` plus the max-min value of `ar2`. `assume_unique`</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">          has no effect when the &#39;table&#39; option is used.</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">        * If None, will automatically choose &#39;table&#39; if</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">          the required memory allocation is less than or equal to</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">          6 times the sum of the sizes of `ar1` and `ar2`,</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">          otherwise will use &#39;sort&#39;. This is done to not use</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">          a large amount of memory by default, even though</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">          &#39;table&#39; may be faster in most cases. If &#39;table&#39; is chosen,</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">          `assume_unique` will have no effect.</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    in1d : (M,) ndarray, bool</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        The values `ar1[in1d]` are in `ar2`.</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    isin                  : Version of this function that preserves the</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">                            shape of ar1.</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    numpy.lib.arraysetops : Module with a number of other functions for</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">                            performing set operations on arrays.</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    `in1d` can be considered as an element-wise function version of the</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    equivalent to ``np.array([item in b for item in a])``.</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    However, this idea fails if `ar2` is a set, or similar (non-sequence)</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    container:  As ``ar2`` is converted to an array, in those cases</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    ``asarray(ar2)`` is an object array rather than the expected array of</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    contained values.</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    Using ``kind=&#39;table&#39;`` tends to be faster than `kind=&#39;sort&#39;` if the</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    following relationship is true:</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    ``log10(len(ar2)) &gt; (log10(max(ar2)-min(ar2)) - 2.27) / 0.927``,</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    but may use greater memory. The default value for `kind` will</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    be automatically selected based only on memory usage, so one may</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    manually set ``kind=&#39;table&#39;`` if memory constraints can be relaxed.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    &gt;&gt;&gt; test = np.array([0, 1, 2, 5, 0])</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    &gt;&gt;&gt; states = [0, 2]</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    &gt;&gt;&gt; mask = np.in1d(test, states)</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    &gt;&gt;&gt; mask</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    array([ True, False,  True, False,  True])</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    &gt;&gt;&gt; test[mask]</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    array([0, 2, 0])</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    &gt;&gt;&gt; mask = np.in1d(test, states, invert=True)</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    &gt;&gt;&gt; mask</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    array([False,  True, False,  True, False])</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    &gt;&gt;&gt; test[mask]</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    array([1, 5])</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  617</span>    <span class="comment"># Ravel both arrays, behavior for the first array could be different</span></div>
<div class="line"><span class="lineno">  618</span>    ar1 = np.asarray(ar1).ravel()</div>
<div class="line"><span class="lineno">  619</span>    ar2 = np.asarray(ar2).ravel()</div>
<div class="line"><span class="lineno">  620</span> </div>
<div class="line"><span class="lineno">  621</span>    <span class="comment"># Ensure that iteration through object arrays yields size-1 arrays</span></div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordflow">if</span> ar2.dtype == object:</div>
<div class="line"><span class="lineno">  623</span>        ar2 = ar2.reshape(-1, 1)</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span>    <span class="keywordflow">if</span> kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="keywordtype">None</span>, <span class="stringliteral">&#39;sort&#39;</span>, <span class="stringliteral">&#39;table&#39;</span>}:</div>
<div class="line"><span class="lineno">  626</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  627</span>            f<span class="stringliteral">&quot;Invalid kind: &#39;{kind}&#39;. Please use None, &#39;sort&#39; or &#39;table&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="line"><span class="lineno">  629</span>    <span class="comment"># Can use the table method if all arrays are integers or boolean:</span></div>
<div class="line"><span class="lineno">  630</span>    is_int_arrays = all(ar.dtype.kind <span class="keywordflow">in</span> (<span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>) <span class="keywordflow">for</span> ar <span class="keywordflow">in</span> (ar1, ar2))</div>
<div class="line"><span class="lineno">  631</span>    use_table_method = is_int_arrays <span class="keywordflow">and</span> kind <span class="keywordflow">in</span> {<span class="keywordtype">None</span>, <span class="stringliteral">&#39;table&#39;</span>}</div>
<div class="line"><span class="lineno">  632</span> </div>
<div class="line"><span class="lineno">  633</span>    <span class="keywordflow">if</span> use_table_method:</div>
<div class="line"><span class="lineno">  634</span>        <span class="keywordflow">if</span> ar2.size == 0:</div>
<div class="line"><span class="lineno">  635</span>            <span class="keywordflow">if</span> invert:</div>
<div class="line"><span class="lineno">  636</span>                <span class="keywordflow">return</span> np.ones_like(ar1, dtype=bool)</div>
<div class="line"><span class="lineno">  637</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  638</span>                <span class="keywordflow">return</span> np.zeros_like(ar1, dtype=bool)</div>
<div class="line"><span class="lineno">  639</span> </div>
<div class="line"><span class="lineno">  640</span>        <span class="comment"># Convert booleans to uint8 so we can use the fast integer algorithm</span></div>
<div class="line"><span class="lineno">  641</span>        <span class="keywordflow">if</span> ar1.dtype == bool:</div>
<div class="line"><span class="lineno">  642</span>            ar1 = ar1.astype(np.uint8)</div>
<div class="line"><span class="lineno">  643</span>        <span class="keywordflow">if</span> ar2.dtype == bool:</div>
<div class="line"><span class="lineno">  644</span>            ar2 = ar2.astype(np.uint8)</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>        ar2_min = np.min(ar2)</div>
<div class="line"><span class="lineno">  647</span>        ar2_max = np.max(ar2)</div>
<div class="line"><span class="lineno">  648</span> </div>
<div class="line"><span class="lineno">  649</span>        ar2_range = int(ar2_max) - int(ar2_min)</div>
<div class="line"><span class="lineno">  650</span> </div>
<div class="line"><span class="lineno">  651</span>        <span class="comment"># Constraints on whether we can actually use the table method:</span></div>
<div class="line"><span class="lineno">  652</span>        <span class="comment">#  1. Assert memory usage is not too large</span></div>
<div class="line"><span class="lineno">  653</span>        below_memory_constraint = ar2_range &lt;= 6 * (ar1.size + ar2.size)</div>
<div class="line"><span class="lineno">  654</span>        <span class="comment">#  2. Check overflows for (ar2 - ar2_min); dtype=ar2.dtype</span></div>
<div class="line"><span class="lineno">  655</span>        range_safe_from_overflow = ar2_range &lt;= np.iinfo(ar2.dtype).max</div>
<div class="line"><span class="lineno">  656</span>        <span class="comment">#  3. Check overflows for (ar1 - ar2_min); dtype=ar1.dtype</span></div>
<div class="line"><span class="lineno">  657</span>        <span class="keywordflow">if</span> ar1.size &gt; 0:</div>
<div class="line"><span class="lineno">  658</span>            ar1_min = np.min(ar1)</div>
<div class="line"><span class="lineno">  659</span>            ar1_max = np.max(ar1)</div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span>            <span class="comment"># After masking, the range of ar1 is guaranteed to be</span></div>
<div class="line"><span class="lineno">  662</span>            <span class="comment"># within the range of ar2:</span></div>
<div class="line"><span class="lineno">  663</span>            ar1_upper = min(int(ar1_max), int(ar2_max))</div>
<div class="line"><span class="lineno">  664</span>            ar1_lower = max(int(ar1_min), int(ar2_min))</div>
<div class="line"><span class="lineno">  665</span> </div>
<div class="line"><span class="lineno">  666</span>            range_safe_from_overflow &amp;= all((</div>
<div class="line"><span class="lineno">  667</span>                ar1_upper - int(ar2_min) &lt;= np.iinfo(ar1.dtype).max,</div>
<div class="line"><span class="lineno">  668</span>                ar1_lower - int(ar2_min) &gt;= np.iinfo(ar1.dtype).min</div>
<div class="line"><span class="lineno">  669</span>            ))</div>
<div class="line"><span class="lineno">  670</span> </div>
<div class="line"><span class="lineno">  671</span>        <span class="comment"># Optimal performance is for approximately</span></div>
<div class="line"><span class="lineno">  672</span>        <span class="comment"># log10(size) &gt; (log10(range) - 2.27) / 0.927.</span></div>
<div class="line"><span class="lineno">  673</span>        <span class="comment"># However, here we set the requirement that by default</span></div>
<div class="line"><span class="lineno">  674</span>        <span class="comment"># the intermediate array can only be 6x</span></div>
<div class="line"><span class="lineno">  675</span>        <span class="comment"># the combined memory allocation of the original</span></div>
<div class="line"><span class="lineno">  676</span>        <span class="comment"># arrays. See discussion on </span></div>
<div class="line"><span class="lineno">  677</span>        <span class="comment"># https://github.com/numpy/numpy/pull/12065.</span></div>
<div class="line"><span class="lineno">  678</span> </div>
<div class="line"><span class="lineno">  679</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  680</span>            range_safe_from_overflow <span class="keywordflow">and</span> </div>
<div class="line"><span class="lineno">  681</span>            (below_memory_constraint <span class="keywordflow">or</span> kind == <span class="stringliteral">&#39;table&#39;</span>)</div>
<div class="line"><span class="lineno">  682</span>        ):</div>
<div class="line"><span class="lineno">  683</span> </div>
<div class="line"><span class="lineno">  684</span>            <span class="keywordflow">if</span> invert:</div>
<div class="line"><span class="lineno">  685</span>                outgoing_array = np.ones_like(ar1, dtype=bool)</div>
<div class="line"><span class="lineno">  686</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  687</span>                outgoing_array = np.zeros_like(ar1, dtype=bool)</div>
<div class="line"><span class="lineno">  688</span> </div>
<div class="line"><span class="lineno">  689</span>            <span class="comment"># Make elements 1 where the integer exists in ar2</span></div>
<div class="line"><span class="lineno">  690</span>            <span class="keywordflow">if</span> invert:</div>
<div class="line"><span class="lineno">  691</span>                isin_helper_ar = np.ones(ar2_range + 1, dtype=bool)</div>
<div class="line"><span class="lineno">  692</span>                isin_helper_ar[ar2 - ar2_min] = 0</div>
<div class="line"><span class="lineno">  693</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  694</span>                isin_helper_ar = np.zeros(ar2_range + 1, dtype=bool)</div>
<div class="line"><span class="lineno">  695</span>                isin_helper_ar[ar2 - ar2_min] = 1</div>
<div class="line"><span class="lineno">  696</span> </div>
<div class="line"><span class="lineno">  697</span>            <span class="comment"># Mask out elements we know won&#39;t work</span></div>
<div class="line"><span class="lineno">  698</span>            basic_mask = (ar1 &lt;= ar2_max) &amp; (ar1 &gt;= ar2_min)</div>
<div class="line"><span class="lineno">  699</span>            outgoing_array[basic_mask] = isin_helper_ar[ar1[basic_mask] -</div>
<div class="line"><span class="lineno">  700</span>                                                        ar2_min]</div>
<div class="line"><span class="lineno">  701</span> </div>
<div class="line"><span class="lineno">  702</span>            <span class="keywordflow">return</span> outgoing_array</div>
<div class="line"><span class="lineno">  703</span>        <span class="keywordflow">elif</span> kind == <span class="stringliteral">&#39;table&#39;</span>:  <span class="comment"># not range_safe_from_overflow</span></div>
<div class="line"><span class="lineno">  704</span>            <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno">  705</span>                <span class="stringliteral">&quot;You have specified kind=&#39;table&#39;, &quot;</span></div>
<div class="line"><span class="lineno">  706</span>                <span class="stringliteral">&quot;but the range of values in `ar2` or `ar1` exceed the &quot;</span></div>
<div class="line"><span class="lineno">  707</span>                <span class="stringliteral">&quot;maximum integer of the datatype. &quot;</span></div>
<div class="line"><span class="lineno">  708</span>                <span class="stringliteral">&quot;Please set `kind` to None or &#39;sort&#39;.&quot;</span></div>
<div class="line"><span class="lineno">  709</span>            )</div>
<div class="line"><span class="lineno">  710</span>    <span class="keywordflow">elif</span> kind == <span class="stringliteral">&#39;table&#39;</span>:</div>
<div class="line"><span class="lineno">  711</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  712</span>            <span class="stringliteral">&quot;The &#39;table&#39; method is only &quot;</span></div>
<div class="line"><span class="lineno">  713</span>            <span class="stringliteral">&quot;supported for boolean or integer arrays. &quot;</span></div>
<div class="line"><span class="lineno">  714</span>            <span class="stringliteral">&quot;Please select &#39;sort&#39; or None for kind.&quot;</span></div>
<div class="line"><span class="lineno">  715</span>        )</div>
<div class="line"><span class="lineno">  716</span> </div>
<div class="line"><span class="lineno">  717</span> </div>
<div class="line"><span class="lineno">  718</span>    <span class="comment"># Check if one of the arrays may contain arbitrary objects</span></div>
<div class="line"><span class="lineno">  719</span>    contains_object = ar1.dtype.hasobject <span class="keywordflow">or</span> ar2.dtype.hasobject</div>
<div class="line"><span class="lineno">  720</span> </div>
<div class="line"><span class="lineno">  721</span>    <span class="comment"># This code is run when</span></div>
<div class="line"><span class="lineno">  722</span>    <span class="comment"># a) the first condition is true, making the code significantly faster</span></div>
<div class="line"><span class="lineno">  723</span>    <span class="comment"># b) the second condition is true (i.e. `ar1` or `ar2` may contain</span></div>
<div class="line"><span class="lineno">  724</span>    <span class="comment">#    arbitrary objects), since then sorting is not guaranteed to work</span></div>
<div class="line"><span class="lineno">  725</span>    <span class="keywordflow">if</span> len(ar2) &lt; 10 * len(ar1) ** 0.145 <span class="keywordflow">or</span> contains_object:</div>
<div class="line"><span class="lineno">  726</span>        <span class="keywordflow">if</span> invert:</div>
<div class="line"><span class="lineno">  727</span>            mask = np.ones(len(ar1), dtype=bool)</div>
<div class="line"><span class="lineno">  728</span>            <span class="keywordflow">for</span> a <span class="keywordflow">in</span> ar2:</div>
<div class="line"><span class="lineno">  729</span>                mask &amp;= (ar1 != a)</div>
<div class="line"><span class="lineno">  730</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  731</span>            mask = np.zeros(len(ar1), dtype=bool)</div>
<div class="line"><span class="lineno">  732</span>            <span class="keywordflow">for</span> a <span class="keywordflow">in</span> ar2:</div>
<div class="line"><span class="lineno">  733</span>                mask |= (ar1 == a)</div>
<div class="line"><span class="lineno">  734</span>        <span class="keywordflow">return</span> mask</div>
<div class="line"><span class="lineno">  735</span> </div>
<div class="line"><span class="lineno">  736</span>    <span class="comment"># Otherwise use sorting</span></div>
<div class="line"><span class="lineno">  737</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> assume_unique:</div>
<div class="line"><span class="lineno">  738</span>        ar1, rev_idx = np.unique(ar1, return_inverse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  739</span>        ar2 = np.unique(ar2)</div>
<div class="line"><span class="lineno">  740</span> </div>
<div class="line"><span class="lineno">  741</span>    ar = np.concatenate((ar1, ar2))</div>
<div class="line"><span class="lineno">  742</span>    <span class="comment"># We need this to be a stable sort, so always use &#39;mergesort&#39;</span></div>
<div class="line"><span class="lineno">  743</span>    <span class="comment"># here. The values from the first array should always come before</span></div>
<div class="line"><span class="lineno">  744</span>    <span class="comment"># the values from the second array.</span></div>
<div class="line"><span class="lineno">  745</span>    order = ar.argsort(kind=<span class="stringliteral">&#39;mergesort&#39;</span>)</div>
<div class="line"><span class="lineno">  746</span>    sar = ar[order]</div>
<div class="line"><span class="lineno">  747</span>    <span class="keywordflow">if</span> invert:</div>
<div class="line"><span class="lineno">  748</span>        bool_ar = (sar[1:] != sar[:-1])</div>
<div class="line"><span class="lineno">  749</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  750</span>        bool_ar = (sar[1:] == sar[:-1])</div>
<div class="line"><span class="lineno">  751</span>    flag = np.concatenate((bool_ar, [invert]))</div>
<div class="line"><span class="lineno">  752</span>    ret = np.empty(ar.shape, dtype=bool)</div>
<div class="line"><span class="lineno">  753</span>    ret[order] = flag</div>
<div class="line"><span class="lineno">  754</span> </div>
<div class="line"><span class="lineno">  755</span>    <span class="keywordflow">if</span> assume_unique:</div>
<div class="line"><span class="lineno">  756</span>        <span class="keywordflow">return</span> ret[:len(ar1)]</div>
<div class="line"><span class="lineno">  757</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  758</span>        <span class="keywordflow">return</span> ret[rev_idx]</div>
<div class="line"><span class="lineno">  759</span> </div>
<div class="line"><span class="lineno">  760</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf888d0107d01e180e3671bafd09d3f0" name="aaf888d0107d01e180e3671bafd09d3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf888d0107d01e180e3671bafd09d3f0">&#9670;&#160;</a></span>intersect1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.intersect1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_indices</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the intersection of two arrays.

Return the sorted, unique values that are in both of the input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays. Will be flattened if not already 1D.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  If True but ``ar1`` or ``ar2`` are not
    unique, incorrect results and out-of-bounds indices could result.
    Default is False.
return_indices : bool
    If True, the indices which correspond to the intersection of the two
    arrays are returned. The first instance of a value is used if there are
    multiple. Default is False.

    .. versionadded:: 1.15.0

Returns
-------
intersect1d : ndarray
    Sorted 1D array of common and unique elements.
comm1 : ndarray
    The indices of the first occurrences of the common values in `ar1`.
    Only provided if `return_indices` is True.
comm2 : ndarray
    The indices of the first occurrences of the common values in `ar2`.
    Only provided if `return_indices` is True.


See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
array([1, 3])

To intersect more than two arrays, use functools.reduce:

&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([3])

To return the indices of the values common to the input arrays
along with the intersected values:

&gt;&gt;&gt; x = np.array([1, 1, 2, 3, 4])
&gt;&gt;&gt; y = np.array([2, 1, 4, 6])
&gt;&gt;&gt; xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
&gt;&gt;&gt; x_ind, y_ind
(array([0, 2, 4]), array([1, 0, 2]))
&gt;&gt;&gt; xy, x[x_ind], y[y_ind]
(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))</pre> <div class="fragment"><div class="line"><span class="lineno">  374</span><span class="keyword">def </span>intersect1d(ar1, ar2, assume_unique=False, return_indices=False):</div>
<div class="line"><span class="lineno">  375</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    Find the intersection of two arrays.</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    Return the sorted, unique values that are in both of the input arrays.</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    ar1, ar2 : array_like</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        Input arrays. Will be flattened if not already 1D.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    assume_unique : bool</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">        If True, the input arrays are both assumed to be unique, which</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">        can speed up the calculation.  If True but ``ar1`` or ``ar2`` are not</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        unique, incorrect results and out-of-bounds indices could result.</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        Default is False.</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    return_indices : bool</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">        If True, the indices which correspond to the intersection of the two</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        arrays are returned. The first instance of a value is used if there are</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">        multiple. Default is False.</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">        .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    intersect1d : ndarray</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        Sorted 1D array of common and unique elements.</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    comm1 : ndarray</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">        The indices of the first occurrences of the common values in `ar1`.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">        Only provided if `return_indices` is True.</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    comm2 : ndarray</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">        The indices of the first occurrences of the common values in `ar2`.</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        Only provided if `return_indices` is True.</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    numpy.lib.arraysetops : Module with a number of other functions for</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">                            performing set operations on arrays.</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    &gt;&gt;&gt; np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    array([1, 3])</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    To intersect more than two arrays, use functools.reduce:</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    &gt;&gt;&gt; from functools import reduce</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    &gt;&gt;&gt; reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    array([3])</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    To return the indices of the values common to the input arrays</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    along with the intersected values:</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([2, 1, 4, 6])</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    &gt;&gt;&gt; xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    &gt;&gt;&gt; x_ind, y_ind</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    (array([0, 2, 4]), array([1, 0, 2]))</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    &gt;&gt;&gt; xy, x[x_ind], y[y_ind]</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    (array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  436</span>    ar1 = np.asanyarray(ar1)</div>
<div class="line"><span class="lineno">  437</span>    ar2 = np.asanyarray(ar2)</div>
<div class="line"><span class="lineno">  438</span> </div>
<div class="line"><span class="lineno">  439</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> assume_unique:</div>
<div class="line"><span class="lineno">  440</span>        <span class="keywordflow">if</span> return_indices:</div>
<div class="line"><span class="lineno">  441</span>            ar1, ind1 = unique(ar1, return_index=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  442</span>            ar2, ind2 = unique(ar2, return_index=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  443</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  444</span>            ar1 = unique(ar1)</div>
<div class="line"><span class="lineno">  445</span>            ar2 = unique(ar2)</div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  447</span>        ar1 = ar1.ravel()</div>
<div class="line"><span class="lineno">  448</span>        ar2 = ar2.ravel()</div>
<div class="line"><span class="lineno">  449</span> </div>
<div class="line"><span class="lineno">  450</span>    aux = np.concatenate((ar1, ar2))</div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">if</span> return_indices:</div>
<div class="line"><span class="lineno">  452</span>        aux_sort_indices = np.argsort(aux, kind=<span class="stringliteral">&#39;mergesort&#39;</span>)</div>
<div class="line"><span class="lineno">  453</span>        aux = aux[aux_sort_indices]</div>
<div class="line"><span class="lineno">  454</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  455</span>        aux.sort()</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    mask = aux[1:] == aux[:-1]</div>
<div class="line"><span class="lineno">  458</span>    int1d = aux[:-1][mask]</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">if</span> return_indices:</div>
<div class="line"><span class="lineno">  461</span>        ar1_indices = aux_sort_indices[:-1][mask]</div>
<div class="line"><span class="lineno">  462</span>        ar2_indices = aux_sort_indices[1:][mask] - ar1.size</div>
<div class="line"><span class="lineno">  463</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> assume_unique:</div>
<div class="line"><span class="lineno">  464</span>            ar1_indices = ind1[ar1_indices]</div>
<div class="line"><span class="lineno">  465</span>            ar2_indices = ind2[ar2_indices]</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span>        <span class="keywordflow">return</span> int1d, ar1_indices, ar2_indices</div>
<div class="line"><span class="lineno">  468</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  469</span>        <span class="keywordflow">return</span> int1d</div>
<div class="line"><span class="lineno">  470</span> </div>
<div class="line"><span class="lineno">  471</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a20eca5e64fc496a00903f06a4573834f" name="a20eca5e64fc496a00903f06a4573834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eca5e64fc496a00903f06a4573834f">&#9670;&#160;</a></span>isin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.isin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>test_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invert</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates ``element in test_elements``, broadcasting over `element` only.
Returns a boolean array of the same shape as `element` that is True
where an element of `element` is in `test_elements` and False otherwise.

Parameters
----------
element : array_like
    Input array.
test_elements : array_like
    The values against which to test each value of `element`.
    This argument is flattened if it is an array or array_like.
    See notes for behavior with non-array-like parameters.
assume_unique : bool, optional
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
invert : bool, optional
    If True, the values in the returned array are inverted, as if
    calculating `element not in test_elements`. Default is False.
    ``np.isin(a, b, invert=True)`` is equivalent to (but faster
    than) ``np.invert(np.isin(a, b))``.
kind : {None, 'sort', 'table'}, optional
    The algorithm to use. This will not affect the final result,
    but will affect the speed and memory use. The default, None,
    will select automatically based on memory considerations.

    * If 'sort', will use a mergesort-based approach. This will have
      a memory usage of roughly 6 times the sum of the sizes of
      `ar1` and `ar2`, not accounting for size of dtypes.
    * If 'table', will use a lookup table approach similar
      to a counting sort. This is only available for boolean and
      integer arrays. This will have a memory usage of the
      size of `ar1` plus the max-min value of `ar2`. `assume_unique`
      has no effect when the 'table' option is used.
    * If None, will automatically choose 'table' if
      the required memory allocation is less than or equal to
      6 times the sum of the sizes of `ar1` and `ar2`,
      otherwise will use 'sort'. This is done to not use
      a large amount of memory by default, even though
      'table' may be faster in most cases. If 'table' is chosen,
      `assume_unique` will have no effect.


Returns
-------
isin : ndarray, bool
    Has the same shape as `element`. The values `element[isin]`
    are in `test_elements`.

See Also
--------
in1d                  : Flattened version of this function.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----

`isin` is an element-wise function version of the python keyword `in`.
``isin(a, b)`` is roughly equivalent to
``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.

`element` and `test_elements` are converted to arrays if they are not
already. If `test_elements` is a set (or other non-sequence collection)
it will be converted to an object array with one element, rather than an
array of the values contained in `test_elements`. This is a consequence
of the `array` constructor's way of handling non-sequence collections.
Converting the set to a list usually gives the desired behavior.

Using ``kind='table'`` tends to be faster than `kind='sort'` if the
following relationship is true:
``log10(len(ar2)) &gt; (log10(max(ar2)-min(ar2)) - 2.27) / 0.927``,
but may use greater memory. The default value for `kind` will
be automatically selected based only on memory usage, so one may
manually set ``kind='table'`` if memory constraints can be relaxed.

.. versionadded:: 1.13.0

Examples
--------
&gt;&gt;&gt; element = 2*np.arange(4).reshape((2, 2))
&gt;&gt;&gt; element
array([[0, 2],
       [4, 6]])
&gt;&gt;&gt; test_elements = [1, 2, 4, 8]
&gt;&gt;&gt; mask = np.isin(element, test_elements)
&gt;&gt;&gt; mask
array([[False,  True],
       [ True, False]])
&gt;&gt;&gt; element[mask]
array([2, 4])

The indices of the matched values can be obtained with `nonzero`:

&gt;&gt;&gt; np.nonzero(mask)
(array([0, 1]), array([1, 0]))

The test can also be inverted:

&gt;&gt;&gt; mask = np.isin(element, test_elements, invert=True)
&gt;&gt;&gt; mask
array([[ True, False],
       [False,  True]])
&gt;&gt;&gt; element[mask]
array([0, 6])

Because of how `array` handles sets, the following does not
work as expected:

&gt;&gt;&gt; test_set = {1, 2, 4, 8}
&gt;&gt;&gt; np.isin(element, test_set)
array([[False, False],
       [False, False]])

Casting the set to a list gives the expected result:

&gt;&gt;&gt; np.isin(element, list(test_set))
array([[False,  True],
       [ True, False]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  768</span>         kind=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  769</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    Calculates ``element in test_elements``, broadcasting over `element` only.</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    Returns a boolean array of the same shape as `element` that is True</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    where an element of `element` is in `test_elements` and False otherwise.</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    element : array_like</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    test_elements : array_like</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        The values against which to test each value of `element`.</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">        This argument is flattened if it is an array or array_like.</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">        See notes for behavior with non-array-like parameters.</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    assume_unique : bool, optional</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        If True, the input arrays are both assumed to be unique, which</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        can speed up the calculation.  Default is False.</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    invert : bool, optional</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        If True, the values in the returned array are inverted, as if</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        calculating `element not in test_elements`. Default is False.</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        ``np.isin(a, b, invert=True)`` is equivalent to (but faster</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">        than) ``np.invert(np.isin(a, b))``.</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    kind : {None, &#39;sort&#39;, &#39;table&#39;}, optional</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">        The algorithm to use. This will not affect the final result,</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        but will affect the speed and memory use. The default, None,</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">        will select automatically based on memory considerations.</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        * If &#39;sort&#39;, will use a mergesort-based approach. This will have</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">          a memory usage of roughly 6 times the sum of the sizes of</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">          `ar1` and `ar2`, not accounting for size of dtypes.</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        * If &#39;table&#39;, will use a lookup table approach similar</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">          to a counting sort. This is only available for boolean and</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">          integer arrays. This will have a memory usage of the</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">          size of `ar1` plus the max-min value of `ar2`. `assume_unique`</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">          has no effect when the &#39;table&#39; option is used.</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">        * If None, will automatically choose &#39;table&#39; if</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">          the required memory allocation is less than or equal to</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">          6 times the sum of the sizes of `ar1` and `ar2`,</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">          otherwise will use &#39;sort&#39;. This is done to not use</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">          a large amount of memory by default, even though</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">          &#39;table&#39; may be faster in most cases. If &#39;table&#39; is chosen,</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">          `assume_unique` will have no effect.</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    isin : ndarray, bool</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">        Has the same shape as `element`. The values `element[isin]`</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">        are in `test_elements`.</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    in1d                  : Flattened version of this function.</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    numpy.lib.arraysetops : Module with a number of other functions for</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">                            performing set operations on arrays.</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    `isin` is an element-wise function version of the python keyword `in`.</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    ``isin(a, b)`` is roughly equivalent to</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    ``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    `element` and `test_elements` are converted to arrays if they are not</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    already. If `test_elements` is a set (or other non-sequence collection)</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    it will be converted to an object array with one element, rather than an</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    array of the values contained in `test_elements`. This is a consequence</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    of the `array` constructor&#39;s way of handling non-sequence collections.</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    Converting the set to a list usually gives the desired behavior.</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    Using ``kind=&#39;table&#39;`` tends to be faster than `kind=&#39;sort&#39;` if the</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    following relationship is true:</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    ``log10(len(ar2)) &gt; (log10(max(ar2)-min(ar2)) - 2.27) / 0.927``,</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    but may use greater memory. The default value for `kind` will</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    be automatically selected based only on memory usage, so one may</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">    manually set ``kind=&#39;table&#39;`` if memory constraints can be relaxed.</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    .. versionadded:: 1.13.0</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    &gt;&gt;&gt; element = 2*np.arange(4).reshape((2, 2))</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    &gt;&gt;&gt; element</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    array([[0, 2],</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">           [4, 6]])</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    &gt;&gt;&gt; test_elements = [1, 2, 4, 8]</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    &gt;&gt;&gt; mask = np.isin(element, test_elements)</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    &gt;&gt;&gt; mask</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    array([[False,  True],</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">           [ True, False]])</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    &gt;&gt;&gt; element[mask]</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    array([2, 4])</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    The indices of the matched values can be obtained with `nonzero`:</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    &gt;&gt;&gt; np.nonzero(mask)</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    (array([0, 1]), array([1, 0]))</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    The test can also be inverted:</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    &gt;&gt;&gt; mask = np.isin(element, test_elements, invert=True)</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    &gt;&gt;&gt; mask</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    array([[ True, False],</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">           [False,  True]])</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    &gt;&gt;&gt; element[mask]</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    array([0, 6])</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    Because of how `array` handles sets, the following does not</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    work as expected:</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    &gt;&gt;&gt; test_set = {1, 2, 4, 8}</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    &gt;&gt;&gt; np.isin(element, test_set)</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    array([[False, False],</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">           [False, False]])</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    Casting the set to a list gives the expected result:</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    &gt;&gt;&gt; np.isin(element, list(test_set))</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    array([[False,  True],</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">           [ True, False]])</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  889</span>    element = np.asarray(element)</div>
<div class="line"><span class="lineno">  890</span>    <span class="keywordflow">return</span> in1d(element, test_elements, assume_unique=assume_unique,</div>
<div class="line"><span class="lineno">  891</span>                invert=invert, kind=kind).reshape(element.shape)</div>
<div class="line"><span class="lineno">  892</span> </div>
<div class="line"><span class="lineno">  893</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ada493fdbed91a81184fb11172da54f9f" name="ada493fdbed91a81184fb11172da54f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada493fdbed91a81184fb11172da54f9f">&#9670;&#160;</a></span>setdiff1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.setdiff1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the set difference of two arrays.

Return the unique values in `ar1` that are not in `ar2`.

Parameters
----------
ar1 : array_like
    Input array.
ar2 : array_like
    Input comparison array.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.

Returns
-------
setdiff1d : ndarray
    1D array of values in `ar1` that are not in `ar2`. The result
    is sorted when `assume_unique=False`, but otherwise only sorted
    if the input is sorted.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; a = np.array([1, 2, 3, 2, 4, 1])
&gt;&gt;&gt; b = np.array([3, 4, 5, 6])
&gt;&gt;&gt; np.setdiff1d(a, b)
array([1, 2])</pre> <div class="fragment"><div class="line"><span class="lineno">  940</span><span class="keyword">def </span>setdiff1d(ar1, ar2, assume_unique=False):</div>
<div class="line"><span class="lineno">  941</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    Find the set difference of two arrays.</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">    Return the unique values in `ar1` that are not in `ar2`.</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    ar1 : array_like</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    ar2 : array_like</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">        Input comparison array.</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    assume_unique : bool</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">        If True, the input arrays are both assumed to be unique, which</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">        can speed up the calculation.  Default is False.</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">    setdiff1d : ndarray</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">        1D array of values in `ar1` that are not in `ar2`. The result</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">        is sorted when `assume_unique=False`, but otherwise only sorted</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">        if the input is sorted.</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    numpy.lib.arraysetops : Module with a number of other functions for</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">                            performing set operations on arrays.</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3, 2, 4, 1])</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">    &gt;&gt;&gt; np.setdiff1d(a, b)</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    array([1, 2])</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  976</span>    <span class="keywordflow">if</span> assume_unique:</div>
<div class="line"><span class="lineno">  977</span>        ar1 = np.asarray(ar1).ravel()</div>
<div class="line"><span class="lineno">  978</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  979</span>        ar1 = unique(ar1)</div>
<div class="line"><span class="lineno">  980</span>        ar2 = unique(ar2)</div>
<div class="line"><span class="lineno">  981</span>    <span class="keywordflow">return</span> ar1[in1d(ar1, ar2, assume_unique=<span class="keyword">True</span>, invert=<span class="keyword">True</span>)]</div>
</div><!-- fragment -->
</div>
</div>
<a id="af58ba81f8f210c61f3d3de715281a33b" name="af58ba81f8f210c61f3d3de715281a33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58ba81f8f210c61f3d3de715281a33b">&#9670;&#160;</a></span>setxor1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.setxor1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the set exclusive-or of two arrays.

Return the sorted, unique values that are in only one (not both) of the
input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.

Returns
-------
setxor1d : ndarray
    Sorted 1D array of unique values that are in only one of the input
    arrays.

Examples
--------
&gt;&gt;&gt; a = np.array([1, 2, 3, 2, 4])
&gt;&gt;&gt; b = np.array([2, 3, 5, 7, 5])
&gt;&gt;&gt; np.setxor1d(a,b)
array([1, 4, 5, 7])</pre> <div class="fragment"><div class="line"><span class="lineno">  477</span><span class="keyword">def </span>setxor1d(ar1, ar2, assume_unique=False):</div>
<div class="line"><span class="lineno">  478</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    Find the set exclusive-or of two arrays.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    Return the sorted, unique values that are in only one (not both) of the</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    input arrays.</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    ar1, ar2 : array_like</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        Input arrays.</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    assume_unique : bool</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        If True, the input arrays are both assumed to be unique, which</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        can speed up the calculation.  Default is False.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    setxor1d : ndarray</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">        Sorted 1D array of unique values that are in only one of the input</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        arrays.</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3, 2, 4])</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([2, 3, 5, 7, 5])</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    &gt;&gt;&gt; np.setxor1d(a,b)</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    array([1, 4, 5, 7])</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  506</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> assume_unique:</div>
<div class="line"><span class="lineno">  507</span>        ar1 = unique(ar1)</div>
<div class="line"><span class="lineno">  508</span>        ar2 = unique(ar2)</div>
<div class="line"><span class="lineno">  509</span> </div>
<div class="line"><span class="lineno">  510</span>    aux = np.concatenate((ar1, ar2))</div>
<div class="line"><span class="lineno">  511</span>    <span class="keywordflow">if</span> aux.size == 0:</div>
<div class="line"><span class="lineno">  512</span>        <span class="keywordflow">return</span> aux</div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span>    aux.sort()</div>
<div class="line"><span class="lineno">  515</span>    flag = np.concatenate(([<span class="keyword">True</span>], aux[1:] != aux[:-1], [<span class="keyword">True</span>]))</div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">return</span> aux[flag[1:] &amp; flag[:-1]]</div>
<div class="line"><span class="lineno">  517</span> </div>
<div class="line"><span class="lineno">  518</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c6ba8d6a374302588ed4bc029616bda" name="a4c6ba8d6a374302588ed4bc029616bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6ba8d6a374302588ed4bc029616bda">&#9670;&#160;</a></span>union1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.union1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the union of two arrays.

Return the unique, sorted array of values that are in either of the two
input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays. They are flattened if they are not already 1D.

Returns
-------
union1d : ndarray
    Unique, sorted union of the input arrays.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; np.union1d([-1, 0, 1], [-2, 0, 2])
array([-2, -1,  0,  1,  2])

To find the union of more than two arrays, use functools.reduce:

&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([1, 2, 3, 4, 6])
</pre> <div class="fragment"><div class="line"><span class="lineno">  899</span><span class="keyword">def </span>union1d(ar1, ar2):</div>
<div class="line"><span class="lineno">  900</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    Find the union of two arrays.</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Return the unique, sorted array of values that are in either of the two</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    input arrays.</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    ar1, ar2 : array_like</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        Input arrays. They are flattened if they are not already 1D.</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    union1d : ndarray</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        Unique, sorted union of the input arrays.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    numpy.lib.arraysetops : Module with a number of other functions for</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">                            performing set operations on arrays.</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    &gt;&gt;&gt; np.union1d([-1, 0, 1], [-2, 0, 2])</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    array([-2, -1,  0,  1,  2])</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    To find the union of more than two arrays, use functools.reduce:</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    &gt;&gt;&gt; from functools import reduce</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    &gt;&gt;&gt; reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    array([1, 2, 3, 4, 6])</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  932</span>    <span class="keywordflow">return</span> unique(np.concatenate((ar1, ar2), axis=<span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  933</span> </div>
<div class="line"><span class="lineno">  934</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="add4fe206d153a493f182b0afd9fca95d" name="add4fe206d153a493f182b0afd9fca95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4fe206d153a493f182b0afd9fca95d">&#9670;&#160;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_index</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_inverse</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_counts</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>equal_nan</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the unique elements of an array.

Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements:

* the indices of the input array that give the unique values
* the indices of the unique array that reconstruct the input array
* the number of times each unique value comes up in the input array

Parameters
----------
ar : array_like
    Input array. Unless `axis` is specified, this will be flattened if it
    is not already 1-D.
return_index : bool, optional
    If True, also return the indices of `ar` (along the specified axis,
    if provided, or in the flattened array) that result in the unique array.
return_inverse : bool, optional
    If True, also return the indices of the unique array (for the specified
    axis, if provided) that can be used to reconstruct `ar`.
return_counts : bool, optional
    If True, also return the number of times each unique item appears
    in `ar`.
axis : int or None, optional
    The axis to operate on. If None, `ar` will be flattened. If an integer,
    the subarrays indexed by the given axis will be flattened and treated
    as the elements of a 1-D array with the dimension of the given axis,
    see the notes for more details.  Object arrays or structured arrays
    that contain objects are not supported if the `axis` kwarg is used. The
    default is None.

    .. versionadded:: 1.13.0

equal_nan : bool, optional
    If True, collapses multiple NaN values in the return array into one.

    .. versionadded:: 1.24

Returns
-------
unique : ndarray
    The sorted unique values.
unique_indices : ndarray, optional
    The indices of the first occurrences of the unique values in the
    original array. Only provided if `return_index` is True.
unique_inverse : ndarray, optional
    The indices to reconstruct the original array from the
    unique array. Only provided if `return_inverse` is True.
unique_counts : ndarray, optional
    The number of times each of the unique values comes up in the
    original array. Only provided if `return_counts` is True.

    .. versionadded:: 1.9.0

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.
repeat : Repeat elements of an array.

Notes
-----
When an axis is specified the subarrays indexed by the axis are sorted.
This is done by making the specified axis the first dimension of the array
(move the axis to the first dimension to keep the order of the other axes)
and then flattening the subarrays in C order. The flattened subarrays are
then viewed as a structured type with each element given a label, with the
effect that we end up with a 1-D array of structured types that can be
treated in the same way as any other 1-D array. The result is that the
flattened subarrays are sorted in lexicographic order starting with the
first element.

.. versionchanged: NumPy 1.21
    If nan values are in the input array, a single nan is put
    to the end of the sorted unique values.

    Also for complex arrays all NaN values are considered equivalent
    (no matter whether the NaN is in the real or imaginary part).
    As the representant for the returned array the smallest one in the
    lexicographical order is chosen - see np.sort for how the lexicographical
    order is defined for complex arrays.

Examples
--------
&gt;&gt;&gt; np.unique([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
&gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])
&gt;&gt;&gt; np.unique(a)
array([1, 2, 3])

Return the unique rows of a 2D array

&gt;&gt;&gt; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
&gt;&gt;&gt; np.unique(a, axis=0)
array([[1, 0, 0], [2, 3, 4]])

Return the indices of the original array that give the unique values:

&gt;&gt;&gt; a = np.array(['a', 'b', 'b', 'c', 'a'])
&gt;&gt;&gt; u, indices = np.unique(a, return_index=True)
&gt;&gt;&gt; u
array(['a', 'b', 'c'], dtype='&lt;U1')
&gt;&gt;&gt; indices
array([0, 1, 3])
&gt;&gt;&gt; a[indices]
array(['a', 'b', 'c'], dtype='&lt;U1')

Reconstruct the input array from the unique values and inverse:

&gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])
&gt;&gt;&gt; u, indices = np.unique(a, return_inverse=True)
&gt;&gt;&gt; u
array([1, 2, 3, 4, 6])
&gt;&gt;&gt; indices
array([0, 1, 4, 3, 1, 2, 1])
&gt;&gt;&gt; u[indices]
array([1, 2, 6, 4, 2, 3, 2])

Reconstruct the input values from the unique values and counts:

&gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])
&gt;&gt;&gt; values, counts = np.unique(a, return_counts=True)
&gt;&gt;&gt; values
array([1, 2, 3, 4, 6])
&gt;&gt;&gt; counts
array([1, 3, 1, 1, 1])
&gt;&gt;&gt; np.repeat(values, counts)
array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved</pre> <div class="fragment"><div class="line"><span class="lineno">  140</span>           return_counts=<span class="keyword">False</span>, axis=<span class="keywordtype">None</span>, *, equal_nan=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  141</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    Find the unique elements of an array.</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    Returns the sorted unique elements of an array. There are three optional</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    outputs in addition to the unique elements:</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    * the indices of the input array that give the unique values</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    * the indices of the unique array that reconstruct the input array</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    * the number of times each unique value comes up in the input array</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    ar : array_like</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        Input array. Unless `axis` is specified, this will be flattened if it</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        is not already 1-D.</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    return_index : bool, optional</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">        If True, also return the indices of `ar` (along the specified axis,</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        if provided, or in the flattened array) that result in the unique array.</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    return_inverse : bool, optional</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        If True, also return the indices of the unique array (for the specified</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        axis, if provided) that can be used to reconstruct `ar`.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    return_counts : bool, optional</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">        If True, also return the number of times each unique item appears</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">        in `ar`.</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">        The axis to operate on. If None, `ar` will be flattened. If an integer,</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">        the subarrays indexed by the given axis will be flattened and treated</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        as the elements of a 1-D array with the dimension of the given axis,</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        see the notes for more details.  Object arrays or structured arrays</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        that contain objects are not supported if the `axis` kwarg is used. The</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        default is None.</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        .. versionadded:: 1.13.0</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    equal_nan : bool, optional</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        If True, collapses multiple NaN values in the return array into one.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">        .. versionadded:: 1.24</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    unique : ndarray</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">        The sorted unique values.</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    unique_indices : ndarray, optional</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        The indices of the first occurrences of the unique values in the</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        original array. Only provided if `return_index` is True.</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    unique_inverse : ndarray, optional</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        The indices to reconstruct the original array from the</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">        unique array. Only provided if `return_inverse` is True.</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    unique_counts : ndarray, optional</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">        The number of times each of the unique values comes up in the</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        original array. Only provided if `return_counts` is True.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">        .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    numpy.lib.arraysetops : Module with a number of other functions for</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">                            performing set operations on arrays.</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    repeat : Repeat elements of an array.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    When an axis is specified the subarrays indexed by the axis are sorted.</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    This is done by making the specified axis the first dimension of the array</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    (move the axis to the first dimension to keep the order of the other axes)</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    and then flattening the subarrays in C order. The flattened subarrays are</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    then viewed as a structured type with each element given a label, with the</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    effect that we end up with a 1-D array of structured types that can be</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    treated in the same way as any other 1-D array. The result is that the</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    flattened subarrays are sorted in lexicographic order starting with the</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    first element.</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    .. versionchanged: NumPy 1.21</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        If nan values are in the input array, a single nan is put</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        to the end of the sorted unique values.</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        Also for complex arrays all NaN values are considered equivalent</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        (no matter whether the NaN is in the real or imaginary part).</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        As the representant for the returned array the smallest one in the</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">        lexicographical order is chosen - see np.sort for how the lexicographical</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        order is defined for complex arrays.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    &gt;&gt;&gt; np.unique([1, 1, 2, 2, 3, 3])</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; np.unique(a)</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    Return the unique rows of a 2D array</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    &gt;&gt;&gt; np.unique(a, axis=0)</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    array([[1, 0, 0], [2, 3, 4]])</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    Return the indices of the original array that give the unique values:</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;])</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    &gt;&gt;&gt; u, indices = np.unique(a, return_index=True)</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    &gt;&gt;&gt; u</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U1&#39;)</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    &gt;&gt;&gt; indices</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    array([0, 1, 3])</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    &gt;&gt;&gt; a[indices]</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U1&#39;)</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    Reconstruct the input array from the unique values and inverse:</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    &gt;&gt;&gt; u, indices = np.unique(a, return_inverse=True)</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    &gt;&gt;&gt; u</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    array([1, 2, 3, 4, 6])</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    &gt;&gt;&gt; indices</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    array([0, 1, 4, 3, 1, 2, 1])</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    &gt;&gt;&gt; u[indices]</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    array([1, 2, 6, 4, 2, 3, 2])</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    Reconstruct the input values from the unique values and counts:</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    &gt;&gt;&gt; values, counts = np.unique(a, return_counts=True)</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    &gt;&gt;&gt; values</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    array([1, 2, 3, 4, 6])</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    &gt;&gt;&gt; counts</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    array([1, 3, 1, 1, 1])</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    &gt;&gt;&gt; np.repeat(values, counts)</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  272</span>    ar = np.asanyarray(ar)</div>
<div class="line"><span class="lineno">  273</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  274</span>        ret = _unique1d(ar, return_index, return_inverse, return_counts, </div>
<div class="line"><span class="lineno">  275</span>                        equal_nan=equal_nan)</div>
<div class="line"><span class="lineno">  276</span>        <span class="keywordflow">return</span> _unpack_tuple(ret)</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>    <span class="comment"># axis was specified and not None</span></div>
<div class="line"><span class="lineno">  279</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  280</span>        ar = np.moveaxis(ar, axis, 0)</div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">except</span> np.AxisError:</div>
<div class="line"><span class="lineno">  282</span>        <span class="comment"># this removes the &quot;axis1&quot; or &quot;axis2&quot; prefix from the error message</span></div>
<div class="line"><span class="lineno">  283</span>        <span class="keywordflow">raise</span> np.AxisError(axis, ar.ndim) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>    <span class="comment"># Must reshape to a contiguous 2D array for this to work...</span></div>
<div class="line"><span class="lineno">  286</span>    orig_shape, orig_dtype = ar.shape, ar.dtype</div>
<div class="line"><span class="lineno">  287</span>    ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))</div>
<div class="line"><span class="lineno">  288</span>    ar = np.ascontiguousarray(ar)</div>
<div class="line"><span class="lineno">  289</span>    dtype = [(<span class="stringliteral">&#39;f{i}&#39;</span>.format(i=i), ar.dtype) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(ar.shape[1])]</div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>    <span class="comment"># At this point, `ar` has shape `(n, m)`, and `dtype` is a structured</span></div>
<div class="line"><span class="lineno">  292</span>    <span class="comment"># data type with `m` fields where each field has the data type of `ar`.</span></div>
<div class="line"><span class="lineno">  293</span>    <span class="comment"># In the following, we create the array `consolidated`, which has</span></div>
<div class="line"><span class="lineno">  294</span>    <span class="comment"># shape `(n,)` with data type `dtype`.</span></div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  296</span>        <span class="keywordflow">if</span> ar.shape[1] &gt; 0:</div>
<div class="line"><span class="lineno">  297</span>            consolidated = ar.view(dtype)</div>
<div class="line"><span class="lineno">  298</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  299</span>            <span class="comment"># If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is</span></div>
<div class="line"><span class="lineno">  300</span>            <span class="comment"># a data type with itemsize 0, and the call `ar.view(dtype)` will</span></div>
<div class="line"><span class="lineno">  301</span>            <span class="comment"># fail.  Instead, we&#39;ll use `np.empty` to explicitly create the</span></div>
<div class="line"><span class="lineno">  302</span>            <span class="comment"># array with shape `(len(ar),)`.  Because `dtype` in this case has</span></div>
<div class="line"><span class="lineno">  303</span>            <span class="comment"># itemsize 0, the total size of the result is still 0 bytes.</span></div>
<div class="line"><span class="lineno">  304</span>            consolidated = np.empty(len(ar), dtype=dtype)</div>
<div class="line"><span class="lineno">  305</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  306</span>        <span class="comment"># There&#39;s no good way to do this for object arrays, etc...</span></div>
<div class="line"><span class="lineno">  307</span>        msg = <span class="stringliteral">&#39;The axis argument to unique is not supported for dtype {dt}&#39;</span></div>
<div class="line"><span class="lineno">  308</span>        <span class="keywordflow">raise</span> TypeError(msg.format(dt=ar.dtype)) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>    <span class="keyword">def </span>reshape_uniq(uniq):</div>
<div class="line"><span class="lineno">  311</span>        n = len(uniq)</div>
<div class="line"><span class="lineno">  312</span>        uniq = uniq.view(orig_dtype)</div>
<div class="line"><span class="lineno">  313</span>        uniq = uniq.reshape(n, *orig_shape[1:])</div>
<div class="line"><span class="lineno">  314</span>        uniq = np.moveaxis(uniq, 0, axis)</div>
<div class="line"><span class="lineno">  315</span>        <span class="keywordflow">return</span> uniq</div>
<div class="line"><span class="lineno">  316</span> </div>
<div class="line"><span class="lineno">  317</span>    output = _unique1d(consolidated, return_index,</div>
<div class="line"><span class="lineno">  318</span>                       return_inverse, return_counts, equal_nan=equal_nan)</div>
<div class="line"><span class="lineno">  319</span>    output = (reshape_uniq(output[0]),) + output[1:]</div>
<div class="line"><span class="lineno">  320</span>    <span class="keywordflow">return</span> _unpack_tuple(output)</div>
<div class="line"><span class="lineno">  321</span> </div>
<div class="line"><span class="lineno">  322</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad2ed5d82dfe2e7bee05263ba295c5d8a" name="ad2ed5d82dfe2e7bee05263ba295c5d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ed5d82dfe2e7bee05263ba295c5d8a">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraysetops.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
