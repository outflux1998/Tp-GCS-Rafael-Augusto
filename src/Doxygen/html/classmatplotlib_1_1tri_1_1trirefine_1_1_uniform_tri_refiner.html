<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.tri.trirefine.UniformTriRefiner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1tri.html">tri</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1tri_1_1trirefine.html">trirefine</a></li><li class="navelem"><a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner.html">UniformTriRefiner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.tri.trirefine.UniformTriRefiner Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for matplotlib.tri.trirefine.UniformTriRefiner:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner.png" usemap="#matplotlib.tri.trirefine.UniformTriRefiner_map" alt=""/>
  <map id="matplotlib.tri.trirefine.UniformTriRefiner_map" name="matplotlib.tri.trirefine.UniformTriRefiner_map">
<area href="classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner.html" alt="matplotlib.tri.trirefine.TriRefiner" shape="rect" coords="0,0,230,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f1ea55911a0ca0d00266aaffc47f8c4" id="r_a3f1ea55911a0ca0d00266aaffc47f8c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner.html#a3f1ea55911a0ca0d00266aaffc47f8c4">__init__</a> (self, triangulation)</td></tr>
<tr class="separator:a3f1ea55911a0ca0d00266aaffc47f8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0229a48fd1e399f47b7f3b306f0e2793" id="r_a0229a48fd1e399f47b7f3b306f0e2793"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner.html#a0229a48fd1e399f47b7f3b306f0e2793">refine_triangulation</a> (self, return_tri_index=False, subdiv=3)</td></tr>
<tr class="separator:a0229a48fd1e399f47b7f3b306f0e2793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1988d36d23832643e593cf0e0bee8821" id="r_a1988d36d23832643e593cf0e0bee8821"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner.html#a1988d36d23832643e593cf0e0bee8821">refine_field</a> (self, <a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>, triinterpolator=None, subdiv=3)</td></tr>
<tr class="separator:a1988d36d23832643e593cf0e0bee8821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad9ddee0cc0d7f043df1e8b32bfbaeec6" id="r_ad9ddee0cc0d7f043df1e8b32bfbaeec6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner.html#ad9ddee0cc0d7f043df1e8b32bfbaeec6">_refine_triangulation_once</a> (triangulation, ancestors=None)</td></tr>
<tr class="separator:ad9ddee0cc0d7f043df1e8b32bfbaeec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac6f401999991f387d7bb32352c654e72" id="r_ac6f401999991f387d7bb32352c654e72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_uniform_tri_refiner.html#ac6f401999991f387d7bb32352c654e72">_triangulation</a></td></tr>
<tr class="separator:ac6f401999991f387d7bb32352c654e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner.html">matplotlib.tri.trirefine.TriRefiner</a></td></tr>
<tr class="memitem:afe054dcca673bba72346889f9d47a394 inherit pro_attribs_classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner" id="r_afe054dcca673bba72346889f9d47a394"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner.html#afe054dcca673bba72346889f9d47a394">_triangulation</a></td></tr>
<tr class="separator:afe054dcca673bba72346889f9d47a394 inherit pro_attribs_classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Uniform mesh refinement by recursive subdivisions.

Parameters
----------
triangulation : `~matplotlib.tri.Triangulation`
    The encapsulated triangulation (to be refined)
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f1ea55911a0ca0d00266aaffc47f8c4" name="a3f1ea55911a0ca0d00266aaffc47f8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1ea55911a0ca0d00266aaffc47f8c4">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tri.trirefine.UniformTriRefiner.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classmatplotlib_1_1tri_1_1trirefine_1_1_tri_refiner.html#aeac0dceef3b37ac5f18c0d36ef5a6be5">matplotlib.tri.trirefine.TriRefiner</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   61</span>    <span class="keyword">def </span>__init__(self, triangulation):</div>
<div class="line"><span class="lineno">   62</span>        super().__init__(triangulation)</div>
<div class="line"><span class="lineno">   63</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9ddee0cc0d7f043df1e8b32bfbaeec6" name="ad9ddee0cc0d7f043df1e8b32bfbaeec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ddee0cc0d7f043df1e8b32bfbaeec6">&#9670;&#160;</a></span>_refine_triangulation_once()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tri.trirefine.UniformTriRefiner._refine_triangulation_once </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ancestors</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Refine a `.Triangulation` by splitting each triangle into 4
child-masked_triangles built on the edges midside nodes.

Masked triangles, if present, are also split, but their children
returned masked.

If *ancestors* is not provided, returns only a new triangulation:
child_triangulation.

If the array-like key table *ancestor* is given, it shall be of shape
(ntri,) where ntri is the number of *triangulation* masked_triangles.
In this case, the function returns
(child_triangulation, child_ancestors)
child_ancestors is defined so that the 4 child masked_triangles share
the same index as their father: child_ancestors.shape = (4 * ntri,).
</pre> <div class="fragment"><div class="line"><span class="lineno">  172</span>    <span class="keyword">def </span>_refine_triangulation_once(triangulation, ancestors=None):</div>
<div class="line"><span class="lineno">  173</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        Refine a `.Triangulation` by splitting each triangle into 4</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        child-masked_triangles built on the edges midside nodes.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">        Masked triangles, if present, are also split, but their children</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">        returned masked.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        If *ancestors* is not provided, returns only a new triangulation:</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        child_triangulation.</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">        If the array-like key table *ancestor* is given, it shall be of shape</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        (ntri,) where ntri is the number of *triangulation* masked_triangles.</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        In this case, the function returns</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        (child_triangulation, child_ancestors)</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">        child_ancestors is defined so that the 4 child masked_triangles share</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        the same index as their father: child_ancestors.shape = (4 * ntri,).</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  190</span> </div>
<div class="line"><span class="lineno">  191</span>        x = triangulation.x</div>
<div class="line"><span class="lineno">  192</span>        y = triangulation.y</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>        <span class="comment">#    According to tri.triangulation doc:</span></div>
<div class="line"><span class="lineno">  195</span>        <span class="comment">#         neighbors[i, j] is the triangle that is the neighbor</span></div>
<div class="line"><span class="lineno">  196</span>        <span class="comment">#         to the edge from point index masked_triangles[i, j] to point</span></div>
<div class="line"><span class="lineno">  197</span>        <span class="comment">#         index masked_triangles[i, (j+1)%3].</span></div>
<div class="line"><span class="lineno">  198</span>        neighbors = triangulation.neighbors</div>
<div class="line"><span class="lineno">  199</span>        triangles = triangulation.triangles</div>
<div class="line"><span class="lineno">  200</span>        npts = np.shape(x)[0]</div>
<div class="line"><span class="lineno">  201</span>        ntri = np.shape(triangles)[0]</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">if</span> ancestors <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  203</span>            ancestors = np.asarray(ancestors)</div>
<div class="line"><span class="lineno">  204</span>            <span class="keywordflow">if</span> np.shape(ancestors) != (ntri,):</div>
<div class="line"><span class="lineno">  205</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  206</span>                    <span class="stringliteral">&quot;Incompatible shapes provide for triangulation&quot;</span></div>
<div class="line"><span class="lineno">  207</span>                    <span class="stringliteral">&quot;.masked_triangles and ancestors: {0} and {1}&quot;</span>.format(</div>
<div class="line"><span class="lineno">  208</span>                        np.shape(triangles), np.shape(ancestors)))</div>
<div class="line"><span class="lineno">  209</span> </div>
<div class="line"><span class="lineno">  210</span>        <span class="comment"># Initiating tables refi_x and refi_y of the refined triangulation</span></div>
<div class="line"><span class="lineno">  211</span>        <span class="comment"># points</span></div>
<div class="line"><span class="lineno">  212</span>        <span class="comment"># hint: each apex is shared by 2 masked_triangles except the borders.</span></div>
<div class="line"><span class="lineno">  213</span>        borders = np.sum(neighbors == -1)</div>
<div class="line"><span class="lineno">  214</span>        added_pts = (3*ntri + borders) // 2</div>
<div class="line"><span class="lineno">  215</span>        refi_npts = npts + added_pts</div>
<div class="line"><span class="lineno">  216</span>        refi_x = np.zeros(refi_npts)</div>
<div class="line"><span class="lineno">  217</span>        refi_y = np.zeros(refi_npts)</div>
<div class="line"><span class="lineno">  218</span> </div>
<div class="line"><span class="lineno">  219</span>        <span class="comment"># First part of refi_x, refi_y is just the initial points</span></div>
<div class="line"><span class="lineno">  220</span>        refi_x[:npts] = x</div>
<div class="line"><span class="lineno">  221</span>        refi_y[:npts] = y</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span>        <span class="comment"># Second part contains the edge midside nodes.</span></div>
<div class="line"><span class="lineno">  224</span>        <span class="comment"># Each edge belongs to 1 triangle (if border edge) or is shared by 2</span></div>
<div class="line"><span class="lineno">  225</span>        <span class="comment"># masked_triangles (interior edge).</span></div>
<div class="line"><span class="lineno">  226</span>        <span class="comment"># We first build 2 * ntri arrays of edge starting nodes (edge_elems,</span></div>
<div class="line"><span class="lineno">  227</span>        <span class="comment"># edge_apexes); we then extract only the masters to avoid overlaps.</span></div>
<div class="line"><span class="lineno">  228</span>        <span class="comment"># The so-called &#39;master&#39; is the triangle with biggest index</span></div>
<div class="line"><span class="lineno">  229</span>        <span class="comment"># The &#39;slave&#39; is the triangle with lower index</span></div>
<div class="line"><span class="lineno">  230</span>        <span class="comment"># (can be -1 if border edge)</span></div>
<div class="line"><span class="lineno">  231</span>        <span class="comment"># For slave and master we will identify the apex pointing to the edge</span></div>
<div class="line"><span class="lineno">  232</span>        <span class="comment"># start</span></div>
<div class="line"><span class="lineno">  233</span>        edge_elems = np.tile(np.arange(ntri, dtype=np.int32), 3)</div>
<div class="line"><span class="lineno">  234</span>        edge_apexes = np.repeat(np.arange(3, dtype=np.int32), ntri)</div>
<div class="line"><span class="lineno">  235</span>        edge_neighbors = neighbors[edge_elems, edge_apexes]</div>
<div class="line"><span class="lineno">  236</span>        mask_masters = (edge_elems &gt; edge_neighbors)</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>        <span class="comment"># Identifying the &quot;masters&quot; and adding to refi_x, refi_y vec</span></div>
<div class="line"><span class="lineno">  239</span>        masters = edge_elems[mask_masters]</div>
<div class="line"><span class="lineno">  240</span>        apex_masters = edge_apexes[mask_masters]</div>
<div class="line"><span class="lineno">  241</span>        x_add = (x[triangles[masters, apex_masters]] +</div>
<div class="line"><span class="lineno">  242</span>                 x[triangles[masters, (apex_masters+1) % 3]]) * 0.5</div>
<div class="line"><span class="lineno">  243</span>        y_add = (y[triangles[masters, apex_masters]] +</div>
<div class="line"><span class="lineno">  244</span>                 y[triangles[masters, (apex_masters+1) % 3]]) * 0.5</div>
<div class="line"><span class="lineno">  245</span>        refi_x[npts:] = x_add</div>
<div class="line"><span class="lineno">  246</span>        refi_y[npts:] = y_add</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span>        <span class="comment"># Building the new masked_triangles; each old masked_triangles hosts</span></div>
<div class="line"><span class="lineno">  249</span>        <span class="comment"># 4 new masked_triangles</span></div>
<div class="line"><span class="lineno">  250</span>        <span class="comment"># there are 6 pts to identify per &#39;old&#39; triangle, 3 new_pt_corner and</span></div>
<div class="line"><span class="lineno">  251</span>        <span class="comment"># 3 new_pt_midside</span></div>
<div class="line"><span class="lineno">  252</span>        new_pt_corner = triangles</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>        <span class="comment"># What is the index in refi_x, refi_y of point at middle of apex iapex</span></div>
<div class="line"><span class="lineno">  255</span>        <span class="comment">#  of elem ielem ?</span></div>
<div class="line"><span class="lineno">  256</span>        <span class="comment"># If ielem is the apex master: simple count, given the way refi_x was</span></div>
<div class="line"><span class="lineno">  257</span>        <span class="comment">#  built.</span></div>
<div class="line"><span class="lineno">  258</span>        <span class="comment"># If ielem is the apex slave: yet we do not know; but we will soon</span></div>
<div class="line"><span class="lineno">  259</span>        <span class="comment"># using the neighbors table.</span></div>
<div class="line"><span class="lineno">  260</span>        new_pt_midside = np.empty([ntri, 3], dtype=np.int32)</div>
<div class="line"><span class="lineno">  261</span>        cum_sum = npts</div>
<div class="line"><span class="lineno">  262</span>        <span class="keywordflow">for</span> imid <span class="keywordflow">in</span> range(3):</div>
<div class="line"><span class="lineno">  263</span>            mask_st_loc = (imid == apex_masters)</div>
<div class="line"><span class="lineno">  264</span>            n_masters_loc = np.sum(mask_st_loc)</div>
<div class="line"><span class="lineno">  265</span>            elem_masters_loc = masters[mask_st_loc]</div>
<div class="line"><span class="lineno">  266</span>            new_pt_midside[:, imid][elem_masters_loc] = np.arange(</div>
<div class="line"><span class="lineno">  267</span>                n_masters_loc, dtype=np.int32) + cum_sum</div>
<div class="line"><span class="lineno">  268</span>            cum_sum += n_masters_loc</div>
<div class="line"><span class="lineno">  269</span> </div>
<div class="line"><span class="lineno">  270</span>        <span class="comment"># Now dealing with slave elems.</span></div>
<div class="line"><span class="lineno">  271</span>        <span class="comment"># for each slave element we identify the master and then the inode</span></div>
<div class="line"><span class="lineno">  272</span>        <span class="comment"># once slave_masters is identified, slave_masters_apex is such that:</span></div>
<div class="line"><span class="lineno">  273</span>        <span class="comment"># neighbors[slaves_masters, slave_masters_apex] == slaves</span></div>
<div class="line"><span class="lineno">  274</span>        mask_slaves = np.logical_not(mask_masters)</div>
<div class="line"><span class="lineno">  275</span>        slaves = edge_elems[mask_slaves]</div>
<div class="line"><span class="lineno">  276</span>        slaves_masters = edge_neighbors[mask_slaves]</div>
<div class="line"><span class="lineno">  277</span>        diff_table = np.abs(neighbors[slaves_masters, :] -</div>
<div class="line"><span class="lineno">  278</span>                            np.outer(slaves, np.ones(3, dtype=np.int32)))</div>
<div class="line"><span class="lineno">  279</span>        slave_masters_apex = np.argmin(diff_table, axis=1)</div>
<div class="line"><span class="lineno">  280</span>        slaves_apex = edge_apexes[mask_slaves]</div>
<div class="line"><span class="lineno">  281</span>        new_pt_midside[slaves, slaves_apex] = new_pt_midside[</div>
<div class="line"><span class="lineno">  282</span>            slaves_masters, slave_masters_apex]</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>        <span class="comment"># Builds the 4 child masked_triangles</span></div>
<div class="line"><span class="lineno">  285</span>        child_triangles = np.empty([ntri*4, 3], dtype=np.int32)</div>
<div class="line"><span class="lineno">  286</span>        child_triangles[0::4, :] = np.vstack([</div>
<div class="line"><span class="lineno">  287</span>            new_pt_corner[:, 0], new_pt_midside[:, 0],</div>
<div class="line"><span class="lineno">  288</span>            new_pt_midside[:, 2]]).T</div>
<div class="line"><span class="lineno">  289</span>        child_triangles[1::4, :] = np.vstack([</div>
<div class="line"><span class="lineno">  290</span>            new_pt_corner[:, 1], new_pt_midside[:, 1],</div>
<div class="line"><span class="lineno">  291</span>            new_pt_midside[:, 0]]).T</div>
<div class="line"><span class="lineno">  292</span>        child_triangles[2::4, :] = np.vstack([</div>
<div class="line"><span class="lineno">  293</span>            new_pt_corner[:, 2], new_pt_midside[:, 2],</div>
<div class="line"><span class="lineno">  294</span>            new_pt_midside[:, 1]]).T</div>
<div class="line"><span class="lineno">  295</span>        child_triangles[3::4, :] = np.vstack([</div>
<div class="line"><span class="lineno">  296</span>            new_pt_midside[:, 0], new_pt_midside[:, 1],</div>
<div class="line"><span class="lineno">  297</span>            new_pt_midside[:, 2]]).T</div>
<div class="line"><span class="lineno">  298</span>        child_triangulation = Triangulation(refi_x, refi_y, child_triangles)</div>
<div class="line"><span class="lineno">  299</span> </div>
<div class="line"><span class="lineno">  300</span>        <span class="comment"># Builds the child mask</span></div>
<div class="line"><span class="lineno">  301</span>        <span class="keywordflow">if</span> triangulation.mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  302</span>            child_triangulation.set_mask(np.repeat(triangulation.mask, 4))</div>
<div class="line"><span class="lineno">  303</span> </div>
<div class="line"><span class="lineno">  304</span>        <span class="keywordflow">if</span> ancestors <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  305</span>            <span class="keywordflow">return</span> child_triangulation</div>
<div class="line"><span class="lineno">  306</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  307</span>            <span class="keywordflow">return</span> child_triangulation, np.repeat(ancestors, 4)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1988d36d23832643e593cf0e0bee8821" name="a1988d36d23832643e593cf0e0bee8821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1988d36d23832643e593cf0e0bee8821">&#9670;&#160;</a></span>refine_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tri.trirefine.UniformTriRefiner.refine_field </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>triinterpolator</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subdiv</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Refine a field defined on the encapsulated triangulation.

Parameters
----------
z : (npoints,) array-like
    Values of the field to refine, defined at the nodes of the
    encapsulated triangulation. (``n_points`` is the number of points
    in the initial triangulation)
triinterpolator : `~matplotlib.tri.TriInterpolator`, optional
    Interpolator used for field interpolation. If not specified,
    a `~matplotlib.tri.CubicTriInterpolator` will be used.
subdiv : int, default: 3
    Recursion level for the subdivision.
    Each triangle is divided into ``4**subdiv`` child triangles.

Returns
-------
refi_tri : `~matplotlib.tri.Triangulation`
     The returned refined triangulation.
refi_z : 1D array of length: *refi_tri* node count.
     The returned interpolated field (at *refi_tri* nodes).
</pre> <div class="fragment"><div class="line"><span class="lineno">  133</span>    <span class="keyword">def </span>refine_field(self, z, triinterpolator=None, subdiv=3):</div>
<div class="line"><span class="lineno">  134</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">        Refine a field defined on the encapsulated triangulation.</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        z : (npoints,) array-like</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">            Values of the field to refine, defined at the nodes of the</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">            encapsulated triangulation. (``n_points`` is the number of points</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">            in the initial triangulation)</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        triinterpolator : `~matplotlib.tri.TriInterpolator`, optional</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">            Interpolator used for field interpolation. If not specified,</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">            a `~matplotlib.tri.CubicTriInterpolator` will be used.</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">        subdiv : int, default: 3</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">            Recursion level for the subdivision.</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">            Each triangle is divided into ``4**subdiv`` child triangles.</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        refi_tri : `~matplotlib.tri.Triangulation`</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">             The returned refined triangulation.</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        refi_z : 1D array of length: *refi_tri* node count.</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">             The returned interpolated field (at *refi_tri* nodes).</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  157</span>        <span class="keywordflow">if</span> triinterpolator <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  158</span>            interp = <a class="code hl_class" href="classmatplotlib_1_1tri_1_1triinterpolate_1_1_cubic_tri_interpolator.html">matplotlib.tri.CubicTriInterpolator</a>(</div>
<div class="line"><span class="lineno">  159</span>                self._triangulation, z)</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  161</span>            _api.check_isinstance(<a class="code hl_class" href="classmatplotlib_1_1tri_1_1triinterpolate_1_1_tri_interpolator.html">matplotlib.tri.TriInterpolator</a>,</div>
<div class="line"><span class="lineno">  162</span>                                  triinterpolator=triinterpolator)</div>
<div class="line"><span class="lineno">  163</span>            interp = triinterpolator</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>        refi_tri, found_index = self.refine_triangulation(</div>
<div class="line"><span class="lineno">  166</span>            subdiv=subdiv, return_tri_index=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  167</span>        refi_z = interp._interpolate_multikeys(</div>
<div class="line"><span class="lineno">  168</span>            refi_tri.x, refi_tri.y, tri_index=found_index)[0]</div>
<div class="line"><span class="lineno">  169</span>        <span class="keywordflow">return</span> refi_tri, refi_z</div>
<div class="line"><span class="lineno">  170</span> </div>
<div class="ttc" id="aclassmatplotlib_1_1tri_1_1triinterpolate_1_1_cubic_tri_interpolator_html"><div class="ttname"><a href="classmatplotlib_1_1tri_1_1triinterpolate_1_1_cubic_tri_interpolator.html">matplotlib.tri.triinterpolate.CubicTriInterpolator</a></div><div class="ttdef"><b>Definition</b> triinterpolate.py:286</div></div>
<div class="ttc" id="aclassmatplotlib_1_1tri_1_1triinterpolate_1_1_tri_interpolator_html"><div class="ttname"><a href="classmatplotlib_1_1tri_1_1triinterpolate_1_1_tri_interpolator.html">matplotlib.tri.triinterpolate.TriInterpolator</a></div><div class="ttdef"><b>Definition</b> triinterpolate.py:15</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0229a48fd1e399f47b7f3b306f0e2793" name="a0229a48fd1e399f47b7f3b306f0e2793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0229a48fd1e399f47b7f3b306f0e2793">&#9670;&#160;</a></span>refine_triangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tri.trirefine.UniformTriRefiner.refine_triangulation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_tri_index</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subdiv</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute an uniformly refined triangulation *refi_triangulation* of
the encapsulated :attr:`triangulation`.

This function refines the encapsulated triangulation by splitting each
father triangle into 4 child sub-triangles built on the edges midside
nodes, recursing *subdiv* times.  In the end, each triangle is hence
divided into ``4**subdiv`` child triangles.

Parameters
----------
return_tri_index : bool, default: False
    Whether an index table indicating the father triangle index of each
    point is returned.
subdiv : int, default: 3
    Recursion level for the subdivision.
    Each triangle is divided into ``4**subdiv`` child triangles;
    hence, the default results in 64 refined subtriangles for each
    triangle of the initial triangulation.

Returns
-------
refi_triangulation : `~matplotlib.tri.Triangulation`
    The refined triangulation.
found_index : int array
    Index of the initial triangulation containing triangle, for each
    point of *refi_triangulation*.
    Returned only if *return_tri_index* is set to True.
</pre> <div class="fragment"><div class="line"><span class="lineno">   64</span>    <span class="keyword">def </span>refine_triangulation(self, return_tri_index=False, subdiv=3):</div>
<div class="line"><span class="lineno">   65</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        Compute an uniformly refined triangulation *refi_triangulation* of</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">        the encapsulated :attr:`triangulation`.</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">        This function refines the encapsulated triangulation by splitting each</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">        father triangle into 4 child sub-triangles built on the edges midside</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">        nodes, recursing *subdiv* times.  In the end, each triangle is hence</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">        divided into ``4**subdiv`` child triangles.</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">        return_tri_index : bool, default: False</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">            Whether an index table indicating the father triangle index of each</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">            point is returned.</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        subdiv : int, default: 3</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">            Recursion level for the subdivision.</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">            Each triangle is divided into ``4**subdiv`` child triangles;</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">            hence, the default results in 64 refined subtriangles for each</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">            triangle of the initial triangulation.</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        refi_triangulation : `~matplotlib.tri.Triangulation`</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">            The refined triangulation.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        found_index : int array</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">            Index of the initial triangulation containing triangle, for each</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">            point of *refi_triangulation*.</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">            Returned only if *return_tri_index* is set to True.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   94</span>        refi_triangulation = self._triangulation</div>
<div class="line"><span class="lineno">   95</span>        ntri = refi_triangulation.triangles.shape[0]</div>
<div class="line"><span class="lineno">   96</span> </div>
<div class="line"><span class="lineno">   97</span>        <span class="comment"># Computes the triangulation ancestors numbers in the reference</span></div>
<div class="line"><span class="lineno">   98</span>        <span class="comment"># triangulation.</span></div>
<div class="line"><span class="lineno">   99</span>        ancestors = np.arange(ntri, dtype=np.int32)</div>
<div class="line"><span class="lineno">  100</span>        <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(subdiv):</div>
<div class="line"><span class="lineno">  101</span>            refi_triangulation, ancestors = self._refine_triangulation_once(</div>
<div class="line"><span class="lineno">  102</span>                refi_triangulation, ancestors)</div>
<div class="line"><span class="lineno">  103</span>        refi_npts = refi_triangulation.x.shape[0]</div>
<div class="line"><span class="lineno">  104</span>        refi_triangles = refi_triangulation.triangles</div>
<div class="line"><span class="lineno">  105</span> </div>
<div class="line"><span class="lineno">  106</span>        <span class="comment"># Now we compute found_index table if needed</span></div>
<div class="line"><span class="lineno">  107</span>        <span class="keywordflow">if</span> return_tri_index:</div>
<div class="line"><span class="lineno">  108</span>            <span class="comment"># We have to initialize found_index with -1 because some nodes</span></div>
<div class="line"><span class="lineno">  109</span>            <span class="comment"># may very well belong to no triangle at all, e.g., in case of</span></div>
<div class="line"><span class="lineno">  110</span>            <span class="comment"># Delaunay Triangulation with DuplicatePointWarning.</span></div>
<div class="line"><span class="lineno">  111</span>            found_index = np.full(refi_npts, -1, dtype=np.int32)</div>
<div class="line"><span class="lineno">  112</span>            tri_mask = self._triangulation.mask</div>
<div class="line"><span class="lineno">  113</span>            <span class="keywordflow">if</span> tri_mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  114</span>                found_index[refi_triangles] = np.repeat(ancestors,</div>
<div class="line"><span class="lineno">  115</span>                                                        3).reshape(-1, 3)</div>
<div class="line"><span class="lineno">  116</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  117</span>                <span class="comment"># There is a subtlety here: we want to avoid whenever possible</span></div>
<div class="line"><span class="lineno">  118</span>                <span class="comment"># that refined points container is a masked triangle (which</span></div>
<div class="line"><span class="lineno">  119</span>                <span class="comment"># would result in artifacts in plots).</span></div>
<div class="line"><span class="lineno">  120</span>                <span class="comment"># So we impose the numbering from masked ancestors first,</span></div>
<div class="line"><span class="lineno">  121</span>                <span class="comment"># then overwrite it with unmasked ancestor numbers.</span></div>
<div class="line"><span class="lineno">  122</span>                ancestor_mask = tri_mask[ancestors]</div>
<div class="line"><span class="lineno">  123</span>                found_index[refi_triangles[ancestor_mask, :]</div>
<div class="line"><span class="lineno">  124</span>                            ] = np.repeat(ancestors[ancestor_mask],</div>
<div class="line"><span class="lineno">  125</span>                                          3).reshape(-1, 3)</div>
<div class="line"><span class="lineno">  126</span>                found_index[refi_triangles[~ancestor_mask, :]</div>
<div class="line"><span class="lineno">  127</span>                            ] = np.repeat(ancestors[~ancestor_mask],</div>
<div class="line"><span class="lineno">  128</span>                                          3).reshape(-1, 3)</div>
<div class="line"><span class="lineno">  129</span>            <span class="keywordflow">return</span> refi_triangulation, found_index</div>
<div class="line"><span class="lineno">  130</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  131</span>            <span class="keywordflow">return</span> refi_triangulation</div>
<div class="line"><span class="lineno">  132</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac6f401999991f387d7bb32352c654e72" name="ac6f401999991f387d7bb32352c654e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f401999991f387d7bb32352c654e72">&#9670;&#160;</a></span>_triangulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tri.trirefine.UniformTriRefiner._triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/matplotlib/tri/<a class="el" href="trirefine_8py.html">trirefine.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
