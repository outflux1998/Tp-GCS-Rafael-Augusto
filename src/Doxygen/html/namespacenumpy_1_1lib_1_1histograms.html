<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.histograms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html">histograms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.histograms Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad3314ea21e4ff6c81eaa1b423a66f171" id="r_ad3314ea21e4ff6c81eaa1b423a66f171"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#ad3314ea21e4ff6c81eaa1b423a66f171">_ptp</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:ad3314ea21e4ff6c81eaa1b423a66f171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbfcb13190c913bd87e799661e452b8" id="r_aafbfcb13190c913bd87e799661e452b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#aafbfcb13190c913bd87e799661e452b8">_hist_bin_sqrt</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:aafbfcb13190c913bd87e799661e452b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288e172ec0079a61cc389b38f7d2343e" id="r_a288e172ec0079a61cc389b38f7d2343e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a288e172ec0079a61cc389b38f7d2343e">_hist_bin_sturges</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:a288e172ec0079a61cc389b38f7d2343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0f65adb8503e33d1e99f2521eb5526" id="r_a0f0f65adb8503e33d1e99f2521eb5526"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a0f0f65adb8503e33d1e99f2521eb5526">_hist_bin_rice</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:a0f0f65adb8503e33d1e99f2521eb5526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2958f93b6c39a8844691cac38cc70504" id="r_a2958f93b6c39a8844691cac38cc70504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a2958f93b6c39a8844691cac38cc70504">_hist_bin_scott</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:a2958f93b6c39a8844691cac38cc70504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07746ecf9693029d574067b8eae169fa" id="r_a07746ecf9693029d574067b8eae169fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a07746ecf9693029d574067b8eae169fa">_hist_bin_stone</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:a07746ecf9693029d574067b8eae169fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae177c807f9a286c50d66afb7d990954d" id="r_ae177c807f9a286c50d66afb7d990954d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#ae177c807f9a286c50d66afb7d990954d">_hist_bin_doane</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:ae177c807f9a286c50d66afb7d990954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316b08ec0e08953eb2174d00bbbd6117" id="r_a316b08ec0e08953eb2174d00bbbd6117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a316b08ec0e08953eb2174d00bbbd6117">_hist_bin_fd</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:a316b08ec0e08953eb2174d00bbbd6117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33949758b257bff326f39bd1bb20b51" id="r_ac33949758b257bff326f39bd1bb20b51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#ac33949758b257bff326f39bd1bb20b51">_hist_bin_auto</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, range)</td></tr>
<tr class="separator:ac33949758b257bff326f39bd1bb20b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c0d08165a4d0a27bcc814084e909d" id="r_acd7c0d08165a4d0a27bcc814084e909d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#acd7c0d08165a4d0a27bcc814084e909d">_ravel_and_check_weights</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, weights)</td></tr>
<tr class="separator:acd7c0d08165a4d0a27bcc814084e909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ec6772d9289fe270a4148eb72d4c19" id="r_aa8ec6772d9289fe270a4148eb72d4c19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#aa8ec6772d9289fe270a4148eb72d4c19">_get_outer_edges</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, range)</td></tr>
<tr class="separator:aa8ec6772d9289fe270a4148eb72d4c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d212c4ab6e7e1d0e4499a928a195c" id="r_a5a6d212c4ab6e7e1d0e4499a928a195c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a5a6d212c4ab6e7e1d0e4499a928a195c">_unsigned_subtract</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b)</td></tr>
<tr class="separator:a5a6d212c4ab6e7e1d0e4499a928a195c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c7a0439e30aeb55393b16bf4ff57b2" id="r_a55c7a0439e30aeb55393b16bf4ff57b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a55c7a0439e30aeb55393b16bf4ff57b2">_get_bin_edges</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, bins, range, weights)</td></tr>
<tr class="separator:a55c7a0439e30aeb55393b16bf4ff57b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dff695fdee709c8982629c411a07003" id="r_a1dff695fdee709c8982629c411a07003"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a1dff695fdee709c8982629c411a07003">_search_sorted_inclusive</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, v)</td></tr>
<tr class="separator:a1dff695fdee709c8982629c411a07003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b8d0dc9db0d5674b8a2ea793e09b2b" id="r_a04b8d0dc9db0d5674b8a2ea793e09b2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a04b8d0dc9db0d5674b8a2ea793e09b2b">_histogram_bin_edges_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, bins=None, range=None, weights=None)</td></tr>
<tr class="separator:a04b8d0dc9db0d5674b8a2ea793e09b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05ae305dd68979bf6b84053bd2513b8" id="r_ab05ae305dd68979bf6b84053bd2513b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#ab05ae305dd68979bf6b84053bd2513b8">histogram_bin_edges</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, bins=10, range=None, weights=None)</td></tr>
<tr class="separator:ab05ae305dd68979bf6b84053bd2513b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31338b1a13ebac8206fc4ed927a610b9" id="r_a31338b1a13ebac8206fc4ed927a610b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a31338b1a13ebac8206fc4ed927a610b9">_histogram_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, bins=None, range=None, density=None, weights=None)</td></tr>
<tr class="separator:a31338b1a13ebac8206fc4ed927a610b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5c7f381c27238f6fa721e56110e0f1" id="r_a5f5c7f381c27238f6fa721e56110e0f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a5f5c7f381c27238f6fa721e56110e0f1">histogram</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, bins=10, range=None, density=None, weights=None)</td></tr>
<tr class="separator:a5f5c7f381c27238f6fa721e56110e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad262a20ad669ab34f663970a688c3a" id="r_a8ad262a20ad669ab34f663970a688c3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a8ad262a20ad669ab34f663970a688c3a">_histogramdd_dispatcher</a> (sample, bins=None, range=None, density=None, weights=None)</td></tr>
<tr class="separator:a8ad262a20ad669ab34f663970a688c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f2714792f560ae21867fa81b0826a7" id="r_ac7f2714792f560ae21867fa81b0826a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#ac7f2714792f560ae21867fa81b0826a7">histogramdd</a> (sample, bins=10, range=None, density=None, weights=None)</td></tr>
<tr class="separator:ac7f2714792f560ae21867fa81b0826a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a773227587f144e5334133beb38236128" id="r_a773227587f144e5334133beb38236128"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a773227587f144e5334133beb38236128">array_function_dispatch</a></td></tr>
<tr class="separator:a773227587f144e5334133beb38236128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadab085e4d176a8e2898f4716e1a261f" id="r_aadab085e4d176a8e2898f4716e1a261f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#aadab085e4d176a8e2898f4716e1a261f">_range</a> = range</td></tr>
<tr class="separator:aadab085e4d176a8e2898f4716e1a261f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca28a0d689bfafe2a730abb5e4aca87" id="r_a9ca28a0d689bfafe2a730abb5e4aca87"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1histograms.html#a9ca28a0d689bfafe2a730abb5e4aca87">_hist_bin_selectors</a></td></tr>
<tr class="separator:a9ca28a0d689bfafe2a730abb5e4aca87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Histogram-related functions
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a55c7a0439e30aeb55393b16bf4ff57b2" name="a55c7a0439e30aeb55393b16bf4ff57b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c7a0439e30aeb55393b16bf4ff57b2">&#9670;&#160;</a></span>_get_bin_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._get_bin_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computes the bins used internally by `histogram`.

Parameters
==========
a : ndarray
    Ravelled data array
bins, range
    Forwarded arguments from `histogram`.
weights : ndarray, optional
    Ravelled weights array, or None

Returns
=======
bin_edges : ndarray
    Array of bin edges
uniform_bins : (Number, Number, int):
    The upper bound, lowerbound, and number of bins, used in the optimized
    implementation of `histogram` that works on uniform bins.
</pre> <div class="fragment"><div class="line"><span class="lineno">  360</span><span class="keyword">def </span>_get_bin_edges(a, bins, range, weights):</div>
<div class="line"><span class="lineno">  361</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    Computes the bins used internally by `histogram`.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    ==========</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">        Ravelled data array</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    bins, range</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">        Forwarded arguments from `histogram`.</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    weights : ndarray, optional</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">        Ravelled weights array, or None</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    =======</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    bin_edges : ndarray</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        Array of bin edges</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    uniform_bins : (Number, Number, int):</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        The upper bound, lowerbound, and number of bins, used in the optimized</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        implementation of `histogram` that works on uniform bins.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  381</span>    <span class="comment"># parse the overloaded bins argument</span></div>
<div class="line"><span class="lineno">  382</span>    n_equal_bins = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  383</span>    bin_edges = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span>    <span class="keywordflow">if</span> isinstance(bins, str):</div>
<div class="line"><span class="lineno">  386</span>        bin_name = bins</div>
<div class="line"><span class="lineno">  387</span>        <span class="comment"># if `bins` is a string for an automatic method,</span></div>
<div class="line"><span class="lineno">  388</span>        <span class="comment"># this will replace it with the number of bins calculated</span></div>
<div class="line"><span class="lineno">  389</span>        <span class="keywordflow">if</span> bin_name <span class="keywordflow">not</span> <span class="keywordflow">in</span> _hist_bin_selectors:</div>
<div class="line"><span class="lineno">  390</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  391</span>                <span class="stringliteral">&quot;{!r} is not a valid estimator for `bins`&quot;</span>.format(bin_name))</div>
<div class="line"><span class="lineno">  392</span>        <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  393</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Automated estimation of the number of &quot;</span></div>
<div class="line"><span class="lineno">  394</span>                            <span class="stringliteral">&quot;bins is not supported for weighted data&quot;</span>)</div>
<div class="line"><span class="lineno">  395</span> </div>
<div class="line"><span class="lineno">  396</span>        first_edge, last_edge = _get_outer_edges(a, range)</div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span>        <span class="comment"># truncate the range if needed</span></div>
<div class="line"><span class="lineno">  399</span>        <span class="keywordflow">if</span> range <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  400</span>            keep = (a &gt;= first_edge)</div>
<div class="line"><span class="lineno">  401</span>            keep &amp;= (a &lt;= last_edge)</div>
<div class="line"><span class="lineno">  402</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.logical_and.reduce(keep):</div>
<div class="line"><span class="lineno">  403</span>                a = a[keep]</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>        <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno">  406</span>            n_equal_bins = 1</div>
<div class="line"><span class="lineno">  407</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  408</span>            <span class="comment"># Do not call selectors on empty arrays</span></div>
<div class="line"><span class="lineno">  409</span>            width = _hist_bin_selectors[bin_name](a, (first_edge, last_edge))</div>
<div class="line"><span class="lineno">  410</span>            <span class="keywordflow">if</span> width:</div>
<div class="line"><span class="lineno">  411</span>                n_equal_bins = int(np.ceil(_unsigned_subtract(last_edge, first_edge) / width))</div>
<div class="line"><span class="lineno">  412</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  413</span>                <span class="comment"># Width can be zero for some estimators, e.g. FD when</span></div>
<div class="line"><span class="lineno">  414</span>                <span class="comment"># the IQR of the data is zero.</span></div>
<div class="line"><span class="lineno">  415</span>                n_equal_bins = 1</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">elif</span> np.ndim(bins) == 0:</div>
<div class="line"><span class="lineno">  418</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  419</span>            n_equal_bins = operator.index(bins)</div>
<div class="line"><span class="lineno">  420</span>        <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  421</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  422</span>                <span class="stringliteral">&#39;`bins` must be an integer, a string, or an array&#39;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  423</span>        <span class="keywordflow">if</span> n_equal_bins &lt; 1:</div>
<div class="line"><span class="lineno">  424</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;`bins` must be positive, when an integer&#39;</span>)</div>
<div class="line"><span class="lineno">  425</span> </div>
<div class="line"><span class="lineno">  426</span>        first_edge, last_edge = _get_outer_edges(a, range)</div>
<div class="line"><span class="lineno">  427</span> </div>
<div class="line"><span class="lineno">  428</span>    <span class="keywordflow">elif</span> np.ndim(bins) == 1:</div>
<div class="line"><span class="lineno">  429</span>        bin_edges = np.asarray(bins)</div>
<div class="line"><span class="lineno">  430</span>        <span class="keywordflow">if</span> np.any(bin_edges[:-1] &gt; bin_edges[1:]):</div>
<div class="line"><span class="lineno">  431</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  432</span>                <span class="stringliteral">&#39;`bins` must increase monotonically, when an array&#39;</span>)</div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  435</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;`bins` must be 1d, when an array&#39;</span>)</div>
<div class="line"><span class="lineno">  436</span> </div>
<div class="line"><span class="lineno">  437</span>    <span class="keywordflow">if</span> n_equal_bins <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  438</span>        <span class="comment"># gh-10322 means that type resolution rules are dependent on array</span></div>
<div class="line"><span class="lineno">  439</span>        <span class="comment"># shapes. To avoid this causing problems, we pick a type now and stick</span></div>
<div class="line"><span class="lineno">  440</span>        <span class="comment"># with it throughout.</span></div>
<div class="line"><span class="lineno">  441</span>        bin_type = np.result_type(first_edge, last_edge, a)</div>
<div class="line"><span class="lineno">  442</span>        <span class="keywordflow">if</span> np.issubdtype(bin_type, np.integer):</div>
<div class="line"><span class="lineno">  443</span>            bin_type = np.result_type(bin_type, float)</div>
<div class="line"><span class="lineno">  444</span> </div>
<div class="line"><span class="lineno">  445</span>        <span class="comment"># bin edges must be computed</span></div>
<div class="line"><span class="lineno">  446</span>        bin_edges = np.linspace(</div>
<div class="line"><span class="lineno">  447</span>            first_edge, last_edge, n_equal_bins + 1,</div>
<div class="line"><span class="lineno">  448</span>            endpoint=<span class="keyword">True</span>, dtype=bin_type)</div>
<div class="line"><span class="lineno">  449</span>        <span class="keywordflow">return</span> bin_edges, (first_edge, last_edge, n_equal_bins)</div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  451</span>        <span class="keywordflow">return</span> bin_edges, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  452</span> </div>
<div class="line"><span class="lineno">  453</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8ec6772d9289fe270a4148eb72d4c19" name="aa8ec6772d9289fe270a4148eb72d4c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ec6772d9289fe270a4148eb72d4c19">&#9670;&#160;</a></span>_get_outer_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._get_outer_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Determine the outer bin edges to use, from either the data or the range
argument
</pre> <div class="fragment"><div class="line"><span class="lineno">  304</span><span class="keyword">def </span>_get_outer_edges(a, range):</div>
<div class="line"><span class="lineno">  305</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    Determine the outer bin edges to use, from either the data or the range</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    argument</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  309</span>    <span class="keywordflow">if</span> range <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  310</span>        first_edge, last_edge = range</div>
<div class="line"><span class="lineno">  311</span>        <span class="keywordflow">if</span> first_edge &gt; last_edge:</div>
<div class="line"><span class="lineno">  312</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  313</span>                <span class="stringliteral">&#39;max must be larger than min in range parameter.&#39;</span>)</div>
<div class="line"><span class="lineno">  314</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (np.isfinite(first_edge) <span class="keywordflow">and</span> np.isfinite(last_edge)):</div>
<div class="line"><span class="lineno">  315</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  316</span>                <span class="stringliteral">&quot;supplied range of [{}, {}] is not finite&quot;</span>.format(first_edge, last_edge))</div>
<div class="line"><span class="lineno">  317</span>    <span class="keywordflow">elif</span> a.size == 0:</div>
<div class="line"><span class="lineno">  318</span>        <span class="comment"># handle empty arrays. Can&#39;t determine range, so use 0-1.</span></div>
<div class="line"><span class="lineno">  319</span>        first_edge, last_edge = 0, 1</div>
<div class="line"><span class="lineno">  320</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  321</span>        first_edge, last_edge = a.min(), a.max()</div>
<div class="line"><span class="lineno">  322</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (np.isfinite(first_edge) <span class="keywordflow">and</span> np.isfinite(last_edge)):</div>
<div class="line"><span class="lineno">  323</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  324</span>                <span class="stringliteral">&quot;autodetected range of [{}, {}] is not finite&quot;</span>.format(first_edge, last_edge))</div>
<div class="line"><span class="lineno">  325</span> </div>
<div class="line"><span class="lineno">  326</span>    <span class="comment"># expand empty range to avoid divide by zero</span></div>
<div class="line"><span class="lineno">  327</span>    <span class="keywordflow">if</span> first_edge == last_edge:</div>
<div class="line"><span class="lineno">  328</span>        first_edge = first_edge - 0.5</div>
<div class="line"><span class="lineno">  329</span>        last_edge = last_edge + 0.5</div>
<div class="line"><span class="lineno">  330</span> </div>
<div class="line"><span class="lineno">  331</span>    <span class="keywordflow">return</span> first_edge, last_edge</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac33949758b257bff326f39bd1bb20b51" name="ac33949758b257bff326f39bd1bb20b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33949758b257bff326f39bd1bb20b51">&#9670;&#160;</a></span>_hist_bin_auto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_auto </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Histogram bin estimator that uses the minimum width of the
Freedman-Diaconis and Sturges estimators if the FD bin width is non-zero.
If the bin width from the FD estimator is 0, the Sturges estimator is used.

The FD estimator is usually the most robust method, but its width
estimate tends to be too large for small `x` and bad for data with limited
variance. The Sturges estimator is quite good for small (&lt;1000) datasets
and is the default in the R language. This method gives good off-the-shelf
behaviour.

.. versionchanged:: 1.15.0
If there is limited variance the IQR can be 0, which results in the
FD bin width being 0 too. This is not a valid bin width, so
``np.histogram_bin_edges`` chooses 1 bin instead, which may not be optimal.
If the IQR is 0, it's unlikely any variance-based estimators will be of
use, so we revert to the Sturges estimator, which only uses the size of the
dataset in its calculation.

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.

Returns
-------
h : An estimate of the optimal bin width for the given data.

See Also
--------
_hist_bin_fd, _hist_bin_sturges
</pre> <div class="fragment"><div class="line"><span class="lineno">  229</span><span class="keyword">def </span>_hist_bin_auto(x, range):</div>
<div class="line"><span class="lineno">  230</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Histogram bin estimator that uses the minimum width of the</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    Freedman-Diaconis and Sturges estimators if the FD bin width is non-zero.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    If the bin width from the FD estimator is 0, the Sturges estimator is used.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    The FD estimator is usually the most robust method, but its width</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    estimate tends to be too large for small `x` and bad for data with limited</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    variance. The Sturges estimator is quite good for small (&lt;1000) datasets</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    and is the default in the R language. This method gives good off-the-shelf</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    behaviour.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    .. versionchanged:: 1.15.0</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    If there is limited variance the IQR can be 0, which results in the</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    FD bin width being 0 too. This is not a valid bin width, so</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    ``np.histogram_bin_edges`` chooses 1 bin instead, which may not be optimal.</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    If the IQR is 0, it&#39;s unlikely any variance-based estimators will be of</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    use, so we revert to the Sturges estimator, which only uses the size of the</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    dataset in its calculation.</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    _hist_bin_fd, _hist_bin_sturges</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  263</span>    fd_bw = _hist_bin_fd(x, range)</div>
<div class="line"><span class="lineno">  264</span>    sturges_bw = _hist_bin_sturges(x, range)</div>
<div class="line"><span class="lineno">  265</span>    del range  <span class="comment"># unused</span></div>
<div class="line"><span class="lineno">  266</span>    <span class="keywordflow">if</span> fd_bw:</div>
<div class="line"><span class="lineno">  267</span>        <span class="keywordflow">return</span> min(fd_bw, sturges_bw)</div>
<div class="line"><span class="lineno">  268</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  269</span>        <span class="comment"># limited variance, so we return a len dependent bw estimator</span></div>
<div class="line"><span class="lineno">  270</span>        <span class="keywordflow">return</span> sturges_bw</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span><span class="comment"># Private dict initialized at module load time</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae177c807f9a286c50d66afb7d990954d" name="ae177c807f9a286c50d66afb7d990954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae177c807f9a286c50d66afb7d990954d">&#9670;&#160;</a></span>_hist_bin_doane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_doane </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Doane's histogram bin estimator.

Improved version of Sturges' formula which works better for
non-normal data. See
stats.stackexchange.com/questions/55134/doanes-formula-for-histogram-binning

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.

Returns
-------
h : An estimate of the optimal bin width for the given data.
</pre> <div class="fragment"><div class="line"><span class="lineno">  164</span><span class="keyword">def </span>_hist_bin_doane(x, range):</div>
<div class="line"><span class="lineno">  165</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    Doane&#39;s histogram bin estimator.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    Improved version of Sturges&#39; formula which works better for</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    non-normal data. See</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    stats.stackexchange.com/questions/55134/doanes-formula-for-histogram-binning</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  182</span>    del range  <span class="comment"># unused</span></div>
<div class="line"><span class="lineno">  183</span>    <span class="keywordflow">if</span> x.size &gt; 2:</div>
<div class="line"><span class="lineno">  184</span>        sg1 = np.sqrt(6.0 * (x.size - 2) / ((x.size + 1.0) * (x.size + 3)))</div>
<div class="line"><span class="lineno">  185</span>        sigma = np.std(x)</div>
<div class="line"><span class="lineno">  186</span>        <span class="keywordflow">if</span> sigma &gt; 0.0:</div>
<div class="line"><span class="lineno">  187</span>            <span class="comment"># These three operations add up to</span></div>
<div class="line"><span class="lineno">  188</span>            <span class="comment"># g1 = np.mean(((x - np.mean(x)) / sigma)**3)</span></div>
<div class="line"><span class="lineno">  189</span>            <span class="comment"># but use only one temp array instead of three</span></div>
<div class="line"><span class="lineno">  190</span>            temp = x - np.mean(x)</div>
<div class="line"><span class="lineno">  191</span>            np.true_divide(temp, sigma, temp)</div>
<div class="line"><span class="lineno">  192</span>            np.power(temp, 3, temp)</div>
<div class="line"><span class="lineno">  193</span>            g1 = np.mean(temp)</div>
<div class="line"><span class="lineno">  194</span>            <span class="keywordflow">return</span> _ptp(x) / (1.0 + np.log2(x.size) +</div>
<div class="line"><span class="lineno">  195</span>                                    np.log2(1.0 + np.absolute(g1) / sg1))</div>
<div class="line"><span class="lineno">  196</span>    <span class="keywordflow">return</span> 0.0</div>
<div class="line"><span class="lineno">  197</span> </div>
<div class="line"><span class="lineno">  198</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a316b08ec0e08953eb2174d00bbbd6117" name="a316b08ec0e08953eb2174d00bbbd6117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316b08ec0e08953eb2174d00bbbd6117">&#9670;&#160;</a></span>_hist_bin_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_fd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The Freedman-Diaconis histogram bin estimator.

The Freedman-Diaconis rule uses interquartile range (IQR) to
estimate binwidth. It is considered a variation of the Scott rule
with more robustness as the IQR is less affected by outliers than
the standard deviation. However, the IQR depends on fewer points
than the standard deviation, so it is less accurate, especially for
long tailed distributions.

If the IQR is 0, this function returns 0 for the bin width.
Binwidth is inversely proportional to the cube root of data size
(asymptotically optimal).

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.

Returns
-------
h : An estimate of the optimal bin width for the given data.
</pre> <div class="fragment"><div class="line"><span class="lineno">  199</span><span class="keyword">def </span>_hist_bin_fd(x, range):</div>
<div class="line"><span class="lineno">  200</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    The Freedman-Diaconis histogram bin estimator.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    The Freedman-Diaconis rule uses interquartile range (IQR) to</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    estimate binwidth. It is considered a variation of the Scott rule</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    with more robustness as the IQR is less affected by outliers than</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    the standard deviation. However, the IQR depends on fewer points</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    than the standard deviation, so it is less accurate, especially for</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    long tailed distributions.</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    If the IQR is 0, this function returns 0 for the bin width.</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Binwidth is inversely proportional to the cube root of data size</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    (asymptotically optimal).</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  224</span>    del range  <span class="comment"># unused</span></div>
<div class="line"><span class="lineno">  225</span>    iqr = np.subtract(*np.percentile(x, [75, 25]))</div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">return</span> 2.0 * iqr * x.size ** (-1.0 / 3.0)</div>
<div class="line"><span class="lineno">  227</span> </div>
<div class="line"><span class="lineno">  228</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f0f65adb8503e33d1e99f2521eb5526" name="a0f0f65adb8503e33d1e99f2521eb5526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0f65adb8503e33d1e99f2521eb5526">&#9670;&#160;</a></span>_hist_bin_rice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_rice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Rice histogram bin estimator.

Another simple estimator with no normality assumption. It has better
performance for large data than Sturges, but tends to overestimate
the number of bins. The number of bins is proportional to the cube
root of data size (asymptotically optimal). The estimate depends
only on size of the data.

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.

Returns
-------
h : An estimate of the optimal bin width for the given data.
</pre> <div class="fragment"><div class="line"><span class="lineno">   76</span><span class="keyword">def </span>_hist_bin_rice(x, range):</div>
<div class="line"><span class="lineno">   77</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    Rice histogram bin estimator.</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    Another simple estimator with no normality assumption. It has better</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    performance for large data than Sturges, but tends to overestimate</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    the number of bins. The number of bins is proportional to the cube</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    root of data size (asymptotically optimal). The estimate depends</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    only on size of the data.</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   96</span>    del range  <span class="comment"># unused</span></div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">return</span> _ptp(x) / (2.0 * x.size ** (1.0 / 3))</div>
<div class="line"><span class="lineno">   98</span> </div>
<div class="line"><span class="lineno">   99</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2958f93b6c39a8844691cac38cc70504" name="a2958f93b6c39a8844691cac38cc70504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2958f93b6c39a8844691cac38cc70504">&#9670;&#160;</a></span>_hist_bin_scott()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_scott </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Scott histogram bin estimator.

The binwidth is proportional to the standard deviation of the data
and inversely proportional to the cube root of data size
(asymptotically optimal).

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.

Returns
-------
h : An estimate of the optimal bin width for the given data.
</pre> <div class="fragment"><div class="line"><span class="lineno">  100</span><span class="keyword">def </span>_hist_bin_scott(x, range):</div>
<div class="line"><span class="lineno">  101</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    Scott histogram bin estimator.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    The binwidth is proportional to the standard deviation of the data</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    and inversely proportional to the cube root of data size</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    (asymptotically optimal).</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  118</span>    del range  <span class="comment"># unused</span></div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">return</span> (24.0 * np.pi**0.5 / x.size)**(1.0 / 3.0) * np.std(x)</div>
<div class="line"><span class="lineno">  120</span> </div>
<div class="line"><span class="lineno">  121</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aafbfcb13190c913bd87e799661e452b8" name="aafbfcb13190c913bd87e799661e452b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbfcb13190c913bd87e799661e452b8">&#9670;&#160;</a></span>_hist_bin_sqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_sqrt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Square root histogram bin estimator.

Bin width is inversely proportional to the data size. Used by many
programs for its simplicity.

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.

Returns
-------
h : An estimate of the optimal bin width for the given data.
</pre> <div class="fragment"><div class="line"><span class="lineno">   32</span><span class="keyword">def </span>_hist_bin_sqrt(x, range):</div>
<div class="line"><span class="lineno">   33</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    Square root histogram bin estimator.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    Bin width is inversely proportional to the data size. Used by many</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    programs for its simplicity.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   49</span>    del range  <span class="comment"># unused</span></div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">return</span> _ptp(x) / np.sqrt(x.size)</div>
<div class="line"><span class="lineno">   51</span> </div>
<div class="line"><span class="lineno">   52</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a07746ecf9693029d574067b8eae169fa" name="a07746ecf9693029d574067b8eae169fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07746ecf9693029d574067b8eae169fa">&#9670;&#160;</a></span>_hist_bin_stone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_stone </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Histogram bin estimator based on minimizing the estimated integrated squared error (ISE).

The number of bins is chosen by minimizing the estimated ISE against the unknown true distribution.
The ISE is estimated using cross-validation and can be regarded as a generalization of Scott's rule.
https://en.wikipedia.org/wiki/Histogram#Scott.27s_normal_reference_rule

This paper by Stone appears to be the origination of this rule.
http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/34.pdf

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.
range : (float, float)
    The lower and upper range of the bins.

Returns
-------
h : An estimate of the optimal bin width for the given data.
</pre> <div class="fragment"><div class="line"><span class="lineno">  122</span><span class="keyword">def </span>_hist_bin_stone(x, range):</div>
<div class="line"><span class="lineno">  123</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    Histogram bin estimator based on minimizing the estimated integrated squared error (ISE).</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    The number of bins is chosen by minimizing the estimated ISE against the unknown true distribution.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    The ISE is estimated using cross-validation and can be regarded as a generalization of Scott&#39;s rule.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    https://en.wikipedia.org/wiki/Histogram#Scott.27s_normal_reference_rule</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    This paper by Stone appears to be the origination of this rule.</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/34.pdf</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    range : (float, float)</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        The lower and upper range of the bins.</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>    n = x.size</div>
<div class="line"><span class="lineno">  147</span>    ptp_x = _ptp(x)</div>
<div class="line"><span class="lineno">  148</span>    <span class="keywordflow">if</span> n &lt;= 1 <span class="keywordflow">or</span> ptp_x == 0:</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">return</span> 0</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>    <span class="keyword">def </span>jhat(nbins):</div>
<div class="line"><span class="lineno">  152</span>        hh = ptp_x / nbins</div>
<div class="line"><span class="lineno">  153</span>        p_k = np.histogram(x, bins=nbins, range=range)[0] / n</div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordflow">return</span> (2 - (n + 1) * p_k.dot(p_k)) / hh</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>    nbins_upper_bound = max(100, int(np.sqrt(n)))</div>
<div class="line"><span class="lineno">  157</span>    nbins = min(_range(1, nbins_upper_bound + 1), key=jhat)</div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">if</span> nbins == nbins_upper_bound:</div>
<div class="line"><span class="lineno">  159</span>        warnings.warn(<span class="stringliteral">&quot;The number of bins estimated may be suboptimal.&quot;</span>,</div>
<div class="line"><span class="lineno">  160</span>                      RuntimeWarning, stacklevel=3)</div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">return</span> ptp_x / nbins</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a288e172ec0079a61cc389b38f7d2343e" name="a288e172ec0079a61cc389b38f7d2343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288e172ec0079a61cc389b38f7d2343e">&#9670;&#160;</a></span>_hist_bin_sturges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._hist_bin_sturges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Sturges histogram bin estimator.

A very simplistic estimator based on the assumption of normality of
the data. This estimator has poor performance for non-normal data,
which becomes especially obvious for large data sets. The estimate
depends only on size of the data.

Parameters
----------
x : array_like
    Input data that is to be histogrammed, trimmed to range. May not
    be empty.

Returns
-------
h : An estimate of the optimal bin width for the given data.
</pre> <div class="fragment"><div class="line"><span class="lineno">   53</span><span class="keyword">def </span>_hist_bin_sturges(x, range):</div>
<div class="line"><span class="lineno">   54</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    Sturges histogram bin estimator.</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    A very simplistic estimator based on the assumption of normality of</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    the data. This estimator has poor performance for non-normal data,</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    which becomes especially obvious for large data sets. The estimate</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    depends only on size of the data.</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        Input data that is to be histogrammed, trimmed to range. May not</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        be empty.</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    h : An estimate of the optimal bin width for the given data.</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   72</span>    del range  <span class="comment"># unused</span></div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">return</span> _ptp(x) / (np.log2(x.size) + 1.0)</div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a04b8d0dc9db0d5674b8a2ea793e09b2b" name="a04b8d0dc9db0d5674b8a2ea793e09b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b8d0dc9db0d5674b8a2ea793e09b2b">&#9670;&#160;</a></span>_histogram_bin_edges_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._histogram_bin_edges_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  466</span><span class="keyword">def </span>_histogram_bin_edges_dispatcher(a, bins=None, range=None, weights=None):</div>
<div class="line"><span class="lineno">  467</span>    <span class="keywordflow">return</span> (a, bins, weights)</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span> </div>
<div class="line"><span class="lineno">  470</span><span class="preprocessor">@array_function_dispatch(_histogram_bin_edges_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a31338b1a13ebac8206fc4ed927a610b9" name="a31338b1a13ebac8206fc4ed927a610b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31338b1a13ebac8206fc4ed927a610b9">&#9670;&#160;</a></span>_histogram_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._histogram_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  674</span>        a, bins=<span class="keywordtype">None</span>, range=<span class="keywordtype">None</span>, density=<span class="keywordtype">None</span>, weights=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  675</span>    <span class="keywordflow">return</span> (a, bins, weights)</div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span><span class="preprocessor">@array_function_dispatch(_histogram_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ad262a20ad669ab34f663970a688c3a" name="a8ad262a20ad669ab34f663970a688c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad262a20ad669ab34f663970a688c3a">&#9670;&#160;</a></span>_histogramdd_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._histogramdd_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  889</span>                            weights=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  890</span>    <span class="keywordflow">if</span> hasattr(sample, <span class="stringliteral">&#39;shape&#39;</span>):  <span class="comment"># same condition as used in histogramdd</span></div>
<div class="line"><span class="lineno">  891</span>        <span class="keywordflow">yield</span> sample</div>
<div class="line"><span class="lineno">  892</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  893</span>        <span class="keywordflow">yield</span> <span class="keyword">from</span> sample</div>
<div class="line"><span class="lineno">  894</span>    <span class="keyword">with</span> contextlib.suppress(TypeError):</div>
<div class="line"><span class="lineno">  895</span>        <span class="keywordflow">yield</span> <span class="keyword">from</span> bins</div>
<div class="line"><span class="lineno">  896</span>    <span class="keywordflow">yield</span> weights</div>
<div class="line"><span class="lineno">  897</span> </div>
<div class="line"><span class="lineno">  898</span> </div>
<div class="line"><span class="lineno">  899</span><span class="preprocessor">@array_function_dispatch(_histogramdd_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3314ea21e4ff6c81eaa1b423a66f171" name="ad3314ea21e4ff6c81eaa1b423a66f171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3314ea21e4ff6c81eaa1b423a66f171">&#9670;&#160;</a></span>_ptp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._ptp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Peak-to-peak value of x.

This implementation avoids the problem of signed integer arrays having a
peak-to-peak value that cannot be represented with the array's data type.
This function returns an unsigned value for signed integer arrays.
</pre> <div class="fragment"><div class="line"><span class="lineno">   22</span><span class="keyword">def </span>_ptp(x):</div>
<div class="line"><span class="lineno">   23</span>    <span class="stringliteral">&quot;&quot;&quot;Peak-to-peak value of x.</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">    This implementation avoids the problem of signed integer arrays having a</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    peak-to-peak value that cannot be represented with the array&#39;s data type.</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    This function returns an unsigned value for signed integer arrays.</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   29</span>    <span class="keywordflow">return</span> _unsigned_subtract(x.max(), x.min())</div>
<div class="line"><span class="lineno">   30</span> </div>
<div class="line"><span class="lineno">   31</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acd7c0d08165a4d0a27bcc814084e909d" name="acd7c0d08165a4d0a27bcc814084e909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c0d08165a4d0a27bcc814084e909d">&#9670;&#160;</a></span>_ravel_and_check_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._ravel_and_check_weights </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Check a and weights have matching shapes, and ravel both </pre> <div class="fragment"><div class="line"><span class="lineno">  283</span><span class="keyword">def </span>_ravel_and_check_weights(a, weights):</div>
<div class="line"><span class="lineno">  284</span>    <span class="stringliteral">&quot;&quot;&quot; Check a and weights have matching shapes, and ravel both &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  285</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno">  286</span> </div>
<div class="line"><span class="lineno">  287</span>    <span class="comment"># Ensure that the array is a &quot;subtractable&quot; dtype</span></div>
<div class="line"><span class="lineno">  288</span>    <span class="keywordflow">if</span> a.dtype == np.bool_:</div>
<div class="line"><span class="lineno">  289</span>        warnings.warn(<span class="stringliteral">&quot;Converting input from {} to {} for compatibility.&quot;</span></div>
<div class="line"><span class="lineno">  290</span>                      .format(a.dtype, np.uint8),</div>
<div class="line"><span class="lineno">  291</span>                      RuntimeWarning, stacklevel=3)</div>
<div class="line"><span class="lineno">  292</span>        a = a.astype(np.uint8)</div>
<div class="line"><span class="lineno">  293</span> </div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  295</span>        weights = np.asarray(weights)</div>
<div class="line"><span class="lineno">  296</span>        <span class="keywordflow">if</span> weights.shape != a.shape:</div>
<div class="line"><span class="lineno">  297</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  298</span>                <span class="stringliteral">&#39;weights should have the same shape as a.&#39;</span>)</div>
<div class="line"><span class="lineno">  299</span>        weights = weights.ravel()</div>
<div class="line"><span class="lineno">  300</span>    a = a.ravel()</div>
<div class="line"><span class="lineno">  301</span>    <span class="keywordflow">return</span> a, weights</div>
<div class="line"><span class="lineno">  302</span> </div>
<div class="line"><span class="lineno">  303</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1dff695fdee709c8982629c411a07003" name="a1dff695fdee709c8982629c411a07003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dff695fdee709c8982629c411a07003">&#9670;&#160;</a></span>_search_sorted_inclusive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._search_sorted_inclusive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Like `searchsorted`, but where the last item in `v` is placed on the right.

In the context of a histogram, this makes the last bin edge inclusive
</pre> <div class="fragment"><div class="line"><span class="lineno">  454</span><span class="keyword">def </span>_search_sorted_inclusive(a, v):</div>
<div class="line"><span class="lineno">  455</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Like `searchsorted`, but where the last item in `v` is placed on the right.</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    In the context of a histogram, this makes the last bin edge inclusive</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">return</span> np.concatenate((</div>
<div class="line"><span class="lineno">  461</span>        a.searchsorted(v[:-1], <span class="stringliteral">&#39;left&#39;</span>),</div>
<div class="line"><span class="lineno">  462</span>        a.searchsorted(v[-1:], <span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno">  463</span>    ))</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a6d212c4ab6e7e1d0e4499a928a195c" name="a5a6d212c4ab6e7e1d0e4499a928a195c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6d212c4ab6e7e1d0e4499a928a195c">&#9670;&#160;</a></span>_unsigned_subtract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._unsigned_subtract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Subtract two values where a &gt;= b, and produce an unsigned result

This is needed when finding the difference between the upper and lower
bound of an int16 histogram
</pre> <div class="fragment"><div class="line"><span class="lineno">  334</span><span class="keyword">def </span>_unsigned_subtract(a, b):</div>
<div class="line"><span class="lineno">  335</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    Subtract two values where a &gt;= b, and produce an unsigned result</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    This is needed when finding the difference between the upper and lower</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    bound of an int16 histogram</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  341</span>    <span class="comment"># coerce to a single type</span></div>
<div class="line"><span class="lineno">  342</span>    signed_to_unsigned = {</div>
<div class="line"><span class="lineno">  343</span>        np.byte: np.ubyte,</div>
<div class="line"><span class="lineno">  344</span>        np.short: np.ushort,</div>
<div class="line"><span class="lineno">  345</span>        np.intc: np.uintc,</div>
<div class="line"><span class="lineno">  346</span>        np.int_: np.uint,</div>
<div class="line"><span class="lineno">  347</span>        np.longlong: np.ulonglong</div>
<div class="line"><span class="lineno">  348</span>    }</div>
<div class="line"><span class="lineno">  349</span>    dt = np.result_type(a, b)</div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  351</span>        dt = signed_to_unsigned[dt.type]</div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno">  353</span>        <span class="keywordflow">return</span> np.subtract(a, b, dtype=dt)</div>
<div class="line"><span class="lineno">  354</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  355</span>        <span class="comment"># we know the inputs are integers, and we are deliberately casting</span></div>
<div class="line"><span class="lineno">  356</span>        <span class="comment"># signed to unsigned</span></div>
<div class="line"><span class="lineno">  357</span>        <span class="keywordflow">return</span> np.subtract(a, b, casting=<span class="stringliteral">&#39;unsafe&#39;</span>, dtype=dt)</div>
<div class="line"><span class="lineno">  358</span> </div>
<div class="line"><span class="lineno">  359</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f5c7f381c27238f6fa721e56110e0f1" name="a5f5c7f381c27238f6fa721e56110e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5c7f381c27238f6fa721e56110e0f1">&#9670;&#160;</a></span>histogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms.histogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the histogram of a dataset.

Parameters
----------
a : array_like
    Input data. The histogram is computed over the flattened array.
bins : int or sequence of scalars or str, optional
    If `bins` is an int, it defines the number of equal-width
    bins in the given range (10, by default). If `bins` is a
    sequence, it defines a monotonically increasing array of bin edges,
    including the rightmost edge, allowing for non-uniform bin widths.

    .. versionadded:: 1.11.0

    If `bins` is a string, it defines the method used to calculate the
    optimal bin width, as defined by `histogram_bin_edges`.

range : (float, float), optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(a.min(), a.max())``.  Values outside the range are
    ignored. The first element of the range must be less than or
    equal to the second. `range` affects the automatic bin
    computation as well. While bin width is computed to be optimal
    based on the actual data within `range`, the bin count will fill
    the entire range including portions containing no data.
weights : array_like, optional
    An array of weights, of the same shape as `a`.  Each value in
    `a` only contributes its associated weight towards the bin count
    (instead of 1). If `density` is True, the weights are
    normalized, so that the integral of the density over the range
    remains 1.
density : bool, optional
    If ``False``, the result will contain the number of samples in
    each bin. If ``True``, the result is the value of the
    probability *density* function at the bin, normalized such that
    the *integral* over the range is 1. Note that the sum of the
    histogram values will not be equal to 1 unless bins of unity
    width are chosen; it is not a probability *mass* function.

Returns
-------
hist : array
    The values of the histogram. See `density` and `weights` for a
    description of the possible semantics.
bin_edges : array of dtype float
    Return the bin edges ``(length(hist)+1)``.


See Also
--------
histogramdd, bincount, searchsorted, digitize, histogram_bin_edges

Notes
-----
All but the last (righthand-most) bin is half-open.  In other words,
if `bins` is::

  [1, 2, 3, 4]

then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
*includes* 4.


Examples
--------
&gt;&gt;&gt; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])
(array([0, 2, 1]), array([0, 1, 2, 3]))
&gt;&gt;&gt; np.histogram(np.arange(4), bins=np.arange(5), density=True)
(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))
&gt;&gt;&gt; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
(array([1, 4, 1]), array([0, 1, 2, 3]))

&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; hist, bin_edges = np.histogram(a, density=True)
&gt;&gt;&gt; hist
array([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])
&gt;&gt;&gt; hist.sum()
2.4999999999999996
&gt;&gt;&gt; np.sum(hist * np.diff(bin_edges))
1.0

.. versionadded:: 1.11.0

Automated Bin Selection Methods example, using 2 peak random data
with 2000 points:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.RandomState(10)  # deterministic random data
&gt;&gt;&gt; a = np.hstack((rng.normal(size=1000),
...                rng.normal(loc=5, scale=2, size=1000)))
&gt;&gt;&gt; _ = plt.hist(a, bins='auto')  # arguments are passed to np.histogram
&gt;&gt;&gt; plt.title("Histogram with 'auto' bins")
Text(0.5, 1.0, "Histogram with 'auto' bins")
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  679</span><span class="keyword">def </span>histogram(a, bins=10, range=None, density=None, weights=None):</div>
<div class="line"><span class="lineno">  680</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    Compute the histogram of a dataset.</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">        Input data. The histogram is computed over the flattened array.</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    bins : int or sequence of scalars or str, optional</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        If `bins` is an int, it defines the number of equal-width</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        bins in the given range (10, by default). If `bins` is a</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        sequence, it defines a monotonically increasing array of bin edges,</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        including the rightmost edge, allowing for non-uniform bin widths.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        .. versionadded:: 1.11.0</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        If `bins` is a string, it defines the method used to calculate the</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">        optimal bin width, as defined by `histogram_bin_edges`.</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    range : (float, float), optional</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        The lower and upper range of the bins.  If not provided, range</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        is simply ``(a.min(), a.max())``.  Values outside the range are</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        ignored. The first element of the range must be less than or</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        equal to the second. `range` affects the automatic bin</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        computation as well. While bin width is computed to be optimal</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        based on the actual data within `range`, the bin count will fill</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">        the entire range including portions containing no data.</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">        An array of weights, of the same shape as `a`.  Each value in</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        `a` only contributes its associated weight towards the bin count</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">        (instead of 1). If `density` is True, the weights are</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">        normalized, so that the integral of the density over the range</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        remains 1.</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    density : bool, optional</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        If ``False``, the result will contain the number of samples in</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        each bin. If ``True``, the result is the value of the</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">        probability *density* function at the bin, normalized such that</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">        the *integral* over the range is 1. Note that the sum of the</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        histogram values will not be equal to 1 unless bins of unity</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">        width are chosen; it is not a probability *mass* function.</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    hist : array</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">        The values of the histogram. See `density` and `weights` for a</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">        description of the possible semantics.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    bin_edges : array of dtype float</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">        Return the bin edges ``(length(hist)+1)``.</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    histogramdd, bincount, searchsorted, digitize, histogram_bin_edges</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    All but the last (righthand-most) bin is half-open.  In other words,</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    if `bins` is::</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">      [1, 2, 3, 4]</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    *includes* 4.</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    &gt;&gt;&gt; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    (array([0, 2, 1]), array([0, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    &gt;&gt;&gt; np.histogram(np.arange(4), bins=np.arange(5), density=True)</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    (array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    &gt;&gt;&gt; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    (array([1, 4, 1]), array([0, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(5)</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    &gt;&gt;&gt; hist, bin_edges = np.histogram(a, density=True)</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    &gt;&gt;&gt; hist</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    array([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    &gt;&gt;&gt; hist.sum()</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    2.4999999999999996</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    &gt;&gt;&gt; np.sum(hist * np.diff(bin_edges))</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    .. versionadded:: 1.11.0</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    Automated Bin Selection Methods example, using 2 peak random data</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    with 2000 points:</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.RandomState(10)  # deterministic random data</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    &gt;&gt;&gt; a = np.hstack((rng.normal(size=1000),</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    ...                rng.normal(loc=5, scale=2, size=1000)))</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    &gt;&gt;&gt; _ = plt.hist(a, bins=&#39;auto&#39;)  # arguments are passed to np.histogram</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Histogram with &#39;auto&#39; bins&quot;)</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    Text(0.5, 1.0, &quot;Histogram with &#39;auto&#39; bins&quot;)</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  778</span>    a, weights = _ravel_and_check_weights(a, weights)</div>
<div class="line"><span class="lineno">  779</span> </div>
<div class="line"><span class="lineno">  780</span>    bin_edges, uniform_bins = _get_bin_edges(a, bins, range, weights)</div>
<div class="line"><span class="lineno">  781</span> </div>
<div class="line"><span class="lineno">  782</span>    <span class="comment"># Histogram is an integer or a float array depending on the weights.</span></div>
<div class="line"><span class="lineno">  783</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  784</span>        ntype = np.dtype(np.intp)</div>
<div class="line"><span class="lineno">  785</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  786</span>        ntype = weights.dtype</div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    <span class="comment"># We set a block size, as this allows us to iterate over chunks when</span></div>
<div class="line"><span class="lineno">  789</span>    <span class="comment"># computing histograms, to minimize memory usage.</span></div>
<div class="line"><span class="lineno">  790</span>    BLOCK = 65536</div>
<div class="line"><span class="lineno">  791</span> </div>
<div class="line"><span class="lineno">  792</span>    <span class="comment"># The fast path uses bincount, but that only works for certain types</span></div>
<div class="line"><span class="lineno">  793</span>    <span class="comment"># of weight</span></div>
<div class="line"><span class="lineno">  794</span>    simple_weights = (</div>
<div class="line"><span class="lineno">  795</span>        weights <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  796</span>        np.can_cast(weights.dtype, np.double) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  797</span>        np.can_cast(weights.dtype, complex)</div>
<div class="line"><span class="lineno">  798</span>    )</div>
<div class="line"><span class="lineno">  799</span> </div>
<div class="line"><span class="lineno">  800</span>    <span class="keywordflow">if</span> uniform_bins <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> simple_weights:</div>
<div class="line"><span class="lineno">  801</span>        <span class="comment"># Fast algorithm for equal bins</span></div>
<div class="line"><span class="lineno">  802</span>        <span class="comment"># We now convert values of a to bin indices, under the assumption of</span></div>
<div class="line"><span class="lineno">  803</span>        <span class="comment"># equal bin widths (which is valid here).</span></div>
<div class="line"><span class="lineno">  804</span>        first_edge, last_edge, n_equal_bins = uniform_bins</div>
<div class="line"><span class="lineno">  805</span> </div>
<div class="line"><span class="lineno">  806</span>        <span class="comment"># Initialize empty histogram</span></div>
<div class="line"><span class="lineno">  807</span>        n = np.zeros(n_equal_bins, ntype)</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>        <span class="comment"># Pre-compute histogram scaling factor</span></div>
<div class="line"><span class="lineno">  810</span>        norm = n_equal_bins / _unsigned_subtract(last_edge, first_edge)</div>
<div class="line"><span class="lineno">  811</span> </div>
<div class="line"><span class="lineno">  812</span>        <span class="comment"># We iterate over blocks here for two reasons: the first is that for</span></div>
<div class="line"><span class="lineno">  813</span>        <span class="comment"># large arrays, it is actually faster (for example for a 10^8 array it</span></div>
<div class="line"><span class="lineno">  814</span>        <span class="comment"># is 2x as fast) and it results in a memory footprint 3x lower in the</span></div>
<div class="line"><span class="lineno">  815</span>        <span class="comment"># limit of large arrays.</span></div>
<div class="line"><span class="lineno">  816</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> _range(0, len(a), BLOCK):</div>
<div class="line"><span class="lineno">  817</span>            tmp_a = a[i:i+BLOCK]</div>
<div class="line"><span class="lineno">  818</span>            <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  819</span>                tmp_w = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  820</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  821</span>                tmp_w = weights[i:i + BLOCK]</div>
<div class="line"><span class="lineno">  822</span> </div>
<div class="line"><span class="lineno">  823</span>            <span class="comment"># Only include values in the right range</span></div>
<div class="line"><span class="lineno">  824</span>            keep = (tmp_a &gt;= first_edge)</div>
<div class="line"><span class="lineno">  825</span>            keep &amp;= (tmp_a &lt;= last_edge)</div>
<div class="line"><span class="lineno">  826</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.logical_and.reduce(keep):</div>
<div class="line"><span class="lineno">  827</span>                tmp_a = tmp_a[keep]</div>
<div class="line"><span class="lineno">  828</span>                <span class="keywordflow">if</span> tmp_w <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  829</span>                    tmp_w = tmp_w[keep]</div>
<div class="line"><span class="lineno">  830</span> </div>
<div class="line"><span class="lineno">  831</span>            <span class="comment"># This cast ensures no type promotions occur below, which gh-10322</span></div>
<div class="line"><span class="lineno">  832</span>            <span class="comment"># make unpredictable. Getting it wrong leads to precision errors</span></div>
<div class="line"><span class="lineno">  833</span>            <span class="comment"># like gh-8123.</span></div>
<div class="line"><span class="lineno">  834</span>            tmp_a = tmp_a.astype(bin_edges.dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  835</span> </div>
<div class="line"><span class="lineno">  836</span>            <span class="comment"># Compute the bin indices, and for values that lie exactly on</span></div>
<div class="line"><span class="lineno">  837</span>            <span class="comment"># last_edge we need to subtract one</span></div>
<div class="line"><span class="lineno">  838</span>            f_indices = _unsigned_subtract(tmp_a, first_edge) * norm</div>
<div class="line"><span class="lineno">  839</span>            indices = f_indices.astype(np.intp)</div>
<div class="line"><span class="lineno">  840</span>            indices[indices == n_equal_bins] -= 1</div>
<div class="line"><span class="lineno">  841</span> </div>
<div class="line"><span class="lineno">  842</span>            <span class="comment"># The index computation is not guaranteed to give exactly</span></div>
<div class="line"><span class="lineno">  843</span>            <span class="comment"># consistent results within ~1 ULP of the bin edges.</span></div>
<div class="line"><span class="lineno">  844</span>            decrement = tmp_a &lt; bin_edges[indices]</div>
<div class="line"><span class="lineno">  845</span>            indices[decrement] -= 1</div>
<div class="line"><span class="lineno">  846</span>            <span class="comment"># The last bin includes the right edge. The other bins do not.</span></div>
<div class="line"><span class="lineno">  847</span>            increment = ((tmp_a &gt;= bin_edges[indices + 1])</div>
<div class="line"><span class="lineno">  848</span>                         &amp; (indices != n_equal_bins - 1))</div>
<div class="line"><span class="lineno">  849</span>            indices[increment] += 1</div>
<div class="line"><span class="lineno">  850</span> </div>
<div class="line"><span class="lineno">  851</span>            <span class="comment"># We now compute the histogram using bincount</span></div>
<div class="line"><span class="lineno">  852</span>            <span class="keywordflow">if</span> ntype.kind == <span class="stringliteral">&#39;c&#39;</span>:</div>
<div class="line"><span class="lineno">  853</span>                n.real += np.bincount(indices, weights=tmp_w.real,</div>
<div class="line"><span class="lineno">  854</span>                                      minlength=n_equal_bins)</div>
<div class="line"><span class="lineno">  855</span>                n.imag += np.bincount(indices, weights=tmp_w.imag,</div>
<div class="line"><span class="lineno">  856</span>                                      minlength=n_equal_bins)</div>
<div class="line"><span class="lineno">  857</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  858</span>                n += np.bincount(indices, weights=tmp_w,</div>
<div class="line"><span class="lineno">  859</span>                                 minlength=n_equal_bins).astype(ntype)</div>
<div class="line"><span class="lineno">  860</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  861</span>        <span class="comment"># Compute via cumulative histogram</span></div>
<div class="line"><span class="lineno">  862</span>        cum_n = np.zeros(bin_edges.shape, ntype)</div>
<div class="line"><span class="lineno">  863</span>        <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  864</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> _range(0, len(a), BLOCK):</div>
<div class="line"><span class="lineno">  865</span>                sa = np.sort(a[i:i+BLOCK])</div>
<div class="line"><span class="lineno">  866</span>                cum_n += _search_sorted_inclusive(sa, bin_edges)</div>
<div class="line"><span class="lineno">  867</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  868</span>            zero = np.zeros(1, dtype=ntype)</div>
<div class="line"><span class="lineno">  869</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> _range(0, len(a), BLOCK):</div>
<div class="line"><span class="lineno">  870</span>                tmp_a = a[i:i+BLOCK]</div>
<div class="line"><span class="lineno">  871</span>                tmp_w = weights[i:i+BLOCK]</div>
<div class="line"><span class="lineno">  872</span>                sorting_index = np.argsort(tmp_a)</div>
<div class="line"><span class="lineno">  873</span>                sa = tmp_a[sorting_index]</div>
<div class="line"><span class="lineno">  874</span>                sw = tmp_w[sorting_index]</div>
<div class="line"><span class="lineno">  875</span>                cw = np.concatenate((zero, sw.cumsum()))</div>
<div class="line"><span class="lineno">  876</span>                bin_index = _search_sorted_inclusive(sa, bin_edges)</div>
<div class="line"><span class="lineno">  877</span>                cum_n += cw[bin_index]</div>
<div class="line"><span class="lineno">  878</span> </div>
<div class="line"><span class="lineno">  879</span>        n = np.diff(cum_n)</div>
<div class="line"><span class="lineno">  880</span> </div>
<div class="line"><span class="lineno">  881</span>    <span class="keywordflow">if</span> density:</div>
<div class="line"><span class="lineno">  882</span>        db = np.array(np.diff(bin_edges), float)</div>
<div class="line"><span class="lineno">  883</span>        <span class="keywordflow">return</span> n/db/n.sum(), bin_edges</div>
<div class="line"><span class="lineno">  884</span> </div>
<div class="line"><span class="lineno">  885</span>    <span class="keywordflow">return</span> n, bin_edges</div>
<div class="line"><span class="lineno">  886</span> </div>
<div class="line"><span class="lineno">  887</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab05ae305dd68979bf6b84053bd2513b8" name="ab05ae305dd68979bf6b84053bd2513b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05ae305dd68979bf6b84053bd2513b8">&#9670;&#160;</a></span>histogram_bin_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms.histogram_bin_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to calculate only the edges of the bins used by the `histogram`
function.

Parameters
----------
a : array_like
    Input data. The histogram is computed over the flattened array.
bins : int or sequence of scalars or str, optional
    If `bins` is an int, it defines the number of equal-width
    bins in the given range (10, by default). If `bins` is a
    sequence, it defines the bin edges, including the rightmost
    edge, allowing for non-uniform bin widths.

    If `bins` is a string from the list below, `histogram_bin_edges` will use
    the method chosen to calculate the optimal bin width and
    consequently the number of bins (see `Notes` for more detail on
    the estimators) from the data that falls within the requested
    range. While the bin width will be optimal for the actual data
    in the range, the number of bins will be computed to fill the
    entire range, including the empty portions. For visualisation,
    using the 'auto' option is suggested. Weighted data is not
    supported for automated bin size selection.

    'auto'
        Maximum of the 'sturges' and 'fd' estimators. Provides good
        all around performance.

    'fd' (Freedman Diaconis Estimator)
        Robust (resilient to outliers) estimator that takes into
        account data variability and data size.

    'doane'
        An improved version of Sturges' estimator that works better
        with non-normal datasets.

    'scott'
        Less robust estimator that takes into account data variability
        and data size.

    'stone'
        Estimator based on leave-one-out cross-validation estimate of
        the integrated squared error. Can be regarded as a generalization
        of Scott's rule.

    'rice'
        Estimator does not take variability into account, only data
        size. Commonly overestimates number of bins required.

    'sturges'
        R's default method, only accounts for data size. Only
        optimal for gaussian data and underestimates number of bins
        for large non-gaussian datasets.

    'sqrt'
        Square root (of data size) estimator, used by Excel and
        other programs for its speed and simplicity.

range : (float, float), optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(a.min(), a.max())``.  Values outside the range are
    ignored. The first element of the range must be less than or
    equal to the second. `range` affects the automatic bin
    computation as well. While bin width is computed to be optimal
    based on the actual data within `range`, the bin count will fill
    the entire range including portions containing no data.

weights : array_like, optional
    An array of weights, of the same shape as `a`.  Each value in
    `a` only contributes its associated weight towards the bin count
    (instead of 1). This is currently not used by any of the bin estimators,
    but may be in the future.

Returns
-------
bin_edges : array of dtype float
    The edges to pass into `histogram`

See Also
--------
histogram

Notes
-----
The methods to estimate the optimal number of bins are well founded
in literature, and are inspired by the choices R provides for
histogram visualisation. Note that having the number of bins
proportional to :math:`n^{1/3}` is asymptotically optimal, which is
why it appears in most estimators. These are simply plug-in methods
that give good starting points for number of bins. In the equations
below, :math:`h` is the binwidth and :math:`n_h` is the number of
bins. All estimators that compute bin counts are recast to bin width
using the `ptp` of the data. The final bin count is obtained from
``np.round(np.ceil(range / h))``. The final bin width is often less
than what is returned by the estimators below.

'auto' (maximum of the 'sturges' and 'fd' estimators)
    A compromise to get a good value. For small datasets the Sturges
    value will usually be chosen, while larger datasets will usually
    default to FD.  Avoids the overly conservative behaviour of FD
    and Sturges for small and large datasets respectively.
    Switchover point is usually :math:`a.size \approx 1000`.

'fd' (Freedman Diaconis Estimator)
    .. math:: h = 2 \frac{IQR}{n^{1/3}}

    The binwidth is proportional to the interquartile range (IQR)
    and inversely proportional to cube root of a.size. Can be too
    conservative for small datasets, but is quite good for large
    datasets. The IQR is very robust to outliers.

'scott'
    .. math:: h = \sigma \sqrt[3]{\frac{24 \sqrt{\pi}}{n}}

    The binwidth is proportional to the standard deviation of the
    data and inversely proportional to cube root of ``x.size``. Can
    be too conservative for small datasets, but is quite good for
    large datasets. The standard deviation is not very robust to
    outliers. Values are very similar to the Freedman-Diaconis
    estimator in the absence of outliers.

'rice'
    .. math:: n_h = 2n^{1/3}

    The number of bins is only proportional to cube root of
    ``a.size``. It tends to overestimate the number of bins and it
    does not take into account data variability.

'sturges'
    .. math:: n_h = \log _{2}(n) + 1

    The number of bins is the base 2 log of ``a.size``.  This
    estimator assumes normality of data and is too conservative for
    larger, non-normal datasets. This is the default method in R's
    ``hist`` method.

'doane'
    .. math:: n_h = 1 + \log_{2}(n) +
                    \log_{2}\left(1 + \frac{|g_1|}{\sigma_{g_1}}\right)

        g_1 = mean\left[\left(\frac{x - \mu}{\sigma}\right)^3\right]

        \sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}

    An improved version of Sturges' formula that produces better
    estimates for non-normal datasets. This estimator attempts to
    account for the skew of the data.

'sqrt'
    .. math:: n_h = \sqrt n

    The simplest and fastest estimator. Only takes into account the
    data size.

Examples
--------
&gt;&gt;&gt; arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])
&gt;&gt;&gt; np.histogram_bin_edges(arr, bins='auto', range=(0, 1))
array([0.  , 0.25, 0.5 , 0.75, 1.  ])
&gt;&gt;&gt; np.histogram_bin_edges(arr, bins=2)
array([0. , 2.5, 5. ])

For consistency with histogram, an array of pre-computed bins is
passed through unmodified:

&gt;&gt;&gt; np.histogram_bin_edges(arr, [1, 2])
array([1, 2])

This function allows one set of bins to be computed, and reused across
multiple histograms:

&gt;&gt;&gt; shared_bins = np.histogram_bin_edges(arr, bins='auto')
&gt;&gt;&gt; shared_bins
array([0., 1., 2., 3., 4., 5.])

&gt;&gt;&gt; group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])
&gt;&gt;&gt; hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)
&gt;&gt;&gt; hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)

&gt;&gt;&gt; hist_0; hist_1
array([1, 1, 0, 1, 0])
array([2, 0, 1, 1, 2])

Which gives more easily comparable results than using separate bins for
each histogram:

&gt;&gt;&gt; hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')
&gt;&gt;&gt; hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')
&gt;&gt;&gt; hist_0; hist_1
array([1, 1, 1])
array([2, 1, 1, 2])
&gt;&gt;&gt; bins_0; bins_1
array([0., 1., 2., 3.])
array([0.  , 1.25, 2.5 , 3.75, 5.  ])</pre> <div class="fragment"><div class="line"><span class="lineno">  471</span><span class="keyword">def </span>histogram_bin_edges(a, bins=10, range=None, weights=None):</div>
<div class="line"><span class="lineno">  472</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    Function to calculate only the edges of the bins used by the `histogram`</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    function.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        Input data. The histogram is computed over the flattened array.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    bins : int or sequence of scalars or str, optional</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        If `bins` is an int, it defines the number of equal-width</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        bins in the given range (10, by default). If `bins` is a</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        sequence, it defines the bin edges, including the rightmost</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        edge, allowing for non-uniform bin widths.</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        If `bins` is a string from the list below, `histogram_bin_edges` will use</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        the method chosen to calculate the optimal bin width and</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        consequently the number of bins (see `Notes` for more detail on</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        the estimators) from the data that falls within the requested</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        range. While the bin width will be optimal for the actual data</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        in the range, the number of bins will be computed to fill the</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">        entire range, including the empty portions. For visualisation,</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        using the &#39;auto&#39; option is suggested. Weighted data is not</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        supported for automated bin size selection.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        &#39;auto&#39;</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">            Maximum of the &#39;sturges&#39; and &#39;fd&#39; estimators. Provides good</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">            all around performance.</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        &#39;fd&#39; (Freedman Diaconis Estimator)</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">            Robust (resilient to outliers) estimator that takes into</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">            account data variability and data size.</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        &#39;doane&#39;</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">            An improved version of Sturges&#39; estimator that works better</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">            with non-normal datasets.</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        &#39;scott&#39;</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">            Less robust estimator that takes into account data variability</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">            and data size.</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        &#39;stone&#39;</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">            Estimator based on leave-one-out cross-validation estimate of</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">            the integrated squared error. Can be regarded as a generalization</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">            of Scott&#39;s rule.</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        &#39;rice&#39;</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">            Estimator does not take variability into account, only data</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">            size. Commonly overestimates number of bins required.</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        &#39;sturges&#39;</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">            R&#39;s default method, only accounts for data size. Only</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">            optimal for gaussian data and underestimates number of bins</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">            for large non-gaussian datasets.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">        &#39;sqrt&#39;</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">            Square root (of data size) estimator, used by Excel and</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">            other programs for its speed and simplicity.</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    range : (float, float), optional</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        The lower and upper range of the bins.  If not provided, range</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        is simply ``(a.min(), a.max())``.  Values outside the range are</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        ignored. The first element of the range must be less than or</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        equal to the second. `range` affects the automatic bin</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        computation as well. While bin width is computed to be optimal</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">        based on the actual data within `range`, the bin count will fill</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">        the entire range including portions containing no data.</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">        An array of weights, of the same shape as `a`.  Each value in</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        `a` only contributes its associated weight towards the bin count</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        (instead of 1). This is currently not used by any of the bin estimators,</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        but may be in the future.</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    bin_edges : array of dtype float</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">        The edges to pass into `histogram`</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    histogram</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    The methods to estimate the optimal number of bins are well founded</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    in literature, and are inspired by the choices R provides for</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    histogram visualisation. Note that having the number of bins</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    proportional to :math:`n^{1/3}` is asymptotically optimal, which is</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    why it appears in most estimators. These are simply plug-in methods</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    that give good starting points for number of bins. In the equations</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    below, :math:`h` is the binwidth and :math:`n_h` is the number of</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    bins. All estimators that compute bin counts are recast to bin width</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    using the `ptp` of the data. The final bin count is obtained from</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    ``np.round(np.ceil(range / h))``. The final bin width is often less</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    than what is returned by the estimators below.</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    &#39;auto&#39; (maximum of the &#39;sturges&#39; and &#39;fd&#39; estimators)</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        A compromise to get a good value. For small datasets the Sturges</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        value will usually be chosen, while larger datasets will usually</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        default to FD.  Avoids the overly conservative behaviour of FD</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        and Sturges for small and large datasets respectively.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        Switchover point is usually :math:`a.size \approx 1000`.</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    &#39;fd&#39; (Freedman Diaconis Estimator)</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        .. math:: h = 2 \frac{IQR}{n^{1/3}}</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        The binwidth is proportional to the interquartile range (IQR)</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        and inversely proportional to cube root of a.size. Can be too</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">        conservative for small datasets, but is quite good for large</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        datasets. The IQR is very robust to outliers.</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    &#39;scott&#39;</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        .. math:: h = \sigma \sqrt[3]{\frac{24 \sqrt{\pi}}{n}}</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        The binwidth is proportional to the standard deviation of the</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        data and inversely proportional to cube root of ``x.size``. Can</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">        be too conservative for small datasets, but is quite good for</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        large datasets. The standard deviation is not very robust to</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">        outliers. Values are very similar to the Freedman-Diaconis</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        estimator in the absence of outliers.</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    &#39;rice&#39;</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        .. math:: n_h = 2n^{1/3}</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        The number of bins is only proportional to cube root of</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        ``a.size``. It tends to overestimate the number of bins and it</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">        does not take into account data variability.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    &#39;sturges&#39;</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        .. math:: n_h = \log _{2}(n) + 1</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">        The number of bins is the base 2 log of ``a.size``.  This</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        estimator assumes normality of data and is too conservative for</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        larger, non-normal datasets. This is the default method in R&#39;s</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        ``hist`` method.</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    &#39;doane&#39;</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">        .. math:: n_h = 1 + \log_{2}(n) +</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">                        \log_{2}\left(1 + \frac{|g_1|}{\sigma_{g_1}}\right)</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">            g_1 = mean\left[\left(\frac{x - \mu}{\sigma}\right)^3\right]</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">            \sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">        An improved version of Sturges&#39; formula that produces better</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">        estimates for non-normal datasets. This estimator attempts to</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        account for the skew of the data.</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    &#39;sqrt&#39;</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        .. math:: n_h = \sqrt n</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">        The simplest and fastest estimator. Only takes into account the</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        data size.</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    &gt;&gt;&gt; arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    &gt;&gt;&gt; np.histogram_bin_edges(arr, bins=&#39;auto&#39;, range=(0, 1))</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    array([0.  , 0.25, 0.5 , 0.75, 1.  ])</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    &gt;&gt;&gt; np.histogram_bin_edges(arr, bins=2)</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    array([0. , 2.5, 5. ])</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    For consistency with histogram, an array of pre-computed bins is</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    passed through unmodified:</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    &gt;&gt;&gt; np.histogram_bin_edges(arr, [1, 2])</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    array([1, 2])</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    This function allows one set of bins to be computed, and reused across</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    multiple histograms:</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    &gt;&gt;&gt; shared_bins = np.histogram_bin_edges(arr, bins=&#39;auto&#39;)</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    &gt;&gt;&gt; shared_bins</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    array([0., 1., 2., 3., 4., 5.])</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    &gt;&gt;&gt; group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    &gt;&gt;&gt; hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    &gt;&gt;&gt; hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    &gt;&gt;&gt; hist_0; hist_1</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    array([1, 1, 0, 1, 0])</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    array([2, 0, 1, 1, 2])</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    Which gives more easily comparable results than using separate bins for</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    each histogram:</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    &gt;&gt;&gt; hist_0, bins_0 = np.histogram(arr[group_id == 0], bins=&#39;auto&#39;)</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    &gt;&gt;&gt; hist_1, bins_1 = np.histogram(arr[group_id == 1], bins=&#39;auto&#39;)</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    &gt;&gt;&gt; hist_0; hist_1</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    array([1, 1, 1])</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    array([2, 1, 1, 2])</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    &gt;&gt;&gt; bins_0; bins_1</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    array([0., 1., 2., 3.])</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    array([0.  , 1.25, 2.5 , 3.75, 5.  ])</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  668</span>    a, weights = _ravel_and_check_weights(a, weights)</div>
<div class="line"><span class="lineno">  669</span>    bin_edges, _ = _get_bin_edges(a, bins, range, weights)</div>
<div class="line"><span class="lineno">  670</span>    <span class="keywordflow">return</span> bin_edges</div>
<div class="line"><span class="lineno">  671</span> </div>
<div class="line"><span class="lineno">  672</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7f2714792f560ae21867fa81b0826a7" name="ac7f2714792f560ae21867fa81b0826a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f2714792f560ae21867fa81b0826a7">&#9670;&#160;</a></span>histogramdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms.histogramdd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the multidimensional histogram of some data.

Parameters
----------
sample : (N, D) array, or (N, D) array_like
    The data to be histogrammed.

    Note the unusual interpretation of sample when an array_like:

    * When an array, each row is a coordinate in a D-dimensional space -
      such as ``histogramdd(np.array([p1, p2, p3]))``.
    * When an array_like, each element is the list of values for single
      coordinate - such as ``histogramdd((X, Y, Z))``.

    The first form should be preferred.

bins : sequence or int, optional
    The bin specification:

    * A sequence of arrays describing the monotonically increasing bin
      edges along each dimension.
    * The number of bins for each dimension (nx, ny, ... =bins)
    * The number of bins for all dimensions (nx=ny=...=bins).

range : sequence, optional
    A sequence of length D, each an optional (lower, upper) tuple giving
    the outer bin edges to be used if the edges are not given explicitly in
    `bins`.
    An entry of None in the sequence results in the minimum and maximum
    values being used for the corresponding dimension.
    The default, None, is equivalent to passing a tuple of D None values.
density : bool, optional
    If False, the default, returns the number of samples in each bin.
    If True, returns the probability *density* function at the bin,
    ``bin_count / sample_count / bin_volume``.
weights : (N,) array_like, optional
    An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.
    Weights are normalized to 1 if density is True. If density is False,
    the values of the returned histogram are equal to the sum of the
    weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray
    The multidimensional histogram of sample x. See density and weights
    for the different possible semantics.
edges : list
    A list of D arrays describing the bin edges for each dimension.

See Also
--------
histogram: 1-D histogram
histogram2d: 2-D histogram

Examples
--------
&gt;&gt;&gt; r = np.random.randn(100,3)
&gt;&gt;&gt; H, edges = np.histogramdd(r, bins = (5, 8, 4))
&gt;&gt;&gt; H.shape, edges[0].size, edges[1].size, edges[2].size
((5, 8, 4), 6, 9, 5)</pre> <div class="fragment"><div class="line"><span class="lineno">  900</span><span class="keyword">def </span>histogramdd(sample, bins=10, range=None, density=None, weights=None):</div>
<div class="line"><span class="lineno">  901</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    Compute the multidimensional histogram of some data.</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    sample : (N, D) array, or (N, D) array_like</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        The data to be histogrammed.</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        Note the unusual interpretation of sample when an array_like:</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        * When an array, each row is a coordinate in a D-dimensional space -</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">          such as ``histogramdd(np.array([p1, p2, p3]))``.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        * When an array_like, each element is the list of values for single</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">          coordinate - such as ``histogramdd((X, Y, Z))``.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">        The first form should be preferred.</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    bins : sequence or int, optional</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">        The bin specification:</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">        * A sequence of arrays describing the monotonically increasing bin</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">          edges along each dimension.</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">        * The number of bins for each dimension (nx, ny, ... =bins)</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">        * The number of bins for all dimensions (nx=ny=...=bins).</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    range : sequence, optional</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">        A sequence of length D, each an optional (lower, upper) tuple giving</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">        the outer bin edges to be used if the edges are not given explicitly in</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">        `bins`.</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">        An entry of None in the sequence results in the minimum and maximum</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">        values being used for the corresponding dimension.</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">        The default, None, is equivalent to passing a tuple of D None values.</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    density : bool, optional</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">        If False, the default, returns the number of samples in each bin.</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">        If True, returns the probability *density* function at the bin,</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">        ``bin_count / sample_count / bin_volume``.</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    weights : (N,) array_like, optional</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">        Weights are normalized to 1 if density is True. If density is False,</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">        the values of the returned histogram are equal to the sum of the</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">        weights belonging to the samples falling into each bin.</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    H : ndarray</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">        The multidimensional histogram of sample x. See density and weights</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">        for the different possible semantics.</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    edges : list</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">        A list of D arrays describing the bin edges for each dimension.</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    histogram: 1-D histogram</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">    histogram2d: 2-D histogram</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">    &gt;&gt;&gt; r = np.random.randn(100,3)</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    &gt;&gt;&gt; H, edges = np.histogramdd(r, bins = (5, 8, 4))</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    &gt;&gt;&gt; H.shape, edges[0].size, edges[1].size, edges[2].size</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    ((5, 8, 4), 6, 9, 5)</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  964</span> </div>
<div class="line"><span class="lineno">  965</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  966</span>        <span class="comment"># Sample is an ND-array.</span></div>
<div class="line"><span class="lineno">  967</span>        N, D = sample.shape</div>
<div class="line"><span class="lineno">  968</span>    <span class="keywordflow">except</span> (AttributeError, ValueError):</div>
<div class="line"><span class="lineno">  969</span>        <span class="comment"># Sample is a sequence of 1D arrays.</span></div>
<div class="line"><span class="lineno">  970</span>        sample = np.atleast_2d(sample).T</div>
<div class="line"><span class="lineno">  971</span>        N, D = sample.shape</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>    nbin = np.empty(D, np.intp)</div>
<div class="line"><span class="lineno">  974</span>    edges = D*[<span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno">  975</span>    dedges = D*[<span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno">  976</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  977</span>        weights = np.asarray(weights)</div>
<div class="line"><span class="lineno">  978</span> </div>
<div class="line"><span class="lineno">  979</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  980</span>        M = len(bins)</div>
<div class="line"><span class="lineno">  981</span>        <span class="keywordflow">if</span> M != D:</div>
<div class="line"><span class="lineno">  982</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  983</span>                <span class="stringliteral">&#39;The dimension of bins must be equal to the dimension of the &#39;</span></div>
<div class="line"><span class="lineno">  984</span>                <span class="stringliteral">&#39; sample x.&#39;</span>)</div>
<div class="line"><span class="lineno">  985</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  986</span>        <span class="comment"># bins is an integer</span></div>
<div class="line"><span class="lineno">  987</span>        bins = D*[bins]</div>
<div class="line"><span class="lineno">  988</span> </div>
<div class="line"><span class="lineno">  989</span>    <span class="comment"># normalize the range argument</span></div>
<div class="line"><span class="lineno">  990</span>    <span class="keywordflow">if</span> range <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  991</span>        range = (<span class="keywordtype">None</span>,) * D</div>
<div class="line"><span class="lineno">  992</span>    <span class="keywordflow">elif</span> len(range) != D:</div>
<div class="line"><span class="lineno">  993</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;range argument must have one entry per dimension&#39;</span>)</div>
<div class="line"><span class="lineno">  994</span> </div>
<div class="line"><span class="lineno">  995</span>    <span class="comment"># Create edge arrays</span></div>
<div class="line"><span class="lineno">  996</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> _range(D):</div>
<div class="line"><span class="lineno">  997</span>        <span class="keywordflow">if</span> np.ndim(bins[i]) == 0:</div>
<div class="line"><span class="lineno">  998</span>            <span class="keywordflow">if</span> bins[i] &lt; 1:</div>
<div class="line"><span class="lineno">  999</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1000</span>                    <span class="stringliteral">&#39;`bins[{}]` must be positive, when an integer&#39;</span>.format(i))</div>
<div class="line"><span class="lineno"> 1001</span>            smin, smax = _get_outer_edges(sample[:,i], range[i])</div>
<div class="line"><span class="lineno"> 1002</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1003</span>                n = operator.index(bins[i])</div>
<div class="line"><span class="lineno"> 1004</span> </div>
<div class="line"><span class="lineno"> 1005</span>            <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 1006</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1007</span>                    <span class="stringliteral">&quot;`bins[{}]` must be an integer, when a scalar&quot;</span>.format(i)</div>
<div class="line"><span class="lineno"> 1008</span>                ) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 1009</span> </div>
<div class="line"><span class="lineno"> 1010</span>            edges[i] = np.linspace(smin, smax, n + 1)</div>
<div class="line"><span class="lineno"> 1011</span>        <span class="keywordflow">elif</span> np.ndim(bins[i]) == 1:</div>
<div class="line"><span class="lineno"> 1012</span>            edges[i] = np.asarray(bins[i])</div>
<div class="line"><span class="lineno"> 1013</span>            <span class="keywordflow">if</span> np.any(edges[i][:-1] &gt; edges[i][1:]):</div>
<div class="line"><span class="lineno"> 1014</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1015</span>                    <span class="stringliteral">&#39;`bins[{}]` must be monotonically increasing, when an array&#39;</span></div>
<div class="line"><span class="lineno"> 1016</span>                    .format(i))</div>
<div class="line"><span class="lineno"> 1017</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1018</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1019</span>                <span class="stringliteral">&#39;`bins[{}]` must be a scalar or 1d array&#39;</span>.format(i))</div>
<div class="line"><span class="lineno"> 1020</span> </div>
<div class="line"><span class="lineno"> 1021</span>        nbin[i] = len(edges[i]) + 1  <span class="comment"># includes an outlier on each end</span></div>
<div class="line"><span class="lineno"> 1022</span>        dedges[i] = np.diff(edges[i])</div>
<div class="line"><span class="lineno"> 1023</span> </div>
<div class="line"><span class="lineno"> 1024</span>    <span class="comment"># Compute the bin number each sample falls into.</span></div>
<div class="line"><span class="lineno"> 1025</span>    Ncount = tuple(</div>
<div class="line"><span class="lineno"> 1026</span>        <span class="comment"># avoid np.digitize to work around gh-11022</span></div>
<div class="line"><span class="lineno"> 1027</span>        np.searchsorted(edges[i], sample[:, i], side=<span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno"> 1028</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> _range(D)</div>
<div class="line"><span class="lineno"> 1029</span>    )</div>
<div class="line"><span class="lineno"> 1030</span> </div>
<div class="line"><span class="lineno"> 1031</span>    <span class="comment"># Using digitize, values that fall on an edge are put in the right bin.</span></div>
<div class="line"><span class="lineno"> 1032</span>    <span class="comment"># For the rightmost bin, we want values equal to the right edge to be</span></div>
<div class="line"><span class="lineno"> 1033</span>    <span class="comment"># counted in the last bin, and not as an outlier.</span></div>
<div class="line"><span class="lineno"> 1034</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> _range(D):</div>
<div class="line"><span class="lineno"> 1035</span>        <span class="comment"># Find which points are on the rightmost edge.</span></div>
<div class="line"><span class="lineno"> 1036</span>        on_edge = (sample[:, i] == edges[i][-1])</div>
<div class="line"><span class="lineno"> 1037</span>        <span class="comment"># Shift these points one bin to the left.</span></div>
<div class="line"><span class="lineno"> 1038</span>        Ncount[i][on_edge] -= 1</div>
<div class="line"><span class="lineno"> 1039</span> </div>
<div class="line"><span class="lineno"> 1040</span>    <span class="comment"># Compute the sample indices in the flattened histogram matrix.</span></div>
<div class="line"><span class="lineno"> 1041</span>    <span class="comment"># This raises an error if the array is too large.</span></div>
<div class="line"><span class="lineno"> 1042</span>    xy = np.ravel_multi_index(Ncount, nbin)</div>
<div class="line"><span class="lineno"> 1043</span> </div>
<div class="line"><span class="lineno"> 1044</span>    <span class="comment"># Compute the number of repetitions in xy and assign it to the</span></div>
<div class="line"><span class="lineno"> 1045</span>    <span class="comment"># flattened histmat.</span></div>
<div class="line"><span class="lineno"> 1046</span>    hist = np.bincount(xy, weights, minlength=nbin.prod())</div>
<div class="line"><span class="lineno"> 1047</span> </div>
<div class="line"><span class="lineno"> 1048</span>    <span class="comment"># Shape into a proper matrix</span></div>
<div class="line"><span class="lineno"> 1049</span>    hist = hist.reshape(nbin)</div>
<div class="line"><span class="lineno"> 1050</span> </div>
<div class="line"><span class="lineno"> 1051</span>    <span class="comment"># This preserves the (bad) behavior observed in gh-7845, for now.</span></div>
<div class="line"><span class="lineno"> 1052</span>    hist = hist.astype(float, casting=<span class="stringliteral">&#39;safe&#39;</span>)</div>
<div class="line"><span class="lineno"> 1053</span> </div>
<div class="line"><span class="lineno"> 1054</span>    <span class="comment"># Remove outliers (indices 0 and -1 for each dimension).</span></div>
<div class="line"><span class="lineno"> 1055</span>    core = D*(slice(1, -1),)</div>
<div class="line"><span class="lineno"> 1056</span>    hist = hist[core]</div>
<div class="line"><span class="lineno"> 1057</span> </div>
<div class="line"><span class="lineno"> 1058</span>    <span class="keywordflow">if</span> density:</div>
<div class="line"><span class="lineno"> 1059</span>        <span class="comment"># calculate the probability density function</span></div>
<div class="line"><span class="lineno"> 1060</span>        s = hist.sum()</div>
<div class="line"><span class="lineno"> 1061</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> _range(D):</div>
<div class="line"><span class="lineno"> 1062</span>            shape = np.ones(D, int)</div>
<div class="line"><span class="lineno"> 1063</span>            shape[i] = nbin[i] - 2</div>
<div class="line"><span class="lineno"> 1064</span>            hist = hist / dedges[i].reshape(shape)</div>
<div class="line"><span class="lineno"> 1065</span>        hist /= s</div>
<div class="line"><span class="lineno"> 1066</span> </div>
<div class="line"><span class="lineno"> 1067</span>    <span class="keywordflow">if</span> (hist.shape != nbin - 2).any():</div>
<div class="line"><span class="lineno"> 1068</span>        <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno"> 1069</span>            <span class="stringliteral">&quot;Internal Shape Error&quot;</span>)</div>
<div class="line"><span class="lineno"> 1070</span>    <span class="keywordflow">return</span> hist, edges</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9ca28a0d689bfafe2a730abb5e4aca87" name="a9ca28a0d689bfafe2a730abb5e4aca87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca28a0d689bfafe2a730abb5e4aca87">&#9670;&#160;</a></span>_hist_bin_selectors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict numpy.lib.histograms._hist_bin_selectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {<span class="stringliteral">&#39;stone&#39;</span>: _hist_bin_stone,</div>
<div class="line"><span class="lineno">    2</span>                       <span class="stringliteral">&#39;auto&#39;</span>: _hist_bin_auto,</div>
<div class="line"><span class="lineno">    3</span>                       <span class="stringliteral">&#39;doane&#39;</span>: _hist_bin_doane,</div>
<div class="line"><span class="lineno">    4</span>                       <span class="stringliteral">&#39;fd&#39;</span>: _hist_bin_fd,</div>
<div class="line"><span class="lineno">    5</span>                       <span class="stringliteral">&#39;rice&#39;</span>: _hist_bin_rice,</div>
<div class="line"><span class="lineno">    6</span>                       <span class="stringliteral">&#39;scott&#39;</span>: _hist_bin_scott,</div>
<div class="line"><span class="lineno">    7</span>                       <span class="stringliteral">&#39;sqrt&#39;</span>: _hist_bin_sqrt,</div>
<div class="line"><span class="lineno">    8</span>                       <span class="stringliteral">&#39;sturges&#39;</span>: _hist_bin_sturges}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aadab085e4d176a8e2898f4716e1a261f" name="aadab085e4d176a8e2898f4716e1a261f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadab085e4d176a8e2898f4716e1a261f">&#9670;&#160;</a></span>_range</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms._range = range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a773227587f144e5334133beb38236128" name="a773227587f144e5334133beb38236128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773227587f144e5334133beb38236128">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.histograms.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
