<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.colors Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1colors.html">colors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.colors Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1___color_mapping.html">_ColorMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_asinh_norm.html">AsinhNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_boundary_norm.html">BoundaryNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_centered_norm.html">CenteredNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_color_converter.html">ColorConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_colormap.html">Colormap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_color_sequence_registry.html">ColorSequenceRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_func_norm.html">FuncNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_light_source.html">LightSource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_linear_segmented_colormap.html">LinearSegmentedColormap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_listed_colormap.html">ListedColormap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_no_norm.html">NoNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_normalize.html">Normalize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_power_norm.html">PowerNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_sym_log_norm.html">SymLogNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1colors_1_1_two_slope_norm.html">TwoSlopeNorm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2fddddcc2b3b5cfbcccfb3f450e88305" id="r_a2fddddcc2b3b5cfbcccfb3f450e88305"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a2fddddcc2b3b5cfbcccfb3f450e88305">get_named_colors_mapping</a> ()</td></tr>
<tr class="separator:a2fddddcc2b3b5cfbcccfb3f450e88305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616854babc5a0b26f6b4455827b917f6" id="r_a616854babc5a0b26f6b4455827b917f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a616854babc5a0b26f6b4455827b917f6">_sanitize_extrema</a> (ex)</td></tr>
<tr class="separator:a616854babc5a0b26f6b4455827b917f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acded809f300a8f44dc60eb08574d38e2" id="r_acded809f300a8f44dc60eb08574d38e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#acded809f300a8f44dc60eb08574d38e2">_is_nth_color</a> (c)</td></tr>
<tr class="separator:acded809f300a8f44dc60eb08574d38e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c380910d4179d1224af466c1292e1" id="r_a5b8c380910d4179d1224af466c1292e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a5b8c380910d4179d1224af466c1292e1">is_color_like</a> (c)</td></tr>
<tr class="separator:a5b8c380910d4179d1224af466c1292e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c83d570876c5f5032771d68d8a5e00" id="r_a09c83d570876c5f5032771d68d8a5e00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a09c83d570876c5f5032771d68d8a5e00">_has_alpha_channel</a> (c)</td></tr>
<tr class="separator:a09c83d570876c5f5032771d68d8a5e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe8f49c5c2420733da38e0b2a55469f" id="r_a6fe8f49c5c2420733da38e0b2a55469f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a6fe8f49c5c2420733da38e0b2a55469f">_check_color_like</a> (**kwargs)</td></tr>
<tr class="separator:a6fe8f49c5c2420733da38e0b2a55469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a51b82e4d94831ff520d6c9ea97abfa" id="r_a9a51b82e4d94831ff520d6c9ea97abfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a9a51b82e4d94831ff520d6c9ea97abfa">same_color</a> (c1, c2)</td></tr>
<tr class="separator:a9a51b82e4d94831ff520d6c9ea97abfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bc0cc88399a2d7cc576330f1f396b5" id="r_a05bc0cc88399a2d7cc576330f1f396b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a05bc0cc88399a2d7cc576330f1f396b5">to_rgba</a> (c, <a class="el" href="__blas__subroutines_8h.html#a29dda7d0819a860e921db821deb590c9">alpha</a>=None)</td></tr>
<tr class="separator:a05bc0cc88399a2d7cc576330f1f396b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63976eb873aff7154156b9fe954ff23b" id="r_a63976eb873aff7154156b9fe954ff23b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a63976eb873aff7154156b9fe954ff23b">_to_rgba_no_colorcycle</a> (c, <a class="el" href="__blas__subroutines_8h.html#a29dda7d0819a860e921db821deb590c9">alpha</a>=None)</td></tr>
<tr class="separator:a63976eb873aff7154156b9fe954ff23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549adc2b2de96d79a7e8140003617f92" id="r_a549adc2b2de96d79a7e8140003617f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a549adc2b2de96d79a7e8140003617f92">to_rgba_array</a> (c, <a class="el" href="__blas__subroutines_8h.html#a29dda7d0819a860e921db821deb590c9">alpha</a>=None)</td></tr>
<tr class="separator:a549adc2b2de96d79a7e8140003617f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e44dff433013eff6271388e066b5fa3" id="r_a4e44dff433013eff6271388e066b5fa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a4e44dff433013eff6271388e066b5fa3">to_rgb</a> (c)</td></tr>
<tr class="separator:a4e44dff433013eff6271388e066b5fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d98b0f57844e85cbc263cdf8aaa55e" id="r_a35d98b0f57844e85cbc263cdf8aaa55e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a35d98b0f57844e85cbc263cdf8aaa55e">to_hex</a> (c, keep_alpha=False)</td></tr>
<tr class="separator:a35d98b0f57844e85cbc263cdf8aaa55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022bf41b256e7295f44d7ccbbb3fcdc0" id="r_a022bf41b256e7295f44d7ccbbb3fcdc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a022bf41b256e7295f44d7ccbbb3fcdc0">_create_lookup_table</a> (N, data, gamma=1.0)</td></tr>
<tr class="memdesc:a022bf41b256e7295f44d7ccbbb3fcdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of backwards-compatible color-conversion API.  <br /></td></tr>
<tr class="separator:a022bf41b256e7295f44d7ccbbb3fcdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723ca546163bf319134488e95a0f78a6" id="r_a723ca546163bf319134488e95a0f78a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a723ca546163bf319134488e95a0f78a6">make_norm_from_scale</a> (scale_cls, base_norm_cls=None, *init=None)</td></tr>
<tr class="separator:a723ca546163bf319134488e95a0f78a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142d79f2c22a9efaefa55e0755d5140" id="r_aa142d79f2c22a9efaefa55e0755d5140"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#aa142d79f2c22a9efaefa55e0755d5140">_make_norm_from_scale</a> (scale_cls, scale_args, scale_kwargs_items, base_norm_cls, bound_init_signature)</td></tr>
<tr class="separator:aa142d79f2c22a9efaefa55e0755d5140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89722be80a5518c33dd3adfb55ff52f" id="r_ad89722be80a5518c33dd3adfb55ff52f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#ad89722be80a5518c33dd3adfb55ff52f">_create_empty_object_of_class</a> (cls)</td></tr>
<tr class="separator:ad89722be80a5518c33dd3adfb55ff52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317910a2b93745b4d49f16873d9f414f" id="r_a317910a2b93745b4d49f16873d9f414f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a317910a2b93745b4d49f16873d9f414f">_picklable_norm_constructor</a> (*args)</td></tr>
<tr class="separator:a317910a2b93745b4d49f16873d9f414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438ddeafc28f4bd634595cfd3f818653" id="r_a438ddeafc28f4bd634595cfd3f818653"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a438ddeafc28f4bd634595cfd3f818653">rgb_to_hsv</a> (arr)</td></tr>
<tr class="separator:a438ddeafc28f4bd634595cfd3f818653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bbf313b0232a7aa888b3f21746c382" id="r_ac2bbf313b0232a7aa888b3f21746c382"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#ac2bbf313b0232a7aa888b3f21746c382">hsv_to_rgb</a> (hsv)</td></tr>
<tr class="separator:ac2bbf313b0232a7aa888b3f21746c382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1ff44810729f28c447b62e8c8f0cee" id="r_aac1ff44810729f28c447b62e8c8f0cee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#aac1ff44810729f28c447b62e8c8f0cee">_vector_magnitude</a> (arr)</td></tr>
<tr class="separator:aac1ff44810729f28c447b62e8c8f0cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ce6ceaef6d5a048b87f32a35ffcbdb" id="r_aa8ce6ceaef6d5a048b87f32a35ffcbdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#aa8ce6ceaef6d5a048b87f32a35ffcbdb">from_levels_and_colors</a> (levels, colors, extend='neither')</td></tr>
<tr class="separator:aa8ce6ceaef6d5a048b87f32a35ffcbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2f318eaae7d8d7ab6f091a9bd3df41d2" id="r_a2f318eaae7d8d7ab6f091a9bd3df41d2"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a2f318eaae7d8d7ab6f091a9bd3df41d2">_colors_full_map</a> = {}</td></tr>
<tr class="separator:a2f318eaae7d8d7ab6f091a9bd3df41d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8695892fea8ad310449628e8dad7e" id="r_a05a8695892fea8ad310449628e8dad7e"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a05a8695892fea8ad310449628e8dad7e">_REPR_PNG_SIZE</a> = (512, 64)</td></tr>
<tr class="separator:a05a8695892fea8ad310449628e8dad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4307f893813eba322104c8f3bf535ff5" id="r_a4307f893813eba322104c8f3bf535ff5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a4307f893813eba322104c8f3bf535ff5">_color_sequences</a> = <a class="el" href="classmatplotlib_1_1colors_1_1_color_sequence_registry.html">ColorSequenceRegistry</a>()</td></tr>
<tr class="separator:a4307f893813eba322104c8f3bf535ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5786340f4f4fddf7665e5246eaf75d68" id="r_a5786340f4f4fddf7665e5246eaf75d68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a5786340f4f4fddf7665e5246eaf75d68">cnames</a> = CSS4_COLORS</td></tr>
<tr class="memdesc:a5786340f4f4fddf7665e5246eaf75d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backwards-compatible color-conversion API.  <br /></td></tr>
<tr class="separator:a5786340f4f4fddf7665e5246eaf75d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26cd70a131ac31abe1aa77acf04c3d7" id="r_af26cd70a131ac31abe1aa77acf04c3d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#af26cd70a131ac31abe1aa77acf04c3d7">hexColorPattern</a> = re.compile(r&quot;\A#[<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>-fA-F0-9]{6}\Z&quot;)</td></tr>
<tr class="separator:af26cd70a131ac31abe1aa77acf04c3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4654955df88176e133b049797744290" id="r_ab4654955df88176e133b049797744290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#ab4654955df88176e133b049797744290">rgb2hex</a> = <a class="el" href="namespacematplotlib_1_1colors.html#a35d98b0f57844e85cbc263cdf8aaa55e">to_hex</a></td></tr>
<tr class="separator:ab4654955df88176e133b049797744290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385cb604484fbd935417d0cc8bf38ab5" id="r_a385cb604484fbd935417d0cc8bf38ab5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a385cb604484fbd935417d0cc8bf38ab5">hex2color</a> = <a class="el" href="namespacematplotlib_1_1colors.html#a4e44dff433013eff6271388e066b5fa3">to_rgb</a></td></tr>
<tr class="separator:a385cb604484fbd935417d0cc8bf38ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f1473cd90343845e171b405e1add8c" id="r_ae0f1473cd90343845e171b405e1add8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#ae0f1473cd90343845e171b405e1add8c">colorConverter</a> = <a class="el" href="classmatplotlib_1_1colors_1_1_color_converter.html">ColorConverter</a>()</td></tr>
<tr class="separator:ae0f1473cd90343845e171b405e1add8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2ef6b5f12a92b335f6dde12ec491f6" id="r_a5f2ef6b5f12a92b335f6dde12ec491f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a5f2ef6b5f12a92b335f6dde12ec491f6">LogNorm</a></td></tr>
<tr class="separator:a5f2ef6b5f12a92b335f6dde12ec491f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b190205df4e5a5765c42bb1dc058f4" id="r_a16b190205df4e5a5765c42bb1dc058f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a16b190205df4e5a5765c42bb1dc058f4">_scale</a></td></tr>
<tr class="separator:a16b190205df4e5a5765c42bb1dc058f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db28ee4d900bf6e908bd8e4b19808dd" id="r_a9db28ee4d900bf6e908bd8e4b19808dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a9db28ee4d900bf6e908bd8e4b19808dd">_trf</a></td></tr>
<tr class="separator:a9db28ee4d900bf6e908bd8e4b19808dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fab219e2255adac7821722f85263bf" id="r_a64fab219e2255adac7821722f85263bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1colors.html#a64fab219e2255adac7821722f85263bf">vmin</a></td></tr>
<tr class="separator:a64fab219e2255adac7821722f85263bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">A module for converting numbers or color arguments to *RGB* or *RGBA*.

*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
range 0-1.

This module includes functions and classes for color specification conversions,
and for mapping numbers to colors in a 1-D array of colors called a colormap.

Mapping data onto colors using a colormap typically involves two steps: a data
array is first mapped onto the range 0-1 using a subclass of `Normalize`,
then this number is mapped to a color using a subclass of `Colormap`.  Two
subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
makes a colormap from a list of colors.

.. seealso::

  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
  make colormaps and

  :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.

  :doc:`/tutorials/colors/colormapnorms` for more details about data
  normalization

  More colormaps are available at palettable_.

The module also provides functions for checking whether an object can be
interpreted as a color (`is_color_like`), for converting such an object
to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
"#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
RGBA array (`to_rgba_array`).  Caching is used for efficiency.

Colors that Matplotlib recognizes are listed at
:doc:`/tutorials/colors/colors`.

.. _palettable: https://jiffyclub.github.io/palettable/
.. _xkcd color survey: https://xkcd.com/color/rgb/
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6fe8f49c5c2420733da38e0b2a55469f" name="a6fe8f49c5c2420733da38e0b2a55469f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe8f49c5c2420733da38e0b2a55469f">&#9670;&#160;</a></span>_check_color_like()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._check_color_like </td>
          <td>(</td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">For each *key, value* pair in *kwargs*, check that *value* is color-like.
</pre> <div class="fragment"><div class="line"><span class="lineno">  237</span><span class="keyword">def </span>_check_color_like(**kwargs):</div>
<div class="line"><span class="lineno">  238</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    For each *key, value* pair in *kwargs*, check that *value* is color-like.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  241</span>    <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> kwargs.items():</div>
<div class="line"><span class="lineno">  242</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_color_like(v):</div>
<div class="line"><span class="lineno">  243</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;{v!r} is not a valid value for {k}&quot;</span>)</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad89722be80a5518c33dd3adfb55ff52f" name="ad89722be80a5518c33dd3adfb55ff52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89722be80a5518c33dd3adfb55ff52f">&#9670;&#160;</a></span>_create_empty_object_of_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._create_empty_object_of_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1743</span><span class="keyword">def </span>_create_empty_object_of_class(cls):</div>
<div class="line"><span class="lineno"> 1744</span>    <span class="keywordflow">return</span> cls.__new__(cls)</div>
<div class="line"><span class="lineno"> 1745</span> </div>
<div class="line"><span class="lineno"> 1746</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a022bf41b256e7295f44d7ccbbb3fcdc0" name="a022bf41b256e7295f44d7ccbbb3fcdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022bf41b256e7295f44d7ccbbb3fcdc0">&#9670;&#160;</a></span>_create_lookup_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._create_lookup_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of backwards-compatible color-conversion API. </p>
<pre class="fragment">    Create an *N* -element 1D lookup table.

    This assumes a mapping :math:`f : [0, 1] \rightarrow [0, 1]`. The returned
    data is an array of N values :math:`y = f(x)` where x is sampled from
    [0, 1].

    By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The
    *gamma* correction factor :math:`\gamma` distorts this equidistant
    sampling by :math:`x \rightarrow x^\gamma`.

    Parameters
    ----------
    N : int
        The number of elements of the created lookup table; at least 1.

    data : (M, 3) array-like or callable
        Defines the mapping :math:`f`.

        If a (M, 3) array-like, the rows define values (x, y0, y1).  The x
        values must start with x=0, end with x=1, and all x values be in
        increasing order.

        A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range
        :math:`y^1_{i-1} \ldots y^0_i` by linear interpolation.

        For the simple case of a y-continuous mapping, y0 and y1 are identical.

        The two values of y are to allow for discontinuous mapping functions.
        E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::

            [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]

        In the special case of ``N == 1``, by convention the returned value
        is y0 for x == 1.

        If *data* is a callable, it must accept and return numpy arrays::

           data(x : ndarray) -&gt; ndarray

        and map values between 0 - 1 to 0 - 1.

    gamma : float
        Gamma correction factor for input distribution x of the mapping.

        See also https://en.wikipedia.org/wiki/Gamma_correction.

    Returns
    -------
    array
        The lookup table where ``lut[x * (N-1)]`` gives the closest value
        for values of x between 0 and 1.

    Notes
    -----
    This function is internally used for `.LinearSegmentedColormap`.</pre> <div class="fragment"><div class="line"><span class="lineno">  549</span><span class="keyword">def </span>_create_lookup_table(N, data, gamma=1.0):</div>
<div class="line"><span class="lineno">  550</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    Create an *N* -element 1D lookup table.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    This assumes a mapping :math:`f : [0, 1] \rightarrow [0, 1]`. The returned</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    data is an array of N values :math:`y = f(x)` where x is sampled from</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    [0, 1].</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    *gamma* correction factor :math:`\gamma` distorts this equidistant</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    sampling by :math:`x \rightarrow x^\gamma`.</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    N : int</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">        The number of elements of the created lookup table; at least 1.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    data : (M, 3) array-like or callable</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        Defines the mapping :math:`f`.</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        If a (M, 3) array-like, the rows define values (x, y0, y1).  The x</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        values must start with x=0, end with x=1, and all x values be in</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        increasing order.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        :math:`y^1_{i-1} \ldots y^0_i` by linear interpolation.</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        For the simple case of a y-continuous mapping, y0 and y1 are identical.</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        The two values of y are to allow for discontinuous mapping functions.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">            [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        In the special case of ``N == 1``, by convention the returned value</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        is y0 for x == 1.</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        If *data* is a callable, it must accept and return numpy arrays::</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">           data(x : ndarray) -&gt; ndarray</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">        and map values between 0 - 1 to 0 - 1.</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    gamma : float</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        Gamma correction factor for input distribution x of the mapping.</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        See also https://en.wikipedia.org/wiki/Gamma_correction.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    array</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">        The lookup table where ``lut[x * (N-1)]`` gives the closest value</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        for values of x between 0 and 1.</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    This function is internally used for `.LinearSegmentedColormap`.</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>    <span class="keywordflow">if</span> callable(data):</div>
<div class="line"><span class="lineno">  609</span>        xind = np.linspace(0, 1, N) ** gamma</div>
<div class="line"><span class="lineno">  610</span>        lut = np.clip(np.array(data(xind), dtype=float), 0, 1)</div>
<div class="line"><span class="lineno">  611</span>        <span class="keywordflow">return</span> lut</div>
<div class="line"><span class="lineno">  612</span> </div>
<div class="line"><span class="lineno">  613</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  614</span>        adata = np.array(data)</div>
<div class="line"><span class="lineno">  615</span>    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  616</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;data must be convertible to an array&quot;</span>) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  617</span>    _api.check_shape((<span class="keywordtype">None</span>, 3), data=adata)</div>
<div class="line"><span class="lineno">  618</span> </div>
<div class="line"><span class="lineno">  619</span>    x = adata[:, 0]</div>
<div class="line"><span class="lineno">  620</span>    y0 = adata[:, 1]</div>
<div class="line"><span class="lineno">  621</span>    y1 = adata[:, 2]</div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span>    <span class="keywordflow">if</span> x[0] != 0. <span class="keywordflow">or</span> x[-1] != 1.0:</div>
<div class="line"><span class="lineno">  624</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  625</span>            <span class="stringliteral">&quot;data mapping points must start with x=0 and end with x=1&quot;</span>)</div>
<div class="line"><span class="lineno">  626</span>    <span class="keywordflow">if</span> (np.diff(x) &lt; 0).any():</div>
<div class="line"><span class="lineno">  627</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;data mapping points must have x in increasing order&quot;</span>)</div>
<div class="line"><span class="lineno">  628</span>    <span class="comment"># begin generation of lookup table</span></div>
<div class="line"><span class="lineno">  629</span>    <span class="keywordflow">if</span> N == 1:</div>
<div class="line"><span class="lineno">  630</span>        <span class="comment"># convention: use the y = f(x=1) value for a 1-element lookup table</span></div>
<div class="line"><span class="lineno">  631</span>        lut = np.array(y0[-1])</div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  633</span>        x = x * (N - 1)</div>
<div class="line"><span class="lineno">  634</span>        xind = (N - 1) * np.linspace(0, 1, N) ** gamma</div>
<div class="line"><span class="lineno">  635</span>        ind = np.searchsorted(x, xind)[1:-1]</div>
<div class="line"><span class="lineno">  636</span> </div>
<div class="line"><span class="lineno">  637</span>        distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])</div>
<div class="line"><span class="lineno">  638</span>        lut = np.concatenate([</div>
<div class="line"><span class="lineno">  639</span>            [y1[0]],</div>
<div class="line"><span class="lineno">  640</span>            distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],</div>
<div class="line"><span class="lineno">  641</span>            [y0[-1]],</div>
<div class="line"><span class="lineno">  642</span>        ])</div>
<div class="line"><span class="lineno">  643</span>    <span class="comment"># ensure that the lut is confined to values between 0 and 1 by clipping it</span></div>
<div class="line"><span class="lineno">  644</span>    <span class="keywordflow">return</span> np.clip(lut, 0.0, 1.0)</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a09c83d570876c5f5032771d68d8a5e00" name="a09c83d570876c5f5032771d68d8a5e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c83d570876c5f5032771d68d8a5e00">&#9670;&#160;</a></span>_has_alpha_channel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._has_alpha_channel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return whether *c* is a color with an alpha channel.</pre> <div class="fragment"><div class="line"><span class="lineno">  231</span><span class="keyword">def </span>_has_alpha_channel(c):</div>
<div class="line"><span class="lineno">  232</span>    <span class="stringliteral">&quot;&quot;&quot;Return whether *c* is a color with an alpha channel.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  233</span>    <span class="comment"># 4-element sequences are interpreted as r, g, b, a</span></div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">return</span> <span class="keywordflow">not</span> isinstance(c, str) <span class="keywordflow">and</span> len(c) == 4</div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acded809f300a8f44dc60eb08574d38e2" name="acded809f300a8f44dc60eb08574d38e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acded809f300a8f44dc60eb08574d38e2">&#9670;&#160;</a></span>_is_nth_color()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._is_nth_color </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return whether *c* can be interpreted as an item in the color cycle.</pre> <div class="fragment"><div class="line"><span class="lineno">  213</span><span class="keyword">def </span>_is_nth_color(c):</div>
<div class="line"><span class="lineno">  214</span>    <span class="stringliteral">&quot;&quot;&quot;Return whether *c* can be interpreted as an item in the color cycle.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  215</span>    <span class="keywordflow">return</span> isinstance(c, str) <span class="keywordflow">and</span> re.match(<span class="stringliteral">r&quot;\AC[0-9]+\Z&quot;</span>, c)</div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa142d79f2c22a9efaefa55e0755d5140" name="aa142d79f2c22a9efaefa55e0755d5140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142d79f2c22a9efaefa55e0755d5140">&#9670;&#160;</a></span>_make_norm_from_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._make_norm_from_scale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_kwargs_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_norm_cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bound_init_signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper for `make_norm_from_scale`.

This function is split out to enable caching (in particular so that
different unpickles reuse the same class).  In order to do so,

- ``functools.partial`` *scale_cls* is expanded into ``func, args, kwargs``
  to allow memoizing returned norms (partial instances always compare
  unequal, but we can check identity based on ``func, args, kwargs``;
- *init* is replaced by *init_signature*, as signatures are picklable,
  unlike to arbitrary lambdas.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1632</span>):</div>
<div class="line"><span class="lineno"> 1633</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    Helper for `make_norm_from_scale`.</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    This function is split out to enable caching (in particular so that</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    different unpickles reuse the same class).  In order to do so,</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">    - ``functools.partial`` *scale_cls* is expanded into ``func, args, kwargs``</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">      to allow memoizing returned norms (partial instances always compare</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">      unequal, but we can check identity based on ``func, args, kwargs``;</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">    - *init* is replaced by *init_signature*, as signatures are picklable,</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">      unlike to arbitrary lambdas.</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1645</span> </div>
<div class="line"><span class="lineno"> 1646</span>    <span class="keyword">class </span>Norm(base_norm_cls):</div>
<div class="line"><span class="lineno"> 1647</span>        <span class="keyword">def </span>__reduce__(self):</div>
<div class="line"><span class="lineno"> 1648</span>            cls = type(self)</div>
<div class="line"><span class="lineno"> 1649</span>            <span class="comment"># If the class is toplevel-accessible, it is possible to directly</span></div>
<div class="line"><span class="lineno"> 1650</span>            <span class="comment"># pickle it &quot;by name&quot;.  This is required to support norm classes</span></div>
<div class="line"><span class="lineno"> 1651</span>            <span class="comment"># defined at a module&#39;s toplevel, as the inner base_norm_cls is</span></div>
<div class="line"><span class="lineno"> 1652</span>            <span class="comment"># otherwise unpicklable (as it gets shadowed by the generated norm</span></div>
<div class="line"><span class="lineno"> 1653</span>            <span class="comment"># class).  If either import or attribute access fails, fall back to</span></div>
<div class="line"><span class="lineno"> 1654</span>            <span class="comment"># the general path.</span></div>
<div class="line"><span class="lineno"> 1655</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1656</span>                <span class="keywordflow">if</span> cls <span class="keywordflow">is</span> getattr(importlib.import_module(cls.__module__),</div>
<div class="line"><span class="lineno"> 1657</span>                                  cls.__qualname__):</div>
<div class="line"><span class="lineno"> 1658</span>                    <span class="keywordflow">return</span> (_create_empty_object_of_class, (cls,), vars(self))</div>
<div class="line"><span class="lineno"> 1659</span>            <span class="keywordflow">except</span> (ImportError, AttributeError):</div>
<div class="line"><span class="lineno"> 1660</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1661</span>            <span class="keywordflow">return</span> (_picklable_norm_constructor,</div>
<div class="line"><span class="lineno"> 1662</span>                    (scale_cls, scale_args, scale_kwargs_items,</div>
<div class="line"><span class="lineno"> 1663</span>                     base_norm_cls, bound_init_signature),</div>
<div class="line"><span class="lineno"> 1664</span>                    vars(self))</div>
<div class="line"><span class="lineno"> 1665</span> </div>
<div class="line"><span class="lineno"> 1666</span>        <span class="keyword">def </span>__init__(self, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 1667</span>            ba = bound_init_signature.bind(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 1668</span>            ba.apply_defaults()</div>
<div class="line"><span class="lineno"> 1669</span>            super().__init__(</div>
<div class="line"><span class="lineno"> 1670</span>                **{k: ba.arguments.pop(k) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> [<span class="stringliteral">&quot;vmin&quot;</span>, <span class="stringliteral">&quot;vmax&quot;</span>, <span class="stringliteral">&quot;clip&quot;</span>]})</div>
<div class="line"><span class="lineno"> 1671</span>            self._scale = functools.partial(</div>
<div class="line"><span class="lineno"> 1672</span>                scale_cls, *scale_args, **dict(scale_kwargs_items))(</div>
<div class="line"><span class="lineno"> 1673</span>                    axis=<span class="keywordtype">None</span>, **ba.arguments)</div>
<div class="line"><span class="lineno"> 1674</span>            self._trf = self._scale.get_transform()</div>
<div class="line"><span class="lineno"> 1675</span> </div>
<div class="line"><span class="lineno"> 1676</span>        __init__.__signature__ = bound_init_signature.replace(parameters=[</div>
<div class="line"><span class="lineno"> 1677</span>            inspect.Parameter(<span class="stringliteral">&quot;self&quot;</span>, inspect.Parameter.POSITIONAL_OR_KEYWORD),</div>
<div class="line"><span class="lineno"> 1678</span>            *bound_init_signature.parameters.values()])</div>
<div class="line"><span class="lineno"> 1679</span> </div>
<div class="line"><span class="lineno"> 1680</span>        <span class="keyword">def </span>__call__(self, value, clip=None):</div>
<div class="line"><span class="lineno"> 1681</span>            value, is_scalar = self.process_value(value)</div>
<div class="line"><span class="lineno"> 1682</span>            <span class="keywordflow">if</span> self.vmin <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> self.vmax <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1683</span>                self.autoscale_None(value)</div>
<div class="line"><span class="lineno"> 1684</span>            <span class="keywordflow">if</span> self.vmin &gt; self.vmax:</div>
<div class="line"><span class="lineno"> 1685</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;vmin must be less or equal to vmax&quot;</span>)</div>
<div class="line"><span class="lineno"> 1686</span>            <span class="keywordflow">if</span> self.vmin == self.vmax:</div>
<div class="line"><span class="lineno"> 1687</span>                <span class="keywordflow">return</span> np.full_like(value, 0)</div>
<div class="line"><span class="lineno"> 1688</span>            <span class="keywordflow">if</span> clip <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1689</span>                clip = self.clip</div>
<div class="line"><span class="lineno"> 1690</span>            <span class="keywordflow">if</span> clip:</div>
<div class="line"><span class="lineno"> 1691</span>                value = np.clip(value, self.vmin, self.vmax)</div>
<div class="line"><span class="lineno"> 1692</span>            t_value = self._trf.transform(value).reshape(np.shape(value))</div>
<div class="line"><span class="lineno"> 1693</span>            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])</div>
<div class="line"><span class="lineno"> 1694</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite([t_vmin, t_vmax]).all():</div>
<div class="line"><span class="lineno"> 1695</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid vmin or vmax&quot;</span>)</div>
<div class="line"><span class="lineno"> 1696</span>            t_value -= t_vmin</div>
<div class="line"><span class="lineno"> 1697</span>            t_value /= (t_vmax - t_vmin)</div>
<div class="line"><span class="lineno"> 1698</span>            t_value = np.ma.masked_invalid(t_value, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1699</span>            <span class="keywordflow">return</span> t_value[0] <span class="keywordflow">if</span> is_scalar <span class="keywordflow">else</span> t_value</div>
<div class="line"><span class="lineno"> 1700</span> </div>
<div class="line"><span class="lineno"> 1701</span>        <span class="keyword">def </span>inverse(self, value):</div>
<div class="line"><span class="lineno"> 1702</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.scaled():</div>
<div class="line"><span class="lineno"> 1703</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Not invertible until scaled&quot;</span>)</div>
<div class="line"><span class="lineno"> 1704</span>            <span class="keywordflow">if</span> self.vmin &gt; self.vmax:</div>
<div class="line"><span class="lineno"> 1705</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;vmin must be less or equal to vmax&quot;</span>)</div>
<div class="line"><span class="lineno"> 1706</span>            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])</div>
<div class="line"><span class="lineno"> 1707</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite([t_vmin, t_vmax]).all():</div>
<div class="line"><span class="lineno"> 1708</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid vmin or vmax&quot;</span>)</div>
<div class="line"><span class="lineno"> 1709</span>            value, is_scalar = self.process_value(value)</div>
<div class="line"><span class="lineno"> 1710</span>            rescaled = value * (t_vmax - t_vmin)</div>
<div class="line"><span class="lineno"> 1711</span>            rescaled += t_vmin</div>
<div class="line"><span class="lineno"> 1712</span>            value = (self._trf</div>
<div class="line"><span class="lineno"> 1713</span>                     .inverted()</div>
<div class="line"><span class="lineno"> 1714</span>                     .transform(rescaled)</div>
<div class="line"><span class="lineno"> 1715</span>                     .reshape(np.shape(value)))</div>
<div class="line"><span class="lineno"> 1716</span>            <span class="keywordflow">return</span> value[0] <span class="keywordflow">if</span> is_scalar <span class="keywordflow">else</span> value</div>
<div class="line"><span class="lineno"> 1717</span> </div>
<div class="line"><span class="lineno"> 1718</span>        <span class="keyword">def </span>autoscale(self, A):</div>
<div class="line"><span class="lineno"> 1719</span>            <span class="comment"># i.e. A[np.isfinite(...)], but also for non-array A&#39;s</span></div>
<div class="line"><span class="lineno"> 1720</span>            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)</div>
<div class="line"><span class="lineno"> 1721</span>            <span class="keywordflow">if</span> in_trf_domain.size == 0:</div>
<div class="line"><span class="lineno"> 1722</span>                in_trf_domain = np.ma.masked</div>
<div class="line"><span class="lineno"> 1723</span>            <span class="keywordflow">return</span> super().autoscale(in_trf_domain)</div>
<div class="line"><span class="lineno"> 1724</span> </div>
<div class="line"><span class="lineno"> 1725</span>        <span class="keyword">def </span>autoscale_None(self, A):</div>
<div class="line"><span class="lineno"> 1726</span>            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)</div>
<div class="line"><span class="lineno"> 1727</span>            <span class="keywordflow">if</span> in_trf_domain.size == 0:</div>
<div class="line"><span class="lineno"> 1728</span>                in_trf_domain = np.ma.masked</div>
<div class="line"><span class="lineno"> 1729</span>            <span class="keywordflow">return</span> super().autoscale_None(in_trf_domain)</div>
<div class="line"><span class="lineno"> 1730</span> </div>
<div class="line"><span class="lineno"> 1731</span>    <span class="keywordflow">if</span> base_norm_cls <span class="keywordflow">is</span> Normalize:</div>
<div class="line"><span class="lineno"> 1732</span>        Norm.__name__ = f<span class="stringliteral">&quot;{scale_cls.__name__}Norm&quot;</span></div>
<div class="line"><span class="lineno"> 1733</span>        Norm.__qualname__ = f<span class="stringliteral">&quot;{scale_cls.__qualname__}Norm&quot;</span></div>
<div class="line"><span class="lineno"> 1734</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1735</span>        Norm.__name__ = base_norm_cls.__name__</div>
<div class="line"><span class="lineno"> 1736</span>        Norm.__qualname__ = base_norm_cls.__qualname__</div>
<div class="line"><span class="lineno"> 1737</span>    Norm.__module__ = base_norm_cls.__module__</div>
<div class="line"><span class="lineno"> 1738</span>    Norm.__doc__ = base_norm_cls.__doc__</div>
<div class="line"><span class="lineno"> 1739</span> </div>
<div class="line"><span class="lineno"> 1740</span>    <span class="keywordflow">return</span> Norm</div>
<div class="line"><span class="lineno"> 1741</span> </div>
<div class="line"><span class="lineno"> 1742</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a317910a2b93745b4d49f16873d9f414f" name="a317910a2b93745b4d49f16873d9f414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317910a2b93745b4d49f16873d9f414f">&#9670;&#160;</a></span>_picklable_norm_constructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._picklable_norm_constructor </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1747</span><span class="keyword">def </span>_picklable_norm_constructor(*args):</div>
<div class="line"><span class="lineno"> 1748</span>    <span class="keywordflow">return</span> _create_empty_object_of_class(_make_norm_from_scale(*args))</div>
<div class="line"><span class="lineno"> 1749</span> </div>
<div class="line"><span class="lineno"> 1750</span> </div>
<div class="line"><span class="lineno"> 1751</span><span class="preprocessor">@make_norm_from_scale</span>(</div>
<div class="line"><span class="lineno"> 1752</span>    scale.FuncScale,</div>
<div class="line"><span class="lineno"> 1753</span>    init=<span class="keyword">lambda</span> functions, vmin=<span class="keywordtype">None</span>, vmax=<span class="keywordtype">None</span>, clip=<span class="keyword">False</span>: <span class="keywordtype">None</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a616854babc5a0b26f6b4455827b917f6" name="a616854babc5a0b26f6b4455827b917f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616854babc5a0b26f6b4455827b917f6">&#9670;&#160;</a></span>_sanitize_extrema()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._sanitize_extrema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  203</span><span class="keyword">def </span>_sanitize_extrema(ex):</div>
<div class="line"><span class="lineno">  204</span>    <span class="keywordflow">if</span> ex <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  205</span>        <span class="keywordflow">return</span> ex</div>
<div class="line"><span class="lineno">  206</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  207</span>        ret = ex.item()</div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno">  209</span>        ret = float(ex)</div>
<div class="line"><span class="lineno">  210</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a63976eb873aff7154156b9fe954ff23b" name="a63976eb873aff7154156b9fe954ff23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63976eb873aff7154156b9fe954ff23b">&#9670;&#160;</a></span>_to_rgba_no_colorcycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._to_rgba_no_colorcycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert *c* to an RGBA color, with no support for color-cycle syntax.

If *alpha* is given, force the alpha value of the returned RGBA tuple
to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha
information, or defaults to 1.

*alpha* is ignored for the color value ``"none"`` (case-insensitive),
which always maps to ``(0, 0, 0, 0)``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  307</span><span class="keyword">def </span>_to_rgba_no_colorcycle(c, alpha=None):</div>
<div class="line"><span class="lineno">  308</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    Convert *c* to an RGBA color, with no support for color-cycle syntax.</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    If *alpha* is given, force the alpha value of the returned RGBA tuple</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    information, or defaults to 1.</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    *alpha* is ignored for the color value ``&quot;none&quot;`` (case-insensitive),</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    which always maps to ``(0, 0, 0, 0)``.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  318</span>    orig_c = c</div>
<div class="line"><span class="lineno">  319</span>    <span class="keywordflow">if</span> c <span class="keywordflow">is</span> np.ma.masked:</div>
<div class="line"><span class="lineno">  320</span>        <span class="keywordflow">return</span> (0., 0., 0., 0.)</div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">if</span> isinstance(c, str):</div>
<div class="line"><span class="lineno">  322</span>        <span class="keywordflow">if</span> c.lower() == <span class="stringliteral">&quot;none&quot;</span>:</div>
<div class="line"><span class="lineno">  323</span>            <span class="keywordflow">return</span> (0., 0., 0., 0.)</div>
<div class="line"><span class="lineno">  324</span>        <span class="comment"># Named color.</span></div>
<div class="line"><span class="lineno">  325</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  326</span>            <span class="comment"># This may turn c into a non-string, so we check again below.</span></div>
<div class="line"><span class="lineno">  327</span>            c = _colors_full_map[c]</div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno">  329</span>            <span class="keywordflow">if</span> len(orig_c) != 1:</div>
<div class="line"><span class="lineno">  330</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  331</span>                    c = _colors_full_map[c.lower()]</div>
<div class="line"><span class="lineno">  332</span>                <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno">  333</span>                    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  334</span>    <span class="keywordflow">if</span> isinstance(c, str):</div>
<div class="line"><span class="lineno">  335</span>        <span class="comment"># hex color in #rrggbb format.</span></div>
<div class="line"><span class="lineno">  336</span>        match = re.match(<span class="stringliteral">r&quot;\A#[a-fA-F0-9]{6}\Z&quot;</span>, c)</div>
<div class="line"><span class="lineno">  337</span>        <span class="keywordflow">if</span> match:</div>
<div class="line"><span class="lineno">  338</span>            <span class="keywordflow">return</span> (tuple(int(n, 16) / 255</div>
<div class="line"><span class="lineno">  339</span>                          <span class="keywordflow">for</span> n <span class="keywordflow">in</span> [c[1:3], c[3:5], c[5:7]])</div>
<div class="line"><span class="lineno">  340</span>                    + (alpha <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> 1.,))</div>
<div class="line"><span class="lineno">  341</span>        <span class="comment"># hex color in #rgb format, shorthand for #rrggbb.</span></div>
<div class="line"><span class="lineno">  342</span>        match = re.match(<span class="stringliteral">r&quot;\A#[a-fA-F0-9]{3}\Z&quot;</span>, c)</div>
<div class="line"><span class="lineno">  343</span>        <span class="keywordflow">if</span> match:</div>
<div class="line"><span class="lineno">  344</span>            <span class="keywordflow">return</span> (tuple(int(n, 16) / 255</div>
<div class="line"><span class="lineno">  345</span>                          <span class="keywordflow">for</span> n <span class="keywordflow">in</span> [c[1]*2, c[2]*2, c[3]*2])</div>
<div class="line"><span class="lineno">  346</span>                    + (alpha <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> 1.,))</div>
<div class="line"><span class="lineno">  347</span>        <span class="comment"># hex color with alpha in #rrggbbaa format.</span></div>
<div class="line"><span class="lineno">  348</span>        match = re.match(<span class="stringliteral">r&quot;\A#[a-fA-F0-9]{8}\Z&quot;</span>, c)</div>
<div class="line"><span class="lineno">  349</span>        <span class="keywordflow">if</span> match:</div>
<div class="line"><span class="lineno">  350</span>            color = [int(n, 16) / 255</div>
<div class="line"><span class="lineno">  351</span>                     <span class="keywordflow">for</span> n <span class="keywordflow">in</span> [c[1:3], c[3:5], c[5:7], c[7:9]]]</div>
<div class="line"><span class="lineno">  352</span>            <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  353</span>                color[-1] = alpha</div>
<div class="line"><span class="lineno">  354</span>            <span class="keywordflow">return</span> tuple(color)</div>
<div class="line"><span class="lineno">  355</span>        <span class="comment"># hex color with alpha in #rgba format, shorthand for #rrggbbaa.</span></div>
<div class="line"><span class="lineno">  356</span>        match = re.match(<span class="stringliteral">r&quot;\A#[a-fA-F0-9]{4}\Z&quot;</span>, c)</div>
<div class="line"><span class="lineno">  357</span>        <span class="keywordflow">if</span> match:</div>
<div class="line"><span class="lineno">  358</span>            color = [int(n, 16) / 255</div>
<div class="line"><span class="lineno">  359</span>                     <span class="keywordflow">for</span> n <span class="keywordflow">in</span> [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]</div>
<div class="line"><span class="lineno">  360</span>            <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  361</span>                color[-1] = alpha</div>
<div class="line"><span class="lineno">  362</span>            <span class="keywordflow">return</span> tuple(color)</div>
<div class="line"><span class="lineno">  363</span>        <span class="comment"># string gray.</span></div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  365</span>            c = float(c)</div>
<div class="line"><span class="lineno">  366</span>        <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  367</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  368</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  369</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> (0 &lt;= c &lt;= 1):</div>
<div class="line"><span class="lineno">  370</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  371</span>                    f<span class="stringliteral">&quot;Invalid string grayscale value {orig_c!r}. &quot;</span></div>
<div class="line"><span class="lineno">  372</span>                    f<span class="stringliteral">&quot;Value must be within 0-1 range&quot;</span>)</div>
<div class="line"><span class="lineno">  373</span>            <span class="keywordflow">return</span> c, c, c, alpha <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> 1.</div>
<div class="line"><span class="lineno">  374</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid RGBA argument: {orig_c!r}&quot;</span>)</div>
<div class="line"><span class="lineno">  375</span>    <span class="comment"># turn 2-D array into 1-D array</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">if</span> isinstance(c, np.ndarray):</div>
<div class="line"><span class="lineno">  377</span>        <span class="keywordflow">if</span> c.ndim == 2 <span class="keywordflow">and</span> c.shape[0] == 1:</div>
<div class="line"><span class="lineno">  378</span>            c = c.reshape(-1)</div>
<div class="line"><span class="lineno">  379</span>    <span class="comment"># tuple color.</span></div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.iterable(c):</div>
<div class="line"><span class="lineno">  381</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid RGBA argument: {orig_c!r}&quot;</span>)</div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">if</span> len(c) <span class="keywordflow">not</span> <span class="keywordflow">in</span> [3, 4]:</div>
<div class="line"><span class="lineno">  383</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;RGBA sequence should have length 3 or 4&quot;</span>)</div>
<div class="line"><span class="lineno">  384</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> all(isinstance(x, Number) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> c):</div>
<div class="line"><span class="lineno">  385</span>        <span class="comment"># Checks that don&#39;t work: `map(float, ...)`, `np.array(..., float)` and</span></div>
<div class="line"><span class="lineno">  386</span>        <span class="comment"># `np.array(...).astype(float)` would all convert &quot;0.5&quot; to 0.5.</span></div>
<div class="line"><span class="lineno">  387</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid RGBA argument: {orig_c!r}&quot;</span>)</div>
<div class="line"><span class="lineno">  388</span>    <span class="comment"># Return a tuple to prevent the cached value from being modified.</span></div>
<div class="line"><span class="lineno">  389</span>    c = tuple(map(float, c))</div>
<div class="line"><span class="lineno">  390</span>    <span class="keywordflow">if</span> len(c) == 3 <span class="keywordflow">and</span> alpha <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  391</span>        alpha = 1</div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  393</span>        c = c[:3] + (alpha,)</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">if</span> any(elem &lt; 0 <span class="keywordflow">or</span> elem &gt; 1 <span class="keywordflow">for</span> elem <span class="keywordflow">in</span> c):</div>
<div class="line"><span class="lineno">  395</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;RGBA values should be within 0-1 range&quot;</span>)</div>
<div class="line"><span class="lineno">  396</span>    <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aac1ff44810729f28c447b62e8c8f0cee" name="aac1ff44810729f28c447b62e8c8f0cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1ff44810729f28c447b62e8c8f0cee">&#9670;&#160;</a></span>_vector_magnitude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._vector_magnitude </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2185</span><span class="keyword">def </span>_vector_magnitude(arr):</div>
<div class="line"><span class="lineno"> 2186</span>    <span class="comment"># things that don&#39;t work here:</span></div>
<div class="line"><span class="lineno"> 2187</span>    <span class="comment">#  * np.linalg.norm: drops mask from ma.array</span></div>
<div class="line"><span class="lineno"> 2188</span>    <span class="comment">#  * np.sum: drops mask from ma.array unless entire vector is masked</span></div>
<div class="line"><span class="lineno"> 2189</span>    sum_sq = 0</div>
<div class="line"><span class="lineno"> 2190</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(arr.shape[-1]):</div>
<div class="line"><span class="lineno"> 2191</span>        sum_sq += arr[..., i, np.newaxis] ** 2</div>
<div class="line"><span class="lineno"> 2192</span>    <span class="keywordflow">return</span> np.sqrt(sum_sq)</div>
<div class="line"><span class="lineno"> 2193</span> </div>
<div class="line"><span class="lineno"> 2194</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8ce6ceaef6d5a048b87f32a35ffcbdb" name="aa8ce6ceaef6d5a048b87f32a35ffcbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ce6ceaef6d5a048b87f32a35ffcbdb">&#9670;&#160;</a></span>from_levels_and_colors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.from_levels_and_colors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extend</em> = <code>'neither'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A helper routine to generate a cmap and a norm instance which
behave similar to contourf's levels and colors arguments.

Parameters
----------
levels : sequence of numbers
    The quantization levels used to construct the `BoundaryNorm`.
    Value ``v`` is quantized to level ``i`` if ``lev[i] &lt;= v &lt; lev[i+1]``.
colors : sequence of colors
    The fill color to use for each level. If *extend* is "neither" there
    must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
    one extra color, and for an *extend* of "both" add two colors.
extend : {'neither', 'min', 'max', 'both'}, optional
    The behaviour when a value falls out of range of the given levels.
    See `~.Axes.contourf` for details.

Returns
-------
cmap : `~matplotlib.colors.Normalize`
norm : `~matplotlib.colors.Colormap`
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2609</span><span class="keyword">def </span>from_levels_and_colors(levels, colors, extend=&#39;neither&#39;):</div>
<div class="line"><span class="lineno"> 2610</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2611</span><span class="stringliteral">    A helper routine to generate a cmap and a norm instance which</span></div>
<div class="line"><span class="lineno"> 2612</span><span class="stringliteral">    behave similar to contourf&#39;s levels and colors arguments.</span></div>
<div class="line"><span class="lineno"> 2613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2614</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2615</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2616</span><span class="stringliteral">    levels : sequence of numbers</span></div>
<div class="line"><span class="lineno"> 2617</span><span class="stringliteral">        The quantization levels used to construct the `BoundaryNorm`.</span></div>
<div class="line"><span class="lineno"> 2618</span><span class="stringliteral">        Value ``v`` is quantized to level ``i`` if ``lev[i] &lt;= v &lt; lev[i+1]``.</span></div>
<div class="line"><span class="lineno"> 2619</span><span class="stringliteral">    colors : sequence of colors</span></div>
<div class="line"><span class="lineno"> 2620</span><span class="stringliteral">        The fill color to use for each level. If *extend* is &quot;neither&quot; there</span></div>
<div class="line"><span class="lineno"> 2621</span><span class="stringliteral">        must be ``n_level - 1`` colors. For an *extend* of &quot;min&quot; or &quot;max&quot; add</span></div>
<div class="line"><span class="lineno"> 2622</span><span class="stringliteral">        one extra color, and for an *extend* of &quot;both&quot; add two colors.</span></div>
<div class="line"><span class="lineno"> 2623</span><span class="stringliteral">    extend : {&#39;neither&#39;, &#39;min&#39;, &#39;max&#39;, &#39;both&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2624</span><span class="stringliteral">        The behaviour when a value falls out of range of the given levels.</span></div>
<div class="line"><span class="lineno"> 2625</span><span class="stringliteral">        See `~.Axes.contourf` for details.</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">    cmap : `~matplotlib.colors.Normalize`</span></div>
<div class="line"><span class="lineno"> 2630</span><span class="stringliteral">    norm : `~matplotlib.colors.Colormap`</span></div>
<div class="line"><span class="lineno"> 2631</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2632</span>    slice_map = {</div>
<div class="line"><span class="lineno"> 2633</span>        <span class="stringliteral">&#39;both&#39;</span>: slice(1, -1),</div>
<div class="line"><span class="lineno"> 2634</span>        <span class="stringliteral">&#39;min&#39;</span>: slice(1, <span class="keywordtype">None</span>),</div>
<div class="line"><span class="lineno"> 2635</span>        <span class="stringliteral">&#39;max&#39;</span>: slice(0, -1),</div>
<div class="line"><span class="lineno"> 2636</span>        <span class="stringliteral">&#39;neither&#39;</span>: slice(0, <span class="keywordtype">None</span>),</div>
<div class="line"><span class="lineno"> 2637</span>    }</div>
<div class="line"><span class="lineno"> 2638</span>    _api.check_in_list(slice_map, extend=extend)</div>
<div class="line"><span class="lineno"> 2639</span>    color_slice = slice_map[extend]</div>
<div class="line"><span class="lineno"> 2640</span> </div>
<div class="line"><span class="lineno"> 2641</span>    n_data_colors = len(levels) - 1</div>
<div class="line"><span class="lineno"> 2642</span>    n_expected = n_data_colors + color_slice.start - (color_slice.stop <span class="keywordflow">or</span> 0)</div>
<div class="line"><span class="lineno"> 2643</span>    <span class="keywordflow">if</span> len(colors) != n_expected:</div>
<div class="line"><span class="lineno"> 2644</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2645</span>            f<span class="stringliteral">&#39;With extend == {extend!r} and {len(levels)} levels, &#39;</span></div>
<div class="line"><span class="lineno"> 2646</span>            f<span class="stringliteral">&#39;expected {n_expected} colors, but got {len(colors)}&#39;</span>)</div>
<div class="line"><span class="lineno"> 2647</span> </div>
<div class="line"><span class="lineno"> 2648</span>    cmap = ListedColormap(colors[color_slice], N=n_data_colors)</div>
<div class="line"><span class="lineno"> 2649</span> </div>
<div class="line"><span class="lineno"> 2650</span>    <span class="keywordflow">if</span> extend <span class="keywordflow">in</span> [<span class="stringliteral">&#39;min&#39;</span>, <span class="stringliteral">&#39;both&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2651</span>        cmap.set_under(colors[0])</div>
<div class="line"><span class="lineno"> 2652</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2653</span>        cmap.set_under(<span class="stringliteral">&#39;none&#39;</span>)</div>
<div class="line"><span class="lineno"> 2654</span> </div>
<div class="line"><span class="lineno"> 2655</span>    <span class="keywordflow">if</span> extend <span class="keywordflow">in</span> [<span class="stringliteral">&#39;max&#39;</span>, <span class="stringliteral">&#39;both&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2656</span>        cmap.set_over(colors[-1])</div>
<div class="line"><span class="lineno"> 2657</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2658</span>        cmap.set_over(<span class="stringliteral">&#39;none&#39;</span>)</div>
<div class="line"><span class="lineno"> 2659</span> </div>
<div class="line"><span class="lineno"> 2660</span>    cmap.colorbar_extend = extend</div>
<div class="line"><span class="lineno"> 2661</span> </div>
<div class="line"><span class="lineno"> 2662</span>    norm = BoundaryNorm(levels, ncolors=n_data_colors)</div>
<div class="line"><span class="lineno"> 2663</span>    <span class="keywordflow">return</span> cmap, norm</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fddddcc2b3b5cfbcccfb3f450e88305" name="a2fddddcc2b3b5cfbcccfb3f450e88305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fddddcc2b3b5cfbcccfb3f450e88305">&#9670;&#160;</a></span>get_named_colors_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.get_named_colors_mapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the global mapping of names to named colors.</pre> <div class="fragment"><div class="line"><span class="lineno">   91</span><span class="keyword">def </span>get_named_colors_mapping():</div>
<div class="line"><span class="lineno">   92</span>    <span class="stringliteral">&quot;&quot;&quot;Return the global mapping of names to named colors.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">return</span> _colors_full_map</div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2bbf313b0232a7aa888b3f21746c382" name="ac2bbf313b0232a7aa888b3f21746c382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bbf313b0232a7aa888b3f21746c382">&#9670;&#160;</a></span>hsv_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.hsv_to_rgb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hsv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert hsv values to rgb.

Parameters
----------
hsv : (..., 3) array-like
   All values assumed to be in range [0, 1]

Returns
-------
(..., 3) ndarray
   Colors converted to RGB values in range [0, 1]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2103</span><span class="keyword">def </span>hsv_to_rgb(hsv):</div>
<div class="line"><span class="lineno"> 2104</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">    Convert hsv values to rgb.</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">    hsv : (..., 3) array-like</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral">       All values assumed to be in range [0, 1]</span></div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">    (..., 3) ndarray</span></div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">       Colors converted to RGB values in range [0, 1]</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2117</span>    hsv = np.asarray(hsv)</div>
<div class="line"><span class="lineno"> 2118</span> </div>
<div class="line"><span class="lineno"> 2119</span>    <span class="comment"># check length of the last dimension, should be _some_ sort of rgb</span></div>
<div class="line"><span class="lineno"> 2120</span>    <span class="keywordflow">if</span> hsv.shape[-1] != 3:</div>
<div class="line"><span class="lineno"> 2121</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Last dimension of input array must be 3; &quot;</span></div>
<div class="line"><span class="lineno"> 2122</span>                         <span class="stringliteral">&quot;shape {shp} was found.&quot;</span>.format(shp=hsv.shape))</div>
<div class="line"><span class="lineno"> 2123</span> </div>
<div class="line"><span class="lineno"> 2124</span>    in_shape = hsv.shape</div>
<div class="line"><span class="lineno"> 2125</span>    hsv = np.array(</div>
<div class="line"><span class="lineno"> 2126</span>        hsv, copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 2127</span>        dtype=np.promote_types(hsv.dtype, np.float32),  <span class="comment"># Don&#39;t work on ints.</span></div>
<div class="line"><span class="lineno"> 2128</span>        ndmin=2,  <span class="comment"># In case input was 1D.</span></div>
<div class="line"><span class="lineno"> 2129</span>    )</div>
<div class="line"><span class="lineno"> 2130</span> </div>
<div class="line"><span class="lineno"> 2131</span>    h = hsv[..., 0]</div>
<div class="line"><span class="lineno"> 2132</span>    s = hsv[..., 1]</div>
<div class="line"><span class="lineno"> 2133</span>    v = hsv[..., 2]</div>
<div class="line"><span class="lineno"> 2134</span> </div>
<div class="line"><span class="lineno"> 2135</span>    r = np.empty_like(h)</div>
<div class="line"><span class="lineno"> 2136</span>    g = np.empty_like(h)</div>
<div class="line"><span class="lineno"> 2137</span>    b = np.empty_like(h)</div>
<div class="line"><span class="lineno"> 2138</span> </div>
<div class="line"><span class="lineno"> 2139</span>    i = (h * 6.0).astype(int)</div>
<div class="line"><span class="lineno"> 2140</span>    f = (h * 6.0) - i</div>
<div class="line"><span class="lineno"> 2141</span>    p = v * (1.0 - s)</div>
<div class="line"><span class="lineno"> 2142</span>    q = v * (1.0 - s * f)</div>
<div class="line"><span class="lineno"> 2143</span>    t = v * (1.0 - s * (1.0 - f))</div>
<div class="line"><span class="lineno"> 2144</span> </div>
<div class="line"><span class="lineno"> 2145</span>    idx = i % 6 == 0</div>
<div class="line"><span class="lineno"> 2146</span>    r[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2147</span>    g[idx] = t[idx]</div>
<div class="line"><span class="lineno"> 2148</span>    b[idx] = p[idx]</div>
<div class="line"><span class="lineno"> 2149</span> </div>
<div class="line"><span class="lineno"> 2150</span>    idx = i == 1</div>
<div class="line"><span class="lineno"> 2151</span>    r[idx] = q[idx]</div>
<div class="line"><span class="lineno"> 2152</span>    g[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2153</span>    b[idx] = p[idx]</div>
<div class="line"><span class="lineno"> 2154</span> </div>
<div class="line"><span class="lineno"> 2155</span>    idx = i == 2</div>
<div class="line"><span class="lineno"> 2156</span>    r[idx] = p[idx]</div>
<div class="line"><span class="lineno"> 2157</span>    g[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2158</span>    b[idx] = t[idx]</div>
<div class="line"><span class="lineno"> 2159</span> </div>
<div class="line"><span class="lineno"> 2160</span>    idx = i == 3</div>
<div class="line"><span class="lineno"> 2161</span>    r[idx] = p[idx]</div>
<div class="line"><span class="lineno"> 2162</span>    g[idx] = q[idx]</div>
<div class="line"><span class="lineno"> 2163</span>    b[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2164</span> </div>
<div class="line"><span class="lineno"> 2165</span>    idx = i == 4</div>
<div class="line"><span class="lineno"> 2166</span>    r[idx] = t[idx]</div>
<div class="line"><span class="lineno"> 2167</span>    g[idx] = p[idx]</div>
<div class="line"><span class="lineno"> 2168</span>    b[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2169</span> </div>
<div class="line"><span class="lineno"> 2170</span>    idx = i == 5</div>
<div class="line"><span class="lineno"> 2171</span>    r[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2172</span>    g[idx] = p[idx]</div>
<div class="line"><span class="lineno"> 2173</span>    b[idx] = q[idx]</div>
<div class="line"><span class="lineno"> 2174</span> </div>
<div class="line"><span class="lineno"> 2175</span>    idx = s == 0</div>
<div class="line"><span class="lineno"> 2176</span>    r[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2177</span>    g[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2178</span>    b[idx] = v[idx]</div>
<div class="line"><span class="lineno"> 2179</span> </div>
<div class="line"><span class="lineno"> 2180</span>    rgb = np.stack([r, g, b], axis=-1)</div>
<div class="line"><span class="lineno"> 2181</span> </div>
<div class="line"><span class="lineno"> 2182</span>    <span class="keywordflow">return</span> rgb.reshape(in_shape)</div>
<div class="line"><span class="lineno"> 2183</span> </div>
<div class="line"><span class="lineno"> 2184</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b8c380910d4179d1224af466c1292e1" name="a5b8c380910d4179d1224af466c1292e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c380910d4179d1224af466c1292e1">&#9670;&#160;</a></span>is_color_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.is_color_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether *c* can be interpreted as an RGB(A) color.</pre> <div class="fragment"><div class="line"><span class="lineno">  218</span><span class="keyword">def </span>is_color_like(c):</div>
<div class="line"><span class="lineno">  219</span>    <span class="stringliteral">&quot;&quot;&quot;Return whether *c* can be interpreted as an RGB(A) color.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  220</span>    <span class="comment"># Special-case nth color syntax because it cannot be parsed during setup.</span></div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">if</span> _is_nth_color(c):</div>
<div class="line"><span class="lineno">  222</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  223</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  224</span>        to_rgba(c)</div>
<div class="line"><span class="lineno">  225</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  226</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  228</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a723ca546163bf319134488e95a0f78a6" name="a723ca546163bf319134488e95a0f78a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723ca546163bf319134488e95a0f78a6">&#9670;&#160;</a></span>make_norm_from_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.make_norm_from_scale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_norm_cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>init</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
subclass.

After ::

    @make_norm_from_scale(scale_cls)
    class norm_cls(Normalize):
        ...

*norm_cls* is filled with methods so that normalization computations are
forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
for the colorbar of a mappable normalized with *norm_cls*).

If *init* is not passed, then the constructor signature of *norm_cls*
will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
parameters will be forwarded to the base class (``Normalize.__init__``),
and a *scale_cls* object will be initialized with no arguments (other than
a dummy axis).

If the *scale_cls* constructor takes additional parameters, then *init*
should be passed to `make_norm_from_scale`.  It is a callable which is
*only* used for its signature.  First, this signature will become the
signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
parameters passed to it using this signature, extract the bound *vmin*,
*vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
forward the remaining bound values (including any defaults defined by the
signature) to the *scale_cls* constructor.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1579</span><span class="keyword">def </span>make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):</div>
<div class="line"><span class="lineno"> 1580</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">    Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">    subclass.</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    After ::</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">        @make_norm_from_scale(scale_cls)</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">        class norm_cls(Normalize):</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">            ...</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">    *norm_cls* is filled with methods so that normalization computations are</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    for the colorbar of a mappable normalized with *norm_cls*).</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    If *init* is not passed, then the constructor signature of *norm_cls*</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    parameters will be forwarded to the base class (``Normalize.__init__``),</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    and a *scale_cls* object will be initialized with no arguments (other than</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">    a dummy axis).</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">    If the *scale_cls* constructor takes additional parameters, then *init*</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    should be passed to `make_norm_from_scale`.  It is a callable which is</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    *only* used for its signature.  First, this signature will become the</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">    signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">    parameters passed to it using this signature, extract the bound *vmin*,</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">    *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">    forward the remaining bound values (including any defaults defined by the</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">    signature) to the *scale_cls* constructor.</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1609</span> </div>
<div class="line"><span class="lineno"> 1610</span>    <span class="keywordflow">if</span> base_norm_cls <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1611</span>        <span class="keywordflow">return</span> functools.partial(make_norm_from_scale, scale_cls, init=init)</div>
<div class="line"><span class="lineno"> 1612</span> </div>
<div class="line"><span class="lineno"> 1613</span>    <span class="keywordflow">if</span> isinstance(scale_cls, functools.partial):</div>
<div class="line"><span class="lineno"> 1614</span>        scale_args = scale_cls.args</div>
<div class="line"><span class="lineno"> 1615</span>        scale_kwargs_items = tuple(scale_cls.keywords.items())</div>
<div class="line"><span class="lineno"> 1616</span>        scale_cls = scale_cls.func</div>
<div class="line"><span class="lineno"> 1617</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1618</span>        scale_args = scale_kwargs_items = ()</div>
<div class="line"><span class="lineno"> 1619</span> </div>
<div class="line"><span class="lineno"> 1620</span>    <span class="keywordflow">if</span> init <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1621</span>        <span class="keyword">def </span>init(vmin=None, vmax=None, clip=False): <span class="keyword">pass</span></div>
<div class="line"><span class="lineno"> 1622</span> </div>
<div class="line"><span class="lineno"> 1623</span>    <span class="keywordflow">return</span> _make_norm_from_scale(</div>
<div class="line"><span class="lineno"> 1624</span>        scale_cls, scale_args, scale_kwargs_items,</div>
<div class="line"><span class="lineno"> 1625</span>        base_norm_cls, inspect.signature(init))</div>
<div class="line"><span class="lineno"> 1626</span> </div>
<div class="line"><span class="lineno"> 1627</span> </div>
<div class="line"><span class="lineno"> 1628</span><span class="preprocessor">@functools.lru_cache(None)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a438ddeafc28f4bd634595cfd3f818653" name="a438ddeafc28f4bd634595cfd3f818653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438ddeafc28f4bd634595cfd3f818653">&#9670;&#160;</a></span>rgb_to_hsv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.rgb_to_hsv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
values.

Parameters
----------
arr : (..., 3) array-like
   All values must be in the range [0, 1]

Returns
-------
(..., 3) ndarray
   Colors converted to hsv values in range [0, 1]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2051</span><span class="keyword">def </span>rgb_to_hsv(arr):</div>
<div class="line"><span class="lineno"> 2052</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2053</span><span class="stringliteral">    Convert float rgb values (in the range [0, 1]), in a numpy array to hsv</span></div>
<div class="line"><span class="lineno"> 2054</span><span class="stringliteral">    values.</span></div>
<div class="line"><span class="lineno"> 2055</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2056</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2057</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2058</span><span class="stringliteral">    arr : (..., 3) array-like</span></div>
<div class="line"><span class="lineno"> 2059</span><span class="stringliteral">       All values must be in the range [0, 1]</span></div>
<div class="line"><span class="lineno"> 2060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2061</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2062</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2063</span><span class="stringliteral">    (..., 3) ndarray</span></div>
<div class="line"><span class="lineno"> 2064</span><span class="stringliteral">       Colors converted to hsv values in range [0, 1]</span></div>
<div class="line"><span class="lineno"> 2065</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2066</span>    arr = np.asarray(arr)</div>
<div class="line"><span class="lineno"> 2067</span> </div>
<div class="line"><span class="lineno"> 2068</span>    <span class="comment"># check length of the last dimension, should be _some_ sort of rgb</span></div>
<div class="line"><span class="lineno"> 2069</span>    <span class="keywordflow">if</span> arr.shape[-1] != 3:</div>
<div class="line"><span class="lineno"> 2070</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Last dimension of input array must be 3; &quot;</span></div>
<div class="line"><span class="lineno"> 2071</span>                         <span class="stringliteral">&quot;shape {} was found.&quot;</span>.format(arr.shape))</div>
<div class="line"><span class="lineno"> 2072</span> </div>
<div class="line"><span class="lineno"> 2073</span>    in_shape = arr.shape</div>
<div class="line"><span class="lineno"> 2074</span>    arr = np.array(</div>
<div class="line"><span class="lineno"> 2075</span>        arr, copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 2076</span>        dtype=np.promote_types(arr.dtype, np.float32),  <span class="comment"># Don&#39;t work on ints.</span></div>
<div class="line"><span class="lineno"> 2077</span>        ndmin=2,  <span class="comment"># In case input was 1D.</span></div>
<div class="line"><span class="lineno"> 2078</span>    )</div>
<div class="line"><span class="lineno"> 2079</span>    out = np.zeros_like(arr)</div>
<div class="line"><span class="lineno"> 2080</span>    arr_max = arr.max(-1)</div>
<div class="line"><span class="lineno"> 2081</span>    ipos = arr_max &gt; 0</div>
<div class="line"><span class="lineno"> 2082</span>    delta = arr.ptp(-1)</div>
<div class="line"><span class="lineno"> 2083</span>    s = np.zeros_like(delta)</div>
<div class="line"><span class="lineno"> 2084</span>    s[ipos] = delta[ipos] / arr_max[ipos]</div>
<div class="line"><span class="lineno"> 2085</span>    ipos = delta &gt; 0</div>
<div class="line"><span class="lineno"> 2086</span>    <span class="comment"># red is max</span></div>
<div class="line"><span class="lineno"> 2087</span>    idx = (arr[..., 0] == arr_max) &amp; ipos</div>
<div class="line"><span class="lineno"> 2088</span>    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]</div>
<div class="line"><span class="lineno"> 2089</span>    <span class="comment"># green is max</span></div>
<div class="line"><span class="lineno"> 2090</span>    idx = (arr[..., 1] == arr_max) &amp; ipos</div>
<div class="line"><span class="lineno"> 2091</span>    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]</div>
<div class="line"><span class="lineno"> 2092</span>    <span class="comment"># blue is max</span></div>
<div class="line"><span class="lineno"> 2093</span>    idx = (arr[..., 2] == arr_max) &amp; ipos</div>
<div class="line"><span class="lineno"> 2094</span>    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]</div>
<div class="line"><span class="lineno"> 2095</span> </div>
<div class="line"><span class="lineno"> 2096</span>    out[..., 0] = (out[..., 0] / 6.0) % 1.0</div>
<div class="line"><span class="lineno"> 2097</span>    out[..., 1] = s</div>
<div class="line"><span class="lineno"> 2098</span>    out[..., 2] = arr_max</div>
<div class="line"><span class="lineno"> 2099</span> </div>
<div class="line"><span class="lineno"> 2100</span>    <span class="keywordflow">return</span> out.reshape(in_shape)</div>
<div class="line"><span class="lineno"> 2101</span> </div>
<div class="line"><span class="lineno"> 2102</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a51b82e4d94831ff520d6c9ea97abfa" name="a9a51b82e4d94831ff520d6c9ea97abfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a51b82e4d94831ff520d6c9ea97abfa">&#9670;&#160;</a></span>same_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.same_color </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the colors *c1* and *c2* are the same.

*c1*, *c2* can be single colors or lists/arrays of colors.
</pre> <div class="fragment"><div class="line"><span class="lineno">  246</span><span class="keyword">def </span>same_color(c1, c2):</div>
<div class="line"><span class="lineno">  247</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    Return whether the colors *c1* and *c2* are the same.</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    *c1*, *c2* can be single colors or lists/arrays of colors.</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  252</span>    c1 = to_rgba_array(c1)</div>
<div class="line"><span class="lineno">  253</span>    c2 = to_rgba_array(c2)</div>
<div class="line"><span class="lineno">  254</span>    n1 = max(c1.shape[0], 1)  <span class="comment"># &#39;none&#39; results in shape (0, 4), but is 1-elem</span></div>
<div class="line"><span class="lineno">  255</span>    n2 = max(c2.shape[0], 1)  <span class="comment"># &#39;none&#39; results in shape (0, 4), but is 1-elem</span></div>
<div class="line"><span class="lineno">  256</span> </div>
<div class="line"><span class="lineno">  257</span>    <span class="keywordflow">if</span> n1 != n2:</div>
<div class="line"><span class="lineno">  258</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Different number of elements passed.&#39;</span>)</div>
<div class="line"><span class="lineno">  259</span>    <span class="comment"># The following shape test is needed to correctly handle comparisons with</span></div>
<div class="line"><span class="lineno">  260</span>    <span class="comment"># &#39;none&#39;, which results in a shape (0, 4) array and thus cannot be tested</span></div>
<div class="line"><span class="lineno">  261</span>    <span class="comment"># via value comparison.</span></div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">return</span> c1.shape == c2.shape <span class="keywordflow">and</span> (c1 == c2).all()</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a35d98b0f57844e85cbc263cdf8aaa55e" name="a35d98b0f57844e85cbc263cdf8aaa55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d98b0f57844e85cbc263cdf8aaa55e">&#9670;&#160;</a></span>to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.to_hex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_alpha</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert *c* to a hex color.

Parameters
----------
c : :doc:`color &lt;/tutorials/colors/colors&gt;` or `numpy.ma.masked`

keep_alpha : bool, default: False
  If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.

Returns
-------
str
  ``#rrggbb`` or ``#rrggbbaa`` hex color string
</pre> <div class="fragment"><div class="line"><span class="lineno">  499</span><span class="keyword">def </span>to_hex(c, keep_alpha=False):</div>
<div class="line"><span class="lineno">  500</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    Convert *c* to a hex color.</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    c : :doc:`color &lt;/tutorials/colors/colors&gt;` or `numpy.ma.masked`</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    keep_alpha : bool, default: False</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">      If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    str</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">      ``#rrggbb`` or ``#rrggbbaa`` hex color string</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  515</span>    c = to_rgba(c)</div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> keep_alpha:</div>
<div class="line"><span class="lineno">  517</span>        c = c[:3]</div>
<div class="line"><span class="lineno">  518</span>    <span class="keywordflow">return</span> <span class="stringliteral">&quot;#&quot;</span> + <span class="stringliteral">&quot;&quot;</span>.join(format(int(round(val * 255)), <span class="stringliteral">&quot;02x&quot;</span>) <span class="keywordflow">for</span> val <span class="keywordflow">in</span> c)</div>
<div class="line"><span class="lineno">  519</span> </div>
<div class="line"><span class="lineno">  520</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e44dff433013eff6271388e066b5fa3" name="a4e44dff433013eff6271388e066b5fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e44dff433013eff6271388e066b5fa3">&#9670;&#160;</a></span>to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.to_rgb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert *c* to an RGB color, silently dropping the alpha channel.</pre> <div class="fragment"><div class="line"><span class="lineno">  494</span><span class="keyword">def </span>to_rgb(c):</div>
<div class="line"><span class="lineno">  495</span>    <span class="stringliteral">&quot;&quot;&quot;Convert *c* to an RGB color, silently dropping the alpha channel.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  496</span>    <span class="keywordflow">return</span> to_rgba(c)[:3]</div>
<div class="line"><span class="lineno">  497</span> </div>
<div class="line"><span class="lineno">  498</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a05bc0cc88399a2d7cc576330f1f396b5" name="a05bc0cc88399a2d7cc576330f1f396b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bc0cc88399a2d7cc576330f1f396b5">&#9670;&#160;</a></span>to_rgba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.to_rgba </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert *c* to an RGBA color.

Parameters
----------
c : Matplotlib color or ``np.ma.masked``

alpha : float, optional
    If *alpha* is given, force the alpha value of the returned RGBA tuple
    to *alpha*.

    If None, the alpha value from *c* is used. If *c* does not have an
    alpha channel, then alpha defaults to 1.

    *alpha* is ignored for the color value ``"none"`` (case-insensitive),
    which always maps to ``(0, 0, 0, 0)``.

Returns
-------
tuple
    Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
    alpha) can assume values between 0 and 1.
</pre> <div class="fragment"><div class="line"><span class="lineno">  265</span><span class="keyword">def </span>to_rgba(c, alpha=None):</div>
<div class="line"><span class="lineno">  266</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    Convert *c* to an RGBA color.</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    c : Matplotlib color or ``np.ma.masked``</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    alpha : float, optional</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        If *alpha* is given, force the alpha value of the returned RGBA tuple</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        to *alpha*.</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        If None, the alpha value from *c* is used. If *c* does not have an</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        alpha channel, then alpha defaults to 1.</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        *alpha* is ignored for the color value ``&quot;none&quot;`` (case-insensitive),</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        which always maps to ``(0, 0, 0, 0)``.</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    tuple</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">        alpha) can assume values between 0 and 1.</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  289</span>    <span class="comment"># Special-case nth color syntax because it should not be cached.</span></div>
<div class="line"><span class="lineno">  290</span>    <span class="keywordflow">if</span> _is_nth_color(c):</div>
<div class="line"><span class="lineno">  291</span>        prop_cycler = mpl.rcParams[<span class="stringliteral">&#39;axes.prop_cycle&#39;</span>]</div>
<div class="line"><span class="lineno">  292</span>        colors = prop_cycler.by_key().get(<span class="stringliteral">&#39;color&#39;</span>, [<span class="stringliteral">&#39;k&#39;</span>])</div>
<div class="line"><span class="lineno">  293</span>        c = colors[int(c[1:]) % len(colors)]</div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  295</span>        rgba = _colors_full_map.cache[c, alpha]</div>
<div class="line"><span class="lineno">  296</span>    <span class="keywordflow">except</span> (KeyError, TypeError):  <span class="comment"># Not in cache, or unhashable.</span></div>
<div class="line"><span class="lineno">  297</span>        rgba = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  298</span>    <span class="keywordflow">if</span> rgba <span class="keywordflow">is</span> <span class="keywordtype">None</span>:  <span class="comment"># Suppress exception chaining of cache lookup failure.</span></div>
<div class="line"><span class="lineno">  299</span>        rgba = _to_rgba_no_colorcycle(c, alpha)</div>
<div class="line"><span class="lineno">  300</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  301</span>            _colors_full_map.cache[c, alpha] = rgba</div>
<div class="line"><span class="lineno">  302</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  303</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  304</span>    <span class="keywordflow">return</span> rgba</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a549adc2b2de96d79a7e8140003617f92" name="a549adc2b2de96d79a7e8140003617f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549adc2b2de96d79a7e8140003617f92">&#9670;&#160;</a></span>to_rgba_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.to_rgba_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert *c* to a (n, 4) array of RGBA colors.

Parameters
----------
c : Matplotlib color or array of colors
    If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
    row for each masked value or row in *c*.

alpha : float or sequence of floats, optional
    If *alpha* is given, force the alpha value of the returned RGBA tuple
    to *alpha*.

    If None, the alpha value from *c* is used. If *c* does not have an
    alpha channel, then alpha defaults to 1.

    *alpha* is ignored for the color value ``"none"`` (case-insensitive),
    which always maps to ``(0, 0, 0, 0)``.

    If *alpha* is a sequence and *c* is a single color, *c* will be
    repeated to match the length of *alpha*.

Returns
-------
array
    (n, 4) array of RGBA colors,  where each channel (red, green, blue,
    alpha) can assume values between 0 and 1.
</pre> <div class="fragment"><div class="line"><span class="lineno">  399</span><span class="keyword">def </span>to_rgba_array(c, alpha=None):</div>
<div class="line"><span class="lineno">  400</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    Convert *c* to a (n, 4) array of RGBA colors.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    c : Matplotlib color or array of colors</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">        If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">        row for each masked value or row in *c*.</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    alpha : float or sequence of floats, optional</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        If *alpha* is given, force the alpha value of the returned RGBA tuple</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        to *alpha*.</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        If None, the alpha value from *c* is used. If *c* does not have an</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">        alpha channel, then alpha defaults to 1.</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        *alpha* is ignored for the color value ``&quot;none&quot;`` (case-insensitive),</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        which always maps to ``(0, 0, 0, 0)``.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        If *alpha* is a sequence and *c* is a single color, *c* will be</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">        repeated to match the length of *alpha*.</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    array</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">        (n, 4) array of RGBA colors,  where each channel (red, green, blue,</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        alpha) can assume values between 0 and 1.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  428</span>    <span class="comment"># Special-case inputs that are already arrays, for performance.  (If the</span></div>
<div class="line"><span class="lineno">  429</span>    <span class="comment"># array has the wrong kind or shape, raise the error during one-at-a-time</span></div>
<div class="line"><span class="lineno">  430</span>    <span class="comment"># conversion.)</span></div>
<div class="line"><span class="lineno">  431</span>    <span class="keywordflow">if</span> np.iterable(alpha):</div>
<div class="line"><span class="lineno">  432</span>        alpha = np.asarray(alpha).ravel()</div>
<div class="line"><span class="lineno">  433</span>    <span class="keywordflow">if</span> (isinstance(c, np.ndarray) <span class="keywordflow">and</span> c.dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&quot;if&quot;</span></div>
<div class="line"><span class="lineno">  434</span>            <span class="keywordflow">and</span> c.ndim == 2 <span class="keywordflow">and</span> c.shape[1] <span class="keywordflow">in</span> [3, 4]):</div>
<div class="line"><span class="lineno">  435</span>        mask = c.mask.any(axis=1) <span class="keywordflow">if</span> np.ma.is_masked(c) <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  436</span>        c = np.ma.getdata(c)</div>
<div class="line"><span class="lineno">  437</span>        <span class="keywordflow">if</span> np.iterable(alpha):</div>
<div class="line"><span class="lineno">  438</span>            <span class="keywordflow">if</span> c.shape[0] == 1 <span class="keywordflow">and</span> alpha.shape[0] &gt; 1:</div>
<div class="line"><span class="lineno">  439</span>                c = np.tile(c, (alpha.shape[0], 1))</div>
<div class="line"><span class="lineno">  440</span>            <span class="keywordflow">elif</span> c.shape[0] != alpha.shape[0]:</div>
<div class="line"><span class="lineno">  441</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The number of colors must match the number&quot;</span></div>
<div class="line"><span class="lineno">  442</span>                                 <span class="stringliteral">&quot; of alpha values if there are more than one&quot;</span></div>
<div class="line"><span class="lineno">  443</span>                                 <span class="stringliteral">&quot; of each.&quot;</span>)</div>
<div class="line"><span class="lineno">  444</span>        <span class="keywordflow">if</span> c.shape[1] == 3:</div>
<div class="line"><span class="lineno">  445</span>            result = np.column_stack([c, np.zeros(len(c))])</div>
<div class="line"><span class="lineno">  446</span>            result[:, -1] = alpha <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> 1.</div>
<div class="line"><span class="lineno">  447</span>        <span class="keywordflow">elif</span> c.shape[1] == 4:</div>
<div class="line"><span class="lineno">  448</span>            result = c.copy()</div>
<div class="line"><span class="lineno">  449</span>            <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  450</span>                result[:, -1] = alpha</div>
<div class="line"><span class="lineno">  451</span>        <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  452</span>            result[mask] = 0</div>
<div class="line"><span class="lineno">  453</span>        <span class="keywordflow">if</span> np.any((result &lt; 0) | (result &gt; 1)):</div>
<div class="line"><span class="lineno">  454</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;RGBA values should be within 0-1 range&quot;</span>)</div>
<div class="line"><span class="lineno">  455</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  456</span>    <span class="comment"># Handle single values.</span></div>
<div class="line"><span class="lineno">  457</span>    <span class="comment"># Note that this occurs *after* handling inputs that are already arrays, as</span></div>
<div class="line"><span class="lineno">  458</span>    <span class="comment"># `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need</span></div>
<div class="line"><span class="lineno">  459</span>    <span class="comment"># to format the array in the ValueError message(!).</span></div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">if</span> cbook._str_lower_equal(c, <span class="stringliteral">&quot;none&quot;</span>):</div>
<div class="line"><span class="lineno">  461</span>        <span class="keywordflow">return</span> np.zeros((0, 4), float)</div>
<div class="line"><span class="lineno">  462</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  463</span>        <span class="keywordflow">if</span> np.iterable(alpha):</div>
<div class="line"><span class="lineno">  464</span>            <span class="keywordflow">return</span> np.array([to_rgba(c, a) <span class="keywordflow">for</span> a <span class="keywordflow">in</span> alpha], float)</div>
<div class="line"><span class="lineno">  465</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  466</span>            <span class="keywordflow">return</span> np.array([to_rgba(c, alpha)], float)</div>
<div class="line"><span class="lineno">  467</span>    <span class="keywordflow">except</span> (ValueError, TypeError):</div>
<div class="line"><span class="lineno">  468</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  469</span> </div>
<div class="line"><span class="lineno">  470</span>    <span class="keywordflow">if</span> isinstance(c, str):</div>
<div class="line"><span class="lineno">  471</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;{c!r} is not a valid color value.&quot;</span>)</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordflow">if</span> len(c) == 0:</div>
<div class="line"><span class="lineno">  474</span>        <span class="keywordflow">return</span> np.zeros((0, 4), float)</div>
<div class="line"><span class="lineno">  475</span> </div>
<div class="line"><span class="lineno">  476</span>    <span class="comment"># Quick path if the whole sequence can be directly converted to a numpy</span></div>
<div class="line"><span class="lineno">  477</span>    <span class="comment"># array in one shot.</span></div>
<div class="line"><span class="lineno">  478</span>    <span class="keywordflow">if</span> isinstance(c, Sequence):</div>
<div class="line"><span class="lineno">  479</span>        lens = {len(cc) <span class="keywordflow">if</span> isinstance(cc, (list, tuple)) <span class="keywordflow">else</span> -1 <span class="keywordflow">for</span> cc <span class="keywordflow">in</span> c}</div>
<div class="line"><span class="lineno">  480</span>        <span class="keywordflow">if</span> lens == {3}:</div>
<div class="line"><span class="lineno">  481</span>            rgba = np.column_stack([c, np.ones(len(c))])</div>
<div class="line"><span class="lineno">  482</span>        <span class="keywordflow">elif</span> lens == {4}:</div>
<div class="line"><span class="lineno">  483</span>            rgba = np.array(c)</div>
<div class="line"><span class="lineno">  484</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  485</span>            rgba = np.array([to_rgba(cc) <span class="keywordflow">for</span> cc <span class="keywordflow">in</span> c])</div>
<div class="line"><span class="lineno">  486</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  487</span>        rgba = np.array([to_rgba(cc) <span class="keywordflow">for</span> cc <span class="keywordflow">in</span> c])</div>
<div class="line"><span class="lineno">  488</span> </div>
<div class="line"><span class="lineno">  489</span>    <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  490</span>        rgba[:, 3] = alpha</div>
<div class="line"><span class="lineno">  491</span>    <span class="keywordflow">return</span> rgba</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4307f893813eba322104c8f3bf535ff5" name="a4307f893813eba322104c8f3bf535ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4307f893813eba322104c8f3bf535ff5">&#9670;&#160;</a></span>_color_sequences</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._color_sequences = <a class="el" href="classmatplotlib_1_1colors_1_1_color_sequence_registry.html">ColorSequenceRegistry</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f318eaae7d8d7ab6f091a9bd3df41d2" name="a2f318eaae7d8d7ab6f091a9bd3df41d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f318eaae7d8d7ab6f091a9bd3df41d2">&#9670;&#160;</a></span>_colors_full_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._colors_full_map = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05a8695892fea8ad310449628e8dad7e" name="a05a8695892fea8ad310449628e8dad7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a8695892fea8ad310449628e8dad7e">&#9670;&#160;</a></span>_REPR_PNG_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple matplotlib.colors._REPR_PNG_SIZE = (512, 64)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16b190205df4e5a5765c42bb1dc058f4" name="a16b190205df4e5a5765c42bb1dc058f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b190205df4e5a5765c42bb1dc058f4">&#9670;&#160;</a></span>_scale</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._scale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9db28ee4d900bf6e908bd8e4b19808dd" name="a9db28ee4d900bf6e908bd8e4b19808dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db28ee4d900bf6e908bd8e4b19808dd">&#9670;&#160;</a></span>_trf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors._trf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5786340f4f4fddf7665e5246eaf75d68" name="a5786340f4f4fddf7665e5246eaf75d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5786340f4f4fddf7665e5246eaf75d68">&#9670;&#160;</a></span>cnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.cnames = CSS4_COLORS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backwards-compatible color-conversion API. </p>

</div>
</div>
<a id="ae0f1473cd90343845e171b405e1add8c" name="ae0f1473cd90343845e171b405e1add8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f1473cd90343845e171b405e1add8c">&#9670;&#160;</a></span>colorConverter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.colorConverter = <a class="el" href="classmatplotlib_1_1colors_1_1_color_converter.html">ColorConverter</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a385cb604484fbd935417d0cc8bf38ab5" name="a385cb604484fbd935417d0cc8bf38ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385cb604484fbd935417d0cc8bf38ab5">&#9670;&#160;</a></span>hex2color</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.hex2color = <a class="el" href="namespacematplotlib_1_1colors.html#a4e44dff433013eff6271388e066b5fa3">to_rgb</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af26cd70a131ac31abe1aa77acf04c3d7" name="af26cd70a131ac31abe1aa77acf04c3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26cd70a131ac31abe1aa77acf04c3d7">&#9670;&#160;</a></span>hexColorPattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.hexColorPattern = re.compile(r&quot;\A#[<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>-fA-F0-9]{6}\Z&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f2ef6b5f12a92b335f6dde12ec491f6" name="a5f2ef6b5f12a92b335f6dde12ec491f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2ef6b5f12a92b335f6dde12ec491f6">&#9670;&#160;</a></span>LogNorm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.LogNorm</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  make_norm_from_scale(</div>
<div class="line"><span class="lineno">    2</span>    functools.partial(scale.LogScale, nonpositive=<span class="stringliteral">&quot;mask&quot;</span>))(Normalize)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4654955df88176e133b049797744290" name="ab4654955df88176e133b049797744290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4654955df88176e133b049797744290">&#9670;&#160;</a></span>rgb2hex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.rgb2hex = <a class="el" href="namespacematplotlib_1_1colors.html#a35d98b0f57844e85cbc263cdf8aaa55e">to_hex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64fab219e2255adac7821722f85263bf" name="a64fab219e2255adac7821722f85263bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fab219e2255adac7821722f85263bf">&#9670;&#160;</a></span>vmin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.colors.vmin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
