<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: _pytest.pathlib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace__pytest.html">_pytest</a></li><li class="navelem"><a class="el" href="namespace__pytest_1_1pathlib.html">pathlib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">_pytest.pathlib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html">ImportMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1_import_path_mismatch_error.html">ImportPathMismatchError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae354b4be99744eed758bfa1902d3901a" id="r_ae354b4be99744eed758bfa1902d3901a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae354b4be99744eed758bfa1902d3901a">_ignore_error</a> (exception)</td></tr>
<tr class="separator:ae354b4be99744eed758bfa1902d3901a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc9f2b91e8d7c2f31e80cc596fc1ad" id="r_a71cc9f2b91e8d7c2f31e80cc596fc1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a71cc9f2b91e8d7c2f31e80cc596fc1ad">get_lock_path</a> (<a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> path)</td></tr>
<tr class="separator:a71cc9f2b91e8d7c2f31e80cc596fc1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6aeb1abf46fea839d27c69a67ff8f1" id="r_a4a6aeb1abf46fea839d27c69a67ff8f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a4a6aeb1abf46fea839d27c69a67ff8f1">on_rm_rf_error</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, str path, exc, *Path start_path)</td></tr>
<tr class="separator:a4a6aeb1abf46fea839d27c69a67ff8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8b0325e6efac0c038f9a724ab8a2bf" id="r_a6b8b0325e6efac0c038f9a724ab8a2bf"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a6b8b0325e6efac0c038f9a724ab8a2bf">ensure_extended_length_path</a> (Path path)</td></tr>
<tr class="separator:a6b8b0325e6efac0c038f9a724ab8a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae544da450e5c7c6870a70be7cabc75d8" id="r_ae544da450e5c7c6870a70be7cabc75d8"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae544da450e5c7c6870a70be7cabc75d8">get_extended_length_path_str</a> (str path)</td></tr>
<tr class="separator:ae544da450e5c7c6870a70be7cabc75d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f0c08537ab64dd461cfb6674625b38" id="r_ae1f0c08537ab64dd461cfb6674625b38"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae1f0c08537ab64dd461cfb6674625b38">rm_rf</a> (Path path)</td></tr>
<tr class="separator:ae1f0c08537ab64dd461cfb6674625b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cce29d5bd2a6bafff9633a5f96c84b2" id="r_a9cce29d5bd2a6bafff9633a5f96c84b2"><td class="memItemLeft" align="right" valign="top">Iterator[Path]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a9cce29d5bd2a6bafff9633a5f96c84b2">find_prefixed</a> (Path root, str prefix)</td></tr>
<tr class="separator:a9cce29d5bd2a6bafff9633a5f96c84b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa5325b03acf273d34e67d175823951" id="r_aaaa5325b03acf273d34e67d175823951"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#aaaa5325b03acf273d34e67d175823951">extract_suffixes</a> (Iterable[PurePath] <a class="el" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>, str prefix)</td></tr>
<tr class="separator:aaaa5325b03acf273d34e67d175823951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a66215e40cad20f751eddc3c6e8721" id="r_ae5a66215e40cad20f751eddc3c6e8721"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae5a66215e40cad20f751eddc3c6e8721">find_suffixes</a> (Path root, str prefix)</td></tr>
<tr class="separator:ae5a66215e40cad20f751eddc3c6e8721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace71386b7a61233602483df7897d63f5" id="r_ace71386b7a61233602483df7897d63f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ace71386b7a61233602483df7897d63f5">parse_num</a> (maybe_num)</td></tr>
<tr class="separator:ace71386b7a61233602483df7897d63f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1bb7832a445214b1954967f934e560" id="r_a7a1bb7832a445214b1954967f934e560"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a7a1bb7832a445214b1954967f934e560">_force_symlink</a> (Path root, Union[str, PurePath] target, Union[str, Path] link_to)</td></tr>
<tr class="separator:a7a1bb7832a445214b1954967f934e560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca62f92c9e61a349836eadf38245d85" id="r_a6ca62f92c9e61a349836eadf38245d85"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a6ca62f92c9e61a349836eadf38245d85">make_numbered_dir</a> (Path root, str prefix, int mode=0o700)</td></tr>
<tr class="separator:a6ca62f92c9e61a349836eadf38245d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae1b99c0fbb9d314aceb95e668a401" id="r_a2fae1b99c0fbb9d314aceb95e668a401"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a2fae1b99c0fbb9d314aceb95e668a401">create_cleanup_lock</a> (Path p)</td></tr>
<tr class="separator:a2fae1b99c0fbb9d314aceb95e668a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3d274fb731694f3f4186a43327da9f" id="r_adf3d274fb731694f3f4186a43327da9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#adf3d274fb731694f3f4186a43327da9f">register_cleanup_lock_removal</a> (Path lock_path, register=atexit.register)</td></tr>
<tr class="separator:adf3d274fb731694f3f4186a43327da9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e58fca02f174fa9bd72475840e51cc" id="r_a13e58fca02f174fa9bd72475840e51cc"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a13e58fca02f174fa9bd72475840e51cc">maybe_delete_a_numbered_dir</a> (Path path)</td></tr>
<tr class="separator:a13e58fca02f174fa9bd72475840e51cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3f573b2bcd340dc200f85899715bfa" id="r_a1c3f573b2bcd340dc200f85899715bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a1c3f573b2bcd340dc200f85899715bfa">ensure_deletable</a> (Path path, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a1c3f573b2bcd340dc200f85899715bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a716332cee4b0ffe6806ccfd56c390" id="r_a94a716332cee4b0ffe6806ccfd56c390"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a94a716332cee4b0ffe6806ccfd56c390">try_cleanup</a> (Path path, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a94a716332cee4b0ffe6806ccfd56c390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357103ea4a06ecb2d8bd3b18af4ea53" id="r_ae357103ea4a06ecb2d8bd3b18af4ea53"><td class="memItemLeft" align="right" valign="top">Iterator[Path]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae357103ea4a06ecb2d8bd3b18af4ea53">cleanup_candidates</a> (Path root, str prefix, int keep)</td></tr>
<tr class="separator:ae357103ea4a06ecb2d8bd3b18af4ea53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1e52490b7f908dbc8b6041d0bba697" id="r_a9d1e52490b7f908dbc8b6041d0bba697"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a9d1e52490b7f908dbc8b6041d0bba697">cleanup_numbered_dir</a> (Path root, str prefix, int keep, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a9d1e52490b7f908dbc8b6041d0bba697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cda2f173f0946adac7122c00608b88" id="r_a31cda2f173f0946adac7122c00608b88"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a31cda2f173f0946adac7122c00608b88">make_numbered_dir_with_cleanup</a> (Path root, str prefix, int keep, float lock_timeout, int mode)</td></tr>
<tr class="separator:a31cda2f173f0946adac7122c00608b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d692771185c792d8b0f888953061d9" id="r_a16d692771185c792d8b0f888953061d9"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a16d692771185c792d8b0f888953061d9">resolve_from_str</a> (str input, Path rootpath)</td></tr>
<tr class="separator:a16d692771185c792d8b0f888953061d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090cdf038044f269b614ee956d872844" id="r_a090cdf038044f269b614ee956d872844"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a090cdf038044f269b614ee956d872844">fnmatch_ex</a> (str pattern, Union[str, &quot;os.PathLike[str]&quot;] path)</td></tr>
<tr class="separator:a090cdf038044f269b614ee956d872844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906f883a8f364371f6913290ea9e4f55" id="r_a906f883a8f364371f6913290ea9e4f55"><td class="memItemLeft" align="right" valign="top">Set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a906f883a8f364371f6913290ea9e4f55">parts</a> (str s)</td></tr>
<tr class="separator:a906f883a8f364371f6913290ea9e4f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b0dbb5e8dce581a88184ad1aab772" id="r_a324b0dbb5e8dce581a88184ad1aab772"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a324b0dbb5e8dce581a88184ad1aab772">symlink_or_skip</a> (src, dst, **kwargs)</td></tr>
<tr class="separator:a324b0dbb5e8dce581a88184ad1aab772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b02dba07652b67ceaa844c6ad687d19" id="r_a9b02dba07652b67ceaa844c6ad687d19"><td class="memItemLeft" align="right" valign="top">ModuleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a9b02dba07652b67ceaa844c6ad687d19">import_path</a> (Union[str, &quot;os.PathLike[str]&quot;] p, *Union[str, <a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html">ImportMode</a>] mode=<a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html#a3c8859503e2fee8e08c242b769efe1b8">ImportMode.prepend</a>, Path root)</td></tr>
<tr class="separator:a9b02dba07652b67ceaa844c6ad687d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b07abdf23e0fb0d65477da791e92ab" id="r_a40b07abdf23e0fb0d65477da791e92ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a40b07abdf23e0fb0d65477da791e92ab">_is_same</a> (str f1, str f2)</td></tr>
<tr class="separator:a40b07abdf23e0fb0d65477da791e92ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627c18aa62422d2db2f1ad51382f5afd" id="r_a627c18aa62422d2db2f1ad51382f5afd"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a627c18aa62422d2db2f1ad51382f5afd">module_name_from_path</a> (Path path, Path root)</td></tr>
<tr class="separator:a627c18aa62422d2db2f1ad51382f5afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae274d7b0edbcf0336cda727491451aa2" id="r_ae274d7b0edbcf0336cda727491451aa2"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae274d7b0edbcf0336cda727491451aa2">insert_missing_modules</a> (Dict[str, ModuleType] modules, str module_name)</td></tr>
<tr class="separator:ae274d7b0edbcf0336cda727491451aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21fb628746de128e1965bd0f7349c89" id="r_ac21fb628746de128e1965bd0f7349c89"><td class="memItemLeft" align="right" valign="top">Optional[Path]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ac21fb628746de128e1965bd0f7349c89">resolve_package_path</a> (Path path)</td></tr>
<tr class="separator:ac21fb628746de128e1965bd0f7349c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63cdb5d34010355b6aa847f704cf1e7" id="r_af63cdb5d34010355b6aa847f704cf1e7"><td class="memItemLeft" align="right" valign="top">Iterator[&quot;os.DirEntry[str]&quot;]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#af63cdb5d34010355b6aa847f704cf1e7">visit</a> (Union[str, &quot;os.PathLike[str]&quot;] path, Callable[[&quot;os.DirEntry[str]&quot;], bool] recurse)</td></tr>
<tr class="separator:af63cdb5d34010355b6aa847f704cf1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad217b0c9ce3cd8068c865e7ac1cfc737" id="r_ad217b0c9ce3cd8068c865e7ac1cfc737"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ad217b0c9ce3cd8068c865e7ac1cfc737">absolutepath</a> (Union[Path, str] path)</td></tr>
<tr class="separator:ad217b0c9ce3cd8068c865e7ac1cfc737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26da1b9dc787b459a3f792467b060972" id="r_a26da1b9dc787b459a3f792467b060972"><td class="memItemLeft" align="right" valign="top">Optional[Path]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a26da1b9dc787b459a3f792467b060972">commonpath</a> (Path path1, Path path2)</td></tr>
<tr class="separator:a26da1b9dc787b459a3f792467b060972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551b7399b00c9a5673964d7a3e299f2f" id="r_a551b7399b00c9a5673964d7a3e299f2f"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a551b7399b00c9a5673964d7a3e299f2f">bestrelpath</a> (Path directory, Path dest)</td></tr>
<tr class="separator:a551b7399b00c9a5673964d7a3e299f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bea223624856b3db5ff5e69ed325357" id="r_a4bea223624856b3db5ff5e69ed325357"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a4bea223624856b3db5ff5e69ed325357">copytree</a> (Path source, Path target)</td></tr>
<tr class="separator:a4bea223624856b3db5ff5e69ed325357"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6c097e7a2732274f1e66f46e679d3fe2" id="r_a6c097e7a2732274f1e66f46e679d3fe2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a6c097e7a2732274f1e66f46e679d3fe2">LOCK_TIMEOUT</a> = 60 * 60 * 24 * 3</td></tr>
<tr class="separator:a6c097e7a2732274f1e66f46e679d3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa54319ebbb1846a29cd4ad31da4d4" id="r_a0eaa54319ebbb1846a29cd4ad31da4d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> = TypeVar(&quot;_AnyPurePath&quot;, bound=PurePath)</td></tr>
<tr class="separator:a0eaa54319ebbb1846a29cd4ad31da4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4098dd7db7f37942e4d1e4898051a34d" id="r_a4098dd7db7f37942e4d1e4898051a34d"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a4098dd7db7f37942e4d1e4898051a34d">_IGNORED_ERRORS</a> = (ENOENT, ENOTDIR, EBADF, ELOOP)</td></tr>
<tr class="separator:a4098dd7db7f37942e4d1e4898051a34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dcc98dfd4f9e8e52ff548aaf17b6e8" id="r_a82dcc98dfd4f9e8e52ff548aaf17b6e8"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a82dcc98dfd4f9e8e52ff548aaf17b6e8">_IGNORED_WINERRORS</a></td></tr>
<tr class="separator:a82dcc98dfd4f9e8e52ff548aaf17b6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7a1bb7832a445214b1954967f934e560" name="a7a1bb7832a445214b1954967f934e560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1bb7832a445214b1954967f934e560">&#9670;&#160;</a></span>_force_symlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib._force_symlink </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, PurePath]&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, Path]
&#160;</td>
          <td class="paramname"><em>link_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper to create the current symlink.

It's full of race conditions that are reasonably OK to ignore
for the context of best effort linking to the latest test run.

The presumption being that in case of much parallelism
the inaccuracy is going to be acceptable.
</pre> <div class="fragment"><div class="line"><span class="lineno">  189</span>) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  190</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to create the current symlink.</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    It&#39;s full of race conditions that are reasonably OK to ignore</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    for the context of best effort linking to the latest test run.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    The presumption being that in case of much parallelism</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    the inaccuracy is going to be acceptable.</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  198</span>    current_symlink = root.joinpath(target)</div>
<div class="line"><span class="lineno">  199</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  200</span>        current_symlink.unlink()</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">except</span> OSError:</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  204</span>        current_symlink.symlink_to(link_to)</div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  207</span> </div>
<div class="line"><span class="lineno">  208</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae354b4be99744eed758bfa1902d3901a" name="ae354b4be99744eed758bfa1902d3901a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae354b4be99744eed758bfa1902d3901a">&#9670;&#160;</a></span>_ignore_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.pathlib._ignore_error </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exception</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   55</span><span class="keyword">def </span>_ignore_error(exception):</div>
<div class="line"><span class="lineno">   56</span>    <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">   57</span>        getattr(exception, <span class="stringliteral">&quot;errno&quot;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">in</span> _IGNORED_ERRORS</div>
<div class="line"><span class="lineno">   58</span>        <span class="keywordflow">or</span> getattr(exception, <span class="stringliteral">&quot;winerror&quot;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">in</span> _IGNORED_WINERRORS</div>
<div class="line"><span class="lineno">   59</span>    )</div>
<div class="line"><span class="lineno">   60</span> </div>
<div class="line"><span class="lineno">   61</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40b07abdf23e0fb0d65477da791e92ab" name="a40b07abdf23e0fb0d65477da791e92ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b07abdf23e0fb0d65477da791e92ab">&#9670;&#160;</a></span>_is_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool _pytest.pathlib._is_same </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  565</span>    <span class="keyword">def </span>_is_same(f1: str, f2: str) -&gt; bool:</div>
<div class="line"><span class="lineno">  566</span>        <span class="keywordflow">return</span> Path(f1) == Path(f2) <span class="keywordflow">or</span> os.path.samefile(f1, f2)</div>
<div class="line"><span class="lineno">  567</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad217b0c9ce3cd8068c865e7ac1cfc737" name="ad217b0c9ce3cd8068c865e7ac1cfc737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad217b0c9ce3cd8068c865e7ac1cfc737">&#9670;&#160;</a></span>absolutepath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.absolutepath </td>
          <td>(</td>
          <td class="paramtype">Union[Path, str]&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a path to an absolute path using os.path.abspath.

Prefer this over Path.resolve() (see #6523).
Prefer this over Path.absolute() (not public, doesn't normalize).
</pre> <div class="fragment"><div class="line"><span class="lineno">  670</span><span class="keyword">def </span>absolutepath(path: Union[Path, str]) -&gt; Path:</div>
<div class="line"><span class="lineno">  671</span>    <span class="stringliteral">&quot;&quot;&quot;Convert a path to an absolute path using os.path.abspath.</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    Prefer this over Path.resolve() (see #6523).</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    Prefer this over Path.absolute() (not public, doesn&#39;t normalize).</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  676</span>    <span class="keywordflow">return</span> Path(os.path.abspath(str(path)))</div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a551b7399b00c9a5673964d7a3e299f2f" name="a551b7399b00c9a5673964d7a3e299f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551b7399b00c9a5673964d7a3e299f2f">&#9670;&#160;</a></span>bestrelpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.bestrelpath </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a string which is a relative path from directory to dest such
that directory/bestrelpath == dest.

The paths must be either both absolute or both relative.

If no such path can be determined, returns dest.
</pre> <div class="fragment"><div class="line"><span class="lineno">  691</span><span class="keyword">def </span>bestrelpath(directory: Path, dest: Path) -&gt; str:</div>
<div class="line"><span class="lineno">  692</span>    <span class="stringliteral">&quot;&quot;&quot;Return a string which is a relative path from directory to dest such</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    that directory/bestrelpath == dest.</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    The paths must be either both absolute or both relative.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    If no such path can be determined, returns dest.</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  699</span>    <span class="keyword">assert</span> isinstance(directory, Path)</div>
<div class="line"><span class="lineno">  700</span>    <span class="keyword">assert</span> isinstance(dest, Path)</div>
<div class="line"><span class="lineno">  701</span>    <span class="keywordflow">if</span> dest == directory:</div>
<div class="line"><span class="lineno">  702</span>        <span class="keywordflow">return</span> os.curdir</div>
<div class="line"><span class="lineno">  703</span>    <span class="comment"># Find the longest common directory.</span></div>
<div class="line"><span class="lineno">  704</span>    base = commonpath(directory, dest)</div>
<div class="line"><span class="lineno">  705</span>    <span class="comment"># Can be the case on Windows for two absolute paths on different drives.</span></div>
<div class="line"><span class="lineno">  706</span>    <span class="comment"># Can be the case for two relative paths without common prefix.</span></div>
<div class="line"><span class="lineno">  707</span>    <span class="comment"># Can be the case for a relative path and an absolute path.</span></div>
<div class="line"><span class="lineno">  708</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> base:</div>
<div class="line"><span class="lineno">  709</span>        <span class="keywordflow">return</span> str(dest)</div>
<div class="line"><span class="lineno">  710</span>    reldirectory = directory.relative_to(base)</div>
<div class="line"><span class="lineno">  711</span>    reldest = dest.relative_to(base)</div>
<div class="line"><span class="lineno">  712</span>    <span class="keywordflow">return</span> os.path.join(</div>
<div class="line"><span class="lineno">  713</span>        <span class="comment"># Back from directory to base.</span></div>
<div class="line"><span class="lineno">  714</span>        *([os.pardir] * len(reldirectory.parts)),</div>
<div class="line"><span class="lineno">  715</span>        <span class="comment"># Forward from base to dest.</span></div>
<div class="line"><span class="lineno">  716</span>        *reldest.parts,</div>
<div class="line"><span class="lineno">  717</span>    )</div>
<div class="line"><span class="lineno">  718</span> </div>
<div class="line"><span class="lineno">  719</span> </div>
<div class="line"><span class="lineno">  720</span><span class="comment"># Originates from py. path.local.copy(), with siginficant trims and adjustments.</span></div>
<div class="line"><span class="lineno">  721</span><span class="comment"># TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae357103ea4a06ecb2d8bd3b18af4ea53" name="ae357103ea4a06ecb2d8bd3b18af4ea53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae357103ea4a06ecb2d8bd3b18af4ea53">&#9670;&#160;</a></span>cleanup_candidates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Path] _pytest.pathlib.cleanup_candidates </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">List candidates for numbered directories to be removed - follows py.path.</pre> <div class="fragment"><div class="line"><span class="lineno">  326</span><span class="keyword">def </span>cleanup_candidates(root: Path, prefix: str, keep: int) -&gt; Iterator[Path]:</div>
<div class="line"><span class="lineno">  327</span>    <span class="stringliteral">&quot;&quot;&quot;List candidates for numbered directories to be removed - follows py.path.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  328</span>    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)</div>
<div class="line"><span class="lineno">  329</span>    max_delete = max_existing - keep</div>
<div class="line"><span class="lineno">  330</span>    paths = find_prefixed(root, prefix)</div>
<div class="line"><span class="lineno">  331</span>    paths, paths2 = itertools.tee(paths)</div>
<div class="line"><span class="lineno">  332</span>    numbers = map(parse_num, extract_suffixes(paths2, prefix))</div>
<div class="line"><span class="lineno">  333</span>    <span class="keywordflow">for</span> path, number <span class="keywordflow">in</span> zip(paths, numbers):</div>
<div class="line"><span class="lineno">  334</span>        <span class="keywordflow">if</span> number &lt;= max_delete:</div>
<div class="line"><span class="lineno">  335</span>            <span class="keywordflow">yield</span> path</div>
<div class="line"><span class="lineno">  336</span> </div>
<div class="line"><span class="lineno">  337</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d1e52490b7f908dbc8b6041d0bba697" name="a9d1e52490b7f908dbc8b6041d0bba697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1e52490b7f908dbc8b6041d0bba697">&#9670;&#160;</a></span>cleanup_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.cleanup_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float
&#160;</td>
          <td class="paramname"><em>consider_lock_dead_if_created_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cleanup for lock driven numbered directories.</pre> <div class="fragment"><div class="line"><span class="lineno">  340</span>) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  341</span>    <span class="stringliteral">&quot;&quot;&quot;Cleanup for lock driven numbered directories.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  342</span>    <span class="keywordflow">for</span> path <span class="keywordflow">in</span> cleanup_candidates(root, prefix, keep):</div>
<div class="line"><span class="lineno">  343</span>        try_cleanup(path, consider_lock_dead_if_created_before)</div>
<div class="line"><span class="lineno">  344</span>    <span class="keywordflow">for</span> path <span class="keywordflow">in</span> root.glob(<span class="stringliteral">&quot;garbage-*&quot;</span>):</div>
<div class="line"><span class="lineno">  345</span>        try_cleanup(path, consider_lock_dead_if_created_before)</div>
<div class="line"><span class="lineno">  346</span> </div>
<div class="line"><span class="lineno">  347</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a26da1b9dc787b459a3f792467b060972" name="a26da1b9dc787b459a3f792467b060972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26da1b9dc787b459a3f792467b060972">&#9670;&#160;</a></span>commonpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[Path] _pytest.pathlib.commonpath </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the common part shared with the other path, or None if there is
no common part.

If one path is relative and one is absolute, returns None.
</pre> <div class="fragment"><div class="line"><span class="lineno">  679</span><span class="keyword">def </span>commonpath(path1: Path, path2: Path) -&gt; Optional[Path]:</div>
<div class="line"><span class="lineno">  680</span>    <span class="stringliteral">&quot;&quot;&quot;Return the common part shared with the other path, or None if there is</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    no common part.</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    If one path is relative and one is absolute, returns None.</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  685</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  686</span>        <span class="keywordflow">return</span> Path(os.path.commonpath((str(path1), str(path2))))</div>
<div class="line"><span class="lineno">  687</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  688</span>        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4bea223624856b3db5ff5e69ed325357" name="a4bea223624856b3db5ff5e69ed325357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bea223624856b3db5ff5e69ed325357">&#9670;&#160;</a></span>copytree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.copytree </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recursively copy a source directory to target.</pre> <div class="fragment"><div class="line"><span class="lineno">  722</span><span class="keyword">def </span>copytree(source: Path, target: Path) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  723</span>    <span class="stringliteral">&quot;&quot;&quot;Recursively copy a source directory to target.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  724</span>    <span class="keyword">assert</span> source.is_dir()</div>
<div class="line"><span class="lineno">  725</span>    <span class="keywordflow">for</span> entry <span class="keywordflow">in</span> visit(source, recurse=<span class="keyword">lambda</span> entry: <span class="keywordflow">not</span> entry.is_symlink()):</div>
<div class="line"><span class="lineno">  726</span>        x = Path(entry)</div>
<div class="line"><span class="lineno">  727</span>        relpath = x.relative_to(source)</div>
<div class="line"><span class="lineno">  728</span>        newx = target / relpath</div>
<div class="line"><span class="lineno">  729</span>        newx.parent.mkdir(exist_ok=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  730</span>        <span class="keywordflow">if</span> x.is_symlink():</div>
<div class="line"><span class="lineno">  731</span>            newx.symlink_to(os.readlink(x))</div>
<div class="line"><span class="lineno">  732</span>        <span class="keywordflow">elif</span> x.is_file():</div>
<div class="line"><span class="lineno">  733</span>            shutil.copyfile(x, newx)</div>
<div class="line"><span class="lineno">  734</span>        <span class="keywordflow">elif</span> x.is_dir():</div>
<div class="line"><span class="lineno">  735</span>            newx.mkdir(exist_ok=<span class="keyword">True</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fae1b99c0fbb9d314aceb95e668a401" name="a2fae1b99c0fbb9d314aceb95e668a401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fae1b99c0fbb9d314aceb95e668a401">&#9670;&#160;</a></span>create_cleanup_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.create_cleanup_lock </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a lock to prevent premature folder cleanup.</pre> <div class="fragment"><div class="line"><span class="lineno">  230</span><span class="keyword">def </span>create_cleanup_lock(p: Path) -&gt; Path:</div>
<div class="line"><span class="lineno">  231</span>    <span class="stringliteral">&quot;&quot;&quot;Create a lock to prevent premature folder cleanup.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  232</span>    lock_path = get_lock_path(p)</div>
<div class="line"><span class="lineno">  233</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  234</span>        fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)</div>
<div class="line"><span class="lineno">  235</span>    <span class="keywordflow">except</span> FileExistsError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  236</span>        <span class="keywordflow">raise</span> OSError(f<span class="stringliteral">&quot;cannot create lockfile in {p}&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  237</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  238</span>        pid = os.getpid()</div>
<div class="line"><span class="lineno">  239</span>        spid = str(pid).encode()</div>
<div class="line"><span class="lineno">  240</span>        os.write(fd, spid)</div>
<div class="line"><span class="lineno">  241</span>        os.close(fd)</div>
<div class="line"><span class="lineno">  242</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> lock_path.is_file():</div>
<div class="line"><span class="lineno">  243</span>            <span class="keywordflow">raise</span> OSError(<span class="stringliteral">&quot;lock path got renamed after successful creation&quot;</span>)</div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">return</span> lock_path</div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c3f573b2bcd340dc200f85899715bfa" name="a1c3f573b2bcd340dc200f85899715bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3f573b2bcd340dc200f85899715bfa">&#9670;&#160;</a></span>ensure_deletable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.ensure_deletable </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>consider_lock_dead_if_created_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if `path` is deletable based on whether the lock file is expired.</pre> <div class="fragment"><div class="line"><span class="lineno">  292</span><span class="keyword">def </span>ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -&gt; bool:</div>
<div class="line"><span class="lineno">  293</span>    <span class="stringliteral">&quot;&quot;&quot;Check if `path` is deletable based on whether the lock file is expired.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">if</span> path.is_symlink():</div>
<div class="line"><span class="lineno">  295</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  296</span>    lock = get_lock_path(path)</div>
<div class="line"><span class="lineno">  297</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  298</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> lock.is_file():</div>
<div class="line"><span class="lineno">  299</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">except</span> OSError:</div>
<div class="line"><span class="lineno">  301</span>        <span class="comment"># we might not have access to the lock file at all, in this case assume</span></div>
<div class="line"><span class="lineno">  302</span>        <span class="comment"># we don&#39;t have access to the entire directory (#7491).</span></div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  304</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  305</span>        lock_time = lock.stat().st_mtime</div>
<div class="line"><span class="lineno">  306</span>    <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  307</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  308</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  309</span>        <span class="keywordflow">if</span> lock_time &lt; consider_lock_dead_if_created_before:</div>
<div class="line"><span class="lineno">  310</span>            <span class="comment"># We want to ignore any errors while trying to remove the lock such as:</span></div>
<div class="line"><span class="lineno">  311</span>            <span class="comment"># - PermissionDenied, like the file permissions have changed since the lock creation;</span></div>
<div class="line"><span class="lineno">  312</span>            <span class="comment"># - FileNotFoundError, in case another pytest process got here first;</span></div>
<div class="line"><span class="lineno">  313</span>            <span class="comment"># and any other cause of failure.</span></div>
<div class="line"><span class="lineno">  314</span>            <span class="keyword">with</span> contextlib.suppress(OSError):</div>
<div class="line"><span class="lineno">  315</span>                lock.unlink()</div>
<div class="line"><span class="lineno">  316</span>                <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  317</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  318</span> </div>
<div class="line"><span class="lineno">  319</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b8b0325e6efac0c038f9a724ab8a2bf" name="a6b8b0325e6efac0c038f9a724ab8a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8b0325e6efac0c038f9a724ab8a2bf">&#9670;&#160;</a></span>ensure_extended_length_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.ensure_extended_length_path </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the extended-length version of a path (Windows).

On Windows, by default, the maximum length of a path (MAX_PATH) is 260
characters, and operations on paths longer than that fail. But it is possible
to overcome this by converting the path to "extended-length" form before
performing the operation:
https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation

On Windows, this function returns the extended-length absolute version of path.
On other platforms it returns path unchanged.
</pre> <div class="fragment"><div class="line"><span class="lineno">  117</span><span class="keyword">def </span>ensure_extended_length_path(path: Path) -&gt; Path:</div>
<div class="line"><span class="lineno">  118</span>    <span class="stringliteral">&quot;&quot;&quot;Get the extended-length version of a path (Windows).</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    On Windows, by default, the maximum length of a path (MAX_PATH) is 260</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    characters, and operations on paths longer than that fail. But it is possible</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    to overcome this by converting the path to &quot;extended-length&quot; form before</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    performing the operation:</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    On Windows, this function returns the extended-length absolute version of path.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    On other platforms it returns path unchanged.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  129</span>    <span class="keywordflow">if</span> sys.platform.startswith(<span class="stringliteral">&quot;win32&quot;</span>):</div>
<div class="line"><span class="lineno">  130</span>        path = path.resolve()</div>
<div class="line"><span class="lineno">  131</span>        path = Path(get_extended_length_path_str(str(path)))</div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">return</span> path</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaaa5325b03acf273d34e67d175823951" name="aaaa5325b03acf273d34e67d175823951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa5325b03acf273d34e67d175823951">&#9670;&#160;</a></span>extract_suffixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] _pytest.pathlib.extract_suffixes </td>
          <td>(</td>
          <td class="paramtype">Iterable[PurePath]&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the parts of the paths following the prefix.

:param iter: Iterator over path names.
:param prefix: Expected prefix of the path names.
</pre> <div class="fragment"><div class="line"><span class="lineno">  163</span><span class="keyword">def </span>extract_suffixes(iter: Iterable[PurePath], prefix: str) -&gt; Iterator[str]:</div>
<div class="line"><span class="lineno">  164</span>    <span class="stringliteral">&quot;&quot;&quot;Return the parts of the paths following the prefix.</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    :param iter: Iterator over path names.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    :param prefix: Expected prefix of the path names.</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  169</span>    p_len = len(prefix)</div>
<div class="line"><span class="lineno">  170</span>    <span class="keywordflow">for</span> p <span class="keywordflow">in</span> iter:</div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordflow">yield</span> p.name[p_len:]</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9cce29d5bd2a6bafff9633a5f96c84b2" name="a9cce29d5bd2a6bafff9633a5f96c84b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cce29d5bd2a6bafff9633a5f96c84b2">&#9670;&#160;</a></span>find_prefixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Path] _pytest.pathlib.find_prefixed </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all elements in root that begin with the prefix, case insensitive.</pre> <div class="fragment"><div class="line"><span class="lineno">  155</span><span class="keyword">def </span>find_prefixed(root: Path, prefix: str) -&gt; Iterator[Path]:</div>
<div class="line"><span class="lineno">  156</span>    <span class="stringliteral">&quot;&quot;&quot;Find all elements in root that begin with the prefix, case insensitive.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  157</span>    l_prefix = prefix.lower()</div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">for</span> x <span class="keywordflow">in</span> root.iterdir():</div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">if</span> x.name.lower().startswith(l_prefix):</div>
<div class="line"><span class="lineno">  160</span>            <span class="keywordflow">yield</span> x</div>
<div class="line"><span class="lineno">  161</span> </div>
<div class="line"><span class="lineno">  162</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5a66215e40cad20f751eddc3c6e8721" name="ae5a66215e40cad20f751eddc3c6e8721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a66215e40cad20f751eddc3c6e8721">&#9670;&#160;</a></span>find_suffixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] _pytest.pathlib.find_suffixes </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Combine find_prefixes and extract_suffixes.</pre> <div class="fragment"><div class="line"><span class="lineno">  174</span><span class="keyword">def </span>find_suffixes(root: Path, prefix: str) -&gt; Iterator[str]:</div>
<div class="line"><span class="lineno">  175</span>    <span class="stringliteral">&quot;&quot;&quot;Combine find_prefixes and extract_suffixes.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordflow">return</span> extract_suffixes(find_prefixed(root, prefix), prefix)</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a090cdf038044f269b614ee956d872844" name="a090cdf038044f269b614ee956d872844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090cdf038044f269b614ee956d872844">&#9670;&#160;</a></span>fnmatch_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.fnmatch_ex </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, &quot;os.PathLike[str]&quot;]&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A port of FNMatcher from py.path.common which works with PurePath() instances.

The difference between this algorithm and PurePath.match() is that the
latter matches "**" glob expressions for each part of the path, while
this algorithm uses the whole path instead.

For example:
    "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
    with this algorithm, but not with PurePath.match().

This algorithm was ported to keep backward-compatibility with existing
settings which assume paths match according this logic.

References:
* https://bugs.python.org/issue29249
* https://bugs.python.org/issue34731
</pre> <div class="fragment"><div class="line"><span class="lineno">  388</span><span class="keyword">def </span>fnmatch_ex(pattern: str, path: Union[str, <span class="stringliteral">&quot;os.PathLike[str]&quot;</span>]) -&gt; bool:</div>
<div class="line"><span class="lineno">  389</span>    <span class="stringliteral">&quot;&quot;&quot;A port of FNMatcher from py.path.common which works with PurePath() instances.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    The difference between this algorithm and PurePath.match() is that the</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    latter matches &quot;**&quot; glob expressions for each part of the path, while</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    this algorithm uses the whole path instead.</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    For example:</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">        &quot;tests/foo/bar/doc/test_foo.py&quot; matches pattern &quot;tests/**/doc/test*.py&quot;</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">        with this algorithm, but not with PurePath.match().</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    This algorithm was ported to keep backward-compatibility with existing</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    settings which assume paths match according this logic.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    References:</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    * https://bugs.python.org/issue29249</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    * https://bugs.python.org/issue34731</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  406</span>    path = PurePath(path)</div>
<div class="line"><span class="lineno">  407</span>    iswin32 = sys.platform.startswith(<span class="stringliteral">&quot;win&quot;</span>)</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">if</span> iswin32 <span class="keywordflow">and</span> sep <span class="keywordflow">not</span> <span class="keywordflow">in</span> pattern <span class="keywordflow">and</span> posix_sep <span class="keywordflow">in</span> pattern:</div>
<div class="line"><span class="lineno">  410</span>        <span class="comment"># Running on Windows, the pattern has no Windows path separators,</span></div>
<div class="line"><span class="lineno">  411</span>        <span class="comment"># and the pattern has one or more Posix path separators. Replace</span></div>
<div class="line"><span class="lineno">  412</span>        <span class="comment"># the Posix path separators with the Windows path separator.</span></div>
<div class="line"><span class="lineno">  413</span>        pattern = pattern.replace(posix_sep, sep)</div>
<div class="line"><span class="lineno">  414</span> </div>
<div class="line"><span class="lineno">  415</span>    <span class="keywordflow">if</span> sep <span class="keywordflow">not</span> <span class="keywordflow">in</span> pattern:</div>
<div class="line"><span class="lineno">  416</span>        name = path.name</div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  418</span>        name = str(path)</div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">if</span> path.is_absolute() <span class="keywordflow">and</span> <span class="keywordflow">not</span> os.path.isabs(pattern):</div>
<div class="line"><span class="lineno">  420</span>            pattern = f<span class="stringliteral">&quot;*{os.sep}{pattern}&quot;</span></div>
<div class="line"><span class="lineno">  421</span>    <span class="keywordflow">return</span> fnmatch.fnmatch(name, pattern)</div>
<div class="line"><span class="lineno">  422</span> </div>
<div class="line"><span class="lineno">  423</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae544da450e5c7c6870a70be7cabc75d8" name="ae544da450e5c7c6870a70be7cabc75d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae544da450e5c7c6870a70be7cabc75d8">&#9670;&#160;</a></span>get_extended_length_path_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.get_extended_length_path_str </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a path to a Windows extended length path.</pre> <div class="fragment"><div class="line"><span class="lineno">  135</span><span class="keyword">def </span>get_extended_length_path_str(path: str) -&gt; str:</div>
<div class="line"><span class="lineno">  136</span>    <span class="stringliteral">&quot;&quot;&quot;Convert a path to a Windows extended length path.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  137</span>    long_path_prefix = <span class="stringliteral">&quot;\\\\?\\&quot;</span></div>
<div class="line"><span class="lineno">  138</span>    unc_long_path_prefix = <span class="stringliteral">&quot;\\\\?\\UNC\\&quot;</span></div>
<div class="line"><span class="lineno">  139</span>    <span class="keywordflow">if</span> path.startswith((long_path_prefix, unc_long_path_prefix)):</div>
<div class="line"><span class="lineno">  140</span>        <span class="keywordflow">return</span> path</div>
<div class="line"><span class="lineno">  141</span>    <span class="comment"># UNC</span></div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">if</span> path.startswith(<span class="stringliteral">&quot;\\\\&quot;</span>):</div>
<div class="line"><span class="lineno">  143</span>        <span class="keywordflow">return</span> unc_long_path_prefix + path[2:]</div>
<div class="line"><span class="lineno">  144</span>    <span class="keywordflow">return</span> long_path_prefix + path</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a71cc9f2b91e8d7c2f31e80cc596fc1ad" name="a71cc9f2b91e8d7c2f31e80cc596fc1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cc9f2b91e8d7c2f31e80cc596fc1ad">&#9670;&#160;</a></span>get_lock_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> _pytest.pathlib.get_lock_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a>&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   62</span><span class="keyword">def </span>get_lock_path(path: _AnyPurePath) -&gt; _AnyPurePath:</div>
<div class="line"><span class="lineno">   63</span>    <span class="keywordflow">return</span> path.joinpath(<span class="stringliteral">&quot;.lock&quot;</span>)</div>
<div class="line"><span class="lineno">   64</span> </div>
<div class="line"><span class="lineno">   65</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b02dba07652b67ceaa844c6ad687d19" name="a9b02dba07652b67ceaa844c6ad687d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b02dba07652b67ceaa844c6ad687d19">&#9670;&#160;</a></span>import_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ModuleType _pytest.pathlib.import_path </td>
          <td>(</td>
          <td class="paramtype">Union[str, &quot;os.PathLike[str]&quot;]&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Union[str, <a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html">ImportMode</a>] &#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class__pytest_1_1pathlib_1_1_import_mode.html#a3c8859503e2fee8e08c242b769efe1b8">ImportMode.prepend</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Import and return a module from the given path, which can be a file (a module) or
a directory (a package).

The import mechanism used is controlled by the `mode` parameter:

* `mode == ImportMode.prepend`: the directory containing the module (or package, taking
  `__init__.py` files into account) will be put at the *start* of `sys.path` before
  being imported with `__import__.

* `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
  to the end of `sys.path`, if not already in `sys.path`.

* `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
  to import the module, which avoids having to use `__import__` and muck with `sys.path`
  at all. It effectively allows having same-named test modules in different places.

:param root:
    Used as an anchor when mode == ImportMode.importlib to obtain
    a unique name for the module being imported so it can safely be stored
    into ``sys.modules``.

:raises ImportPathMismatchError:
    If after importing the given `path` and the module `__file__`
    are different. Only raised in `prepend` and `append` modes.
</pre> <div class="fragment"><div class="line"><span class="lineno">  459</span>) -&gt; ModuleType:</div>
<div class="line"><span class="lineno">  460</span>    <span class="stringliteral">&quot;&quot;&quot;Import and return a module from the given path, which can be a file (a module) or</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    a directory (a package).</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    The import mechanism used is controlled by the `mode` parameter:</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    * `mode == ImportMode.prepend`: the directory containing the module (or package, taking</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">      `__init__.py` files into account) will be put at the *start* of `sys.path` before</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">      being imported with `__import__.</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">      to the end of `sys.path`, if not already in `sys.path`.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">      to import the module, which avoids having to use `__import__` and muck with `sys.path`</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">      at all. It effectively allows having same-named test modules in different places.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    :param root:</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        Used as an anchor when mode == ImportMode.importlib to obtain</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        a unique name for the module being imported so it can safely be stored</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        into ``sys.modules``.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    :raises ImportPathMismatchError:</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        If after importing the given `path` and the module `__file__`</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        are different. Only raised in `prepend` and `append` modes.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  485</span>    mode = ImportMode(mode)</div>
<div class="line"><span class="lineno">  486</span> </div>
<div class="line"><span class="lineno">  487</span>    path = Path(p)</div>
<div class="line"><span class="lineno">  488</span> </div>
<div class="line"><span class="lineno">  489</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> path.exists():</div>
<div class="line"><span class="lineno">  490</span>        <span class="keywordflow">raise</span> ImportError(path)</div>
<div class="line"><span class="lineno">  491</span> </div>
<div class="line"><span class="lineno">  492</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">is</span> ImportMode.importlib:</div>
<div class="line"><span class="lineno">  493</span>        module_name = module_name_from_path(path, root)</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>        <span class="keywordflow">for</span> meta_importer <span class="keywordflow">in</span> sys.meta_path:</div>
<div class="line"><span class="lineno">  496</span>            spec = meta_importer.find_spec(module_name, [str(path.parent)])</div>
<div class="line"><span class="lineno">  497</span>            <span class="keywordflow">if</span> spec <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  498</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  499</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  500</span>            spec = importlib.util.spec_from_file_location(module_name, str(path))</div>
<div class="line"><span class="lineno">  501</span> </div>
<div class="line"><span class="lineno">  502</span>        <span class="keywordflow">if</span> spec <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  503</span>            <span class="keywordflow">raise</span> ImportError(f<span class="stringliteral">&quot;Can&#39;t find module {module_name} at location {path}&quot;</span>)</div>
<div class="line"><span class="lineno">  504</span>        mod = importlib.util.module_from_spec(spec)</div>
<div class="line"><span class="lineno">  505</span>        sys.modules[module_name] = mod</div>
<div class="line"><span class="lineno">  506</span>        spec.loader.exec_module(mod)  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno">  507</span>        insert_missing_modules(sys.modules, module_name)</div>
<div class="line"><span class="lineno">  508</span>        <span class="keywordflow">return</span> mod</div>
<div class="line"><span class="lineno">  509</span> </div>
<div class="line"><span class="lineno">  510</span>    pkg_path = resolve_package_path(path)</div>
<div class="line"><span class="lineno">  511</span>    <span class="keywordflow">if</span> pkg_path <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  512</span>        pkg_root = pkg_path.parent</div>
<div class="line"><span class="lineno">  513</span>        names = list(path.with_suffix(<span class="stringliteral">&quot;&quot;</span>).relative_to(pkg_root).parts)</div>
<div class="line"><span class="lineno">  514</span>        <span class="keywordflow">if</span> names[-1] == <span class="stringliteral">&quot;__init__&quot;</span>:</div>
<div class="line"><span class="lineno">  515</span>            names.pop()</div>
<div class="line"><span class="lineno">  516</span>        module_name = <span class="stringliteral">&quot;.&quot;</span>.join(names)</div>
<div class="line"><span class="lineno">  517</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  518</span>        pkg_root = path.parent</div>
<div class="line"><span class="lineno">  519</span>        module_name = path.stem</div>
<div class="line"><span class="lineno">  520</span> </div>
<div class="line"><span class="lineno">  521</span>    <span class="comment"># Change sys.path permanently: restoring it at the end of this function would cause surprising</span></div>
<div class="line"><span class="lineno">  522</span>    <span class="comment"># problems because of delayed imports: for example, a conftest.py file imported by this function</span></div>
<div class="line"><span class="lineno">  523</span>    <span class="comment"># might have local imports, which would fail at runtime if we restored sys.path.</span></div>
<div class="line"><span class="lineno">  524</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">is</span> ImportMode.append:</div>
<div class="line"><span class="lineno">  525</span>        <span class="keywordflow">if</span> str(pkg_root) <span class="keywordflow">not</span> <span class="keywordflow">in</span> sys.path:</div>
<div class="line"><span class="lineno">  526</span>            sys.path.append(str(pkg_root))</div>
<div class="line"><span class="lineno">  527</span>    <span class="keywordflow">elif</span> mode <span class="keywordflow">is</span> ImportMode.prepend:</div>
<div class="line"><span class="lineno">  528</span>        <span class="keywordflow">if</span> str(pkg_root) != sys.path[0]:</div>
<div class="line"><span class="lineno">  529</span>            sys.path.insert(0, str(pkg_root))</div>
<div class="line"><span class="lineno">  530</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  531</span>        assert_never(mode)</div>
<div class="line"><span class="lineno">  532</span> </div>
<div class="line"><span class="lineno">  533</span>    importlib.import_module(module_name)</div>
<div class="line"><span class="lineno">  534</span> </div>
<div class="line"><span class="lineno">  535</span>    mod = sys.modules[module_name]</div>
<div class="line"><span class="lineno">  536</span>    <span class="keywordflow">if</span> path.name == <span class="stringliteral">&quot;__init__.py&quot;</span>:</div>
<div class="line"><span class="lineno">  537</span>        <span class="keywordflow">return</span> mod</div>
<div class="line"><span class="lineno">  538</span> </div>
<div class="line"><span class="lineno">  539</span>    ignore = os.environ.get(<span class="stringliteral">&quot;PY_IGNORE_IMPORTMISMATCH&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  540</span>    <span class="keywordflow">if</span> ignore != <span class="stringliteral">&quot;1&quot;</span>:</div>
<div class="line"><span class="lineno">  541</span>        module_file = mod.__file__</div>
<div class="line"><span class="lineno">  542</span>        <span class="keywordflow">if</span> module_file <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  543</span>            <span class="keywordflow">raise</span> ImportPathMismatchError(module_name, module_file, path)</div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span>        <span class="keywordflow">if</span> module_file.endswith((<span class="stringliteral">&quot;.pyc&quot;</span>, <span class="stringliteral">&quot;.pyo&quot;</span>)):</div>
<div class="line"><span class="lineno">  546</span>            module_file = module_file[:-1]</div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">if</span> module_file.endswith(os.path.sep + <span class="stringliteral">&quot;__init__.py&quot;</span>):</div>
<div class="line"><span class="lineno">  548</span>            module_file = module_file[: -(len(os.path.sep + <span class="stringliteral">&quot;__init__.py&quot;</span>))]</div>
<div class="line"><span class="lineno">  549</span> </div>
<div class="line"><span class="lineno">  550</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  551</span>            is_same = _is_same(str(path), module_file)</div>
<div class="line"><span class="lineno">  552</span>        <span class="keywordflow">except</span> FileNotFoundError:</div>
<div class="line"><span class="lineno">  553</span>            is_same = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_same:</div>
<div class="line"><span class="lineno">  556</span>            <span class="keywordflow">raise</span> ImportPathMismatchError(module_name, module_file, path)</div>
<div class="line"><span class="lineno">  557</span> </div>
<div class="line"><span class="lineno">  558</span>    <span class="keywordflow">return</span> mod</div>
<div class="line"><span class="lineno">  559</span> </div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span><span class="comment"># Implement a special _is_same function on Windows which returns True if the two filenames</span></div>
<div class="line"><span class="lineno">  562</span><span class="comment"># compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae274d7b0edbcf0336cda727491451aa2" name="ae274d7b0edbcf0336cda727491451aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae274d7b0edbcf0336cda727491451aa2">&#9670;&#160;</a></span>insert_missing_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.insert_missing_modules </td>
          <td>(</td>
          <td class="paramtype">Dict[str, ModuleType]&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>module_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Used by ``import_path`` to create intermediate modules when using mode=importlib.

When we want to import a module as "src.tests.test_foo" for example, we need
to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
otherwise "src.tests.test_foo" is not importable by ``__import__``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  595</span><span class="keyword">def </span>insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  596</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    Used by ``import_path`` to create intermediate modules when using mode=importlib.</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    When we want to import a module as &quot;src.tests.test_foo&quot; for example, we need</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    to create empty modules &quot;src&quot; and &quot;src.tests&quot; after inserting &quot;src.tests.test_foo&quot;,</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    otherwise &quot;src.tests.test_foo&quot; is not importable by ``__import__``.</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  603</span>    module_parts = module_name.split(<span class="stringliteral">&quot;.&quot;</span>)</div>
<div class="line"><span class="lineno">  604</span>    <span class="keywordflow">while</span> module_name:</div>
<div class="line"><span class="lineno">  605</span>        <span class="keywordflow">if</span> module_name <span class="keywordflow">not</span> <span class="keywordflow">in</span> modules:</div>
<div class="line"><span class="lineno">  606</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  607</span>                <span class="comment"># If sys.meta_path is empty, calling import_module will issue</span></div>
<div class="line"><span class="lineno">  608</span>                <span class="comment"># a warning and raise ModuleNotFoundError. To avoid the</span></div>
<div class="line"><span class="lineno">  609</span>                <span class="comment"># warning, we check sys.meta_path explicitly and raise the error</span></div>
<div class="line"><span class="lineno">  610</span>                <span class="comment"># ourselves to fall back to creating a dummy module.</span></div>
<div class="line"><span class="lineno">  611</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> sys.meta_path:</div>
<div class="line"><span class="lineno">  612</span>                    <span class="keywordflow">raise</span> ModuleNotFoundError</div>
<div class="line"><span class="lineno">  613</span>                importlib.import_module(module_name)</div>
<div class="line"><span class="lineno">  614</span>            <span class="keywordflow">except</span> ModuleNotFoundError:</div>
<div class="line"><span class="lineno">  615</span>                module = ModuleType(</div>
<div class="line"><span class="lineno">  616</span>                    module_name,</div>
<div class="line"><span class="lineno">  617</span>                    doc=<span class="stringliteral">&quot;Empty module created by pytest&#39;s importmode=importlib.&quot;</span>,</div>
<div class="line"><span class="lineno">  618</span>                )</div>
<div class="line"><span class="lineno">  619</span>                modules[module_name] = module</div>
<div class="line"><span class="lineno">  620</span>        module_parts.pop(-1)</div>
<div class="line"><span class="lineno">  621</span>        module_name = <span class="stringliteral">&quot;.&quot;</span>.join(module_parts)</div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ca62f92c9e61a349836eadf38245d85" name="a6ca62f92c9e61a349836eadf38245d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca62f92c9e61a349836eadf38245d85">&#9670;&#160;</a></span>make_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.make_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>mode</em> = <code>0o700</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a directory with an increased number as suffix for the given prefix.</pre> <div class="fragment"><div class="line"><span class="lineno">  209</span><span class="keyword">def </span>make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -&gt; Path:</div>
<div class="line"><span class="lineno">  210</span>    <span class="stringliteral">&quot;&quot;&quot;Create a directory with an increased number as suffix for the given prefix.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  211</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(10):</div>
<div class="line"><span class="lineno">  212</span>        <span class="comment"># try up to 10 times to create the folder</span></div>
<div class="line"><span class="lineno">  213</span>        max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)</div>
<div class="line"><span class="lineno">  214</span>        new_number = max_existing + 1</div>
<div class="line"><span class="lineno">  215</span>        new_path = root.joinpath(f<span class="stringliteral">&quot;{prefix}{new_number}&quot;</span>)</div>
<div class="line"><span class="lineno">  216</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  217</span>            new_path.mkdir(mode=mode)</div>
<div class="line"><span class="lineno">  218</span>        <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  219</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  220</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  221</span>            _force_symlink(root, prefix + <span class="stringliteral">&quot;current&quot;</span>, new_path)</div>
<div class="line"><span class="lineno">  222</span>            <span class="keywordflow">return</span> new_path</div>
<div class="line"><span class="lineno">  223</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  224</span>        <span class="keywordflow">raise</span> OSError(</div>
<div class="line"><span class="lineno">  225</span>            <span class="stringliteral">&quot;could not create numbered dir with prefix &quot;</span></div>
<div class="line"><span class="lineno">  226</span>            <span class="stringliteral">&quot;{prefix} in {root} after 10 tries&quot;</span>.format(prefix=prefix, root=root)</div>
<div class="line"><span class="lineno">  227</span>        )</div>
<div class="line"><span class="lineno">  228</span> </div>
<div class="line"><span class="lineno">  229</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a31cda2f173f0946adac7122c00608b88" name="a31cda2f173f0946adac7122c00608b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cda2f173f0946adac7122c00608b88">&#9670;&#160;</a></span>make_numbered_dir_with_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.make_numbered_dir_with_cleanup </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lock_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a numbered dir with a cleanup lock and remove old ones.</pre> <div class="fragment"><div class="line"><span class="lineno">  354</span>) -&gt; Path:</div>
<div class="line"><span class="lineno">  355</span>    <span class="stringliteral">&quot;&quot;&quot;Create a numbered dir with a cleanup lock and remove old ones.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  356</span>    e = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(10):</div>
<div class="line"><span class="lineno">  358</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  359</span>            p = make_numbered_dir(root, prefix, mode)</div>
<div class="line"><span class="lineno">  360</span>            lock_path = create_cleanup_lock(p)</div>
<div class="line"><span class="lineno">  361</span>            register_cleanup_lock_removal(lock_path)</div>
<div class="line"><span class="lineno">  362</span>        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> exc:</div>
<div class="line"><span class="lineno">  363</span>            e = exc</div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  365</span>            consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout</div>
<div class="line"><span class="lineno">  366</span>            <span class="comment"># Register a cleanup for program exit</span></div>
<div class="line"><span class="lineno">  367</span>            atexit.register(</div>
<div class="line"><span class="lineno">  368</span>                cleanup_numbered_dir,</div>
<div class="line"><span class="lineno">  369</span>                root,</div>
<div class="line"><span class="lineno">  370</span>                prefix,</div>
<div class="line"><span class="lineno">  371</span>                keep,</div>
<div class="line"><span class="lineno">  372</span>                consider_lock_dead_if_created_before,</div>
<div class="line"><span class="lineno">  373</span>            )</div>
<div class="line"><span class="lineno">  374</span>            <span class="keywordflow">return</span> p</div>
<div class="line"><span class="lineno">  375</span>    <span class="keyword">assert</span> e <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">raise</span> e</div>
<div class="line"><span class="lineno">  377</span> </div>
<div class="line"><span class="lineno">  378</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a13e58fca02f174fa9bd72475840e51cc" name="a13e58fca02f174fa9bd72475840e51cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e58fca02f174fa9bd72475840e51cc">&#9670;&#160;</a></span>maybe_delete_a_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.maybe_delete_a_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove a numbered directory if its lock can be obtained and it does
not seem to be in use.</pre> <div class="fragment"><div class="line"><span class="lineno">  264</span><span class="keyword">def </span>maybe_delete_a_numbered_dir(path: Path) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  265</span>    <span class="stringliteral">&quot;&quot;&quot;Remove a numbered directory if its lock can be obtained and it does</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    not seem to be in use.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  267</span>    path = ensure_extended_length_path(path)</div>
<div class="line"><span class="lineno">  268</span>    lock_path = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  270</span>        lock_path = create_cleanup_lock(path)</div>
<div class="line"><span class="lineno">  271</span>        parent = path.parent</div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  273</span>        garbage = parent.joinpath(f<span class="stringliteral">&quot;garbage-{uuid.uuid4()}&quot;</span>)</div>
<div class="line"><span class="lineno">  274</span>        path.rename(garbage)</div>
<div class="line"><span class="lineno">  275</span>        rm_rf(garbage)</div>
<div class="line"><span class="lineno">  276</span>    <span class="keywordflow">except</span> OSError:</div>
<div class="line"><span class="lineno">  277</span>        <span class="comment">#  known races:</span></div>
<div class="line"><span class="lineno">  278</span>        <span class="comment">#  * other process did a cleanup at the same time</span></div>
<div class="line"><span class="lineno">  279</span>        <span class="comment">#  * deletable folder was found</span></div>
<div class="line"><span class="lineno">  280</span>        <span class="comment">#  * process cwd (Windows)</span></div>
<div class="line"><span class="lineno">  281</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  282</span>    <span class="keywordflow">finally</span>:</div>
<div class="line"><span class="lineno">  283</span>        <span class="comment"># If we created the lock, ensure we remove it even if we failed</span></div>
<div class="line"><span class="lineno">  284</span>        <span class="comment"># to properly remove the numbered dir.</span></div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">if</span> lock_path <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  286</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  287</span>                lock_path.unlink()</div>
<div class="line"><span class="lineno">  288</span>            <span class="keywordflow">except</span> OSError:</div>
<div class="line"><span class="lineno">  289</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a627c18aa62422d2db2f1ad51382f5afd" name="a627c18aa62422d2db2f1ad51382f5afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627c18aa62422d2db2f1ad51382f5afd">&#9670;&#160;</a></span>module_name_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.module_name_from_path </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dotted module name based on the given path, anchored on root.

For example: path="projects/src/tests/test_foo.py" and root="/projects", the
resulting module name will be "src.tests.test_foo".
</pre> <div class="fragment"><div class="line"><span class="lineno">  574</span><span class="keyword">def </span>module_name_from_path(path: Path, root: Path) -&gt; str:</div>
<div class="line"><span class="lineno">  575</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    Return a dotted module name based on the given path, anchored on root.</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    For example: path=&quot;projects/src/tests/test_foo.py&quot; and root=&quot;/projects&quot;, the</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    resulting module name will be &quot;src.tests.test_foo&quot;.</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  581</span>    path = path.with_suffix(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  582</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  583</span>        relative_path = path.relative_to(root)</div>
<div class="line"><span class="lineno">  584</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  585</span>        <span class="comment"># If we can&#39;t get a relative path to root, use the full path, except</span></div>
<div class="line"><span class="lineno">  586</span>        <span class="comment"># for the first part (&quot;d:\\&quot; or &quot;/&quot; depending on the platform, for example).</span></div>
<div class="line"><span class="lineno">  587</span>        path_parts = path.parts[1:]</div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  589</span>        <span class="comment"># Use the parts for the relative path to the root path.</span></div>
<div class="line"><span class="lineno">  590</span>        path_parts = relative_path.parts</div>
<div class="line"><span class="lineno">  591</span> </div>
<div class="line"><span class="lineno">  592</span>    <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>.join(path_parts)</div>
<div class="line"><span class="lineno">  593</span> </div>
<div class="line"><span class="lineno">  594</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a6aeb1abf46fea839d27c69a67ff8f1" name="a4a6aeb1abf46fea839d27c69a67ff8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6aeb1abf46fea839d27c69a67ff8f1">&#9670;&#160;</a></span>on_rm_rf_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.on_rm_rf_error </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Path&#160;</td>
          <td class="paramname"><em>start_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Handle known read-only errors during rmtree.

The returned value is used only by our own tests.
</pre> <div class="fragment"><div class="line"><span class="lineno">   66</span><span class="keyword">def </span>on_rm_rf_error(func, path: str, exc, *, start_path: Path) -&gt; bool:</div>
<div class="line"><span class="lineno">   67</span>    <span class="stringliteral">&quot;&quot;&quot;Handle known read-only errors during rmtree.</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    The returned value is used only by our own tests.</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   71</span>    exctype, excvalue = exc[:2]</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    <span class="comment"># Another process removed the file in the middle of the &quot;rm_rf&quot; (xdist for example).</span></div>
<div class="line"><span class="lineno">   74</span>    <span class="comment"># More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018</span></div>
<div class="line"><span class="lineno">   75</span>    <span class="keywordflow">if</span> isinstance(excvalue, FileNotFoundError):</div>
<div class="line"><span class="lineno">   76</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(excvalue, PermissionError):</div>
<div class="line"><span class="lineno">   79</span>        warnings.warn(</div>
<div class="line"><span class="lineno">   80</span>            PytestWarning(f<span class="stringliteral">&quot;(rm_rf) error removing {path}\n{exctype}: {excvalue}&quot;</span>)</div>
<div class="line"><span class="lineno">   81</span>        )</div>
<div class="line"><span class="lineno">   82</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>    <span class="keywordflow">if</span> func <span class="keywordflow">not</span> <span class="keywordflow">in</span> (os.rmdir, os.remove, os.unlink):</div>
<div class="line"><span class="lineno">   85</span>        <span class="keywordflow">if</span> func <span class="keywordflow">not</span> <span class="keywordflow">in</span> (os.open,):</div>
<div class="line"><span class="lineno">   86</span>            warnings.warn(</div>
<div class="line"><span class="lineno">   87</span>                PytestWarning(</div>
<div class="line"><span class="lineno">   88</span>                    <span class="stringliteral">&quot;(rm_rf) unknown function {} when removing {}:\n{}: {}&quot;</span>.format(</div>
<div class="line"><span class="lineno">   89</span>                        func, path, exctype, excvalue</div>
<div class="line"><span class="lineno">   90</span>                    )</div>
<div class="line"><span class="lineno">   91</span>                )</div>
<div class="line"><span class="lineno">   92</span>            )</div>
<div class="line"><span class="lineno">   93</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span>    <span class="comment"># Chmod + retry.</span></div>
<div class="line"><span class="lineno">   96</span>    <span class="keyword">import</span> stat</div>
<div class="line"><span class="lineno">   97</span> </div>
<div class="line"><span class="lineno">   98</span>    <span class="keyword">def </span>chmod_rw(p: str) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   99</span>        mode = os.stat(p).st_mode</div>
<div class="line"><span class="lineno">  100</span>        os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)</div>
<div class="line"><span class="lineno">  101</span> </div>
<div class="line"><span class="lineno">  102</span>    <span class="comment"># For files, we need to recursively go upwards in the directories to</span></div>
<div class="line"><span class="lineno">  103</span>    <span class="comment"># ensure they all are also writable.</span></div>
<div class="line"><span class="lineno">  104</span>    p = Path(path)</div>
<div class="line"><span class="lineno">  105</span>    <span class="keywordflow">if</span> p.is_file():</div>
<div class="line"><span class="lineno">  106</span>        <span class="keywordflow">for</span> parent <span class="keywordflow">in</span> p.parents:</div>
<div class="line"><span class="lineno">  107</span>            chmod_rw(str(parent))</div>
<div class="line"><span class="lineno">  108</span>            <span class="comment"># Stop when we reach the original path passed to rm_rf.</span></div>
<div class="line"><span class="lineno">  109</span>            <span class="keywordflow">if</span> parent == start_path:</div>
<div class="line"><span class="lineno">  110</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  111</span>    chmod_rw(str(path))</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>    <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(path)</div>
<div class="line"><span class="lineno">  114</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ace71386b7a61233602483df7897d63f5" name="ace71386b7a61233602483df7897d63f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace71386b7a61233602483df7897d63f5">&#9670;&#160;</a></span>parse_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int _pytest.pathlib.parse_num </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maybe_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse number path suffixes, returns -1 on error.</pre> <div class="fragment"><div class="line"><span class="lineno">  179</span><span class="keyword">def </span>parse_num(maybe_num) -&gt; int:</div>
<div class="line"><span class="lineno">  180</span>    <span class="stringliteral">&quot;&quot;&quot;Parse number path suffixes, returns -1 on error.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  181</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  182</span>        <span class="keywordflow">return</span> int(maybe_num)</div>
<div class="line"><span class="lineno">  183</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  184</span>        <span class="keywordflow">return</span> -1</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a906f883a8f364371f6913290ea9e4f55" name="a906f883a8f364371f6913290ea9e4f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906f883a8f364371f6913290ea9e4f55">&#9670;&#160;</a></span>parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[str] _pytest.pathlib.parts </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  424</span><span class="keyword">def </span>parts(s: str) -&gt; Set[str]:</div>
<div class="line"><span class="lineno">  425</span>    parts = s.split(sep)</div>
<div class="line"><span class="lineno">  426</span>    <span class="keywordflow">return</span> {sep.join(parts[: i + 1]) <span class="keywordflow">or</span> sep <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(parts))}</div>
<div class="line"><span class="lineno">  427</span> </div>
<div class="line"><span class="lineno">  428</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adf3d274fb731694f3f4186a43327da9f" name="adf3d274fb731694f3f4186a43327da9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3d274fb731694f3f4186a43327da9f">&#9670;&#160;</a></span>register_cleanup_lock_removal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.pathlib.register_cleanup_lock_removal </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>lock_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>register</em> = <code>atexit.register</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Register a cleanup function for removing a lock, by default on atexit.</pre> <div class="fragment"><div class="line"><span class="lineno">  247</span><span class="keyword">def </span>register_cleanup_lock_removal(lock_path: Path, register=atexit.register):</div>
<div class="line"><span class="lineno">  248</span>    <span class="stringliteral">&quot;&quot;&quot;Register a cleanup function for removing a lock, by default on atexit.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  249</span>    pid = os.getpid()</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>    <span class="keyword">def </span>cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  252</span>        current_pid = os.getpid()</div>
<div class="line"><span class="lineno">  253</span>        <span class="keywordflow">if</span> current_pid != original_pid:</div>
<div class="line"><span class="lineno">  254</span>            <span class="comment"># fork</span></div>
<div class="line"><span class="lineno">  255</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  257</span>            lock_path.unlink()</div>
<div class="line"><span class="lineno">  258</span>        <span class="keywordflow">except</span> OSError:</div>
<div class="line"><span class="lineno">  259</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span>    <span class="keywordflow">return</span> register(cleanup_on_exit)</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a16d692771185c792d8b0f888953061d9" name="a16d692771185c792d8b0f888953061d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d692771185c792d8b0f888953061d9">&#9670;&#160;</a></span>resolve_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.resolve_from_str </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>rootpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  379</span><span class="keyword">def </span>resolve_from_str(input: str, rootpath: Path) -&gt; Path:</div>
<div class="line"><span class="lineno">  380</span>    input = expanduser(input)</div>
<div class="line"><span class="lineno">  381</span>    input = expandvars(input)</div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">if</span> isabs(input):</div>
<div class="line"><span class="lineno">  383</span>        <span class="keywordflow">return</span> Path(input)</div>
<div class="line"><span class="lineno">  384</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  385</span>        <span class="keywordflow">return</span> rootpath.joinpath(input)</div>
<div class="line"><span class="lineno">  386</span> </div>
<div class="line"><span class="lineno">  387</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac21fb628746de128e1965bd0f7349c89" name="ac21fb628746de128e1965bd0f7349c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21fb628746de128e1965bd0f7349c89">&#9670;&#160;</a></span>resolve_package_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[Path] _pytest.pathlib.resolve_package_path </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Python package path by looking for the last
directory upwards which still contains an __init__.py.

Returns None if it can not be determined.
</pre> <div class="fragment"><div class="line"><span class="lineno">  624</span><span class="keyword">def </span>resolve_package_path(path: Path) -&gt; Optional[Path]:</div>
<div class="line"><span class="lineno">  625</span>    <span class="stringliteral">&quot;&quot;&quot;Return the Python package path by looking for the last</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    directory upwards which still contains an __init__.py.</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    Returns None if it can not be determined.</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  630</span>    result = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  631</span>    <span class="keywordflow">for</span> parent <span class="keywordflow">in</span> itertools.chain((path,), path.parents):</div>
<div class="line"><span class="lineno">  632</span>        <span class="keywordflow">if</span> parent.is_dir():</div>
<div class="line"><span class="lineno">  633</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> parent.joinpath(<span class="stringliteral">&quot;__init__.py&quot;</span>).is_file():</div>
<div class="line"><span class="lineno">  634</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  635</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> parent.name.isidentifier():</div>
<div class="line"><span class="lineno">  636</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  637</span>            result = parent</div>
<div class="line"><span class="lineno">  638</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  639</span> </div>
<div class="line"><span class="lineno">  640</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae1f0c08537ab64dd461cfb6674625b38" name="ae1f0c08537ab64dd461cfb6674625b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0c08537ab64dd461cfb6674625b38">&#9670;&#160;</a></span>rm_rf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.rm_rf </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove the path contents recursively, even if some elements
are read-only.</pre> <div class="fragment"><div class="line"><span class="lineno">  147</span><span class="keyword">def </span>rm_rf(path: Path) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  148</span>    <span class="stringliteral">&quot;&quot;&quot;Remove the path contents recursively, even if some elements</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    are read-only.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  150</span>    path = ensure_extended_length_path(path)</div>
<div class="line"><span class="lineno">  151</span>    onerror = partial(on_rm_rf_error, start_path=path)</div>
<div class="line"><span class="lineno">  152</span>    shutil.rmtree(str(path), onerror=onerror)</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a324b0dbb5e8dce581a88184ad1aab772" name="a324b0dbb5e8dce581a88184ad1aab772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324b0dbb5e8dce581a88184ad1aab772">&#9670;&#160;</a></span>symlink_or_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.pathlib.symlink_or_skip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a symlink, or skip the test in case symlinks are not supported.</pre> <div class="fragment"><div class="line"><span class="lineno">  429</span><span class="keyword">def </span>symlink_or_skip(src, dst, **kwargs):</div>
<div class="line"><span class="lineno">  430</span>    <span class="stringliteral">&quot;&quot;&quot;Make a symlink, or skip the test in case symlinks are not supported.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  431</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  432</span>        os.symlink(str(src), str(dst), **kwargs)</div>
<div class="line"><span class="lineno">  433</span>    <span class="keywordflow">except</span> OSError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  434</span>        skip(f<span class="stringliteral">&quot;symlinks not supported: {e}&quot;</span>)</div>
<div class="line"><span class="lineno">  435</span> </div>
<div class="line"><span class="lineno">  436</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a94a716332cee4b0ffe6806ccfd56c390" name="a94a716332cee4b0ffe6806ccfd56c390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a716332cee4b0ffe6806ccfd56c390">&#9670;&#160;</a></span>try_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.try_cleanup </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>consider_lock_dead_if_created_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to cleanup a folder if we can ensure it's deletable.</pre> <div class="fragment"><div class="line"><span class="lineno">  320</span><span class="keyword">def </span>try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  321</span>    <span class="stringliteral">&quot;&quot;&quot;Try to cleanup a folder if we can ensure it&#39;s deletable.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  322</span>    <span class="keywordflow">if</span> ensure_deletable(path, consider_lock_dead_if_created_before):</div>
<div class="line"><span class="lineno">  323</span>        maybe_delete_a_numbered_dir(path)</div>
<div class="line"><span class="lineno">  324</span> </div>
<div class="line"><span class="lineno">  325</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af63cdb5d34010355b6aa847f704cf1e7" name="af63cdb5d34010355b6aa847f704cf1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63cdb5d34010355b6aa847f704cf1e7">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[&quot;os.DirEntry[str]&quot;] _pytest.pathlib.visit </td>
          <td>(</td>
          <td class="paramtype">Union[str, &quot;os.PathLike[str]&quot;]&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[&quot;os.DirEntry[str]&quot;], bool]
&#160;</td>
          <td class="paramname"><em>recurse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Walk a directory recursively, in breadth-first order.

Entries at each directory level are sorted.
</pre> <div class="fragment"><div class="line"><span class="lineno">  643</span>) -&gt; Iterator[<span class="stringliteral">&quot;os.DirEntry[str]&quot;</span>]:</div>
<div class="line"><span class="lineno">  644</span>    <span class="stringliteral">&quot;&quot;&quot;Walk a directory recursively, in breadth-first order.</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    Entries at each directory level are sorted.</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  648</span> </div>
<div class="line"><span class="lineno">  649</span>    <span class="comment"># Skip entries with symlink loops and other brokenness, so the caller doesn&#39;t</span></div>
<div class="line"><span class="lineno">  650</span>    <span class="comment"># have to deal with it.</span></div>
<div class="line"><span class="lineno">  651</span>    entries = []</div>
<div class="line"><span class="lineno">  652</span>    <span class="keywordflow">for</span> entry <span class="keywordflow">in</span> os.scandir(path):</div>
<div class="line"><span class="lineno">  653</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  654</span>            entry.is_file()</div>
<div class="line"><span class="lineno">  655</span>        <span class="keywordflow">except</span> OSError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  656</span>            <span class="keywordflow">if</span> _ignore_error(err):</div>
<div class="line"><span class="lineno">  657</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  658</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  659</span>        entries.append(entry)</div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span>    entries.sort(key=<span class="keyword">lambda</span> entry: entry.name)</div>
<div class="line"><span class="lineno">  662</span> </div>
<div class="line"><span class="lineno">  663</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> entries</div>
<div class="line"><span class="lineno">  664</span> </div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">for</span> entry <span class="keywordflow">in</span> entries:</div>
<div class="line"><span class="lineno">  666</span>        <span class="keywordflow">if</span> entry.is_dir() <span class="keywordflow">and</span> recurse(entry):</div>
<div class="line"><span class="lineno">  667</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> visit(entry.path, recurse)</div>
<div class="line"><span class="lineno">  668</span> </div>
<div class="line"><span class="lineno">  669</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0eaa54319ebbb1846a29cd4ad31da4d4" name="a0eaa54319ebbb1846a29cd4ad31da4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaa54319ebbb1846a29cd4ad31da4d4">&#9670;&#160;</a></span>_AnyPurePath</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.pathlib._AnyPurePath = TypeVar(&quot;_AnyPurePath&quot;, bound=PurePath)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4098dd7db7f37942e4d1e4898051a34d" name="a4098dd7db7f37942e4d1e4898051a34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4098dd7db7f37942e4d1e4898051a34d">&#9670;&#160;</a></span>_IGNORED_ERRORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple _pytest.pathlib._IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82dcc98dfd4f9e8e52ff548aaf17b6e8" name="a82dcc98dfd4f9e8e52ff548aaf17b6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dcc98dfd4f9e8e52ff548aaf17b6e8">&#9670;&#160;</a></span>_IGNORED_WINERRORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple _pytest.pathlib._IGNORED_WINERRORS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  (</div>
<div class="line"><span class="lineno">    2</span>    21,  <span class="comment"># ERROR_NOT_READY - drive exists but is not accessible</span></div>
<div class="line"><span class="lineno">    3</span>    1921,  <span class="comment"># ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself</span></div>
<div class="line"><span class="lineno">    4</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c097e7a2732274f1e66f46e679d3fe2" name="a6c097e7a2732274f1e66f46e679d3fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c097e7a2732274f1e66f46e679d3fe2">&#9670;&#160;</a></span>LOCK_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _pytest.pathlib.LOCK_TIMEOUT = 60 * 60 * 24 * 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
