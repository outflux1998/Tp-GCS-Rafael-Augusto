<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.cluster._affinity_propagation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster_1_1__affinity__propagation.html">_affinity_propagation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.cluster._affinity_propagation Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__affinity__propagation_1_1_affinity_propagation.html">AffinityPropagation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac54a1c5beec5c04255d6436aefc9a8d1" id="r_ac54a1c5beec5c04255d6436aefc9a8d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__affinity__propagation.html#ac54a1c5beec5c04255d6436aefc9a8d1">_equal_similarities_and_preferences</a> (S, preference)</td></tr>
<tr class="separator:ac54a1c5beec5c04255d6436aefc9a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c75c715317f4398b5a5752d7804c60" id="r_a61c75c715317f4398b5a5752d7804c60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__affinity__propagation.html#a61c75c715317f4398b5a5752d7804c60">_affinity_propagation</a> (S, *preference, convergence_iter, max_iter, damping, verbose, return_n_iter, random_state)</td></tr>
<tr class="separator:a61c75c715317f4398b5a5752d7804c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328f309992ce4433b9e0c6bd061704b6" id="r_a328f309992ce4433b9e0c6bd061704b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__affinity__propagation.html#a328f309992ce4433b9e0c6bd061704b6">affinity_propagation</a> (S, *preference=None, convergence_iter=15, max_iter=200, damping=0.5, copy=True, verbose=False, return_n_iter=False, random_state=None)</td></tr>
<tr class="memdesc:a328f309992ce4433b9e0c6bd061704b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public API.  <br /></td></tr>
<tr class="separator:a328f309992ce4433b9e0c6bd061704b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Affinity Propagation clustering algorithm.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a61c75c715317f4398b5a5752d7804c60" name="a61c75c715317f4398b5a5752d7804c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c75c715317f4398b5a5752d7804c60">&#9670;&#160;</a></span>_affinity_propagation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._affinity_propagation._affinity_propagation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>preference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convergence_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>damping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_n_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Main affinity propagation algorithm.</pre> <div class="fragment"><div class="line"><span class="lineno">   47</span>):</div>
<div class="line"><span class="lineno">   48</span>    <span class="stringliteral">&quot;&quot;&quot;Main affinity propagation algorithm.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   49</span>    n_samples = S.shape[0]</div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">if</span> n_samples == 1 <span class="keywordflow">or</span> _equal_similarities_and_preferences(S, preference):</div>
<div class="line"><span class="lineno">   51</span>        <span class="comment"># It makes no sense to run the algorithm in this case, so return 1 or</span></div>
<div class="line"><span class="lineno">   52</span>        <span class="comment"># n_samples clusters, depending on preferences</span></div>
<div class="line"><span class="lineno">   53</span>        warnings.warn(</div>
<div class="line"><span class="lineno">   54</span>            <span class="stringliteral">&quot;All samples have mutually equal similarities. &quot;</span></div>
<div class="line"><span class="lineno">   55</span>            <span class="stringliteral">&quot;Returning arbitrary cluster center(s).&quot;</span></div>
<div class="line"><span class="lineno">   56</span>        )</div>
<div class="line"><span class="lineno">   57</span>        <span class="keywordflow">if</span> preference.flat[0] &gt;= S.flat[n_samples - 1]:</div>
<div class="line"><span class="lineno">   58</span>            <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">   59</span>                (np.arange(n_samples), np.arange(n_samples), 0)</div>
<div class="line"><span class="lineno">   60</span>                <span class="keywordflow">if</span> return_n_iter</div>
<div class="line"><span class="lineno">   61</span>                <span class="keywordflow">else</span> (np.arange(n_samples), np.arange(n_samples))</div>
<div class="line"><span class="lineno">   62</span>            )</div>
<div class="line"><span class="lineno">   63</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   64</span>            <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">   65</span>                (np.array([0]), np.array([0] * n_samples), 0)</div>
<div class="line"><span class="lineno">   66</span>                <span class="keywordflow">if</span> return_n_iter</div>
<div class="line"><span class="lineno">   67</span>                <span class="keywordflow">else</span> (np.array([0]), np.array([0] * n_samples))</div>
<div class="line"><span class="lineno">   68</span>            )</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span>    <span class="comment"># Place preference on the diagonal of S</span></div>
<div class="line"><span class="lineno">   71</span>    S.flat[:: (n_samples + 1)] = preference</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    A = np.zeros((n_samples, n_samples))</div>
<div class="line"><span class="lineno">   74</span>    R = np.zeros((n_samples, n_samples))  <span class="comment"># Initialize messages</span></div>
<div class="line"><span class="lineno">   75</span>    <span class="comment"># Intermediate results</span></div>
<div class="line"><span class="lineno">   76</span>    tmp = np.zeros((n_samples, n_samples))</div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span>    <span class="comment"># Remove degeneracies</span></div>
<div class="line"><span class="lineno">   79</span>    S += (</div>
<div class="line"><span class="lineno">   80</span>        np.finfo(S.dtype).eps * S + np.finfo(S.dtype).tiny * 100</div>
<div class="line"><span class="lineno">   81</span>    ) * random_state.standard_normal(size=(n_samples, n_samples))</div>
<div class="line"><span class="lineno">   82</span> </div>
<div class="line"><span class="lineno">   83</span>    <span class="comment"># Execute parallel affinity propagation updates</span></div>
<div class="line"><span class="lineno">   84</span>    e = np.zeros((n_samples, convergence_iter))</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>    ind = np.arange(n_samples)</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordflow">for</span> it <span class="keywordflow">in</span> range(max_iter):</div>
<div class="line"><span class="lineno">   89</span>        <span class="comment"># tmp = A + S; compute responsibilities</span></div>
<div class="line"><span class="lineno">   90</span>        np.add(A, S, tmp)</div>
<div class="line"><span class="lineno">   91</span>        I = np.argmax(tmp, axis=1)</div>
<div class="line"><span class="lineno">   92</span>        Y = tmp[ind, I]  <span class="comment"># np.max(A + S, axis=1)</span></div>
<div class="line"><span class="lineno">   93</span>        tmp[ind, I] = -np.inf</div>
<div class="line"><span class="lineno">   94</span>        Y2 = np.max(tmp, axis=1)</div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="line"><span class="lineno">   96</span>        <span class="comment"># tmp = Rnew</span></div>
<div class="line"><span class="lineno">   97</span>        np.subtract(S, Y[:, <span class="keywordtype">None</span>], tmp)</div>
<div class="line"><span class="lineno">   98</span>        tmp[ind, I] = S[ind, I] - Y2</div>
<div class="line"><span class="lineno">   99</span> </div>
<div class="line"><span class="lineno">  100</span>        <span class="comment"># Damping</span></div>
<div class="line"><span class="lineno">  101</span>        tmp *= 1 - damping</div>
<div class="line"><span class="lineno">  102</span>        R *= damping</div>
<div class="line"><span class="lineno">  103</span>        R += tmp</div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span>        <span class="comment"># tmp = Rp; compute availabilities</span></div>
<div class="line"><span class="lineno">  106</span>        np.maximum(R, 0, tmp)</div>
<div class="line"><span class="lineno">  107</span>        tmp.flat[:: n_samples + 1] = R.flat[:: n_samples + 1]</div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>        <span class="comment"># tmp = -Anew</span></div>
<div class="line"><span class="lineno">  110</span>        tmp -= np.sum(tmp, axis=0)</div>
<div class="line"><span class="lineno">  111</span>        dA = np.diag(tmp).copy()</div>
<div class="line"><span class="lineno">  112</span>        tmp.clip(0, np.inf, tmp)</div>
<div class="line"><span class="lineno">  113</span>        tmp.flat[:: n_samples + 1] = dA</div>
<div class="line"><span class="lineno">  114</span> </div>
<div class="line"><span class="lineno">  115</span>        <span class="comment"># Damping</span></div>
<div class="line"><span class="lineno">  116</span>        tmp *= 1 - damping</div>
<div class="line"><span class="lineno">  117</span>        A *= damping</div>
<div class="line"><span class="lineno">  118</span>        A -= tmp</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span>        <span class="comment"># Check for convergence</span></div>
<div class="line"><span class="lineno">  121</span>        E = (np.diag(A) + np.diag(R)) &gt; 0</div>
<div class="line"><span class="lineno">  122</span>        e[:, it % convergence_iter] = E</div>
<div class="line"><span class="lineno">  123</span>        K = np.sum(E, axis=0)</div>
<div class="line"><span class="lineno">  124</span> </div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">if</span> it &gt;= convergence_iter:</div>
<div class="line"><span class="lineno">  126</span>            se = np.sum(e, axis=1)</div>
<div class="line"><span class="lineno">  127</span>            unconverged = np.sum((se == convergence_iter) + (se == 0)) != n_samples</div>
<div class="line"><span class="lineno">  128</span>            <span class="keywordflow">if</span> (<span class="keywordflow">not</span> unconverged <span class="keywordflow">and</span> (K &gt; 0)) <span class="keywordflow">or</span> (it == max_iter):</div>
<div class="line"><span class="lineno">  129</span>                never_converged = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  130</span>                <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  131</span>                    print(<span class="stringliteral">&quot;Converged after %d iterations.&quot;</span> % it)</div>
<div class="line"><span class="lineno">  132</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  134</span>        never_converged = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  135</span>        <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  136</span>            print(<span class="stringliteral">&quot;Did not converge&quot;</span>)</div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span>    I = np.flatnonzero(E)</div>
<div class="line"><span class="lineno">  139</span>    K = I.size  <span class="comment"># Identify exemplars</span></div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">if</span> K &gt; 0:</div>
<div class="line"><span class="lineno">  142</span>        <span class="keywordflow">if</span> never_converged:</div>
<div class="line"><span class="lineno">  143</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  144</span>                <span class="stringliteral">&quot;Affinity propagation did not converge, this model &quot;</span></div>
<div class="line"><span class="lineno">  145</span>                <span class="stringliteral">&quot;may return degenerate cluster centers and labels.&quot;</span>,</div>
<div class="line"><span class="lineno">  146</span>                ConvergenceWarning,</div>
<div class="line"><span class="lineno">  147</span>            )</div>
<div class="line"><span class="lineno">  148</span>        c = np.argmax(S[:, I], axis=1)</div>
<div class="line"><span class="lineno">  149</span>        c[I] = np.arange(K)  <span class="comment"># Identify clusters</span></div>
<div class="line"><span class="lineno">  150</span>        <span class="comment"># Refine the final set of exemplars and clusters and return results</span></div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(K):</div>
<div class="line"><span class="lineno">  152</span>            ii = np.where(c == k)[0]</div>
<div class="line"><span class="lineno">  153</span>            j = np.argmax(np.sum(S[ii[:, np.newaxis], ii], axis=0))</div>
<div class="line"><span class="lineno">  154</span>            I[k] = ii[j]</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>        c = np.argmax(S[:, I], axis=1)</div>
<div class="line"><span class="lineno">  157</span>        c[I] = np.arange(K)</div>
<div class="line"><span class="lineno">  158</span>        labels = I[c]</div>
<div class="line"><span class="lineno">  159</span>        <span class="comment"># Reduce labels to a sorted, gapless, list</span></div>
<div class="line"><span class="lineno">  160</span>        cluster_centers_indices = np.unique(labels)</div>
<div class="line"><span class="lineno">  161</span>        labels = np.searchsorted(cluster_centers_indices, labels)</div>
<div class="line"><span class="lineno">  162</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  163</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  164</span>            <span class="stringliteral">&quot;Affinity propagation did not converge and this model &quot;</span></div>
<div class="line"><span class="lineno">  165</span>            <span class="stringliteral">&quot;will not have any cluster centers.&quot;</span>,</div>
<div class="line"><span class="lineno">  166</span>            ConvergenceWarning,</div>
<div class="line"><span class="lineno">  167</span>        )</div>
<div class="line"><span class="lineno">  168</span>        labels = np.array([-1] * n_samples)</div>
<div class="line"><span class="lineno">  169</span>        cluster_centers_indices = []</div>
<div class="line"><span class="lineno">  170</span> </div>
<div class="line"><span class="lineno">  171</span>    <span class="keywordflow">if</span> return_n_iter:</div>
<div class="line"><span class="lineno">  172</span>        <span class="keywordflow">return</span> cluster_centers_indices, labels, it + 1</div>
<div class="line"><span class="lineno">  173</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  174</span>        <span class="keywordflow">return</span> cluster_centers_indices, labels</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac54a1c5beec5c04255d6436aefc9a8d1" name="ac54a1c5beec5c04255d6436aefc9a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54a1c5beec5c04255d6436aefc9a8d1">&#9670;&#160;</a></span>_equal_similarities_and_preferences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._affinity_propagation._equal_similarities_and_preferences </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>preference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   23</span><span class="keyword">def </span>_equal_similarities_and_preferences(S, preference):</div>
<div class="line"><span class="lineno">   24</span>    <span class="keyword">def </span>all_equal_preferences():</div>
<div class="line"><span class="lineno">   25</span>        <span class="keywordflow">return</span> np.all(preference == preference.flat[0])</div>
<div class="line"><span class="lineno">   26</span> </div>
<div class="line"><span class="lineno">   27</span>    <span class="keyword">def </span>all_equal_similarities():</div>
<div class="line"><span class="lineno">   28</span>        <span class="comment"># Create mask to ignore diagonal of S</span></div>
<div class="line"><span class="lineno">   29</span>        mask = np.ones(S.shape, dtype=bool)</div>
<div class="line"><span class="lineno">   30</span>        np.fill_diagonal(mask, 0)</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span>        <span class="keywordflow">return</span> np.all(S[mask].flat == S[mask].flat[0])</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">return</span> all_equal_preferences() <span class="keywordflow">and</span> all_equal_similarities()</div>
<div class="line"><span class="lineno">   35</span> </div>
<div class="line"><span class="lineno">   36</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a328f309992ce4433b9e0c6bd061704b6" name="a328f309992ce4433b9e0c6bd061704b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328f309992ce4433b9e0c6bd061704b6">&#9670;&#160;</a></span>affinity_propagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._affinity_propagation.affinity_propagation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>preference</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convergence_iter</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>damping</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_n_iter</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public API. </p>
<pre class="fragment">Perform Affinity Propagation Clustering of data.

Read more in the :ref:`User Guide &lt;affinity_propagation&gt;`.

Parameters
----------
S : array-like of shape (n_samples, n_samples)
    Matrix of similarities between points.

preference : array-like of shape (n_samples,) or float, default=None
    Preferences for each point - points with larger values of
    preferences are more likely to be chosen as exemplars. The number of
    exemplars, i.e. of clusters, is influenced by the input preferences
    value. If the preferences are not passed as arguments, they will be
    set to the median of the input similarities (resulting in a moderate
    number of clusters). For a smaller amount of clusters, this can be set
    to the minimum value of the similarities.

convergence_iter : int, default=15
    Number of iterations with no change in the number
    of estimated clusters that stops the convergence.

max_iter : int, default=200
    Maximum number of iterations.

damping : float, default=0.5
    Damping factor between 0.5 and 1.

copy : bool, default=True
    If copy is False, the affinity matrix is modified inplace by the
    algorithm, for memory efficiency.

verbose : bool, default=False
    The verbosity level.

return_n_iter : bool, default=False
    Whether or not to return the number of iterations.

random_state : int, RandomState instance or None, default=None
    Pseudo-random number generator to control the starting state.
    Use an int for reproducible results across function calls.
    See the :term:`Glossary &lt;random_state&gt;`.

    .. versionadded:: 0.23
        this parameter was previously hardcoded as 0.

Returns
-------
cluster_centers_indices : ndarray of shape (n_clusters,)
    Index of clusters centers.

labels : ndarray of shape (n_samples,)
    Cluster labels for each point.

n_iter : int
    Number of iterations run. Returned only if `return_n_iter` is
    set to True.

Notes
-----
For an example, see :ref:`examples/cluster/plot_affinity_propagation.py
&lt;sphx_glr_auto_examples_cluster_plot_affinity_propagation.py&gt;`.

When the algorithm does not converge, it will still return a arrays of
``cluster_center_indices`` and labels if there are any exemplars/clusters,
however they may be degenerate and should be used with caution.

When all training samples have equal similarities and equal preferences,
the assignment of cluster centers and labels depends on the preference.
If the preference is smaller than the similarities, a single cluster center
and label ``0`` for every sample will be returned. Otherwise, every
training sample becomes its own cluster center and is assigned a unique
label.

References
----------
Brendan J. Frey and Delbert Dueck, "Clustering by Passing Messages
Between Data Points", Science Feb. 2007
</pre> <div class="fragment"><div class="line"><span class="lineno">  192</span>):</div>
<div class="line"><span class="lineno">  193</span>    <span class="stringliteral">&quot;&quot;&quot;Perform Affinity Propagation Clustering of data.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;affinity_propagation&gt;`.</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    S : array-like of shape (n_samples, n_samples)</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        Matrix of similarities between points.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    preference : array-like of shape (n_samples,) or float, default=None</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        Preferences for each point - points with larger values of</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        preferences are more likely to be chosen as exemplars. The number of</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">        exemplars, i.e. of clusters, is influenced by the input preferences</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        value. If the preferences are not passed as arguments, they will be</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        set to the median of the input similarities (resulting in a moderate</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        number of clusters). For a smaller amount of clusters, this can be set</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        to the minimum value of the similarities.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    convergence_iter : int, default=15</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        Number of iterations with no change in the number</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        of estimated clusters that stops the convergence.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    max_iter : int, default=200</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        Maximum number of iterations.</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    damping : float, default=0.5</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        Damping factor between 0.5 and 1.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    copy : bool, default=True</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        If copy is False, the affinity matrix is modified inplace by the</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">        algorithm, for memory efficiency.</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    verbose : bool, default=False</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        The verbosity level.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    return_n_iter : bool, default=False</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        Whether or not to return the number of iterations.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    random_state : int, RandomState instance or None, default=None</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        Pseudo-random number generator to control the starting state.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        Use an int for reproducible results across function calls.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        See the :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        .. versionadded:: 0.23</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">            this parameter was previously hardcoded as 0.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    cluster_centers_indices : ndarray of shape (n_clusters,)</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        Index of clusters centers.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    labels : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        Cluster labels for each point.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    n_iter : int</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        Number of iterations run. Returned only if `return_n_iter` is</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        set to True.</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    For an example, see :ref:`examples/cluster/plot_affinity_propagation.py</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    &lt;sphx_glr_auto_examples_cluster_plot_affinity_propagation.py&gt;`.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    When the algorithm does not converge, it will still return a arrays of</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    ``cluster_center_indices`` and labels if there are any exemplars/clusters,</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    however they may be degenerate and should be used with caution.</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    When all training samples have equal similarities and equal preferences,</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    the assignment of cluster centers and labels depends on the preference.</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    If the preference is smaller than the similarities, a single cluster center</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    and label ``0`` for every sample will be returned. Otherwise, every</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    training sample becomes its own cluster center and is assigned a unique</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    label.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    Brendan J. Frey and Delbert Dueck, &quot;Clustering by Passing Messages</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    Between Data Points&quot;, Science Feb. 2007</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  272</span>    S = as_float_array(S, copy=copy)</div>
<div class="line"><span class="lineno">  273</span> </div>
<div class="line"><span class="lineno">  274</span>    estimator = AffinityPropagation(</div>
<div class="line"><span class="lineno">  275</span>        damping=damping,</div>
<div class="line"><span class="lineno">  276</span>        max_iter=max_iter,</div>
<div class="line"><span class="lineno">  277</span>        convergence_iter=convergence_iter,</div>
<div class="line"><span class="lineno">  278</span>        copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  279</span>        preference=preference,</div>
<div class="line"><span class="lineno">  280</span>        affinity=<span class="stringliteral">&quot;precomputed&quot;</span>,</div>
<div class="line"><span class="lineno">  281</span>        verbose=verbose,</div>
<div class="line"><span class="lineno">  282</span>        random_state=random_state,</div>
<div class="line"><span class="lineno">  283</span>    ).fit(S)</div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">if</span> return_n_iter:</div>
<div class="line"><span class="lineno">  286</span>        <span class="keywordflow">return</span> estimator.cluster_centers_indices_, estimator.labels_, estimator.n_iter_</div>
<div class="line"><span class="lineno">  287</span>    <span class="keywordflow">return</span> estimator.cluster_centers_indices_, estimator.labels_</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
