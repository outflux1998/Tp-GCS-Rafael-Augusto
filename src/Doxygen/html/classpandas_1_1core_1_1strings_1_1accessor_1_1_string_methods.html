<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.strings.accessor.StringMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html">accessor</a></li><li class="navelem"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html">StringMethods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.strings.accessor.StringMethods Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for pandas.core.strings.accessor.StringMethods:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.png" usemap="#pandas.core.strings.accessor.StringMethods_map" alt=""/>
  <map id="pandas.core.strings.accessor.StringMethods_map" name="pandas.core.strings.accessor.StringMethods_map">
<area href="classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin.html" alt="pandas.core.base.NoNewAttributesMixin" shape="rect" coords="0,0,265,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4dfb4ad7629d086d3ec8e18c1b51fac6" id="r_a4dfb4ad7629d086d3ec8e18c1b51fac6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a4dfb4ad7629d086d3ec8e18c1b51fac6">__init__</a> (self, data)</td></tr>
<tr class="separator:a4dfb4ad7629d086d3ec8e18c1b51fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d6acd0a862dc6fc56dd89e3dd9957" id="r_a2f0d6acd0a862dc6fc56dd89e3dd9957"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a2f0d6acd0a862dc6fc56dd89e3dd9957">__getitem__</a> (self, key)</td></tr>
<tr class="separator:a2f0d6acd0a862dc6fc56dd89e3dd9957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8c8c0f904e72923bf4770967a4c096" id="r_a4e8c8c0f904e72923bf4770967a4c096"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a4e8c8c0f904e72923bf4770967a4c096">__iter__</a> (self)</td></tr>
<tr class="separator:a4e8c8c0f904e72923bf4770967a4c096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd67d334b1c4b0b1113ccd5681b23a6" id="r_a3cd67d334b1c4b0b1113ccd5681b23a6"><td class="memItemLeft" align="right" valign="top">str|Series|Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a3cd67d334b1c4b0b1113ccd5681b23a6">cat</a> (self, others=None, sep=None, na_rep=None, <a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a44967ff44c9a6aea41f279d961516137">join</a>=&quot;left&quot;)</td></tr>
<tr class="separator:a3cd67d334b1c4b0b1113ccd5681b23a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ed7de8173c36998665dc3fa93cd7b5" id="r_a67ed7de8173c36998665dc3fa93cd7b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a67ed7de8173c36998665dc3fa93cd7b5">split</a> (self, str|re.Pattern|None pat=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=-1, expand=False, *bool|None regex=None)</td></tr>
<tr class="separator:a67ed7de8173c36998665dc3fa93cd7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e071153fe800e1fee171e92b4f6356c" id="r_a1e071153fe800e1fee171e92b4f6356c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a1e071153fe800e1fee171e92b4f6356c">rsplit</a> (self, pat=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=-1, expand=False)</td></tr>
<tr class="separator:a1e071153fe800e1fee171e92b4f6356c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e33de42a74f320c3212ed19c59f7804" id="r_a5e33de42a74f320c3212ed19c59f7804"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a5e33de42a74f320c3212ed19c59f7804">partition</a> (self, sep=&quot; &quot;, expand=True)</td></tr>
<tr class="separator:a5e33de42a74f320c3212ed19c59f7804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbed76592b3b5971588c202f27807d7" id="r_acbbed76592b3b5971588c202f27807d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#acbbed76592b3b5971588c202f27807d7">rpartition</a> (self, sep=&quot; &quot;, expand=True)</td></tr>
<tr class="separator:acbbed76592b3b5971588c202f27807d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ca88d35cc388416bb5949389dc1dee" id="r_af5ca88d35cc388416bb5949389dc1dee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#af5ca88d35cc388416bb5949389dc1dee">get</a> (self, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>)</td></tr>
<tr class="separator:af5ca88d35cc388416bb5949389dc1dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44967ff44c9a6aea41f279d961516137" id="r_a44967ff44c9a6aea41f279d961516137"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a44967ff44c9a6aea41f279d961516137">join</a> (self, sep)</td></tr>
<tr class="separator:a44967ff44c9a6aea41f279d961516137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381d11aa123d89771d1868eb11601459" id="r_a381d11aa123d89771d1868eb11601459"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a381d11aa123d89771d1868eb11601459">contains</a> (self, pat, case=True, flags=0, <a class="el" href="__lapack__subroutines_8h.html#a7c406db23c88628a1214aeaa87642bbd">na</a>=None, regex=True)</td></tr>
<tr class="separator:a381d11aa123d89771d1868eb11601459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402b6b60c0a4f9ef8cb09573e266d67" id="r_ab402b6b60c0a4f9ef8cb09573e266d67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ab402b6b60c0a4f9ef8cb09573e266d67">match</a> (self, pat, case=True, flags=0, <a class="el" href="__lapack__subroutines_8h.html#a7c406db23c88628a1214aeaa87642bbd">na</a>=None)</td></tr>
<tr class="separator:ab402b6b60c0a4f9ef8cb09573e266d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafeca91b8723b1c8c50393ffb9f7c963" id="r_aafeca91b8723b1c8c50393ffb9f7c963"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#aafeca91b8723b1c8c50393ffb9f7c963">fullmatch</a> (self, pat, case=True, flags=0, <a class="el" href="__lapack__subroutines_8h.html#a7c406db23c88628a1214aeaa87642bbd">na</a>=None)</td></tr>
<tr class="separator:aafeca91b8723b1c8c50393ffb9f7c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75eefac0458e0690175cdccf85cbe0e" id="r_ae75eefac0458e0690175cdccf85cbe0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ae75eefac0458e0690175cdccf85cbe0e">replace</a> (self, str|re.Pattern pat, str|Callable repl, int <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=-1, bool|None case=None, int flags=0, bool|None regex=None)</td></tr>
<tr class="separator:ae75eefac0458e0690175cdccf85cbe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d53ba5dac9299b8e92a50839ba8e90" id="r_ae6d53ba5dac9299b8e92a50839ba8e90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ae6d53ba5dac9299b8e92a50839ba8e90">repeat</a> (self, repeats)</td></tr>
<tr class="separator:ae6d53ba5dac9299b8e92a50839ba8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5187ed1323820d43fbec71a62fbb70db" id="r_a5187ed1323820d43fbec71a62fbb70db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a5187ed1323820d43fbec71a62fbb70db">pad</a> (self, width, <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>=&quot;left&quot;, fillchar=&quot; &quot;)</td></tr>
<tr class="separator:a5187ed1323820d43fbec71a62fbb70db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97970c1d9152e6854ce31c3a4bdddd0a" id="r_a97970c1d9152e6854ce31c3a4bdddd0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a97970c1d9152e6854ce31c3a4bdddd0a">center</a> (self, width, fillchar=&quot; &quot;)</td></tr>
<tr class="separator:a97970c1d9152e6854ce31c3a4bdddd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d1168e82c73e57e665139e04190534" id="r_a94d1168e82c73e57e665139e04190534"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a94d1168e82c73e57e665139e04190534">ljust</a> (self, width, fillchar=&quot; &quot;)</td></tr>
<tr class="separator:a94d1168e82c73e57e665139e04190534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca11e5fc9d876d122d3f5cfc296970" id="r_a6eca11e5fc9d876d122d3f5cfc296970"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a6eca11e5fc9d876d122d3f5cfc296970">rjust</a> (self, width, fillchar=&quot; &quot;)</td></tr>
<tr class="separator:a6eca11e5fc9d876d122d3f5cfc296970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b2917c3c252e095ed9b6a3ef03a0b4" id="r_a91b2917c3c252e095ed9b6a3ef03a0b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a91b2917c3c252e095ed9b6a3ef03a0b4">zfill</a> (self, width)</td></tr>
<tr class="separator:a91b2917c3c252e095ed9b6a3ef03a0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104396fbf2e11ddfffa77246e5778881" id="r_a104396fbf2e11ddfffa77246e5778881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a104396fbf2e11ddfffa77246e5778881">slice</a> (self, start=None, stop=None, step=None)</td></tr>
<tr class="separator:a104396fbf2e11ddfffa77246e5778881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4e27627d0fdc6b14c971d5eb948f69" id="r_abc4e27627d0fdc6b14c971d5eb948f69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#abc4e27627d0fdc6b14c971d5eb948f69">slice_replace</a> (self, start=None, stop=None, repl=None)</td></tr>
<tr class="separator:abc4e27627d0fdc6b14c971d5eb948f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca9277ef70d4220757ba5375a5950ec" id="r_a8ca9277ef70d4220757ba5375a5950ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a8ca9277ef70d4220757ba5375a5950ec">decode</a> (self, encoding, errors=&quot;strict&quot;)</td></tr>
<tr class="separator:a8ca9277ef70d4220757ba5375a5950ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cce38a4e1543760feb1bc6dbb183438" id="r_a2cce38a4e1543760feb1bc6dbb183438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a2cce38a4e1543760feb1bc6dbb183438">encode</a> (self, encoding, errors=&quot;strict&quot;)</td></tr>
<tr class="separator:a2cce38a4e1543760feb1bc6dbb183438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d65f2a3236f8a1fdd3efa289d52df3d" id="r_a3d65f2a3236f8a1fdd3efa289d52df3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a3d65f2a3236f8a1fdd3efa289d52df3d">strip</a> (self, to_strip=None)</td></tr>
<tr class="separator:a3d65f2a3236f8a1fdd3efa289d52df3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd879dead1434ac4d2414536b70385b" id="r_a9fd879dead1434ac4d2414536b70385b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a9fd879dead1434ac4d2414536b70385b">lstrip</a> (self, to_strip=None)</td></tr>
<tr class="separator:a9fd879dead1434ac4d2414536b70385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758978c745520e1dc0872d4d42fc7688" id="r_a758978c745520e1dc0872d4d42fc7688"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a758978c745520e1dc0872d4d42fc7688">rstrip</a> (self, to_strip=None)</td></tr>
<tr class="separator:a758978c745520e1dc0872d4d42fc7688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1a877bf6a5b971baa75d7759f4d4be" id="r_a5a1a877bf6a5b971baa75d7759f4d4be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a5a1a877bf6a5b971baa75d7759f4d4be">removeprefix</a> (self, prefix)</td></tr>
<tr class="separator:a5a1a877bf6a5b971baa75d7759f4d4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8262bec640317ac13ec7ba9e15617b" id="r_a8e8262bec640317ac13ec7ba9e15617b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a8e8262bec640317ac13ec7ba9e15617b">removesuffix</a> (self, suffix)</td></tr>
<tr class="separator:a8e8262bec640317ac13ec7ba9e15617b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383e4bad85eb68e0f4ec4aa9180dfa49" id="r_a383e4bad85eb68e0f4ec4aa9180dfa49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a383e4bad85eb68e0f4ec4aa9180dfa49">wrap</a> (self, width, **kwargs)</td></tr>
<tr class="separator:a383e4bad85eb68e0f4ec4aa9180dfa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a346122f954f97a34a52e10ae2b00c" id="r_ad9a346122f954f97a34a52e10ae2b00c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ad9a346122f954f97a34a52e10ae2b00c">get_dummies</a> (self, sep=&quot;|&quot;)</td></tr>
<tr class="separator:ad9a346122f954f97a34a52e10ae2b00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b047c5261002afdbe2b59de65df4b1" id="r_a05b047c5261002afdbe2b59de65df4b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a05b047c5261002afdbe2b59de65df4b1">translate</a> (self, table)</td></tr>
<tr class="separator:a05b047c5261002afdbe2b59de65df4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d9bf6c35ab54f24cdc4cfc38170579" id="r_af4d9bf6c35ab54f24cdc4cfc38170579"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#af4d9bf6c35ab54f24cdc4cfc38170579">count</a> (self, pat, flags=0)</td></tr>
<tr class="separator:af4d9bf6c35ab54f24cdc4cfc38170579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83918f37a3c1d62594b66082554d85" id="r_aba83918f37a3c1d62594b66082554d85"><td class="memItemLeft" align="right" valign="top">Series|Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#aba83918f37a3c1d62594b66082554d85">startswith</a> (self, str|tuple[str,...] pat, Scalar|None <a class="el" href="__lapack__subroutines_8h.html#a7c406db23c88628a1214aeaa87642bbd">na</a>=None)</td></tr>
<tr class="separator:aba83918f37a3c1d62594b66082554d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602a20e3b5b1316091b01a924e15eb11" id="r_a602a20e3b5b1316091b01a924e15eb11"><td class="memItemLeft" align="right" valign="top">Series|Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a602a20e3b5b1316091b01a924e15eb11">endswith</a> (self, str|tuple[str,...] pat, Scalar|None <a class="el" href="__lapack__subroutines_8h.html#a7c406db23c88628a1214aeaa87642bbd">na</a>=None)</td></tr>
<tr class="separator:a602a20e3b5b1316091b01a924e15eb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cbcc55abae33524d2434ff076d3bc3" id="r_a55cbcc55abae33524d2434ff076d3bc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a55cbcc55abae33524d2434ff076d3bc3">findall</a> (self, pat, flags=0)</td></tr>
<tr class="separator:a55cbcc55abae33524d2434ff076d3bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b054352c9f15f21370db49fc60ee5fd" id="r_a8b054352c9f15f21370db49fc60ee5fd"><td class="memItemLeft" align="right" valign="top">DataFrame|Series|Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a8b054352c9f15f21370db49fc60ee5fd">extract</a> (self, str pat, int flags=0, bool expand=True)</td></tr>
<tr class="separator:a8b054352c9f15f21370db49fc60ee5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96f48e3cd0cf95d769ace18e6c2319a" id="r_ac96f48e3cd0cf95d769ace18e6c2319a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ac96f48e3cd0cf95d769ace18e6c2319a">extractall</a> (self, pat, flags=0)</td></tr>
<tr class="separator:ac96f48e3cd0cf95d769ace18e6c2319a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa701ec5e10972d7a8bbbd5d3a29b12d7" id="r_aa701ec5e10972d7a8bbbd5d3a29b12d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#aa701ec5e10972d7a8bbbd5d3a29b12d7">find</a> (self, sub, start=0, end=None)</td></tr>
<tr class="separator:aa701ec5e10972d7a8bbbd5d3a29b12d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccb6ee7e4a325f5fb8c7275807ebb43" id="r_a1ccb6ee7e4a325f5fb8c7275807ebb43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a1ccb6ee7e4a325f5fb8c7275807ebb43">rfind</a> (self, sub, start=0, end=None)</td></tr>
<tr class="separator:a1ccb6ee7e4a325f5fb8c7275807ebb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd26fa58d16d1fd987e3a18412deae9" id="r_a6fd26fa58d16d1fd987e3a18412deae9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a6fd26fa58d16d1fd987e3a18412deae9">normalize</a> (self, form)</td></tr>
<tr class="separator:a6fd26fa58d16d1fd987e3a18412deae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c25d97e50cb371ee35829597ce48b12" id="r_a5c25d97e50cb371ee35829597ce48b12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a5c25d97e50cb371ee35829597ce48b12">index</a> (self, sub, start=0, end=None)</td></tr>
<tr class="separator:a5c25d97e50cb371ee35829597ce48b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ab30039a1725b4e6ae61a9cebc08b4" id="r_ac2ab30039a1725b4e6ae61a9cebc08b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ac2ab30039a1725b4e6ae61a9cebc08b4">rindex</a> (self, sub, start=0, end=None)</td></tr>
<tr class="separator:ac2ab30039a1725b4e6ae61a9cebc08b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34be368cab53168ad3a6b9a75247712" id="r_ad34be368cab53168ad3a6b9a75247712"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ad34be368cab53168ad3a6b9a75247712">len</a> (self)</td></tr>
<tr class="separator:ad34be368cab53168ad3a6b9a75247712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570aae76320c8226653aa0c7d0b3c76f" id="r_a570aae76320c8226653aa0c7d0b3c76f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a570aae76320c8226653aa0c7d0b3c76f">lower</a> (self)</td></tr>
<tr class="separator:a570aae76320c8226653aa0c7d0b3c76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975ff1996ba168420562abe4f8898277" id="r_a975ff1996ba168420562abe4f8898277"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a975ff1996ba168420562abe4f8898277">upper</a> (self)</td></tr>
<tr class="separator:a975ff1996ba168420562abe4f8898277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f385da8044811562e1545097519213" id="r_a88f385da8044811562e1545097519213"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a88f385da8044811562e1545097519213">title</a> (self)</td></tr>
<tr class="separator:a88f385da8044811562e1545097519213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51de8206997c691e3f5eba64abb064d" id="r_ac51de8206997c691e3f5eba64abb064d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ac51de8206997c691e3f5eba64abb064d">capitalize</a> (self)</td></tr>
<tr class="separator:ac51de8206997c691e3f5eba64abb064d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637134393abbd560faa1456f806ffe37" id="r_a637134393abbd560faa1456f806ffe37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a637134393abbd560faa1456f806ffe37">swapcase</a> (self)</td></tr>
<tr class="separator:a637134393abbd560faa1456f806ffe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfbb7419cec01847648752bbd09efdd" id="r_a2bfbb7419cec01847648752bbd09efdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a2bfbb7419cec01847648752bbd09efdd">casefold</a> (self)</td></tr>
<tr class="separator:a2bfbb7419cec01847648752bbd09efdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin.html">pandas.core.base.NoNewAttributesMixin</a></td></tr>
<tr class="memitem:a75487720304fa4de4b3b2ed5f3273634 inherit pub_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin" id="r_a75487720304fa4de4b3b2ed5f3273634"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin.html#a75487720304fa4de4b3b2ed5f3273634">__setattr__</a> (self, str key, value)</td></tr>
<tr class="separator:a75487720304fa4de4b3b2ed5f3273634 inherit pub_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af3896754601ab3a1d1207169bcd35345" id="r_af3896754601ab3a1d1207169bcd35345"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#af3896754601ab3a1d1207169bcd35345">isalnum</a></td></tr>
<tr class="separator:af3896754601ab3a1d1207169bcd35345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c4a17f5dadf8d1ad088a96fe9cf3df" id="r_a25c4a17f5dadf8d1ad088a96fe9cf3df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a25c4a17f5dadf8d1ad088a96fe9cf3df">isalpha</a></td></tr>
<tr class="separator:a25c4a17f5dadf8d1ad088a96fe9cf3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cead0abdc04ffb30a67f76e0c323a39" id="r_a6cead0abdc04ffb30a67f76e0c323a39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a6cead0abdc04ffb30a67f76e0c323a39">isdigit</a></td></tr>
<tr class="separator:a6cead0abdc04ffb30a67f76e0c323a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57427c35555368a1a7f67ffd94946d2" id="r_ab57427c35555368a1a7f67ffd94946d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ab57427c35555368a1a7f67ffd94946d2">isspace</a></td></tr>
<tr class="separator:ab57427c35555368a1a7f67ffd94946d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f3ce8996b3fff51c9ec1a259d861f" id="r_a287f3ce8996b3fff51c9ec1a259d861f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a287f3ce8996b3fff51c9ec1a259d861f">islower</a></td></tr>
<tr class="separator:a287f3ce8996b3fff51c9ec1a259d861f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a4333c1f2f88e028dec22c31e87d88" id="r_ad0a4333c1f2f88e028dec22c31e87d88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ad0a4333c1f2f88e028dec22c31e87d88">isupper</a></td></tr>
<tr class="separator:ad0a4333c1f2f88e028dec22c31e87d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55de6c3def43f8868ef4e6c99678dbc7" id="r_a55de6c3def43f8868ef4e6c99678dbc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a55de6c3def43f8868ef4e6c99678dbc7">istitle</a></td></tr>
<tr class="separator:a55de6c3def43f8868ef4e6c99678dbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f0c443280b2268e278d48f9dc5e881" id="r_a39f0c443280b2268e278d48f9dc5e881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a39f0c443280b2268e278d48f9dc5e881">isnumeric</a></td></tr>
<tr class="separator:a39f0c443280b2268e278d48f9dc5e881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd620e0cfa64303c1a6a009628cd02f" id="r_adbd620e0cfa64303c1a6a009628cd02f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#adbd620e0cfa64303c1a6a009628cd02f">isdecimal</a></td></tr>
<tr class="separator:adbd620e0cfa64303c1a6a009628cd02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a653b067d925fa9ed797ef6567c127489" id="r_a653b067d925fa9ed797ef6567c127489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a653b067d925fa9ed797ef6567c127489">_wrap_result</a> (self, result, name=None, bool|None expand=None, fill_value=np.nan, returns_string=True, bool returns_bool=False)</td></tr>
<tr class="separator:a653b067d925fa9ed797ef6567c127489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333e4e9f83387ea9a54b8958bb012fdd" id="r_a333e4e9f83387ea9a54b8958bb012fdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a333e4e9f83387ea9a54b8958bb012fdd">_get_series_list</a> (self, others)</td></tr>
<tr class="separator:a333e4e9f83387ea9a54b8958bb012fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin.html">pandas.core.base.NoNewAttributesMixin</a></td></tr>
<tr class="memitem:a804cd82b1768c337274f973595fc3af3 inherit pro_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin" id="r_a804cd82b1768c337274f973595fc3af3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin.html#a804cd82b1768c337274f973595fc3af3">_freeze</a> (self)</td></tr>
<tr class="separator:a804cd82b1768c337274f973595fc3af3 inherit pro_methods_classpandas_1_1core_1_1base_1_1_no_new_attributes_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a18f2a8b9ff780b724f2de7991fe2d08a" id="r_a18f2a8b9ff780b724f2de7991fe2d08a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a18f2a8b9ff780b724f2de7991fe2d08a">_validate</a> (data)</td></tr>
<tr class="separator:a18f2a8b9ff780b724f2de7991fe2d08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a78ba459ec6f86cb7982d51cd6afb7833" id="r_a78ba459ec6f86cb7982d51cd6afb7833"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a78ba459ec6f86cb7982d51cd6afb7833">_inferred_dtype</a></td></tr>
<tr class="separator:a78ba459ec6f86cb7982d51cd6afb7833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62091cd5c2eade0a46408af23d74b31" id="r_af62091cd5c2eade0a46408af23d74b31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#af62091cd5c2eade0a46408af23d74b31">_is_categorical</a></td></tr>
<tr class="separator:af62091cd5c2eade0a46408af23d74b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dc71a51d139037b6972858a419eb05" id="r_ab0dc71a51d139037b6972858a419eb05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ab0dc71a51d139037b6972858a419eb05">_is_string</a></td></tr>
<tr class="separator:ab0dc71a51d139037b6972858a419eb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332ded9906c1a558e652bc0de324044f" id="r_a332ded9906c1a558e652bc0de324044f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a332ded9906c1a558e652bc0de324044f">_data</a></td></tr>
<tr class="separator:a332ded9906c1a558e652bc0de324044f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7fc992c7d77f8663db5f5ffcf95271" id="r_a1e7fc992c7d77f8663db5f5ffcf95271"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a1e7fc992c7d77f8663db5f5ffcf95271">_index</a></td></tr>
<tr class="separator:a1e7fc992c7d77f8663db5f5ffcf95271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade552f90a4da0a7e0d6f388dd40804b6" id="r_ade552f90a4da0a7e0d6f388dd40804b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#ade552f90a4da0a7e0d6f388dd40804b6">_name</a></td></tr>
<tr class="separator:ade552f90a4da0a7e0d6f388dd40804b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566226ec0fc52b59d1ad70e2a5ec7c78" id="r_a566226ec0fc52b59d1ad70e2a5ec7c78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a566226ec0fc52b59d1ad70e2a5ec7c78">_parent</a></td></tr>
<tr class="separator:a566226ec0fc52b59d1ad70e2a5ec7c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6449413b7c205c2f1c9028b9fab9900" id="r_aa6449413b7c205c2f1c9028b9fab9900"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#aa6449413b7c205c2f1c9028b9fab9900">_orig</a></td></tr>
<tr class="separator:aa6449413b7c205c2f1c9028b9fab9900"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a32d58d6df988c955e7e925134eab4304" id="r_a32d58d6df988c955e7e925134eab4304"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html#a32d58d6df988c955e7e925134eab4304">_doc_args</a> = {}</td></tr>
<tr class="separator:a32d58d6df988c955e7e925134eab4304"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Vectorized string functions for Series and Index.

NAs stay NA unless handled otherwise by a particular method.
Patterned after Python's string methods, with some inspiration from
R's stringr package.

Examples
--------
&gt;&gt;&gt; s = pd.Series(["A_Str_Series"])
&gt;&gt;&gt; s
0    A_Str_Series
dtype: object

&gt;&gt;&gt; s.str.split("_")
0    [A, Str, Series]
dtype: object

&gt;&gt;&gt; s.str.replace("_", "")
0    AStrSeries
dtype: object
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4dfb4ad7629d086d3ec8e18c1b51fac6" name="a4dfb4ad7629d086d3ec8e18c1b51fac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfb4ad7629d086d3ec8e18c1b51fac6">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.strings.accessor.StringMethods.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  178</span>    <span class="keyword">def </span>__init__(self, data) -&gt; None:</div>
<div class="line"><span class="lineno">  179</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a> <span class="keyword">import</span> StringDtype</div>
<div class="line"><span class="lineno">  180</span> </div>
<div class="line"><span class="lineno">  181</span>        self._inferred_dtype = self._validate(data)</div>
<div class="line"><span class="lineno">  182</span>        self._is_categorical = is_categorical_dtype(data.dtype)</div>
<div class="line"><span class="lineno">  183</span>        self._is_string = isinstance(data.dtype, StringDtype)</div>
<div class="line"><span class="lineno">  184</span>        self._data = data</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>        self._index = self._name = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  187</span>        <span class="keywordflow">if</span> isinstance(data, ABCSeries):</div>
<div class="line"><span class="lineno">  188</span>            self._index = data.index</div>
<div class="line"><span class="lineno">  189</span>            self._name = data.name</div>
<div class="line"><span class="lineno">  190</span> </div>
<div class="line"><span class="lineno">  191</span>        <span class="comment"># ._values.categories works for both Series/Index</span></div>
<div class="line"><span class="lineno">  192</span>        self._parent = data._values.categories <span class="keywordflow">if</span> self._is_categorical <span class="keywordflow">else</span> data</div>
<div class="line"><span class="lineno">  193</span>        <span class="comment"># save orig to blow up categoricals to the right type</span></div>
<div class="line"><span class="lineno">  194</span>        self._orig = data</div>
<div class="line"><span class="lineno">  195</span>        self._freeze()</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1string___html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a></div><div class="ttdef"><b>Definition</b> string_.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f0d6acd0a862dc6fc56dd89e3dd9957" name="a2f0d6acd0a862dc6fc56dd89e3dd9957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0d6acd0a862dc6fc56dd89e3dd9957">&#9670;&#160;</a></span>__getitem__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.__getitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  238</span>    <span class="keyword">def </span>__getitem__(self, key):</div>
<div class="line"><span class="lineno">  239</span>        result = self._data.array._str_getitem(key)</div>
<div class="line"><span class="lineno">  240</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno">  241</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e8c8c0f904e72923bf4770967a4c096" name="a4e8c8c0f904e72923bf4770967a4c096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8c8c0f904e72923bf4770967a4c096">&#9670;&#160;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.__iter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  242</span>    <span class="keyword">def </span>__iter__(self):</div>
<div class="line"><span class="lineno">  243</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  244</span>            <span class="stringliteral">&quot;Columnar iteration over characters will be deprecated in future releases.&quot;</span>,</div>
<div class="line"><span class="lineno">  245</span>            FutureWarning,</div>
<div class="line"><span class="lineno">  246</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  247</span>        )</div>
<div class="line"><span class="lineno">  248</span>        i = 0</div>
<div class="line"><span class="lineno">  249</span>        g = self.get(i)</div>
<div class="line"><span class="lineno">  250</span>        <span class="keywordflow">while</span> g.notna().any():</div>
<div class="line"><span class="lineno">  251</span>            <span class="keywordflow">yield</span> g</div>
<div class="line"><span class="lineno">  252</span>            i += 1</div>
<div class="line"><span class="lineno">  253</span>            g = self.get(i)</div>
<div class="line"><span class="lineno">  254</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a333e4e9f83387ea9a54b8958bb012fdd" name="a333e4e9f83387ea9a54b8958bb012fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333e4e9f83387ea9a54b8958bb012fdd">&#9670;&#160;</a></span>_get_series_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._get_series_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Auxiliary function for :meth:`str.cat`. Turn potentially mixed input
into a list of Series (elements without an index must match the length
of the calling Series/Index).

Parameters
----------
others : Series, DataFrame, np.ndarray, list-like or list-like of
    Objects that are either Series, Index or np.ndarray (1-dim).

Returns
-------
list of Series
    Others transformed into list of Series.
</pre> <div class="fragment"><div class="line"><span class="lineno">  366</span>    <span class="keyword">def </span>_get_series_list(self, others):</div>
<div class="line"><span class="lineno">  367</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">        into a list of Series (elements without an index must match the length</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">        of the calling Series/Index).</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        others : Series, DataFrame, np.ndarray, list-like or list-like of</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">            Objects that are either Series, Index or np.ndarray (1-dim).</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        list of Series</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">            Others transformed into list of Series.</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  382</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> (</div>
<div class="line"><span class="lineno">  383</span>            DataFrame,</div>
<div class="line"><span class="lineno">  384</span>            Series,</div>
<div class="line"><span class="lineno">  385</span>        )</div>
<div class="line"><span class="lineno">  386</span> </div>
<div class="line"><span class="lineno">  387</span>        <span class="comment"># self._orig is either Series or Index</span></div>
<div class="line"><span class="lineno">  388</span>        idx = self._orig <span class="keywordflow">if</span> isinstance(self._orig, ABCIndex) <span class="keywordflow">else</span> self._orig.index</div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span>        <span class="comment"># Generally speaking, all objects without an index inherit the index</span></div>
<div class="line"><span class="lineno">  391</span>        <span class="comment"># `idx` of the calling Series/Index - i.e. must have matching length.</span></div>
<div class="line"><span class="lineno">  392</span>        <span class="comment"># Objects with an index (i.e. Series/Index/DataFrame) keep their own.</span></div>
<div class="line"><span class="lineno">  393</span>        <span class="keywordflow">if</span> isinstance(others, ABCSeries):</div>
<div class="line"><span class="lineno">  394</span>            <span class="keywordflow">return</span> [others]</div>
<div class="line"><span class="lineno">  395</span>        <span class="keywordflow">elif</span> isinstance(others, ABCIndex):</div>
<div class="line"><span class="lineno">  396</span>            <span class="keywordflow">return</span> [Series(others._values, index=idx, dtype=others.dtype)]</div>
<div class="line"><span class="lineno">  397</span>        <span class="keywordflow">elif</span> isinstance(others, ABCDataFrame):</div>
<div class="line"><span class="lineno">  398</span>            <span class="keywordflow">return</span> [others[x] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> others]</div>
<div class="line"><span class="lineno">  399</span>        <span class="keywordflow">elif</span> isinstance(others, np.ndarray) <span class="keywordflow">and</span> others.ndim == 2:</div>
<div class="line"><span class="lineno">  400</span>            others = DataFrame(others, index=idx)</div>
<div class="line"><span class="lineno">  401</span>            <span class="keywordflow">return</span> [others[x] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> others]</div>
<div class="line"><span class="lineno">  402</span>        <span class="keywordflow">elif</span> is_list_like(others, allow_sets=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  403</span>            others = list(others)  <span class="comment"># ensure iterators do not get read twice etc</span></div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>            <span class="comment"># in case of list-like `others`, all elements must be</span></div>
<div class="line"><span class="lineno">  406</span>            <span class="comment"># either Series/Index/np.ndarray (1-dim)...</span></div>
<div class="line"><span class="lineno">  407</span>            <span class="keywordflow">if</span> all(</div>
<div class="line"><span class="lineno">  408</span>                isinstance(x, (ABCSeries, ABCIndex))</div>
<div class="line"><span class="lineno">  409</span>                <span class="keywordflow">or</span> (isinstance(x, np.ndarray) <span class="keywordflow">and</span> x.ndim == 1)</div>
<div class="line"><span class="lineno">  410</span>                <span class="keywordflow">for</span> x <span class="keywordflow">in</span> others</div>
<div class="line"><span class="lineno">  411</span>            ):</div>
<div class="line"><span class="lineno">  412</span>                los: list[Series] = []</div>
<div class="line"><span class="lineno">  413</span>                <span class="keywordflow">while</span> others:  <span class="comment"># iterate through list and append each element</span></div>
<div class="line"><span class="lineno">  414</span>                    los = los + self._get_series_list(others.pop(0))</div>
<div class="line"><span class="lineno">  415</span>                <span class="keywordflow">return</span> los</div>
<div class="line"><span class="lineno">  416</span>            <span class="comment"># ... or just strings</span></div>
<div class="line"><span class="lineno">  417</span>            <span class="keywordflow">elif</span> all(<span class="keywordflow">not</span> is_list_like(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> others):</div>
<div class="line"><span class="lineno">  418</span>                <span class="keywordflow">return</span> [Series(others, index=idx)]</div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  420</span>            <span class="stringliteral">&quot;others must be Series, Index, DataFrame, np.ndarray &quot;</span></div>
<div class="line"><span class="lineno">  421</span>            <span class="stringliteral">&quot;or list-like (either containing only strings or &quot;</span></div>
<div class="line"><span class="lineno">  422</span>            <span class="stringliteral">&quot;containing only objects of type Series/Index/&quot;</span></div>
<div class="line"><span class="lineno">  423</span>            <span class="stringliteral">&quot;np.ndarray[1-dim])&quot;</span></div>
<div class="line"><span class="lineno">  424</span>        )</div>
<div class="line"><span class="lineno">  425</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a18f2a8b9ff780b724f2de7991fe2d08a" name="a18f2a8b9ff780b724f2de7991fe2d08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f2a8b9ff780b724f2de7991fe2d08a">&#9670;&#160;</a></span>_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._validate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Auxiliary function for StringMethods, infers and checks dtype of data.

This is a "first line of defence" at the creation of the StringMethods-
object, and just checks that the dtype is in the
*union* of the allowed types over all string methods below; this
restriction is then refined on a per-method basis using the decorator
@forbid_nonstring_types (more info in the corresponding docstring).

This really should exclude all series/index with any non-string values,
but that isn't practical for performance reasons until we have a str
dtype (GH 9343 / 13877)

Parameters
----------
data : The content of the Series

Returns
-------
dtype : inferred dtype of data
</pre> <div class="fragment"><div class="line"><span class="lineno">  198</span>    <span class="keyword">def </span>_validate(data):</div>
<div class="line"><span class="lineno">  199</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        Auxiliary function for StringMethods, infers and checks dtype of data.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        This is a &quot;first line of defence&quot; at the creation of the StringMethods-</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        object, and just checks that the dtype is in the</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        *union* of the allowed types over all string methods below; this</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">        restriction is then refined on a per-method basis using the decorator</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        @forbid_nonstring_types (more info in the corresponding docstring).</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        This really should exclude all series/index with any non-string values,</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        but that isn&#39;t practical for performance reasons until we have a str</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        dtype (GH 9343 / 13877)</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        data : The content of the Series</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        dtype : inferred dtype of data</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  220</span>        <span class="keywordflow">if</span> isinstance(data, ABCMultiIndex):</div>
<div class="line"><span class="lineno">  221</span>            <span class="keywordflow">raise</span> AttributeError(</div>
<div class="line"><span class="lineno">  222</span>                <span class="stringliteral">&quot;Can only use .str accessor with Index, not MultiIndex&quot;</span></div>
<div class="line"><span class="lineno">  223</span>            )</div>
<div class="line"><span class="lineno">  224</span> </div>
<div class="line"><span class="lineno">  225</span>        <span class="comment"># see _libs/lib.pyx for list of inferred types</span></div>
<div class="line"><span class="lineno">  226</span>        allowed_types = [<span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;empty&quot;</span>, <span class="stringliteral">&quot;bytes&quot;</span>, <span class="stringliteral">&quot;mixed&quot;</span>, <span class="stringliteral">&quot;mixed-integer&quot;</span>]</div>
<div class="line"><span class="lineno">  227</span> </div>
<div class="line"><span class="lineno">  228</span>        data = extract_array(data)</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>        values = getattr(data, <span class="stringliteral">&quot;categories&quot;</span>, data)  <span class="comment"># categorical / normal</span></div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>        inferred_dtype = lib.infer_dtype(values, skipna=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  233</span> </div>
<div class="line"><span class="lineno">  234</span>        <span class="keywordflow">if</span> inferred_dtype <span class="keywordflow">not</span> <span class="keywordflow">in</span> allowed_types:</div>
<div class="line"><span class="lineno">  235</span>            <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&quot;Can only use .str accessor with string values!&quot;</span>)</div>
<div class="line"><span class="lineno">  236</span>        <span class="keywordflow">return</span> inferred_dtype</div>
<div class="line"><span class="lineno">  237</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a653b067d925fa9ed797ef6567c127489" name="a653b067d925fa9ed797ef6567c127489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653b067d925fa9ed797ef6567c127489">&#9670;&#160;</a></span>_wrap_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._wrap_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>expand</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>np.nan</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>returns_string</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>returns_bool</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  263</span>    ):</div>
<div class="line"><span class="lineno">  264</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> (</div>
<div class="line"><span class="lineno">  265</span>            Index,</div>
<div class="line"><span class="lineno">  266</span>            MultiIndex,</div>
<div class="line"><span class="lineno">  267</span>        )</div>
<div class="line"><span class="lineno">  268</span> </div>
<div class="line"><span class="lineno">  269</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(result, <span class="stringliteral">&quot;ndim&quot;</span>) <span class="keywordflow">or</span> <span class="keywordflow">not</span> hasattr(result, <span class="stringliteral">&quot;dtype&quot;</span>):</div>
<div class="line"><span class="lineno">  270</span>            <span class="keywordflow">if</span> isinstance(result, ABCDataFrame):</div>
<div class="line"><span class="lineno">  271</span>                result = result.__finalize__(self._orig, name=<span class="stringliteral">&quot;str&quot;</span>)</div>
<div class="line"><span class="lineno">  272</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  273</span>        <span class="keyword">assert</span> result.ndim &lt; 3</div>
<div class="line"><span class="lineno">  274</span> </div>
<div class="line"><span class="lineno">  275</span>        <span class="comment"># We can be wrapping a string / object / categorical result, in which</span></div>
<div class="line"><span class="lineno">  276</span>        <span class="comment"># case we&#39;ll want to return the same dtype as the input.</span></div>
<div class="line"><span class="lineno">  277</span>        <span class="comment"># Or we can be wrapping a numeric output, in which case we don&#39;t want</span></div>
<div class="line"><span class="lineno">  278</span>        <span class="comment"># to return a StringArray.</span></div>
<div class="line"><span class="lineno">  279</span>        <span class="comment"># Ideally the array method returns the right array type.</span></div>
<div class="line"><span class="lineno">  280</span>        <span class="keywordflow">if</span> expand <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  281</span>            <span class="comment"># infer from ndim if expand is not specified</span></div>
<div class="line"><span class="lineno">  282</span>            expand = result.ndim != 1</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>        <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno">  285</span>            expand <span class="keywordflow">is</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  286</span>            <span class="keywordflow">and</span> is_object_dtype(result)</div>
<div class="line"><span class="lineno">  287</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self._orig, ABCIndex)</div>
<div class="line"><span class="lineno">  288</span>        ):</div>
<div class="line"><span class="lineno">  289</span>            <span class="comment"># required when expand=True is explicitly specified</span></div>
<div class="line"><span class="lineno">  290</span>            <span class="comment"># not needed when inferred</span></div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>            <span class="keyword">def </span>cons_row(x):</div>
<div class="line"><span class="lineno">  293</span>                <span class="keywordflow">if</span> is_list_like(x):</div>
<div class="line"><span class="lineno">  294</span>                    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  295</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  296</span>                    <span class="keywordflow">return</span> [x]</div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span>            result = [cons_row(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> result]</div>
<div class="line"><span class="lineno">  299</span>            <span class="keywordflow">if</span> result <span class="keywordflow">and</span> <span class="keywordflow">not</span> self._is_string:</div>
<div class="line"><span class="lineno">  300</span>                <span class="comment"># propagate nan values to match longest sequence (GH 18450)</span></div>
<div class="line"><span class="lineno">  301</span>                max_len = max(len(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> result)</div>
<div class="line"><span class="lineno">  302</span>                result = [</div>
<div class="line"><span class="lineno">  303</span>                    x * max_len <span class="keywordflow">if</span> len(x) == 0 <span class="keywordflow">or</span> x[0] <span class="keywordflow">is</span> np.nan <span class="keywordflow">else</span> x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> result</div>
<div class="line"><span class="lineno">  304</span>                ]</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(expand, bool):</div>
<div class="line"><span class="lineno">  307</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;expand must be True or False&quot;</span>)</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span>        <span class="keywordflow">if</span> expand <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno">  310</span>            <span class="comment"># if expand is False, result should have the same name</span></div>
<div class="line"><span class="lineno">  311</span>            <span class="comment"># as the original otherwise specified</span></div>
<div class="line"><span class="lineno">  312</span>            <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  313</span>                name = getattr(result, <span class="stringliteral">&quot;name&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  314</span>            <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  315</span>                <span class="comment"># do not use logical or, _orig may be a DataFrame</span></div>
<div class="line"><span class="lineno">  316</span>                <span class="comment"># which has &quot;name&quot; column</span></div>
<div class="line"><span class="lineno">  317</span>                name = self._orig.name</div>
<div class="line"><span class="lineno">  318</span> </div>
<div class="line"><span class="lineno">  319</span>        <span class="comment"># Wait until we are sure result is a Series or Index before</span></div>
<div class="line"><span class="lineno">  320</span>        <span class="comment"># checking attributes (GH 12180)</span></div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">if</span> isinstance(self._orig, ABCIndex):</div>
<div class="line"><span class="lineno">  322</span>            <span class="comment"># if result is a boolean np.array, return the np.array</span></div>
<div class="line"><span class="lineno">  323</span>            <span class="comment"># instead of wrapping it into a boolean Index (GH 8875)</span></div>
<div class="line"><span class="lineno">  324</span>            <span class="keywordflow">if</span> is_bool_dtype(result):</div>
<div class="line"><span class="lineno">  325</span>                <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span>            <span class="keywordflow">if</span> expand:</div>
<div class="line"><span class="lineno">  328</span>                result = list(result)</div>
<div class="line"><span class="lineno">  329</span>                out = MultiIndex.from_tuples(result, names=name)</div>
<div class="line"><span class="lineno">  330</span>                <span class="keywordflow">if</span> out.nlevels == 1:</div>
<div class="line"><span class="lineno">  331</span>                    <span class="comment"># We had all tuples of length-one, which are</span></div>
<div class="line"><span class="lineno">  332</span>                    <span class="comment"># better represented as a regular Index.</span></div>
<div class="line"><span class="lineno">  333</span>                    out = out.get_level_values(0)</div>
<div class="line"><span class="lineno">  334</span>                <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  335</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  336</span>                <span class="keywordflow">return</span> Index._with_infer(result, name=name)</div>
<div class="line"><span class="lineno">  337</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  338</span>            index = self._orig.index</div>
<div class="line"><span class="lineno">  339</span>            <span class="comment"># This is a mess.</span></div>
<div class="line"><span class="lineno">  340</span>            dtype: DtypeObj | str | <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  341</span>            vdtype = getattr(result, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  342</span>            <span class="keywordflow">if</span> self._is_string:</div>
<div class="line"><span class="lineno">  343</span>                <span class="keywordflow">if</span> is_bool_dtype(vdtype):</div>
<div class="line"><span class="lineno">  344</span>                    dtype = result.dtype</div>
<div class="line"><span class="lineno">  345</span>                <span class="keywordflow">elif</span> returns_string:</div>
<div class="line"><span class="lineno">  346</span>                    dtype = self._orig.dtype</div>
<div class="line"><span class="lineno">  347</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  348</span>                    dtype = vdtype</div>
<div class="line"><span class="lineno">  349</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  350</span>                dtype = vdtype</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>            <span class="keywordflow">if</span> expand:</div>
<div class="line"><span class="lineno">  353</span>                cons = self._orig._constructor_expanddim</div>
<div class="line"><span class="lineno">  354</span>                result = cons(result, columns=name, index=index, dtype=dtype)</div>
<div class="line"><span class="lineno">  355</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  356</span>                <span class="comment"># Must be a Series</span></div>
<div class="line"><span class="lineno">  357</span>                cons = self._orig._constructor</div>
<div class="line"><span class="lineno">  358</span>                result = cons(result, name=name, index=index, dtype=dtype)</div>
<div class="line"><span class="lineno">  359</span>            result = result.__finalize__(self._orig, method=<span class="stringliteral">&quot;str&quot;</span>)</div>
<div class="line"><span class="lineno">  360</span>            <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> result.ndim == 1:</div>
<div class="line"><span class="lineno">  361</span>                <span class="comment"># __finalize__ might copy over the original name, but we may</span></div>
<div class="line"><span class="lineno">  362</span>                <span class="comment"># want the new name (e.g. str.extract).</span></div>
<div class="line"><span class="lineno">  363</span>                result.name = name</div>
<div class="line"><span class="lineno">  364</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  365</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac51de8206997c691e3f5eba64abb064d" name="ac51de8206997c691e3f5eba64abb064d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51de8206997c691e3f5eba64abb064d">&#9670;&#160;</a></span>capitalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.capitalize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3033</span>    <span class="keyword">def </span>capitalize(self):</div>
<div class="line"><span class="lineno"> 3034</span>        result = self._data.array._str_capitalize()</div>
<div class="line"><span class="lineno"> 3035</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 3036</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2bfbb7419cec01847648752bbd09efdd" name="a2bfbb7419cec01847648752bbd09efdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfbb7419cec01847648752bbd09efdd">&#9670;&#160;</a></span>casefold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.casefold </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3045</span>    <span class="keyword">def </span>casefold(self):</div>
<div class="line"><span class="lineno"> 3046</span>        result = self._data.array._str_casefold()</div>
<div class="line"><span class="lineno"> 3047</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 3048</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3cd67d334b1c4b0b1113ccd5681b23a6" name="a3cd67d334b1c4b0b1113ccd5681b23a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd67d334b1c4b0b1113ccd5681b23a6">&#9670;&#160;</a></span>cat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str | Series | Index pandas.core.strings.accessor.StringMethods.cat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>others</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>na_rep</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>join</em> = <code>&quot;left&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Concatenate strings in the Series/Index with given separator.

If `others` is specified, this function concatenates the Series/Index
and elements of `others` element-wise.
If `others` is not passed, then all values in the Series/Index are
concatenated into a single string with a given `sep`.

Parameters
----------
others : Series, Index, DataFrame, np.ndarray or list-like
    Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and
    other list-likes of strings must have the same length as the
    calling Series/Index, with the exception of indexed objects (i.e.
    Series/Index/DataFrame) if `join` is not None.

    If others is a list-like that contains a combination of Series,
    Index or np.ndarray (1-dim), then all elements will be unpacked and
    must satisfy the above criteria individually.

    If others is None, the method returns the concatenation of all
    strings in the calling Series/Index.
sep : str, default ''
    The separator between the different elements/columns. By default
    the empty string `''` is used.
na_rep : str or None, default None
    Representation that is inserted for all missing values:

    - If `na_rep` is None, and `others` is None, missing values in the
      Series/Index are omitted from the result.
    - If `na_rep` is None, and `others` is not None, a row containing a
      missing value in any of the columns (before concatenation) will
      have a missing value in the result.
join : {'left', 'right', 'outer', 'inner'}, default 'left'
    Determines the join-style between the calling Series/Index and any
    Series/Index/DataFrame in `others` (objects without an index need
    to match the length of the calling Series/Index). To disable
    alignment, use `.values` on any Series/Index/DataFrame in `others`.

    .. versionadded:: 0.23.0
    .. versionchanged:: 1.0.0
        Changed default of `join` from None to `'left'`.

Returns
-------
str, Series or Index
    If `others` is None, `str` is returned, otherwise a `Series/Index`
    (same type as caller) of objects is returned.

See Also
--------
split : Split each string in the Series/Index.
join : Join lists contained as elements in the Series/Index.

Examples
--------
When not passing `others`, all values are concatenated into a single
string:

&gt;&gt;&gt; s = pd.Series(['a', 'b', np.nan, 'd'])
&gt;&gt;&gt; s.str.cat(sep=' ')
'a b d'

By default, NA values in the Series are ignored. Using `na_rep`, they
can be given a representation:

&gt;&gt;&gt; s.str.cat(sep=' ', na_rep='?')
'a b ? d'

If `others` is specified, corresponding values are concatenated with
the separator. Result will be a Series of strings.

&gt;&gt;&gt; s.str.cat(['A', 'B', 'C', 'D'], sep=',')
0    a,A
1    b,B
2    NaN
3    d,D
dtype: object

Missing values will remain missing in the result, but can again be
represented using `na_rep`

&gt;&gt;&gt; s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')
0    a,A
1    b,B
2    -,C
3    d,D
dtype: object

If `sep` is not specified, the values are concatenated without
separation.

&gt;&gt;&gt; s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')
0    aA
1    bB
2    -C
3    dD
dtype: object

Series with different indexes can be aligned before concatenation. The
`join`-keyword works as in other methods.

&gt;&gt;&gt; t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])
&gt;&gt;&gt; s.str.cat(t, join='left', na_rep='-')
0    aa
1    b-
2    -c
3    dd
dtype: object
&gt;&gt;&gt;
&gt;&gt;&gt; s.str.cat(t, join='outer', na_rep='-')
0    aa
1    b-
2    -c
3    dd
4    -e
dtype: object
&gt;&gt;&gt;
&gt;&gt;&gt; s.str.cat(t, join='inner', na_rep='-')
0    aa
2    -c
3    dd
dtype: object
&gt;&gt;&gt;
&gt;&gt;&gt; s.str.cat(t, join='right', na_rep='-')
3    dd
0    aa
4    -e
2    -c
dtype: object

For more examples, see :ref:`here &lt;text.concatenate&gt;`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  429</span>    ) -&gt; str | Series | Index:</div>
<div class="line"><span class="lineno">  430</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        Concatenate strings in the Series/Index with given separator.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        If `others` is specified, this function concatenates the Series/Index</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        and elements of `others` element-wise.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        If `others` is not passed, then all values in the Series/Index are</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">        concatenated into a single string with a given `sep`.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        others : Series, Index, DataFrame, np.ndarray or list-like</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">            other list-likes of strings must have the same length as the</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">            calling Series/Index, with the exception of indexed objects (i.e.</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">            Series/Index/DataFrame) if `join` is not None.</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">            If others is a list-like that contains a combination of Series,</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">            Index or np.ndarray (1-dim), then all elements will be unpacked and</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">            must satisfy the above criteria individually.</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">            If others is None, the method returns the concatenation of all</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">            strings in the calling Series/Index.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        sep : str, default &#39;&#39;</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">            The separator between the different elements/columns. By default</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">            the empty string `&#39;&#39;` is used.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">        na_rep : str or None, default None</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">            Representation that is inserted for all missing values:</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">            - If `na_rep` is None, and `others` is None, missing values in the</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">              Series/Index are omitted from the result.</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">            - If `na_rep` is None, and `others` is not None, a row containing a</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">              missing value in any of the columns (before concatenation) will</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">              have a missing value in the result.</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        join : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;}, default &#39;left&#39;</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">            Determines the join-style between the calling Series/Index and any</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">            Series/Index/DataFrame in `others` (objects without an index need</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">            to match the length of the calling Series/Index). To disable</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">            alignment, use `.values` on any Series/Index/DataFrame in `others`.</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">            .. versionadded:: 0.23.0</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">            .. versionchanged:: 1.0.0</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">                Changed default of `join` from None to `&#39;left&#39;`.</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        str, Series or Index</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">            If `others` is None, `str` is returned, otherwise a `Series/Index`</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">            (same type as caller) of objects is returned.</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        split : Split each string in the Series/Index.</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        join : Join lists contained as elements in the Series/Index.</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        When not passing `others`, all values are concatenated into a single</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        string:</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;b&#39;, np.nan, &#39;d&#39;])</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat(sep=&#39; &#39;)</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        &#39;a b d&#39;</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        By default, NA values in the Series are ignored. Using `na_rep`, they</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        can be given a representation:</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat(sep=&#39; &#39;, na_rep=&#39;?&#39;)</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">        &#39;a b ? d&#39;</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        If `others` is specified, corresponding values are concatenated with</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        the separator. Result will be a Series of strings.</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], sep=&#39;,&#39;)</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        0    a,A</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        1    b,B</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        2    NaN</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        3    d,D</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        Missing values will remain missing in the result, but can again be</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        represented using `na_rep`</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], sep=&#39;,&#39;, na_rep=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        0    a,A</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        1    b,B</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        2    -,C</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        3    d,D</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        If `sep` is not specified, the values are concatenated without</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        separation.</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], na_rep=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        0    aA</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        1    bB</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">        2    -C</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">        3    dD</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        Series with different indexes can be aligned before concatenation. The</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        `join`-keyword works as in other methods.</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        &gt;&gt;&gt; t = pd.Series([&#39;d&#39;, &#39;a&#39;, &#39;e&#39;, &#39;c&#39;], index=[3, 0, 4, 2])</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat(t, join=&#39;left&#39;, na_rep=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        0    aa</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        1    b-</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">        2    -c</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">        3    dd</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">        &gt;&gt;&gt;</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat(t, join=&#39;outer&#39;, na_rep=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        0    aa</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        1    b-</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        2    -c</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        3    dd</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        4    -e</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">        &gt;&gt;&gt;</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat(t, join=&#39;inner&#39;, na_rep=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        0    aa</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        2    -c</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        3    dd</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        &gt;&gt;&gt;</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">        &gt;&gt;&gt; s.str.cat(t, join=&#39;right&#39;, na_rep=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">        3    dd</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">        0    aa</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">        4    -e</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">        2    -c</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">        For more examples, see :ref:`here &lt;text.concatenate&gt;`.</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  563</span>        <span class="comment"># TODO: dispatch</span></div>
<div class="line"><span class="lineno">  564</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> (</div>
<div class="line"><span class="lineno">  565</span>            Index,</div>
<div class="line"><span class="lineno">  566</span>            Series,</div>
<div class="line"><span class="lineno">  567</span>            concat,</div>
<div class="line"><span class="lineno">  568</span>        )</div>
<div class="line"><span class="lineno">  569</span> </div>
<div class="line"><span class="lineno">  570</span>        <span class="keywordflow">if</span> isinstance(others, str):</div>
<div class="line"><span class="lineno">  571</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Did you mean to supply a `sep` keyword?&quot;</span>)</div>
<div class="line"><span class="lineno">  572</span>        <span class="keywordflow">if</span> sep <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  573</span>            sep = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  574</span> </div>
<div class="line"><span class="lineno">  575</span>        <span class="keywordflow">if</span> isinstance(self._orig, ABCIndex):</div>
<div class="line"><span class="lineno">  576</span>            data = Series(self._orig, index=self._orig, dtype=self._orig.dtype)</div>
<div class="line"><span class="lineno">  577</span>        <span class="keywordflow">else</span>:  <span class="comment"># Series</span></div>
<div class="line"><span class="lineno">  578</span>            data = self._orig</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span>        <span class="comment"># concatenate Series/Index with itself if no &quot;others&quot;</span></div>
<div class="line"><span class="lineno">  581</span>        <span class="keywordflow">if</span> others <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  582</span>            <span class="comment"># error: Incompatible types in assignment (expression has type</span></div>
<div class="line"><span class="lineno">  583</span>            <span class="comment"># &quot;ndarray&quot;, variable has type &quot;Series&quot;)</span></div>
<div class="line"><span class="lineno">  584</span>            data = ensure_object(data)  <span class="comment"># type: ignore[assignment]</span></div>
<div class="line"><span class="lineno">  585</span>            na_mask = isna(data)</div>
<div class="line"><span class="lineno">  586</span>            <span class="keywordflow">if</span> na_rep <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> na_mask.any():</div>
<div class="line"><span class="lineno">  587</span>                <span class="keywordflow">return</span> sep.join(data[~na_mask])</div>
<div class="line"><span class="lineno">  588</span>            <span class="keywordflow">elif</span> na_rep <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> na_mask.any():</div>
<div class="line"><span class="lineno">  589</span>                <span class="keywordflow">return</span> sep.join(np.where(na_mask, na_rep, data))</div>
<div class="line"><span class="lineno">  590</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  591</span>                <span class="keywordflow">return</span> sep.join(data)</div>
<div class="line"><span class="lineno">  592</span> </div>
<div class="line"><span class="lineno">  593</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  594</span>            <span class="comment"># turn anything in &quot;others&quot; into lists of Series</span></div>
<div class="line"><span class="lineno">  595</span>            others = self._get_series_list(others)</div>
<div class="line"><span class="lineno">  596</span>        <span class="keywordflow">except</span> ValueError <span class="keyword">as</span> err:  <span class="comment"># do not catch TypeError raised by _get_series_list</span></div>
<div class="line"><span class="lineno">  597</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  598</span>                <span class="stringliteral">&quot;If `others` contains arrays or lists (or other &quot;</span></div>
<div class="line"><span class="lineno">  599</span>                <span class="stringliteral">&quot;list-likes without an index), these must all be &quot;</span></div>
<div class="line"><span class="lineno">  600</span>                <span class="stringliteral">&quot;of the same length as the calling Series/Index.&quot;</span></div>
<div class="line"><span class="lineno">  601</span>            ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>        <span class="comment"># align if required</span></div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">if</span> any(<span class="keywordflow">not</span> data.index.equals(x.index) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> others):</div>
<div class="line"><span class="lineno">  605</span>            <span class="comment"># Need to add keys for uniqueness in case of duplicate columns</span></div>
<div class="line"><span class="lineno">  606</span>            others = concat(</div>
<div class="line"><span class="lineno">  607</span>                others,</div>
<div class="line"><span class="lineno">  608</span>                axis=1,</div>
<div class="line"><span class="lineno">  609</span>                join=(join <span class="keywordflow">if</span> join == <span class="stringliteral">&quot;inner&quot;</span> <span class="keywordflow">else</span> <span class="stringliteral">&quot;outer&quot;</span>),</div>
<div class="line"><span class="lineno">  610</span>                keys=range(len(others)),</div>
<div class="line"><span class="lineno">  611</span>                sort=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  612</span>                copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  613</span>            )</div>
<div class="line"><span class="lineno">  614</span>            data, others = data.align(others, join=join)</div>
<div class="line"><span class="lineno">  615</span>            others = [others[x] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> others]  <span class="comment"># again list of Series</span></div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span>        all_cols = [ensure_object(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> [data] + others]</div>
<div class="line"><span class="lineno">  618</span>        na_masks = np.array([isna(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> all_cols])</div>
<div class="line"><span class="lineno">  619</span>        union_mask = np.logical_or.reduce(na_masks, axis=0)</div>
<div class="line"><span class="lineno">  620</span> </div>
<div class="line"><span class="lineno">  621</span>        <span class="keywordflow">if</span> na_rep <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> union_mask.any():</div>
<div class="line"><span class="lineno">  622</span>            <span class="comment"># no na_rep means NaNs for all rows where any column has a NaN</span></div>
<div class="line"><span class="lineno">  623</span>            <span class="comment"># only necessary if there are actually any NaNs</span></div>
<div class="line"><span class="lineno">  624</span>            result = np.empty(len(data), dtype=object)</div>
<div class="line"><span class="lineno">  625</span>            np.putmask(result, union_mask, np.nan)</div>
<div class="line"><span class="lineno">  626</span> </div>
<div class="line"><span class="lineno">  627</span>            not_masked = ~union_mask</div>
<div class="line"><span class="lineno">  628</span>            result[not_masked] = cat_safe([x[not_masked] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> all_cols], sep)</div>
<div class="line"><span class="lineno">  629</span>        <span class="keywordflow">elif</span> na_rep <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> union_mask.any():</div>
<div class="line"><span class="lineno">  630</span>            <span class="comment"># fill NaNs with na_rep in case there are actually any NaNs</span></div>
<div class="line"><span class="lineno">  631</span>            all_cols = [</div>
<div class="line"><span class="lineno">  632</span>                np.where(nm, na_rep, col) <span class="keywordflow">for</span> nm, col <span class="keywordflow">in</span> zip(na_masks, all_cols)</div>
<div class="line"><span class="lineno">  633</span>            ]</div>
<div class="line"><span class="lineno">  634</span>            result = cat_safe(all_cols, sep)</div>
<div class="line"><span class="lineno">  635</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  636</span>            <span class="comment"># no NaNs - can just concatenate</span></div>
<div class="line"><span class="lineno">  637</span>            result = cat_safe(all_cols, sep)</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span>        out: Index | Series</div>
<div class="line"><span class="lineno">  640</span>        <span class="keywordflow">if</span> isinstance(self._orig, ABCIndex):</div>
<div class="line"><span class="lineno">  641</span>            <span class="comment"># add dtype for case that result is all-NA</span></div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>            out = Index(result, dtype=object, name=self._orig.name)</div>
<div class="line"><span class="lineno">  644</span>        <span class="keywordflow">else</span>:  <span class="comment"># Series</span></div>
<div class="line"><span class="lineno">  645</span>            <span class="keywordflow">if</span> is_categorical_dtype(self._orig.dtype):</div>
<div class="line"><span class="lineno">  646</span>                <span class="comment"># We need to infer the new categories.</span></div>
<div class="line"><span class="lineno">  647</span>                dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  648</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  649</span>                dtype = self._orig.dtype</div>
<div class="line"><span class="lineno">  650</span>            res_ser = Series(</div>
<div class="line"><span class="lineno">  651</span>                result, dtype=dtype, index=data.index, name=self._orig.name</div>
<div class="line"><span class="lineno">  652</span>            )</div>
<div class="line"><span class="lineno">  653</span>            out = res_ser.__finalize__(self._orig, method=<span class="stringliteral">&quot;str_cat&quot;</span>)</div>
<div class="line"><span class="lineno">  654</span>        <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  655</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a97970c1d9152e6854ce31c3a4bdddd0a" name="a97970c1d9152e6854ce31c3a4bdddd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97970c1d9152e6854ce31c3a4bdddd0a">&#9670;&#160;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.center </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1639</span>    <span class="keyword">def </span>center(self, width, fillchar=&quot; &quot;):</div>
<div class="line"><span class="lineno"> 1640</span>        <span class="keywordflow">return</span> self.pad(width, side=<span class="stringliteral">&quot;both&quot;</span>, fillchar=fillchar)</div>
<div class="line"><span class="lineno"> 1641</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a381d11aa123d89771d1868eb11601459" name="a381d11aa123d89771d1868eb11601459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381d11aa123d89771d1868eb11601459">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.contains </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>case</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>na</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>regex</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Test if pattern or regex is contained within a string of a Series or Index.

    Return boolean Series or Index based on whether a given pattern or regex is
    contained within a string of a Series or Index.

    Parameters
    ----------
    pat : str
        Character sequence or regular expression.
    case : bool, default True
        If True, case sensitive.
    flags : int, default 0 (no flags)
        Flags to pass through to the re module, e.g. re.IGNORECASE.
    na : scalar, optional
        Fill value for missing values. The default depends on dtype of the
        array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,
        ``pandas.NA`` is used.
    regex : bool, default True
        If True, assumes the pat is a regular expression.

        If False, treats the pat as a literal string.

    Returns
    -------
    Series or Index of boolean values
        A Series or Index of boolean values indicating whether the
        given pattern is contained within the string of each element
        of the Series or Index.

    See Also
    --------
    match : Analogous, but stricter, relying on re.match instead of re.search.
    Series.str.startswith : Test if the start of each string element matches a
        pattern.
    Series.str.endswith : Same as startswith, but tests the end of string.

    Examples
    --------
    Returning a Series of booleans using only a literal pattern.

    &gt;&gt;&gt; s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])
    &gt;&gt;&gt; s1.str.contains('og', regex=False)
    0    False
    1     True
    2    False
    3    False
    4      NaN
    dtype: object

    Returning an Index of booleans using only a literal pattern.

    &gt;&gt;&gt; ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])
    &gt;&gt;&gt; ind.str.contains('23', regex=False)
    Index([False, False, False, True, nan], dtype='object')

    Specifying case sensitivity using `case`.

    &gt;&gt;&gt; s1.str.contains('oG', case=True, regex=True)
    0    False
    1    False
    2    False
    3    False
    4      NaN
    dtype: object

    Specifying `na` to be `False` instead of `NaN` replaces NaN values
    with `False`. If Series or Index does not contain NaN values
    the resultant dtype will be `bool`, otherwise, an `object` dtype.

    &gt;&gt;&gt; s1.str.contains('og', na=False, regex=True)
    0    False
    1     True
    2    False
    3    False
    4    False
    dtype: bool

    Returning 'house' or 'dog' when either expression occurs in a string.

    &gt;&gt;&gt; s1.str.contains('house|dog', regex=True)
    0    False
    1     True
    2     True
    3    False
    4      NaN
    dtype: object

    Ignoring case sensitivity using `flags` with regex.

    &gt;&gt;&gt; import re
    &gt;&gt;&gt; s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)
    0    False
    1    False
    2     True
    3    False
    4      NaN
    dtype: object

    Returning any digit using regular expression.

    &gt;&gt;&gt; s1.str.contains('\\d', regex=True)
    0    False
    1    False
    2    False
    3     True
    4      NaN
    dtype: object

    Ensure `pat` is a not a literal pattern when `regex` is set to True.
    Note in the following example one might expect only `s2[1]` and `s2[3]` to
    return `True`. However, '.0' as a regex matches any character
    followed by a 0.

    &gt;&gt;&gt; s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])
    &gt;&gt;&gt; s2.str.contains('.0', regex=True)
    0     True
    1     True
    2    False
    3     True
    4    False
    dtype: bool</pre> <div class="fragment"><div class="line"><span class="lineno"> 1128</span>    <span class="keyword">def </span>contains(self, pat, case=True, flags=0, na=None, regex=True):</div>
<div class="line"><span class="lineno"> 1129</span>        <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">        Test if pattern or regex is contained within a string of a Series or Index.</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">        Return boolean Series or Index based on whether a given pattern or regex is</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">        contained within a string of a Series or Index.</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">        pat : str</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">            Character sequence or regular expression.</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">        case : bool, default True</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">            If True, case sensitive.</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">        flags : int, default 0 (no flags)</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">            Flags to pass through to the re module, e.g. re.IGNORECASE.</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">        na : scalar, optional</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">            Fill value for missing values. The default depends on dtype of the</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">            ``pandas.NA`` is used.</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">        regex : bool, default True</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">            If True, assumes the pat is a regular expression.</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">            If False, treats the pat as a literal string.</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">        Series or Index of boolean values</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">            A Series or Index of boolean values indicating whether the</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">            given pattern is contained within the string of each element</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">            of the Series or Index.</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">        match : Analogous, but stricter, relying on re.match instead of re.search.</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">        Series.str.startswith : Test if the start of each string element matches a</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">            pattern.</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">        Series.str.endswith : Same as startswith, but tests the end of string.</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">        Returning a Series of booleans using only a literal pattern.</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">        &gt;&gt;&gt; s1 = pd.Series([&#39;Mouse&#39;, &#39;dog&#39;, &#39;house and parrot&#39;, &#39;23&#39;, np.NaN])</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">        &gt;&gt;&gt; s1.str.contains(&#39;og&#39;, regex=False)</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">        0    False</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">        1     True</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">        3    False</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">        4      NaN</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">        Returning an Index of booleans using only a literal pattern.</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">        &gt;&gt;&gt; ind = pd.Index([&#39;Mouse&#39;, &#39;dog&#39;, &#39;house and parrot&#39;, &#39;23.0&#39;, np.NaN])</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">        &gt;&gt;&gt; ind.str.contains(&#39;23&#39;, regex=False)</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">        Index([False, False, False, True, nan], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">        Specifying case sensitivity using `case`.</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">        &gt;&gt;&gt; s1.str.contains(&#39;oG&#39;, case=True, regex=True)</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">        0    False</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">        3    False</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">        4      NaN</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">        Specifying `na` to be `False` instead of `NaN` replaces NaN values</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">        with `False`. If Series or Index does not contain NaN values</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">        the resultant dtype will be `bool`, otherwise, an `object` dtype.</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">        &gt;&gt;&gt; s1.str.contains(&#39;og&#39;, na=False, regex=True)</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">        0    False</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">        1     True</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">        3    False</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">        4    False</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">        dtype: bool</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">        Returning &#39;house&#39; or &#39;dog&#39; when either expression occurs in a string.</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">        &gt;&gt;&gt; s1.str.contains(&#39;house|dog&#39;, regex=True)</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">        0    False</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">        1     True</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">        2     True</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">        3    False</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">        4      NaN</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">        Ignoring case sensitivity using `flags` with regex.</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">        &gt;&gt;&gt; import re</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">        &gt;&gt;&gt; s1.str.contains(&#39;PARROT&#39;, flags=re.IGNORECASE, regex=True)</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">        0    False</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">        2     True</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">        3    False</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">        4      NaN</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">        Returning any digit using regular expression.</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">        &gt;&gt;&gt; s1.str.contains(&#39;\\d&#39;, regex=True)</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">        0    False</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">        3     True</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">        4      NaN</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">        Ensure `pat` is a not a literal pattern when `regex` is set to True.</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">        Note in the following example one might expect only `s2[1]` and `s2[3]` to</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">        return `True`. However, &#39;.0&#39; as a regex matches any character</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">        followed by a 0.</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">        &gt;&gt;&gt; s2 = pd.Series([&#39;40&#39;, &#39;40.0&#39;, &#39;41&#39;, &#39;41.0&#39;, &#39;35&#39;])</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">        &gt;&gt;&gt; s2.str.contains(&#39;.0&#39;, regex=True)</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">        0     True</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">        1     True</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">        3     True</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">        4    False</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">        dtype: bool</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1252</span>        <span class="keywordflow">if</span> regex <span class="keywordflow">and</span> re.compile(pat).groups:</div>
<div class="line"><span class="lineno"> 1253</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1254</span>                <span class="stringliteral">&quot;This pattern is interpreted as a regular expression, and has &quot;</span></div>
<div class="line"><span class="lineno"> 1255</span>                <span class="stringliteral">&quot;match groups. To actually get the groups, use str.extract.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1256</span>                UserWarning,</div>
<div class="line"><span class="lineno"> 1257</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1258</span>            )</div>
<div class="line"><span class="lineno"> 1259</span> </div>
<div class="line"><span class="lineno"> 1260</span>        result = self._data.array._str_contains(pat, case, flags, na, regex)</div>
<div class="line"><span class="lineno"> 1261</span>        <span class="keywordflow">return</span> self._wrap_result(result, fill_value=na, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1262</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af4d9bf6c35ab54f24cdc4cfc38170579" name="af4d9bf6c35ab54f24cdc4cfc38170579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d9bf6c35ab54f24cdc4cfc38170579">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Count occurrences of pattern in each string of the Series/Index.

    This function is used to count the number of times a particular regex
    pattern is repeated in each of the string elements of the
    :class:`~pandas.Series`.

    Parameters
    ----------
    pat : str
        Valid regular expression.
    flags : int, default 0, meaning no flags
        Flags for the `re` module. For a complete list, `see here
        &lt;https://docs.python.org/3/howto/regex.html#compilation-flags&gt;`_.
    **kwargs
        For compatibility with other string methods. Not used.

    Returns
    -------
    Series or Index
        Same type as the calling object containing the integer counts.

    See Also
    --------
    re : Standard library module for regular expressions.
    str.count : Standard library version, without regular expression support.

    Notes
    -----
    Some characters need to be escaped when passing in `pat`.
    eg. ``'$'`` has a special meaning in regex and must be escaped when
    finding this literal character.

    Examples
    --------
    &gt;&gt;&gt; s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])
    &gt;&gt;&gt; s.str.count('a')
    0    0.0
    1    0.0
    2    2.0
    3    2.0
    4    NaN
    5    0.0
    6    1.0
    dtype: float64

    Escape ``'$'`` to find the literal dollar sign.

    &gt;&gt;&gt; s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])
    &gt;&gt;&gt; s.str.count('\\$')
    0    1
    1    0
    2    1
    3    2
    4    2
    5    0
    dtype: int64

    This is also available on Index

    &gt;&gt;&gt; pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')
    Int64Index([0, 0, 2, 1], dtype='int64')</pre> <div class="fragment"><div class="line"><span class="lineno"> 2218</span>    <span class="keyword">def </span>count(self, pat, flags=0):</div>
<div class="line"><span class="lineno"> 2219</span>        <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral">        Count occurrences of pattern in each string of the Series/Index.</span></div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2222</span><span class="stringliteral">        This function is used to count the number of times a particular regex</span></div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral">        pattern is repeated in each of the string elements of the</span></div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral">        :class:`~pandas.Series`.</span></div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">        pat : str</span></div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">            Valid regular expression.</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">        flags : int, default 0, meaning no flags</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral">            Flags for the `re` module. For a complete list, `see here</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">            &lt;https://docs.python.org/3/howto/regex.html#compilation-flags&gt;`_.</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">        **kwargs</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">            For compatibility with other string methods. Not used.</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral">        Series or Index</span></div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">            Same type as the calling object containing the integer counts.</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">        re : Standard library module for regular expressions.</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">        str.count : Standard library version, without regular expression support.</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">        Some characters need to be escaped when passing in `pat`.</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral">        eg. ``&#39;$&#39;`` has a special meaning in regex and must be escaped when</span></div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral">        finding this literal character.</span></div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;A&#39;, &#39;B&#39;, &#39;Aaba&#39;, &#39;Baca&#39;, np.nan, &#39;CABA&#39;, &#39;cat&#39;])</span></div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">        &gt;&gt;&gt; s.str.count(&#39;a&#39;)</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral">        0    0.0</span></div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral">        1    0.0</span></div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">        2    2.0</span></div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral">        3    2.0</span></div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">        4    NaN</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral">        5    0.0</span></div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral">        6    1.0</span></div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral">        dtype: float64</span></div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2265</span><span class="stringliteral">        Escape ``&#39;$&#39;`` to find the literal dollar sign.</span></div>
<div class="line"><span class="lineno"> 2266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2267</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;$&#39;, &#39;B&#39;, &#39;Aab$&#39;, &#39;$$ca&#39;, &#39;C$B$&#39;, &#39;cat&#39;])</span></div>
<div class="line"><span class="lineno"> 2268</span><span class="stringliteral">        &gt;&gt;&gt; s.str.count(&#39;\\$&#39;)</span></div>
<div class="line"><span class="lineno"> 2269</span><span class="stringliteral">        0    1</span></div>
<div class="line"><span class="lineno"> 2270</span><span class="stringliteral">        1    0</span></div>
<div class="line"><span class="lineno"> 2271</span><span class="stringliteral">        2    1</span></div>
<div class="line"><span class="lineno"> 2272</span><span class="stringliteral">        3    2</span></div>
<div class="line"><span class="lineno"> 2273</span><span class="stringliteral">        4    2</span></div>
<div class="line"><span class="lineno"> 2274</span><span class="stringliteral">        5    0</span></div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral">        dtype: int64</span></div>
<div class="line"><span class="lineno"> 2276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2277</span><span class="stringliteral">        This is also available on Index</span></div>
<div class="line"><span class="lineno"> 2278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2279</span><span class="stringliteral">        &gt;&gt;&gt; pd.Index([&#39;A&#39;, &#39;A&#39;, &#39;Aaba&#39;, &#39;cat&#39;]).str.count(&#39;a&#39;)</span></div>
<div class="line"><span class="lineno"> 2280</span><span class="stringliteral">        Int64Index([0, 0, 2, 1], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 2281</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2282</span>        result = self._data.array._str_count(pat, flags)</div>
<div class="line"><span class="lineno"> 2283</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2284</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ca9277ef70d4220757ba5375a5950ec" name="a8ca9277ef70d4220757ba5375a5950ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca9277ef70d4220757ba5375a5950ec">&#9670;&#160;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.decode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;strict&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decode character string in the Series/Index using indicated encoding.

Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in
python3.

Parameters
----------
encoding : str
errors : str, optional

Returns
-------
Series or Index
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1871</span>    <span class="keyword">def </span>decode(self, encoding, errors=&quot;strict&quot;):</div>
<div class="line"><span class="lineno"> 1872</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">        Decode character string in the Series/Index using indicated encoding.</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">        Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">        python3.</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral">        encoding : str</span></div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">        errors : str, optional</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">        Series or Index</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1887</span>        <span class="comment"># TODO: Add a similar _bytes interface.</span></div>
<div class="line"><span class="lineno"> 1888</span>        <span class="keywordflow">if</span> encoding <span class="keywordflow">in</span> _cpython_optimized_decoders:</div>
<div class="line"><span class="lineno"> 1889</span>            <span class="comment"># CPython optimized implementation</span></div>
<div class="line"><span class="lineno"> 1890</span>            f = <span class="keyword">lambda</span> x: x.decode(encoding, errors)</div>
<div class="line"><span class="lineno"> 1891</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1892</span>            decoder = codecs.getdecoder(encoding)</div>
<div class="line"><span class="lineno"> 1893</span>            f = <span class="keyword">lambda</span> x: decoder(x, errors)[0]</div>
<div class="line"><span class="lineno"> 1894</span>        arr = self._data.array</div>
<div class="line"><span class="lineno"> 1895</span>        <span class="comment"># assert isinstance(arr, (StringArray,))</span></div>
<div class="line"><span class="lineno"> 1896</span>        result = arr._str_map(f)</div>
<div class="line"><span class="lineno"> 1897</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1898</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2cce38a4e1543760feb1bc6dbb183438" name="a2cce38a4e1543760feb1bc6dbb183438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cce38a4e1543760feb1bc6dbb183438">&#9670;&#160;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.encode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;strict&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encode character string in the Series/Index using indicated encoding.

Equivalent to :meth:`str.encode`.

Parameters
----------
encoding : str
errors : str, optional

Returns
-------
encoded : Series/Index of objects
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1900</span>    <span class="keyword">def </span>encode(self, encoding, errors=&quot;strict&quot;):</div>
<div class="line"><span class="lineno"> 1901</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">        Encode character string in the Series/Index using indicated encoding.</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">        Equivalent to :meth:`str.encode`.</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">        encoding : str</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">        errors : str, optional</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">        encoded : Series/Index of objects</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1915</span>        result = self._data.array._str_encode(encoding, errors)</div>
<div class="line"><span class="lineno"> 1916</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1917</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a602a20e3b5b1316091b01a924e15eb11" name="a602a20e3b5b1316091b01a924e15eb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602a20e3b5b1316091b01a924e15eb11">&#9670;&#160;</a></span>endswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Series | Index pandas.core.strings.accessor.StringMethods.endswith </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | tuple[str, ...]&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar | None &#160;</td>
          <td class="paramname"><em>na</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the end of each string element matches a pattern.

Equivalent to :meth:`str.endswith`.

Parameters
----------
pat : str or tuple[str, ...]
    Character sequence or tuple of strings. Regular expressions are not
    accepted.
na : object, default NaN
    Object shown if element tested is not a string. The default depends
    on dtype of the array. For object-dtype, ``numpy.nan`` is used.
    For ``StringDtype``, ``pandas.NA`` is used.

Returns
-------
Series or Index of bool
    A Series of booleans indicating whether the given pattern matches
    the end of each string element.

See Also
--------
str.endswith : Python standard library string method.
Series.str.startswith : Same as endswith, but tests the start of string.
Series.str.contains : Tests if string element contains a pattern.

Examples
--------
&gt;&gt;&gt; s = pd.Series(['bat', 'bear', 'caT', np.nan])
&gt;&gt;&gt; s
0     bat
1    bear
2     caT
3     NaN
dtype: object

&gt;&gt;&gt; s.str.endswith('t')
0     True
1    False
2    False
3      NaN
dtype: object

&gt;&gt;&gt; s.str.endswith(('t', 'T'))
0     True
1    False
2     True
3      NaN
dtype: object

Specifying `na` to be `False` instead of `NaN`.

&gt;&gt;&gt; s.str.endswith('t', na=False)
0     True
1    False
2    False
3    False
dtype: bool
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2358</span>    ) -&gt; Series | Index:</div>
<div class="line"><span class="lineno"> 2359</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2360</span><span class="stringliteral">        Test if the end of each string element matches a pattern.</span></div>
<div class="line"><span class="lineno"> 2361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2362</span><span class="stringliteral">        Equivalent to :meth:`str.endswith`.</span></div>
<div class="line"><span class="lineno"> 2363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2364</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2365</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2366</span><span class="stringliteral">        pat : str or tuple[str, ...]</span></div>
<div class="line"><span class="lineno"> 2367</span><span class="stringliteral">            Character sequence or tuple of strings. Regular expressions are not</span></div>
<div class="line"><span class="lineno"> 2368</span><span class="stringliteral">            accepted.</span></div>
<div class="line"><span class="lineno"> 2369</span><span class="stringliteral">        na : object, default NaN</span></div>
<div class="line"><span class="lineno"> 2370</span><span class="stringliteral">            Object shown if element tested is not a string. The default depends</span></div>
<div class="line"><span class="lineno"> 2371</span><span class="stringliteral">            on dtype of the array. For object-dtype, ``numpy.nan`` is used.</span></div>
<div class="line"><span class="lineno"> 2372</span><span class="stringliteral">            For ``StringDtype``, ``pandas.NA`` is used.</span></div>
<div class="line"><span class="lineno"> 2373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2374</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2375</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2376</span><span class="stringliteral">        Series or Index of bool</span></div>
<div class="line"><span class="lineno"> 2377</span><span class="stringliteral">            A Series of booleans indicating whether the given pattern matches</span></div>
<div class="line"><span class="lineno"> 2378</span><span class="stringliteral">            the end of each string element.</span></div>
<div class="line"><span class="lineno"> 2379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2380</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2381</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2382</span><span class="stringliteral">        str.endswith : Python standard library string method.</span></div>
<div class="line"><span class="lineno"> 2383</span><span class="stringliteral">        Series.str.startswith : Same as endswith, but tests the start of string.</span></div>
<div class="line"><span class="lineno"> 2384</span><span class="stringliteral">        Series.str.contains : Tests if string element contains a pattern.</span></div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2387</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2388</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;bat&#39;, &#39;bear&#39;, &#39;caT&#39;, np.nan])</span></div>
<div class="line"><span class="lineno"> 2389</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 2390</span><span class="stringliteral">        0     bat</span></div>
<div class="line"><span class="lineno"> 2391</span><span class="stringliteral">        1    bear</span></div>
<div class="line"><span class="lineno"> 2392</span><span class="stringliteral">        2     caT</span></div>
<div class="line"><span class="lineno"> 2393</span><span class="stringliteral">        3     NaN</span></div>
<div class="line"><span class="lineno"> 2394</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral">        &gt;&gt;&gt; s.str.endswith(&#39;t&#39;)</span></div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral">        0     True</span></div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">        3      NaN</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">        &gt;&gt;&gt; s.str.endswith((&#39;t&#39;, &#39;T&#39;))</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">        0     True</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">        2     True</span></div>
<div class="line"><span class="lineno"> 2407</span><span class="stringliteral">        3      NaN</span></div>
<div class="line"><span class="lineno"> 2408</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2410</span><span class="stringliteral">        Specifying `na` to be `False` instead of `NaN`.</span></div>
<div class="line"><span class="lineno"> 2411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral">        &gt;&gt;&gt; s.str.endswith(&#39;t&#39;, na=False)</span></div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral">        0     True</span></div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral">        3    False</span></div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral">        dtype: bool</span></div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2419</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(pat, (str, tuple)):</div>
<div class="line"><span class="lineno"> 2420</span>            msg = f<span class="stringliteral">&quot;expected a string or tuple, not {type(pat).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 2421</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 2422</span>        result = self._data.array._str_endswith(pat, na=na)</div>
<div class="line"><span class="lineno"> 2423</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2424</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b054352c9f15f21370db49fc60ee5fd" name="a8b054352c9f15f21370db49fc60ee5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b054352c9f15f21370db49fc60ee5fd">&#9670;&#160;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame | Series | Index pandas.core.strings.accessor.StringMethods.extract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>expand</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Extract capture groups in the regex `pat` as columns in a DataFrame.

    For each subject string in the Series, extract groups from the
    first match of regular expression `pat`.

    Parameters
    ----------
    pat : str
        Regular expression pattern with capturing groups.
    flags : int, default 0 (no flags)
        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that
        modify regular expression matching for things like case,
        spaces, etc. For more details, see :mod:`re`.
    expand : bool, default True
        If True, return DataFrame with one column per capture group.
        If False, return a Series/Index if there is one capture group
        or DataFrame if there are multiple capture groups.

    Returns
    -------
    DataFrame or Series or Index
        A DataFrame with one row for each subject string, and one
        column for each group. Any capture group names in regular
        expression pat will be used for column names; otherwise
        capture group numbers will be used. The dtype of each result
        column is always object, even when no match is found. If
        ``expand=False`` and pat has only one capture group, then
        return a Series (if subject is a Series) or Index (if subject
        is an Index).

    See Also
    --------
    extractall : Returns all matches (not just the first match).

    Examples
    --------
    A pattern with two groups will return a DataFrame with two columns.
    Non-matches will be NaN.

    &gt;&gt;&gt; s = pd.Series(['a1', 'b2', 'c3'])
    &gt;&gt;&gt; s.str.extract(r'([ab])(\d)')
        0    1
    0    a    1
    1    b    2
    2  NaN  NaN

    A pattern may contain optional groups.

    &gt;&gt;&gt; s.str.extract(r'([ab])?(\d)')
        0  1
    0    a  1
    1    b  2
    2  NaN  3

    Named groups will become column names in the result.

    &gt;&gt;&gt; s.str.extract(r'(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)')
    letter digit
    0      a     1
    1      b     2
    2    NaN   NaN

    A pattern with one group will return a DataFrame with one column
    if expand=True.

    &gt;&gt;&gt; s.str.extract(r'[ab](\d)', expand=True)
        0
    0    1
    1    2
    2  NaN

    A pattern with one group will return a Series if expand=False.

    &gt;&gt;&gt; s.str.extract(r'[ab](\d)', expand=False)
    0      1
    1      2
    2    NaN
    dtype: object</pre> <div class="fragment"><div class="line"><span class="lineno"> 2521</span>    ) -&gt; DataFrame | Series | Index:</div>
<div class="line"><span class="lineno"> 2522</span>        <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral">        Extract capture groups in the regex `pat` as columns in a DataFrame.</span></div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral">        For each subject string in the Series, extract groups from the</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral">        first match of regular expression `pat`.</span></div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">        pat : str</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral">            Regular expression pattern with capturing groups.</span></div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">        flags : int, default 0 (no flags)</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">            Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">            modify regular expression matching for things like case,</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">            spaces, etc. For more details, see :mod:`re`.</span></div>
<div class="line"><span class="lineno"> 2536</span><span class="stringliteral">        expand : bool, default True</span></div>
<div class="line"><span class="lineno"> 2537</span><span class="stringliteral">            If True, return DataFrame with one column per capture group.</span></div>
<div class="line"><span class="lineno"> 2538</span><span class="stringliteral">            If False, return a Series/Index if there is one capture group</span></div>
<div class="line"><span class="lineno"> 2539</span><span class="stringliteral">            or DataFrame if there are multiple capture groups.</span></div>
<div class="line"><span class="lineno"> 2540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral">        DataFrame or Series or Index</span></div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">            A DataFrame with one row for each subject string, and one</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral">            column for each group. Any capture group names in regular</span></div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral">            expression pat will be used for column names; otherwise</span></div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral">            capture group numbers will be used. The dtype of each result</span></div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">            column is always object, even when no match is found. If</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral">            ``expand=False`` and pat has only one capture group, then</span></div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral">            return a Series (if subject is a Series) or Index (if subject</span></div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral">            is an Index).</span></div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2555</span><span class="stringliteral">        extractall : Returns all matches (not just the first match).</span></div>
<div class="line"><span class="lineno"> 2556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2557</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2558</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral">        A pattern with two groups will return a DataFrame with two columns.</span></div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral">        Non-matches will be NaN.</span></div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;a1&#39;, &#39;b2&#39;, &#39;c3&#39;])</span></div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extract(r&#39;([ab])(\d)&#39;)</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">            0    1</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral">        0    a    1</span></div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">        1    b    2</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">        2  NaN  NaN</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral">        A pattern may contain optional groups.</span></div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extract(r&#39;([ab])?(\d)&#39;)</span></div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral">            0  1</span></div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">        0    a  1</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral">        1    b  2</span></div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral">        2  NaN  3</span></div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2577</span><span class="stringliteral">        Named groups will become column names in the result.</span></div>
<div class="line"><span class="lineno"> 2578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2579</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extract(r&#39;(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)&#39;)</span></div>
<div class="line"><span class="lineno"> 2580</span><span class="stringliteral">        letter digit</span></div>
<div class="line"><span class="lineno"> 2581</span><span class="stringliteral">        0      a     1</span></div>
<div class="line"><span class="lineno"> 2582</span><span class="stringliteral">        1      b     2</span></div>
<div class="line"><span class="lineno"> 2583</span><span class="stringliteral">        2    NaN   NaN</span></div>
<div class="line"><span class="lineno"> 2584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral">        A pattern with one group will return a DataFrame with one column</span></div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral">        if expand=True.</span></div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extract(r&#39;[ab](\d)&#39;, expand=True)</span></div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral">            0</span></div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">        0    1</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral">        1    2</span></div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral">        2  NaN</span></div>
<div class="line"><span class="lineno"> 2593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2594</span><span class="stringliteral">        A pattern with one group will return a Series if expand=False.</span></div>
<div class="line"><span class="lineno"> 2595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2596</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extract(r&#39;[ab](\d)&#39;, expand=False)</span></div>
<div class="line"><span class="lineno"> 2597</span><span class="stringliteral">        0      1</span></div>
<div class="line"><span class="lineno"> 2598</span><span class="stringliteral">        1      2</span></div>
<div class="line"><span class="lineno"> 2599</span><span class="stringliteral">        2    NaN</span></div>
<div class="line"><span class="lineno"> 2600</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2601</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2602</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</div>
<div class="line"><span class="lineno"> 2603</span> </div>
<div class="line"><span class="lineno"> 2604</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(expand, bool):</div>
<div class="line"><span class="lineno"> 2605</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;expand must be True or False&quot;</span>)</div>
<div class="line"><span class="lineno"> 2606</span> </div>
<div class="line"><span class="lineno"> 2607</span>        regex = re.compile(pat, flags=flags)</div>
<div class="line"><span class="lineno"> 2608</span>        <span class="keywordflow">if</span> regex.groups == 0:</div>
<div class="line"><span class="lineno"> 2609</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;pattern contains no capture groups&quot;</span>)</div>
<div class="line"><span class="lineno"> 2610</span> </div>
<div class="line"><span class="lineno"> 2611</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> expand <span class="keywordflow">and</span> regex.groups &gt; 1 <span class="keywordflow">and</span> isinstance(self._data, ABCIndex):</div>
<div class="line"><span class="lineno"> 2612</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;only one regex group is supported with Index&quot;</span>)</div>
<div class="line"><span class="lineno"> 2613</span> </div>
<div class="line"><span class="lineno"> 2614</span>        obj = self._data</div>
<div class="line"><span class="lineno"> 2615</span>        result_dtype = _result_dtype(obj)</div>
<div class="line"><span class="lineno"> 2616</span> </div>
<div class="line"><span class="lineno"> 2617</span>        returns_df = regex.groups &gt; 1 <span class="keywordflow">or</span> expand</div>
<div class="line"><span class="lineno"> 2618</span> </div>
<div class="line"><span class="lineno"> 2619</span>        <span class="keywordflow">if</span> returns_df:</div>
<div class="line"><span class="lineno"> 2620</span>            name = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2621</span>            columns = _get_group_names(regex)</div>
<div class="line"><span class="lineno"> 2622</span> </div>
<div class="line"><span class="lineno"> 2623</span>            <span class="keywordflow">if</span> obj.array.size == 0:</div>
<div class="line"><span class="lineno"> 2624</span>                result = DataFrame(columns=columns, dtype=result_dtype)</div>
<div class="line"><span class="lineno"> 2625</span> </div>
<div class="line"><span class="lineno"> 2626</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2627</span>                result_list = self._data.array._str_extract(</div>
<div class="line"><span class="lineno"> 2628</span>                    pat, flags=flags, expand=returns_df</div>
<div class="line"><span class="lineno"> 2629</span>                )</div>
<div class="line"><span class="lineno"> 2630</span> </div>
<div class="line"><span class="lineno"> 2631</span>                result_index: Index | <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2632</span>                <span class="keywordflow">if</span> isinstance(obj, ABCSeries):</div>
<div class="line"><span class="lineno"> 2633</span>                    result_index = obj.index</div>
<div class="line"><span class="lineno"> 2634</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2635</span>                    result_index = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2636</span> </div>
<div class="line"><span class="lineno"> 2637</span>                result = DataFrame(</div>
<div class="line"><span class="lineno"> 2638</span>                    result_list, columns=columns, index=result_index, dtype=result_dtype</div>
<div class="line"><span class="lineno"> 2639</span>                )</div>
<div class="line"><span class="lineno"> 2640</span> </div>
<div class="line"><span class="lineno"> 2641</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2642</span>            name = _get_single_group_name(regex)</div>
<div class="line"><span class="lineno"> 2643</span>            result = self._data.array._str_extract(pat, flags=flags, expand=returns_df)</div>
<div class="line"><span class="lineno"> 2644</span>        <span class="keywordflow">return</span> self._wrap_result(result, name=name)</div>
<div class="line"><span class="lineno"> 2645</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac96f48e3cd0cf95d769ace18e6c2319a" name="ac96f48e3cd0cf95d769ace18e6c2319a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96f48e3cd0cf95d769ace18e6c2319a">&#9670;&#160;</a></span>extractall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.extractall </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Extract capture groups in the regex `pat` as columns in DataFrame.

    For each subject string in the Series, extract groups from all
    matches of regular expression pat. When each subject string in the
    Series has exactly one match, extractall(pat).xs(0, level='match')
    is the same as extract(pat).

    Parameters
    ----------
    pat : str
        Regular expression pattern with capturing groups.
    flags : int, default 0 (no flags)
        A ``re`` module flag, for example ``re.IGNORECASE``. These allow
        to modify regular expression matching for things like case, spaces,
        etc. Multiple flags can be combined with the bitwise OR operator,
        for example ``re.IGNORECASE | re.MULTILINE``.

    Returns
    -------
    DataFrame
        A ``DataFrame`` with one row for each match, and one column for each
        group. Its rows have a ``MultiIndex`` with first levels that come from
        the subject ``Series``. The last level is named 'match' and indexes the
        matches in each item of the ``Series``. Any capture group names in
        regular expression pat will be used for column names; otherwise capture
        group numbers will be used.

    See Also
    --------
    extract : Returns first match only (not all matches).

    Examples
    --------
    A pattern with one group will return a DataFrame with one column.
    Indices with no matches will not appear in the result.

    &gt;&gt;&gt; s = pd.Series(["a1a2", "b1", "c1"], index=["A", "B", "C"])
    &gt;&gt;&gt; s.str.extractall(r"[ab](\d)")
            0
    match
    A 0      1
      1      2
    B 0      1

    Capture group names are used for column names of the result.

    &gt;&gt;&gt; s.str.extractall(r"[ab](?P&lt;digit&gt;\d)")
            digit
    match
    A 0         1
      1         2
    B 0         1

    A pattern with two groups will return a DataFrame with two columns.

    &gt;&gt;&gt; s.str.extractall(r"(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)")
            letter digit
    match
    A 0          a     1
      1          a     2
    B 0          b     1

    Optional groups that do not match are NaN in the result.

    &gt;&gt;&gt; s.str.extractall(r"(?P&lt;letter&gt;[ab])?(?P&lt;digit&gt;\d)")
            letter digit
    match
    A 0          a     1
      1          a     2
    B 0          b     1
    C 0        NaN     1</pre> <div class="fragment"><div class="line"><span class="lineno"> 2647</span>    <span class="keyword">def </span>extractall(self, pat, flags=0):</div>
<div class="line"><span class="lineno"> 2648</span>        <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2649</span><span class="stringliteral">        Extract capture groups in the regex `pat` as columns in DataFrame.</span></div>
<div class="line"><span class="lineno"> 2650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2651</span><span class="stringliteral">        For each subject string in the Series, extract groups from all</span></div>
<div class="line"><span class="lineno"> 2652</span><span class="stringliteral">        matches of regular expression pat. When each subject string in the</span></div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral">        Series has exactly one match, extractall(pat).xs(0, level=&#39;match&#39;)</span></div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral">        is the same as extract(pat).</span></div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2658</span><span class="stringliteral">        pat : str</span></div>
<div class="line"><span class="lineno"> 2659</span><span class="stringliteral">            Regular expression pattern with capturing groups.</span></div>
<div class="line"><span class="lineno"> 2660</span><span class="stringliteral">        flags : int, default 0 (no flags)</span></div>
<div class="line"><span class="lineno"> 2661</span><span class="stringliteral">            A ``re`` module flag, for example ``re.IGNORECASE``. These allow</span></div>
<div class="line"><span class="lineno"> 2662</span><span class="stringliteral">            to modify regular expression matching for things like case, spaces,</span></div>
<div class="line"><span class="lineno"> 2663</span><span class="stringliteral">            etc. Multiple flags can be combined with the bitwise OR operator,</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="stringliteral">            for example ``re.IGNORECASE | re.MULTILINE``.</span></div>
<div class="line"><span class="lineno"> 2665</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2666</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2667</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2668</span><span class="stringliteral">        DataFrame</span></div>
<div class="line"><span class="lineno"> 2669</span><span class="stringliteral">            A ``DataFrame`` with one row for each match, and one column for each</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral">            group. Its rows have a ``MultiIndex`` with first levels that come from</span></div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral">            the subject ``Series``. The last level is named &#39;match&#39; and indexes the</span></div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">            matches in each item of the ``Series``. Any capture group names in</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">            regular expression pat will be used for column names; otherwise capture</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">            group numbers will be used.</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral">        extract : Returns first match only (not all matches).</span></div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral">        A pattern with one group will return a DataFrame with one column.</span></div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral">        Indices with no matches will not appear in the result.</span></div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&quot;a1a2&quot;, &quot;b1&quot;, &quot;c1&quot;], index=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span></div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extractall(r&quot;[ab](\d)&quot;)</span></div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral">                0</span></div>
<div class="line"><span class="lineno"> 2688</span><span class="stringliteral">        match</span></div>
<div class="line"><span class="lineno"> 2689</span><span class="stringliteral">        A 0      1</span></div>
<div class="line"><span class="lineno"> 2690</span><span class="stringliteral">          1      2</span></div>
<div class="line"><span class="lineno"> 2691</span><span class="stringliteral">        B 0      1</span></div>
<div class="line"><span class="lineno"> 2692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2693</span><span class="stringliteral">        Capture group names are used for column names of the result.</span></div>
<div class="line"><span class="lineno"> 2694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2695</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extractall(r&quot;[ab](?P&lt;digit&gt;\d)&quot;)</span></div>
<div class="line"><span class="lineno"> 2696</span><span class="stringliteral">                digit</span></div>
<div class="line"><span class="lineno"> 2697</span><span class="stringliteral">        match</span></div>
<div class="line"><span class="lineno"> 2698</span><span class="stringliteral">        A 0         1</span></div>
<div class="line"><span class="lineno"> 2699</span><span class="stringliteral">          1         2</span></div>
<div class="line"><span class="lineno"> 2700</span><span class="stringliteral">        B 0         1</span></div>
<div class="line"><span class="lineno"> 2701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2702</span><span class="stringliteral">        A pattern with two groups will return a DataFrame with two columns.</span></div>
<div class="line"><span class="lineno"> 2703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2704</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extractall(r&quot;(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)&quot;)</span></div>
<div class="line"><span class="lineno"> 2705</span><span class="stringliteral">                letter digit</span></div>
<div class="line"><span class="lineno"> 2706</span><span class="stringliteral">        match</span></div>
<div class="line"><span class="lineno"> 2707</span><span class="stringliteral">        A 0          a     1</span></div>
<div class="line"><span class="lineno"> 2708</span><span class="stringliteral">          1          a     2</span></div>
<div class="line"><span class="lineno"> 2709</span><span class="stringliteral">        B 0          b     1</span></div>
<div class="line"><span class="lineno"> 2710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2711</span><span class="stringliteral">        Optional groups that do not match are NaN in the result.</span></div>
<div class="line"><span class="lineno"> 2712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2713</span><span class="stringliteral">        &gt;&gt;&gt; s.str.extractall(r&quot;(?P&lt;letter&gt;[ab])?(?P&lt;digit&gt;\d)&quot;)</span></div>
<div class="line"><span class="lineno"> 2714</span><span class="stringliteral">                letter digit</span></div>
<div class="line"><span class="lineno"> 2715</span><span class="stringliteral">        match</span></div>
<div class="line"><span class="lineno"> 2716</span><span class="stringliteral">        A 0          a     1</span></div>
<div class="line"><span class="lineno"> 2717</span><span class="stringliteral">          1          a     2</span></div>
<div class="line"><span class="lineno"> 2718</span><span class="stringliteral">        B 0          b     1</span></div>
<div class="line"><span class="lineno"> 2719</span><span class="stringliteral">        C 0        NaN     1</span></div>
<div class="line"><span class="lineno"> 2720</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2721</span>        <span class="comment"># TODO: dispatch</span></div>
<div class="line"><span class="lineno"> 2722</span>        <span class="keywordflow">return</span> str_extractall(self._orig, pat, flags)</div>
<div class="line"><span class="lineno"> 2723</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa701ec5e10972d7a8bbbd5d3a29b12d7" name="aa701ec5e10972d7a8bbbd5d3a29b12d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa701ec5e10972d7a8bbbd5d3a29b12d7">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.find </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2760</span>    <span class="keyword">def </span>find(self, sub, start=0, end=None):</div>
<div class="line"><span class="lineno"> 2761</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(sub, str):</div>
<div class="line"><span class="lineno"> 2762</span>            msg = f<span class="stringliteral">&quot;expected a string object, not {type(sub).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 2763</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 2764</span> </div>
<div class="line"><span class="lineno"> 2765</span>        result = self._data.array._str_find(sub, start, end)</div>
<div class="line"><span class="lineno"> 2766</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2767</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a55cbcc55abae33524d2434ff076d3bc3" name="a55cbcc55abae33524d2434ff076d3bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cbcc55abae33524d2434ff076d3bc3">&#9670;&#160;</a></span>findall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.findall </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all occurrences of pattern or regular expression in the Series/Index.

Equivalent to applying :func:`re.findall` to all the elements in the
Series/Index.

Parameters
----------
pat : str
    Pattern or regular expression.
flags : int, default 0
    Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which
    means no flags).

Returns
-------
Series/Index of lists of strings
    All non-overlapping matches of pattern or regular expression in each
    string of this Series/Index.

See Also
--------
count : Count occurrences of pattern or regular expression in each string
    of the Series/Index.
extractall : For each string in the Series, extract groups from all matches
    of regular expression and return a DataFrame with one row for each
    match and one column for each group.
re.findall : The equivalent ``re`` function to all non-overlapping matches
    of pattern or regular expression in string, as a list of strings.

Examples
--------
&gt;&gt;&gt; s = pd.Series(['Lion', 'Monkey', 'Rabbit'])

The search for the pattern 'Monkey' returns one match:

&gt;&gt;&gt; s.str.findall('Monkey')
0          []
1    [Monkey]
2          []
dtype: object

On the other hand, the search for the pattern 'MONKEY' doesn't return any
match:

&gt;&gt;&gt; s.str.findall('MONKEY')
0    []
1    []
2    []
dtype: object

Flags can be added to the pattern or regular expression. For instance,
to find the pattern 'MONKEY' ignoring the case:

&gt;&gt;&gt; import re
&gt;&gt;&gt; s.str.findall('MONKEY', flags=re.IGNORECASE)
0          []
1    [Monkey]
2          []
dtype: object

When the pattern matches more than one string in the Series, all matches
are returned:

&gt;&gt;&gt; s.str.findall('on')
0    [on]
1    [on]
2      []
dtype: object

Regular expressions are supported too. For instance, the search for all the
strings ending with the word 'on' is shown next:

&gt;&gt;&gt; s.str.findall('on$')
0    [on]
1      []
2      []
dtype: object

If the pattern is found more than once in the same string, then a list of
multiple strings is returned:

&gt;&gt;&gt; s.str.findall('b')
0        []
1        []
2    [b, b]
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2426</span>    <span class="keyword">def </span>findall(self, pat, flags=0):</div>
<div class="line"><span class="lineno"> 2427</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2428</span><span class="stringliteral">        Find all occurrences of pattern or regular expression in the Series/Index.</span></div>
<div class="line"><span class="lineno"> 2429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral">        Equivalent to applying :func:`re.findall` to all the elements in the</span></div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral">        Series/Index.</span></div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">        pat : str</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">            Pattern or regular expression.</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">        flags : int, default 0</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">            Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">            means no flags).</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">        Series/Index of lists of strings</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral">            All non-overlapping matches of pattern or regular expression in each</span></div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">            string of this Series/Index.</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">        count : Count occurrences of pattern or regular expression in each string</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">            of the Series/Index.</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral">        extractall : For each string in the Series, extract groups from all matches</span></div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">            of regular expression and return a DataFrame with one row for each</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">            match and one column for each group.</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">        re.findall : The equivalent ``re`` function to all non-overlapping matches</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">            of pattern or regular expression in string, as a list of strings.</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;Lion&#39;, &#39;Monkey&#39;, &#39;Rabbit&#39;])</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">        The search for the pattern &#39;Monkey&#39; returns one match:</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral">        &gt;&gt;&gt; s.str.findall(&#39;Monkey&#39;)</span></div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">        0          []</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">        1    [Monkey]</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral">        2          []</span></div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">        On the other hand, the search for the pattern &#39;MONKEY&#39; doesn&#39;t return any</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral">        match:</span></div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral">        &gt;&gt;&gt; s.str.findall(&#39;MONKEY&#39;)</span></div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">        0    []</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral">        1    []</span></div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">        2    []</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">        Flags can be added to the pattern or regular expression. For instance,</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">        to find the pattern &#39;MONKEY&#39; ignoring the case:</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">        &gt;&gt;&gt; import re</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">        &gt;&gt;&gt; s.str.findall(&#39;MONKEY&#39;, flags=re.IGNORECASE)</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">        0          []</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">        1    [Monkey]</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral">        2          []</span></div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">        When the pattern matches more than one string in the Series, all matches</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">        are returned:</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">        &gt;&gt;&gt; s.str.findall(&#39;on&#39;)</span></div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral">        0    [on]</span></div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">        1    [on]</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral">        2      []</span></div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral">        Regular expressions are supported too. For instance, the search for all the</span></div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral">        strings ending with the word &#39;on&#39; is shown next:</span></div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral">        &gt;&gt;&gt; s.str.findall(&#39;on$&#39;)</span></div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral">        0    [on]</span></div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">        1      []</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">        2      []</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">        If the pattern is found more than once in the same string, then a list of</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral">        multiple strings is returned:</span></div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral">        &gt;&gt;&gt; s.str.findall(&#39;b&#39;)</span></div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral">        0        []</span></div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">        1        []</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">        2    [b, b]</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2515</span>        result = self._data.array._str_findall(pat, flags)</div>
<div class="line"><span class="lineno"> 2516</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2517</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aafeca91b8723b1c8c50393ffb9f7c963" name="aafeca91b8723b1c8c50393ffb9f7c963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafeca91b8723b1c8c50393ffb9f7c963">&#9670;&#160;</a></span>fullmatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.fullmatch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>case</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>na</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine if each string entirely matches a regular expression.

.. versionadded:: 1.1.0

Parameters
----------
pat : str
    Character sequence or regular expression.
case : bool, default True
    If True, case sensitive.
flags : int, default 0 (no flags)
    Regex module flags, e.g. re.IGNORECASE.
na : scalar, optional
    Fill value for missing values. The default depends on dtype of the
    array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,
    ``pandas.NA`` is used.

Returns
-------
Series/Index/array of boolean values

See Also
--------
match : Similar, but also returns `True` when only a *prefix* of the string
    matches the regular expression.
extract : Extract matched groups.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1296</span>    <span class="keyword">def </span>fullmatch(self, pat, case=True, flags=0, na=None):</div>
<div class="line"><span class="lineno"> 1297</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">        Determine if each string entirely matches a regular expression.</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">        .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">        pat : str</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">            Character sequence or regular expression.</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">        case : bool, default True</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">            If True, case sensitive.</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">        flags : int, default 0 (no flags)</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">            Regex module flags, e.g. re.IGNORECASE.</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">        na : scalar, optional</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">            Fill value for missing values. The default depends on dtype of the</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral">            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,</span></div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">            ``pandas.NA`` is used.</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">        Series/Index/array of boolean values</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">        match : Similar, but also returns `True` when only a *prefix* of the string</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">            matches the regular expression.</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">        extract : Extract matched groups.</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1325</span>        result = self._data.array._str_fullmatch(pat, case=case, flags=flags, na=na)</div>
<div class="line"><span class="lineno"> 1326</span>        <span class="keywordflow">return</span> self._wrap_result(result, fill_value=na, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1327</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af5ca88d35cc388416bb5949389dc1dee" name="af5ca88d35cc388416bb5949389dc1dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ca88d35cc388416bb5949389dc1dee">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.get </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract element from each component at specified position or with specified key.

Extract element from lists, tuples, dict, or strings in each element in the
Series/Index.

Parameters
----------
i : int or hashable dict label
    Position or key of element to extract.

Returns
-------
Series or Index

Examples
--------
&gt;&gt;&gt; s = pd.Series(["String",
...               (1, 2, 3),
...               ["a", "b", "c"],
...               123,
...               -456,
...               {1: "Hello", "2": "World"}])
&gt;&gt;&gt; s
0                        String
1                     (1, 2, 3)
2                     [a, b, c]
3                           123
4                          -456
5    {1: 'Hello', '2': 'World'}
dtype: object

&gt;&gt;&gt; s.str.get(1)
0        t
1        2
2        b
3      NaN
4      NaN
5    Hello
dtype: object

&gt;&gt;&gt; s.str.get(-1)
0      g
1      3
2      c
3    NaN
4    NaN
5    None
dtype: object

Return element with given key

&gt;&gt;&gt; s = pd.Series([{"name": "Hello", "value": "World"},
...               {"name": "Goodbye", "value": "Planet"}])
&gt;&gt;&gt; s.str.get('name')
0      Hello
1    Goodbye
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno">  998</span>    <span class="keyword">def </span>get(self, i):</div>
<div class="line"><span class="lineno">  999</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        Extract element from each component at specified position or with specified key.</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">        Extract element from lists, tuples, dict, or strings in each element in the</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">        Series/Index.</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">        i : int or hashable dict label</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">            Position or key of element to extract.</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">        Series or Index</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&quot;String&quot;,</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        ...               (1, 2, 3),</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">        ...               [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">        ...               123,</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">        ...               -456,</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">        ...               {1: &quot;Hello&quot;, &quot;2&quot;: &quot;World&quot;}])</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">        0                        String</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">        1                     (1, 2, 3)</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">        2                     [a, b, c]</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">        3                           123</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">        4                          -456</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">        5    {1: &#39;Hello&#39;, &#39;2&#39;: &#39;World&#39;}</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">        &gt;&gt;&gt; s.str.get(1)</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">        0        t</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">        1        2</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">        2        b</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">        3      NaN</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">        4      NaN</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">        5    Hello</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">        &gt;&gt;&gt; s.str.get(-1)</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">        0      g</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        1      3</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">        2      c</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">        3    NaN</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">        4    NaN</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        5    None</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">        Return element with given key</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([{&quot;name&quot;: &quot;Hello&quot;, &quot;value&quot;: &quot;World&quot;},</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">        ...               {&quot;name&quot;: &quot;Goodbye&quot;, &quot;value&quot;: &quot;Planet&quot;}])</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">        &gt;&gt;&gt; s.str.get(&#39;name&#39;)</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">        0      Hello</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">        1    Goodbye</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1058</span>        result = self._data.array._str_get(i)</div>
<div class="line"><span class="lineno"> 1059</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1060</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9a346122f954f97a34a52e10ae2b00c" name="ad9a346122f954f97a34a52e10ae2b00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a346122f954f97a34a52e10ae2b00c">&#9670;&#160;</a></span>get_dummies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.get_dummies </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;|&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return DataFrame of dummy/indicator variables for Series.

Each string in Series is split by sep and returned as a DataFrame
of dummy/indicator variables.

Parameters
----------
sep : str, default "|"
    String to split on.

Returns
-------
DataFrame
    Dummy variables corresponding to values of the Series.

See Also
--------
get_dummies : Convert categorical variable into dummy/indicator
    variables.

Examples
--------
&gt;&gt;&gt; pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()
   a  b  c
0  1  1  0
1  1  0  0
2  1  0  1

&gt;&gt;&gt; pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()
   a  b  c
0  1  1  0
1  0  0  0
2  1  0  1
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2149</span>    <span class="keyword">def </span>get_dummies(self, sep=&quot;|&quot;):</div>
<div class="line"><span class="lineno"> 2150</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2151</span><span class="stringliteral">        Return DataFrame of dummy/indicator variables for Series.</span></div>
<div class="line"><span class="lineno"> 2152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2153</span><span class="stringliteral">        Each string in Series is split by sep and returned as a DataFrame</span></div>
<div class="line"><span class="lineno"> 2154</span><span class="stringliteral">        of dummy/indicator variables.</span></div>
<div class="line"><span class="lineno"> 2155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2156</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2157</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2158</span><span class="stringliteral">        sep : str, default &quot;|&quot;</span></div>
<div class="line"><span class="lineno"> 2159</span><span class="stringliteral">            String to split on.</span></div>
<div class="line"><span class="lineno"> 2160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral">        DataFrame</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">            Dummy variables corresponding to values of the Series.</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">        get_dummies : Convert categorical variable into dummy/indicator</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">            variables.</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral">        &gt;&gt;&gt; pd.Series([&#39;a|b&#39;, &#39;a&#39;, &#39;a|c&#39;]).str.get_dummies()</span></div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">           a  b  c</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">        0  1  1  0</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">        1  1  0  0</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">        2  1  0  1</span></div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">        &gt;&gt;&gt; pd.Series([&#39;a|b&#39;, np.nan, &#39;a|c&#39;]).str.get_dummies()</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">           a  b  c</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral">        0  1  1  0</span></div>
<div class="line"><span class="lineno"> 2182</span><span class="stringliteral">        1  0  0  0</span></div>
<div class="line"><span class="lineno"> 2183</span><span class="stringliteral">        2  1  0  1</span></div>
<div class="line"><span class="lineno"> 2184</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2185</span>        <span class="comment"># we need to cast to Series of strings as only that has all</span></div>
<div class="line"><span class="lineno"> 2186</span>        <span class="comment"># methods available for making the dummies...</span></div>
<div class="line"><span class="lineno"> 2187</span>        result, name = self._data.array._str_get_dummies(sep)</div>
<div class="line"><span class="lineno"> 2188</span>        <span class="keywordflow">return</span> self._wrap_result(</div>
<div class="line"><span class="lineno"> 2189</span>            result,</div>
<div class="line"><span class="lineno"> 2190</span>            name=name,</div>
<div class="line"><span class="lineno"> 2191</span>            expand=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 2192</span>            returns_string=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 2193</span>        )</div>
<div class="line"><span class="lineno"> 2194</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c25d97e50cb371ee35829597ce48b12" name="a5c25d97e50cb371ee35829597ce48b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c25d97e50cb371ee35829597ce48b12">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2844</span>    <span class="keyword">def </span>index(self, sub, start=0, end=None):</div>
<div class="line"><span class="lineno"> 2845</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(sub, str):</div>
<div class="line"><span class="lineno"> 2846</span>            msg = f<span class="stringliteral">&quot;expected a string object, not {type(sub).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 2847</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 2848</span> </div>
<div class="line"><span class="lineno"> 2849</span>        result = self._data.array._str_index(sub, start=start, end=end)</div>
<div class="line"><span class="lineno"> 2850</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2851</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a44967ff44c9a6aea41f279d961516137" name="a44967ff44c9a6aea41f279d961516137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44967ff44c9a6aea41f279d961516137">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Join lists contained as elements in the Series/Index with passed delimiter.

If the elements of a Series are lists themselves, join the content of these
lists using the delimiter passed to the function.
This function is an equivalent to :meth:`str.join`.

Parameters
----------
sep : str
    Delimiter to use between list entries.

Returns
-------
Series/Index: object
    The list entries concatenated by intervening occurrences of the
    delimiter.

Raises
------
AttributeError
    If the supplied Series contains neither strings nor lists.

See Also
--------
str.join : Standard library version of this method.
Series.str.split : Split strings around given separator/delimiter.

Notes
-----
If any of the list items is not a string object, the result of the join
will be `NaN`.

Examples
--------
Example with a list that contains non-string elements.

&gt;&gt;&gt; s = pd.Series([['lion', 'elephant', 'zebra'],
...                [1.1, 2.2, 3.3],
...                ['cat', np.nan, 'dog'],
...                ['cow', 4.5, 'goat'],
...                ['duck', ['swan', 'fish'], 'guppy']])
&gt;&gt;&gt; s
0        [lion, elephant, zebra]
1                [1.1, 2.2, 3.3]
2                [cat, nan, dog]
3               [cow, 4.5, goat]
4    [duck, [swan, fish], guppy]
dtype: object

Join all lists using a '-'. The lists containing object(s) of types other
than str will produce a NaN.

&gt;&gt;&gt; s.str.join('-')
0    lion-elephant-zebra
1                    NaN
2                    NaN
3                    NaN
4                    NaN
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1062</span>    <span class="keyword">def </span>join(self, sep):</div>
<div class="line"><span class="lineno"> 1063</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        Join lists contained as elements in the Series/Index with passed delimiter.</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">        If the elements of a Series are lists themselves, join the content of these</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">        lists using the delimiter passed to the function.</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">        This function is an equivalent to :meth:`str.join`.</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">        sep : str</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">            Delimiter to use between list entries.</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">        Series/Index: object</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">            The list entries concatenated by intervening occurrences of the</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">            delimiter.</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">        AttributeError</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">            If the supplied Series contains neither strings nor lists.</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">        str.join : Standard library version of this method.</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">        Series.str.split : Split strings around given separator/delimiter.</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">        If any of the list items is not a string object, the result of the join</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        will be `NaN`.</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">        Example with a list that contains non-string elements.</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([[&#39;lion&#39;, &#39;elephant&#39;, &#39;zebra&#39;],</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">        ...                [1.1, 2.2, 3.3],</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">        ...                [&#39;cat&#39;, np.nan, &#39;dog&#39;],</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">        ...                [&#39;cow&#39;, 4.5, &#39;goat&#39;],</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">        ...                [&#39;duck&#39;, [&#39;swan&#39;, &#39;fish&#39;], &#39;guppy&#39;]])</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">        0        [lion, elephant, zebra]</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">        1                [1.1, 2.2, 3.3]</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">        2                [cat, nan, dog]</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">        3               [cow, 4.5, goat]</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">        4    [duck, [swan, fish], guppy]</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">        Join all lists using a &#39;-&#39;. The lists containing object(s) of types other</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">        than str will produce a NaN.</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">        &gt;&gt;&gt; s.str.join(&#39;-&#39;)</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">        0    lion-elephant-zebra</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">        1                    NaN</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">        2                    NaN</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">        3                    NaN</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">        4                    NaN</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1124</span>        result = self._data.array._str_join(sep)</div>
<div class="line"><span class="lineno"> 1125</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1126</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad34be368cab53168ad3a6b9a75247712" name="ad34be368cab53168ad3a6b9a75247712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34be368cab53168ad3a6b9a75247712">&#9670;&#160;</a></span>len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.len </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the length of each element in the Series/Index.

The element may be a sequence (such as a string, tuple or list) or a collection
(such as a dictionary).

Returns
-------
Series or Index of int
    A Series or Index of integer values indicating the length of each
    element in the Series or Index.

See Also
--------
str.len : Python built-in function returning the length of an object.
Series.size : Returns the length of the Series.

Examples
--------
Returns the length (number of characters) in a string. Returns the
number of entries for dictionaries, lists or tuples.

&gt;&gt;&gt; s = pd.Series(['dog',
...                 '',
...                 5,
...                 {'foo' : 'bar'},
...                 [2, 3, 5, 7],
...                 ('one', 'two', 'three')])
&gt;&gt;&gt; s
0                  dog
1
2                    5
3       {'foo': 'bar'}
4         [2, 3, 5, 7]
5    (one, two, three)
dtype: object
&gt;&gt;&gt; s.str.len()
0    3.0
1    0.0
2    NaN
3    1.0
4    4.0
5    3.0
dtype: float64
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2870</span>    <span class="keyword">def </span>len(self):</div>
<div class="line"><span class="lineno"> 2871</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2872</span><span class="stringliteral">        Compute the length of each element in the Series/Index.</span></div>
<div class="line"><span class="lineno"> 2873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2874</span><span class="stringliteral">        The element may be a sequence (such as a string, tuple or list) or a collection</span></div>
<div class="line"><span class="lineno"> 2875</span><span class="stringliteral">        (such as a dictionary).</span></div>
<div class="line"><span class="lineno"> 2876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2877</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2878</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2879</span><span class="stringliteral">        Series or Index of int</span></div>
<div class="line"><span class="lineno"> 2880</span><span class="stringliteral">            A Series or Index of integer values indicating the length of each</span></div>
<div class="line"><span class="lineno"> 2881</span><span class="stringliteral">            element in the Series or Index.</span></div>
<div class="line"><span class="lineno"> 2882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2883</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2884</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2885</span><span class="stringliteral">        str.len : Python built-in function returning the length of an object.</span></div>
<div class="line"><span class="lineno"> 2886</span><span class="stringliteral">        Series.size : Returns the length of the Series.</span></div>
<div class="line"><span class="lineno"> 2887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2888</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2889</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2890</span><span class="stringliteral">        Returns the length (number of characters) in a string. Returns the</span></div>
<div class="line"><span class="lineno"> 2891</span><span class="stringliteral">        number of entries for dictionaries, lists or tuples.</span></div>
<div class="line"><span class="lineno"> 2892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2893</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;dog&#39;,</span></div>
<div class="line"><span class="lineno"> 2894</span><span class="stringliteral">        ...                 &#39;&#39;,</span></div>
<div class="line"><span class="lineno"> 2895</span><span class="stringliteral">        ...                 5,</span></div>
<div class="line"><span class="lineno"> 2896</span><span class="stringliteral">        ...                 {&#39;foo&#39; : &#39;bar&#39;},</span></div>
<div class="line"><span class="lineno"> 2897</span><span class="stringliteral">        ...                 [2, 3, 5, 7],</span></div>
<div class="line"><span class="lineno"> 2898</span><span class="stringliteral">        ...                 (&#39;one&#39;, &#39;two&#39;, &#39;three&#39;)])</span></div>
<div class="line"><span class="lineno"> 2899</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 2900</span><span class="stringliteral">        0                  dog</span></div>
<div class="line"><span class="lineno"> 2901</span><span class="stringliteral">        1</span></div>
<div class="line"><span class="lineno"> 2902</span><span class="stringliteral">        2                    5</span></div>
<div class="line"><span class="lineno"> 2903</span><span class="stringliteral">        3       {&#39;foo&#39;: &#39;bar&#39;}</span></div>
<div class="line"><span class="lineno"> 2904</span><span class="stringliteral">        4         [2, 3, 5, 7]</span></div>
<div class="line"><span class="lineno"> 2905</span><span class="stringliteral">        5    (one, two, three)</span></div>
<div class="line"><span class="lineno"> 2906</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2907</span><span class="stringliteral">        &gt;&gt;&gt; s.str.len()</span></div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral">        0    3.0</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral">        1    0.0</span></div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral">        2    NaN</span></div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral">        3    1.0</span></div>
<div class="line"><span class="lineno"> 2912</span><span class="stringliteral">        4    4.0</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral">        5    3.0</span></div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral">        dtype: float64</span></div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2916</span>        result = self._data.array._str_len()</div>
<div class="line"><span class="lineno"> 2917</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2918</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a94d1168e82c73e57e665139e04190534" name="a94d1168e82c73e57e665139e04190534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d1168e82c73e57e665139e04190534">&#9670;&#160;</a></span>ljust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.ljust </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1644</span>    <span class="keyword">def </span>ljust(self, width, fillchar=&quot; &quot;):</div>
<div class="line"><span class="lineno"> 1645</span>        <span class="keywordflow">return</span> self.pad(width, side=<span class="stringliteral">&quot;right&quot;</span>, fillchar=fillchar)</div>
<div class="line"><span class="lineno"> 1646</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a570aae76320c8226653aa0c7d0b3c76f" name="a570aae76320c8226653aa0c7d0b3c76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570aae76320c8226653aa0c7d0b3c76f">&#9670;&#160;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.lower </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3015</span>    <span class="keyword">def </span>lower(self):</div>
<div class="line"><span class="lineno"> 3016</span>        result = self._data.array._str_lower()</div>
<div class="line"><span class="lineno"> 3017</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 3018</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9fd879dead1434ac4d2414536b70385b" name="a9fd879dead1434ac4d2414536b70385b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd879dead1434ac4d2414536b70385b">&#9670;&#160;</a></span>lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.lstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_strip</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2012</span>    <span class="keyword">def </span>lstrip(self, to_strip=None):</div>
<div class="line"><span class="lineno"> 2013</span>        result = self._data.array._str_lstrip(to_strip)</div>
<div class="line"><span class="lineno"> 2014</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2015</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab402b6b60c0a4f9ef8cb09573e266d67" name="ab402b6b60c0a4f9ef8cb09573e266d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab402b6b60c0a4f9ef8cb09573e266d67">&#9670;&#160;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.match </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>case</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>na</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine if each string starts with a match of a regular expression.

Parameters
----------
pat : str
    Character sequence or regular expression.
case : bool, default True
    If True, case sensitive.
flags : int, default 0 (no flags)
    Regex module flags, e.g. re.IGNORECASE.
na : scalar, optional
    Fill value for missing values. The default depends on dtype of the
    array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,
    ``pandas.NA`` is used.

Returns
-------
Series/Index/array of boolean values

See Also
--------
fullmatch : Stricter matching that requires the entire string to match.
contains : Analogous, but less strict, relying on re.search instead of
    re.match.
extract : Extract matched groups.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1264</span>    <span class="keyword">def </span>match(self, pat, case=True, flags=0, na=None):</div>
<div class="line"><span class="lineno"> 1265</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        Determine if each string starts with a match of a regular expression.</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">        pat : str</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">            Character sequence or regular expression.</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">        case : bool, default True</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">            If True, case sensitive.</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">        flags : int, default 0 (no flags)</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">            Regex module flags, e.g. re.IGNORECASE.</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">        na : scalar, optional</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">            Fill value for missing values. The default depends on dtype of the</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">            ``pandas.NA`` is used.</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">        Series/Index/array of boolean values</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">        fullmatch : Stricter matching that requires the entire string to match.</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">        contains : Analogous, but less strict, relying on re.search instead of</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">            re.match.</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">        extract : Extract matched groups.</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1292</span>        result = self._data.array._str_match(pat, case=case, flags=flags, na=na)</div>
<div class="line"><span class="lineno"> 1293</span>        <span class="keywordflow">return</span> self._wrap_result(result, fill_value=na, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1294</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6fd26fa58d16d1fd987e3a18412deae9" name="a6fd26fa58d16d1fd987e3a18412deae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd26fa58d16d1fd987e3a18412deae9">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.normalize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Unicode normal form for the strings in the Series/Index.

For more information on the forms, see the
:func:`unicodedata.normalize`.

Parameters
----------
form : {'NFC', 'NFKC', 'NFD', 'NFKD'}
    Unicode form.

Returns
-------
normalized : Series/Index of objects
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2786</span>    <span class="keyword">def </span>normalize(self, form):</div>
<div class="line"><span class="lineno"> 2787</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">        Return the Unicode normal form for the strings in the Series/Index.</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">        For more information on the forms, see the</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">        :func:`unicodedata.normalize`.</span></div>
<div class="line"><span class="lineno"> 2792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2793</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2794</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2795</span><span class="stringliteral">        form : {&#39;NFC&#39;, &#39;NFKC&#39;, &#39;NFD&#39;, &#39;NFKD&#39;}</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral">            Unicode form.</span></div>
<div class="line"><span class="lineno"> 2797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2798</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2799</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2800</span><span class="stringliteral">        normalized : Series/Index of objects</span></div>
<div class="line"><span class="lineno"> 2801</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2802</span>        result = self._data.array._str_normalize(form)</div>
<div class="line"><span class="lineno"> 2803</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2804</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5187ed1323820d43fbec71a62fbb70db" name="a5187ed1323820d43fbec71a62fbb70db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5187ed1323820d43fbec71a62fbb70db">&#9670;&#160;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.pad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>side</em> = <code>&quot;left&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pad strings in the Series/Index up to width.

Parameters
----------
width : int
    Minimum width of resulting string; additional characters will be filled
    with character defined in `fillchar`.
side : {'left', 'right', 'both'}, default 'left'
    Side from which to fill resulting string.
fillchar : str, default ' '
    Additional character for filling, default is whitespace.

Returns
-------
Series or Index of object
    Returns Series or Index with minimum number of char in object.

See Also
--------
Series.str.rjust : Fills the left side of strings with an arbitrary
    character. Equivalent to ``Series.str.pad(side='left')``.
Series.str.ljust : Fills the right side of strings with an arbitrary
    character. Equivalent to ``Series.str.pad(side='right')``.
Series.str.center : Fills both sides of strings with an arbitrary
    character. Equivalent to ``Series.str.pad(side='both')``.
Series.str.zfill : Pad strings in the Series/Index by prepending '0'
    character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.

Examples
--------
&gt;&gt;&gt; s = pd.Series(["caribou", "tiger"])
&gt;&gt;&gt; s
0    caribou
1      tiger
dtype: object

&gt;&gt;&gt; s.str.pad(width=10)
0       caribou
1         tiger
dtype: object

&gt;&gt;&gt; s.str.pad(width=10, side='right', fillchar='-')
0    caribou---
1    tiger-----
dtype: object

&gt;&gt;&gt; s.str.pad(width=10, side='both', fillchar='-')
0    -caribou--
1    --tiger---
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1550</span>    <span class="keyword">def </span>pad(self, width, side=&quot;left&quot;, fillchar=&quot; &quot;):</div>
<div class="line"><span class="lineno"> 1551</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">        Pad strings in the Series/Index up to width.</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">        width : int</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">            Minimum width of resulting string; additional characters will be filled</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">            with character defined in `fillchar`.</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">        side : {&#39;left&#39;, &#39;right&#39;, &#39;both&#39;}, default &#39;left&#39;</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">            Side from which to fill resulting string.</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">        fillchar : str, default &#39; &#39;</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">            Additional character for filling, default is whitespace.</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">        Series or Index of object</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">            Returns Series or Index with minimum number of char in object.</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">        Series.str.rjust : Fills the left side of strings with an arbitrary</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">            character. Equivalent to ``Series.str.pad(side=&#39;left&#39;)``.</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral">        Series.str.ljust : Fills the right side of strings with an arbitrary</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">            character. Equivalent to ``Series.str.pad(side=&#39;right&#39;)``.</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">        Series.str.center : Fills both sides of strings with an arbitrary</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">            character. Equivalent to ``Series.str.pad(side=&#39;both&#39;)``.</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">        Series.str.zfill : Pad strings in the Series/Index by prepending &#39;0&#39;</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral">            character. Equivalent to ``Series.str.pad(side=&#39;left&#39;, fillchar=&#39;0&#39;)``.</span></div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&quot;caribou&quot;, &quot;tiger&quot;])</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">        0    caribou</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">        1      tiger</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">        &gt;&gt;&gt; s.str.pad(width=10)</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">        0       caribou</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">        1         tiger</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">        &gt;&gt;&gt; s.str.pad(width=10, side=&#39;right&#39;, fillchar=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">        0    caribou---</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">        1    tiger-----</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">        &gt;&gt;&gt; s.str.pad(width=10, side=&#39;both&#39;, fillchar=&#39;-&#39;)</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">        0    -caribou--</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        1    --tiger---</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1603</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(fillchar, str):</div>
<div class="line"><span class="lineno"> 1604</span>            msg = f<span class="stringliteral">&quot;fillchar must be a character, not {type(fillchar).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 1605</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 1606</span> </div>
<div class="line"><span class="lineno"> 1607</span>        <span class="keywordflow">if</span> len(fillchar) != 1:</div>
<div class="line"><span class="lineno"> 1608</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;fillchar must be a character, not str&quot;</span>)</div>
<div class="line"><span class="lineno"> 1609</span> </div>
<div class="line"><span class="lineno"> 1610</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_integer(width):</div>
<div class="line"><span class="lineno"> 1611</span>            msg = f<span class="stringliteral">&quot;width must be of integer type, not {type(width).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 1612</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 1613</span> </div>
<div class="line"><span class="lineno"> 1614</span>        result = self._data.array._str_pad(width, side=side, fillchar=fillchar)</div>
<div class="line"><span class="lineno"> 1615</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1616</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e33de42a74f320c3212ed19c59f7804" name="a5e33de42a74f320c3212ed19c59f7804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e33de42a74f320c3212ed19c59f7804">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.partition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expand</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  980</span>    <span class="keyword">def </span>partition(self, sep=&quot; &quot;, expand=True):</div>
<div class="line"><span class="lineno">  981</span>        result = self._data.array._str_partition(sep, expand)</div>
<div class="line"><span class="lineno">  982</span>        <span class="keywordflow">return</span> self._wrap_result(result, expand=expand, returns_string=expand)</div>
<div class="line"><span class="lineno">  983</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a1a877bf6a5b971baa75d7759f4d4be" name="a5a1a877bf6a5b971baa75d7759f4d4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1a877bf6a5b971baa75d7759f4d4be">&#9670;&#160;</a></span>removeprefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.removeprefix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2077</span>    <span class="keyword">def </span>removeprefix(self, prefix):</div>
<div class="line"><span class="lineno"> 2078</span>        result = self._data.array._str_removeprefix(prefix)</div>
<div class="line"><span class="lineno"> 2079</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2080</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e8262bec640317ac13ec7ba9e15617b" name="a8e8262bec640317ac13ec7ba9e15617b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8262bec640317ac13ec7ba9e15617b">&#9670;&#160;</a></span>removesuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.removesuffix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2085</span>    <span class="keyword">def </span>removesuffix(self, suffix):</div>
<div class="line"><span class="lineno"> 2086</span>        result = self._data.array._str_removesuffix(suffix)</div>
<div class="line"><span class="lineno"> 2087</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2088</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6d53ba5dac9299b8e92a50839ba8e90" name="ae6d53ba5dac9299b8e92a50839ba8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d53ba5dac9299b8e92a50839ba8e90">&#9670;&#160;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.repeat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repeats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Duplicate each string in the Series or Index.

Parameters
----------
repeats : int or sequence of int
    Same value for all (int) or different value per (sequence).

Returns
-------
Series or Index of object
    Series or Index of repeated string objects specified by
    input parameter repeats.

Examples
--------
&gt;&gt;&gt; s = pd.Series(['a', 'b', 'c'])
&gt;&gt;&gt; s
0    a
1    b
2    c
dtype: object

Single int repeats string in Series

&gt;&gt;&gt; s.str.repeat(repeats=2)
0    aa
1    bb
2    cc
dtype: object

Sequence of int repeats corresponding string in Series

&gt;&gt;&gt; s.str.repeat(repeats=[1, 2, 3])
0      a
1     bb
2    ccc
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1506</span>    <span class="keyword">def </span>repeat(self, repeats):</div>
<div class="line"><span class="lineno"> 1507</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">        Duplicate each string in the Series or Index.</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        repeats : int or sequence of int</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">            Same value for all (int) or different value per (sequence).</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">        Series or Index of object</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">            Series or Index of repeated string objects specified by</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">            input parameter repeats.</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">        0    a</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">        1    b</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">        2    c</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">        Single int repeats string in Series</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">        &gt;&gt;&gt; s.str.repeat(repeats=2)</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">        0    aa</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">        1    bb</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">        2    cc</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">        Sequence of int repeats corresponding string in Series</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">        &gt;&gt;&gt; s.str.repeat(repeats=[1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">        0      a</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">        1     bb</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">        2    ccc</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1546</span>        result = self._data.array._str_repeat(repeats)</div>
<div class="line"><span class="lineno"> 1547</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1548</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae75eefac0458e0690175cdccf85cbe0e" name="ae75eefac0458e0690175cdccf85cbe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75eefac0458e0690175cdccf85cbe0e">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.replace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | re.Pattern&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | Callable&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>n</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>case</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>regex</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Replace each occurrence of pattern/regex in the Series/Index.

    Equivalent to :meth:`str.replace` or :func:`re.sub`, depending on
    the regex value.

    Parameters
    ----------
    pat : str or compiled regex
        String can be a character sequence or regular expression.
    repl : str or callable
        Replacement string or a callable. The callable is passed the regex
        match object and must return a replacement string to be used.
        See :func:`re.sub`.
    n : int, default -1 (all)
        Number of replacements to make from start.
    case : bool, default None
        Determines if replace is case sensitive:

        - If True, case sensitive (the default if `pat` is a string)
        - Set to False for case insensitive
        - Cannot be set if `pat` is a compiled regex.

    flags : int, default 0 (no flags)
        Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled
        regex.
    regex : bool, default True
        Determines if the passed-in pattern is a regular expression:

        - If True, assumes the passed-in pattern is a regular expression.
        - If False, treats the pattern as a literal string
        - Cannot be set to False if `pat` is a compiled regex or `repl` is
          a callable.

        .. versionadded:: 0.23.0

    Returns
    -------
    Series or Index of object
        A copy of the object with all matching occurrences of `pat` replaced by
        `repl`.

    Raises
    ------
    ValueError
        * if `regex` is False and `repl` is a callable or `pat` is a compiled
          regex
        * if `pat` is a compiled regex and `case` or `flags` is set

    Notes
    -----
    When `pat` is a compiled regex, all flags should be included in the
    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled
    regex will raise an error.

    Examples
    --------
    When `pat` is a string and `regex` is True (the default), the given `pat`
    is compiled as a regex. When `repl` is a string, it replaces matching
    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are
    left as is:

    &gt;&gt;&gt; pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)
    0    bao
    1    baz
    2    NaN
    dtype: object

    When `pat` is a string and `regex` is False, every `pat` is replaced with
    `repl` as with :meth:`str.replace`:

    &gt;&gt;&gt; pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)
    0    bao
    1    fuz
    2    NaN
    dtype: object

    When `repl` is a callable, it is called on every `pat` using
    :func:`re.sub`. The callable should expect one positional argument
    (a regex object) and return a string.

    To get the idea:

    &gt;&gt;&gt; pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr, regex=True)
    0    &lt;re.Match object; span=(0, 1), match='f'&gt;oo
    1    &lt;re.Match object; span=(0, 1), match='f'&gt;uz
    2                                            NaN
    dtype: object

    Reverse every lowercase alphabetic word:

    &gt;&gt;&gt; repl = lambda m: m.group(0)[::-1]
    &gt;&gt;&gt; ser = pd.Series(['foo 123', 'bar baz', np.nan])
    &gt;&gt;&gt; ser.str.replace(r'[a-z]+', repl, regex=True)
    0    oof 123
    1    rab zab
    2        NaN
    dtype: object

    Using regex groups (extract second group and swap case):

    &gt;&gt;&gt; pat = r"(?P&lt;one&gt;\w+) (?P&lt;two&gt;\w+) (?P&lt;three&gt;\w+)"
    &gt;&gt;&gt; repl = lambda m: m.group('two').swapcase()
    &gt;&gt;&gt; ser = pd.Series(['One Two Three', 'Foo Bar Baz'])
    &gt;&gt;&gt; ser.str.replace(pat, repl, regex=True)
    0    tWO
    1    bAR
    dtype: object

    Using a compiled regex with flags

    &gt;&gt;&gt; import re
    &gt;&gt;&gt; regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)
    &gt;&gt;&gt; pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar', regex=True)
    0    foo
    1    bar
    2    NaN
    dtype: object</pre> <div class="fragment"><div class="line"><span class="lineno"> 1337</span>    ):</div>
<div class="line"><span class="lineno"> 1338</span>        <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">        Replace each occurrence of pattern/regex in the Series/Index.</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        Equivalent to :meth:`str.replace` or :func:`re.sub`, depending on</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">        the regex value.</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">        pat : str or compiled regex</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">            String can be a character sequence or regular expression.</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">        repl : str or callable</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">            Replacement string or a callable. The callable is passed the regex</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">            match object and must return a replacement string to be used.</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">            See :func:`re.sub`.</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">        n : int, default -1 (all)</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">            Number of replacements to make from start.</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">        case : bool, default None</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">            Determines if replace is case sensitive:</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">            - If True, case sensitive (the default if `pat` is a string)</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">            - Set to False for case insensitive</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">            - Cannot be set if `pat` is a compiled regex.</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">        flags : int, default 0 (no flags)</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">            Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">            regex.</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">        regex : bool, default True</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">            Determines if the passed-in pattern is a regular expression:</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">            - If True, assumes the passed-in pattern is a regular expression.</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">            - If False, treats the pattern as a literal string</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">            - Cannot be set to False if `pat` is a compiled regex or `repl` is</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">              a callable.</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">            .. versionadded:: 0.23.0</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">        Series or Index of object</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">            A copy of the object with all matching occurrences of `pat` replaced by</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">            `repl`.</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">        ValueError</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">            * if `regex` is False and `repl` is a callable or `pat` is a compiled</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">              regex</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">            * if `pat` is a compiled regex and `case` or `flags` is set</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">        When `pat` is a compiled regex, all flags should be included in the</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">        compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">        regex will raise an error.</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">        When `pat` is a string and `regex` is True (the default), the given `pat`</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">        is compiled as a regex. When `repl` is a string, it replaces matching</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">        regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">        left as is:</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">        &gt;&gt;&gt; pd.Series([&#39;foo&#39;, &#39;fuz&#39;, np.nan]).str.replace(&#39;f.&#39;, &#39;ba&#39;, regex=True)</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">        0    bao</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">        1    baz</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">        2    NaN</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">        When `pat` is a string and `regex` is False, every `pat` is replaced with</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">        `repl` as with :meth:`str.replace`:</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">        &gt;&gt;&gt; pd.Series([&#39;f.o&#39;, &#39;fuz&#39;, np.nan]).str.replace(&#39;f.&#39;, &#39;ba&#39;, regex=False)</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">        0    bao</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">        1    fuz</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">        2    NaN</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">        When `repl` is a callable, it is called on every `pat` using</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">        :func:`re.sub`. The callable should expect one positional argument</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">        (a regex object) and return a string.</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">        To get the idea:</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">        &gt;&gt;&gt; pd.Series([&#39;foo&#39;, &#39;fuz&#39;, np.nan]).str.replace(&#39;f&#39;, repr, regex=True)</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">        0    &lt;re.Match object; span=(0, 1), match=&#39;f&#39;&gt;oo</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">        1    &lt;re.Match object; span=(0, 1), match=&#39;f&#39;&gt;uz</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">        2                                            NaN</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">        Reverse every lowercase alphabetic word:</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">        &gt;&gt;&gt; repl = lambda m: m.group(0)[::-1]</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">        &gt;&gt;&gt; ser = pd.Series([&#39;foo 123&#39;, &#39;bar baz&#39;, np.nan])</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">        &gt;&gt;&gt; ser.str.replace(r&#39;[a-z]+&#39;, repl, regex=True)</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">        0    oof 123</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">        1    rab zab</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">        2        NaN</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">        Using regex groups (extract second group and swap case):</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">        &gt;&gt;&gt; pat = r&quot;(?P&lt;one&gt;\w+) (?P&lt;two&gt;\w+) (?P&lt;three&gt;\w+)&quot;</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">        &gt;&gt;&gt; repl = lambda m: m.group(&#39;two&#39;).swapcase()</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">        &gt;&gt;&gt; ser = pd.Series([&#39;One Two Three&#39;, &#39;Foo Bar Baz&#39;])</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">        &gt;&gt;&gt; ser.str.replace(pat, repl, regex=True)</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">        0    tWO</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">        1    bAR</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">        Using a compiled regex with flags</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">        &gt;&gt;&gt; import re</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">        &gt;&gt;&gt; regex_pat = re.compile(r&#39;FUZ&#39;, flags=re.IGNORECASE)</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">        &gt;&gt;&gt; pd.Series([&#39;foo&#39;, &#39;fuz&#39;, np.nan]).str.replace(regex_pat, &#39;bar&#39;, regex=True)</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">        0    foo</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">        1    bar</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">        2    NaN</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1457</span>        <span class="keywordflow">if</span> regex <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1458</span>            <span class="keywordflow">if</span> isinstance(pat, str) <span class="keywordflow">and</span> any(c <span class="keywordflow">in</span> pat <span class="keywordflow">for</span> c <span class="keywordflow">in</span> <span class="stringliteral">&quot;.+*|^$?[](){}\\&quot;</span>):</div>
<div class="line"><span class="lineno"> 1459</span>                <span class="comment"># warn only in cases where regex behavior would differ from literal</span></div>
<div class="line"><span class="lineno"> 1460</span>                msg = (</div>
<div class="line"><span class="lineno"> 1461</span>                    <span class="stringliteral">&quot;The default value of regex will change from True to False &quot;</span></div>
<div class="line"><span class="lineno"> 1462</span>                    <span class="stringliteral">&quot;in a future version.&quot;</span></div>
<div class="line"><span class="lineno"> 1463</span>                )</div>
<div class="line"><span class="lineno"> 1464</span>                <span class="keywordflow">if</span> len(pat) == 1:</div>
<div class="line"><span class="lineno"> 1465</span>                    msg += (</div>
<div class="line"><span class="lineno"> 1466</span>                        <span class="stringliteral">&quot; In addition, single character regular expressions will &quot;</span></div>
<div class="line"><span class="lineno"> 1467</span>                        <span class="stringliteral">&quot;*not* be treated as literal strings when regex=True.&quot;</span></div>
<div class="line"><span class="lineno"> 1468</span>                    )</div>
<div class="line"><span class="lineno"> 1469</span>                warnings.warn(msg, FutureWarning, stacklevel=find_stack_level())</div>
<div class="line"><span class="lineno"> 1470</span> </div>
<div class="line"><span class="lineno"> 1471</span>        <span class="comment"># Check whether repl is valid (GH 13438, GH 15055)</span></div>
<div class="line"><span class="lineno"> 1472</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (isinstance(repl, str) <span class="keywordflow">or</span> callable(repl)):</div>
<div class="line"><span class="lineno"> 1473</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;repl must be a string or callable&quot;</span>)</div>
<div class="line"><span class="lineno"> 1474</span> </div>
<div class="line"><span class="lineno"> 1475</span>        is_compiled_re = is_re(pat)</div>
<div class="line"><span class="lineno"> 1476</span>        <span class="keywordflow">if</span> regex <span class="keywordflow">or</span> regex <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1477</span>            <span class="keywordflow">if</span> is_compiled_re <span class="keywordflow">and</span> (case <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> flags != 0):</div>
<div class="line"><span class="lineno"> 1478</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1479</span>                    <span class="stringliteral">&quot;case and flags cannot be set when pat is a compiled regex&quot;</span></div>
<div class="line"><span class="lineno"> 1480</span>                )</div>
<div class="line"><span class="lineno"> 1481</span> </div>
<div class="line"><span class="lineno"> 1482</span>        <span class="keywordflow">elif</span> is_compiled_re:</div>
<div class="line"><span class="lineno"> 1483</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1484</span>                <span class="stringliteral">&quot;Cannot use a compiled regex as replacement pattern with regex=False&quot;</span></div>
<div class="line"><span class="lineno"> 1485</span>            )</div>
<div class="line"><span class="lineno"> 1486</span>        <span class="keywordflow">elif</span> callable(repl):</div>
<div class="line"><span class="lineno"> 1487</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Cannot use a callable replacement when regex=False&quot;</span>)</div>
<div class="line"><span class="lineno"> 1488</span> </div>
<div class="line"><span class="lineno"> 1489</span>        <span class="comment"># The current behavior is to treat single character patterns as literal strings,</span></div>
<div class="line"><span class="lineno"> 1490</span>        <span class="comment"># even when ``regex`` is set to ``True``.</span></div>
<div class="line"><span class="lineno"> 1491</span>        <span class="keywordflow">if</span> isinstance(pat, str) <span class="keywordflow">and</span> len(pat) == 1:</div>
<div class="line"><span class="lineno"> 1492</span>            regex = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1493</span> </div>
<div class="line"><span class="lineno"> 1494</span>        <span class="keywordflow">if</span> regex <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1495</span>            regex = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1496</span> </div>
<div class="line"><span class="lineno"> 1497</span>        <span class="keywordflow">if</span> case <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1498</span>            case = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1499</span> </div>
<div class="line"><span class="lineno"> 1500</span>        result = self._data.array._str_replace(</div>
<div class="line"><span class="lineno"> 1501</span>            pat, repl, n=n, case=case, flags=flags, regex=regex</div>
<div class="line"><span class="lineno"> 1502</span>        )</div>
<div class="line"><span class="lineno"> 1503</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1504</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ccb6ee7e4a325f5fb8c7275807ebb43" name="a1ccb6ee7e4a325f5fb8c7275807ebb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccb6ee7e4a325f5fb8c7275807ebb43">&#9670;&#160;</a></span>rfind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.rfind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2777</span>    <span class="keyword">def </span>rfind(self, sub, start=0, end=None):</div>
<div class="line"><span class="lineno"> 2778</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(sub, str):</div>
<div class="line"><span class="lineno"> 2779</span>            msg = f<span class="stringliteral">&quot;expected a string object, not {type(sub).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 2780</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 2781</span> </div>
<div class="line"><span class="lineno"> 2782</span>        result = self._data.array._str_rfind(sub, start=start, end=end)</div>
<div class="line"><span class="lineno"> 2783</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2784</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2ab30039a1725b4e6ae61a9cebc08b4" name="ac2ab30039a1725b4e6ae61a9cebc08b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ab30039a1725b4e6ae61a9cebc08b4">&#9670;&#160;</a></span>rindex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.rindex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2862</span>    <span class="keyword">def </span>rindex(self, sub, start=0, end=None):</div>
<div class="line"><span class="lineno"> 2863</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(sub, str):</div>
<div class="line"><span class="lineno"> 2864</span>            msg = f<span class="stringliteral">&quot;expected a string object, not {type(sub).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 2865</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 2866</span> </div>
<div class="line"><span class="lineno"> 2867</span>        result = self._data.array._str_rindex(sub, start=start, end=end)</div>
<div class="line"><span class="lineno"> 2868</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2869</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6eca11e5fc9d876d122d3f5cfc296970" name="a6eca11e5fc9d876d122d3f5cfc296970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca11e5fc9d876d122d3f5cfc296970">&#9670;&#160;</a></span>rjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.rjust </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1649</span>    <span class="keyword">def </span>rjust(self, width, fillchar=&quot; &quot;):</div>
<div class="line"><span class="lineno"> 1650</span>        <span class="keywordflow">return</span> self.pad(width, side=<span class="stringliteral">&quot;left&quot;</span>, fillchar=fillchar)</div>
<div class="line"><span class="lineno"> 1651</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acbbed76592b3b5971588c202f27807d7" name="acbbed76592b3b5971588c202f27807d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbed76592b3b5971588c202f27807d7">&#9670;&#160;</a></span>rpartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.rpartition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expand</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  994</span>    <span class="keyword">def </span>rpartition(self, sep=&quot; &quot;, expand=True):</div>
<div class="line"><span class="lineno">  995</span>        result = self._data.array._str_rpartition(sep, expand)</div>
<div class="line"><span class="lineno">  996</span>        <span class="keywordflow">return</span> self._wrap_result(result, expand=expand, returns_string=expand)</div>
<div class="line"><span class="lineno">  997</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e071153fe800e1fee171e92b4f6356c" name="a1e071153fe800e1fee171e92b4f6356c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e071153fe800e1fee171e92b4f6356c">&#9670;&#160;</a></span>rsplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.rsplit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expand</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  884</span>    <span class="keyword">def </span>rsplit(self, pat=None, n=-1, expand=False):</div>
<div class="line"><span class="lineno">  885</span>        result = self._data.array._str_rsplit(pat, n=n)</div>
<div class="line"><span class="lineno">  886</span>        <span class="keywordflow">return</span> self._wrap_result(result, expand=expand, returns_string=expand)</div>
<div class="line"><span class="lineno">  887</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a758978c745520e1dc0872d4d42fc7688" name="a758978c745520e1dc0872d4d42fc7688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758978c745520e1dc0872d4d42fc7688">&#9670;&#160;</a></span>rstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.rstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_strip</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2021</span>    <span class="keyword">def </span>rstrip(self, to_strip=None):</div>
<div class="line"><span class="lineno"> 2022</span>        result = self._data.array._str_rstrip(to_strip)</div>
<div class="line"><span class="lineno"> 2023</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2024</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a104396fbf2e11ddfffa77246e5778881" name="a104396fbf2e11ddfffa77246e5778881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104396fbf2e11ddfffa77246e5778881">&#9670;&#160;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.slice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stop</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Slice substrings from each element in the Series or Index.

Parameters
----------
start : int, optional
    Start position for slice operation.
stop : int, optional
    Stop position for slice operation.
step : int, optional
    Step size for slice operation.

Returns
-------
Series or Index of object
    Series or Index from sliced substring from original string object.

See Also
--------
Series.str.slice_replace : Replace a slice with a string.
Series.str.get : Return element at position.
    Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`
    being the position.

Examples
--------
&gt;&gt;&gt; s = pd.Series(["koala", "dog", "chameleon"])
&gt;&gt;&gt; s
0        koala
1          dog
2    chameleon
dtype: object

&gt;&gt;&gt; s.str.slice(start=1)
0        oala
1          og
2    hameleon
dtype: object

&gt;&gt;&gt; s.str.slice(start=-1)
0           a
1           g
2           n
dtype: object

&gt;&gt;&gt; s.str.slice(stop=2)
0    ko
1    do
2    ch
dtype: object

&gt;&gt;&gt; s.str.slice(step=2)
0      kaa
1       dg
2    caeen
dtype: object

&gt;&gt;&gt; s.str.slice(start=0, stop=5, step=3)
0    kl
1     d
2    cm
dtype: object

Equivalent behaviour to:

&gt;&gt;&gt; s.str[0:5:3]
0    kl
1     d
2    cm
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1720</span>    <span class="keyword">def </span>slice(self, start=None, stop=None, step=None):</div>
<div class="line"><span class="lineno"> 1721</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">        Slice substrings from each element in the Series or Index.</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">        start : int, optional</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">            Start position for slice operation.</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">        stop : int, optional</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">            Stop position for slice operation.</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">        step : int, optional</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">            Step size for slice operation.</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">        Series or Index of object</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral">            Series or Index from sliced substring from original string object.</span></div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">        Series.str.slice_replace : Replace a slice with a string.</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">        Series.str.get : Return element at position.</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">            Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">            being the position.</span></div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&quot;koala&quot;, &quot;dog&quot;, &quot;chameleon&quot;])</span></div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral">        0        koala</span></div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">        1          dog</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral">        2    chameleon</span></div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice(start=1)</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">        0        oala</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral">        1          og</span></div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">        2    hameleon</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice(start=-1)</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">        0           a</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">        1           g</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">        2           n</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice(stop=2)</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">        0    ko</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">        1    do</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">        2    ch</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice(step=2)</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">        0      kaa</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">        1       dg</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">        2    caeen</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice(start=0, stop=5, step=3)</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">        0    kl</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">        1     d</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">        2    cm</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">        Equivalent behaviour to:</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">        &gt;&gt;&gt; s.str[0:5:3]</span></div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">        0    kl</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">        1     d</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">        2    cm</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1792</span>        result = self._data.array._str_slice(start, stop, step)</div>
<div class="line"><span class="lineno"> 1793</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1794</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abc4e27627d0fdc6b14c971d5eb948f69" name="abc4e27627d0fdc6b14c971d5eb948f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4e27627d0fdc6b14c971d5eb948f69">&#9670;&#160;</a></span>slice_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.slice_replace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stop</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repl</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replace a positional slice of a string with another value.

Parameters
----------
start : int, optional
    Left index position to use for the slice. If not specified (None),
    the slice is unbounded on the left, i.e. slice from the start
    of the string.
stop : int, optional
    Right index position to use for the slice. If not specified (None),
    the slice is unbounded on the right, i.e. slice until the
    end of the string.
repl : str, optional
    String for replacement. If not specified (None), the sliced region
    is replaced with an empty string.

Returns
-------
Series or Index
    Same type as the original object.

See Also
--------
Series.str.slice : Just slicing without replacement.

Examples
--------
&gt;&gt;&gt; s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])
&gt;&gt;&gt; s
0        a
1       ab
2      abc
3     abdc
4    abcde
dtype: object

Specify just `start`, meaning replace `start` until the end of the
string with `repl`.

&gt;&gt;&gt; s.str.slice_replace(1, repl='X')
0    aX
1    aX
2    aX
3    aX
4    aX
dtype: object

Specify just `stop`, meaning the start of the string to `stop` is replaced
with `repl`, and the rest of the string is included.

&gt;&gt;&gt; s.str.slice_replace(stop=2, repl='X')
0       X
1       X
2      Xc
3     Xdc
4    Xcde
dtype: object

Specify `start` and `stop`, meaning the slice from `start` to `stop` is
replaced with `repl`. Everything before or after `start` and `stop` is
included as is.

&gt;&gt;&gt; s.str.slice_replace(start=1, stop=3, repl='X')
0      aX
1      aX
2      aX
3     aXc
4    aXde
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1796</span>    <span class="keyword">def </span>slice_replace(self, start=None, stop=None, repl=None):</div>
<div class="line"><span class="lineno"> 1797</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">        Replace a positional slice of a string with another value.</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        start : int, optional</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">            Left index position to use for the slice. If not specified (None),</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">            the slice is unbounded on the left, i.e. slice from the start</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">            of the string.</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">        stop : int, optional</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">            Right index position to use for the slice. If not specified (None),</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">            the slice is unbounded on the right, i.e. slice until the</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">            end of the string.</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">        repl : str, optional</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">            String for replacement. If not specified (None), the sliced region</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">            is replaced with an empty string.</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">        Series or Index</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">            Same type as the original object.</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">        Series.str.slice : Just slicing without replacement.</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;ab&#39;, &#39;abc&#39;, &#39;abdc&#39;, &#39;abcde&#39;])</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">        0        a</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">        1       ab</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        2      abc</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">        3     abdc</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">        4    abcde</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">        Specify just `start`, meaning replace `start` until the end of the</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">        string with `repl`.</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice_replace(1, repl=&#39;X&#39;)</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">        0    aX</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">        1    aX</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">        2    aX</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">        3    aX</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">        4    aX</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">        Specify just `stop`, meaning the start of the string to `stop` is replaced</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">        with `repl`, and the rest of the string is included.</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice_replace(stop=2, repl=&#39;X&#39;)</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">        0       X</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">        1       X</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">        2      Xc</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">        3     Xdc</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">        4    Xcde</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">        Specify `start` and `stop`, meaning the slice from `start` to `stop` is</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">        replaced with `repl`. Everything before or after `start` and `stop` is</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral">        included as is.</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral">        &gt;&gt;&gt; s.str.slice_replace(start=1, stop=3, repl=&#39;X&#39;)</span></div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">        0      aX</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">        1      aX</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">        2      aX</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">        3     aXc</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">        4    aXde</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1868</span>        result = self._data.array._str_slice_replace(start, stop, repl)</div>
<div class="line"><span class="lineno"> 1869</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1870</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a67ed7de8173c36998665dc3fa93cd7b5" name="a67ed7de8173c36998665dc3fa93cd7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ed7de8173c36998665dc3fa93cd7b5">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.split </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | re.Pattern | None &#160;</td>
          <td class="paramname"><em>pat</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expand</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>regex</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  859</span>    ):</div>
<div class="line"><span class="lineno">  860</span>        <span class="keywordflow">if</span> regex <span class="keywordflow">is</span> <span class="keyword">False</span> <span class="keywordflow">and</span> is_re(pat):</div>
<div class="line"><span class="lineno">  861</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  862</span>                <span class="stringliteral">&quot;Cannot use a compiled regex as replacement pattern with regex=False&quot;</span></div>
<div class="line"><span class="lineno">  863</span>            )</div>
<div class="line"><span class="lineno">  864</span>        <span class="keywordflow">if</span> is_re(pat):</div>
<div class="line"><span class="lineno">  865</span>            regex = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  866</span>        result = self._data.array._str_split(pat, n, expand, regex)</div>
<div class="line"><span class="lineno">  867</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=expand, expand=expand)</div>
<div class="line"><span class="lineno">  868</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aba83918f37a3c1d62594b66082554d85" name="aba83918f37a3c1d62594b66082554d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba83918f37a3c1d62594b66082554d85">&#9670;&#160;</a></span>startswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Series | Index pandas.core.strings.accessor.StringMethods.startswith </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | tuple[str, ...]&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar | None &#160;</td>
          <td class="paramname"><em>na</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the start of each string element matches a pattern.

Equivalent to :meth:`str.startswith`.

Parameters
----------
pat : str or tuple[str, ...]
    Character sequence or tuple of strings. Regular expressions are not
    accepted.
na : object, default NaN
    Object shown if element tested is not a string. The default depends
    on dtype of the array. For object-dtype, ``numpy.nan`` is used.
    For ``StringDtype``, ``pandas.NA`` is used.

Returns
-------
Series or Index of bool
    A Series of booleans indicating whether the given pattern matches
    the start of each string element.

See Also
--------
str.startswith : Python standard library string method.
Series.str.endswith : Same as startswith, but tests the end of string.
Series.str.contains : Tests if string element contains a pattern.

Examples
--------
&gt;&gt;&gt; s = pd.Series(['bat', 'Bear', 'cat', np.nan])
&gt;&gt;&gt; s
0     bat
1    Bear
2     cat
3     NaN
dtype: object

&gt;&gt;&gt; s.str.startswith('b')
0     True
1    False
2    False
3      NaN
dtype: object

&gt;&gt;&gt; s.str.startswith(('b', 'B'))
0     True
1     True
2    False
3      NaN
dtype: object

Specifying `na` to be `False` instead of `NaN`.

&gt;&gt;&gt; s.str.startswith('b', na=False)
0     True
1    False
2    False
3    False
dtype: bool
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2288</span>    ) -&gt; Series | Index:</div>
<div class="line"><span class="lineno"> 2289</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2290</span><span class="stringliteral">        Test if the start of each string element matches a pattern.</span></div>
<div class="line"><span class="lineno"> 2291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2292</span><span class="stringliteral">        Equivalent to :meth:`str.startswith`.</span></div>
<div class="line"><span class="lineno"> 2293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2294</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2295</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2296</span><span class="stringliteral">        pat : str or tuple[str, ...]</span></div>
<div class="line"><span class="lineno"> 2297</span><span class="stringliteral">            Character sequence or tuple of strings. Regular expressions are not</span></div>
<div class="line"><span class="lineno"> 2298</span><span class="stringliteral">            accepted.</span></div>
<div class="line"><span class="lineno"> 2299</span><span class="stringliteral">        na : object, default NaN</span></div>
<div class="line"><span class="lineno"> 2300</span><span class="stringliteral">            Object shown if element tested is not a string. The default depends</span></div>
<div class="line"><span class="lineno"> 2301</span><span class="stringliteral">            on dtype of the array. For object-dtype, ``numpy.nan`` is used.</span></div>
<div class="line"><span class="lineno"> 2302</span><span class="stringliteral">            For ``StringDtype``, ``pandas.NA`` is used.</span></div>
<div class="line"><span class="lineno"> 2303</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2304</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2305</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2306</span><span class="stringliteral">        Series or Index of bool</span></div>
<div class="line"><span class="lineno"> 2307</span><span class="stringliteral">            A Series of booleans indicating whether the given pattern matches</span></div>
<div class="line"><span class="lineno"> 2308</span><span class="stringliteral">            the start of each string element.</span></div>
<div class="line"><span class="lineno"> 2309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2310</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2311</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2312</span><span class="stringliteral">        str.startswith : Python standard library string method.</span></div>
<div class="line"><span class="lineno"> 2313</span><span class="stringliteral">        Series.str.endswith : Same as startswith, but tests the end of string.</span></div>
<div class="line"><span class="lineno"> 2314</span><span class="stringliteral">        Series.str.contains : Tests if string element contains a pattern.</span></div>
<div class="line"><span class="lineno"> 2315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2316</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2317</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2318</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;bat&#39;, &#39;Bear&#39;, &#39;cat&#39;, np.nan])</span></div>
<div class="line"><span class="lineno"> 2319</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 2320</span><span class="stringliteral">        0     bat</span></div>
<div class="line"><span class="lineno"> 2321</span><span class="stringliteral">        1    Bear</span></div>
<div class="line"><span class="lineno"> 2322</span><span class="stringliteral">        2     cat</span></div>
<div class="line"><span class="lineno"> 2323</span><span class="stringliteral">        3     NaN</span></div>
<div class="line"><span class="lineno"> 2324</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2326</span><span class="stringliteral">        &gt;&gt;&gt; s.str.startswith(&#39;b&#39;)</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral">        0     True</span></div>
<div class="line"><span class="lineno"> 2328</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 2329</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 2330</span><span class="stringliteral">        3      NaN</span></div>
<div class="line"><span class="lineno"> 2331</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2333</span><span class="stringliteral">        &gt;&gt;&gt; s.str.startswith((&#39;b&#39;, &#39;B&#39;))</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral">        0     True</span></div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral">        1     True</span></div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral">        3      NaN</span></div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral">        Specifying `na` to be `False` instead of `NaN`.</span></div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral">        &gt;&gt;&gt; s.str.startswith(&#39;b&#39;, na=False)</span></div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral">        0     True</span></div>
<div class="line"><span class="lineno"> 2344</span><span class="stringliteral">        1    False</span></div>
<div class="line"><span class="lineno"> 2345</span><span class="stringliteral">        2    False</span></div>
<div class="line"><span class="lineno"> 2346</span><span class="stringliteral">        3    False</span></div>
<div class="line"><span class="lineno"> 2347</span><span class="stringliteral">        dtype: bool</span></div>
<div class="line"><span class="lineno"> 2348</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2349</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(pat, (str, tuple)):</div>
<div class="line"><span class="lineno"> 2350</span>            msg = f<span class="stringliteral">&quot;expected a string or tuple, not {type(pat).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 2351</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 2352</span>        result = self._data.array._str_startswith(pat, na=na)</div>
<div class="line"><span class="lineno"> 2353</span>        <span class="keywordflow">return</span> self._wrap_result(result, returns_string=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2354</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d65f2a3236f8a1fdd3efa289d52df3d" name="a3d65f2a3236f8a1fdd3efa289d52df3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d65f2a3236f8a1fdd3efa289d52df3d">&#9670;&#160;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.strip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_strip</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2003</span>    <span class="keyword">def </span>strip(self, to_strip=None):</div>
<div class="line"><span class="lineno"> 2004</span>        result = self._data.array._str_strip(to_strip)</div>
<div class="line"><span class="lineno"> 2005</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2006</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a637134393abbd560faa1456f806ffe37" name="a637134393abbd560faa1456f806ffe37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637134393abbd560faa1456f806ffe37">&#9670;&#160;</a></span>swapcase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.swapcase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3039</span>    <span class="keyword">def </span>swapcase(self):</div>
<div class="line"><span class="lineno"> 3040</span>        result = self._data.array._str_swapcase()</div>
<div class="line"><span class="lineno"> 3041</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 3042</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a88f385da8044811562e1545097519213" name="a88f385da8044811562e1545097519213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f385da8044811562e1545097519213">&#9670;&#160;</a></span>title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.title </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3027</span>    <span class="keyword">def </span>title(self):</div>
<div class="line"><span class="lineno"> 3028</span>        result = self._data.array._str_title()</div>
<div class="line"><span class="lineno"> 3029</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 3030</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a05b047c5261002afdbe2b59de65df4b1" name="a05b047c5261002afdbe2b59de65df4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b047c5261002afdbe2b59de65df4b1">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.translate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Map all characters in the string through the given mapping table.

Equivalent to standard :meth:`str.translate`.

Parameters
----------
table : dict
    Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or
    None. Unmapped characters are left untouched.
    Characters mapped to None are deleted. :meth:`str.maketrans` is a
    helper function for making translation tables.

Returns
-------
Series or Index
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2196</span>    <span class="keyword">def </span>translate(self, table):</div>
<div class="line"><span class="lineno"> 2197</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2198</span><span class="stringliteral">        Map all characters in the string through the given mapping table.</span></div>
<div class="line"><span class="lineno"> 2199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2200</span><span class="stringliteral">        Equivalent to standard :meth:`str.translate`.</span></div>
<div class="line"><span class="lineno"> 2201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2202</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2203</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2204</span><span class="stringliteral">        table : dict</span></div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral">            Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or</span></div>
<div class="line"><span class="lineno"> 2206</span><span class="stringliteral">            None. Unmapped characters are left untouched.</span></div>
<div class="line"><span class="lineno"> 2207</span><span class="stringliteral">            Characters mapped to None are deleted. :meth:`str.maketrans` is a</span></div>
<div class="line"><span class="lineno"> 2208</span><span class="stringliteral">            helper function for making translation tables.</span></div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral">        Series or Index</span></div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2214</span>        result = self._data.array._str_translate(table)</div>
<div class="line"><span class="lineno"> 2215</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2216</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a975ff1996ba168420562abe4f8898277" name="a975ff1996ba168420562abe4f8898277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975ff1996ba168420562abe4f8898277">&#9670;&#160;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.upper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3021</span>    <span class="keyword">def </span>upper(self):</div>
<div class="line"><span class="lineno"> 3022</span>        result = self._data.array._str_upper()</div>
<div class="line"><span class="lineno"> 3023</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 3024</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a383e4bad85eb68e0f4ec4aa9180dfa49" name="a383e4bad85eb68e0f4ec4aa9180dfa49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383e4bad85eb68e0f4ec4aa9180dfa49">&#9670;&#160;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.wrap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Wrap strings in Series/Index at specified line width.

    This method has the same keyword parameters and defaults as
    :class:`textwrap.TextWrapper`.

    Parameters
    ----------
    width : int
        Maximum line width.
    expand_tabs : bool, optional
        If True, tab characters will be expanded to spaces (default: True).
    replace_whitespace : bool, optional
        If True, each whitespace character (as defined by string.whitespace)
        remaining after tab expansion will be replaced by a single space
        (default: True).
    drop_whitespace : bool, optional
        If True, whitespace that, after wrapping, happens to end up at the
        beginning or end of a line is dropped (default: True).
    break_long_words : bool, optional
        If True, then words longer than width will be broken in order to ensure
        that no lines are longer than width. If it is false, long words will
        not be broken, and some lines may be longer than width (default: True).
    break_on_hyphens : bool, optional
        If True, wrapping will occur preferably on whitespace and right after
        hyphens in compound words, as it is customary in English. If false,
        only whitespaces will be considered as potentially good places for line
        breaks, but you need to set break_long_words to false if you want truly
        insecable words (default: True).

    Returns
    -------
    Series or Index

    Notes
    -----
    Internally, this method uses a :class:`textwrap.TextWrapper` instance with
    default settings. To achieve behavior matching R's stringr library str_wrap
    function, use the arguments:

    - expand_tabs = False
    - replace_whitespace = True
    - drop_whitespace = True
    - break_long_words = False
    - break_on_hyphens = False

    Examples
    --------
    &gt;&gt;&gt; s = pd.Series(['line to be wrapped', 'another line to be wrapped'])
    &gt;&gt;&gt; s.str.wrap(12)
    0             line to be\nwrapped
    1    another line\nto be\nwrapped
    dtype: object</pre> <div class="fragment"><div class="line"><span class="lineno"> 2090</span>    <span class="keyword">def </span>wrap(self, width, **kwargs):</div>
<div class="line"><span class="lineno"> 2091</span>        <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral">        Wrap strings in Series/Index at specified line width.</span></div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">        This method has the same keyword parameters and defaults as</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral">        :class:`textwrap.TextWrapper`.</span></div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">        width : int</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">            Maximum line width.</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">        expand_tabs : bool, optional</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral">            If True, tab characters will be expanded to spaces (default: True).</span></div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral">        replace_whitespace : bool, optional</span></div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral">            If True, each whitespace character (as defined by string.whitespace)</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">            remaining after tab expansion will be replaced by a single space</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral">            (default: True).</span></div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">        drop_whitespace : bool, optional</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral">            If True, whitespace that, after wrapping, happens to end up at the</span></div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">            beginning or end of a line is dropped (default: True).</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral">        break_long_words : bool, optional</span></div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">            If True, then words longer than width will be broken in order to ensure</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">            that no lines are longer than width. If it is false, long words will</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">            not be broken, and some lines may be longer than width (default: True).</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">        break_on_hyphens : bool, optional</span></div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">            If True, wrapping will occur preferably on whitespace and right after</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral">            hyphens in compound words, as it is customary in English. If false,</span></div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">            only whitespaces will be considered as potentially good places for line</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">            breaks, but you need to set break_long_words to false if you want truly</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral">            insecable words (default: True).</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">        Series or Index</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral">        Internally, this method uses a :class:`textwrap.TextWrapper` instance with</span></div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral">        default settings. To achieve behavior matching R&#39;s stringr library str_wrap</span></div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">        function, use the arguments:</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral">        - expand_tabs = False</span></div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral">        - replace_whitespace = True</span></div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">        - drop_whitespace = True</span></div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral">        - break_long_words = False</span></div>
<div class="line"><span class="lineno"> 2135</span><span class="stringliteral">        - break_on_hyphens = False</span></div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;line to be wrapped&#39;, &#39;another line to be wrapped&#39;])</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral">        &gt;&gt;&gt; s.str.wrap(12)</span></div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">        0             line to be\nwrapped</span></div>
<div class="line"><span class="lineno"> 2142</span><span class="stringliteral">        1    another line\nto be\nwrapped</span></div>
<div class="line"><span class="lineno"> 2143</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2144</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2145</span>        result = self._data.array._str_wrap(width, **kwargs)</div>
<div class="line"><span class="lineno"> 2146</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 2147</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a91b2917c3c252e095ed9b6a3ef03a0b4" name="a91b2917c3c252e095ed9b6a3ef03a0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b2917c3c252e095ed9b6a3ef03a0b4">&#9670;&#160;</a></span>zfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.zfill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pad strings in the Series/Index by prepending '0' characters.

Strings in the Series/Index are padded with '0' characters on the
left of the string to reach a total string length  `width`. Strings
in the Series/Index with length greater or equal to `width` are
unchanged.

Parameters
----------
width : int
    Minimum length of resulting string; strings with length less
    than `width` be prepended with '0' characters.

Returns
-------
Series/Index of objects.

See Also
--------
Series.str.rjust : Fills the left side of strings with an arbitrary
    character.
Series.str.ljust : Fills the right side of strings with an arbitrary
    character.
Series.str.pad : Fills the specified sides of strings with an arbitrary
    character.
Series.str.center : Fills both sides of strings with an arbitrary
    character.

Notes
-----
Differs from :meth:`str.zfill` which has special handling
for '+'/'-' in the string.

Examples
--------
&gt;&gt;&gt; s = pd.Series(['-1', '1', '1000', 10, np.nan])
&gt;&gt;&gt; s
0      -1
1       1
2    1000
3      10
4     NaN
dtype: object

Note that ``10`` and ``NaN`` are not strings, therefore they are
converted to ``NaN``. The minus sign in ``'-1'`` is treated as a
special character and the zero is added to the right of it
(:meth:`str.zfill` would have moved it to the left). ``1000``
remains unchanged as it is longer than `width`.

&gt;&gt;&gt; s.str.zfill(3)
0     -01
1     001
2    1000
3     NaN
4     NaN
dtype: object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1653</span>    <span class="keyword">def </span>zfill(self, width):</div>
<div class="line"><span class="lineno"> 1654</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">        Pad strings in the Series/Index by prepending &#39;0&#39; characters.</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">        Strings in the Series/Index are padded with &#39;0&#39; characters on the</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">        left of the string to reach a total string length  `width`. Strings</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">        in the Series/Index with length greater or equal to `width` are</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">        unchanged.</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">        width : int</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">            Minimum length of resulting string; strings with length less</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">            than `width` be prepended with &#39;0&#39; characters.</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">        Series/Index of objects.</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">        Series.str.rjust : Fills the left side of strings with an arbitrary</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">            character.</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">        Series.str.ljust : Fills the right side of strings with an arbitrary</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">            character.</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">        Series.str.pad : Fills the specified sides of strings with an arbitrary</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">            character.</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">        Series.str.center : Fills both sides of strings with an arbitrary</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">            character.</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">        Differs from :meth:`str.zfill` which has special handling</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        for &#39;+&#39;/&#39;-&#39; in the string.</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&#39;-1&#39;, &#39;1&#39;, &#39;1000&#39;, 10, np.nan])</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">        0      -1</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">        1       1</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">        2    1000</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">        3      10</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">        4     NaN</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">        Note that ``10`` and ``NaN`` are not strings, therefore they are</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">        converted to ``NaN``. The minus sign in ``&#39;-1&#39;`` is treated as a</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">        special character and the zero is added to the right of it</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">        (:meth:`str.zfill` would have moved it to the left). ``1000``</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">        remains unchanged as it is longer than `width`.</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">        &gt;&gt;&gt; s.str.zfill(3)</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral">        0     -01</span></div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">        1     001</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">        2    1000</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">        3     NaN</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">        4     NaN</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1713</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_integer(width):</div>
<div class="line"><span class="lineno"> 1714</span>            msg = f<span class="stringliteral">&quot;width must be of integer type, not {type(width).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 1715</span>            <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno"> 1716</span>        f = <span class="keyword">lambda</span> x: x.zfill(width)</div>
<div class="line"><span class="lineno"> 1717</span>        result = self._data.array._str_map(f)</div>
<div class="line"><span class="lineno"> 1718</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno"> 1719</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a332ded9906c1a558e652bc0de324044f" name="a332ded9906c1a558e652bc0de324044f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332ded9906c1a558e652bc0de324044f">&#9670;&#160;</a></span>_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32d58d6df988c955e7e925134eab4304" name="a32d58d6df988c955e7e925134eab4304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d58d6df988c955e7e925134eab4304">&#9670;&#160;</a></span>_doc_args</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.strings.accessor.StringMethods._doc_args = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e7fc992c7d77f8663db5f5ffcf95271" name="a1e7fc992c7d77f8663db5f5ffcf95271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7fc992c7d77f8663db5f5ffcf95271">&#9670;&#160;</a></span>_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78ba459ec6f86cb7982d51cd6afb7833" name="a78ba459ec6f86cb7982d51cd6afb7833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ba459ec6f86cb7982d51cd6afb7833">&#9670;&#160;</a></span>_inferred_dtype</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._inferred_dtype</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af62091cd5c2eade0a46408af23d74b31" name="af62091cd5c2eade0a46408af23d74b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62091cd5c2eade0a46408af23d74b31">&#9670;&#160;</a></span>_is_categorical</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._is_categorical</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0dc71a51d139037b6972858a419eb05" name="ab0dc71a51d139037b6972858a419eb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dc71a51d139037b6972858a419eb05">&#9670;&#160;</a></span>_is_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._is_string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade552f90a4da0a7e0d6f388dd40804b6" name="ade552f90a4da0a7e0d6f388dd40804b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade552f90a4da0a7e0d6f388dd40804b6">&#9670;&#160;</a></span>_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6449413b7c205c2f1c9028b9fab9900" name="aa6449413b7c205c2f1c9028b9fab9900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6449413b7c205c2f1c9028b9fab9900">&#9670;&#160;</a></span>_orig</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._orig</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a566226ec0fc52b59d1ad70e2a5ec7c78" name="a566226ec0fc52b59d1ad70e2a5ec7c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566226ec0fc52b59d1ad70e2a5ec7c78">&#9670;&#160;</a></span>_parent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods._parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3896754601ab3a1d1207169bcd35345" name="af3896754601ab3a1d1207169bcd35345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3896754601ab3a1d1207169bcd35345">&#9670;&#160;</a></span>isalnum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.isalnum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;isalnum&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;isalnum&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a25c4a17f5dadf8d1ad088a96fe9cf3df" name="a25c4a17f5dadf8d1ad088a96fe9cf3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c4a17f5dadf8d1ad088a96fe9cf3df">&#9670;&#160;</a></span>isalpha</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.isalpha</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;isalpha&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;isalpha&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="adbd620e0cfa64303c1a6a009628cd02f" name="adbd620e0cfa64303c1a6a009628cd02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd620e0cfa64303c1a6a009628cd02f">&#9670;&#160;</a></span>isdecimal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.isdecimal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;isdecimal&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;isdecimal&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cead0abdc04ffb30a67f76e0c323a39" name="a6cead0abdc04ffb30a67f76e0c323a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cead0abdc04ffb30a67f76e0c323a39">&#9670;&#160;</a></span>isdigit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.isdigit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;isdigit&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;isdigit&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a287f3ce8996b3fff51c9ec1a259d861f" name="a287f3ce8996b3fff51c9ec1a259d861f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287f3ce8996b3fff51c9ec1a259d861f">&#9670;&#160;</a></span>islower</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.islower</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;islower&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;islower&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a39f0c443280b2268e278d48f9dc5e881" name="a39f0c443280b2268e278d48f9dc5e881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f0c443280b2268e278d48f9dc5e881">&#9670;&#160;</a></span>isnumeric</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.isnumeric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;isnumeric&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;isnumeric&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab57427c35555368a1a7f67ffd94946d2" name="ab57427c35555368a1a7f67ffd94946d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57427c35555368a1a7f67ffd94946d2">&#9670;&#160;</a></span>isspace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.isspace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;isspace&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;isspace&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a55de6c3def43f8868ef4e6c99678dbc7" name="a55de6c3def43f8868ef4e6c99678dbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55de6c3def43f8868ef4e6c99678dbc7">&#9670;&#160;</a></span>istitle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.istitle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;istitle&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;istitle&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0a4333c1f2f88e028dec22c31e87d88" name="ad0a4333c1f2f88e028dec22c31e87d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a4333c1f2f88e028dec22c31e87d88">&#9670;&#160;</a></span>isupper</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.StringMethods.isupper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  _map_and_wrap(</div>
<div class="line">        <span class="stringliteral">&quot;isupper&quot;</span>, docstring=_shared_docs[<span class="stringliteral">&quot;ismethods&quot;</span>] % _doc_args[<span class="stringliteral">&quot;isupper&quot;</span>]</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/pandas/core/strings/<a class="el" href="strings_2accessor_8py.html">accessor.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
