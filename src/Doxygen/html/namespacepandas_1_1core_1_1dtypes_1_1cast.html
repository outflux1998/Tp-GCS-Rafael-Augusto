<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.dtypes.cast Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1dtypes.html">dtypes</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html">cast</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.dtypes.cast Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1dtypes_1_1cast_1_1_lossy_setitem_error.html">LossySetitemError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3e0546e41e53c96032a75703546ff4d9" id="r_a3e0546e41e53c96032a75703546ff4d9"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a3e0546e41e53c96032a75703546ff4d9">maybe_convert_platform</a> (list|tuple|range|np.ndarray|<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> values)</td></tr>
<tr class="separator:a3e0546e41e53c96032a75703546ff4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc27bce7e9bf8ceb512330d68b187c7" id="r_a0cc27bce7e9bf8ceb512330d68b187c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a0cc27bce7e9bf8ceb512330d68b187c7">is_nested_object</a> (obj)</td></tr>
<tr class="separator:a0cc27bce7e9bf8ceb512330d68b187c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5548d3d7c78d47e2d6565ae50509ff6" id="r_ae5548d3d7c78d47e2d6565ae50509ff6"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae5548d3d7c78d47e2d6565ae50509ff6">maybe_box_datetimelike</a> (Scalar value, Dtype|None dtype=None)</td></tr>
<tr class="separator:ae5548d3d7c78d47e2d6565ae50509ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c208f5001f5c389695f373d980d20be" id="r_a5c208f5001f5c389695f373d980d20be"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a5c208f5001f5c389695f373d980d20be">maybe_box_native</a> (Scalar value)</td></tr>
<tr class="separator:a5c208f5001f5c389695f373d980d20be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da75e27f6443a9c517c6211130c2a1" id="r_ab4da75e27f6443a9c517c6211130c2a1"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ab4da75e27f6443a9c517c6211130c2a1">_maybe_unbox_datetimelike</a> (Scalar value, DtypeObj dtype)</td></tr>
<tr class="separator:ab4da75e27f6443a9c517c6211130c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2c5942d245cb1b70edf8cc8427ee04" id="r_aad2c5942d245cb1b70edf8cc8427ee04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#aad2c5942d245cb1b70edf8cc8427ee04">_disallow_mismatched_datetimelike</a> (value, DtypeObj dtype)</td></tr>
<tr class="separator:aad2c5942d245cb1b70edf8cc8427ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356724beda43b3474c7ece06d38ef7a6" id="r_a356724beda43b3474c7ece06d38ef7a6"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a356724beda43b3474c7ece06d38ef7a6">maybe_downcast_to_dtype</a> (np.ndarray result, str|np.dtype dtype)</td></tr>
<tr class="separator:a356724beda43b3474c7ece06d38ef7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb5e241bc864174a15f96651417e4b" id="r_a17cb5e241bc864174a15f96651417e4b"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a17cb5e241bc864174a15f96651417e4b">maybe_downcast_to_dtype</a> (<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> result, str|np.dtype dtype)</td></tr>
<tr class="separator:a17cb5e241bc864174a15f96651417e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6d26ff44449313f1e33fd9d90d5294" id="r_acd6d26ff44449313f1e33fd9d90d5294"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#acd6d26ff44449313f1e33fd9d90d5294">maybe_downcast_to_dtype</a> (ArrayLike result, str|np.dtype dtype)</td></tr>
<tr class="separator:acd6d26ff44449313f1e33fd9d90d5294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d76dc239d7946e45554f32bf1ed4f2f" id="r_a0d76dc239d7946e45554f32bf1ed4f2f"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a0d76dc239d7946e45554f32bf1ed4f2f">maybe_downcast_numeric</a> (np.ndarray result, np.dtype dtype, bool do_round=False)</td></tr>
<tr class="separator:a0d76dc239d7946e45554f32bf1ed4f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c6ee07e6749105d874c4f76dc3e03d" id="r_a88c6ee07e6749105d874c4f76dc3e03d"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a88c6ee07e6749105d874c4f76dc3e03d">maybe_downcast_numeric</a> (<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> result, DtypeObj dtype, bool do_round=False)</td></tr>
<tr class="separator:a88c6ee07e6749105d874c4f76dc3e03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c6953eeceba193cc19b8181b38c0ee" id="r_a76c6953eeceba193cc19b8181b38c0ee"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a76c6953eeceba193cc19b8181b38c0ee">maybe_downcast_numeric</a> (ArrayLike result, DtypeObj dtype, bool do_round=False)</td></tr>
<tr class="separator:a76c6953eeceba193cc19b8181b38c0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e57b96cdcb0bf909cdbc091545b0fb" id="r_a45e57b96cdcb0bf909cdbc091545b0fb"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a45e57b96cdcb0bf909cdbc091545b0fb">maybe_cast_pointwise_result</a> (ArrayLike result, DtypeObj dtype, bool numeric_only=False, bool same_dtype=True)</td></tr>
<tr class="separator:a45e57b96cdcb0bf909cdbc091545b0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6a7fe82dc981d3a48511027abacefd" id="r_abc6a7fe82dc981d3a48511027abacefd"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#abc6a7fe82dc981d3a48511027abacefd">maybe_cast_to_extension_array</a> (type[<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>] cls, ArrayLike obj, ExtensionDtype|None dtype=None)</td></tr>
<tr class="separator:abc6a7fe82dc981d3a48511027abacefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93811896b8667a3834bf5634e9324bd0" id="r_a93811896b8667a3834bf5634e9324bd0"><td class="memItemLeft" align="right" valign="top">np.dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a93811896b8667a3834bf5634e9324bd0">ensure_dtype_can_hold_na</a> (np.dtype dtype)</td></tr>
<tr class="separator:a93811896b8667a3834bf5634e9324bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4255c5d74bd414ef1cc66c802b3cbbc" id="r_ae4255c5d74bd414ef1cc66c802b3cbbc"><td class="memItemLeft" align="right" valign="top">ExtensionDtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae4255c5d74bd414ef1cc66c802b3cbbc">ensure_dtype_can_hold_na</a> (ExtensionDtype dtype)</td></tr>
<tr class="separator:ae4255c5d74bd414ef1cc66c802b3cbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4269d6a9869c3377456fb7547c5ca3f8" id="r_a4269d6a9869c3377456fb7547c5ca3f8"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a4269d6a9869c3377456fb7547c5ca3f8">ensure_dtype_can_hold_na</a> (DtypeObj dtype)</td></tr>
<tr class="separator:a4269d6a9869c3377456fb7547c5ca3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f0326c6219165515fbe3f031dd31e0" id="r_a52f0326c6219165515fbe3f031dd31e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a52f0326c6219165515fbe3f031dd31e0">maybe_promote</a> (np.dtype dtype, fill_value=np.nan)</td></tr>
<tr class="separator:a52f0326c6219165515fbe3f031dd31e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc5a17afe923997b8f2cf3c50170490" id="r_afbc5a17afe923997b8f2cf3c50170490"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#afbc5a17afe923997b8f2cf3c50170490">_maybe_promote_cached</a> (dtype, fill_value, fill_value_type)</td></tr>
<tr class="separator:afbc5a17afe923997b8f2cf3c50170490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dc57d3cfd37b4a4c473c46c1801940" id="r_a80dc57d3cfd37b4a4c473c46c1801940"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a80dc57d3cfd37b4a4c473c46c1801940">_maybe_promote</a> (np.dtype dtype, fill_value=np.nan)</td></tr>
<tr class="separator:a80dc57d3cfd37b4a4c473c46c1801940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb094e1aa74b48c4d8d4fa8cd353f686" id="r_acb094e1aa74b48c4d8d4fa8cd353f686"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#acb094e1aa74b48c4d8d4fa8cd353f686">_ensure_dtype_type</a> (value, np.dtype dtype)</td></tr>
<tr class="separator:acb094e1aa74b48c4d8d4fa8cd353f686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09efe179d3e091c870e8e42cbaffa41" id="r_ab09efe179d3e091c870e8e42cbaffa41"><td class="memItemLeft" align="right" valign="top">tuple[DtypeObj, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ab09efe179d3e091c870e8e42cbaffa41">infer_dtype_from</a> (val, bool pandas_dtype=False)</td></tr>
<tr class="separator:ab09efe179d3e091c870e8e42cbaffa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6a13673d8105d668fcc911ca5ffba" id="r_a51c6a13673d8105d668fcc911ca5ffba"><td class="memItemLeft" align="right" valign="top">tuple[DtypeObj, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a51c6a13673d8105d668fcc911ca5ffba">infer_dtype_from_scalar</a> (val, bool pandas_dtype=False)</td></tr>
<tr class="separator:a51c6a13673d8105d668fcc911ca5ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5277fbc2b394cf46d7cf1d9e5cb33f" id="r_a7e5277fbc2b394cf46d7cf1d9e5cb33f"><td class="memItemLeft" align="right" valign="top">dict[Scalar, Scalar]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a7e5277fbc2b394cf46d7cf1d9e5cb33f">dict_compat</a> (dict[Scalar, Scalar] <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>)</td></tr>
<tr class="separator:a7e5277fbc2b394cf46d7cf1d9e5cb33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acde6340083817b93e3e3c65f4e1649" id="r_a6acde6340083817b93e3e3c65f4e1649"><td class="memItemLeft" align="right" valign="top">tuple[DtypeObj, ArrayLike]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a6acde6340083817b93e3e3c65f4e1649">infer_dtype_from_array</a> (arr, bool pandas_dtype=False)</td></tr>
<tr class="separator:a6acde6340083817b93e3e3c65f4e1649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ed8f39391afe46e055774dede2e86" id="r_a213ed8f39391afe46e055774dede2e86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a213ed8f39391afe46e055774dede2e86">_maybe_infer_dtype_type</a> (element)</td></tr>
<tr class="separator:a213ed8f39391afe46e055774dede2e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f07ece1cc06aa845bab6fc63bdc405" id="r_a19f07ece1cc06aa845bab6fc63bdc405"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae3e5050f68fa519a6bfa4a03c069fca2">NumpyArrayT</a>, Scalar]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a19f07ece1cc06aa845bab6fc63bdc405">maybe_upcast</a> (<a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae3e5050f68fa519a6bfa4a03c069fca2">NumpyArrayT</a> values, Scalar fill_value=np.nan, bool copy=False)</td></tr>
<tr class="separator:a19f07ece1cc06aa845bab6fc63bdc405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780a189e763d590e2da71efe5f47413d" id="r_a780a189e763d590e2da71efe5f47413d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a780a189e763d590e2da71efe5f47413d">invalidate_string_dtypes</a> (set[DtypeObj] dtype_set)</td></tr>
<tr class="separator:a780a189e763d590e2da71efe5f47413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5337ca30725c08229b9a598ed1d65989" id="r_a5337ca30725c08229b9a598ed1d65989"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a5337ca30725c08229b9a598ed1d65989">coerce_indexer_dtype</a> (indexer, categories)</td></tr>
<tr class="separator:a5337ca30725c08229b9a598ed1d65989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62553df99bf32375d2ff83b7f0427816" id="r_a62553df99bf32375d2ff83b7f0427816"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a62553df99bf32375d2ff83b7f0427816">soft_convert_objects</a> (np.ndarray values, bool datetime=True, bool numeric=True, bool timedelta=True, bool period=True, bool copy=True)</td></tr>
<tr class="separator:a62553df99bf32375d2ff83b7f0427816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ea35dfd0224b37df3e9a8775835a9" id="r_ad40ea35dfd0224b37df3e9a8775835a9"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ad40ea35dfd0224b37df3e9a8775835a9">convert_dtypes</a> (ArrayLike input_array, bool convert_string=True, bool convert_integer=True, bool convert_boolean=True, bool convert_floating=True)</td></tr>
<tr class="separator:ad40ea35dfd0224b37df3e9a8775835a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540813e524e656a13a54d36ce795a175" id="r_a540813e524e656a13a54d36ce795a175"><td class="memItemLeft" align="right" valign="top">np.ndarray|<a class="el" href="classpandas_1_1core_1_1arrays_1_1datetimes_1_1_datetime_array.html">DatetimeArray</a>|<a class="el" href="classpandas_1_1core_1_1arrays_1_1timedeltas_1_1_timedelta_array.html">TimedeltaArray</a>|<a class="el" href="classpandas_1_1core_1_1arrays_1_1period_1_1_period_array.html">PeriodArray</a>|<a class="el" href="classpandas_1_1core_1_1arrays_1_1interval_1_1_interval_array.html">IntervalArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a540813e524e656a13a54d36ce795a175">maybe_infer_to_datetimelike</a> (np.ndarray value)</td></tr>
<tr class="separator:a540813e524e656a13a54d36ce795a175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d134d3ebff8a083096c6a53fefe888" id="r_af5d134d3ebff8a083096c6a53fefe888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#af5d134d3ebff8a083096c6a53fefe888">maybe_cast_to_datetime</a> (<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>|np.ndarray|list value, DtypeObj|None dtype)</td></tr>
<tr class="separator:af5d134d3ebff8a083096c6a53fefe888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627ccf521987cc11e81a5a91f137a72e" id="r_a627ccf521987cc11e81a5a91f137a72e"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a627ccf521987cc11e81a5a91f137a72e">sanitize_to_nanoseconds</a> (np.ndarray values, bool copy=False)</td></tr>
<tr class="separator:a627ccf521987cc11e81a5a91f137a72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84e5b3d9cd324934c392a78eb4cf797" id="r_ae84e5b3d9cd324934c392a78eb4cf797"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae84e5b3d9cd324934c392a78eb4cf797">_ensure_nanosecond_dtype</a> (DtypeObj dtype)</td></tr>
<tr class="separator:ae84e5b3d9cd324934c392a78eb4cf797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3d960ca2e8e78effd6c036abf6b3f" id="r_a02c3d960ca2e8e78effd6c036abf6b3f"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a02c3d960ca2e8e78effd6c036abf6b3f">find_result_type</a> (ArrayLike left, Any right)</td></tr>
<tr class="separator:a02c3d960ca2e8e78effd6c036abf6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e74253b77ab1f7d6b2497aa2a3cbf39" id="r_a1e74253b77ab1f7d6b2497aa2a3cbf39"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a1e74253b77ab1f7d6b2497aa2a3cbf39">common_dtype_categorical_compat</a> (list[Index|ArrayLike] objs, DtypeObj dtype)</td></tr>
<tr class="separator:a1e74253b77ab1f7d6b2497aa2a3cbf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b073e156904577296121c10356d398" id="r_ac8b073e156904577296121c10356d398"><td class="memItemLeft" align="right" valign="top">np.dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ac8b073e156904577296121c10356d398">find_common_type</a> (list[np.dtype] types)</td></tr>
<tr class="separator:ac8b073e156904577296121c10356d398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c64570a6e0a10755625b6320e5def5" id="r_a56c64570a6e0a10755625b6320e5def5"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a56c64570a6e0a10755625b6320e5def5">find_common_type</a> (list[ExtensionDtype] types)</td></tr>
<tr class="separator:a56c64570a6e0a10755625b6320e5def5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261d5b1b4162e21dfbf3aed133d5c551" id="r_a261d5b1b4162e21dfbf3aed133d5c551"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a261d5b1b4162e21dfbf3aed133d5c551">find_common_type</a> (list[DtypeObj] types)</td></tr>
<tr class="separator:a261d5b1b4162e21dfbf3aed133d5c551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fe1aa9c59f05c2e11df516f36db80" id="r_a511fe1aa9c59f05c2e11df516f36db80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a511fe1aa9c59f05c2e11df516f36db80">find_common_type</a> (types)</td></tr>
<tr class="separator:a511fe1aa9c59f05c2e11df516f36db80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c7e71ae0da76fccac4af991e92e5d3" id="r_a84c7e71ae0da76fccac4af991e92e5d3"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a84c7e71ae0da76fccac4af991e92e5d3">construct_2d_arraylike_from_scalar</a> (Scalar value, int length, int width, np.dtype dtype, bool copy)</td></tr>
<tr class="separator:a84c7e71ae0da76fccac4af991e92e5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d5f69629ebae71a54401042c25c26a" id="r_aa5d5f69629ebae71a54401042c25c26a"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#aa5d5f69629ebae71a54401042c25c26a">construct_1d_arraylike_from_scalar</a> (Scalar value, int length, DtypeObj|None dtype)</td></tr>
<tr class="separator:aa5d5f69629ebae71a54401042c25c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e46426beac228fee7b9df4e5d468452" id="r_a7e46426beac228fee7b9df4e5d468452"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a7e46426beac228fee7b9df4e5d468452">_maybe_unbox_datetimelike_tz_deprecation</a> (Scalar value, DtypeObj dtype)</td></tr>
<tr class="separator:a7e46426beac228fee7b9df4e5d468452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d261c84ed6cd14ef570993c92a5d125" id="r_a3d261c84ed6cd14ef570993c92a5d125"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a3d261c84ed6cd14ef570993c92a5d125">construct_1d_object_array_from_listlike</a> (Sized values)</td></tr>
<tr class="separator:a3d261c84ed6cd14ef570993c92a5d125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac619cbe4b5bfd84803bbfa4e1c72a30c" id="r_ac619cbe4b5bfd84803bbfa4e1c72a30c"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ac619cbe4b5bfd84803bbfa4e1c72a30c">maybe_cast_to_integer_array</a> (list|np.ndarray arr, np.dtype dtype, bool copy=False)</td></tr>
<tr class="separator:ac619cbe4b5bfd84803bbfa4e1c72a30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b61269e681205ee89a035704a221f89" id="r_a5b61269e681205ee89a035704a221f89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a5b61269e681205ee89a035704a221f89">can_hold_element</a> (ArrayLike arr, Any element)</td></tr>
<tr class="separator:a5b61269e681205ee89a035704a221f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b8205415aa199b12a0de6bccfafc6d" id="r_af4b8205415aa199b12a0de6bccfafc6d"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#af4b8205415aa199b12a0de6bccfafc6d">np_can_hold_element</a> (np.dtype dtype, Any element)</td></tr>
<tr class="separator:af4b8205415aa199b12a0de6bccfafc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deb23ac8fe486513ff901070a681348" id="r_a1deb23ac8fe486513ff901070a681348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a1deb23ac8fe486513ff901070a681348">_dtype_can_hold_range</a> (range rng, np.dtype dtype)</td></tr>
<tr class="separator:a1deb23ac8fe486513ff901070a681348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0eab1ecf3ea5ae83d198a98efe5fa1c5" id="r_a0eab1ecf3ea5ae83d198a98efe5fa1c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a0eab1ecf3ea5ae83d198a98efe5fa1c5">_int8_max</a> = np.iinfo(np.int8).max</td></tr>
<tr class="separator:a0eab1ecf3ea5ae83d198a98efe5fa1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758379c1ffc315069babb46b2b7ad525" id="r_a758379c1ffc315069babb46b2b7ad525"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a758379c1ffc315069babb46b2b7ad525">_int16_max</a> = np.iinfo(np.int16).max</td></tr>
<tr class="separator:a758379c1ffc315069babb46b2b7ad525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741b08e58e9c60005f0b7ad9067fb88e" id="r_a741b08e58e9c60005f0b7ad9067fb88e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a741b08e58e9c60005f0b7ad9067fb88e">_int32_max</a> = np.iinfo(np.int32).max</td></tr>
<tr class="separator:a741b08e58e9c60005f0b7ad9067fb88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f43e69ba61548ca53fd55820dcd176" id="r_ad6f43e69ba61548ca53fd55820dcd176"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ad6f43e69ba61548ca53fd55820dcd176">_int64_max</a> = np.iinfo(np.int64).max</td></tr>
<tr class="separator:ad6f43e69ba61548ca53fd55820dcd176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98631a98b75ae98b505ecdb290c2c56d" id="r_a98631a98b75ae98b505ecdb290c2c56d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#a98631a98b75ae98b505ecdb290c2c56d">_dtype_obj</a> = np.dtype(object)</td></tr>
<tr class="separator:a98631a98b75ae98b505ecdb290c2c56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e5050f68fa519a6bfa4a03c069fca2" id="r_ae3e5050f68fa519a6bfa4a03c069fca2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae3e5050f68fa519a6bfa4a03c069fca2">NumpyArrayT</a> = TypeVar(&quot;NumpyArrayT&quot;, bound=np.ndarray)</td></tr>
<tr class="separator:ae3e5050f68fa519a6bfa4a03c069fca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Routines for casting.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aad2c5942d245cb1b70edf8cc8427ee04" name="aad2c5942d245cb1b70edf8cc8427ee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2c5942d245cb1b70edf8cc8427ee04">&#9670;&#160;</a></span>_disallow_mismatched_datetimelike()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._disallow_mismatched_datetimelike </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">numpy allows np.array(dt64values, dtype="timedelta64[ns]") and
vice-versa, but we do not want to allow this, so we need to
check explicitly
</pre> <div class="fragment"><div class="line"><span class="lineno">  234</span><span class="keyword">def </span>_disallow_mismatched_datetimelike(value, dtype: DtypeObj):</div>
<div class="line"><span class="lineno">  235</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    numpy allows np.array(dt64values, dtype=&quot;timedelta64[ns]&quot;) and</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    vice-versa, but we do not want to allow this, so we need to</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    check explicitly</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  240</span>    vdtype = getattr(value, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  241</span>    <span class="keywordflow">if</span> vdtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  242</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordflow">elif</span> (vdtype.kind == <span class="stringliteral">&quot;m&quot;</span> <span class="keywordflow">and</span> dtype.kind == <span class="stringliteral">&quot;M&quot;</span>) <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno">  244</span>        vdtype.kind == <span class="stringliteral">&quot;M&quot;</span> <span class="keywordflow">and</span> dtype.kind == <span class="stringliteral">&quot;m&quot;</span></div>
<div class="line"><span class="lineno">  245</span>    ):</div>
<div class="line"><span class="lineno">  246</span>        <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;Cannot cast {repr(value)} to {dtype}&quot;</span>)</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span> </div>
<div class="line"><span class="lineno">  249</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1deb23ac8fe486513ff901070a681348" name="a1deb23ac8fe486513ff901070a681348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deb23ac8fe486513ff901070a681348">&#9670;&#160;</a></span>_dtype_can_hold_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.dtypes.cast._dtype_can_hold_range </td>
          <td>(</td>
          <td class="paramtype">range&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">_maybe_infer_dtype_type infers to int64 (and float64 for very large endpoints),
but in many cases a range can be held by a smaller integer dtype.
Check if this is one of those cases.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2089</span><span class="keyword">def </span>_dtype_can_hold_range(rng: range, dtype: np.dtype) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2090</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">    _maybe_infer_dtype_type infers to int64 (and float64 for very large endpoints),</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral">    but in many cases a range can be held by a smaller integer dtype.</span></div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">    Check if this is one of those cases.</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2095</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(rng):</div>
<div class="line"><span class="lineno"> 2096</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2097</span>    <span class="keywordflow">return</span> np.can_cast(rng[0], dtype) <span class="keywordflow">and</span> np.can_cast(rng[-1], dtype)</div>
<div class="line"><span class="lineno"> 2098</span> </div>
<div class="line"><span class="lineno"> 2099</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acb094e1aa74b48c4d8d4fa8cd353f686" name="acb094e1aa74b48c4d8d4fa8cd353f686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb094e1aa74b48c4d8d4fa8cd353f686">&#9670;&#160;</a></span>_ensure_dtype_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._ensure_dtype_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure that the given value is an instance of the given dtype.

e.g. if out dtype is np.complex64_, we should have an instance of that
as opposed to a python complex object.

Parameters
----------
value : object
dtype : np.dtype

Returns
-------
object
</pre> <div class="fragment"><div class="line"><span class="lineno">  714</span><span class="keyword">def </span>_ensure_dtype_type(value, dtype: np.dtype):</div>
<div class="line"><span class="lineno">  715</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    Ensure that the given value is an instance of the given dtype.</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    e.g. if out dtype is np.complex64_, we should have an instance of that</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    as opposed to a python complex object.</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    value : object</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    dtype : np.dtype</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    object</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  730</span>    <span class="comment"># Start with exceptions in which we do _not_ cast to numpy types</span></div>
<div class="line"><span class="lineno">  731</span> </div>
<div class="line"><span class="lineno">  732</span>    <span class="keywordflow">if</span> dtype == _dtype_obj:</div>
<div class="line"><span class="lineno">  733</span>        <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno">  734</span> </div>
<div class="line"><span class="lineno">  735</span>    <span class="comment"># Note: before we get here we have already excluded isna(value)</span></div>
<div class="line"><span class="lineno">  736</span>    <span class="keywordflow">return</span> dtype.type(value)</div>
<div class="line"><span class="lineno">  737</span> </div>
<div class="line"><span class="lineno">  738</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae84e5b3d9cd324934c392a78eb4cf797" name="ae84e5b3d9cd324934c392a78eb4cf797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84e5b3d9cd324934c392a78eb4cf797">&#9670;&#160;</a></span>_ensure_nanosecond_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.dtypes.cast._ensure_nanosecond_dtype </td>
          <td>(</td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert dtypes with granularity less than nanosecond to nanosecond

&gt;&gt;&gt; _ensure_nanosecond_dtype(np.dtype("M8[s]"))
dtype('&lt;M8[ns]')

&gt;&gt;&gt; _ensure_nanosecond_dtype(np.dtype("m8[ps]"))
Traceback (most recent call last):
    ...
TypeError: cannot convert timedeltalike to dtype [timedelta64[ps]]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1439</span><span class="keyword">def </span>_ensure_nanosecond_dtype(dtype: DtypeObj) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno"> 1440</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    Convert dtypes with granularity less than nanosecond to nanosecond</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    &gt;&gt;&gt; _ensure_nanosecond_dtype(np.dtype(&quot;M8[s]&quot;))</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    dtype(&#39;&lt;M8[ns]&#39;)</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    &gt;&gt;&gt; _ensure_nanosecond_dtype(np.dtype(&quot;m8[ps]&quot;))</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">    TypeError: cannot convert timedeltalike to dtype [timedelta64[ps]]</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1451</span>    msg = (</div>
<div class="line"><span class="lineno"> 1452</span>        f<span class="stringliteral">&quot;The &#39;{dtype.name}&#39; dtype has no unit. &quot;</span></div>
<div class="line"><span class="lineno"> 1453</span>        f<span class="stringliteral">&quot;Please pass in &#39;{dtype.name}[ns]&#39; instead.&quot;</span></div>
<div class="line"><span class="lineno"> 1454</span>    )</div>
<div class="line"><span class="lineno"> 1455</span> </div>
<div class="line"><span class="lineno"> 1456</span>    <span class="comment"># unpack e.g. SparseDtype</span></div>
<div class="line"><span class="lineno"> 1457</span>    dtype = getattr(dtype, <span class="stringliteral">&quot;subtype&quot;</span>, dtype)</div>
<div class="line"><span class="lineno"> 1458</span> </div>
<div class="line"><span class="lineno"> 1459</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, np.dtype):</div>
<div class="line"><span class="lineno"> 1460</span>        <span class="comment"># i.e. datetime64tz</span></div>
<div class="line"><span class="lineno"> 1461</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1462</span> </div>
<div class="line"><span class="lineno"> 1463</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;M&quot;</span> <span class="keywordflow">and</span> dtype != DT64NS_DTYPE:</div>
<div class="line"><span class="lineno"> 1464</span>        <span class="comment"># pandas supports dtype whose granularity is less than [ns]</span></div>
<div class="line"><span class="lineno"> 1465</span>        <span class="comment"># e.g., [ps], [fs], [as]</span></div>
<div class="line"><span class="lineno"> 1466</span>        <span class="keywordflow">if</span> dtype &lt;= np.dtype(<span class="stringliteral">&quot;M8[ns]&quot;</span>):</div>
<div class="line"><span class="lineno"> 1467</span>            <span class="keywordflow">if</span> dtype.name == <span class="stringliteral">&quot;datetime64&quot;</span>:</div>
<div class="line"><span class="lineno"> 1468</span>                <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 1469</span>            dtype = DT64NS_DTYPE</div>
<div class="line"><span class="lineno"> 1470</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1471</span>            <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;cannot convert datetimelike to dtype [{dtype}]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1472</span> </div>
<div class="line"><span class="lineno"> 1473</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;m&quot;</span> <span class="keywordflow">and</span> dtype != TD64NS_DTYPE:</div>
<div class="line"><span class="lineno"> 1474</span>        <span class="comment"># pandas supports dtype whose granularity is less than [ns]</span></div>
<div class="line"><span class="lineno"> 1475</span>        <span class="comment"># e.g., [ps], [fs], [as]</span></div>
<div class="line"><span class="lineno"> 1476</span>        <span class="keywordflow">if</span> dtype &lt;= np.dtype(<span class="stringliteral">&quot;m8[ns]&quot;</span>):</div>
<div class="line"><span class="lineno"> 1477</span>            <span class="keywordflow">if</span> dtype.name == <span class="stringliteral">&quot;timedelta64&quot;</span>:</div>
<div class="line"><span class="lineno"> 1478</span>                <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 1479</span>            dtype = TD64NS_DTYPE</div>
<div class="line"><span class="lineno"> 1480</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1481</span>            <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;cannot convert timedeltalike to dtype [{dtype}]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1482</span>    <span class="keywordflow">return</span> dtype</div>
<div class="line"><span class="lineno"> 1483</span> </div>
<div class="line"><span class="lineno"> 1484</span> </div>
<div class="line"><span class="lineno"> 1485</span><span class="comment"># TODO: other value-dependent functions to standardize here include</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="comment">#  dtypes.concat.cast_to_common_type and Index._find_common_type_compat</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a213ed8f39391afe46e055774dede2e86" name="a213ed8f39391afe46e055774dede2e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213ed8f39391afe46e055774dede2e86">&#9670;&#160;</a></span>_maybe_infer_dtype_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._maybe_infer_dtype_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Try to infer an object's dtype, for use in arithmetic ops.

Uses `element.dtype` if that's available.
Objects implementing the iterator protocol are cast to a NumPy array,
and from there the array's type is used.

Parameters
----------
element : object
    Possibly has a `.dtype` attribute, and possibly the iterator
    protocol.

Returns
-------
tipo : type

Examples
--------
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Foo = namedtuple("Foo", "dtype")
&gt;&gt;&gt; _maybe_infer_dtype_type(Foo(np.dtype("i8")))
dtype('int64')
</pre> <div class="fragment"><div class="line"><span class="lineno">  919</span><span class="keyword">def </span>_maybe_infer_dtype_type(element):</div>
<div class="line"><span class="lineno">  920</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    Try to infer an object&#39;s dtype, for use in arithmetic ops.</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    Uses `element.dtype` if that&#39;s available.</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    Objects implementing the iterator protocol are cast to a NumPy array,</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    and from there the array&#39;s type is used.</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    element : object</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">        Possibly has a `.dtype` attribute, and possibly the iterator</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">        protocol.</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    tipo : type</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    &gt;&gt;&gt; from collections import namedtuple</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    &gt;&gt;&gt; Foo = namedtuple(&quot;Foo&quot;, &quot;dtype&quot;)</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    &gt;&gt;&gt; _maybe_infer_dtype_type(Foo(np.dtype(&quot;i8&quot;)))</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    dtype(&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  944</span>    tipo = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  945</span>    <span class="keywordflow">if</span> hasattr(element, <span class="stringliteral">&quot;dtype&quot;</span>):</div>
<div class="line"><span class="lineno">  946</span>        tipo = element.dtype</div>
<div class="line"><span class="lineno">  947</span>    <span class="keywordflow">elif</span> is_list_like(element):</div>
<div class="line"><span class="lineno">  948</span>        element = np.asarray(element)</div>
<div class="line"><span class="lineno">  949</span>        tipo = element.dtype</div>
<div class="line"><span class="lineno">  950</span>    <span class="keywordflow">return</span> tipo</div>
<div class="line"><span class="lineno">  951</span> </div>
<div class="line"><span class="lineno">  952</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a80dc57d3cfd37b4a4c473c46c1801940" name="a80dc57d3cfd37b4a4c473c46c1801940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dc57d3cfd37b4a4c473c46c1801940">&#9670;&#160;</a></span>_maybe_promote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._maybe_promote </td>
          <td>(</td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>np.nan</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  574</span><span class="keyword">def </span>_maybe_promote(dtype: np.dtype, fill_value=np.nan):</div>
<div class="line"><span class="lineno">  575</span>    <span class="comment"># The actual implementation of the function, use `maybe_promote` above for</span></div>
<div class="line"><span class="lineno">  576</span>    <span class="comment"># a cached version.</span></div>
<div class="line"><span class="lineno">  577</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_scalar(fill_value):</div>
<div class="line"><span class="lineno">  578</span>        <span class="comment"># with object dtype there is nothing to promote, and the user can</span></div>
<div class="line"><span class="lineno">  579</span>        <span class="comment">#  pass pretty much any weird fill_value they like</span></div>
<div class="line"><span class="lineno">  580</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_object_dtype(dtype):</div>
<div class="line"><span class="lineno">  581</span>            <span class="comment"># with object dtype there is nothing to promote, and the user can</span></div>
<div class="line"><span class="lineno">  582</span>            <span class="comment">#  pass pretty much any weird fill_value they like</span></div>
<div class="line"><span class="lineno">  583</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;fill_value must be a scalar&quot;</span>)</div>
<div class="line"><span class="lineno">  584</span>        dtype = _dtype_obj</div>
<div class="line"><span class="lineno">  585</span>        <span class="keywordflow">return</span> dtype, fill_value</div>
<div class="line"><span class="lineno">  586</span> </div>
<div class="line"><span class="lineno">  587</span>    kinds = [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]</div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">if</span> is_valid_na_for_dtype(fill_value, dtype) <span class="keywordflow">and</span> dtype.kind <span class="keywordflow">in</span> kinds:</div>
<div class="line"><span class="lineno">  589</span>        dtype = ensure_dtype_can_hold_na(dtype)</div>
<div class="line"><span class="lineno">  590</span>        fv = na_value_for_dtype(dtype)</div>
<div class="line"><span class="lineno">  591</span>        <span class="keywordflow">return</span> dtype, fv</div>
<div class="line"><span class="lineno">  592</span> </div>
<div class="line"><span class="lineno">  593</span>    <span class="keywordflow">elif</span> isinstance(dtype, CategoricalDtype):</div>
<div class="line"><span class="lineno">  594</span>        <span class="keywordflow">if</span> fill_value <span class="keywordflow">in</span> dtype.categories <span class="keywordflow">or</span> isna(fill_value):</div>
<div class="line"><span class="lineno">  595</span>            <span class="keywordflow">return</span> dtype, fill_value</div>
<div class="line"><span class="lineno">  596</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  597</span>            <span class="keywordflow">return</span> object, ensure_object(fill_value)</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span>    <span class="keywordflow">elif</span> isna(fill_value):</div>
<div class="line"><span class="lineno">  600</span>        dtype = _dtype_obj</div>
<div class="line"><span class="lineno">  601</span>        <span class="keywordflow">if</span> fill_value <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  602</span>            <span class="comment"># but we retain e.g. pd.NA</span></div>
<div class="line"><span class="lineno">  603</span>            fill_value = np.nan</div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">return</span> dtype, fill_value</div>
<div class="line"><span class="lineno">  605</span> </div>
<div class="line"><span class="lineno">  606</span>    <span class="comment"># returns tuple of (dtype, fill_value)</span></div>
<div class="line"><span class="lineno">  607</span>    <span class="keywordflow">if</span> issubclass(dtype.type, np.datetime64):</div>
<div class="line"><span class="lineno">  608</span>        inferred, fv = infer_dtype_from_scalar(fill_value, pandas_dtype=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  609</span>        <span class="keywordflow">if</span> inferred == dtype:</div>
<div class="line"><span class="lineno">  610</span>            <span class="keywordflow">return</span> dtype, fv</div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>        <span class="comment"># TODO(2.0): once this deprecation is enforced, this whole case</span></div>
<div class="line"><span class="lineno">  613</span>        <span class="comment"># becomes equivalent to:</span></div>
<div class="line"><span class="lineno">  614</span>        <span class="comment">#  dta = DatetimeArray._from_sequence([], dtype=&quot;M8[ns]&quot;)</span></div>
<div class="line"><span class="lineno">  615</span>        <span class="comment">#  try:</span></div>
<div class="line"><span class="lineno">  616</span>        <span class="comment">#      fv = dta._validate_setitem_value(fill_value)</span></div>
<div class="line"><span class="lineno">  617</span>        <span class="comment">#      return dta.dtype, fv</span></div>
<div class="line"><span class="lineno">  618</span>        <span class="comment">#  except (ValueError, TypeError):</span></div>
<div class="line"><span class="lineno">  619</span>        <span class="comment">#      return _dtype_obj, fill_value</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">if</span> isinstance(fill_value, date) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(fill_value, datetime):</div>
<div class="line"><span class="lineno">  621</span>            <span class="comment"># deprecate casting of date object to match infer_dtype_from_scalar</span></div>
<div class="line"><span class="lineno">  622</span>            <span class="comment">#  and DatetimeArray._validate_setitem_value</span></div>
<div class="line"><span class="lineno">  623</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  624</span>                fv = Timestamp(fill_value).to_datetime64()</div>
<div class="line"><span class="lineno">  625</span>            <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno">  626</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  627</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  628</span>                warnings.warn(</div>
<div class="line"><span class="lineno">  629</span>                    <span class="stringliteral">&quot;Using a `date` object for fill_value with `datetime64[ns]` &quot;</span></div>
<div class="line"><span class="lineno">  630</span>                    <span class="stringliteral">&quot;dtype is deprecated. In a future version, this will be cast &quot;</span></div>
<div class="line"><span class="lineno">  631</span>                    <span class="stringliteral">&quot;to object dtype. Pass `fill_value=Timestamp(date_obj)` instead.&quot;</span>,</div>
<div class="line"><span class="lineno">  632</span>                    FutureWarning,</div>
<div class="line"><span class="lineno">  633</span>                    stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  634</span>                )</div>
<div class="line"><span class="lineno">  635</span>                <span class="keywordflow">return</span> dtype, fv</div>
<div class="line"><span class="lineno">  636</span>        <span class="keywordflow">elif</span> isinstance(fill_value, str):</div>
<div class="line"><span class="lineno">  637</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  638</span>                <span class="comment"># explicitly wrap in str to convert np.str_</span></div>
<div class="line"><span class="lineno">  639</span>                fv = Timestamp(str(fill_value))</div>
<div class="line"><span class="lineno">  640</span>            <span class="keywordflow">except</span> (ValueError, TypeError):</div>
<div class="line"><span class="lineno">  641</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  642</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  643</span>                <span class="keywordflow">if</span> isna(fv) <span class="keywordflow">or</span> fv.tz <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  644</span>                    <span class="keywordflow">return</span> dtype, fv.asm8</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>        <span class="keywordflow">return</span> np.dtype(<span class="stringliteral">&quot;object&quot;</span>), fill_value</div>
<div class="line"><span class="lineno">  647</span> </div>
<div class="line"><span class="lineno">  648</span>    <span class="keywordflow">elif</span> issubclass(dtype.type, np.timedelta64):</div>
<div class="line"><span class="lineno">  649</span>        inferred, fv = infer_dtype_from_scalar(fill_value, pandas_dtype=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  650</span>        <span class="keywordflow">if</span> inferred == dtype:</div>
<div class="line"><span class="lineno">  651</span>            <span class="keywordflow">return</span> dtype, fv</div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span>        <span class="keywordflow">return</span> np.dtype(<span class="stringliteral">&quot;object&quot;</span>), fill_value</div>
<div class="line"><span class="lineno">  654</span> </div>
<div class="line"><span class="lineno">  655</span>    <span class="keywordflow">elif</span> is_float(fill_value):</div>
<div class="line"><span class="lineno">  656</span>        <span class="keywordflow">if</span> issubclass(dtype.type, np.bool_):</div>
<div class="line"><span class="lineno">  657</span>            dtype = np.dtype(np.object_)</div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span>        <span class="keywordflow">elif</span> issubclass(dtype.type, np.integer):</div>
<div class="line"><span class="lineno">  660</span>            dtype = np.dtype(np.float64)</div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span>        <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;f&quot;</span>:</div>
<div class="line"><span class="lineno">  663</span>            mst = np.min_scalar_type(fill_value)</div>
<div class="line"><span class="lineno">  664</span>            <span class="keywordflow">if</span> mst &gt; dtype:</div>
<div class="line"><span class="lineno">  665</span>                <span class="comment"># e.g. mst is np.float64 and dtype is np.float32</span></div>
<div class="line"><span class="lineno">  666</span>                dtype = mst</div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span>        <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;c&quot;</span>:</div>
<div class="line"><span class="lineno">  669</span>            mst = np.min_scalar_type(fill_value)</div>
<div class="line"><span class="lineno">  670</span>            dtype = np.promote_types(dtype, mst)</div>
<div class="line"><span class="lineno">  671</span> </div>
<div class="line"><span class="lineno">  672</span>    <span class="keywordflow">elif</span> is_bool(fill_value):</div>
<div class="line"><span class="lineno">  673</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> issubclass(dtype.type, np.bool_):</div>
<div class="line"><span class="lineno">  674</span>            dtype = np.dtype(np.object_)</div>
<div class="line"><span class="lineno">  675</span> </div>
<div class="line"><span class="lineno">  676</span>    <span class="keywordflow">elif</span> is_integer(fill_value):</div>
<div class="line"><span class="lineno">  677</span>        <span class="keywordflow">if</span> issubclass(dtype.type, np.bool_):</div>
<div class="line"><span class="lineno">  678</span>            dtype = np.dtype(np.object_)</div>
<div class="line"><span class="lineno">  679</span> </div>
<div class="line"><span class="lineno">  680</span>        <span class="keywordflow">elif</span> issubclass(dtype.type, np.integer):</div>
<div class="line"><span class="lineno">  681</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.can_cast(fill_value, dtype):</div>
<div class="line"><span class="lineno">  682</span>                <span class="comment"># upcast to prevent overflow</span></div>
<div class="line"><span class="lineno">  683</span>                mst = np.min_scalar_type(fill_value)</div>
<div class="line"><span class="lineno">  684</span>                dtype = np.promote_types(dtype, mst)</div>
<div class="line"><span class="lineno">  685</span>                <span class="keywordflow">if</span> dtype.kind == <span class="stringliteral">&quot;f&quot;</span>:</div>
<div class="line"><span class="lineno">  686</span>                    <span class="comment"># Case where we disagree with numpy</span></div>
<div class="line"><span class="lineno">  687</span>                    dtype = np.dtype(np.object_)</div>
<div class="line"><span class="lineno">  688</span> </div>
<div class="line"><span class="lineno">  689</span>    <span class="keywordflow">elif</span> is_complex(fill_value):</div>
<div class="line"><span class="lineno">  690</span>        <span class="keywordflow">if</span> issubclass(dtype.type, np.bool_):</div>
<div class="line"><span class="lineno">  691</span>            dtype = np.dtype(np.object_)</div>
<div class="line"><span class="lineno">  692</span> </div>
<div class="line"><span class="lineno">  693</span>        <span class="keywordflow">elif</span> issubclass(dtype.type, (np.integer, np.floating)):</div>
<div class="line"><span class="lineno">  694</span>            mst = np.min_scalar_type(fill_value)</div>
<div class="line"><span class="lineno">  695</span>            dtype = np.promote_types(dtype, mst)</div>
<div class="line"><span class="lineno">  696</span> </div>
<div class="line"><span class="lineno">  697</span>        <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;c&quot;</span>:</div>
<div class="line"><span class="lineno">  698</span>            mst = np.min_scalar_type(fill_value)</div>
<div class="line"><span class="lineno">  699</span>            <span class="keywordflow">if</span> mst &gt; dtype:</div>
<div class="line"><span class="lineno">  700</span>                <span class="comment"># e.g. mst is np.complex128 and dtype is np.complex64</span></div>
<div class="line"><span class="lineno">  701</span>                dtype = mst</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  704</span>        dtype = np.dtype(np.object_)</div>
<div class="line"><span class="lineno">  705</span> </div>
<div class="line"><span class="lineno">  706</span>    <span class="comment"># in case we have a string that looked like a number</span></div>
<div class="line"><span class="lineno">  707</span>    <span class="keywordflow">if</span> issubclass(dtype.type, (bytes, str)):</div>
<div class="line"><span class="lineno">  708</span>        dtype = np.dtype(np.object_)</div>
<div class="line"><span class="lineno">  709</span> </div>
<div class="line"><span class="lineno">  710</span>    fill_value = _ensure_dtype_type(fill_value, dtype)</div>
<div class="line"><span class="lineno">  711</span>    <span class="keywordflow">return</span> dtype, fill_value</div>
<div class="line"><span class="lineno">  712</span> </div>
<div class="line"><span class="lineno">  713</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afbc5a17afe923997b8f2cf3c50170490" name="afbc5a17afe923997b8f2cf3c50170490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc5a17afe923997b8f2cf3c50170490">&#9670;&#160;</a></span>_maybe_promote_cached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._maybe_promote_cached </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  567</span><span class="keyword">def </span>_maybe_promote_cached(dtype, fill_value, fill_value_type):</div>
<div class="line"><span class="lineno">  568</span>    <span class="comment"># The cached version of _maybe_promote below</span></div>
<div class="line"><span class="lineno">  569</span>    <span class="comment"># This also use fill_value_type as (unused) argument to use this in the</span></div>
<div class="line"><span class="lineno">  570</span>    <span class="comment"># cache lookup -&gt; to differentiate 1 and True</span></div>
<div class="line"><span class="lineno">  571</span>    <span class="keywordflow">return</span> _maybe_promote(dtype, fill_value)</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4da75e27f6443a9c517c6211130c2a1" name="ab4da75e27f6443a9c517c6211130c2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4da75e27f6443a9c517c6211130c2a1">&#9670;&#160;</a></span>_maybe_unbox_datetimelike()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Scalar pandas.core.dtypes.cast._maybe_unbox_datetimelike </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a Timedelta or Timestamp to timedelta64 or datetime64 for setting
into a numpy array.  Failing to unbox would risk dropping nanoseconds.

Notes
-----
Caller is responsible for checking dtype.kind in ["m", "M"]
</pre> <div class="fragment"><div class="line"><span class="lineno">  208</span><span class="keyword">def </span>_maybe_unbox_datetimelike(value: Scalar, dtype: DtypeObj) -&gt; Scalar:</div>
<div class="line"><span class="lineno">  209</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    Convert a Timedelta or Timestamp to timedelta64 or datetime64 for setting</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    into a numpy array.  Failing to unbox would risk dropping nanoseconds.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    Caller is responsible for checking dtype.kind in [&quot;m&quot;, &quot;M&quot;]</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  217</span>    <span class="keywordflow">if</span> is_valid_na_for_dtype(value, dtype):</div>
<div class="line"><span class="lineno">  218</span>        <span class="comment"># GH#36541: can&#39;t fill array directly with pd.NaT</span></div>
<div class="line"><span class="lineno">  219</span>        <span class="comment"># &gt; np.empty(10, dtype=&quot;datetime64[64]&quot;).fill(pd.NaT)</span></div>
<div class="line"><span class="lineno">  220</span>        <span class="comment"># ValueError: cannot convert float NaN to integer</span></div>
<div class="line"><span class="lineno">  221</span>        value = dtype.type(<span class="stringliteral">&quot;NaT&quot;</span>, <span class="stringliteral">&quot;ns&quot;</span>)</div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">elif</span> isinstance(value, Timestamp):</div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">if</span> value.tz <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  224</span>            value = value.to_datetime64()</div>
<div class="line"><span class="lineno">  225</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(dtype, DatetimeTZDtype):</div>
<div class="line"><span class="lineno">  226</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Cannot unbox tzaware Timestamp to tznaive dtype&quot;</span>)</div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">elif</span> isinstance(value, Timedelta):</div>
<div class="line"><span class="lineno">  228</span>        value = value.to_timedelta64()</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>    _disallow_mismatched_datetimelike(value, dtype)</div>
<div class="line"><span class="lineno">  231</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno">  232</span> </div>
<div class="line"><span class="lineno">  233</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e46426beac228fee7b9df4e5d468452" name="a7e46426beac228fee7b9df4e5d468452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e46426beac228fee7b9df4e5d468452">&#9670;&#160;</a></span>_maybe_unbox_datetimelike_tz_deprecation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._maybe_unbox_datetimelike_tz_deprecation </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wrap _maybe_unbox_datetimelike with a check for a timezone-aware Timestamp
along with a timezone-naive datetime64 dtype, which is deprecated.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1725</span><span class="keyword">def </span>_maybe_unbox_datetimelike_tz_deprecation(value: Scalar, dtype: DtypeObj):</div>
<div class="line"><span class="lineno"> 1726</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">    Wrap _maybe_unbox_datetimelike with a check for a timezone-aware Timestamp</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">    along with a timezone-naive datetime64 dtype, which is deprecated.</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1730</span>    <span class="comment"># Caller is responsible for checking dtype.kind in [&quot;m&quot;, &quot;M&quot;]</span></div>
<div class="line"><span class="lineno"> 1731</span> </div>
<div class="line"><span class="lineno"> 1732</span>    <span class="keywordflow">if</span> isinstance(value, datetime):</div>
<div class="line"><span class="lineno"> 1733</span>        <span class="comment"># we dont want to box dt64, in particular datetime64(&quot;NaT&quot;)</span></div>
<div class="line"><span class="lineno"> 1734</span>        value = maybe_box_datetimelike(value, dtype)</div>
<div class="line"><span class="lineno"> 1735</span> </div>
<div class="line"><span class="lineno"> 1736</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1737</span>        value = _maybe_unbox_datetimelike(value, dtype)</div>
<div class="line"><span class="lineno"> 1738</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1739</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1740</span>            isinstance(value, Timestamp)</div>
<div class="line"><span class="lineno"> 1741</span>            <span class="keywordflow">and</span> value.tzinfo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1742</span>            <span class="keywordflow">and</span> isinstance(dtype, np.dtype)</div>
<div class="line"><span class="lineno"> 1743</span>            <span class="keywordflow">and</span> dtype.kind == <span class="stringliteral">&quot;M&quot;</span></div>
<div class="line"><span class="lineno"> 1744</span>        ):</div>
<div class="line"><span class="lineno"> 1745</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1746</span>                <span class="stringliteral">&quot;Data is timezone-aware. Converting &quot;</span></div>
<div class="line"><span class="lineno"> 1747</span>                <span class="stringliteral">&quot;timezone-aware data to timezone-naive by &quot;</span></div>
<div class="line"><span class="lineno"> 1748</span>                <span class="stringliteral">&quot;passing dtype=&#39;datetime64[ns]&#39; to &quot;</span></div>
<div class="line"><span class="lineno"> 1749</span>                <span class="stringliteral">&quot;DataFrame or Series is deprecated and will &quot;</span></div>
<div class="line"><span class="lineno"> 1750</span>                <span class="stringliteral">&quot;raise in a future version. Use &quot;</span></div>
<div class="line"><span class="lineno"> 1751</span>                <span class="stringliteral">&quot;`pd.Series(values).dt.tz_localize(None)` &quot;</span></div>
<div class="line"><span class="lineno"> 1752</span>                <span class="stringliteral">&quot;instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1753</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 1754</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1755</span>            )</div>
<div class="line"><span class="lineno"> 1756</span>            new_value = value.tz_localize(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1757</span>            <span class="keywordflow">return</span> _maybe_unbox_datetimelike(new_value, dtype)</div>
<div class="line"><span class="lineno"> 1758</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1759</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 1760</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno"> 1761</span> </div>
<div class="line"><span class="lineno"> 1762</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b61269e681205ee89a035704a221f89" name="a5b61269e681205ee89a035704a221f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b61269e681205ee89a035704a221f89">&#9670;&#160;</a></span>can_hold_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.dtypes.cast.can_hold_element </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Can we do an inplace setitem with this element in an array with this dtype?

Parameters
----------
arr : np.ndarray or ExtensionArray
element : Any

Returns
-------
bool
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1891</span><span class="keyword">def </span>can_hold_element(arr: ArrayLike, element: Any) -&gt; bool:</div>
<div class="line"><span class="lineno"> 1892</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">    Can we do an inplace setitem with this element in an array with this dtype?</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    arr : np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">    element : Any</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">    bool</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1904</span>    dtype = arr.dtype</div>
<div class="line"><span class="lineno"> 1905</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, np.dtype) <span class="keywordflow">or</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1906</span>        <span class="keywordflow">if</span> isinstance(dtype, (PeriodDtype, IntervalDtype, DatetimeTZDtype, np.dtype)):</div>
<div class="line"><span class="lineno"> 1907</span>            <span class="comment"># np.dtype here catches datetime64ns and timedelta64ns; we assume</span></div>
<div class="line"><span class="lineno"> 1908</span>            <span class="comment">#  in this case that we have DatetimeArray/TimedeltaArray</span></div>
<div class="line"><span class="lineno"> 1909</span>            arr = cast(</div>
<div class="line"><span class="lineno"> 1910</span>                <span class="stringliteral">&quot;PeriodArray | DatetimeArray | TimedeltaArray | IntervalArray&quot;</span>, arr</div>
<div class="line"><span class="lineno"> 1911</span>            )</div>
<div class="line"><span class="lineno"> 1912</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1913</span>                arr._validate_setitem_value(element)</div>
<div class="line"><span class="lineno"> 1914</span>                <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1915</span>            <span class="keywordflow">except</span> (ValueError, TypeError):</div>
<div class="line"><span class="lineno"> 1916</span>                <span class="comment"># TODO(2.0): stop catching ValueError for tzaware, see</span></div>
<div class="line"><span class="lineno"> 1917</span>                <span class="comment">#  _catch_deprecated_value_error</span></div>
<div class="line"><span class="lineno"> 1918</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1919</span> </div>
<div class="line"><span class="lineno"> 1920</span>        <span class="comment"># This is technically incorrect, but maintains the behavior of</span></div>
<div class="line"><span class="lineno"> 1921</span>        <span class="comment"># ExtensionBlock._can_hold_element</span></div>
<div class="line"><span class="lineno"> 1922</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1923</span> </div>
<div class="line"><span class="lineno"> 1924</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1925</span>        np_can_hold_element(dtype, element)</div>
<div class="line"><span class="lineno"> 1926</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1927</span>    <span class="keywordflow">except</span> (TypeError, LossySetitemError):</div>
<div class="line"><span class="lineno"> 1928</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1929</span> </div>
<div class="line"><span class="lineno"> 1930</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5337ca30725c08229b9a598ed1d65989" name="a5337ca30725c08229b9a598ed1d65989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5337ca30725c08229b9a598ed1d65989">&#9670;&#160;</a></span>coerce_indexer_dtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.dtypes.cast.coerce_indexer_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>categories</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">coerce the indexer input array to the smallest dtype possible</pre> <div class="fragment"><div class="line"><span class="lineno"> 1004</span><span class="keyword">def </span>coerce_indexer_dtype(indexer, categories) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1005</span>    <span class="stringliteral">&quot;&quot;&quot;coerce the indexer input array to the smallest dtype possible&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1006</span>    length = len(categories)</div>
<div class="line"><span class="lineno"> 1007</span>    <span class="keywordflow">if</span> length &lt; _int8_max:</div>
<div class="line"><span class="lineno"> 1008</span>        <span class="keywordflow">return</span> ensure_int8(indexer)</div>
<div class="line"><span class="lineno"> 1009</span>    <span class="keywordflow">elif</span> length &lt; _int16_max:</div>
<div class="line"><span class="lineno"> 1010</span>        <span class="keywordflow">return</span> ensure_int16(indexer)</div>
<div class="line"><span class="lineno"> 1011</span>    <span class="keywordflow">elif</span> length &lt; _int32_max:</div>
<div class="line"><span class="lineno"> 1012</span>        <span class="keywordflow">return</span> ensure_int32(indexer)</div>
<div class="line"><span class="lineno"> 1013</span>    <span class="keywordflow">return</span> ensure_int64(indexer)</div>
<div class="line"><span class="lineno"> 1014</span> </div>
<div class="line"><span class="lineno"> 1015</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e74253b77ab1f7d6b2497aa2a3cbf39" name="a1e74253b77ab1f7d6b2497aa2a3cbf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e74253b77ab1f7d6b2497aa2a3cbf39">&#9670;&#160;</a></span>common_dtype_categorical_compat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.dtypes.cast.common_dtype_categorical_compat </td>
          <td>(</td>
          <td class="paramtype">list[Index | ArrayLike]&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj
&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Update the result of find_common_type to account for NAs in a Categorical.

Parameters
----------
objs : list[np.ndarray | ExtensionArray | Index]
dtype : np.dtype or ExtensionDtype

Returns
-------
np.dtype or ExtensionDtype
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1538</span>) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno"> 1539</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    Update the result of find_common_type to account for NAs in a Categorical.</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    objs : list[np.ndarray | ExtensionArray | Index]</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    dtype : np.dtype or ExtensionDtype</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    np.dtype or ExtensionDtype</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1551</span>    <span class="comment"># GH#38240</span></div>
<div class="line"><span class="lineno"> 1552</span> </div>
<div class="line"><span class="lineno"> 1553</span>    <span class="comment"># TODO: more generally, could do `not can_hold_na(dtype)`</span></div>
<div class="line"><span class="lineno"> 1554</span>    <span class="keywordflow">if</span> isinstance(dtype, np.dtype) <span class="keywordflow">and</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1555</span> </div>
<div class="line"><span class="lineno"> 1556</span>        <span class="keywordflow">for</span> obj <span class="keywordflow">in</span> objs:</div>
<div class="line"><span class="lineno"> 1557</span>            <span class="comment"># We don&#39;t want to accientally allow e.g. &quot;categorical&quot; str here</span></div>
<div class="line"><span class="lineno"> 1558</span>            obj_dtype = getattr(obj, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1559</span>            <span class="keywordflow">if</span> isinstance(obj_dtype, CategoricalDtype):</div>
<div class="line"><span class="lineno"> 1560</span>                <span class="keywordflow">if</span> isinstance(obj, ABCIndex):</div>
<div class="line"><span class="lineno"> 1561</span>                    <span class="comment"># This check may already be cached</span></div>
<div class="line"><span class="lineno"> 1562</span>                    hasnas = obj.hasnans</div>
<div class="line"><span class="lineno"> 1563</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1564</span>                    <span class="comment"># Categorical</span></div>
<div class="line"><span class="lineno"> 1565</span>                    hasnas = cast(<span class="stringliteral">&quot;Categorical&quot;</span>, obj)._hasna</div>
<div class="line"><span class="lineno"> 1566</span> </div>
<div class="line"><span class="lineno"> 1567</span>                <span class="keywordflow">if</span> hasnas:</div>
<div class="line"><span class="lineno"> 1568</span>                    <span class="comment"># see test_union_int_categorical_with_nan</span></div>
<div class="line"><span class="lineno"> 1569</span>                    dtype = np.dtype(np.float64)</div>
<div class="line"><span class="lineno"> 1570</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1571</span>    <span class="keywordflow">return</span> dtype</div>
<div class="line"><span class="lineno"> 1572</span> </div>
<div class="line"><span class="lineno"> 1573</span> </div>
<div class="line"><span class="lineno"> 1574</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5d5f69629ebae71a54401042c25c26a" name="aa5d5f69629ebae71a54401042c25c26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d5f69629ebae71a54401042c25c26a">&#9670;&#160;</a></span>construct_1d_arraylike_from_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.construct_1d_arraylike_from_scalar </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj | None
&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">create a np.ndarray / pandas type of specified shape and dtype
filled with values

Parameters
----------
value : scalar value
length : int
dtype : pandas_dtype or np.dtype

Returns
-------
np.ndarray / pandas type of length, filled with value</pre> <div class="fragment"><div class="line"><span class="lineno"> 1675</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1676</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    create a np.ndarray / pandas type of specified shape and dtype</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    filled with values</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">    value : scalar value</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">    length : int</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    dtype : pandas_dtype or np.dtype</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">    np.ndarray / pandas type of length, filled with value</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1691</span> </div>
<div class="line"><span class="lineno"> 1692</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1693</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1694</span>            dtype, value = infer_dtype_from_scalar(value, pandas_dtype=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1695</span>        <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno"> 1696</span>            dtype = _dtype_obj</div>
<div class="line"><span class="lineno"> 1697</span> </div>
<div class="line"><span class="lineno"> 1698</span>    <span class="keywordflow">if</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno"> 1699</span>        cls = dtype.construct_array_type()</div>
<div class="line"><span class="lineno"> 1700</span>        seq = [] <span class="keywordflow">if</span> length == 0 <span class="keywordflow">else</span> [value]</div>
<div class="line"><span class="lineno"> 1701</span>        subarr = cls._from_sequence(seq, dtype=dtype).repeat(length)</div>
<div class="line"><span class="lineno"> 1702</span> </div>
<div class="line"><span class="lineno"> 1703</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1704</span> </div>
<div class="line"><span class="lineno"> 1705</span>        <span class="keywordflow">if</span> length <span class="keywordflow">and</span> is_integer_dtype(dtype) <span class="keywordflow">and</span> isna(value):</div>
<div class="line"><span class="lineno"> 1706</span>            <span class="comment"># coerce if we have nan for an integer dtype</span></div>
<div class="line"><span class="lineno"> 1707</span>            dtype = np.dtype(<span class="stringliteral">&quot;float64&quot;</span>)</div>
<div class="line"><span class="lineno"> 1708</span>        <span class="keywordflow">elif</span> isinstance(dtype, np.dtype) <span class="keywordflow">and</span> dtype.kind <span class="keywordflow">in</span> (<span class="stringliteral">&quot;U&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>):</div>
<div class="line"><span class="lineno"> 1709</span>            <span class="comment"># we need to coerce to object dtype to avoid</span></div>
<div class="line"><span class="lineno"> 1710</span>            <span class="comment"># to allow numpy to take our string as a scalar value</span></div>
<div class="line"><span class="lineno"> 1711</span>            dtype = np.dtype(<span class="stringliteral">&quot;object&quot;</span>)</div>
<div class="line"><span class="lineno"> 1712</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isna(value):</div>
<div class="line"><span class="lineno"> 1713</span>                value = ensure_str(value)</div>
<div class="line"><span class="lineno"> 1714</span>        <span class="keywordflow">elif</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;M&quot;</span>, <span class="stringliteral">&quot;m&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1715</span>            value = _maybe_unbox_datetimelike_tz_deprecation(value, dtype)</div>
<div class="line"><span class="lineno"> 1716</span> </div>
<div class="line"><span class="lineno"> 1717</span>        subarr = np.empty(length, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1718</span>        <span class="keywordflow">if</span> length:</div>
<div class="line"><span class="lineno"> 1719</span>            <span class="comment"># GH 47391: numpy &gt; 1.24 will raise filling np.nan into int dtypes</span></div>
<div class="line"><span class="lineno"> 1720</span>            subarr.fill(value)</div>
<div class="line"><span class="lineno"> 1721</span> </div>
<div class="line"><span class="lineno"> 1722</span>    <span class="keywordflow">return</span> subarr</div>
<div class="line"><span class="lineno"> 1723</span> </div>
<div class="line"><span class="lineno"> 1724</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d261c84ed6cd14ef570993c92a5d125" name="a3d261c84ed6cd14ef570993c92a5d125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d261c84ed6cd14ef570993c92a5d125">&#9670;&#160;</a></span>construct_1d_object_array_from_listlike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.dtypes.cast.construct_1d_object_array_from_listlike </td>
          <td>(</td>
          <td class="paramtype">Sized&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform any list-like object in a 1-dimensional numpy array of object
dtype.

Parameters
----------
values : any iterable which has a len()

Raises
------
TypeError
    * If `values` does not have a len()

Returns
-------
1-dimensional numpy array of dtype object
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1763</span><span class="keyword">def </span>construct_1d_object_array_from_listlike(values: Sized) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1764</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    Transform any list-like object in a 1-dimensional numpy array of object</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">    dtype.</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral">    values : any iterable which has a len()</span></div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">        * If `values` does not have a len()</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">    1-dimensional numpy array of dtype object</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1781</span>    <span class="comment"># numpy will try to interpret nested lists as further dimensions, hence</span></div>
<div class="line"><span class="lineno"> 1782</span>    <span class="comment"># making a 1D array that contains list-likes is a bit tricky:</span></div>
<div class="line"><span class="lineno"> 1783</span>    result = np.empty(len(values), dtype=<span class="stringliteral">&quot;object&quot;</span>)</div>
<div class="line"><span class="lineno"> 1784</span>    result[:] = values</div>
<div class="line"><span class="lineno"> 1785</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1786</span> </div>
<div class="line"><span class="lineno"> 1787</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a84c7e71ae0da76fccac4af991e92e5d3" name="a84c7e71ae0da76fccac4af991e92e5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c7e71ae0da76fccac4af991e92e5d3">&#9670;&#160;</a></span>construct_2d_arraylike_from_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.dtypes.cast.construct_2d_arraylike_from_scalar </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1646</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1647</span> </div>
<div class="line"><span class="lineno"> 1648</span>    shape = (length, width)</div>
<div class="line"><span class="lineno"> 1649</span> </div>
<div class="line"><span class="lineno"> 1650</span>    <span class="keywordflow">if</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1651</span>        value = _maybe_unbox_datetimelike_tz_deprecation(value, dtype)</div>
<div class="line"><span class="lineno"> 1652</span>    <span class="keywordflow">elif</span> dtype == _dtype_obj:</div>
<div class="line"><span class="lineno"> 1653</span>        <span class="keywordflow">if</span> isinstance(value, (np.timedelta64, np.datetime64)):</div>
<div class="line"><span class="lineno"> 1654</span>            <span class="comment"># calling np.array below would cast to pytimedelta/pydatetime</span></div>
<div class="line"><span class="lineno"> 1655</span>            out = np.empty(shape, dtype=object)</div>
<div class="line"><span class="lineno"> 1656</span>            out.fill(value)</div>
<div class="line"><span class="lineno"> 1657</span>            <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1658</span> </div>
<div class="line"><span class="lineno"> 1659</span>    <span class="comment"># Attempt to coerce to a numpy array</span></div>
<div class="line"><span class="lineno"> 1660</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1661</span>        arr = np.array(value, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno"> 1662</span>    <span class="keywordflow">except</span> (ValueError, TypeError) <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1663</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1664</span>            f<span class="stringliteral">&quot;DataFrame constructor called with incompatible data and dtype: {err}&quot;</span></div>
<div class="line"><span class="lineno"> 1665</span>        ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 1666</span> </div>
<div class="line"><span class="lineno"> 1667</span>    <span class="keywordflow">if</span> arr.ndim != 0:</div>
<div class="line"><span class="lineno"> 1668</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;DataFrame constructor not properly called!&quot;</span>)</div>
<div class="line"><span class="lineno"> 1669</span> </div>
<div class="line"><span class="lineno"> 1670</span>    <span class="keywordflow">return</span> np.full(shape, arr)</div>
<div class="line"><span class="lineno"> 1671</span> </div>
<div class="line"><span class="lineno"> 1672</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad40ea35dfd0224b37df3e9a8775835a9" name="ad40ea35dfd0224b37df3e9a8775835a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40ea35dfd0224b37df3e9a8775835a9">&#9670;&#160;</a></span>convert_dtypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.dtypes.cast.convert_dtypes </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>input_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>convert_string</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>convert_integer</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>convert_boolean</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>convert_floating</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert objects to best possible type, and optionally,
to types supporting ``pd.NA``.

Parameters
----------
input_array : ExtensionArray or np.ndarray
convert_string : bool, default True
    Whether object dtypes should be converted to ``StringDtype()``.
convert_integer : bool, default True
    Whether, if possible, conversion can be done to integer extension types.
convert_boolean : bool, defaults True
    Whether object dtypes should be converted to ``BooleanDtypes()``.
convert_floating : bool, defaults True
    Whether, if possible, conversion can be done to floating extension types.
    If `convert_integer` is also True, preference will be give to integer
    dtypes if the floats can be faithfully casted to integers.

Returns
-------
np.dtype, or ExtensionDtype
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1082</span>) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno"> 1083</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    Convert objects to best possible type, and optionally,</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">    to types supporting ``pd.NA``.</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    input_array : ExtensionArray or np.ndarray</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    convert_string : bool, default True</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">        Whether object dtypes should be converted to ``StringDtype()``.</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    convert_integer : bool, default True</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">        Whether, if possible, conversion can be done to integer extension types.</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    convert_boolean : bool, defaults True</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">        Whether object dtypes should be converted to ``BooleanDtypes()``.</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">    convert_floating : bool, defaults True</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">        Whether, if possible, conversion can be done to floating extension types.</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">        If `convert_integer` is also True, preference will be give to integer</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">        dtypes if the floats can be faithfully casted to integers.</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    np.dtype, or ExtensionDtype</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1105</span>    inferred_dtype: str | DtypeObj</div>
<div class="line"><span class="lineno"> 1106</span> </div>
<div class="line"><span class="lineno"> 1107</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1108</span>        convert_string <span class="keywordflow">or</span> convert_integer <span class="keywordflow">or</span> convert_boolean <span class="keywordflow">or</span> convert_floating</div>
<div class="line"><span class="lineno"> 1109</span>    ) <span class="keywordflow">and</span> isinstance(input_array, np.ndarray):</div>
<div class="line"><span class="lineno"> 1110</span> </div>
<div class="line"><span class="lineno"> 1111</span>        <span class="keywordflow">if</span> is_object_dtype(input_array.dtype):</div>
<div class="line"><span class="lineno"> 1112</span>            inferred_dtype = lib.infer_dtype(input_array)</div>
<div class="line"><span class="lineno"> 1113</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1114</span>            inferred_dtype = input_array.dtype</div>
<div class="line"><span class="lineno"> 1115</span> </div>
<div class="line"><span class="lineno"> 1116</span>        <span class="keywordflow">if</span> is_string_dtype(inferred_dtype):</div>
<div class="line"><span class="lineno"> 1117</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> convert_string <span class="keywordflow">or</span> inferred_dtype == <span class="stringliteral">&quot;bytes&quot;</span>:</div>
<div class="line"><span class="lineno"> 1118</span>                <span class="keywordflow">return</span> input_array.dtype</div>
<div class="line"><span class="lineno"> 1119</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1120</span>                <span class="keywordflow">return</span> pandas_dtype(<span class="stringliteral">&quot;string&quot;</span>)</div>
<div class="line"><span class="lineno"> 1121</span> </div>
<div class="line"><span class="lineno"> 1122</span>        <span class="keywordflow">if</span> convert_integer:</div>
<div class="line"><span class="lineno"> 1123</span>            target_int_dtype = pandas_dtype(<span class="stringliteral">&quot;Int64&quot;</span>)</div>
<div class="line"><span class="lineno"> 1124</span> </div>
<div class="line"><span class="lineno"> 1125</span>            <span class="keywordflow">if</span> is_integer_dtype(input_array.dtype):</div>
<div class="line"><span class="lineno"> 1126</span>                <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1integer.html">pandas.core.arrays.integer</a> <span class="keyword">import</span> INT_STR_TO_DTYPE</div>
<div class="line"><span class="lineno"> 1127</span> </div>
<div class="line"><span class="lineno"> 1128</span>                inferred_dtype = INT_STR_TO_DTYPE.get(</div>
<div class="line"><span class="lineno"> 1129</span>                    input_array.dtype.name, target_int_dtype</div>
<div class="line"><span class="lineno"> 1130</span>                )</div>
<div class="line"><span class="lineno"> 1131</span>            <span class="keywordflow">elif</span> is_numeric_dtype(input_array.dtype):</div>
<div class="line"><span class="lineno"> 1132</span>                <span class="comment"># TODO: de-dup with maybe_cast_to_integer_array?</span></div>
<div class="line"><span class="lineno"> 1133</span>                arr = input_array[notna(input_array)]</div>
<div class="line"><span class="lineno"> 1134</span>                <span class="keywordflow">if</span> (arr.astype(int) == arr).all():</div>
<div class="line"><span class="lineno"> 1135</span>                    inferred_dtype = target_int_dtype</div>
<div class="line"><span class="lineno"> 1136</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1137</span>                    inferred_dtype = input_array.dtype</div>
<div class="line"><span class="lineno"> 1138</span> </div>
<div class="line"><span class="lineno"> 1139</span>        <span class="keywordflow">if</span> convert_floating:</div>
<div class="line"><span class="lineno"> 1140</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_integer_dtype(input_array.dtype) <span class="keywordflow">and</span> is_numeric_dtype(</div>
<div class="line"><span class="lineno"> 1141</span>                input_array.dtype</div>
<div class="line"><span class="lineno"> 1142</span>            ):</div>
<div class="line"><span class="lineno"> 1143</span>                <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1floating.html">pandas.core.arrays.floating</a> <span class="keyword">import</span> FLOAT_STR_TO_DTYPE</div>
<div class="line"><span class="lineno"> 1144</span> </div>
<div class="line"><span class="lineno"> 1145</span>                inferred_float_dtype: DtypeObj = FLOAT_STR_TO_DTYPE.get(</div>
<div class="line"><span class="lineno"> 1146</span>                    input_array.dtype.name, pandas_dtype(<span class="stringliteral">&quot;Float64&quot;</span>)</div>
<div class="line"><span class="lineno"> 1147</span>                )</div>
<div class="line"><span class="lineno"> 1148</span>                <span class="comment"># if we could also convert to integer, check if all floats</span></div>
<div class="line"><span class="lineno"> 1149</span>                <span class="comment"># are actually integers</span></div>
<div class="line"><span class="lineno"> 1150</span>                <span class="keywordflow">if</span> convert_integer:</div>
<div class="line"><span class="lineno"> 1151</span>                    <span class="comment"># TODO: de-dup with maybe_cast_to_integer_array?</span></div>
<div class="line"><span class="lineno"> 1152</span>                    arr = input_array[notna(input_array)]</div>
<div class="line"><span class="lineno"> 1153</span>                    <span class="keywordflow">if</span> (arr.astype(int) == arr).all():</div>
<div class="line"><span class="lineno"> 1154</span>                        inferred_dtype = pandas_dtype(<span class="stringliteral">&quot;Int64&quot;</span>)</div>
<div class="line"><span class="lineno"> 1155</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1156</span>                        inferred_dtype = inferred_float_dtype</div>
<div class="line"><span class="lineno"> 1157</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1158</span>                    inferred_dtype = inferred_float_dtype</div>
<div class="line"><span class="lineno"> 1159</span> </div>
<div class="line"><span class="lineno"> 1160</span>        <span class="keywordflow">if</span> convert_boolean:</div>
<div class="line"><span class="lineno"> 1161</span>            <span class="keywordflow">if</span> is_bool_dtype(input_array.dtype):</div>
<div class="line"><span class="lineno"> 1162</span>                inferred_dtype = pandas_dtype(<span class="stringliteral">&quot;boolean&quot;</span>)</div>
<div class="line"><span class="lineno"> 1163</span>            <span class="keywordflow">elif</span> isinstance(inferred_dtype, str) <span class="keywordflow">and</span> inferred_dtype == <span class="stringliteral">&quot;boolean&quot;</span>:</div>
<div class="line"><span class="lineno"> 1164</span>                inferred_dtype = pandas_dtype(<span class="stringliteral">&quot;boolean&quot;</span>)</div>
<div class="line"><span class="lineno"> 1165</span> </div>
<div class="line"><span class="lineno"> 1166</span>        <span class="keywordflow">if</span> isinstance(inferred_dtype, str):</div>
<div class="line"><span class="lineno"> 1167</span>            <span class="comment"># If we couldn&#39;t do anything else, then we retain the dtype</span></div>
<div class="line"><span class="lineno"> 1168</span>            inferred_dtype = input_array.dtype</div>
<div class="line"><span class="lineno"> 1169</span> </div>
<div class="line"><span class="lineno"> 1170</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1171</span>        <span class="keywordflow">return</span> input_array.dtype</div>
<div class="line"><span class="lineno"> 1172</span> </div>
<div class="line"><span class="lineno"> 1173</span>    <span class="comment"># error: Incompatible return value type (got &quot;Union[str, Union[dtype[Any],</span></div>
<div class="line"><span class="lineno"> 1174</span>    <span class="comment"># ExtensionDtype]]&quot;, expected &quot;Union[dtype[Any], ExtensionDtype]&quot;)</span></div>
<div class="line"><span class="lineno"> 1175</span>    <span class="keywordflow">return</span> inferred_dtype  <span class="comment"># type: ignore[return-value]</span></div>
<div class="line"><span class="lineno"> 1176</span> </div>
<div class="line"><span class="lineno"> 1177</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1floating_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1floating.html">pandas.core.arrays.floating</a></div><div class="ttdef"><b>Definition</b> floating.py:1</div></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1integer_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1integer.html">pandas.core.arrays.integer</a></div><div class="ttdef"><b>Definition</b> integer.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e5277fbc2b394cf46d7cf1d9e5cb33f" name="a7e5277fbc2b394cf46d7cf1d9e5cb33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5277fbc2b394cf46d7cf1d9e5cb33f">&#9670;&#160;</a></span>dict_compat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[Scalar, Scalar] pandas.core.dtypes.cast.dict_compat </td>
          <td>(</td>
          <td class="paramtype">dict[Scalar, Scalar]&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert datetimelike-keyed dicts to a Timestamp-keyed dict.

Parameters
----------
d: dict-like object

Returns
-------
dict
</pre> <div class="fragment"><div class="line"><span class="lineno">  848</span><span class="keyword">def </span>dict_compat(d: dict[Scalar, Scalar]) -&gt; dict[Scalar, Scalar]:</div>
<div class="line"><span class="lineno">  849</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    Convert datetimelike-keyed dicts to a Timestamp-keyed dict.</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    d: dict-like object</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    dict</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  860</span>    <span class="keywordflow">return</span> {maybe_box_datetimelike(key): value <span class="keywordflow">for</span> key, value <span class="keywordflow">in</span> d.items()}</div>
<div class="line"><span class="lineno">  861</span> </div>
<div class="line"><span class="lineno">  862</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4269d6a9869c3377456fb7547c5ca3f8" name="a4269d6a9869c3377456fb7547c5ca3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4269d6a9869c3377456fb7547c5ca3f8">&#9670;&#160;</a></span>ensure_dtype_can_hold_na() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.dtypes.cast.ensure_dtype_can_hold_na </td>
          <td>(</td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If we have a dtype that cannot hold NA values, find the best match that can.
</pre> <div class="fragment"><div class="line"><span class="lineno">  508</span><span class="keyword">def </span>ensure_dtype_can_hold_na(dtype: DtypeObj) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno">  509</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    If we have a dtype that cannot hold NA values, find the best match that can.</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  512</span>    <span class="keywordflow">if</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno">  513</span>        <span class="keywordflow">if</span> dtype._can_hold_na:</div>
<div class="line"><span class="lineno">  514</span>            <span class="keywordflow">return</span> dtype</div>
<div class="line"><span class="lineno">  515</span>        <span class="keywordflow">elif</span> isinstance(dtype, IntervalDtype):</div>
<div class="line"><span class="lineno">  516</span>            <span class="comment"># TODO(GH#45349): don&#39;t special-case IntervalDtype, allow</span></div>
<div class="line"><span class="lineno">  517</span>            <span class="comment">#  overriding instead of returning object below.</span></div>
<div class="line"><span class="lineno">  518</span>            <span class="keywordflow">return</span> IntervalDtype(np.float64, closed=dtype.closed)</div>
<div class="line"><span class="lineno">  519</span>        <span class="keywordflow">return</span> _dtype_obj</div>
<div class="line"><span class="lineno">  520</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;b&quot;</span>:</div>
<div class="line"><span class="lineno">  521</span>        <span class="keywordflow">return</span> _dtype_obj</div>
<div class="line"><span class="lineno">  522</span>    <span class="keywordflow">elif</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]:</div>
<div class="line"><span class="lineno">  523</span>        <span class="keywordflow">return</span> np.dtype(np.float64)</div>
<div class="line"><span class="lineno">  524</span>    <span class="keywordflow">return</span> dtype</div>
<div class="line"><span class="lineno">  525</span> </div>
<div class="line"><span class="lineno">  526</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4255c5d74bd414ef1cc66c802b3cbbc" name="ae4255c5d74bd414ef1cc66c802b3cbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4255c5d74bd414ef1cc66c802b3cbbc">&#9670;&#160;</a></span>ensure_dtype_can_hold_na() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ExtensionDtype pandas.core.dtypes.cast.ensure_dtype_can_hold_na </td>
          <td>(</td>
          <td class="paramtype">ExtensionDtype&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  504</span><span class="keyword">def </span>ensure_dtype_can_hold_na(dtype: ExtensionDtype) -&gt; ExtensionDtype:</div>
<div class="line"><span class="lineno">  505</span>    ...</div>
<div class="line"><span class="lineno">  506</span> </div>
<div class="line"><span class="lineno">  507</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a93811896b8667a3834bf5634e9324bd0" name="a93811896b8667a3834bf5634e9324bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93811896b8667a3834bf5634e9324bd0">&#9670;&#160;</a></span>ensure_dtype_can_hold_na() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.dtype pandas.core.dtypes.cast.ensure_dtype_can_hold_na </td>
          <td>(</td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  499</span><span class="keyword">def </span>ensure_dtype_can_hold_na(dtype: np.dtype) -&gt; np.dtype:</div>
<div class="line"><span class="lineno">  500</span>    ...</div>
<div class="line"><span class="lineno">  501</span> </div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a261d5b1b4162e21dfbf3aed133d5c551" name="a261d5b1b4162e21dfbf3aed133d5c551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261d5b1b4162e21dfbf3aed133d5c551">&#9670;&#160;</a></span>find_common_type() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.dtypes.cast.find_common_type </td>
          <td>(</td>
          <td class="paramtype">list[DtypeObj]&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1585</span><span class="keyword">def </span>find_common_type(types: list[DtypeObj]) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno"> 1586</span>    ...</div>
<div class="line"><span class="lineno"> 1587</span> </div>
<div class="line"><span class="lineno"> 1588</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a56c64570a6e0a10755625b6320e5def5" name="a56c64570a6e0a10755625b6320e5def5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c64570a6e0a10755625b6320e5def5">&#9670;&#160;</a></span>find_common_type() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.dtypes.cast.find_common_type </td>
          <td>(</td>
          <td class="paramtype">list[ExtensionDtype]&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1580</span><span class="keyword">def </span>find_common_type(types: list[ExtensionDtype]) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno"> 1581</span>    ...</div>
<div class="line"><span class="lineno"> 1582</span> </div>
<div class="line"><span class="lineno"> 1583</span> </div>
<div class="line"><span class="lineno"> 1584</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8b073e156904577296121c10356d398" name="ac8b073e156904577296121c10356d398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b073e156904577296121c10356d398">&#9670;&#160;</a></span>find_common_type() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.dtype pandas.core.dtypes.cast.find_common_type </td>
          <td>(</td>
          <td class="paramtype">list[np.dtype]&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1575</span><span class="keyword">def </span>find_common_type(types: list[np.dtype]) -&gt; np.dtype:</div>
<div class="line"><span class="lineno"> 1576</span>    ...</div>
<div class="line"><span class="lineno"> 1577</span> </div>
<div class="line"><span class="lineno"> 1578</span> </div>
<div class="line"><span class="lineno"> 1579</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a511fe1aa9c59f05c2e11df516f36db80" name="a511fe1aa9c59f05c2e11df516f36db80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511fe1aa9c59f05c2e11df516f36db80">&#9670;&#160;</a></span>find_common_type() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast.find_common_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a common data type among the given dtypes.

Parameters
----------
types : list of dtypes

Returns
-------
pandas extension or numpy dtype

See Also
--------
numpy.find_common_type</pre> <div class="fragment"><div class="line"><span class="lineno"> 1589</span><span class="keyword">def </span>find_common_type(types):</div>
<div class="line"><span class="lineno"> 1590</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    Find a common data type among the given dtypes.</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    types : list of dtypes</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    pandas extension or numpy dtype</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">    numpy.find_common_type</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1606</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> types:</div>
<div class="line"><span class="lineno"> 1607</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;no types given&quot;</span>)</div>
<div class="line"><span class="lineno"> 1608</span> </div>
<div class="line"><span class="lineno"> 1609</span>    first = types[0]</div>
<div class="line"><span class="lineno"> 1610</span> </div>
<div class="line"><span class="lineno"> 1611</span>    <span class="comment"># workaround for find_common_type([np.dtype(&#39;datetime64[ns]&#39;)] * 2)</span></div>
<div class="line"><span class="lineno"> 1612</span>    <span class="comment"># =&gt; object</span></div>
<div class="line"><span class="lineno"> 1613</span>    <span class="keywordflow">if</span> lib.dtypes_all_equal(list(types)):</div>
<div class="line"><span class="lineno"> 1614</span>        <span class="keywordflow">return</span> first</div>
<div class="line"><span class="lineno"> 1615</span> </div>
<div class="line"><span class="lineno"> 1616</span>    <span class="comment"># get unique types (dict.fromkeys is used as order-preserving set())</span></div>
<div class="line"><span class="lineno"> 1617</span>    types = list(dict.fromkeys(types).keys())</div>
<div class="line"><span class="lineno"> 1618</span> </div>
<div class="line"><span class="lineno"> 1619</span>    <span class="keywordflow">if</span> any(isinstance(t, ExtensionDtype) <span class="keywordflow">for</span> t <span class="keywordflow">in</span> types):</div>
<div class="line"><span class="lineno"> 1620</span>        <span class="keywordflow">for</span> t <span class="keywordflow">in</span> types:</div>
<div class="line"><span class="lineno"> 1621</span>            <span class="keywordflow">if</span> isinstance(t, ExtensionDtype):</div>
<div class="line"><span class="lineno"> 1622</span>                res = t._get_common_dtype(types)</div>
<div class="line"><span class="lineno"> 1623</span>                <span class="keywordflow">if</span> res <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1624</span>                    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 1625</span>        <span class="keywordflow">return</span> np.dtype(<span class="stringliteral">&quot;object&quot;</span>)</div>
<div class="line"><span class="lineno"> 1626</span> </div>
<div class="line"><span class="lineno"> 1627</span>    <span class="comment"># take lowest unit</span></div>
<div class="line"><span class="lineno"> 1628</span>    <span class="keywordflow">if</span> all(is_datetime64_dtype(t) <span class="keywordflow">for</span> t <span class="keywordflow">in</span> types):</div>
<div class="line"><span class="lineno"> 1629</span>        <span class="keywordflow">return</span> np.dtype(<span class="stringliteral">&quot;datetime64[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1630</span>    <span class="keywordflow">if</span> all(is_timedelta64_dtype(t) <span class="keywordflow">for</span> t <span class="keywordflow">in</span> types):</div>
<div class="line"><span class="lineno"> 1631</span>        <span class="keywordflow">return</span> np.dtype(<span class="stringliteral">&quot;timedelta64[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1632</span> </div>
<div class="line"><span class="lineno"> 1633</span>    <span class="comment"># don&#39;t mix bool / int or float or complex</span></div>
<div class="line"><span class="lineno"> 1634</span>    <span class="comment"># this is different from numpy, which casts bool with float/int as int</span></div>
<div class="line"><span class="lineno"> 1635</span>    has_bools = any(is_bool_dtype(t) <span class="keywordflow">for</span> t <span class="keywordflow">in</span> types)</div>
<div class="line"><span class="lineno"> 1636</span>    <span class="keywordflow">if</span> has_bools:</div>
<div class="line"><span class="lineno"> 1637</span>        <span class="keywordflow">for</span> t <span class="keywordflow">in</span> types:</div>
<div class="line"><span class="lineno"> 1638</span>            <span class="keywordflow">if</span> is_integer_dtype(t) <span class="keywordflow">or</span> is_float_dtype(t) <span class="keywordflow">or</span> is_complex_dtype(t):</div>
<div class="line"><span class="lineno"> 1639</span>                <span class="keywordflow">return</span> np.dtype(<span class="stringliteral">&quot;object&quot;</span>)</div>
<div class="line"><span class="lineno"> 1640</span> </div>
<div class="line"><span class="lineno"> 1641</span>    <span class="keywordflow">return</span> np.find_common_type(types, [])</div>
<div class="line"><span class="lineno"> 1642</span> </div>
<div class="line"><span class="lineno"> 1643</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02c3d960ca2e8e78effd6c036abf6b3f" name="a02c3d960ca2e8e78effd6c036abf6b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3d960ca2e8e78effd6c036abf6b3f">&#9670;&#160;</a></span>find_result_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.dtypes.cast.find_result_type </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the type/dtype for a the result of an operation between these objects.

This is similar to find_common_type, but looks at the objects instead
of just their dtypes. This can be useful in particular when one of the
objects does not have a `dtype`.

Parameters
----------
left : np.ndarray or ExtensionArray
right : Any

Returns
-------
np.dtype or ExtensionDtype

See also
--------
find_common_type
numpy.result_type
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1487</span><span class="keyword">def </span>find_result_type(left: ArrayLike, right: Any) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno"> 1488</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">    Find the type/dtype for a the result of an operation between these objects.</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">    This is similar to find_common_type, but looks at the objects instead</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">    of just their dtypes. This can be useful in particular when one of the</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">    objects does not have a `dtype`.</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    left : np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">    right : Any</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">    np.dtype or ExtensionDtype</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">    find_common_type</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    numpy.result_type</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1509</span>    new_dtype: DtypeObj</div>
<div class="line"><span class="lineno"> 1510</span> </div>
<div class="line"><span class="lineno"> 1511</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1512</span>        isinstance(left, np.ndarray)</div>
<div class="line"><span class="lineno"> 1513</span>        <span class="keywordflow">and</span> left.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>]</div>
<div class="line"><span class="lineno"> 1514</span>        <span class="keywordflow">and</span> (lib.is_integer(right) <span class="keywordflow">or</span> lib.is_float(right))</div>
<div class="line"><span class="lineno"> 1515</span>    ):</div>
<div class="line"><span class="lineno"> 1516</span>        <span class="comment"># e.g. with int8 dtype and right=512, we want to end up with</span></div>
<div class="line"><span class="lineno"> 1517</span>        <span class="comment"># np.int16, whereas infer_dtype_from(512) gives np.int64,</span></div>
<div class="line"><span class="lineno"> 1518</span>        <span class="comment">#  which will make us upcast too far.</span></div>
<div class="line"><span class="lineno"> 1519</span>        <span class="keywordflow">if</span> lib.is_float(right) <span class="keywordflow">and</span> right.is_integer() <span class="keywordflow">and</span> left.dtype.kind != <span class="stringliteral">&quot;f&quot;</span>:</div>
<div class="line"><span class="lineno"> 1520</span>            right = int(right)</div>
<div class="line"><span class="lineno"> 1521</span> </div>
<div class="line"><span class="lineno"> 1522</span>        new_dtype = np.result_type(left, right)</div>
<div class="line"><span class="lineno"> 1523</span> </div>
<div class="line"><span class="lineno"> 1524</span>    <span class="keywordflow">elif</span> is_valid_na_for_dtype(right, left.dtype):</div>
<div class="line"><span class="lineno"> 1525</span>        <span class="comment"># e.g. IntervalDtype[int] and None/np.nan</span></div>
<div class="line"><span class="lineno"> 1526</span>        new_dtype = ensure_dtype_can_hold_na(left.dtype)</div>
<div class="line"><span class="lineno"> 1527</span> </div>
<div class="line"><span class="lineno"> 1528</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1529</span>        dtype, _ = infer_dtype_from(right, pandas_dtype=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1530</span> </div>
<div class="line"><span class="lineno"> 1531</span>        new_dtype = find_common_type([left.dtype, dtype])</div>
<div class="line"><span class="lineno"> 1532</span> </div>
<div class="line"><span class="lineno"> 1533</span>    <span class="keywordflow">return</span> new_dtype</div>
<div class="line"><span class="lineno"> 1534</span> </div>
<div class="line"><span class="lineno"> 1535</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab09efe179d3e091c870e8e42cbaffa41" name="ab09efe179d3e091c870e8e42cbaffa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09efe179d3e091c870e8e42cbaffa41">&#9670;&#160;</a></span>infer_dtype_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[DtypeObj, Any] pandas.core.dtypes.cast.infer_dtype_from </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pandas_dtype</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Interpret the dtype from a scalar or array.

Parameters
----------
val : object
pandas_dtype : bool, default False
    whether to infer dtype including pandas extension types.
    If False, scalar/array belongs to pandas extension types is inferred as
    object
</pre> <div class="fragment"><div class="line"><span class="lineno">  739</span><span class="keyword">def </span>infer_dtype_from(val, pandas_dtype: bool = <span class="keyword">False</span>) -&gt; tuple[DtypeObj, Any]:</div>
<div class="line"><span class="lineno">  740</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    Interpret the dtype from a scalar or array.</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    val : object</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    pandas_dtype : bool, default False</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        whether to infer dtype including pandas extension types.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        If False, scalar/array belongs to pandas extension types is inferred as</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        object</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  751</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(val):</div>
<div class="line"><span class="lineno">  752</span>        <span class="keywordflow">return</span> infer_dtype_from_scalar(val, pandas_dtype=pandas_dtype)</div>
<div class="line"><span class="lineno">  753</span>    <span class="keywordflow">return</span> infer_dtype_from_array(val, pandas_dtype=pandas_dtype)</div>
<div class="line"><span class="lineno">  754</span> </div>
<div class="line"><span class="lineno">  755</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6acde6340083817b93e3e3c65f4e1649" name="a6acde6340083817b93e3e3c65f4e1649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acde6340083817b93e3e3c65f4e1649">&#9670;&#160;</a></span>infer_dtype_from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[DtypeObj, ArrayLike] pandas.core.dtypes.cast.infer_dtype_from_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pandas_dtype</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Infer the dtype from an array.

Parameters
----------
arr : array
pandas_dtype : bool, default False
    whether to infer dtype including pandas extension types.
    If False, array belongs to pandas extension types
    is inferred as object

Returns
-------
tuple (numpy-compat/pandas-compat dtype, array)

Notes
-----
if pandas_dtype=False. these infer to numpy dtypes
exactly with the exception that mixed / object dtypes
are not coerced by stringifying or conversion

if pandas_dtype=True. datetime64tz-aware/categorical
types will retain there character.

Examples
--------
&gt;&gt;&gt; np.asarray([1, '1'])
array(['1', '1'], dtype='&lt;U21')

&gt;&gt;&gt; infer_dtype_from_array([1, '1'])
(dtype('O'), [1, '1'])
</pre> <div class="fragment"><div class="line"><span class="lineno">  865</span>) -&gt; tuple[DtypeObj, ArrayLike]:</div>
<div class="line"><span class="lineno">  866</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    Infer the dtype from an array.</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    arr : array</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    pandas_dtype : bool, default False</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">        whether to infer dtype including pandas extension types.</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">        If False, array belongs to pandas extension types</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        is inferred as object</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    tuple (numpy-compat/pandas-compat dtype, array)</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    if pandas_dtype=False. these infer to numpy dtypes</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    exactly with the exception that mixed / object dtypes</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    are not coerced by stringifying or conversion</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    if pandas_dtype=True. datetime64tz-aware/categorical</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    types will retain there character.</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    &gt;&gt;&gt; np.asarray([1, &#39;1&#39;])</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    array([&#39;1&#39;, &#39;1&#39;], dtype=&#39;&lt;U21&#39;)</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    &gt;&gt;&gt; infer_dtype_from_array([1, &#39;1&#39;])</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    (dtype(&#39;O&#39;), [1, &#39;1&#39;])</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  898</span>    <span class="keywordflow">if</span> isinstance(arr, np.ndarray):</div>
<div class="line"><span class="lineno">  899</span>        <span class="keywordflow">return</span> arr.dtype, arr</div>
<div class="line"><span class="lineno">  900</span> </div>
<div class="line"><span class="lineno">  901</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(arr):</div>
<div class="line"><span class="lineno">  902</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;&#39;arr&#39; must be list-like&quot;</span>)</div>
<div class="line"><span class="lineno">  903</span> </div>
<div class="line"><span class="lineno">  904</span>    <span class="keywordflow">if</span> pandas_dtype <span class="keywordflow">and</span> is_extension_array_dtype(arr):</div>
<div class="line"><span class="lineno">  905</span>        <span class="keywordflow">return</span> arr.dtype, arr</div>
<div class="line"><span class="lineno">  906</span> </div>
<div class="line"><span class="lineno">  907</span>    <span class="keywordflow">elif</span> isinstance(arr, ABCSeries):</div>
<div class="line"><span class="lineno">  908</span>        <span class="keywordflow">return</span> arr.dtype, np.asarray(arr)</div>
<div class="line"><span class="lineno">  909</span> </div>
<div class="line"><span class="lineno">  910</span>    <span class="comment"># don&#39;t force numpy coerce with nan&#39;s</span></div>
<div class="line"><span class="lineno">  911</span>    inferred = lib.infer_dtype(arr, skipna=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  912</span>    <span class="keywordflow">if</span> inferred <span class="keywordflow">in</span> [<span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;bytes&quot;</span>, <span class="stringliteral">&quot;mixed&quot;</span>, <span class="stringliteral">&quot;mixed-integer&quot;</span>]:</div>
<div class="line"><span class="lineno">  913</span>        <span class="keywordflow">return</span> (np.dtype(np.object_), arr)</div>
<div class="line"><span class="lineno">  914</span> </div>
<div class="line"><span class="lineno">  915</span>    arr = np.asarray(arr)</div>
<div class="line"><span class="lineno">  916</span>    <span class="keywordflow">return</span> arr.dtype, arr</div>
<div class="line"><span class="lineno">  917</span> </div>
<div class="line"><span class="lineno">  918</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a51c6a13673d8105d668fcc911ca5ffba" name="a51c6a13673d8105d668fcc911ca5ffba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c6a13673d8105d668fcc911ca5ffba">&#9670;&#160;</a></span>infer_dtype_from_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[DtypeObj, Any] pandas.core.dtypes.cast.infer_dtype_from_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pandas_dtype</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Interpret the dtype from a scalar.

Parameters
----------
pandas_dtype : bool, default False
    whether to infer dtype including pandas extension types.
    If False, scalar belongs to pandas extension types is inferred as
    object
</pre> <div class="fragment"><div class="line"><span class="lineno">  756</span><span class="keyword">def </span>infer_dtype_from_scalar(val, pandas_dtype: bool = <span class="keyword">False</span>) -&gt; tuple[DtypeObj, Any]:</div>
<div class="line"><span class="lineno">  757</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    Interpret the dtype from a scalar.</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    pandas_dtype : bool, default False</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        whether to infer dtype including pandas extension types.</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        If False, scalar belongs to pandas extension types is inferred as</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        object</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  767</span>    dtype: DtypeObj = _dtype_obj</div>
<div class="line"><span class="lineno">  768</span> </div>
<div class="line"><span class="lineno">  769</span>    <span class="comment"># a 1-element ndarray</span></div>
<div class="line"><span class="lineno">  770</span>    <span class="keywordflow">if</span> isinstance(val, np.ndarray):</div>
<div class="line"><span class="lineno">  771</span>        <span class="keywordflow">if</span> val.ndim != 0:</div>
<div class="line"><span class="lineno">  772</span>            msg = <span class="stringliteral">&quot;invalid ndarray passed to infer_dtype_from_scalar&quot;</span></div>
<div class="line"><span class="lineno">  773</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  774</span> </div>
<div class="line"><span class="lineno">  775</span>        dtype = val.dtype</div>
<div class="line"><span class="lineno">  776</span>        val = lib.item_from_zerodim(val)</div>
<div class="line"><span class="lineno">  777</span> </div>
<div class="line"><span class="lineno">  778</span>    <span class="keywordflow">elif</span> isinstance(val, str):</div>
<div class="line"><span class="lineno">  779</span> </div>
<div class="line"><span class="lineno">  780</span>        <span class="comment"># If we create an empty array using a string to infer</span></div>
<div class="line"><span class="lineno">  781</span>        <span class="comment"># the dtype, NumPy will only allocate one character per entry</span></div>
<div class="line"><span class="lineno">  782</span>        <span class="comment"># so this is kind of bad. Alternately we could use np.repeat</span></div>
<div class="line"><span class="lineno">  783</span>        <span class="comment"># instead of np.empty (but then you still don&#39;t want things</span></div>
<div class="line"><span class="lineno">  784</span>        <span class="comment"># coming out as np.str_!</span></div>
<div class="line"><span class="lineno">  785</span> </div>
<div class="line"><span class="lineno">  786</span>        dtype = _dtype_obj</div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    <span class="keywordflow">elif</span> isinstance(val, (np.datetime64, datetime)):</div>
<div class="line"><span class="lineno">  789</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  790</span>            val = Timestamp(val)</div>
<div class="line"><span class="lineno">  791</span>        <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno">  792</span>            <span class="keywordflow">return</span> _dtype_obj, val</div>
<div class="line"><span class="lineno">  793</span> </div>
<div class="line"><span class="lineno">  794</span>        <span class="comment"># error: Non-overlapping identity check (left operand type: &quot;Timestamp&quot;,</span></div>
<div class="line"><span class="lineno">  795</span>        <span class="comment"># right operand type: &quot;NaTType&quot;)</span></div>
<div class="line"><span class="lineno">  796</span>        <span class="keywordflow">if</span> val <span class="keywordflow">is</span> NaT <span class="keywordflow">or</span> val.tz <span class="keywordflow">is</span> <span class="keywordtype">None</span>:  <span class="comment"># type: ignore[comparison-overlap]</span></div>
<div class="line"><span class="lineno">  797</span>            dtype = np.dtype(<span class="stringliteral">&quot;M8[ns]&quot;</span>)</div>
<div class="line"><span class="lineno">  798</span>            val = val.to_datetime64()</div>
<div class="line"><span class="lineno">  799</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  800</span>            <span class="keywordflow">if</span> pandas_dtype:</div>
<div class="line"><span class="lineno">  801</span>                dtype = DatetimeTZDtype(unit=<span class="stringliteral">&quot;ns&quot;</span>, tz=val.tz)</div>
<div class="line"><span class="lineno">  802</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  803</span>                <span class="comment"># return datetimetz as object</span></div>
<div class="line"><span class="lineno">  804</span>                <span class="keywordflow">return</span> _dtype_obj, val</div>
<div class="line"><span class="lineno">  805</span> </div>
<div class="line"><span class="lineno">  806</span>    <span class="keywordflow">elif</span> isinstance(val, (np.timedelta64, timedelta)):</div>
<div class="line"><span class="lineno">  807</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  808</span>            val = Timedelta(val)</div>
<div class="line"><span class="lineno">  809</span>        <span class="keywordflow">except</span> (OutOfBoundsTimedelta, OverflowError):</div>
<div class="line"><span class="lineno">  810</span>            dtype = _dtype_obj</div>
<div class="line"><span class="lineno">  811</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  812</span>            dtype = np.dtype(<span class="stringliteral">&quot;m8[ns]&quot;</span>)</div>
<div class="line"><span class="lineno">  813</span>            val = np.timedelta64(val.value, <span class="stringliteral">&quot;ns&quot;</span>)</div>
<div class="line"><span class="lineno">  814</span> </div>
<div class="line"><span class="lineno">  815</span>    <span class="keywordflow">elif</span> is_bool(val):</div>
<div class="line"><span class="lineno">  816</span>        dtype = np.dtype(np.bool_)</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span>    <span class="keywordflow">elif</span> is_integer(val):</div>
<div class="line"><span class="lineno">  819</span>        <span class="keywordflow">if</span> isinstance(val, np.integer):</div>
<div class="line"><span class="lineno">  820</span>            dtype = np.dtype(type(val))</div>
<div class="line"><span class="lineno">  821</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  822</span>            dtype = np.dtype(np.int64)</div>
<div class="line"><span class="lineno">  823</span> </div>
<div class="line"><span class="lineno">  824</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  825</span>            np.array(val, dtype=dtype)</div>
<div class="line"><span class="lineno">  826</span>        <span class="keywordflow">except</span> OverflowError:</div>
<div class="line"><span class="lineno">  827</span>            dtype = np.array(val).dtype</div>
<div class="line"><span class="lineno">  828</span> </div>
<div class="line"><span class="lineno">  829</span>    <span class="keywordflow">elif</span> is_float(val):</div>
<div class="line"><span class="lineno">  830</span>        <span class="keywordflow">if</span> isinstance(val, np.floating):</div>
<div class="line"><span class="lineno">  831</span>            dtype = np.dtype(type(val))</div>
<div class="line"><span class="lineno">  832</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  833</span>            dtype = np.dtype(np.float64)</div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span>    <span class="keywordflow">elif</span> is_complex(val):</div>
<div class="line"><span class="lineno">  836</span>        dtype = np.dtype(np.complex_)</div>
<div class="line"><span class="lineno">  837</span> </div>
<div class="line"><span class="lineno">  838</span>    <span class="keywordflow">elif</span> pandas_dtype:</div>
<div class="line"><span class="lineno">  839</span>        <span class="keywordflow">if</span> lib.is_period(val):</div>
<div class="line"><span class="lineno">  840</span>            dtype = PeriodDtype(freq=val.freq)</div>
<div class="line"><span class="lineno">  841</span>        <span class="keywordflow">elif</span> lib.is_interval(val):</div>
<div class="line"><span class="lineno">  842</span>            subtype = infer_dtype_from_scalar(val.left, pandas_dtype=<span class="keyword">True</span>)[0]</div>
<div class="line"><span class="lineno">  843</span>            dtype = IntervalDtype(subtype=subtype, closed=val.closed)</div>
<div class="line"><span class="lineno">  844</span> </div>
<div class="line"><span class="lineno">  845</span>    <span class="keywordflow">return</span> dtype, val</div>
<div class="line"><span class="lineno">  846</span> </div>
<div class="line"><span class="lineno">  847</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a780a189e763d590e2da71efe5f47413d" name="a780a189e763d590e2da71efe5f47413d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780a189e763d590e2da71efe5f47413d">&#9670;&#160;</a></span>invalidate_string_dtypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.dtypes.cast.invalidate_string_dtypes </td>
          <td>(</td>
          <td class="paramtype">set[DtypeObj]&#160;</td>
          <td class="paramname"><em>dtype_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Change string like dtypes to object for
``DataFrame.select_dtypes()``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  987</span><span class="keyword">def </span>invalidate_string_dtypes(dtype_set: set[DtypeObj]) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  988</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    Change string like dtypes to object for</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    ``DataFrame.select_dtypes()``.</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  992</span>    <span class="comment"># error: Argument 1 to &lt;set&gt; has incompatible type &quot;Type[generic]&quot;; expected</span></div>
<div class="line"><span class="lineno">  993</span>    <span class="comment"># &quot;Union[dtype[Any], ExtensionDtype, None]&quot;</span></div>
<div class="line"><span class="lineno">  994</span>    <span class="comment"># error: Argument 2 to &lt;set&gt; has incompatible type &quot;Type[generic]&quot;; expected</span></div>
<div class="line"><span class="lineno">  995</span>    <span class="comment"># &quot;Union[dtype[Any], ExtensionDtype, None]&quot;</span></div>
<div class="line"><span class="lineno">  996</span>    non_string_dtypes = dtype_set - {</div>
<div class="line"><span class="lineno">  997</span>        np.dtype(<span class="stringliteral">&quot;S&quot;</span>).type,  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  998</span>        np.dtype(<span class="stringliteral">&quot;&lt;U&quot;</span>).type,  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  999</span>    }</div>
<div class="line"><span class="lineno"> 1000</span>    <span class="keywordflow">if</span> non_string_dtypes != dtype_set:</div>
<div class="line"><span class="lineno"> 1001</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;string dtypes are not allowed, use &#39;object&#39; instead&quot;</span>)</div>
<div class="line"><span class="lineno"> 1002</span> </div>
<div class="line"><span class="lineno"> 1003</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0cc27bce7e9bf8ceb512330d68b187c7" name="a0cc27bce7e9bf8ceb512330d68b187c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc27bce7e9bf8ceb512330d68b187c7">&#9670;&#160;</a></span>is_nested_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.dtypes.cast.is_nested_object </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return a boolean if we have a nested object, e.g. a Series with 1 or
more Series elements

This may not be necessarily be performant.</pre> <div class="fragment"><div class="line"><span class="lineno">  140</span><span class="keyword">def </span>is_nested_object(obj) -&gt; bool:</div>
<div class="line"><span class="lineno">  141</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    return a boolean if we have a nested object, e.g. a Series with 1 or</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    more Series elements</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    This may not be necessarily be performant.</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  148</span>    <span class="keywordflow">return</span> bool(</div>
<div class="line"><span class="lineno">  149</span>        isinstance(obj, ABCSeries)</div>
<div class="line"><span class="lineno">  150</span>        <span class="keywordflow">and</span> is_object_dtype(obj.dtype)</div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">and</span> any(isinstance(v, ABCSeries) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> obj._values)</div>
<div class="line"><span class="lineno">  152</span>    )</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5548d3d7c78d47e2d6565ae50509ff6" name="ae5548d3d7c78d47e2d6565ae50509ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5548d3d7c78d47e2d6565ae50509ff6">&#9670;&#160;</a></span>maybe_box_datetimelike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Scalar pandas.core.dtypes.cast.maybe_box_datetimelike </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dtype | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cast scalar to Timestamp or Timedelta if scalar is datetime-like
and dtype is not object.

Parameters
----------
value : scalar
dtype : Dtype, optional

Returns
-------
scalar
</pre> <div class="fragment"><div class="line"><span class="lineno">  155</span><span class="keyword">def </span>maybe_box_datetimelike(value: Scalar, dtype: Dtype | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>) -&gt; Scalar:</div>
<div class="line"><span class="lineno">  156</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    Cast scalar to Timestamp or Timedelta if scalar is datetime-like</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    and dtype is not object.</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    value : scalar</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    dtype : Dtype, optional</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    scalar</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">if</span> dtype == _dtype_obj:</div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  171</span>    <span class="keywordflow">elif</span> isinstance(value, (np.datetime64, datetime)):</div>
<div class="line"><span class="lineno">  172</span>        value = Timestamp(value)</div>
<div class="line"><span class="lineno">  173</span>    <span class="keywordflow">elif</span> isinstance(value, (np.timedelta64, timedelta)):</div>
<div class="line"><span class="lineno">  174</span>        value = Timedelta(value)</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c208f5001f5c389695f373d980d20be" name="a5c208f5001f5c389695f373d980d20be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c208f5001f5c389695f373d980d20be">&#9670;&#160;</a></span>maybe_box_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Scalar pandas.core.dtypes.cast.maybe_box_native </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If passed a scalar cast the scalar to a python native type.

Parameters
----------
value : scalar or Series

Returns
-------
scalar or Series
</pre> <div class="fragment"><div class="line"><span class="lineno">  179</span><span class="keyword">def </span>maybe_box_native(value: Scalar) -&gt; Scalar:</div>
<div class="line"><span class="lineno">  180</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    If passed a scalar cast the scalar to a python native type.</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    value : scalar or Series</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    scalar or Series</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  191</span>    <span class="keywordflow">if</span> is_float(value):</div>
<div class="line"><span class="lineno">  192</span>        <span class="comment"># error: Argument 1 to &quot;float&quot; has incompatible type</span></div>
<div class="line"><span class="lineno">  193</span>        <span class="comment"># &quot;Union[Union[str, int, float, bool], Union[Any, Timestamp, Timedelta, Any]]&quot;;</span></div>
<div class="line"><span class="lineno">  194</span>        <span class="comment"># expected &quot;Union[SupportsFloat, _SupportsIndex, str]&quot;</span></div>
<div class="line"><span class="lineno">  195</span>        value = float(value)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  196</span>    <span class="keywordflow">elif</span> is_integer(value):</div>
<div class="line"><span class="lineno">  197</span>        <span class="comment"># error: Argument 1 to &quot;int&quot; has incompatible type</span></div>
<div class="line"><span class="lineno">  198</span>        <span class="comment"># &quot;Union[Union[str, int, float, bool], Union[Any, Timestamp, Timedelta, Any]]&quot;;</span></div>
<div class="line"><span class="lineno">  199</span>        <span class="comment"># expected &quot;Union[str, SupportsInt, _SupportsIndex, _SupportsTrunc]&quot;</span></div>
<div class="line"><span class="lineno">  200</span>        value = int(value)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">elif</span> is_bool(value):</div>
<div class="line"><span class="lineno">  202</span>        value = bool(value)</div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">elif</span> isinstance(value, (np.datetime64, np.timedelta64)):</div>
<div class="line"><span class="lineno">  204</span>        value = maybe_box_datetimelike(value)</div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno">  206</span> </div>
<div class="line"><span class="lineno">  207</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a45e57b96cdcb0bf909cdbc091545b0fb" name="a45e57b96cdcb0bf909cdbc091545b0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e57b96cdcb0bf909cdbc091545b0fb">&#9670;&#160;</a></span>maybe_cast_pointwise_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.maybe_cast_pointwise_result </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>same_dtype</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try casting result of a pointwise operation back to the original dtype if
appropriate.

Parameters
----------
result : array-like
    Result to cast.
dtype : np.dtype or ExtensionDtype
    Input Series from which result was calculated.
numeric_only : bool, default False
    Whether to cast only numerics or datetimes as well.
same_dtype : bool, default True
    Specify dtype when calling _from_sequence

Returns
-------
result : array-like
    result maybe casted to the dtype.
</pre> <div class="fragment"><div class="line"><span class="lineno">  421</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  422</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    Try casting result of a pointwise operation back to the original dtype if</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    appropriate.</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    result : array-like</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">        Result to cast.</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    dtype : np.dtype or ExtensionDtype</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        Input Series from which result was calculated.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    numeric_only : bool, default False</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        Whether to cast only numerics or datetimes as well.</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    same_dtype : bool, default True</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        Specify dtype when calling _from_sequence</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    result : array-like</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        result maybe casted to the dtype.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  442</span> </div>
<div class="line"><span class="lineno">  443</span>    <span class="keyword">assert</span> <span class="keywordflow">not</span> is_scalar(result)</div>
<div class="line"><span class="lineno">  444</span> </div>
<div class="line"><span class="lineno">  445</span>    <span class="keywordflow">if</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno">  446</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, (CategoricalDtype, DatetimeTZDtype)):</div>
<div class="line"><span class="lineno">  447</span>            <span class="comment"># TODO: avoid this special-casing</span></div>
<div class="line"><span class="lineno">  448</span>            <span class="comment"># We have to special case categorical so as not to upcast</span></div>
<div class="line"><span class="lineno">  449</span>            <span class="comment"># things like counts back to categorical</span></div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span>            cls = dtype.construct_array_type()</div>
<div class="line"><span class="lineno">  452</span>            <span class="keywordflow">if</span> same_dtype:</div>
<div class="line"><span class="lineno">  453</span>                result = maybe_cast_to_extension_array(cls, result, dtype=dtype)</div>
<div class="line"><span class="lineno">  454</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  455</span>                result = maybe_cast_to_extension_array(cls, result)</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    <span class="keywordflow">elif</span> (numeric_only <span class="keywordflow">and</span> is_numeric_dtype(dtype)) <span class="keywordflow">or</span> <span class="keywordflow">not</span> numeric_only:</div>
<div class="line"><span class="lineno">  458</span>        result = maybe_downcast_to_dtype(result, dtype)</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af5d134d3ebff8a083096c6a53fefe888" name="af5d134d3ebff8a083096c6a53fefe888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d134d3ebff8a083096c6a53fefe888">&#9670;&#160;</a></span>maybe_cast_to_datetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> | np.ndarray pandas.core.dtypes.cast.maybe_cast_to_datetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> | np.ndarray | list&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj | None
&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">try to cast the array/value to a datetimelike dtype, converting float
nan to iNaT

We allow a list *only* when dtype is not None.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1293</span>) -&gt; ExtensionArray | np.ndarray:</div>
<div class="line"><span class="lineno"> 1294</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    try to cast the array/value to a datetimelike dtype, converting float</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    nan to iNaT</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    We allow a list *only* when dtype is not None.</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1300</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1datetimes.html">pandas.core.arrays.datetimes</a> <span class="keyword">import</span> sequence_to_datetimes</div>
<div class="line"><span class="lineno"> 1301</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1timedeltas.html">pandas.core.arrays.timedeltas</a> <span class="keyword">import</span> TimedeltaArray</div>
<div class="line"><span class="lineno"> 1302</span> </div>
<div class="line"><span class="lineno"> 1303</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(value):</div>
<div class="line"><span class="lineno"> 1304</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;value must be listlike&quot;</span>)</div>
<div class="line"><span class="lineno"> 1305</span> </div>
<div class="line"><span class="lineno"> 1306</span>    <span class="keywordflow">if</span> is_timedelta64_dtype(dtype):</div>
<div class="line"><span class="lineno"> 1307</span>        <span class="comment"># TODO: _from_sequence would raise ValueError in cases where</span></div>
<div class="line"><span class="lineno"> 1308</span>        <span class="comment">#  _ensure_nanosecond_dtype raises TypeError</span></div>
<div class="line"><span class="lineno"> 1309</span>        dtype = cast(np.dtype, dtype)</div>
<div class="line"><span class="lineno"> 1310</span>        dtype = _ensure_nanosecond_dtype(dtype)</div>
<div class="line"><span class="lineno"> 1311</span>        res = TimedeltaArray._from_sequence(value, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1312</span>        <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 1313</span> </div>
<div class="line"><span class="lineno"> 1314</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1315</span>        is_datetime64 = is_datetime64_dtype(dtype)</div>
<div class="line"><span class="lineno"> 1316</span>        is_datetime64tz = is_datetime64tz_dtype(dtype)</div>
<div class="line"><span class="lineno"> 1317</span> </div>
<div class="line"><span class="lineno"> 1318</span>        vdtype = getattr(value, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1319</span> </div>
<div class="line"><span class="lineno"> 1320</span>        <span class="keywordflow">if</span> is_datetime64 <span class="keywordflow">or</span> is_datetime64tz:</div>
<div class="line"><span class="lineno"> 1321</span>            dtype = _ensure_nanosecond_dtype(dtype)</div>
<div class="line"><span class="lineno"> 1322</span> </div>
<div class="line"><span class="lineno"> 1323</span>            value = np.array(value, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1324</span> </div>
<div class="line"><span class="lineno"> 1325</span>            <span class="comment"># we have an array of datetime or timedeltas &amp; nulls</span></div>
<div class="line"><span class="lineno"> 1326</span>            <span class="keywordflow">if</span> value.size <span class="keywordflow">or</span> <span class="keywordflow">not</span> is_dtype_equal(value.dtype, dtype):</div>
<div class="line"><span class="lineno"> 1327</span>                _disallow_mismatched_datetimelike(value, dtype)</div>
<div class="line"><span class="lineno"> 1328</span> </div>
<div class="line"><span class="lineno"> 1329</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1330</span>                    <span class="keywordflow">if</span> is_datetime64:</div>
<div class="line"><span class="lineno"> 1331</span>                        dta = sequence_to_datetimes(value)</div>
<div class="line"><span class="lineno"> 1332</span>                        <span class="comment"># GH 25843: Remove tz information since the dtype</span></div>
<div class="line"><span class="lineno"> 1333</span>                        <span class="comment"># didn&#39;t specify one</span></div>
<div class="line"><span class="lineno"> 1334</span> </div>
<div class="line"><span class="lineno"> 1335</span>                        <span class="keywordflow">if</span> dta.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1336</span>                            warnings.warn(</div>
<div class="line"><span class="lineno"> 1337</span>                                <span class="stringliteral">&quot;Data is timezone-aware. Converting &quot;</span></div>
<div class="line"><span class="lineno"> 1338</span>                                <span class="stringliteral">&quot;timezone-aware data to timezone-naive by &quot;</span></div>
<div class="line"><span class="lineno"> 1339</span>                                <span class="stringliteral">&quot;passing dtype=&#39;datetime64[ns]&#39; to &quot;</span></div>
<div class="line"><span class="lineno"> 1340</span>                                <span class="stringliteral">&quot;DataFrame or Series is deprecated and will &quot;</span></div>
<div class="line"><span class="lineno"> 1341</span>                                <span class="stringliteral">&quot;raise in a future version. Use &quot;</span></div>
<div class="line"><span class="lineno"> 1342</span>                                <span class="stringliteral">&quot;`pd.Series(values).dt.tz_localize(None)` &quot;</span></div>
<div class="line"><span class="lineno"> 1343</span>                                <span class="stringliteral">&quot;instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1344</span>                                FutureWarning,</div>
<div class="line"><span class="lineno"> 1345</span>                                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1346</span>                            )</div>
<div class="line"><span class="lineno"> 1347</span>                            <span class="comment"># equiv: dta.view(dtype)</span></div>
<div class="line"><span class="lineno"> 1348</span>                            <span class="comment"># Note: NOT equivalent to dta.astype(dtype)</span></div>
<div class="line"><span class="lineno"> 1349</span>                            dta = dta.tz_localize(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1350</span> </div>
<div class="line"><span class="lineno"> 1351</span>                        value = dta</div>
<div class="line"><span class="lineno"> 1352</span>                    <span class="keywordflow">elif</span> is_datetime64tz:</div>
<div class="line"><span class="lineno"> 1353</span>                        dtype = cast(DatetimeTZDtype, dtype)</div>
<div class="line"><span class="lineno"> 1354</span>                        <span class="comment"># The string check can be removed once issue #13712</span></div>
<div class="line"><span class="lineno"> 1355</span>                        <span class="comment"># is solved. String data that is passed with a</span></div>
<div class="line"><span class="lineno"> 1356</span>                        <span class="comment"># datetime64tz is assumed to be naive which should</span></div>
<div class="line"><span class="lineno"> 1357</span>                        <span class="comment"># be localized to the timezone.</span></div>
<div class="line"><span class="lineno"> 1358</span>                        is_dt_string = is_string_dtype(value.dtype)</div>
<div class="line"><span class="lineno"> 1359</span>                        dta = sequence_to_datetimes(value)</div>
<div class="line"><span class="lineno"> 1360</span>                        <span class="keywordflow">if</span> dta.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1361</span>                            value = dta.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1362</span>                        <span class="keywordflow">elif</span> is_dt_string:</div>
<div class="line"><span class="lineno"> 1363</span>                            <span class="comment"># Strings here are naive, so directly localize</span></div>
<div class="line"><span class="lineno"> 1364</span>                            <span class="comment"># equiv: dta.astype(dtype)  # though deprecated</span></div>
<div class="line"><span class="lineno"> 1365</span> </div>
<div class="line"><span class="lineno"> 1366</span>                            value = dta.tz_localize(dtype.tz)</div>
<div class="line"><span class="lineno"> 1367</span>                        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1368</span>                            <span class="comment"># Numeric values are UTC at this point,</span></div>
<div class="line"><span class="lineno"> 1369</span>                            <span class="comment"># so localize and convert</span></div>
<div class="line"><span class="lineno"> 1370</span>                            <span class="comment"># equiv: Series(dta).astype(dtype) # though deprecated</span></div>
<div class="line"><span class="lineno"> 1371</span>                            <span class="keywordflow">if</span> getattr(vdtype, <span class="stringliteral">&quot;kind&quot;</span>, <span class="keywordtype">None</span>) == <span class="stringliteral">&quot;M&quot;</span>:</div>
<div class="line"><span class="lineno"> 1372</span>                                <span class="comment"># GH#24559, GH#33401 deprecate behavior inconsistent</span></div>
<div class="line"><span class="lineno"> 1373</span>                                <span class="comment">#  with DatetimeArray/DatetimeIndex</span></div>
<div class="line"><span class="lineno"> 1374</span>                                warnings.warn(</div>
<div class="line"><span class="lineno"> 1375</span>                                    <span class="stringliteral">&quot;In a future version, constructing a Series &quot;</span></div>
<div class="line"><span class="lineno"> 1376</span>                                    <span class="stringliteral">&quot;from datetime64[ns] data and a &quot;</span></div>
<div class="line"><span class="lineno"> 1377</span>                                    <span class="stringliteral">&quot;DatetimeTZDtype will interpret the data &quot;</span></div>
<div class="line"><span class="lineno"> 1378</span>                                    <span class="stringliteral">&quot;as wall-times instead of &quot;</span></div>
<div class="line"><span class="lineno"> 1379</span>                                    <span class="stringliteral">&quot;UTC times, matching the behavior of &quot;</span></div>
<div class="line"><span class="lineno"> 1380</span>                                    <span class="stringliteral">&quot;DatetimeIndex. To treat the data as UTC &quot;</span></div>
<div class="line"><span class="lineno"> 1381</span>                                    <span class="stringliteral">&quot;times, use pd.Series(data).dt&quot;</span></div>
<div class="line"><span class="lineno"> 1382</span>                                    <span class="stringliteral">&quot;.tz_localize(&#39;UTC&#39;).tz_convert(dtype.tz) &quot;</span></div>
<div class="line"><span class="lineno"> 1383</span>                                    <span class="stringliteral">&quot;or pd.Series(data.view(&#39;int64&#39;), dtype=dtype)&quot;</span>,</div>
<div class="line"><span class="lineno"> 1384</span>                                    FutureWarning,</div>
<div class="line"><span class="lineno"> 1385</span>                                    stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1386</span>                                )</div>
<div class="line"><span class="lineno"> 1387</span> </div>
<div class="line"><span class="lineno"> 1388</span>                            value = dta.tz_localize(<span class="stringliteral">&quot;UTC&quot;</span>).tz_convert(dtype.tz)</div>
<div class="line"><span class="lineno"> 1389</span>                <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno"> 1390</span>                    <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 1391</span>                <span class="keywordflow">except</span> ParserError:</div>
<div class="line"><span class="lineno"> 1392</span>                    <span class="comment"># Note: this is dateutil&#39;s ParserError, not ours.</span></div>
<div class="line"><span class="lineno"> 1393</span>                    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1394</span> </div>
<div class="line"><span class="lineno"> 1395</span>        <span class="keywordflow">elif</span> getattr(vdtype, <span class="stringliteral">&quot;kind&quot;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1396</span>            <span class="comment"># we are already datetimelike and want to coerce to non-datetimelike;</span></div>
<div class="line"><span class="lineno"> 1397</span>            <span class="comment">#  astype_nansafe will raise for anything other than object, then upcast.</span></div>
<div class="line"><span class="lineno"> 1398</span>            <span class="comment">#  see test_datetimelike_values_with_object_dtype</span></div>
<div class="line"><span class="lineno"> 1399</span>            <span class="comment"># error: Argument 2 to &quot;astype_nansafe&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 1400</span>            <span class="comment"># &quot;Union[dtype[Any], ExtensionDtype]&quot;; expected &quot;dtype[Any]&quot;</span></div>
<div class="line"><span class="lineno"> 1401</span>            <span class="keywordflow">return</span> astype_nansafe(value, dtype)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 1402</span> </div>
<div class="line"><span class="lineno"> 1403</span>    <span class="keywordflow">elif</span> isinstance(value, np.ndarray):</div>
<div class="line"><span class="lineno"> 1404</span>        <span class="keywordflow">if</span> value.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;M&quot;</span>, <span class="stringliteral">&quot;m&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1405</span>            <span class="comment"># catch a datetime/timedelta that is not of ns variety</span></div>
<div class="line"><span class="lineno"> 1406</span>            <span class="comment"># and no coercion specified</span></div>
<div class="line"><span class="lineno"> 1407</span>            value = sanitize_to_nanoseconds(value)</div>
<div class="line"><span class="lineno"> 1408</span> </div>
<div class="line"><span class="lineno"> 1409</span>        <span class="keywordflow">elif</span> value.dtype == _dtype_obj:</div>
<div class="line"><span class="lineno"> 1410</span>            value = maybe_infer_to_datetimelike(value)</div>
<div class="line"><span class="lineno"> 1411</span> </div>
<div class="line"><span class="lineno"> 1412</span>    <span class="keywordflow">elif</span> isinstance(value, list):</div>
<div class="line"><span class="lineno"> 1413</span>        <span class="comment"># we only get here with dtype=None, which we do not allow</span></div>
<div class="line"><span class="lineno"> 1414</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1415</span>            <span class="stringliteral">&quot;maybe_cast_to_datetime allows a list *only* if dtype is not None&quot;</span></div>
<div class="line"><span class="lineno"> 1416</span>        )</div>
<div class="line"><span class="lineno"> 1417</span> </div>
<div class="line"><span class="lineno"> 1418</span>    <span class="comment"># at this point we have converted or raised in all cases where we had a list</span></div>
<div class="line"><span class="lineno"> 1419</span>    <span class="keywordflow">return</span> cast(ArrayLike, value)</div>
<div class="line"><span class="lineno"> 1420</span> </div>
<div class="line"><span class="lineno"> 1421</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1datetimes_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1datetimes.html">pandas.core.arrays.datetimes</a></div><div class="ttdef"><b>Definition</b> datetimes.py:1</div></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1timedeltas_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1timedeltas.html">pandas.core.arrays.timedeltas</a></div><div class="ttdef"><b>Definition</b> timedeltas.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abc6a7fe82dc981d3a48511027abacefd" name="abc6a7fe82dc981d3a48511027abacefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6a7fe82dc981d3a48511027abacefd">&#9670;&#160;</a></span>maybe_cast_to_extension_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.maybe_cast_to_extension_array </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtensionDtype | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Call to `_from_sequence` that returns the object unchanged on Exception.

Parameters
----------
cls : class, subclass of ExtensionArray
obj : arraylike
    Values to pass to cls._from_sequence
dtype : ExtensionDtype, optional

Returns
-------
ExtensionArray or obj
</pre> <div class="fragment"><div class="line"><span class="lineno">  465</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  466</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    Call to `_from_sequence` that returns the object unchanged on Exception.</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    cls : class, subclass of ExtensionArray</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    obj : arraylike</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        Values to pass to cls._from_sequence</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    dtype : ExtensionDtype, optional</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    ExtensionArray or obj</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  480</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a> <span class="keyword">import</span> BaseStringArray</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span>    <span class="keyword">assert</span> isinstance(cls, type), f<span class="stringliteral">&quot;must pass a type: {cls}&quot;</span></div>
<div class="line"><span class="lineno">  483</span>    assertion_msg = f<span class="stringliteral">&quot;must pass a subclass of ExtensionArray: {cls}&quot;</span></div>
<div class="line"><span class="lineno">  484</span>    <span class="keyword">assert</span> issubclass(cls, ABCExtensionArray), assertion_msg</div>
<div class="line"><span class="lineno">  485</span> </div>
<div class="line"><span class="lineno">  486</span>    <span class="comment"># Everything can be converted to StringArrays, but we may not want to convert</span></div>
<div class="line"><span class="lineno">  487</span>    <span class="keywordflow">if</span> issubclass(cls, BaseStringArray) <span class="keywordflow">and</span> lib.infer_dtype(obj) != <span class="stringliteral">&quot;string&quot;</span>:</div>
<div class="line"><span class="lineno">  488</span>        <span class="keywordflow">return</span> obj</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  491</span>        result = cls._from_sequence(obj, dtype=dtype)</div>
<div class="line"><span class="lineno">  492</span>    <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  493</span>        <span class="comment"># We can&#39;t predict what downstream EA constructors may raise</span></div>
<div class="line"><span class="lineno">  494</span>        result = obj</div>
<div class="line"><span class="lineno">  495</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  496</span> </div>
<div class="line"><span class="lineno">  497</span> </div>
<div class="line"><span class="lineno">  498</span><span class="preprocessor">@overload</span></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1string___html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a></div><div class="ttdef"><b>Definition</b> string_.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac619cbe4b5bfd84803bbfa4e1c72a30c" name="ac619cbe4b5bfd84803bbfa4e1c72a30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac619cbe4b5bfd84803bbfa4e1c72a30c">&#9670;&#160;</a></span>maybe_cast_to_integer_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.dtypes.cast.maybe_cast_to_integer_array </td>
          <td>(</td>
          <td class="paramtype">list | np.ndarray&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Takes any dtype and returns the casted version, raising for when data is
incompatible with integer/unsigned integer dtypes.

Parameters
----------
arr : np.ndarray or list
    The array to cast.
dtype : np.dtype
    The integer dtype to cast the array to.
copy: bool, default False
    Whether to make a copy of the array before returning.

Returns
-------
ndarray
    Array of integer or unsigned integer dtype.

Raises
------
OverflowError : the dtype is incompatible with the data
ValueError : loss of precision has occurred during casting

Examples
--------
If you try to coerce negative values to unsigned integers, it raises:

&gt;&gt;&gt; pd.Series([-1], dtype="uint64")
Traceback (most recent call last):
    ...
OverflowError: Trying to coerce negative values to unsigned integers

Also, if you try to coerce float values to integers, it raises:

&gt;&gt;&gt; maybe_cast_to_integer_array([1, 2, 3.5], dtype=np.dtype("int64"))
Traceback (most recent call last):
    ...
ValueError: Trying to coerce float values to integers
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1790</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1791</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    Takes any dtype and returns the casted version, raising for when data is</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">    incompatible with integer/unsigned integer dtypes.</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">    arr : np.ndarray or list</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">        The array to cast.</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">    dtype : np.dtype</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        The integer dtype to cast the array to.</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">    copy: bool, default False</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        Whether to make a copy of the array before returning.</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    ndarray</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">        Array of integer or unsigned integer dtype.</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">    OverflowError : the dtype is incompatible with the data</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">    ValueError : loss of precision has occurred during casting</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">    If you try to coerce negative values to unsigned integers, it raises:</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">    &gt;&gt;&gt; pd.Series([-1], dtype=&quot;uint64&quot;)</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    OverflowError: Trying to coerce negative values to unsigned integers</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    Also, if you try to coerce float values to integers, it raises:</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    &gt;&gt;&gt; maybe_cast_to_integer_array([1, 2, 3.5], dtype=np.dtype(&quot;int64&quot;))</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    ValueError: Trying to coerce float values to integers</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1830</span>    <span class="keyword">assert</span> is_integer_dtype(dtype)</div>
<div class="line"><span class="lineno"> 1831</span> </div>
<div class="line"><span class="lineno"> 1832</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1833</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(arr, np.ndarray):</div>
<div class="line"><span class="lineno"> 1834</span>            casted = np.array(arr, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno"> 1835</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1836</span>            casted = arr.astype(dtype, copy=copy)</div>
<div class="line"><span class="lineno"> 1837</span>    <span class="keywordflow">except</span> OverflowError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1838</span>        <span class="keywordflow">raise</span> OverflowError(</div>
<div class="line"><span class="lineno"> 1839</span>            <span class="stringliteral">&quot;The elements provided in the data cannot all be &quot;</span></div>
<div class="line"><span class="lineno"> 1840</span>            f<span class="stringliteral">&quot;casted to the dtype {dtype}&quot;</span></div>
<div class="line"><span class="lineno"> 1841</span>        ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 1842</span> </div>
<div class="line"><span class="lineno"> 1843</span>    <span class="keywordflow">if</span> np.array_equal(arr, casted):</div>
<div class="line"><span class="lineno"> 1844</span>        <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 1845</span> </div>
<div class="line"><span class="lineno"> 1846</span>    <span class="comment"># We do this casting to allow for proper</span></div>
<div class="line"><span class="lineno"> 1847</span>    <span class="comment"># data and dtype checking.</span></div>
<div class="line"><span class="lineno"> 1848</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1849</span>    <span class="comment"># We didn&#39;t do this earlier because NumPy</span></div>
<div class="line"><span class="lineno"> 1850</span>    <span class="comment"># doesn&#39;t handle `uint64` correctly.</span></div>
<div class="line"><span class="lineno"> 1851</span>    arr = np.asarray(arr)</div>
<div class="line"><span class="lineno"> 1852</span> </div>
<div class="line"><span class="lineno"> 1853</span>    <span class="keywordflow">if</span> is_unsigned_integer_dtype(dtype) <span class="keywordflow">and</span> (arr &lt; 0).any():</div>
<div class="line"><span class="lineno"> 1854</span>        <span class="keywordflow">raise</span> OverflowError(<span class="stringliteral">&quot;Trying to coerce negative values to unsigned integers&quot;</span>)</div>
<div class="line"><span class="lineno"> 1855</span> </div>
<div class="line"><span class="lineno"> 1856</span>    <span class="keywordflow">if</span> is_float_dtype(arr.dtype):</div>
<div class="line"><span class="lineno"> 1857</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(arr).all():</div>
<div class="line"><span class="lineno"> 1858</span>            <span class="keywordflow">raise</span> IntCastingNaNError(</div>
<div class="line"><span class="lineno"> 1859</span>                <span class="stringliteral">&quot;Cannot convert non-finite values (NA or inf) to integer&quot;</span></div>
<div class="line"><span class="lineno"> 1860</span>            )</div>
<div class="line"><span class="lineno"> 1861</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Trying to coerce float values to integers&quot;</span>)</div>
<div class="line"><span class="lineno"> 1862</span>    <span class="keywordflow">if</span> is_object_dtype(arr.dtype):</div>
<div class="line"><span class="lineno"> 1863</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Trying to coerce float values to integers&quot;</span>)</div>
<div class="line"><span class="lineno"> 1864</span> </div>
<div class="line"><span class="lineno"> 1865</span>    <span class="keywordflow">if</span> casted.dtype &lt; arr.dtype:</div>
<div class="line"><span class="lineno"> 1866</span>        <span class="comment"># GH#41734 e.g. [1, 200, 923442] and dtype=&quot;int8&quot; -&gt; overflows</span></div>
<div class="line"><span class="lineno"> 1867</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1868</span>            f<span class="stringliteral">&quot;Values are too large to be losslessly cast to {dtype}. &quot;</span></div>
<div class="line"><span class="lineno"> 1869</span>            <span class="stringliteral">&quot;In a future version this will raise OverflowError. To retain the &quot;</span></div>
<div class="line"><span class="lineno"> 1870</span>            f<span class="stringliteral">&quot;old behavior, use pd.Series(values).astype({dtype})&quot;</span>,</div>
<div class="line"><span class="lineno"> 1871</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 1872</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1873</span>        )</div>
<div class="line"><span class="lineno"> 1874</span>        <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 1875</span> </div>
<div class="line"><span class="lineno"> 1876</span>    <span class="keywordflow">if</span> arr.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1877</span>        <span class="comment"># test_constructor_maskedarray_nonfloat</span></div>
<div class="line"><span class="lineno"> 1878</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1879</span>            f<span class="stringliteral">&quot;Constructing Series or DataFrame from {arr.dtype} values and &quot;</span></div>
<div class="line"><span class="lineno"> 1880</span>            f<span class="stringliteral">&quot;dtype={dtype} is deprecated and will raise in a future version. &quot;</span></div>
<div class="line"><span class="lineno"> 1881</span>            <span class="stringliteral">&quot;Use values.view(dtype) instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1882</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 1883</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1884</span>        )</div>
<div class="line"><span class="lineno"> 1885</span>        <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 1886</span> </div>
<div class="line"><span class="lineno"> 1887</span>    <span class="comment"># No known cases that get here, but raising explicitly to cover our bases.</span></div>
<div class="line"><span class="lineno"> 1888</span>    <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;values cannot be losslessly cast to {dtype}&quot;</span>)</div>
<div class="line"><span class="lineno"> 1889</span> </div>
<div class="line"><span class="lineno"> 1890</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e0546e41e53c96032a75703546ff4d9" name="a3e0546e41e53c96032a75703546ff4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0546e41e53c96032a75703546ff4d9">&#9670;&#160;</a></span>maybe_convert_platform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.maybe_convert_platform </td>
          <td>(</td>
          <td class="paramtype">list | tuple | range | np.ndarray | <a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">try to do platform conversion, allow ndarray or list here</pre> <div class="fragment"><div class="line"><span class="lineno">  122</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  123</span>    <span class="stringliteral">&quot;&quot;&quot;try to do platform conversion, allow ndarray or list here&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  124</span>    arr: ArrayLike</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">if</span> isinstance(values, (list, tuple, range)):</div>
<div class="line"><span class="lineno">  127</span>        arr = construct_1d_object_array_from_listlike(values)</div>
<div class="line"><span class="lineno">  128</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  129</span>        <span class="comment"># The caller is responsible for ensuring that we have np.ndarray</span></div>
<div class="line"><span class="lineno">  130</span>        <span class="comment">#  or ExtensionArray here.</span></div>
<div class="line"><span class="lineno">  131</span>        arr = values</div>
<div class="line"><span class="lineno">  132</span> </div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">if</span> arr.dtype == _dtype_obj:</div>
<div class="line"><span class="lineno">  134</span>        arr = cast(np.ndarray, arr)</div>
<div class="line"><span class="lineno">  135</span>        arr = lib.maybe_convert_objects(arr)</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno">  138</span> </div>
<div class="line"><span class="lineno">  139</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a76c6953eeceba193cc19b8181b38c0ee" name="a76c6953eeceba193cc19b8181b38c0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c6953eeceba193cc19b8181b38c0ee">&#9670;&#160;</a></span>maybe_downcast_numeric() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.maybe_downcast_numeric </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>do_round</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Subset of maybe_downcast_to_dtype restricted to numeric dtypes.

Parameters
----------
result : ndarray or ExtensionArray
dtype : np.dtype or ExtensionDtype
do_round : bool

Returns
-------
ndarray or ExtensionArray
</pre> <div class="fragment"><div class="line"><span class="lineno">  330</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  331</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    Subset of maybe_downcast_to_dtype restricted to numeric dtypes.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    result : ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    dtype : np.dtype or ExtensionDtype</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    do_round : bool</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  344</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, np.dtype) <span class="keywordflow">or</span> <span class="keywordflow">not</span> isinstance(result.dtype, np.dtype):</div>
<div class="line"><span class="lineno">  345</span>        <span class="comment"># e.g. SparseDtype has no itemsize attr</span></div>
<div class="line"><span class="lineno">  346</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>    <span class="keyword">def </span><a class="code hl_variable" href="__blas__subroutines_8h.html#ac2c81d916d6b7d6ad26c81ad7cfe575f">trans</a>(x):</div>
<div class="line"><span class="lineno">  349</span>        <span class="keywordflow">if</span> do_round:</div>
<div class="line"><span class="lineno">  350</span>            <span class="keywordflow">return</span> x.round()</div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  352</span> </div>
<div class="line"><span class="lineno">  353</span>    <span class="keywordflow">if</span> dtype.kind == result.dtype.kind:</div>
<div class="line"><span class="lineno">  354</span>        <span class="comment"># don&#39;t allow upcasts here (except if empty)</span></div>
<div class="line"><span class="lineno">  355</span>        <span class="keywordflow">if</span> result.dtype.itemsize &lt;= dtype.itemsize <span class="keywordflow">and</span> result.size:</div>
<div class="line"><span class="lineno">  356</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>    <span class="keywordflow">if</span> is_bool_dtype(dtype) <span class="keywordflow">or</span> is_integer_dtype(dtype):</div>
<div class="line"><span class="lineno">  359</span> </div>
<div class="line"><span class="lineno">  360</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> result.size:</div>
<div class="line"><span class="lineno">  361</span>            <span class="comment"># if we don&#39;t have any elements, just astype it</span></div>
<div class="line"><span class="lineno">  362</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="__blas__subroutines_8h.html#ac2c81d916d6b7d6ad26c81ad7cfe575f">trans</a>(result).astype(dtype)</div>
<div class="line"><span class="lineno">  363</span> </div>
<div class="line"><span class="lineno">  364</span>        <span class="comment"># do a test on the first element, if it fails then we are done</span></div>
<div class="line"><span class="lineno">  365</span>        r = result.ravel()</div>
<div class="line"><span class="lineno">  366</span>        arr = np.array([r[0]])</div>
<div class="line"><span class="lineno">  367</span> </div>
<div class="line"><span class="lineno">  368</span>        <span class="keywordflow">if</span> isna(arr).any():</div>
<div class="line"><span class="lineno">  369</span>            <span class="comment"># if we have any nulls, then we are done</span></div>
<div class="line"><span class="lineno">  370</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(r[0], (np.integer, np.floating, int, float, bool)):</div>
<div class="line"><span class="lineno">  373</span>            <span class="comment"># a comparable, e.g. a Decimal may slip in here</span></div>
<div class="line"><span class="lineno">  374</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  375</span> </div>
<div class="line"><span class="lineno">  376</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  377</span>            issubclass(result.dtype.type, (np.object_, np.number))</div>
<div class="line"><span class="lineno">  378</span>            <span class="keywordflow">and</span> notna(result).all()</div>
<div class="line"><span class="lineno">  379</span>        ):</div>
<div class="line"><span class="lineno">  380</span>            new_result = <a class="code hl_variable" href="__blas__subroutines_8h.html#ac2c81d916d6b7d6ad26c81ad7cfe575f">trans</a>(result).astype(dtype)</div>
<div class="line"><span class="lineno">  381</span>            <span class="keywordflow">if</span> new_result.dtype.kind == <span class="stringliteral">&quot;O&quot;</span> <span class="keywordflow">or</span> result.dtype.kind == <span class="stringliteral">&quot;O&quot;</span>:</div>
<div class="line"><span class="lineno">  382</span>                <span class="comment"># np.allclose may raise TypeError on object-dtype</span></div>
<div class="line"><span class="lineno">  383</span>                <span class="keywordflow">if</span> (new_result == result).all():</div>
<div class="line"><span class="lineno">  384</span>                    <span class="keywordflow">return</span> new_result</div>
<div class="line"><span class="lineno">  385</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  386</span>                <span class="keywordflow">if</span> np.allclose(new_result, result, rtol=0):</div>
<div class="line"><span class="lineno">  387</span>                    <span class="keywordflow">return</span> new_result</div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>    <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno">  390</span>        issubclass(dtype.type, np.floating)</div>
<div class="line"><span class="lineno">  391</span>        <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_bool_dtype(result.dtype)</div>
<div class="line"><span class="lineno">  392</span>        <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_string_dtype(result.dtype)</div>
<div class="line"><span class="lineno">  393</span>    ):</div>
<div class="line"><span class="lineno">  394</span>        new_result = result.astype(dtype)</div>
<div class="line"><span class="lineno">  395</span> </div>
<div class="line"><span class="lineno">  396</span>        <span class="comment"># Adjust tolerances based on floating point size</span></div>
<div class="line"><span class="lineno">  397</span>        size_tols = {4: 5e-4, 8: 5e-8, 16: 5e-16}</div>
<div class="line"><span class="lineno">  398</span> </div>
<div class="line"><span class="lineno">  399</span>        atol = size_tols.get(new_result.dtype.itemsize, 0.0)</div>
<div class="line"><span class="lineno">  400</span> </div>
<div class="line"><span class="lineno">  401</span>        <span class="comment"># Check downcast float values are still equal within 7 digits when</span></div>
<div class="line"><span class="lineno">  402</span>        <span class="comment"># converting from float64 to float32</span></div>
<div class="line"><span class="lineno">  403</span>        <span class="keywordflow">if</span> np.allclose(new_result, result, equal_nan=<span class="keyword">True</span>, rtol=0.0, atol=atol):</div>
<div class="line"><span class="lineno">  404</span>            <span class="keywordflow">return</span> new_result</div>
<div class="line"><span class="lineno">  405</span> </div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">elif</span> dtype.kind == result.dtype.kind == <span class="stringliteral">&quot;c&quot;</span>:</div>
<div class="line"><span class="lineno">  407</span>        new_result = result.astype(dtype)</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span>        <span class="keywordflow">if</span> array_equivalent(new_result, result):</div>
<div class="line"><span class="lineno">  410</span>            <span class="comment"># TODO: use tolerance like we do for float?</span></div>
<div class="line"><span class="lineno">  411</span>            <span class="keywordflow">return</span> new_result</div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  414</span> </div>
<div class="line"><span class="lineno">  415</span> </div>
<div class="ttc" id="a__blas__subroutines_8h_html_ac2c81d916d6b7d6ad26c81ad7cfe575f"><div class="ttname"><a href="__blas__subroutines_8h.html#ac2c81d916d6b7d6ad26c81ad7cfe575f">trans</a></div><div class="ttdeci">void char * trans</div><div class="ttdef"><b>Definition</b> _blas_subroutines.h:48</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a88c6ee07e6749105d874c4f76dc3e03d" name="a88c6ee07e6749105d874c4f76dc3e03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c6ee07e6749105d874c4f76dc3e03d">&#9670;&#160;</a></span>maybe_downcast_numeric() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.maybe_downcast_numeric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>do_round</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  324</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  325</span>    ...</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d76dc239d7946e45554f32bf1ed4f2f" name="a0d76dc239d7946e45554f32bf1ed4f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d76dc239d7946e45554f32bf1ed4f2f">&#9670;&#160;</a></span>maybe_downcast_numeric() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.dtypes.cast.maybe_downcast_numeric </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>do_round</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  317</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  318</span>    ...</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span> </div>
<div class="line"><span class="lineno">  321</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="acd6d26ff44449313f1e33fd9d90d5294" name="acd6d26ff44449313f1e33fd9d90d5294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6d26ff44449313f1e33fd9d90d5294">&#9670;&#160;</a></span>maybe_downcast_to_dtype() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.maybe_downcast_to_dtype </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">try to cast to the specified dtype (e.g. convert back to bool/int
or could be an astype of float64-&gt;float32
</pre> <div class="fragment"><div class="line"><span class="lineno">  259</span><span class="keyword">def </span>maybe_downcast_to_dtype(result: ArrayLike, dtype: str | np.dtype) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  260</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    try to cast to the specified dtype (e.g. convert back to bool/int</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    or could be an astype of float64-&gt;float32</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  264</span>    do_round = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span>    <span class="keywordflow">if</span> isinstance(dtype, str):</div>
<div class="line"><span class="lineno">  267</span>        <span class="keywordflow">if</span> dtype == <span class="stringliteral">&quot;infer&quot;</span>:</div>
<div class="line"><span class="lineno">  268</span>            inferred_type = lib.infer_dtype(result, skipna=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  269</span>            <span class="keywordflow">if</span> inferred_type == <span class="stringliteral">&quot;boolean&quot;</span>:</div>
<div class="line"><span class="lineno">  270</span>                dtype = <span class="stringliteral">&quot;bool&quot;</span></div>
<div class="line"><span class="lineno">  271</span>            <span class="keywordflow">elif</span> inferred_type == <span class="stringliteral">&quot;integer&quot;</span>:</div>
<div class="line"><span class="lineno">  272</span>                dtype = <span class="stringliteral">&quot;int64&quot;</span></div>
<div class="line"><span class="lineno">  273</span>            <span class="keywordflow">elif</span> inferred_type == <span class="stringliteral">&quot;datetime64&quot;</span>:</div>
<div class="line"><span class="lineno">  274</span>                dtype = <span class="stringliteral">&quot;datetime64[ns]&quot;</span></div>
<div class="line"><span class="lineno">  275</span>            <span class="keywordflow">elif</span> inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;timedelta&quot;</span>, <span class="stringliteral">&quot;timedelta64&quot;</span>]:</div>
<div class="line"><span class="lineno">  276</span>                dtype = <span class="stringliteral">&quot;timedelta64[ns]&quot;</span></div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>            <span class="comment"># try to upcast here</span></div>
<div class="line"><span class="lineno">  279</span>            <span class="keywordflow">elif</span> inferred_type == <span class="stringliteral">&quot;floating&quot;</span>:</div>
<div class="line"><span class="lineno">  280</span>                dtype = <span class="stringliteral">&quot;int64&quot;</span></div>
<div class="line"><span class="lineno">  281</span>                <span class="keywordflow">if</span> issubclass(result.dtype.type, np.number):</div>
<div class="line"><span class="lineno">  282</span>                    do_round = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  285</span>                <span class="comment"># TODO: complex?  what if result is already non-object?</span></div>
<div class="line"><span class="lineno">  286</span>                dtype = <span class="stringliteral">&quot;object&quot;</span></div>
<div class="line"><span class="lineno">  287</span> </div>
<div class="line"><span class="lineno">  288</span>        dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, np.dtype):</div>
<div class="line"><span class="lineno">  291</span>        <span class="comment"># enforce our signature annotation</span></div>
<div class="line"><span class="lineno">  292</span>        <span class="keywordflow">raise</span> TypeError(dtype)  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno">  293</span> </div>
<div class="line"><span class="lineno">  294</span>    converted = maybe_downcast_numeric(result, dtype, do_round)</div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">if</span> converted <span class="keywordflow">is</span> <span class="keywordflow">not</span> result:</div>
<div class="line"><span class="lineno">  296</span>        <span class="keywordflow">return</span> converted</div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span>    <span class="comment"># a datetimelike</span></div>
<div class="line"><span class="lineno">  299</span>    <span class="comment"># GH12821, iNaT is cast to float</span></div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">if</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;M&quot;</span>, <span class="stringliteral">&quot;m&quot;</span>] <span class="keywordflow">and</span> result.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>]:</div>
<div class="line"><span class="lineno">  301</span>        result = result.astype(dtype)</div>
<div class="line"><span class="lineno">  302</span> </div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;m&quot;</span> <span class="keywordflow">and</span> result.dtype == _dtype_obj:</div>
<div class="line"><span class="lineno">  304</span>        <span class="comment"># test_where_downcast_to_td64</span></div>
<div class="line"><span class="lineno">  305</span>        result = cast(np.ndarray, result)</div>
<div class="line"><span class="lineno">  306</span>        result = array_to_timedelta64(result)</div>
<div class="line"><span class="lineno">  307</span> </div>
<div class="line"><span class="lineno">  308</span>    <span class="keywordflow">elif</span> dtype == np.dtype(<span class="stringliteral">&quot;M8[ns]&quot;</span>) <span class="keywordflow">and</span> result.dtype == _dtype_obj:</div>
<div class="line"><span class="lineno">  309</span>        <span class="keywordflow">return</span> np.asarray(maybe_cast_to_datetime(result, dtype=dtype))</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  312</span> </div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a17cb5e241bc864174a15f96651417e4b" name="a17cb5e241bc864174a15f96651417e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cb5e241bc864174a15f96651417e4b">&#9670;&#160;</a></span>maybe_downcast_to_dtype() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.maybe_downcast_to_dtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  255</span><span class="keyword">def </span>maybe_downcast_to_dtype(result: ExtensionArray, dtype: str | np.dtype) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  256</span>    ...</div>
<div class="line"><span class="lineno">  257</span> </div>
<div class="line"><span class="lineno">  258</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a356724beda43b3474c7ece06d38ef7a6" name="a356724beda43b3474c7ece06d38ef7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356724beda43b3474c7ece06d38ef7a6">&#9670;&#160;</a></span>maybe_downcast_to_dtype() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.dtypes.cast.maybe_downcast_to_dtype </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  250</span><span class="keyword">def </span>maybe_downcast_to_dtype(result: np.ndarray, dtype: str | np.dtype) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  251</span>    ...</div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a540813e524e656a13a54d36ce795a175" name="a540813e524e656a13a54d36ce795a175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540813e524e656a13a54d36ce795a175">&#9670;&#160;</a></span>maybe_infer_to_datetimelike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray | <a class="el" href="classpandas_1_1core_1_1arrays_1_1datetimes_1_1_datetime_array.html">DatetimeArray</a> | <a class="el" href="classpandas_1_1core_1_1arrays_1_1timedeltas_1_1_timedelta_array.html">TimedeltaArray</a> | <a class="el" href="classpandas_1_1core_1_1arrays_1_1period_1_1_period_array.html">PeriodArray</a> | <a class="el" href="classpandas_1_1core_1_1arrays_1_1interval_1_1_interval_array.html">IntervalArray</a> pandas.core.dtypes.cast.maybe_infer_to_datetimelike </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">we might have a array (or single object) that is datetime like,
and no dtype is passed don't change the value unless we find a
datetime/timedelta set

this is pretty strict in that a datetime/timedelta is REQUIRED
in addition to possible nulls/string likes

Parameters
----------
value : np.ndarray[object]

Returns
-------
np.ndarray, DatetimeArray, TimedeltaArray, PeriodArray, or IntervalArray</pre> <div class="fragment"><div class="line"><span class="lineno"> 1180</span>) -&gt; np.ndarray | DatetimeArray | TimedeltaArray | PeriodArray | IntervalArray:</div>
<div class="line"><span class="lineno"> 1181</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    we might have a array (or single object) that is datetime like,</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    and no dtype is passed don&#39;t change the value unless we find a</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    datetime/timedelta set</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    this is pretty strict in that a datetime/timedelta is REQUIRED</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    in addition to possible nulls/string likes</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    value : np.ndarray[object]</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    np.ndarray, DatetimeArray, TimedeltaArray, PeriodArray, or IntervalArray</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1198</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(value, np.ndarray) <span class="keywordflow">or</span> value.dtype != object:</div>
<div class="line"><span class="lineno"> 1199</span>        <span class="comment"># Caller is responsible for passing only ndarray[object]</span></div>
<div class="line"><span class="lineno"> 1200</span>        <span class="keywordflow">raise</span> TypeError(type(value))  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno"> 1201</span> </div>
<div class="line"><span class="lineno"> 1202</span>    v = np.array(value, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1203</span> </div>
<div class="line"><span class="lineno"> 1204</span>    shape = v.shape</div>
<div class="line"><span class="lineno"> 1205</span>    <span class="keywordflow">if</span> v.ndim != 1:</div>
<div class="line"><span class="lineno"> 1206</span>        v = v.ravel()</div>
<div class="line"><span class="lineno"> 1207</span> </div>
<div class="line"><span class="lineno"> 1208</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(v):</div>
<div class="line"><span class="lineno"> 1209</span>        <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno"> 1210</span> </div>
<div class="line"><span class="lineno"> 1211</span>    <span class="keyword">def </span>try_datetime(v: np.ndarray) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1212</span>        <span class="comment"># Coerce to datetime64, datetime64tz, or in corner cases</span></div>
<div class="line"><span class="lineno"> 1213</span>        <span class="comment">#  object[datetimes]</span></div>
<div class="line"><span class="lineno"> 1214</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1datetimes.html">pandas.core.arrays.datetimes</a> <span class="keyword">import</span> sequence_to_datetimes</div>
<div class="line"><span class="lineno"> 1215</span> </div>
<div class="line"><span class="lineno"> 1216</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1217</span>            <span class="comment"># GH#19671 we pass require_iso8601 to be relatively strict</span></div>
<div class="line"><span class="lineno"> 1218</span>            <span class="comment">#  when parsing strings.</span></div>
<div class="line"><span class="lineno"> 1219</span>            dta = sequence_to_datetimes(v, require_iso8601=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1220</span>        <span class="keywordflow">except</span> (ValueError, TypeError):</div>
<div class="line"><span class="lineno"> 1221</span>            <span class="comment"># e.g. &lt;class &#39;numpy.timedelta64&#39;&gt; is not convertible to datetime</span></div>
<div class="line"><span class="lineno"> 1222</span>            <span class="keywordflow">return</span> v.reshape(shape)</div>
<div class="line"><span class="lineno"> 1223</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1224</span>            <span class="comment"># GH#19761 we may have mixed timezones, in which cast &#39;dta&#39; is</span></div>
<div class="line"><span class="lineno"> 1225</span>            <span class="comment">#  an ndarray[object].  Only 1 test</span></div>
<div class="line"><span class="lineno"> 1226</span>            <span class="comment">#  relies on this behavior, see GH#40111</span></div>
<div class="line"><span class="lineno"> 1227</span>            <span class="keywordflow">return</span> dta.reshape(shape)</div>
<div class="line"><span class="lineno"> 1228</span> </div>
<div class="line"><span class="lineno"> 1229</span>    <span class="keyword">def </span>try_timedelta(v: np.ndarray) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1230</span>        <span class="comment"># safe coerce to timedelta64</span></div>
<div class="line"><span class="lineno"> 1231</span> </div>
<div class="line"><span class="lineno"> 1232</span>        <span class="comment"># will try first with a string &amp; object conversion</span></div>
<div class="line"><span class="lineno"> 1233</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1234</span>            <span class="comment"># bc we know v.dtype == object, this is equivalent to</span></div>
<div class="line"><span class="lineno"> 1235</span>            <span class="comment">#  `np.asarray(to_timedelta(v))`, but using a lower-level API that</span></div>
<div class="line"><span class="lineno"> 1236</span>            <span class="comment">#  does not require a circular import.</span></div>
<div class="line"><span class="lineno"> 1237</span>            td_values = array_to_timedelta64(v).view(<span class="stringliteral">&quot;m8[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1238</span>        <span class="keywordflow">except</span> (ValueError, OverflowError):</div>
<div class="line"><span class="lineno"> 1239</span>            <span class="keywordflow">return</span> v.reshape(shape)</div>
<div class="line"><span class="lineno"> 1240</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1241</span>            <span class="keywordflow">return</span> td_values.reshape(shape)</div>
<div class="line"><span class="lineno"> 1242</span> </div>
<div class="line"><span class="lineno"> 1243</span>    inferred_type, seen_str = lib.infer_datetimelike_array(ensure_object(v))</div>
<div class="line"><span class="lineno"> 1244</span>    <span class="keywordflow">if</span> inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;period&quot;</span>, <span class="stringliteral">&quot;interval&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1245</span>        <span class="comment"># Incompatible return value type (got &quot;Union[ExtensionArray, ndarray]&quot;,</span></div>
<div class="line"><span class="lineno"> 1246</span>        <span class="comment"># expected &quot;Union[ndarray, DatetimeArray, TimedeltaArray, PeriodArray,</span></div>
<div class="line"><span class="lineno"> 1247</span>        <span class="comment"># IntervalArray]&quot;)</span></div>
<div class="line"><span class="lineno"> 1248</span>        <span class="keywordflow">return</span> lib.maybe_convert_objects(  <span class="comment"># type: ignore[return-value]</span></div>
<div class="line"><span class="lineno"> 1249</span>            v, convert_period=<span class="keyword">True</span>, convert_interval=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1250</span>        )</div>
<div class="line"><span class="lineno"> 1251</span> </div>
<div class="line"><span class="lineno"> 1252</span>    <span class="keywordflow">if</span> inferred_type == <span class="stringliteral">&quot;datetime&quot;</span>:</div>
<div class="line"><span class="lineno"> 1253</span>        <span class="comment"># error: Incompatible types in assignment (expression has type &quot;ExtensionArray&quot;,</span></div>
<div class="line"><span class="lineno"> 1254</span>        <span class="comment"># variable has type &quot;Union[ndarray, List[Any]]&quot;)</span></div>
<div class="line"><span class="lineno"> 1255</span>        value = try_datetime(v)  <span class="comment"># type: ignore[assignment]</span></div>
<div class="line"><span class="lineno"> 1256</span>    <span class="keywordflow">elif</span> inferred_type == <span class="stringliteral">&quot;timedelta&quot;</span>:</div>
<div class="line"><span class="lineno"> 1257</span>        value = try_timedelta(v)</div>
<div class="line"><span class="lineno"> 1258</span>    <span class="keywordflow">elif</span> inferred_type == <span class="stringliteral">&quot;nat&quot;</span>:</div>
<div class="line"><span class="lineno"> 1259</span> </div>
<div class="line"><span class="lineno"> 1260</span>        <span class="comment"># if all NaT, return as datetime</span></div>
<div class="line"><span class="lineno"> 1261</span>        <span class="keywordflow">if</span> isna(v).all():</div>
<div class="line"><span class="lineno"> 1262</span>            <span class="comment"># error: Incompatible types in assignment (expression has type</span></div>
<div class="line"><span class="lineno"> 1263</span>            <span class="comment"># &quot;ExtensionArray&quot;, variable has type &quot;Union[ndarray, List[Any]]&quot;)</span></div>
<div class="line"><span class="lineno"> 1264</span>            value = try_datetime(v)  <span class="comment"># type: ignore[assignment]</span></div>
<div class="line"><span class="lineno"> 1265</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1266</span> </div>
<div class="line"><span class="lineno"> 1267</span>            <span class="comment"># We have at least a NaT and a string</span></div>
<div class="line"><span class="lineno"> 1268</span>            <span class="comment"># try timedelta first to avoid spurious datetime conversions</span></div>
<div class="line"><span class="lineno"> 1269</span>            <span class="comment"># e.g. &#39;00:00:01&#39; is a timedelta but technically is also a datetime</span></div>
<div class="line"><span class="lineno"> 1270</span>            value = try_timedelta(v)</div>
<div class="line"><span class="lineno"> 1271</span>            <span class="keywordflow">if</span> lib.infer_dtype(value, skipna=<span class="keyword">False</span>) <span class="keywordflow">in</span> [<span class="stringliteral">&quot;mixed&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1272</span>                <span class="comment"># cannot skip missing values, as NaT implies that the string</span></div>
<div class="line"><span class="lineno"> 1273</span>                <span class="comment"># is actually a datetime</span></div>
<div class="line"><span class="lineno"> 1274</span> </div>
<div class="line"><span class="lineno"> 1275</span>                <span class="comment"># error: Incompatible types in assignment (expression has type</span></div>
<div class="line"><span class="lineno"> 1276</span>                <span class="comment"># &quot;ExtensionArray&quot;, variable has type &quot;Union[ndarray, List[Any]]&quot;)</span></div>
<div class="line"><span class="lineno"> 1277</span>                value = try_datetime(v)  <span class="comment"># type: ignore[assignment]</span></div>
<div class="line"><span class="lineno"> 1278</span> </div>
<div class="line"><span class="lineno"> 1279</span>    <span class="keywordflow">if</span> value.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>] <span class="keywordflow">and</span> seen_str:</div>
<div class="line"><span class="lineno"> 1280</span>        <span class="comment"># TODO(2.0): enforcing this deprecation should close GH#40111</span></div>
<div class="line"><span class="lineno"> 1281</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1282</span>            f<span class="stringliteral">&quot;Inferring {value.dtype} from data containing strings is deprecated &quot;</span></div>
<div class="line"><span class="lineno"> 1283</span>            <span class="stringliteral">&quot;and will be removed in a future version. To retain the old behavior &quot;</span></div>
<div class="line"><span class="lineno"> 1284</span>            f<span class="stringliteral">&quot;explicitly pass Series(data, dtype={value.dtype})&quot;</span>,</div>
<div class="line"><span class="lineno"> 1285</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 1286</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1287</span>        )</div>
<div class="line"><span class="lineno"> 1288</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno"> 1289</span> </div>
<div class="line"><span class="lineno"> 1290</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a52f0326c6219165515fbe3f031dd31e0" name="a52f0326c6219165515fbe3f031dd31e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f0326c6219165515fbe3f031dd31e0">&#9670;&#160;</a></span>maybe_promote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast.maybe_promote </td>
          <td>(</td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>np.nan</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the minimal dtype that can hold both the given dtype and fill_value.

Parameters
----------
dtype : np.dtype
fill_value : scalar, default np.nan

Returns
-------
dtype
    Upcasted from dtype argument if necessary.
fill_value
    Upcasted from fill_value argument if necessary.

Raises
------
ValueError
    If fill_value is a non-scalar and dtype is not object.
</pre> <div class="fragment"><div class="line"><span class="lineno">  527</span><span class="keyword">def </span>maybe_promote(dtype: np.dtype, fill_value=np.nan):</div>
<div class="line"><span class="lineno">  528</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    Find the minimal dtype that can hold both the given dtype and fill_value.</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    dtype : np.dtype</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    fill_value : scalar, default np.nan</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    dtype</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">        Upcasted from dtype argument if necessary.</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    fill_value</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        Upcasted from fill_value argument if necessary.</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        If fill_value is a non-scalar and dtype is not object.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  548</span>    <span class="comment"># TODO(2.0): need to directly use the non-cached version as long as we</span></div>
<div class="line"><span class="lineno">  549</span>    <span class="comment"># possibly raise a deprecation warning for datetime dtype</span></div>
<div class="line"><span class="lineno">  550</span>    <span class="keywordflow">if</span> dtype.kind == <span class="stringliteral">&quot;M&quot;</span>:</div>
<div class="line"><span class="lineno">  551</span>        <span class="keywordflow">return</span> _maybe_promote(dtype, fill_value)</div>
<div class="line"><span class="lineno">  552</span>    <span class="comment"># for performance, we are using a cached version of the actual implementation</span></div>
<div class="line"><span class="lineno">  553</span>    <span class="comment"># of the function in _maybe_promote. However, this doesn&#39;t always work (in case</span></div>
<div class="line"><span class="lineno">  554</span>    <span class="comment"># of non-hashable arguments), so we fallback to the actual implementation if needed</span></div>
<div class="line"><span class="lineno">  555</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  556</span>        <span class="comment"># error: Argument 3 to &quot;__call__&quot; of &quot;_lru_cache_wrapper&quot; has incompatible type</span></div>
<div class="line"><span class="lineno">  557</span>        <span class="comment"># &quot;Type[Any]&quot;; expected &quot;Hashable&quot;  [arg-type]</span></div>
<div class="line"><span class="lineno">  558</span>        <span class="keywordflow">return</span> _maybe_promote_cached(</div>
<div class="line"><span class="lineno">  559</span>            dtype, fill_value, type(fill_value)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  560</span>        )</div>
<div class="line"><span class="lineno">  561</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  562</span>        <span class="comment"># if fill_value is not hashable (required for caching)</span></div>
<div class="line"><span class="lineno">  563</span>        <span class="keywordflow">return</span> _maybe_promote(dtype, fill_value)</div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span><span class="preprocessor">@functools.lru_cache(maxsize=128)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a19f07ece1cc06aa845bab6fc63bdc405" name="a19f07ece1cc06aa845bab6fc63bdc405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f07ece1cc06aa845bab6fc63bdc405">&#9670;&#160;</a></span>maybe_upcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae3e5050f68fa519a6bfa4a03c069fca2">NumpyArrayT</a>, Scalar] pandas.core.dtypes.cast.maybe_upcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1dtypes_1_1cast.html#ae3e5050f68fa519a6bfa4a03c069fca2">NumpyArrayT</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>np.nan</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide explicit type promotion and coercion.

Parameters
----------
values : np.ndarray
    The array that we may want to upcast.
fill_value : what we want to fill with
copy : bool, default True
    If True always make a copy even if no upcast is required.

Returns
-------
values: np.ndarray
    the original array, possibly upcast
fill_value:
    the fill value, possibly upcast
</pre> <div class="fragment"><div class="line"><span class="lineno">  957</span>) -&gt; tuple[NumpyArrayT, Scalar]:</div>
<div class="line"><span class="lineno">  958</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    Provide explicit type promotion and coercion.</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    values : np.ndarray</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">        The array that we may want to upcast.</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    fill_value : what we want to fill with</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    copy : bool, default True</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">        If True always make a copy even if no upcast is required.</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    values: np.ndarray</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">        the original array, possibly upcast</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    fill_value:</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        the fill value, possibly upcast</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  976</span>    new_dtype, fill_value = maybe_promote(values.dtype, fill_value)</div>
<div class="line"><span class="lineno">  977</span>    <span class="comment"># We get a copy in all cases _except_ (values.dtype == new_dtype and not copy)</span></div>
<div class="line"><span class="lineno">  978</span>    upcast_values = values.astype(new_dtype, copy=copy)</div>
<div class="line"><span class="lineno">  979</span> </div>
<div class="line"><span class="lineno">  980</span>    <span class="comment"># error: Incompatible return value type (got &quot;Tuple[ndarray[Any, dtype[Any]],</span></div>
<div class="line"><span class="lineno">  981</span>    <span class="comment"># Union[Union[str, int, float, bool] Union[Period, Timestamp, Timedelta, Any]]]&quot;,</span></div>
<div class="line"><span class="lineno">  982</span>    <span class="comment"># expected &quot;Tuple[NumpyArrayT, Union[Union[str, int, float, bool], Union[Period,</span></div>
<div class="line"><span class="lineno">  983</span>    <span class="comment"># Timestamp, Timedelta, Any]]]&quot;)</span></div>
<div class="line"><span class="lineno">  984</span>    <span class="keywordflow">return</span> upcast_values, fill_value  <span class="comment"># type: ignore[return-value]</span></div>
<div class="line"><span class="lineno">  985</span> </div>
<div class="line"><span class="lineno">  986</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af4b8205415aa199b12a0de6bccfafc6d" name="af4b8205415aa199b12a0de6bccfafc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b8205415aa199b12a0de6bccfafc6d">&#9670;&#160;</a></span>np_can_hold_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pandas.core.dtypes.cast.np_can_hold_element </td>
          <td>(</td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Raise if we cannot losslessly set this element into an ndarray with this dtype.

Specifically about places where we disagree with numpy.  i.e. there are
cases where numpy will raise in doing the setitem that we do not check
for here, e.g. setting str "X" into a numeric ndarray.

Returns
-------
Any
    The element, potentially cast to the dtype.

Raises
------
ValueError : If we cannot losslessly store this element with this dtype.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1931</span><span class="keyword">def </span>np_can_hold_element(dtype: np.dtype, element: Any) -&gt; Any:</div>
<div class="line"><span class="lineno"> 1932</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">    Raise if we cannot losslessly set this element into an ndarray with this dtype.</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral">    Specifically about places where we disagree with numpy.  i.e. there are</span></div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral">    cases where numpy will raise in doing the setitem that we do not check</span></div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral">    for here, e.g. setting str &quot;X&quot; into a numeric ndarray.</span></div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral">    Any</span></div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">        The element, potentially cast to the dtype.</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">    ValueError : If we cannot losslessly store this element with this dtype.</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1948</span>    <span class="keywordflow">if</span> dtype == _dtype_obj:</div>
<div class="line"><span class="lineno"> 1949</span>        <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 1950</span> </div>
<div class="line"><span class="lineno"> 1951</span>    tipo = _maybe_infer_dtype_type(element)</div>
<div class="line"><span class="lineno"> 1952</span> </div>
<div class="line"><span class="lineno"> 1953</span>    <span class="keywordflow">if</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1954</span>        <span class="keywordflow">if</span> isinstance(element, range):</div>
<div class="line"><span class="lineno"> 1955</span>            <span class="keywordflow">if</span> _dtype_can_hold_range(element, dtype):</div>
<div class="line"><span class="lineno"> 1956</span>                <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 1957</span>            <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 1958</span> </div>
<div class="line"><span class="lineno"> 1959</span>        <span class="keywordflow">elif</span> is_integer(element) <span class="keywordflow">or</span> (is_float(element) <span class="keywordflow">and</span> element.is_integer()):</div>
<div class="line"><span class="lineno"> 1960</span>            <span class="comment"># e.g. test_setitem_series_int8 if we have a python int 1</span></div>
<div class="line"><span class="lineno"> 1961</span>            <span class="comment">#  tipo may be np.int32, despite the fact that it will fit</span></div>
<div class="line"><span class="lineno"> 1962</span>            <span class="comment">#  in smaller int dtypes.</span></div>
<div class="line"><span class="lineno"> 1963</span>            info = np.iinfo(dtype)</div>
<div class="line"><span class="lineno"> 1964</span>            <span class="keywordflow">if</span> info.min &lt;= element &lt;= info.max:</div>
<div class="line"><span class="lineno"> 1965</span>                <span class="keywordflow">return</span> dtype.type(element)</div>
<div class="line"><span class="lineno"> 1966</span>            <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 1967</span> </div>
<div class="line"><span class="lineno"> 1968</span>        <span class="keywordflow">if</span> tipo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1969</span>            <span class="keywordflow">if</span> tipo.kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1970</span>                <span class="keywordflow">if</span> isinstance(element, np.ndarray) <span class="keywordflow">and</span> element.dtype.kind == <span class="stringliteral">&quot;f&quot;</span>:</div>
<div class="line"><span class="lineno"> 1971</span>                    <span class="comment"># If all can be losslessly cast to integers, then we can hold them</span></div>
<div class="line"><span class="lineno"> 1972</span>                    <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno"> 1973</span>                        <span class="comment"># We check afterwards if cast was losslessly, so no need to show</span></div>
<div class="line"><span class="lineno"> 1974</span>                        <span class="comment"># the warning</span></div>
<div class="line"><span class="lineno"> 1975</span>                        casted = element.astype(dtype)</div>
<div class="line"><span class="lineno"> 1976</span>                    comp = casted == element</div>
<div class="line"><span class="lineno"> 1977</span>                    <span class="keywordflow">if</span> comp.all():</div>
<div class="line"><span class="lineno"> 1978</span>                        <span class="comment"># Return the casted values bc they can be passed to</span></div>
<div class="line"><span class="lineno"> 1979</span>                        <span class="comment">#  np.putmask, whereas the raw values cannot.</span></div>
<div class="line"><span class="lineno"> 1980</span>                        <span class="comment">#  see TestSetitemFloatNDarrayIntoIntegerSeries</span></div>
<div class="line"><span class="lineno"> 1981</span>                        <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 1982</span>                    <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 1983</span> </div>
<div class="line"><span class="lineno"> 1984</span>                <span class="comment"># Anything other than integer we cannot hold</span></div>
<div class="line"><span class="lineno"> 1985</span>                <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 1986</span>            <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno"> 1987</span>                dtype.kind == <span class="stringliteral">&quot;u&quot;</span></div>
<div class="line"><span class="lineno"> 1988</span>                <span class="keywordflow">and</span> isinstance(element, np.ndarray)</div>
<div class="line"><span class="lineno"> 1989</span>                <span class="keywordflow">and</span> element.dtype.kind == <span class="stringliteral">&quot;i&quot;</span></div>
<div class="line"><span class="lineno"> 1990</span>            ):</div>
<div class="line"><span class="lineno"> 1991</span>                <span class="comment"># see test_where_uint64</span></div>
<div class="line"><span class="lineno"> 1992</span>                casted = element.astype(dtype)</div>
<div class="line"><span class="lineno"> 1993</span>                <span class="keywordflow">if</span> (casted == element).all():</div>
<div class="line"><span class="lineno"> 1994</span>                    <span class="comment"># TODO: faster to check (element &gt;=0).all()?  potential</span></div>
<div class="line"><span class="lineno"> 1995</span>                    <span class="comment">#  itemsize issues there?</span></div>
<div class="line"><span class="lineno"> 1996</span>                    <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 1997</span>                <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 1998</span>            <span class="keywordflow">elif</span> dtype.itemsize &lt; tipo.itemsize:</div>
<div class="line"><span class="lineno"> 1999</span>                <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2000</span>            <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(tipo, np.dtype):</div>
<div class="line"><span class="lineno"> 2001</span>                <span class="comment"># i.e. nullable IntegerDtype; we can put this into an ndarray</span></div>
<div class="line"><span class="lineno"> 2002</span>                <span class="comment">#  losslessly iff it has no NAs</span></div>
<div class="line"><span class="lineno"> 2003</span>                <span class="keywordflow">if</span> element._hasna:</div>
<div class="line"><span class="lineno"> 2004</span>                    <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2005</span>                <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2006</span> </div>
<div class="line"><span class="lineno"> 2007</span>            <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2008</span> </div>
<div class="line"><span class="lineno"> 2009</span>        <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2010</span> </div>
<div class="line"><span class="lineno"> 2011</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;f&quot;</span>:</div>
<div class="line"><span class="lineno"> 2012</span>        <span class="keywordflow">if</span> lib.is_integer(element) <span class="keywordflow">or</span> lib.is_float(element):</div>
<div class="line"><span class="lineno"> 2013</span>            casted = dtype.type(element)</div>
<div class="line"><span class="lineno"> 2014</span>            <span class="keywordflow">if</span> np.isnan(casted) <span class="keywordflow">or</span> casted == element:</div>
<div class="line"><span class="lineno"> 2015</span>                <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 2016</span>            <span class="comment"># otherwise e.g. overflow see TestCoercionFloat32</span></div>
<div class="line"><span class="lineno"> 2017</span>            <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2018</span> </div>
<div class="line"><span class="lineno"> 2019</span>        <span class="keywordflow">if</span> tipo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2020</span>            <span class="comment"># TODO: itemsize check?</span></div>
<div class="line"><span class="lineno"> 2021</span>            <span class="keywordflow">if</span> tipo.kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]:</div>
<div class="line"><span class="lineno"> 2022</span>                <span class="comment"># Anything other than float/integer we cannot hold</span></div>
<div class="line"><span class="lineno"> 2023</span>                <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2024</span>            <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(tipo, np.dtype):</div>
<div class="line"><span class="lineno"> 2025</span>                <span class="comment"># i.e. nullable IntegerDtype or FloatingDtype;</span></div>
<div class="line"><span class="lineno"> 2026</span>                <span class="comment">#  we can put this into an ndarray losslessly iff it has no NAs</span></div>
<div class="line"><span class="lineno"> 2027</span>                <span class="keywordflow">if</span> element._hasna:</div>
<div class="line"><span class="lineno"> 2028</span>                    <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2029</span>                <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2030</span>            <span class="keywordflow">elif</span> tipo.itemsize &gt; dtype.itemsize <span class="keywordflow">or</span> tipo.kind != dtype.kind:</div>
<div class="line"><span class="lineno"> 2031</span>                <span class="keywordflow">if</span> isinstance(element, np.ndarray):</div>
<div class="line"><span class="lineno"> 2032</span>                    <span class="comment"># e.g. TestDataFrameIndexingWhere::test_where_alignment</span></div>
<div class="line"><span class="lineno"> 2033</span>                    casted = element.astype(dtype)</div>
<div class="line"><span class="lineno"> 2034</span>                    <span class="comment"># TODO(np&gt;=1.20): we can just use np.array_equal with equal_nan</span></div>
<div class="line"><span class="lineno"> 2035</span>                    <span class="keywordflow">if</span> array_equivalent(casted, element):</div>
<div class="line"><span class="lineno"> 2036</span>                        <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 2037</span>                    <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2038</span> </div>
<div class="line"><span class="lineno"> 2039</span>            <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2040</span> </div>
<div class="line"><span class="lineno"> 2041</span>        <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2042</span> </div>
<div class="line"><span class="lineno"> 2043</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;c&quot;</span>:</div>
<div class="line"><span class="lineno"> 2044</span>        <span class="keywordflow">if</span> lib.is_integer(element) <span class="keywordflow">or</span> lib.is_complex(element) <span class="keywordflow">or</span> lib.is_float(element):</div>
<div class="line"><span class="lineno"> 2045</span>            <span class="keywordflow">if</span> np.isnan(element):</div>
<div class="line"><span class="lineno"> 2046</span>                <span class="comment"># see test_where_complex GH#6345</span></div>
<div class="line"><span class="lineno"> 2047</span>                <span class="keywordflow">return</span> dtype.type(element)</div>
<div class="line"><span class="lineno"> 2048</span> </div>
<div class="line"><span class="lineno"> 2049</span>            casted = dtype.type(element)</div>
<div class="line"><span class="lineno"> 2050</span>            <span class="keywordflow">if</span> casted == element:</div>
<div class="line"><span class="lineno"> 2051</span>                <span class="keywordflow">return</span> casted</div>
<div class="line"><span class="lineno"> 2052</span>            <span class="comment"># otherwise e.g. overflow see test_32878_complex_itemsize</span></div>
<div class="line"><span class="lineno"> 2053</span>            <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2054</span> </div>
<div class="line"><span class="lineno"> 2055</span>        <span class="keywordflow">if</span> tipo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2056</span>            <span class="keywordflow">if</span> tipo.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]:</div>
<div class="line"><span class="lineno"> 2057</span>                <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2058</span>            <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2059</span>        <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2060</span> </div>
<div class="line"><span class="lineno"> 2061</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;b&quot;</span>:</div>
<div class="line"><span class="lineno"> 2062</span>        <span class="keywordflow">if</span> tipo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2063</span>            <span class="keywordflow">if</span> tipo.kind == <span class="stringliteral">&quot;b&quot;</span>:</div>
<div class="line"><span class="lineno"> 2064</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(tipo, np.dtype):</div>
<div class="line"><span class="lineno"> 2065</span>                    <span class="comment"># i.e. we have a BooleanArray</span></div>
<div class="line"><span class="lineno"> 2066</span>                    <span class="keywordflow">if</span> element._hasna:</div>
<div class="line"><span class="lineno"> 2067</span>                        <span class="comment"># i.e. there are pd.NA elements</span></div>
<div class="line"><span class="lineno"> 2068</span>                        <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2069</span>                <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2070</span>            <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2071</span>        <span class="keywordflow">if</span> lib.is_bool(element):</div>
<div class="line"><span class="lineno"> 2072</span>            <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2073</span>        <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2074</span> </div>
<div class="line"><span class="lineno"> 2075</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;S&quot;</span>:</div>
<div class="line"><span class="lineno"> 2076</span>        <span class="comment"># TODO: test tests.frame.methods.test_replace tests get here,</span></div>
<div class="line"><span class="lineno"> 2077</span>        <span class="comment">#  need more targeted tests.  xref phofl has a PR about this</span></div>
<div class="line"><span class="lineno"> 2078</span>        <span class="keywordflow">if</span> tipo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2079</span>            <span class="keywordflow">if</span> tipo.kind == <span class="stringliteral">&quot;S&quot;</span> <span class="keywordflow">and</span> tipo.itemsize &lt;= dtype.itemsize:</div>
<div class="line"><span class="lineno"> 2080</span>                <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2081</span>            <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2082</span>        <span class="keywordflow">if</span> isinstance(element, bytes) <span class="keywordflow">and</span> len(element) &lt;= dtype.itemsize:</div>
<div class="line"><span class="lineno"> 2083</span>            <span class="keywordflow">return</span> element</div>
<div class="line"><span class="lineno"> 2084</span>        <span class="keywordflow">raise</span> LossySetitemError</div>
<div class="line"><span class="lineno"> 2085</span> </div>
<div class="line"><span class="lineno"> 2086</span>    <span class="keywordflow">raise</span> NotImplementedError(dtype)</div>
<div class="line"><span class="lineno"> 2087</span> </div>
<div class="line"><span class="lineno"> 2088</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a627ccf521987cc11e81a5a91f137a72e" name="a627ccf521987cc11e81a5a91f137a72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627ccf521987cc11e81a5a91f137a72e">&#9670;&#160;</a></span>sanitize_to_nanoseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.dtypes.cast.sanitize_to_nanoseconds </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Safely convert non-nanosecond datetime64 or timedelta64 values to nanosecond.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1422</span><span class="keyword">def </span>sanitize_to_nanoseconds(values: np.ndarray, copy: bool = <span class="keyword">False</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1423</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    Safely convert non-nanosecond datetime64 or timedelta64 values to nanosecond.</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1426</span>    dtype = values.dtype</div>
<div class="line"><span class="lineno"> 1427</span>    <span class="keywordflow">if</span> dtype.kind == <span class="stringliteral">&quot;M&quot;</span> <span class="keywordflow">and</span> dtype != DT64NS_DTYPE:</div>
<div class="line"><span class="lineno"> 1428</span>        values = astype_overflowsafe(values, dtype=DT64NS_DTYPE)</div>
<div class="line"><span class="lineno"> 1429</span> </div>
<div class="line"><span class="lineno"> 1430</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;m&quot;</span> <span class="keywordflow">and</span> dtype != TD64NS_DTYPE:</div>
<div class="line"><span class="lineno"> 1431</span>        values = astype_overflowsafe(values, dtype=TD64NS_DTYPE)</div>
<div class="line"><span class="lineno"> 1432</span> </div>
<div class="line"><span class="lineno"> 1433</span>    <span class="keywordflow">elif</span> copy:</div>
<div class="line"><span class="lineno"> 1434</span>        values = values.copy()</div>
<div class="line"><span class="lineno"> 1435</span> </div>
<div class="line"><span class="lineno"> 1436</span>    <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1437</span> </div>
<div class="line"><span class="lineno"> 1438</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a62553df99bf32375d2ff83b7f0427816" name="a62553df99bf32375d2ff83b7f0427816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62553df99bf32375d2ff83b7f0427816">&#9670;&#160;</a></span>soft_convert_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.dtypes.cast.soft_convert_objects </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>datetime</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>numeric</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>timedelta</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>period</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to coerce datetime, timedelta, and numeric object-dtype columns
to inferred dtype.

Parameters
----------
values : np.ndarray[object]
datetime : bool, default True
numeric: bool, default True
timedelta : bool, default True
period : bool, default True
copy : bool, default True

Returns
-------
np.ndarray or ExtensionArray
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1023</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1024</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    Try to coerce datetime, timedelta, and numeric object-dtype columns</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    to inferred dtype.</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    values : np.ndarray[object]</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    datetime : bool, default True</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    numeric: bool, default True</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    timedelta : bool, default True</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    period : bool, default True</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    copy : bool, default True</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1041</span>    validate_bool_kwarg(datetime, <span class="stringliteral">&quot;datetime&quot;</span>)</div>
<div class="line"><span class="lineno"> 1042</span>    validate_bool_kwarg(numeric, <span class="stringliteral">&quot;numeric&quot;</span>)</div>
<div class="line"><span class="lineno"> 1043</span>    validate_bool_kwarg(timedelta, <span class="stringliteral">&quot;timedelta&quot;</span>)</div>
<div class="line"><span class="lineno"> 1044</span>    validate_bool_kwarg(copy, <span class="stringliteral">&quot;copy&quot;</span>)</div>
<div class="line"><span class="lineno"> 1045</span> </div>
<div class="line"><span class="lineno"> 1046</span>    conversion_count = sum((datetime, numeric, timedelta))</div>
<div class="line"><span class="lineno"> 1047</span>    <span class="keywordflow">if</span> conversion_count == 0:</div>
<div class="line"><span class="lineno"> 1048</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;At least one of datetime, numeric or timedelta must be True.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1049</span> </div>
<div class="line"><span class="lineno"> 1050</span>    <span class="comment"># Soft conversions</span></div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">if</span> datetime <span class="keywordflow">or</span> timedelta:</div>
<div class="line"><span class="lineno"> 1052</span>        <span class="comment"># GH 20380, when datetime is beyond year 2262, hence outside</span></div>
<div class="line"><span class="lineno"> 1053</span>        <span class="comment"># bound of nanosecond-resolution 64-bit integers.</span></div>
<div class="line"><span class="lineno"> 1054</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1055</span>            converted = lib.maybe_convert_objects(</div>
<div class="line"><span class="lineno"> 1056</span>                values,</div>
<div class="line"><span class="lineno"> 1057</span>                convert_datetime=datetime,</div>
<div class="line"><span class="lineno"> 1058</span>                convert_timedelta=timedelta,</div>
<div class="line"><span class="lineno"> 1059</span>                convert_period=period,</div>
<div class="line"><span class="lineno"> 1060</span>            )</div>
<div class="line"><span class="lineno"> 1061</span>        <span class="keywordflow">except</span> (OutOfBoundsDatetime, ValueError):</div>
<div class="line"><span class="lineno"> 1062</span>            <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1063</span>        <span class="keywordflow">if</span> converted <span class="keywordflow">is</span> <span class="keywordflow">not</span> values:</div>
<div class="line"><span class="lineno"> 1064</span>            <span class="keywordflow">return</span> converted</div>
<div class="line"><span class="lineno"> 1065</span> </div>
<div class="line"><span class="lineno"> 1066</span>    <span class="keywordflow">if</span> numeric <span class="keywordflow">and</span> is_object_dtype(values.dtype):</div>
<div class="line"><span class="lineno"> 1067</span>        converted, _ = lib.maybe_convert_numeric(values, set(), coerce_numeric=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1068</span> </div>
<div class="line"><span class="lineno"> 1069</span>        <span class="comment"># If all NaNs, then do not-alter</span></div>
<div class="line"><span class="lineno"> 1070</span>        values = converted <span class="keywordflow">if</span> <span class="keywordflow">not</span> isna(converted).all() <span class="keywordflow">else</span> values</div>
<div class="line"><span class="lineno"> 1071</span>        values = values.copy() <span class="keywordflow">if</span> copy <span class="keywordflow">else</span> values</div>
<div class="line"><span class="lineno"> 1072</span> </div>
<div class="line"><span class="lineno"> 1073</span>    <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1074</span> </div>
<div class="line"><span class="lineno"> 1075</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a98631a98b75ae98b505ecdb290c2c56d" name="a98631a98b75ae98b505ecdb290c2c56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98631a98b75ae98b505ecdb290c2c56d">&#9670;&#160;</a></span>_dtype_obj</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._dtype_obj = np.dtype(object)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a758379c1ffc315069babb46b2b7ad525" name="a758379c1ffc315069babb46b2b7ad525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758379c1ffc315069babb46b2b7ad525">&#9670;&#160;</a></span>_int16_max</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._int16_max = np.iinfo(np.int16).max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a741b08e58e9c60005f0b7ad9067fb88e" name="a741b08e58e9c60005f0b7ad9067fb88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741b08e58e9c60005f0b7ad9067fb88e">&#9670;&#160;</a></span>_int32_max</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._int32_max = np.iinfo(np.int32).max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6f43e69ba61548ca53fd55820dcd176" name="ad6f43e69ba61548ca53fd55820dcd176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f43e69ba61548ca53fd55820dcd176">&#9670;&#160;</a></span>_int64_max</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._int64_max = np.iinfo(np.int64).max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eab1ecf3ea5ae83d198a98efe5fa1c5" name="a0eab1ecf3ea5ae83d198a98efe5fa1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eab1ecf3ea5ae83d198a98efe5fa1c5">&#9670;&#160;</a></span>_int8_max</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast._int8_max = np.iinfo(np.int8).max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3e5050f68fa519a6bfa4a03c069fca2" name="ae3e5050f68fa519a6bfa4a03c069fca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e5050f68fa519a6bfa4a03c069fca2">&#9670;&#160;</a></span>NumpyArrayT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.dtypes.cast.NumpyArrayT = TypeVar(&quot;NumpyArrayT&quot;, bound=np.ndarray)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
