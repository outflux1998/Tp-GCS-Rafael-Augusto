<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.utils.class_weight Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1utils_1_1class__weight.html">class_weight</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.utils.class_weight Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4ef2f8e085b14890faeb78f339781dd8" id="r_a4ef2f8e085b14890faeb78f339781dd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1class__weight.html#a4ef2f8e085b14890faeb78f339781dd8">compute_class_weight</a> (class_weight, *classes, y)</td></tr>
<tr class="separator:a4ef2f8e085b14890faeb78f339781dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9753b7e52ebf6181b7668ffc1fd270cd" id="r_a9753b7e52ebf6181b7668ffc1fd270cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1class__weight.html#a9753b7e52ebf6181b7668ffc1fd270cd">compute_sample_weight</a> (class_weight, y, *indices=None)</td></tr>
<tr class="separator:a9753b7e52ebf6181b7668ffc1fd270cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4ef2f8e085b14890faeb78f339781dd8" name="a4ef2f8e085b14890faeb78f339781dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2f8e085b14890faeb78f339781dd8">&#9670;&#160;</a></span>compute_class_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.class_weight.compute_class_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>class_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate class weights for unbalanced datasets.

Parameters
----------
class_weight : dict, 'balanced' or None
    If 'balanced', class weights will be given by
    ``n_samples / (n_classes * np.bincount(y))``.
    If a dictionary is given, keys are classes and values
    are corresponding class weights.
    If None is given, the class weights will be uniform.

classes : ndarray
    Array of the classes occurring in the data, as given by
    ``np.unique(y_org)`` with ``y_org`` the original class labels.

y : array-like of shape (n_samples,)
    Array of original class labels per sample.

Returns
-------
class_weight_vect : ndarray of shape (n_classes,)
    Array with class_weight_vect[i] the weight for i-th class.

References
----------
The "balanced" heuristic is inspired by
Logistic Regression in Rare Events Data, King, Zen, 2001.
</pre> <div class="fragment"><div class="line"><span class="lineno">   10</span><span class="keyword">def </span>compute_class_weight(class_weight, *, classes, y):</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&quot;&quot;&quot;Estimate class weights for unbalanced datasets.</span></div>
<div class="line"><span class="lineno">   12</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   13</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   14</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   15</span><span class="stringliteral">    class_weight : dict, &#39;balanced&#39; or None</span></div>
<div class="line"><span class="lineno">   16</span><span class="stringliteral">        If &#39;balanced&#39;, class weights will be given by</span></div>
<div class="line"><span class="lineno">   17</span><span class="stringliteral">        ``n_samples / (n_classes * np.bincount(y))``.</span></div>
<div class="line"><span class="lineno">   18</span><span class="stringliteral">        If a dictionary is given, keys are classes and values</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral">        are corresponding class weights.</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral">        If None is given, the class weights will be uniform.</span></div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">    classes : ndarray</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">        Array of the classes occurring in the data, as given by</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">        ``np.unique(y_org)`` with ``y_org`` the original class labels.</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    y : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">        Array of original class labels per sample.</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">    class_weight_vect : ndarray of shape (n_classes,)</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">        Array with class_weight_vect[i] the weight for i-th class.</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    The &quot;balanced&quot; heuristic is inspired by</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    Logistic Regression in Rare Events Data, King, Zen, 2001.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   39</span>    <span class="comment"># Import error caused by circular imports.</span></div>
<div class="line"><span class="lineno">   40</span>    <span class="keyword">from</span> ..preprocessing <span class="keyword">import</span> LabelEncoder</div>
<div class="line"><span class="lineno">   41</span> </div>
<div class="line"><span class="lineno">   42</span>    <span class="keywordflow">if</span> set(y) - set(classes):</div>
<div class="line"><span class="lineno">   43</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;classes should include all valid labels that can be in y&quot;</span>)</div>
<div class="line"><span class="lineno">   44</span>    <span class="keywordflow">if</span> class_weight <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> len(class_weight) == 0:</div>
<div class="line"><span class="lineno">   45</span>        <span class="comment"># uniform class weights</span></div>
<div class="line"><span class="lineno">   46</span>        weight = np.ones(classes.shape[0], dtype=np.float64, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">   47</span>    <span class="keywordflow">elif</span> class_weight == <span class="stringliteral">&quot;balanced&quot;</span>:</div>
<div class="line"><span class="lineno">   48</span>        <span class="comment"># Find the weight of each class as present in y.</span></div>
<div class="line"><span class="lineno">   49</span>        le = LabelEncoder()</div>
<div class="line"><span class="lineno">   50</span>        y_ind = le.fit_transform(y)</div>
<div class="line"><span class="lineno">   51</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> all(np.in1d(classes, le.classes_)):</div>
<div class="line"><span class="lineno">   52</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;classes should have valid labels that are in y&quot;</span>)</div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span>        recip_freq = len(y) / (len(le.classes_) * np.bincount(y_ind).astype(np.float64))</div>
<div class="line"><span class="lineno">   55</span>        weight = recip_freq[le.transform(classes)]</div>
<div class="line"><span class="lineno">   56</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   57</span>        <span class="comment"># user-defined dictionary</span></div>
<div class="line"><span class="lineno">   58</span>        weight = np.ones(classes.shape[0], dtype=np.float64, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">   59</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(class_weight, dict):</div>
<div class="line"><span class="lineno">   60</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">   61</span>                <span class="stringliteral">&quot;class_weight must be dict, &#39;balanced&#39;, or None, got: %r&quot;</span> % class_weight</div>
<div class="line"><span class="lineno">   62</span>            )</div>
<div class="line"><span class="lineno">   63</span>        unweighted_classes = []</div>
<div class="line"><span class="lineno">   64</span>        <span class="keywordflow">for</span> i, c <span class="keywordflow">in</span> enumerate(classes):</div>
<div class="line"><span class="lineno">   65</span>            <span class="keywordflow">if</span> c <span class="keywordflow">in</span> class_weight:</div>
<div class="line"><span class="lineno">   66</span>                weight[i] = class_weight[c]</div>
<div class="line"><span class="lineno">   67</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   68</span>                unweighted_classes.append(c)</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span>        n_weighted_classes = len(classes) - len(unweighted_classes)</div>
<div class="line"><span class="lineno">   71</span>        <span class="keywordflow">if</span> unweighted_classes <span class="keywordflow">and</span> n_weighted_classes != len(class_weight):</div>
<div class="line"><span class="lineno">   72</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">   73</span>                f<span class="stringliteral">&quot;The classes, {unweighted_classes}, are not in class_weight&quot;</span></div>
<div class="line"><span class="lineno">   74</span>            )</div>
<div class="line"><span class="lineno">   75</span> </div>
<div class="line"><span class="lineno">   76</span>    <span class="keywordflow">return</span> weight</div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9753b7e52ebf6181b7668ffc1fd270cd" name="a9753b7e52ebf6181b7668ffc1fd270cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9753b7e52ebf6181b7668ffc1fd270cd">&#9670;&#160;</a></span>compute_sample_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.class_weight.compute_sample_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>class_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>indices</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate sample weights by class for unbalanced datasets.

Parameters
----------
class_weight : dict, list of dicts, "balanced", or None
    Weights associated with classes in the form ``{class_label: weight}``.
    If not given, all classes are supposed to have weight one. For
    multi-output problems, a list of dicts can be provided in the same
    order as the columns of y.

    Note that for multioutput (including multilabel) weights should be
    defined for each class of every column in its own dict. For example,
    for four-class multilabel classification weights should be
    [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of
    [{1:1}, {2:5}, {3:1}, {4:1}].

    The "balanced" mode uses the values of y to automatically adjust
    weights inversely proportional to class frequencies in the input data:
    ``n_samples / (n_classes * np.bincount(y))``.

    For multi-output, the weights of each column of y will be multiplied.

y : {array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs)
    Array of original class labels per sample.

indices : array-like of shape (n_subsample,), default=None
    Array of indices to be used in a subsample. Can be of length less than
    n_samples in the case of a subsample, or equal to n_samples in the
    case of a bootstrap subsample with repeated indices. If None, the
    sample weight will be calculated over the full sample. Only "balanced"
    is supported for class_weight if this is provided.

Returns
-------
sample_weight_vect : ndarray of shape (n_samples,)
    Array with sample weights as applied to the original y.
</pre> <div class="fragment"><div class="line"><span class="lineno">   79</span><span class="keyword">def </span>compute_sample_weight(class_weight, y, *, indices=None):</div>
<div class="line"><span class="lineno">   80</span>    <span class="stringliteral">&quot;&quot;&quot;Estimate sample weights by class for unbalanced datasets.</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    class_weight : dict, list of dicts, &quot;balanced&quot;, or None</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        Weights associated with classes in the form ``{class_label: weight}``.</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        If not given, all classes are supposed to have weight one. For</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        multi-output problems, a list of dicts can be provided in the same</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        order as the columns of y.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        Note that for multioutput (including multilabel) weights should be</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        defined for each class of every column in its own dict. For example,</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        for four-class multilabel classification weights should be</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        [{1:1}, {2:5}, {3:1}, {4:1}].</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        The &quot;balanced&quot; mode uses the values of y to automatically adjust</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        weights inversely proportional to class frequencies in the input data:</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        ``n_samples / (n_classes * np.bincount(y))``.</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        For multi-output, the weights of each column of y will be multiplied.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    y : {array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs)</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        Array of original class labels per sample.</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    indices : array-like of shape (n_subsample,), default=None</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        Array of indices to be used in a subsample. Can be of length less than</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        n_samples in the case of a subsample, or equal to n_samples in the</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        case of a bootstrap subsample with repeated indices. If None, the</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        sample weight will be calculated over the full sample. Only &quot;balanced&quot;</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        is supported for class_weight if this is provided.</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    sample_weight_vect : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        Array with sample weights as applied to the original y.</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  117</span> </div>
<div class="line"><span class="lineno">  118</span>    <span class="comment"># Ensure y is 2D. Sparse matrices are already 2D.</span></div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> sparse.issparse(y):</div>
<div class="line"><span class="lineno">  120</span>        y = np.atleast_1d(y)</div>
<div class="line"><span class="lineno">  121</span>        <span class="keywordflow">if</span> y.ndim == 1:</div>
<div class="line"><span class="lineno">  122</span>            y = np.reshape(y, (-1, 1))</div>
<div class="line"><span class="lineno">  123</span>    n_outputs = y.shape[1]</div>
<div class="line"><span class="lineno">  124</span> </div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">if</span> isinstance(class_weight, str):</div>
<div class="line"><span class="lineno">  126</span>        <span class="keywordflow">if</span> class_weight <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;balanced&quot;</span>]:</div>
<div class="line"><span class="lineno">  127</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  128</span>                <span class="stringliteral">&#39;The only valid preset for class_weight is &quot;balanced&quot;. Given &quot;%s&quot;.&#39;</span></div>
<div class="line"><span class="lineno">  129</span>                % class_weight</div>
<div class="line"><span class="lineno">  130</span>            )</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">elif</span> indices <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(class_weight, str):</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  133</span>            <span class="stringliteral">&#39;The only valid class_weight for subsampling is &quot;balanced&quot;. Given &quot;%s&quot;.&#39;</span></div>
<div class="line"><span class="lineno">  134</span>            % class_weight</div>
<div class="line"><span class="lineno">  135</span>        )</div>
<div class="line"><span class="lineno">  136</span>    <span class="keywordflow">elif</span> n_outputs &gt; 1:</div>
<div class="line"><span class="lineno">  137</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(class_weight, <span class="stringliteral">&quot;__iter__&quot;</span>) <span class="keywordflow">or</span> isinstance(class_weight, dict):</div>
<div class="line"><span class="lineno">  138</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  139</span>                <span class="stringliteral">&quot;For multi-output, class_weight should be a &quot;</span></div>
<div class="line"><span class="lineno">  140</span>                <span class="stringliteral">&quot;list of dicts, or a valid string.&quot;</span></div>
<div class="line"><span class="lineno">  141</span>            )</div>
<div class="line"><span class="lineno">  142</span>        <span class="keywordflow">if</span> len(class_weight) != n_outputs:</div>
<div class="line"><span class="lineno">  143</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  144</span>                <span class="stringliteral">&quot;For multi-output, number of elements in &quot;</span></div>
<div class="line"><span class="lineno">  145</span>                <span class="stringliteral">&quot;class_weight should match number of outputs.&quot;</span></div>
<div class="line"><span class="lineno">  146</span>            )</div>
<div class="line"><span class="lineno">  147</span> </div>
<div class="line"><span class="lineno">  148</span>    expanded_class_weight = []</div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(n_outputs):</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>        y_full = y[:, k]</div>
<div class="line"><span class="lineno">  152</span>        <span class="keywordflow">if</span> sparse.issparse(y_full):</div>
<div class="line"><span class="lineno">  153</span>            <span class="comment"># Ok to densify a single column at a time</span></div>
<div class="line"><span class="lineno">  154</span>            y_full = y_full.toarray().flatten()</div>
<div class="line"><span class="lineno">  155</span>        classes_full = np.unique(y_full)</div>
<div class="line"><span class="lineno">  156</span>        classes_missing = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  157</span> </div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">if</span> class_weight == <span class="stringliteral">&quot;balanced&quot;</span> <span class="keywordflow">or</span> n_outputs == 1:</div>
<div class="line"><span class="lineno">  159</span>            class_weight_k = class_weight</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  161</span>            class_weight_k = class_weight[k]</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>        <span class="keywordflow">if</span> indices <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  164</span>            <span class="comment"># Get class weights for the subsample, covering all classes in</span></div>
<div class="line"><span class="lineno">  165</span>            <span class="comment"># case some labels that were present in the original data are</span></div>
<div class="line"><span class="lineno">  166</span>            <span class="comment"># missing from the sample.</span></div>
<div class="line"><span class="lineno">  167</span>            y_subsample = y_full[indices]</div>
<div class="line"><span class="lineno">  168</span>            classes_subsample = np.unique(y_subsample)</div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="line"><span class="lineno">  170</span>            weight_k = np.take(</div>
<div class="line"><span class="lineno">  171</span>                compute_class_weight(</div>
<div class="line"><span class="lineno">  172</span>                    class_weight_k, classes=classes_subsample, y=y_subsample</div>
<div class="line"><span class="lineno">  173</span>                ),</div>
<div class="line"><span class="lineno">  174</span>                np.searchsorted(classes_subsample, classes_full),</div>
<div class="line"><span class="lineno">  175</span>                mode=<span class="stringliteral">&quot;clip&quot;</span>,</div>
<div class="line"><span class="lineno">  176</span>            )</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span>            classes_missing = set(classes_full) - set(classes_subsample)</div>
<div class="line"><span class="lineno">  179</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  180</span>            weight_k = compute_class_weight(</div>
<div class="line"><span class="lineno">  181</span>                class_weight_k, classes=classes_full, y=y_full</div>
<div class="line"><span class="lineno">  182</span>            )</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>        weight_k = weight_k[np.searchsorted(classes_full, y_full)]</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>        <span class="keywordflow">if</span> classes_missing:</div>
<div class="line"><span class="lineno">  187</span>            <span class="comment"># Make missing classes&#39; weight zero</span></div>
<div class="line"><span class="lineno">  188</span>            weight_k[np.in1d(y_full, list(classes_missing))] = 0.0</div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="line"><span class="lineno">  190</span>        expanded_class_weight.append(weight_k)</div>
<div class="line"><span class="lineno">  191</span> </div>
<div class="line"><span class="lineno">  192</span>    expanded_class_weight = np.prod(expanded_class_weight, axis=0, dtype=np.float64)</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">return</span> expanded_class_weight</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
