<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.transforms.Transform Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1transforms.html">transforms</a></li><li class="navelem"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html">Transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmatplotlib_1_1transforms_1_1_transform-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.transforms.Transform Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for matplotlib.transforms.Transform:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmatplotlib_1_1transforms_1_1_transform.png" usemap="#matplotlib.transforms.Transform_map" alt=""/>
  <map id="matplotlib.transforms.Transform_map" name="matplotlib.transforms.Transform_map">
<area href="classmatplotlib_1_1transforms_1_1_transform_node.html" alt="matplotlib.transforms.TransformNode" shape="rect" coords="0,0,294,24"/>
<area href="classaxisartist_1_1grid__finder_1_1___user2_d_transform.html" alt="axisartist.grid_finder._User2DTransform" shape="rect" coords="304,112,598,136"/>
<area href="classmatplotlib_1_1projections_1_1geo_1_1___geo_transform.html" alt="matplotlib.projections.geo._GeoTransform" shape="rect" coords="304,168,598,192"/>
<area href="classmatplotlib_1_1scale_1_1_asinh_transform.html" alt="matplotlib.scale.AsinhTransform" shape="rect" coords="304,224,598,248"/>
<area href="classmatplotlib_1_1scale_1_1_func_transform.html" alt="matplotlib.scale.FuncTransform" shape="rect" coords="304,280,598,304"/>
<area href="classmatplotlib_1_1scale_1_1_inverted_asinh_transform.html" alt="matplotlib.scale.InvertedAsinhTransform" shape="rect" coords="304,336,598,360"/>
<area href="classmatplotlib_1_1scale_1_1_inverted_log_transform.html" alt="matplotlib.scale.InvertedLogTransform" shape="rect" coords="304,392,598,416"/>
<area href="classmatplotlib_1_1scale_1_1_inverted_symmetrical_log_transform.html" alt="matplotlib.scale.InvertedSymmetricalLogTransform" shape="rect" coords="304,448,598,472"/>
<area href="classmatplotlib_1_1scale_1_1_log_transform.html" alt="matplotlib.scale.LogTransform" shape="rect" coords="304,504,598,528"/>
<area href="classmatplotlib_1_1scale_1_1_logistic_transform.html" alt="matplotlib.scale.LogisticTransform" shape="rect" coords="304,560,598,584"/>
<area href="classmatplotlib_1_1scale_1_1_logit_transform.html" alt="matplotlib.scale.LogitTransform" shape="rect" coords="304,616,598,640"/>
<area href="classmatplotlib_1_1scale_1_1_symmetrical_log_transform.html" alt="matplotlib.scale.SymmetricalLogTransform" shape="rect" coords="304,672,598,696"/>
<area href="classmatplotlib_1_1transforms_1_1_affine_base.html" alt="matplotlib.transforms.AffineBase" shape="rect" coords="304,728,598,752"/>
<area href="classmatplotlib_1_1transforms_1_1_blended_generic_transform.html" alt="matplotlib.transforms.BlendedGenericTransform" shape="rect" coords="304,784,598,808"/>
<area href="classmatplotlib_1_1transforms_1_1_composite_generic_transform.html" alt="matplotlib.transforms.CompositeGenericTransform" shape="rect" coords="304,840,598,864"/>
<area href="classmatplotlib_1_1transforms_1_1_transform_wrapper.html" alt="matplotlib.transforms.TransformWrapper" shape="rect" coords="304,896,598,920"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acaf7e7ff2a7cc8c6b094850095856c6e" id="r_acaf7e7ff2a7cc8c6b094850095856c6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#acaf7e7ff2a7cc8c6b094850095856c6e">__init_subclass__</a> (cls)</td></tr>
<tr class="separator:acaf7e7ff2a7cc8c6b094850095856c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543f60bda5dee1b7ade5e7de8481f856" id="r_a543f60bda5dee1b7ade5e7de8481f856"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a543f60bda5dee1b7ade5e7de8481f856">__add__</a> (self, other)</td></tr>
<tr class="separator:a543f60bda5dee1b7ade5e7de8481f856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7b1e3e5c3c8ba66dcbf926bffb9771" id="r_adc7b1e3e5c3c8ba66dcbf926bffb9771"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#adc7b1e3e5c3c8ba66dcbf926bffb9771">depth</a> (self)</td></tr>
<tr class="separator:adc7b1e3e5c3c8ba66dcbf926bffb9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b76698481128fa9b1867bf2ccfa9e67" id="r_a5b76698481128fa9b1867bf2ccfa9e67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a5b76698481128fa9b1867bf2ccfa9e67">contains_branch</a> (self, other)</td></tr>
<tr class="separator:a5b76698481128fa9b1867bf2ccfa9e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0f019dbd8808def2fec6fd472353d7" id="r_a4f0f019dbd8808def2fec6fd472353d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a4f0f019dbd8808def2fec6fd472353d7">contains_branch_seperately</a> (self, other_transform)</td></tr>
<tr class="separator:a4f0f019dbd8808def2fec6fd472353d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860ae34e76545dab0f51a678d31a9ac0" id="r_a860ae34e76545dab0f51a678d31a9ac0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a860ae34e76545dab0f51a678d31a9ac0">__sub__</a> (self, other)</td></tr>
<tr class="separator:a860ae34e76545dab0f51a678d31a9ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9d2879b4a42be7281a20f3d9257254" id="r_a6c9d2879b4a42be7281a20f3d9257254"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a6c9d2879b4a42be7281a20f3d9257254">__array__</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:a6c9d2879b4a42be7281a20f3d9257254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cca82bf47dd286ad6175e29df6997e3" id="r_a3cca82bf47dd286ad6175e29df6997e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a3cca82bf47dd286ad6175e29df6997e3">transform</a> (self, values)</td></tr>
<tr class="separator:a3cca82bf47dd286ad6175e29df6997e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a5da098109edd8cdbd236719d2410c" id="r_a46a5da098109edd8cdbd236719d2410c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a46a5da098109edd8cdbd236719d2410c">transform_affine</a> (self, values)</td></tr>
<tr class="separator:a46a5da098109edd8cdbd236719d2410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617ef28309e2192597d706ae1c42c842" id="r_a617ef28309e2192597d706ae1c42c842"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a617ef28309e2192597d706ae1c42c842">transform_non_affine</a> (self, values)</td></tr>
<tr class="separator:a617ef28309e2192597d706ae1c42c842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0129ccc8740a1c97c8d977196d3129" id="r_a7d0129ccc8740a1c97c8d977196d3129"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a7d0129ccc8740a1c97c8d977196d3129">transform_bbox</a> (self, bbox)</td></tr>
<tr class="separator:a7d0129ccc8740a1c97c8d977196d3129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c215464134db37acc098692fd2507c5" id="r_a2c215464134db37acc098692fd2507c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a2c215464134db37acc098692fd2507c5">get_affine</a> (self)</td></tr>
<tr class="separator:a2c215464134db37acc098692fd2507c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa856954cf79fedd56c4b3a67e29f82db" id="r_aa856954cf79fedd56c4b3a67e29f82db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#aa856954cf79fedd56c4b3a67e29f82db">get_matrix</a> (self)</td></tr>
<tr class="separator:aa856954cf79fedd56c4b3a67e29f82db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e22ca460e074ab0fda63b6528ab388" id="r_a20e22ca460e074ab0fda63b6528ab388"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a20e22ca460e074ab0fda63b6528ab388">transform_point</a> (self, point)</td></tr>
<tr class="separator:a20e22ca460e074ab0fda63b6528ab388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fb337dd589527fc102a643ca7f95c9" id="r_a10fb337dd589527fc102a643ca7f95c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a10fb337dd589527fc102a643ca7f95c9">transform_path</a> (self, path)</td></tr>
<tr class="separator:a10fb337dd589527fc102a643ca7f95c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d89e7ed4b93e6eed560bec8b9a2d32" id="r_a44d89e7ed4b93e6eed560bec8b9a2d32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a44d89e7ed4b93e6eed560bec8b9a2d32">transform_path_affine</a> (self, path)</td></tr>
<tr class="separator:a44d89e7ed4b93e6eed560bec8b9a2d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ad8fcd7adabb6e4244a5a1dccd902d" id="r_a40ad8fcd7adabb6e4244a5a1dccd902d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a40ad8fcd7adabb6e4244a5a1dccd902d">transform_path_non_affine</a> (self, path)</td></tr>
<tr class="separator:a40ad8fcd7adabb6e4244a5a1dccd902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105399ba3093603576e3a727e777c4ea" id="r_a105399ba3093603576e3a727e777c4ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a105399ba3093603576e3a727e777c4ea">transform_angles</a> (self, angles, pts, radians=False, pushoff=1e-5)</td></tr>
<tr class="separator:a105399ba3093603576e3a727e777c4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbcbd88fdd30936fd444e4463c14f5a" id="r_a3bbcbd88fdd30936fd444e4463c14f5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a3bbcbd88fdd30936fd444e4463c14f5a">inverted</a> (self)</td></tr>
<tr class="separator:a3bbcbd88fdd30936fd444e4463c14f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmatplotlib_1_1transforms_1_1_transform_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html">matplotlib.transforms.TransformNode</a></td></tr>
<tr class="memitem:a3f49dbe46dec7b1a4260a10cd8668117 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a3f49dbe46dec7b1a4260a10cd8668117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a3f49dbe46dec7b1a4260a10cd8668117">__init__</a> (self, shorthand_name=None)</td></tr>
<tr class="separator:a3f49dbe46dec7b1a4260a10cd8668117 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694e2a3dc6e7397b95127b6eb7b26ecf inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a694e2a3dc6e7397b95127b6eb7b26ecf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a694e2a3dc6e7397b95127b6eb7b26ecf">__str__</a> (self)</td></tr>
<tr class="separator:a694e2a3dc6e7397b95127b6eb7b26ecf inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e8296c05c4a476fb6b9fd61883e0c8 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_ab8e8296c05c4a476fb6b9fd61883e0c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#ab8e8296c05c4a476fb6b9fd61883e0c8">__getstate__</a> (self)</td></tr>
<tr class="separator:ab8e8296c05c4a476fb6b9fd61883e0c8 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915af64f6dfb9615e4f3a59d27332006 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a915af64f6dfb9615e4f3a59d27332006"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a915af64f6dfb9615e4f3a59d27332006">__setstate__</a> (self, data_dict)</td></tr>
<tr class="separator:a915af64f6dfb9615e4f3a59d27332006 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda6afa0e8ae73fa0c0276330ac54533 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_adda6afa0e8ae73fa0c0276330ac54533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#adda6afa0e8ae73fa0c0276330ac54533">__copy__</a> (self)</td></tr>
<tr class="separator:adda6afa0e8ae73fa0c0276330ac54533 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1164b8947d1245b0bacf6cd59332fc6 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_aa1164b8947d1245b0bacf6cd59332fc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#aa1164b8947d1245b0bacf6cd59332fc6">invalidate</a> (self)</td></tr>
<tr class="separator:aa1164b8947d1245b0bacf6cd59332fc6 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccfb8bc628b7da44cc21c71c7b98cf2 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a6ccfb8bc628b7da44cc21c71c7b98cf2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a6ccfb8bc628b7da44cc21c71c7b98cf2">set_children</a> (self, *children)</td></tr>
<tr class="separator:a6ccfb8bc628b7da44cc21c71c7b98cf2 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbe3d959d76fc346a9ac8acac025413 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_aadbe3d959d76fc346a9ac8acac025413"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#aadbe3d959d76fc346a9ac8acac025413">frozen</a> (self)</td></tr>
<tr class="separator:aadbe3d959d76fc346a9ac8acac025413 inherit pub_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af81ccab23877735961f7d384a9947e8c" id="r_af81ccab23877735961f7d384a9947e8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#af81ccab23877735961f7d384a9947e8c">is_separable</a></td></tr>
<tr class="separator:af81ccab23877735961f7d384a9947e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd7be3f8ed35b38c6a86c8d843121b0" id="r_a9cd7be3f8ed35b38c6a86c8d843121b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a9cd7be3f8ed35b38c6a86c8d843121b0">has_inverse</a></td></tr>
<tr class="separator:a9cd7be3f8ed35b38c6a86c8d843121b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a96d2969a2a9cbc5105534e2c848d0112" id="r_a96d2969a2a9cbc5105534e2c848d0112"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a96d2969a2a9cbc5105534e2c848d0112">input_dims</a> = None</td></tr>
<tr class="separator:a96d2969a2a9cbc5105534e2c848d0112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54640edfc4c4cec07e567f82a756f767" id="r_a54640edfc4c4cec07e567f82a756f767"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a54640edfc4c4cec07e567f82a756f767">output_dims</a> = None</td></tr>
<tr class="separator:a54640edfc4c4cec07e567f82a756f767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc38831d2adea7c8421b476289affd6" id="r_afbc38831d2adea7c8421b476289affd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#afbc38831d2adea7c8421b476289affd6">is_separable</a> = False</td></tr>
<tr class="separator:afbc38831d2adea7c8421b476289affd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1003fe73ba72390415bb580f4bb51499" id="r_a1003fe73ba72390415bb580f4bb51499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#a1003fe73ba72390415bb580f4bb51499">has_inverse</a> = False</td></tr>
<tr class="separator:a1003fe73ba72390415bb580f4bb51499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html">matplotlib.transforms.TransformNode</a></td></tr>
<tr class="memitem:a46cebd22a020db64583d5279d7c490de inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a46cebd22a020db64583d5279d7c490de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a46cebd22a020db64583d5279d7c490de">INVALID_NON_AFFINE</a> = 1</td></tr>
<tr class="separator:a46cebd22a020db64583d5279d7c490de inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6f7cd0a3cc1729b4a5b6568abf654b inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_abe6f7cd0a3cc1729b4a5b6568abf654b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#abe6f7cd0a3cc1729b4a5b6568abf654b">INVALID_AFFINE</a> = 2</td></tr>
<tr class="separator:abe6f7cd0a3cc1729b4a5b6568abf654b inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4388e21af811745b95571f1d94150ec7 inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a4388e21af811745b95571f1d94150ec7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a4388e21af811745b95571f1d94150ec7">INVALID</a> = <a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a46cebd22a020db64583d5279d7c490de">INVALID_NON_AFFINE</a> | <a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#abe6f7cd0a3cc1729b4a5b6568abf654b">INVALID_AFFINE</a></td></tr>
<tr class="separator:a4388e21af811745b95571f1d94150ec7 inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f80f07e95a4bfec9fd943351dfd0aec inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a7f80f07e95a4bfec9fd943351dfd0aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a7f80f07e95a4bfec9fd943351dfd0aec">is_affine</a> = False</td></tr>
<tr class="separator:a7f80f07e95a4bfec9fd943351dfd0aec inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1854e5c598fad87f83290331bab4a3c inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_ae1854e5c598fad87f83290331bab4a3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#ae1854e5c598fad87f83290331bab4a3c">is_bbox</a> = False</td></tr>
<tr class="separator:ae1854e5c598fad87f83290331bab4a3c inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9e48f977a15a6cd0b4bfa8d0c58c40 inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a8b9e48f977a15a6cd0b4bfa8d0c58c40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a8b9e48f977a15a6cd0b4bfa8d0c58c40">pass_through</a> = False</td></tr>
<tr class="separator:a8b9e48f977a15a6cd0b4bfa8d0c58c40 inherit pub_static_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab3f6383e0edd11f38995bf34c2281001" id="r_ab3f6383e0edd11f38995bf34c2281001"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform.html#ab3f6383e0edd11f38995bf34c2281001">_iter_break_from_left_to_right</a> (self)</td></tr>
<tr class="separator:ab3f6383e0edd11f38995bf34c2281001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmatplotlib_1_1transforms_1_1_transform_node')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html">matplotlib.transforms.TransformNode</a></td></tr>
<tr class="memitem:a7e13f9884fcb5cf6cc196e27364be894 inherit pro_methods_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a7e13f9884fcb5cf6cc196e27364be894"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a7e13f9884fcb5cf6cc196e27364be894">_invalidate_internal</a> (self, value, invalidating_node)</td></tr>
<tr class="separator:a7e13f9884fcb5cf6cc196e27364be894 inherit pro_methods_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html">matplotlib.transforms.TransformNode</a></td></tr>
<tr class="memitem:a19d23142127206b873dfb23429f3d2f2 inherit pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a19d23142127206b873dfb23429f3d2f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a19d23142127206b873dfb23429f3d2f2">_parents</a></td></tr>
<tr class="separator:a19d23142127206b873dfb23429f3d2f2 inherit pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1c6c257f9e20f57219a83998c2f6a2 inherit pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a7b1c6c257f9e20f57219a83998c2f6a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a7b1c6c257f9e20f57219a83998c2f6a2">_invalid</a></td></tr>
<tr class="separator:a7b1c6c257f9e20f57219a83998c2f6a2 inherit pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502f9d0dbd3fa9b458d59a3ad62014aa inherit pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node" id="r_a502f9d0dbd3fa9b458d59a3ad62014aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1transforms_1_1_transform_node.html#a502f9d0dbd3fa9b458d59a3ad62014aa">_shorthand_name</a></td></tr>
<tr class="separator:a502f9d0dbd3fa9b458d59a3ad62014aa inherit pro_attribs_classmatplotlib_1_1transforms_1_1_transform_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The base class of all `TransformNode` instances that
actually perform a transformation.

All non-affine transformations should be subclasses of this class.
New affine transformations should be subclasses of `Affine2D`.

Subclasses of this class should override the following members (at
minimum):

- :attr:`input_dims`
- :attr:`output_dims`
- :meth:`transform`
- :meth:`inverted` (if an inverse exists)

The following attributes may be overridden if the default is unsuitable:

- :attr:`is_separable` (defaults to True for 1D -&gt; 1D transforms, False
  otherwise)
- :attr:`has_inverse` (defaults to True if :meth:`inverted` is overridden,
  False otherwise)

If the transform needs to do something non-standard with
`matplotlib.path.Path` objects, such as adding curves
where there were once line segments, it should override:

- :meth:`transform_path`
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a543f60bda5dee1b7ade5e7de8481f856" name="a543f60bda5dee1b7ade5e7de8481f856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543f60bda5dee1b7ade5e7de8481f856">&#9670;&#160;</a></span>__add__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.__add__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compose two transforms together so that *self* is followed by *other*.

``A + B`` returns a transform ``C`` so that
``C.transform(x) == B.transform(A.transform(x))``.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1335</span>    <span class="keyword">def </span>__add__(self, other):</div>
<div class="line"><span class="lineno"> 1336</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">        Compose two transforms together so that *self* is followed by *other*.</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">        ``A + B`` returns a transform ``C`` so that</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">        ``C.transform(x) == B.transform(A.transform(x))``.</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1342</span>        <span class="keywordflow">return</span> (composite_transform_factory(self, other)</div>
<div class="line"><span class="lineno"> 1343</span>                <span class="keywordflow">if</span> isinstance(other, Transform) <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1344</span>                NotImplemented)</div>
<div class="line"><span class="lineno"> 1345</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c9d2879b4a42be7281a20f3d9257254" name="a6c9d2879b4a42be7281a20f3d9257254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9d2879b4a42be7281a20f3d9257254">&#9670;&#160;</a></span>__array__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.__array__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Array interface to get at this Transform's affine matrix.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#a887025aab734cce776530e2bcb48de43">matplotlib.transforms.AffineBase</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1463</span>    <span class="keyword">def </span>__array__(self, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 1464</span>        <span class="stringliteral">&quot;&quot;&quot;Array interface to get at this Transform&#39;s affine matrix.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1465</span>        <span class="keywordflow">return</span> self.get_affine().get_matrix()</div>
<div class="line"><span class="lineno"> 1466</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acaf7e7ff2a7cc8c6b094850095856c6e" name="acaf7e7ff2a7cc8c6b094850095856c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf7e7ff2a7cc8c6b094850095856c6e">&#9670;&#160;</a></span>__init_subclass__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.__init_subclass__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1319</span>    <span class="keyword">def </span>__init_subclass__(cls):</div>
<div class="line"><span class="lineno"> 1320</span>        <span class="comment"># 1d transforms are always separable; we assume higher-dimensional ones</span></div>
<div class="line"><span class="lineno"> 1321</span>        <span class="comment"># are not but subclasses can also directly set is_separable -- this is</span></div>
<div class="line"><span class="lineno"> 1322</span>        <span class="comment"># verified by checking whether &quot;is_separable&quot; appears more than once in</span></div>
<div class="line"><span class="lineno"> 1323</span>        <span class="comment"># the class&#39;s MRO (it appears once in Transform).</span></div>
<div class="line"><span class="lineno"> 1324</span>        <span class="keywordflow">if</span> (sum(<span class="stringliteral">&quot;is_separable&quot;</span> <span class="keywordflow">in</span> vars(parent) <span class="keywordflow">for</span> parent <span class="keywordflow">in</span> cls.__mro__) == 1</div>
<div class="line"><span class="lineno"> 1325</span>                <span class="keywordflow">and</span> cls.input_dims == cls.output_dims == 1):</div>
<div class="line"><span class="lineno"> 1326</span>            cls.is_separable = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1327</span>        <span class="comment"># Transform.inverted raises NotImplementedError; we assume that if this</span></div>
<div class="line"><span class="lineno"> 1328</span>        <span class="comment"># is overridden then the transform is invertible but subclass can also</span></div>
<div class="line"><span class="lineno"> 1329</span>        <span class="comment"># directly set has_inverse.</span></div>
<div class="line"><span class="lineno"> 1330</span>        <span class="keywordflow">if</span> (sum(<span class="stringliteral">&quot;has_inverse&quot;</span> <span class="keywordflow">in</span> vars(parent) <span class="keywordflow">for</span> parent <span class="keywordflow">in</span> cls.__mro__) == 1</div>
<div class="line"><span class="lineno"> 1331</span>                <span class="keywordflow">and</span> hasattr(cls, <span class="stringliteral">&quot;inverted&quot;</span>)</div>
<div class="line"><span class="lineno"> 1332</span>                <span class="keywordflow">and</span> cls.inverted <span class="keywordflow">is</span> <span class="keywordflow">not</span> Transform.inverted):</div>
<div class="line"><span class="lineno"> 1333</span>            cls.has_inverse = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1334</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a860ae34e76545dab0f51a678d31a9ac0" name="a860ae34e76545dab0f51a678d31a9ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860ae34e76545dab0f51a678d31a9ac0">&#9670;&#160;</a></span>__sub__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.__sub__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compose *self* with the inverse of *other*, cancelling identical terms
if any::

    # In general:
    A - B == A + B.inverted()
    # (but see note regarding frozen transforms below).

    # If A "ends with" B (i.e. A == A' + B for some A') we can cancel
    # out B:
    (A' + B) - B == A'

    # Likewise, if B "starts with" A (B = A + B'), we can cancel out A:
    A - (A + B') == B'.inverted() == B'^-1

Cancellation (rather than naively returning ``A + B.inverted()``) is
important for multiple reasons:

- It avoids floating-point inaccuracies when computing the inverse of
  B: ``B - B`` is guaranteed to cancel out exactly (resulting in the
  identity transform), whereas ``B + B.inverted()`` may differ by a
  small epsilon.
- ``B.inverted()`` always returns a frozen transform: if one computes
  ``A + B + B.inverted()`` and later mutates ``B``, then
  ``B.inverted()`` won't be updated and the last two terms won't cancel
  out anymore; on the other hand, ``A + B - B`` will always be equal to
  ``A`` even if ``B`` is mutated.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1413</span>    <span class="keyword">def </span>__sub__(self, other):</div>
<div class="line"><span class="lineno"> 1414</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">        Compose *self* with the inverse of *other*, cancelling identical terms</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">        if any::</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">            # In general:</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">            A - B == A + B.inverted()</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">            # (but see note regarding frozen transforms below).</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">            # If A &quot;ends with&quot; B (i.e. A == A&#39; + B for some A&#39;) we can cancel</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">            # out B:</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">            (A&#39; + B) - B == A&#39;</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">            # Likewise, if B &quot;starts with&quot; A (B = A + B&#39;), we can cancel out A:</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">            A - (A + B&#39;) == B&#39;.inverted() == B&#39;^-1</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">        Cancellation (rather than naively returning ``A + B.inverted()``) is</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">        important for multiple reasons:</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">        - It avoids floating-point inaccuracies when computing the inverse of</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">          B: ``B - B`` is guaranteed to cancel out exactly (resulting in the</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">          identity transform), whereas ``B + B.inverted()`` may differ by a</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">          small epsilon.</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">        - ``B.inverted()`` always returns a frozen transform: if one computes</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">          ``A + B + B.inverted()`` and later mutates ``B``, then</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">          ``B.inverted()`` won&#39;t be updated and the last two terms won&#39;t cancel</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">          out anymore; on the other hand, ``A + B - B`` will always be equal to</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">          ``A`` even if ``B`` is mutated.</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1442</span>        <span class="comment"># we only know how to do this operation if other is a Transform.</span></div>
<div class="line"><span class="lineno"> 1443</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(other, Transform):</div>
<div class="line"><span class="lineno"> 1444</span>            <span class="keywordflow">return</span> NotImplemented</div>
<div class="line"><span class="lineno"> 1445</span>        <span class="keywordflow">for</span> remainder, sub_tree <span class="keywordflow">in</span> self._iter_break_from_left_to_right():</div>
<div class="line"><span class="lineno"> 1446</span>            <span class="keywordflow">if</span> sub_tree == other:</div>
<div class="line"><span class="lineno"> 1447</span>                <span class="keywordflow">return</span> remainder</div>
<div class="line"><span class="lineno"> 1448</span>        <span class="keywordflow">for</span> remainder, sub_tree <span class="keywordflow">in</span> other._iter_break_from_left_to_right():</div>
<div class="line"><span class="lineno"> 1449</span>            <span class="keywordflow">if</span> sub_tree == self:</div>
<div class="line"><span class="lineno"> 1450</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> remainder.has_inverse:</div>
<div class="line"><span class="lineno"> 1451</span>                    <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1452</span>                        <span class="stringliteral">&quot;The shortcut cannot be computed since &#39;other&#39; &quot;</span></div>
<div class="line"><span class="lineno"> 1453</span>                        <span class="stringliteral">&quot;includes a non-invertible component&quot;</span>)</div>
<div class="line"><span class="lineno"> 1454</span>                <span class="keywordflow">return</span> remainder.inverted()</div>
<div class="line"><span class="lineno"> 1455</span>        <span class="comment"># if we have got this far, then there was no shortcut possible</span></div>
<div class="line"><span class="lineno"> 1456</span>        <span class="keywordflow">if</span> other.has_inverse:</div>
<div class="line"><span class="lineno"> 1457</span>            <span class="keywordflow">return</span> self + other.inverted()</div>
<div class="line"><span class="lineno"> 1458</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1459</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;It is not possible to compute transA - transB &#39;</span></div>
<div class="line"><span class="lineno"> 1460</span>                             <span class="stringliteral">&#39;since transB cannot be inverted and there is no &#39;</span></div>
<div class="line"><span class="lineno"> 1461</span>                             <span class="stringliteral">&#39;shortcut possible.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1462</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3f6383e0edd11f38995bf34c2281001" name="ab3f6383e0edd11f38995bf34c2281001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6383e0edd11f38995bf34c2281001">&#9670;&#160;</a></span>_iter_break_from_left_to_right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform._iter_break_from_left_to_right </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return an iterator breaking down this transform stack from left to
right recursively. If self == ((A, N), A) then the result will be an
iterator which yields I : ((A, N), A), followed by A : (N, A),
followed by (A, N) : (A), but not ((A, N), A) : I.

This is equivalent to flattening the stack then yielding
``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_generic_transform.html#abdf1bf48d55e20c704cec88c21d1ab86">matplotlib.transforms.CompositeGenericTransform</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_affine2_d.html#aac77bd83b8c9f8898eaa9eaa3fb82853">matplotlib.transforms.CompositeAffine2D</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1350</span>    <span class="keyword">def </span>_iter_break_from_left_to_right(self):</div>
<div class="line"><span class="lineno"> 1351</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">        Return an iterator breaking down this transform stack from left to</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">        right recursively. If self == ((A, N), A) then the result will be an</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">        iterator which yields I : ((A, N), A), followed by A : (N, A),</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">        followed by (A, N) : (A), but not ((A, N), A) : I.</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">        This is equivalent to flattening the stack then yielding</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1360</span>        <span class="keywordflow">yield</span> IdentityTransform(), self</div>
<div class="line"><span class="lineno"> 1361</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b76698481128fa9b1867bf2ccfa9e67" name="a5b76698481128fa9b1867bf2ccfa9e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b76698481128fa9b1867bf2ccfa9e67">&#9670;&#160;</a></span>contains_branch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.contains_branch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the given transform is a sub-tree of this transform.

This routine uses transform equality to identify sub-trees, therefore
in many situations it is object id which will be used.

For the case where the given transform represents the whole
of this transform, returns True.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_blended_generic_transform.html#a6e95aad88e50c3b9b65a9f74889426ec">matplotlib.transforms.BlendedGenericTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1376</span>    <span class="keyword">def </span>contains_branch(self, other):</div>
<div class="line"><span class="lineno"> 1377</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">        Return whether the given transform is a sub-tree of this transform.</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">        This routine uses transform equality to identify sub-trees, therefore</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">        in many situations it is object id which will be used.</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">        For the case where the given transform represents the whole</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">        of this transform, returns True.</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1386</span>        <span class="keywordflow">if</span> self.depth &lt; other.depth:</div>
<div class="line"><span class="lineno"> 1387</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1388</span> </div>
<div class="line"><span class="lineno"> 1389</span>        <span class="comment"># check that a subtree is equal to other (starting from self)</span></div>
<div class="line"><span class="lineno"> 1390</span>        <span class="keywordflow">for</span> _, sub_tree <span class="keywordflow">in</span> self._iter_break_from_left_to_right():</div>
<div class="line"><span class="lineno"> 1391</span>            <span class="keywordflow">if</span> sub_tree == other:</div>
<div class="line"><span class="lineno"> 1392</span>                <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1393</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1394</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f0f019dbd8808def2fec6fd472353d7" name="a4f0f019dbd8808def2fec6fd472353d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0f019dbd8808def2fec6fd472353d7">&#9670;&#160;</a></span>contains_branch_seperately()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.contains_branch_seperately </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the given branch is a sub-tree of this transform on
each separate dimension.

A common use for this method is to identify if a transform is a blended
transform containing an Axes' data transform. e.g.::

    x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1395</span>    <span class="keyword">def </span>contains_branch_seperately(self, other_transform):</div>
<div class="line"><span class="lineno"> 1396</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">        Return whether the given branch is a sub-tree of this transform on</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">        each separate dimension.</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">        A common use for this method is to identify if a transform is a blended</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">        transform containing an Axes&#39; data transform. e.g.::</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1406</span>        <span class="keywordflow">if</span> self.output_dims != 2:</div>
<div class="line"><span class="lineno"> 1407</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;contains_branch_seperately only supports &#39;</span></div>
<div class="line"><span class="lineno"> 1408</span>                             <span class="stringliteral">&#39;transforms with 2 output dimensions&#39;</span>)</div>
<div class="line"><span class="lineno"> 1409</span>        <span class="comment"># for a non-blended transform each separate dimension is the same, so</span></div>
<div class="line"><span class="lineno"> 1410</span>        <span class="comment"># just return the appropriate shape.</span></div>
<div class="line"><span class="lineno"> 1411</span>        <span class="keywordflow">return</span> [self.contains_branch(other_transform)] * 2</div>
<div class="line"><span class="lineno"> 1412</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adc7b1e3e5c3c8ba66dcbf926bffb9771" name="adc7b1e3e5c3c8ba66dcbf926bffb9771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7b1e3e5c3c8ba66dcbf926bffb9771">&#9670;&#160;</a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.depth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of transforms which have been chained
together to form this Transform instance.

.. note::

    For the special case of a Composite transform, the maximum depth
    of the two is returned.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_blended_generic_transform.html#a143fd8a38c85786b320a47b31f103e61">matplotlib.transforms.BlendedGenericTransform</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_affine2_d.html#ae564239e6fabf19b2441f997085e38d0">matplotlib.transforms.CompositeAffine2D</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1363</span>    <span class="keyword">def </span>depth(self):</div>
<div class="line"><span class="lineno"> 1364</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">        Return the number of transforms which have been chained</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">        together to form this Transform instance.</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">        .. note::</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">            For the special case of a Composite transform, the maximum depth</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">            of the two is returned.</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1374</span>        <span class="keywordflow">return</span> 1</div>
<div class="line"><span class="lineno"> 1375</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c215464134db37acc098692fd2507c5" name="a2c215464134db37acc098692fd2507c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c215464134db37acc098692fd2507c5">&#9670;&#160;</a></span>get_affine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.get_affine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the affine part of this transform.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#a6ea68edb22dee8ee9574173fccd63c3f">matplotlib.transforms.AffineBase</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#a941e5347ac5de20b7eb2f515c5774dfe">matplotlib.transforms.IdentityTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_blended_generic_transform.html#a027eb6a6f4b7442a1447b353596f6774">matplotlib.transforms.BlendedGenericTransform</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_generic_transform.html#aab94e7d5bb9494b05b74219fecb657f6">matplotlib.transforms.CompositeGenericTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1564</span>    <span class="keyword">def </span>get_affine(self):</div>
<div class="line"><span class="lineno"> 1565</span>        <span class="stringliteral">&quot;&quot;&quot;Get the affine part of this transform.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1566</span>        <span class="keywordflow">return</span> IdentityTransform()</div>
<div class="line"><span class="lineno"> 1567</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa856954cf79fedd56c4b3a67e29f82db" name="aa856954cf79fedd56c4b3a67e29f82db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa856954cf79fedd56c4b3a67e29f82db">&#9670;&#160;</a></span>get_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.get_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the matrix for the affine part of this transform.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine2_d.html#a5620721424a2521c3d61ebab34894257">matplotlib.transforms.Affine2D</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#af3df0f27b706785c7578e2745065f21a">matplotlib.transforms.IdentityTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_blended_affine2_d.html#a64f7b5383257b674f7c36d61c5f9a6a4">matplotlib.transforms.BlendedAffine2D</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_affine2_d.html#a354cc9cf524d2b0da4544e607b7284f1">matplotlib.transforms.CompositeAffine2D</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_bbox_transform.html#a36b57da425c918e04277339521cf0605">matplotlib.transforms.BboxTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_bbox_transform_to.html#a63f7f95a8b2acfe9426d5e95bb8de2e3">matplotlib.transforms.BboxTransformTo</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_bbox_transform_to_max_only.html#aa30fb34b6ce04f5b738d98aaee42f620">matplotlib.transforms.BboxTransformToMaxOnly</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_bbox_transform_from.html#afc7d1ae068effd294770758deff90703">matplotlib.transforms.BboxTransformFrom</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_scaled_translation.html#aa50c57ba6c607b7f11c96148b68d0236">matplotlib.transforms.ScaledTranslation</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_delta_transform.html#af5d8bc68ae7b97236889338a806010e9">matplotlib.transforms.AffineDeltaTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1568</span>    <span class="keyword">def </span>get_matrix(self):</div>
<div class="line"><span class="lineno"> 1569</span>        <span class="stringliteral">&quot;&quot;&quot;Get the matrix for the affine part of this transform.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1570</span>        <span class="keywordflow">return</span> self.get_affine().get_matrix()</div>
<div class="line"><span class="lineno"> 1571</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bbcbd88fdd30936fd444e4463c14f5a" name="a3bbcbd88fdd30936fd444e4463c14f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbcbd88fdd30936fd444e4463c14f5a">&#9670;&#160;</a></span>inverted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.inverted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the corresponding inverse transformation.

It holds ``x == self.inverted().transform(self.transform(x))``.

The return value of this method should be treated as
temporary.  An update to *self* does not cause a corresponding
update to its inverted copy.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_aitoff_axes_1_1_aitoff_transform.html#ae2ccb2a80c6b3b2cece1cc73e3aa4e0b">matplotlib.projections.geo.AitoffAxes.AitoffTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_aitoff_axes_1_1_inverted_aitoff_transform.html#ae32e2c73269125df61473edfbdae41c8">matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_hammer_axes_1_1_hammer_transform.html#a3edaf192640239148c1e53d19651875c">matplotlib.projections.geo.HammerAxes.HammerTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_hammer_axes_1_1_inverted_hammer_transform.html#adceca2aac280002df05633c653b0b875">matplotlib.projections.geo.HammerAxes.InvertedHammerTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_mollweide_axes_1_1_mollweide_transform.html#a91907ff0b81d573f896b0a07b81a1b93">matplotlib.projections.geo.MollweideAxes.MollweideTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_mollweide_axes_1_1_inverted_mollweide_transform.html#ab2d9b32c21961f4d8975f8892d3a8d41">matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_lambert_axes_1_1_lambert_transform.html#a37ab304aecb688805db3556c15fe2fd9">matplotlib.projections.geo.LambertAxes.LambertTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_lambert_axes_1_1_inverted_lambert_transform.html#a2fdf691d334b2ddbaef13981dff02223">matplotlib.projections.geo.LambertAxes.InvertedLambertTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_func_transform.html#a79e48621658012551a7f3ab29b172634">matplotlib.scale.FuncTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_log_transform.html#a60b56d50b261127bc8cf4ce534d966b9">matplotlib.scale.LogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_inverted_log_transform.html#ad1306d42362f3ecef77865ce0283c807">matplotlib.scale.InvertedLogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_symmetrical_log_transform.html#a3eecf83e5e566d33ef405749d140dd87">matplotlib.scale.SymmetricalLogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_inverted_symmetrical_log_transform.html#aa51cce8ca11e42daa038b8c7208e7839">matplotlib.scale.InvertedSymmetricalLogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_asinh_transform.html#aed30acff133cd57a363479533593281c">matplotlib.scale.AsinhTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_inverted_asinh_transform.html#a5b66466419ce413d96681894d3c7b981">matplotlib.scale.InvertedAsinhTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_logit_transform.html#aa0112b23da0fdae6a05a2d1ad933f841">matplotlib.scale.LogitTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_logistic_transform.html#a54f30cabb0cfe04969a0f87ad38e77fb">matplotlib.scale.LogisticTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_affine2_d_base.html#a2fce001c52f62cf02213b10a5cdeada4">matplotlib.transforms.Affine2DBase</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#a2c9eba339ccdae7f030fb201d801da25">matplotlib.transforms.IdentityTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_blended_generic_transform.html#aa4b0367e741f8264adb94b1d5ffb1d4e">matplotlib.transforms.BlendedGenericTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_generic_transform.html#aecf4ba9c46cb7e53fee335d5d6a4d0b8">matplotlib.transforms.CompositeGenericTransform</a>, and <a class="el" href="classaxisartist_1_1grid__finder_1_1___user2_d_transform.html#a83c6fb608364910ea7d3f7fa6950737b">axisartist.grid_finder._User2DTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1667</span>    <span class="keyword">def </span>inverted(self):</div>
<div class="line"><span class="lineno"> 1668</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">        Return the corresponding inverse transformation.</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">        It holds ``x == self.inverted().transform(self.transform(x))``.</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">        The return value of this method should be treated as</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">        temporary.  An update to *self* does not cause a corresponding</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">        update to its inverted copy.</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1677</span>        <span class="keywordflow">raise</span> NotImplementedError()</div>
<div class="line"><span class="lineno"> 1678</span> </div>
<div class="line"><span class="lineno"> 1679</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3cca82bf47dd286ad6175e29df6997e3" name="a3cca82bf47dd286ad6175e29df6997e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cca82bf47dd286ad6175e29df6997e3">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply this transformation on the given array of *values*.

Parameters
----------
values : array
    The input values as NumPy array of length :attr:`input_dims` or
    shape (N x :attr:`input_dims`).

Returns
-------
array
    The output values as NumPy array of length :attr:`output_dims` or
    shape (N x :attr:`output_dims`), depending on the input.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#a54f116d1e70d044f7f2547d9465a9e5a">matplotlib.transforms.IdentityTransform</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#a14017dc147bfbda72eddfa8a1f12eaf4">matplotlib.transforms.AffineBase</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1467</span>    <span class="keyword">def </span>transform(self, values):</div>
<div class="line"><span class="lineno"> 1468</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">        Apply this transformation on the given array of *values*.</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">        values : array</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">            The input values as NumPy array of length :attr:`input_dims` or</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">            shape (N x :attr:`input_dims`).</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">        array</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">            The output values as NumPy array of length :attr:`output_dims` or</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">            shape (N x :attr:`output_dims`), depending on the input.</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1483</span>        <span class="comment"># Ensure that values is a 2d array (but remember whether</span></div>
<div class="line"><span class="lineno"> 1484</span>        <span class="comment"># we started with a 1d or 2d array).</span></div>
<div class="line"><span class="lineno"> 1485</span>        values = np.asanyarray(values)</div>
<div class="line"><span class="lineno"> 1486</span>        ndim = values.ndim</div>
<div class="line"><span class="lineno"> 1487</span>        values = values.reshape((-1, self.input_dims))</div>
<div class="line"><span class="lineno"> 1488</span> </div>
<div class="line"><span class="lineno"> 1489</span>        <span class="comment"># Transform the values</span></div>
<div class="line"><span class="lineno"> 1490</span>        res = self.transform_affine(self.transform_non_affine(values))</div>
<div class="line"><span class="lineno"> 1491</span> </div>
<div class="line"><span class="lineno"> 1492</span>        <span class="comment"># Convert the result back to the shape of the input values.</span></div>
<div class="line"><span class="lineno"> 1493</span>        <span class="keywordflow">if</span> ndim == 0:</div>
<div class="line"><span class="lineno"> 1494</span>            <span class="keyword">assert</span> <span class="keywordflow">not</span> np.ma.is_masked(res)  <span class="comment"># just to be on the safe side</span></div>
<div class="line"><span class="lineno"> 1495</span>            <span class="keywordflow">return</span> res[0, 0]</div>
<div class="line"><span class="lineno"> 1496</span>        <span class="keywordflow">if</span> ndim == 1:</div>
<div class="line"><span class="lineno"> 1497</span>            <span class="keywordflow">return</span> res.reshape(-1)</div>
<div class="line"><span class="lineno"> 1498</span>        <span class="keywordflow">elif</span> ndim == 2:</div>
<div class="line"><span class="lineno"> 1499</span>            <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 1500</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1501</span>            <span class="stringliteral">&quot;Input values must have shape (N x {dims}) &quot;</span></div>
<div class="line"><span class="lineno"> 1502</span>            <span class="stringliteral">&quot;or ({dims}).&quot;</span>.format(dims=self.input_dims))</div>
<div class="line"><span class="lineno"> 1503</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a46a5da098109edd8cdbd236719d2410c" name="a46a5da098109edd8cdbd236719d2410c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a5da098109edd8cdbd236719d2410c">&#9670;&#160;</a></span>transform_affine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_affine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply only the affine part of this transformation on the
given array of values.

``transform(values)`` is always equivalent to
``transform_affine(transform_non_affine(values))``.

In non-affine transformations, this is generally a no-op.  In
affine transformations, this is equivalent to
``transform(values)``.

Parameters
----------
values : array
    The input values as NumPy array of length :attr:`input_dims` or
    shape (N x :attr:`input_dims`).

Returns
-------
array
    The output values as NumPy array of length :attr:`output_dims` or
    shape (N x :attr:`output_dims`), depending on the input.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine2_d_base.html#ab9390ff66e21638c071e77c02c6ec34f">matplotlib.transforms.Affine2DBase</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_affine2_d_base.html#ab9390ff66e21638c071e77c02c6ec34f">matplotlib.transforms.Affine2DBase</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#a239b78c2e81acc8369fe61585bcc5d5f">matplotlib.transforms.IdentityTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_generic_transform.html#ae4e8a3f9e00bb7efa68ca8b91b878fe4">matplotlib.transforms.CompositeGenericTransform</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#ab081d5914f5a2ff4dd067d08397b26c8">matplotlib.transforms.AffineBase</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1504</span>    <span class="keyword">def </span>transform_affine(self, values):</div>
<div class="line"><span class="lineno"> 1505</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">        Apply only the affine part of this transformation on the</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">        given array of values.</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">        ``transform(values)`` is always equivalent to</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        ``transform_affine(transform_non_affine(values))``.</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        In non-affine transformations, this is generally a no-op.  In</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">        affine transformations, this is equivalent to</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">        ``transform(values)``.</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">        values : array</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">            The input values as NumPy array of length :attr:`input_dims` or</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">            shape (N x :attr:`input_dims`).</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">        array</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">            The output values as NumPy array of length :attr:`output_dims` or</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">            shape (N x :attr:`output_dims`), depending on the input.</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1528</span>        <span class="keywordflow">return</span> self.get_affine().transform(values)</div>
<div class="line"><span class="lineno"> 1529</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a105399ba3093603576e3a727e777c4ea" name="a105399ba3093603576e3a727e777c4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105399ba3093603576e3a727e777c4ea">&#9670;&#160;</a></span>transform_angles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_angles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>angles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radians</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pushoff</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform a set of angles anchored at specific locations.

Parameters
----------
angles : (N,) array-like
    The angles to transform.
pts : (N, 2) array-like
    The points where the angles are anchored.
radians : bool, default: False
    Whether *angles* are radians or degrees.
pushoff : float
    For each point in *pts* and angle in *angles*, the transformed
    angle is computed by transforming a segment of length *pushoff*
    starting at that point and making that angle relative to the
    horizontal axis, and measuring the angle between the horizontal
    axis and the transformed segment.

Returns
-------
(N,) array
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1618</span>    <span class="keyword">def </span>transform_angles(self, angles, pts, radians=False, pushoff=1e-5):</div>
<div class="line"><span class="lineno"> 1619</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">        Transform a set of angles anchored at specific locations.</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">        angles : (N,) array-like</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">            The angles to transform.</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">        pts : (N, 2) array-like</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">            The points where the angles are anchored.</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">        radians : bool, default: False</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">            Whether *angles* are radians or degrees.</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">        pushoff : float</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">            For each point in *pts* and angle in *angles*, the transformed</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">            angle is computed by transforming a segment of length *pushoff*</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">            starting at that point and making that angle relative to the</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">            horizontal axis, and measuring the angle between the horizontal</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">            axis and the transformed segment.</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">        (N,) array</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1641</span>        <span class="comment"># Must be 2D</span></div>
<div class="line"><span class="lineno"> 1642</span>        <span class="keywordflow">if</span> self.input_dims != 2 <span class="keywordflow">or</span> self.output_dims != 2:</div>
<div class="line"><span class="lineno"> 1643</span>            <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&#39;Only defined in 2D&#39;</span>)</div>
<div class="line"><span class="lineno"> 1644</span>        angles = np.asarray(angles)</div>
<div class="line"><span class="lineno"> 1645</span>        pts = np.asarray(pts)</div>
<div class="line"><span class="lineno"> 1646</span>        _api.check_shape((<span class="keywordtype">None</span>, 2), pts=pts)</div>
<div class="line"><span class="lineno"> 1647</span>        _api.check_shape((<span class="keywordtype">None</span>,), angles=angles)</div>
<div class="line"><span class="lineno"> 1648</span>        <span class="keywordflow">if</span> len(angles) != len(pts):</div>
<div class="line"><span class="lineno"> 1649</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;There must be as many &#39;angles&#39; as &#39;pts&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1650</span>        <span class="comment"># Convert to radians if desired</span></div>
<div class="line"><span class="lineno"> 1651</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> radians:</div>
<div class="line"><span class="lineno"> 1652</span>            angles = np.deg2rad(angles)</div>
<div class="line"><span class="lineno"> 1653</span>        <span class="comment"># Move a short distance away</span></div>
<div class="line"><span class="lineno"> 1654</span>        pts2 = pts + pushoff * np.column_stack([np.cos(angles),</div>
<div class="line"><span class="lineno"> 1655</span>                                                np.sin(angles)])</div>
<div class="line"><span class="lineno"> 1656</span>        <span class="comment"># Transform both sets of points</span></div>
<div class="line"><span class="lineno"> 1657</span>        tpts = self.transform(pts)</div>
<div class="line"><span class="lineno"> 1658</span>        tpts2 = self.transform(pts2)</div>
<div class="line"><span class="lineno"> 1659</span>        <span class="comment"># Calculate transformed angles</span></div>
<div class="line"><span class="lineno"> 1660</span>        d = tpts2 - tpts</div>
<div class="line"><span class="lineno"> 1661</span>        a = np.arctan2(d[:, 1], d[:, 0])</div>
<div class="line"><span class="lineno"> 1662</span>        <span class="comment"># Convert back to degrees if desired</span></div>
<div class="line"><span class="lineno"> 1663</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> radians:</div>
<div class="line"><span class="lineno"> 1664</span>            a = np.rad2deg(a)</div>
<div class="line"><span class="lineno"> 1665</span>        <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno"> 1666</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d0129ccc8740a1c97c8d977196d3129" name="a7d0129ccc8740a1c97c8d977196d3129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0129ccc8740a1c97c8d977196d3129">&#9670;&#160;</a></span>transform_bbox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_bbox </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform the given bounding box.

For smarter transforms including caching (a common requirement in
Matplotlib), see `TransformedBbox`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1555</span>    <span class="keyword">def </span>transform_bbox(self, bbox):</div>
<div class="line"><span class="lineno"> 1556</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">        Transform the given bounding box.</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">        For smarter transforms including caching (a common requirement in</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">        Matplotlib), see `TransformedBbox`.</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1562</span>        <span class="keywordflow">return</span> Bbox(self.transform(bbox.get_points()))</div>
<div class="line"><span class="lineno"> 1563</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a617ef28309e2192597d706ae1c42c842" name="a617ef28309e2192597d706ae1c42c842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617ef28309e2192597d706ae1c42c842">&#9670;&#160;</a></span>transform_non_affine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_non_affine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply only the non-affine part of this transformation.

``transform(values)`` is always equivalent to
``transform_affine(transform_non_affine(values))``.

In non-affine transformations, this is generally equivalent to
``transform(values)``.  In affine transformations, this is
always a no-op.

Parameters
----------
values : array
    The input values as NumPy array of length :attr:`input_dims` or
    shape (N x :attr:`input_dims`).

Returns
-------
array
    The output values as NumPy array of length :attr:`output_dims` or
    shape (N x :attr:`output_dims`), depending on the input.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1scale_1_1_log_transform.html#a663989575a1e7424fc76d169a6007d59">matplotlib.scale.LogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_inverted_log_transform.html#af6c859951f37fc9301477c8e01354a3c">matplotlib.scale.InvertedLogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_symmetrical_log_transform.html#a63d7969978afb7d79ac6a0cb7d64d9b4">matplotlib.scale.SymmetricalLogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_inverted_symmetrical_log_transform.html#a03cf720aba14823a9a997213f0644662">matplotlib.scale.InvertedSymmetricalLogTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_asinh_transform.html#a642bd384a99302d8d4ca3647311a28a9">matplotlib.scale.AsinhTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_inverted_asinh_transform.html#a6b0bb91932c334f6c18f60a5808dca6e">matplotlib.scale.InvertedAsinhTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_logit_transform.html#a265009be4cf44617e493daf227b41fcc">matplotlib.scale.LogitTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_logistic_transform.html#aa6efa74d97d9294fe84b2b9af9dde120">matplotlib.scale.LogisticTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_aitoff_axes_1_1_aitoff_transform.html#a0113c8b6192b55d3322a2c35ef073f59">matplotlib.projections.geo.AitoffAxes.AitoffTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_hammer_axes_1_1_hammer_transform.html#a9648d6bd19649f7b6391f52b92b65241">matplotlib.projections.geo.HammerAxes.HammerTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_mollweide_axes_1_1_mollweide_transform.html#a921faef678e4aea8961f42471704b3ff">matplotlib.projections.geo.MollweideAxes.MollweideTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_lambert_axes_1_1_lambert_transform.html#a6ef5933a64920567fa51976f7213af16">matplotlib.projections.geo.LambertAxes.LambertTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#adb20dc9ba92fbf2b9eca2668fba3cec5">matplotlib.transforms.AffineBase</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#acc615ccd5e82fab110af18c1c31f78be">matplotlib.transforms.IdentityTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_blended_generic_transform.html#ad9d379dbba577ccfbedcc97eea6fab71">matplotlib.transforms.BlendedGenericTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_generic_transform.html#a100c4015f9d4f8b8d1df9d651e9d64ce">matplotlib.transforms.CompositeGenericTransform</a>, <a class="el" href="classmatplotlib_1_1scale_1_1_func_transform.html#ab7f1ae6b608d0f53f513c8ef9ed20907">matplotlib.scale.FuncTransform</a>, <a class="el" href="classaxisartist_1_1grid__finder_1_1___user2_d_transform.html#aed801d24c71628f5b43a1b21c1682894">axisartist.grid_finder._User2DTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_aitoff_axes_1_1_inverted_aitoff_transform.html#afc03c66680c0d16614f13fc6b62c6173">matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_hammer_axes_1_1_inverted_hammer_transform.html#a5fe955eebda8b9bb73610a90f1310f97">matplotlib.projections.geo.HammerAxes.InvertedHammerTransform</a>, <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_mollweide_axes_1_1_inverted_mollweide_transform.html#a76bd424c7512db86781a525a5b3fe6ad">matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform</a>, and <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1_lambert_axes_1_1_inverted_lambert_transform.html#a16be9ec067b6c9a2390ab9eac28ee227">matplotlib.projections.geo.LambertAxes.InvertedLambertTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1530</span>    <span class="keyword">def </span>transform_non_affine(self, values):</div>
<div class="line"><span class="lineno"> 1531</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">        Apply only the non-affine part of this transformation.</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">        ``transform(values)`` is always equivalent to</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">        ``transform_affine(transform_non_affine(values))``.</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">        In non-affine transformations, this is generally equivalent to</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">        ``transform(values)``.  In affine transformations, this is</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">        always a no-op.</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">        values : array</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">            The input values as NumPy array of length :attr:`input_dims` or</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">            shape (N x :attr:`input_dims`).</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">        array</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">            The output values as NumPy array of length :attr:`output_dims` or</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">            shape (N x :attr:`output_dims`), depending on the input.</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1553</span>        <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1554</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a10fb337dd589527fc102a643ca7f95c9" name="a10fb337dd589527fc102a643ca7f95c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fb337dd589527fc102a643ca7f95c9">&#9670;&#160;</a></span>transform_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply the transform to `.Path` *path*, returning a new `.Path`.

In some cases, this transform may insert curves into the path
that began as line segments.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#a6fd4e3c8226746ba7d12b60649a2a651">matplotlib.transforms.AffineBase</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#a4e9323a3e51dab4d5d9b7a36e31f83bc">matplotlib.transforms.IdentityTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1588</span>    <span class="keyword">def </span>transform_path(self, path):</div>
<div class="line"><span class="lineno"> 1589</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">        Apply the transform to `.Path` *path*, returning a new `.Path`.</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">        In some cases, this transform may insert curves into the path</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">        that began as line segments.</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1595</span>        <span class="keywordflow">return</span> self.transform_path_affine(self.transform_path_non_affine(path))</div>
<div class="line"><span class="lineno"> 1596</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a44d89e7ed4b93e6eed560bec8b9a2d32" name="a44d89e7ed4b93e6eed560bec8b9a2d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d89e7ed4b93e6eed560bec8b9a2d32">&#9670;&#160;</a></span>transform_path_affine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_path_affine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply the affine part of this transform to `.Path` *path*, returning a
new `.Path`.

``transform_path(path)`` is equivalent to
``transform_path_affine(transform_path_non_affine(values))``.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#ae9f412ed85d46d7a6b78c5320f62226e">matplotlib.transforms.AffineBase</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#a924478e19487b6b3adafcdfac42e4245">matplotlib.transforms.IdentityTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1597</span>    <span class="keyword">def </span>transform_path_affine(self, path):</div>
<div class="line"><span class="lineno"> 1598</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">        Apply the affine part of this transform to `.Path` *path*, returning a</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        new `.Path`.</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">        ``transform_path(path)`` is equivalent to</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">        ``transform_path_affine(transform_path_non_affine(values))``.</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1605</span>        <span class="keywordflow">return</span> self.get_affine().transform_path_affine(path)</div>
<div class="line"><span class="lineno"> 1606</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40ad8fcd7adabb6e4244a5a1dccd902d" name="a40ad8fcd7adabb6e4244a5a1dccd902d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ad8fcd7adabb6e4244a5a1dccd902d">&#9670;&#160;</a></span>transform_path_non_affine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_path_non_affine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply the non-affine part of this transform to `.Path` *path*,
returning a new `.Path`.

``transform_path(path)`` is equivalent to
``transform_path_affine(transform_path_non_affine(values))``.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1projections_1_1geo_1_1___geo_transform.html#a3a93c3b8faf2bb64f2e6c6be2629696a">matplotlib.projections.geo._GeoTransform</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_affine_base.html#a1a7b571e214b69708dba562115a5ffe0">matplotlib.transforms.AffineBase</a>, <a class="el" href="classmatplotlib_1_1transforms_1_1_identity_transform.html#a12ad4b43d348f3d7437d0d820f3505e6">matplotlib.transforms.IdentityTransform</a>, and <a class="el" href="classmatplotlib_1_1transforms_1_1_composite_generic_transform.html#a21273e0211acf43589b3913b0da6bf8a">matplotlib.transforms.CompositeGenericTransform</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1607</span>    <span class="keyword">def </span>transform_path_non_affine(self, path):</div>
<div class="line"><span class="lineno"> 1608</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">        Apply the non-affine part of this transform to `.Path` *path*,</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">        returning a new `.Path`.</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">        ``transform_path(path)`` is equivalent to</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">        ``transform_path_affine(transform_path_non_affine(values))``.</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1615</span>        x = self.transform_non_affine(path.vertices)</div>
<div class="line"><span class="lineno"> 1616</span>        <span class="keywordflow">return</span> Path._fast_from_codes_and_verts(x, path.codes, path)</div>
<div class="line"><span class="lineno"> 1617</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a20e22ca460e074ab0fda63b6528ab388" name="a20e22ca460e074ab0fda63b6528ab388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e22ca460e074ab0fda63b6528ab388">&#9670;&#160;</a></span>transform_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.transform_point </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a transformed point.

This function is only kept for backcompatibility; the more general
`.transform` method is capable of transforming both a list of points
and a single point.

The point is given as a sequence of length :attr:`input_dims`.
The transformed point is returned as a sequence of length
:attr:`output_dims`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1572</span>    <span class="keyword">def </span>transform_point(self, point):</div>
<div class="line"><span class="lineno"> 1573</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">        Return a transformed point.</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">        This function is only kept for backcompatibility; the more general</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">        `.transform` method is capable of transforming both a list of points</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral">        and a single point.</span></div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">        The point is given as a sequence of length :attr:`input_dims`.</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">        The transformed point is returned as a sequence of length</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">        :attr:`output_dims`.</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1584</span>        <span class="keywordflow">if</span> len(point) != self.input_dims:</div>
<div class="line"><span class="lineno"> 1585</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The length of &#39;point&#39; must be &#39;self.input_dims&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1586</span>        <span class="keywordflow">return</span> self.transform(point)</div>
<div class="line"><span class="lineno"> 1587</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1003fe73ba72390415bb580f4bb51499" name="a1003fe73ba72390415bb580f4bb51499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1003fe73ba72390415bb580f4bb51499">&#9670;&#160;</a></span>has_inverse <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool matplotlib.transforms.Transform.has_inverse = False</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cd7be3f8ed35b38c6a86c8d843121b0" name="a9cd7be3f8ed35b38c6a86c8d843121b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd7be3f8ed35b38c6a86c8d843121b0">&#9670;&#160;</a></span>has_inverse <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.has_inverse</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96d2969a2a9cbc5105534e2c848d0112" name="a96d2969a2a9cbc5105534e2c848d0112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d2969a2a9cbc5105534e2c848d0112">&#9670;&#160;</a></span>input_dims</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.input_dims = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbc38831d2adea7c8421b476289affd6" name="afbc38831d2adea7c8421b476289affd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc38831d2adea7c8421b476289affd6">&#9670;&#160;</a></span>is_separable <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool matplotlib.transforms.Transform.is_separable = False</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine2_d_base.html#a9df05a01538ac92a8d4be934a817a30c">matplotlib.transforms.Affine2DBase</a>.</p>

</div>
</div>
<a id="af81ccab23877735961f7d384a9947e8c" name="af81ccab23877735961f7d384a9947e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81ccab23877735961f7d384a9947e8c">&#9670;&#160;</a></span>is_separable <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.is_separable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1transforms_1_1_affine2_d_base.html#a9df05a01538ac92a8d4be934a817a30c">matplotlib.transforms.Affine2DBase</a>.</p>

</div>
</div>
<a id="a54640edfc4c4cec07e567f82a756f767" name="a54640edfc4c4cec07e567f82a756f767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54640edfc4c4cec07e567f82a756f767">&#9670;&#160;</a></span>output_dims</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.transforms.Transform.output_dims = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/matplotlib/<a class="el" href="matplotlib_2transforms_8py.html">transforms.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
