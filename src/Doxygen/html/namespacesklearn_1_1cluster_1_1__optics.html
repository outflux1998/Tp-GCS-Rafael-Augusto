<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.cluster._optics Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html">_optics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.cluster._optics Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__optics_1_1_o_p_t_i_c_s.html">OPTICS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1a23fd16403b68f90c5a8e94bdd806ff" id="r_a1a23fd16403b68f90c5a8e94bdd806ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#a1a23fd16403b68f90c5a8e94bdd806ff">_validate_size</a> (size, n_samples, param_name)</td></tr>
<tr class="separator:a1a23fd16403b68f90c5a8e94bdd806ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7f077f478b42dd9770583dafaa7c62" id="r_afb7f077f478b42dd9770583dafaa7c62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#afb7f077f478b42dd9770583dafaa7c62">_compute_core_distances_</a> (X, neighbors, min_samples, working_memory)</td></tr>
<tr class="separator:afb7f077f478b42dd9770583dafaa7c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae463a6ca7d936104ee2b2cdb5c3e23b9" id="r_ae463a6ca7d936104ee2b2cdb5c3e23b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#ae463a6ca7d936104ee2b2cdb5c3e23b9">compute_optics_graph</a> (X, *min_samples, max_eps, metric, p, metric_params, algorithm, leaf_size, n_jobs)</td></tr>
<tr class="separator:ae463a6ca7d936104ee2b2cdb5c3e23b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3984ecdd3e7f496266936f970febf7cc" id="r_a3984ecdd3e7f496266936f970febf7cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#a3984ecdd3e7f496266936f970febf7cc">_set_reach_dist</a> (core_distances_, reachability_, predecessor_, point_index, processed, X, nbrs, metric, metric_params, p, max_eps)</td></tr>
<tr class="separator:a3984ecdd3e7f496266936f970febf7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc94c07cba78b77a702fc6b8728375eb" id="r_acc94c07cba78b77a702fc6b8728375eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#acc94c07cba78b77a702fc6b8728375eb">cluster_optics_dbscan</a> (*reachability, core_distances, ordering, <a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>)</td></tr>
<tr class="separator:acc94c07cba78b77a702fc6b8728375eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8468854ca94951890b390907bdaaa731" id="r_a8468854ca94951890b390907bdaaa731"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#a8468854ca94951890b390907bdaaa731">cluster_optics_xi</a> (*reachability, predecessor, ordering, min_samples, min_cluster_size=None, xi=0.05, predecessor_correction=True)</td></tr>
<tr class="separator:a8468854ca94951890b390907bdaaa731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab161ee0866fb871a43881f9228dc10da" id="r_ab161ee0866fb871a43881f9228dc10da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#ab161ee0866fb871a43881f9228dc10da">_extend_region</a> (steep_point, xward_point, start, min_samples)</td></tr>
<tr class="separator:ab161ee0866fb871a43881f9228dc10da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f52f7066710373e697427ce6891250" id="r_a59f52f7066710373e697427ce6891250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#a59f52f7066710373e697427ce6891250">_update_filter_sdas</a> (sdas, mib, xi_complement, reachability_plot)</td></tr>
<tr class="separator:a59f52f7066710373e697427ce6891250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada463efea84a53b7ea5e103432ed6421" id="r_ada463efea84a53b7ea5e103432ed6421"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#ada463efea84a53b7ea5e103432ed6421">_correct_predecessor</a> (reachability_plot, predecessor_plot, ordering, s, e)</td></tr>
<tr class="separator:ada463efea84a53b7ea5e103432ed6421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca4867ed224dee781e1ae63c64f4307" id="r_a9ca4867ed224dee781e1ae63c64f4307"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#a9ca4867ed224dee781e1ae63c64f4307">_xi_cluster</a> (reachability_plot, predecessor_plot, ordering, xi, min_samples, min_cluster_size, predecessor_correction)</td></tr>
<tr class="separator:a9ca4867ed224dee781e1ae63c64f4307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9754cc79736a1fd15348c5d32097d5bc" id="r_a9754cc79736a1fd15348c5d32097d5bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__optics.html#a9754cc79736a1fd15348c5d32097d5bc">_extract_xi_labels</a> (ordering, clusters)</td></tr>
<tr class="separator:a9754cc79736a1fd15348c5d32097d5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Ordering Points To Identify the Clustering Structure (OPTICS)

These routines execute the OPTICS algorithm, and implement various
cluster extraction methods of the ordered list.

Authors: Shane Grigsby &lt;refuge@rocktalus.com&gt;
         Adrin Jalali &lt;adrinjalali@gmail.com&gt;
         Erich Schubert &lt;erich@debian.org&gt;
         Hanmin Qin &lt;qinhanmin2005@sina.com&gt;
License: BSD 3 clause
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="afb7f077f478b42dd9770583dafaa7c62" name="afb7f077f478b42dd9770583dafaa7c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7f077f478b42dd9770583dafaa7c62">&#9670;&#160;</a></span>_compute_core_distances_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._compute_core_distances_ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>working_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the k-th nearest neighbor of each sample.

Equivalent to neighbors.kneighbors(X, self.min_samples)[0][:, -1]
but with more memory efficiency.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    The data.
neighbors : NearestNeighbors instance
    The fitted nearest neighbors estimator.
working_memory : int, default=None
    The sought maximum memory for temporary distance matrix chunks.
    When None (default), the value of
    ``sklearn.get_config()['working_memory']`` is used.

Returns
-------
core_distances : ndarray of shape (n_samples,)
    Distance at which each sample becomes a core point.
    Points which will never be core have a distance of inf.
</pre> <div class="fragment"><div class="line"><span class="lineno">  390</span><span class="keyword">def </span>_compute_core_distances_(X, neighbors, min_samples, working_memory):</div>
<div class="line"><span class="lineno">  391</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the k-th nearest neighbor of each sample.</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    Equivalent to neighbors.kneighbors(X, self.min_samples)[0][:, -1]</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    but with more memory efficiency.</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        The data.</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    neighbors : NearestNeighbors instance</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">        The fitted nearest neighbors estimator.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    working_memory : int, default=None</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">        The sought maximum memory for temporary distance matrix chunks.</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">        When None (default), the value of</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        ``sklearn.get_config()[&#39;working_memory&#39;]`` is used.</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    core_distances : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        Distance at which each sample becomes a core point.</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        Points which will never be core have a distance of inf.</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  413</span>    n_samples = X.shape[0]</div>
<div class="line"><span class="lineno">  414</span>    core_distances = np.empty(n_samples)</div>
<div class="line"><span class="lineno">  415</span>    core_distances.fill(np.nan)</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>    chunk_n_rows = get_chunk_n_rows(</div>
<div class="line"><span class="lineno">  418</span>        row_bytes=16 * min_samples, max_n_rows=n_samples, working_memory=working_memory</div>
<div class="line"><span class="lineno">  419</span>    )</div>
<div class="line"><span class="lineno">  420</span>    slices = gen_batches(n_samples, chunk_n_rows)</div>
<div class="line"><span class="lineno">  421</span>    <span class="keywordflow">for</span> sl <span class="keywordflow">in</span> slices:</div>
<div class="line"><span class="lineno">  422</span>        core_distances[sl] = neighbors.kneighbors(X[sl], min_samples)[0][:, -1]</div>
<div class="line"><span class="lineno">  423</span>    <span class="keywordflow">return</span> core_distances</div>
<div class="line"><span class="lineno">  424</span> </div>
<div class="line"><span class="lineno">  425</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ada463efea84a53b7ea5e103432ed6421" name="ada463efea84a53b7ea5e103432ed6421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada463efea84a53b7ea5e103432ed6421">&#9670;&#160;</a></span>_correct_predecessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._correct_predecessor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reachability_plot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predecessor_plot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Correct for predecessors.

Applies Algorithm 2 of [1]_.

Input parameters are ordered by the computer OPTICS ordering.

.. [1] Schubert, Erich, Michael Gertz.
   "Improving the Cluster Structure Extracted from OPTICS Plots." Proc. of
   the Conference "Lernen, Wissen, Daten, Analysen" (LWDA) (2018): 318-329.
</pre> <div class="fragment"><div class="line"><span class="lineno">  847</span><span class="keyword">def </span>_correct_predecessor(reachability_plot, predecessor_plot, ordering, s, e):</div>
<div class="line"><span class="lineno">  848</span>    <span class="stringliteral">&quot;&quot;&quot;Correct for predecessors.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    Applies Algorithm 2 of [1]_.</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    Input parameters are ordered by the computer OPTICS ordering.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    .. [1] Schubert, Erich, Michael Gertz.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">       &quot;Improving the Cluster Structure Extracted from OPTICS Plots.&quot; Proc. of</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">       the Conference &quot;Lernen, Wissen, Daten, Analysen&quot; (LWDA) (2018): 318-329.</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  858</span>    <span class="keywordflow">while</span> s &lt; e:</div>
<div class="line"><span class="lineno">  859</span>        <span class="keywordflow">if</span> reachability_plot[s] &gt; reachability_plot[e]:</div>
<div class="line"><span class="lineno">  860</span>            <span class="keywordflow">return</span> s, e</div>
<div class="line"><span class="lineno">  861</span>        p_e = ordering[predecessor_plot[e]]</div>
<div class="line"><span class="lineno">  862</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(s, e):</div>
<div class="line"><span class="lineno">  863</span>            <span class="keywordflow">if</span> p_e == ordering[i]:</div>
<div class="line"><span class="lineno">  864</span>                <span class="keywordflow">return</span> s, e</div>
<div class="line"><span class="lineno">  865</span>        e -= 1</div>
<div class="line"><span class="lineno">  866</span>    <span class="keywordflow">return</span> <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  867</span> </div>
<div class="line"><span class="lineno">  868</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab161ee0866fb871a43881f9228dc10da" name="ab161ee0866fb871a43881f9228dc10da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab161ee0866fb871a43881f9228dc10da">&#9670;&#160;</a></span>_extend_region()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._extend_region </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steep_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xward_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Extend the area until it's maximal.

It's the same function for both upward and downward reagions, depending on
the given input parameters. Assuming:

    - steep_{upward/downward}: bool array indicating whether a point is a
      steep {upward/downward};
    - upward/downward: bool array indicating whether a point is
      upward/downward;

To extend an upward reagion, ``steep_point=steep_upward`` and
``xward_point=downward`` are expected, and to extend a downward region,
``steep_point=steep_downward`` and ``xward_point=upward``.

Parameters
----------
steep_point : ndarray of shape (n_samples,), dtype=bool
    True if the point is steep downward (upward).

xward_point : ndarray of shape (n_samples,), dtype=bool
    True if the point is an upward (respectively downward) point.

start : int
    The start of the xward region.

min_samples : int
   The same as the min_samples given to OPTICS. Up and down steep
   regions can't have more then ``min_samples`` consecutive non-steep
   points.

Returns
-------
index : int
    The current index iterating over all the samples, i.e. where we are up
    to in our search.

end : int
    The end of the region, which can be behind the index. The region
    includes the ``end`` index.
</pre> <div class="fragment"><div class="line"><span class="lineno">  770</span><span class="keyword">def </span>_extend_region(steep_point, xward_point, start, min_samples):</div>
<div class="line"><span class="lineno">  771</span>    <span class="stringliteral">&quot;&quot;&quot;Extend the area until it&#39;s maximal.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    It&#39;s the same function for both upward and downward reagions, depending on</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    the given input parameters. Assuming:</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        - steep_{upward/downward}: bool array indicating whether a point is a</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">          steep {upward/downward};</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">        - upward/downward: bool array indicating whether a point is</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">          upward/downward;</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    To extend an upward reagion, ``steep_point=steep_upward`` and</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    ``xward_point=downward`` are expected, and to extend a downward region,</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    ``steep_point=steep_downward`` and ``xward_point=upward``.</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    steep_point : ndarray of shape (n_samples,), dtype=bool</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        True if the point is steep downward (upward).</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    xward_point : ndarray of shape (n_samples,), dtype=bool</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">        True if the point is an upward (respectively downward) point.</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    start : int</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        The start of the xward region.</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    min_samples : int</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">       The same as the min_samples given to OPTICS. Up and down steep</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">       regions can&#39;t have more then ``min_samples`` consecutive non-steep</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">       points.</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    index : int</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        The current index iterating over all the samples, i.e. where we are up</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        to in our search.</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    end : int</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        The end of the region, which can be behind the index. The region</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        includes the ``end`` index.</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  811</span>    n_samples = len(steep_point)</div>
<div class="line"><span class="lineno">  812</span>    non_xward_points = 0</div>
<div class="line"><span class="lineno">  813</span>    index = start</div>
<div class="line"><span class="lineno">  814</span>    end = start</div>
<div class="line"><span class="lineno">  815</span>    <span class="comment"># find a maximal area</span></div>
<div class="line"><span class="lineno">  816</span>    <span class="keywordflow">while</span> index &lt; n_samples:</div>
<div class="line"><span class="lineno">  817</span>        <span class="keywordflow">if</span> steep_point[index]:</div>
<div class="line"><span class="lineno">  818</span>            non_xward_points = 0</div>
<div class="line"><span class="lineno">  819</span>            end = index</div>
<div class="line"><span class="lineno">  820</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> xward_point[index]:</div>
<div class="line"><span class="lineno">  821</span>            <span class="comment"># it&#39;s not a steep point, but still goes up.</span></div>
<div class="line"><span class="lineno">  822</span>            non_xward_points += 1</div>
<div class="line"><span class="lineno">  823</span>            <span class="comment"># region should include no more than min_samples consecutive</span></div>
<div class="line"><span class="lineno">  824</span>            <span class="comment"># non steep xward points.</span></div>
<div class="line"><span class="lineno">  825</span>            <span class="keywordflow">if</span> non_xward_points &gt; min_samples:</div>
<div class="line"><span class="lineno">  826</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  827</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  828</span>            <span class="keywordflow">return</span> end</div>
<div class="line"><span class="lineno">  829</span>        index += 1</div>
<div class="line"><span class="lineno">  830</span>    <span class="keywordflow">return</span> end</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9754cc79736a1fd15348c5d32097d5bc" name="a9754cc79736a1fd15348c5d32097d5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754cc79736a1fd15348c5d32097d5bc">&#9670;&#160;</a></span>_extract_xi_labels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._extract_xi_labels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Extracts the labels from the clusters returned by `_xi_cluster`.
We rely on the fact that clusters are stored
with the smaller clusters coming before the larger ones.

Parameters
----------
ordering : array-like of shape (n_samples,)
    The ordering of points calculated by OPTICS

clusters : array-like of shape (n_clusters, 2)
    List of clusters i.e. (start, end) tuples,
    as returned by `_xi_cluster`.

Returns
-------
labels : ndarray of shape (n_samples,)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1024</span><span class="keyword">def </span>_extract_xi_labels(ordering, clusters):</div>
<div class="line"><span class="lineno"> 1025</span>    <span class="stringliteral">&quot;&quot;&quot;Extracts the labels from the clusters returned by `_xi_cluster`.</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    We rely on the fact that clusters are stored</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    with the smaller clusters coming before the larger ones.</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    ordering : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">        The ordering of points calculated by OPTICS</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    clusters : array-like of shape (n_clusters, 2)</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">        List of clusters i.e. (start, end) tuples,</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">        as returned by `_xi_cluster`.</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    labels : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1042</span> </div>
<div class="line"><span class="lineno"> 1043</span>    labels = np.full(len(ordering), -1, dtype=int)</div>
<div class="line"><span class="lineno"> 1044</span>    label = 0</div>
<div class="line"><span class="lineno"> 1045</span>    <span class="keywordflow">for</span> c <span class="keywordflow">in</span> clusters:</div>
<div class="line"><span class="lineno"> 1046</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.any(labels[c[0] : (c[1] + 1)] != -1):</div>
<div class="line"><span class="lineno"> 1047</span>            labels[c[0] : (c[1] + 1)] = label</div>
<div class="line"><span class="lineno"> 1048</span>            label += 1</div>
<div class="line"><span class="lineno"> 1049</span>    labels[ordering] = labels.copy()</div>
<div class="line"><span class="lineno"> 1050</span>    <span class="keywordflow">return</span> labels</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3984ecdd3e7f496266936f970febf7cc" name="a3984ecdd3e7f496266936f970febf7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3984ecdd3e7f496266936f970febf7cc">&#9670;&#160;</a></span>_set_reach_dist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._set_reach_dist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>core_distances_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reachability_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predecessor_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>processed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  618</span>):</div>
<div class="line"><span class="lineno">  619</span>    P = X[point_index : point_index + 1]</div>
<div class="line"><span class="lineno">  620</span>    <span class="comment"># Assume that radius_neighbors is faster without distances</span></div>
<div class="line"><span class="lineno">  621</span>    <span class="comment"># and we don&#39;t need all distances, nevertheless, this means</span></div>
<div class="line"><span class="lineno">  622</span>    <span class="comment"># we may be doing some work twice.</span></div>
<div class="line"><span class="lineno">  623</span>    indices = nbrs.radius_neighbors(P, radius=max_eps, return_distance=<span class="keyword">False</span>)[0]</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span>    <span class="comment"># Getting indices of neighbors that have not been processed</span></div>
<div class="line"><span class="lineno">  626</span>    unproc = np.compress(~np.take(processed, indices), indices)</div>
<div class="line"><span class="lineno">  627</span>    <span class="comment"># Neighbors of current point are already processed.</span></div>
<div class="line"><span class="lineno">  628</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> unproc.size:</div>
<div class="line"><span class="lineno">  629</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  630</span> </div>
<div class="line"><span class="lineno">  631</span>    <span class="comment"># Only compute distances to unprocessed neighbors:</span></div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">if</span> metric == <span class="stringliteral">&quot;precomputed&quot;</span>:</div>
<div class="line"><span class="lineno">  633</span>        dists = X[point_index, unproc]</div>
<div class="line"><span class="lineno">  634</span>        <span class="keywordflow">if</span> issparse(dists):</div>
<div class="line"><span class="lineno">  635</span>            dists.sort_indices()</div>
<div class="line"><span class="lineno">  636</span>            dists = dists.data</div>
<div class="line"><span class="lineno">  637</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  638</span>        _params = dict() <span class="keywordflow">if</span> metric_params <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> metric_params.copy()</div>
<div class="line"><span class="lineno">  639</span>        <span class="keywordflow">if</span> metric == <span class="stringliteral">&quot;minkowski&quot;</span> <span class="keywordflow">and</span> <span class="stringliteral">&quot;p&quot;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> _params:</div>
<div class="line"><span class="lineno">  640</span>            <span class="comment"># the same logic as neighbors, p is ignored if explicitly set</span></div>
<div class="line"><span class="lineno">  641</span>            <span class="comment"># in the dict params</span></div>
<div class="line"><span class="lineno">  642</span>            _params[<span class="stringliteral">&quot;p&quot;</span>] = p</div>
<div class="line"><span class="lineno">  643</span>        dists = pairwise_distances(P, X[unproc], metric, n_jobs=<span class="keywordtype">None</span>, **_params).ravel()</div>
<div class="line"><span class="lineno">  644</span> </div>
<div class="line"><span class="lineno">  645</span>    rdists = np.maximum(dists, core_distances_[point_index])</div>
<div class="line"><span class="lineno">  646</span>    np.around(rdists, decimals=np.finfo(rdists.dtype).precision, out=rdists)</div>
<div class="line"><span class="lineno">  647</span>    improved = np.where(rdists &lt; np.take(reachability_, unproc))</div>
<div class="line"><span class="lineno">  648</span>    reachability_[unproc[improved]] = rdists[improved]</div>
<div class="line"><span class="lineno">  649</span>    predecessor_[unproc[improved]] = point_index</div>
<div class="line"><span class="lineno">  650</span> </div>
<div class="line"><span class="lineno">  651</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a59f52f7066710373e697427ce6891250" name="a59f52f7066710373e697427ce6891250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f52f7066710373e697427ce6891250">&#9670;&#160;</a></span>_update_filter_sdas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._update_filter_sdas </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sdas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xi_complement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reachability_plot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Update steep down areas (SDAs) using the new maximum in between (mib)
value, and the given complement of xi, i.e. ``1 - xi``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  833</span><span class="keyword">def </span>_update_filter_sdas(sdas, mib, xi_complement, reachability_plot):</div>
<div class="line"><span class="lineno">  834</span>    <span class="stringliteral">&quot;&quot;&quot;Update steep down areas (SDAs) using the new maximum in between (mib)</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    value, and the given complement of xi, i.e. ``1 - xi``.</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  837</span>    <span class="keywordflow">if</span> np.isinf(mib):</div>
<div class="line"><span class="lineno">  838</span>        <span class="keywordflow">return</span> []</div>
<div class="line"><span class="lineno">  839</span>    res = [</div>
<div class="line"><span class="lineno">  840</span>        sda <span class="keywordflow">for</span> sda <span class="keywordflow">in</span> sdas <span class="keywordflow">if</span> mib &lt;= reachability_plot[sda[<span class="stringliteral">&quot;start&quot;</span>]] * xi_complement</div>
<div class="line"><span class="lineno">  841</span>    ]</div>
<div class="line"><span class="lineno">  842</span>    <span class="keywordflow">for</span> sda <span class="keywordflow">in</span> res:</div>
<div class="line"><span class="lineno">  843</span>        sda[<span class="stringliteral">&quot;mib&quot;</span>] = max(sda[<span class="stringliteral">&quot;mib&quot;</span>], mib)</div>
<div class="line"><span class="lineno">  844</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  845</span> </div>
<div class="line"><span class="lineno">  846</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a23fd16403b68f90c5a8e94bdd806ff" name="a1a23fd16403b68f90c5a8e94bdd806ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a23fd16403b68f90c5a8e94bdd806ff">&#9670;&#160;</a></span>_validate_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._validate_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  381</span><span class="keyword">def </span>_validate_size(size, n_samples, param_name):</div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">if</span> size &gt; n_samples:</div>
<div class="line"><span class="lineno">  383</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  384</span>            <span class="stringliteral">&quot;%s must be no greater than the number of samples (%d). Got %d&quot;</span></div>
<div class="line"><span class="lineno">  385</span>            % (param_name, n_samples, size)</div>
<div class="line"><span class="lineno">  386</span>        )</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span><span class="comment"># OPTICS helper functions</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ca4867ed224dee781e1ae63c64f4307" name="a9ca4867ed224dee781e1ae63c64f4307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca4867ed224dee781e1ae63c64f4307">&#9670;&#160;</a></span>_xi_cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics._xi_cluster </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reachability_plot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predecessor_plot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_cluster_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predecessor_correction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Automatically extract clusters according to the Xi-steep method.

This is rouphly an implementation of Figure 19 of the OPTICS paper.

Parameters
----------
reachability_plot : array-like of shape (n_samples,)
    The reachability plot, i.e. reachability ordered according to
    the calculated ordering, all computed by OPTICS.

predecessor_plot : array-like of shape (n_samples,)
    Predecessors ordered according to the calculated ordering.

xi : float, between 0 and 1
    Determines the minimum steepness on the reachability plot that
    constitutes a cluster boundary. For example, an upwards point in the
    reachability plot is defined by the ratio from one point to its
    successor being at most 1-xi.

min_samples : int &gt; 1
    The same as the min_samples given to OPTICS. Up and down steep regions
    can't have more then ``min_samples`` consecutive non-steep points.

min_cluster_size : int &gt; 1
    Minimum number of samples in an OPTICS cluster.

predecessor_correction : bool
    Correct clusters based on the calculated predecessors.

Returns
-------
clusters : ndarray of shape (n_clusters, 2)
    The list of clusters in the form of [start, end] in each row, with all
    indices inclusive. The clusters are ordered in a way that larger
    clusters encompassing smaller clusters come after those smaller
    clusters.
</pre> <div class="fragment"><div class="line"><span class="lineno">  877</span>):</div>
<div class="line"><span class="lineno">  878</span>    <span class="stringliteral">&quot;&quot;&quot;Automatically extract clusters according to the Xi-steep method.</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    This is rouphly an implementation of Figure 19 of the OPTICS paper.</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    reachability_plot : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">        The reachability plot, i.e. reachability ordered according to</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">        the calculated ordering, all computed by OPTICS.</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    predecessor_plot : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        Predecessors ordered according to the calculated ordering.</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    xi : float, between 0 and 1</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">        Determines the minimum steepness on the reachability plot that</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">        constitutes a cluster boundary. For example, an upwards point in the</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">        reachability plot is defined by the ratio from one point to its</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">        successor being at most 1-xi.</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    min_samples : int &gt; 1</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">        The same as the min_samples given to OPTICS. Up and down steep regions</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">        can&#39;t have more then ``min_samples`` consecutive non-steep points.</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    min_cluster_size : int &gt; 1</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">        Minimum number of samples in an OPTICS cluster.</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    predecessor_correction : bool</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">        Correct clusters based on the calculated predecessors.</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    clusters : ndarray of shape (n_clusters, 2)</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        The list of clusters in the form of [start, end] in each row, with all</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        indices inclusive. The clusters are ordered in a way that larger</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        clusters encompassing smaller clusters come after those smaller</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        clusters.</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  915</span> </div>
<div class="line"><span class="lineno">  916</span>    <span class="comment"># Our implementation adds an inf to the end of reachability plot</span></div>
<div class="line"><span class="lineno">  917</span>    <span class="comment"># this helps to find potential clusters at the end of the</span></div>
<div class="line"><span class="lineno">  918</span>    <span class="comment"># reachability plot even if there&#39;s no upward region at the end of it.</span></div>
<div class="line"><span class="lineno">  919</span>    reachability_plot = np.hstack((reachability_plot, np.inf))</div>
<div class="line"><span class="lineno">  920</span> </div>
<div class="line"><span class="lineno">  921</span>    xi_complement = 1 - xi</div>
<div class="line"><span class="lineno">  922</span>    sdas = []  <span class="comment"># steep down areas, introduced in section 4.3.2 of the paper</span></div>
<div class="line"><span class="lineno">  923</span>    clusters = []</div>
<div class="line"><span class="lineno">  924</span>    index = 0</div>
<div class="line"><span class="lineno">  925</span>    mib = 0.0  <span class="comment"># maximum in between, section 4.3.2</span></div>
<div class="line"><span class="lineno">  926</span> </div>
<div class="line"><span class="lineno">  927</span>    <span class="comment"># Our implementation corrects a mistake in the original</span></div>
<div class="line"><span class="lineno">  928</span>    <span class="comment"># paper, i.e., in Definition 9 steep downward point,</span></div>
<div class="line"><span class="lineno">  929</span>    <span class="comment"># r(p) * (1 - x1) &lt;= r(p + 1) should be</span></div>
<div class="line"><span class="lineno">  930</span>    <span class="comment"># r(p) * (1 - x1) &gt;= r(p + 1)</span></div>
<div class="line"><span class="lineno">  931</span>    <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno">  932</span>        ratio = reachability_plot[:-1] / reachability_plot[1:]</div>
<div class="line"><span class="lineno">  933</span>        steep_upward = ratio &lt;= xi_complement</div>
<div class="line"><span class="lineno">  934</span>        steep_downward = ratio &gt;= 1 / xi_complement</div>
<div class="line"><span class="lineno">  935</span>        downward = ratio &gt; 1</div>
<div class="line"><span class="lineno">  936</span>        upward = ratio &lt; 1</div>
<div class="line"><span class="lineno">  937</span> </div>
<div class="line"><span class="lineno">  938</span>    <span class="comment"># the following loop is almost exactly as Figure 19 of the paper.</span></div>
<div class="line"><span class="lineno">  939</span>    <span class="comment"># it jumps over the areas which are not either steep down or up areas</span></div>
<div class="line"><span class="lineno">  940</span>    <span class="keywordflow">for</span> steep_index <span class="keywordflow">in</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(np.flatnonzero(steep_upward | steep_downward)):</div>
<div class="line"><span class="lineno">  941</span>        <span class="comment"># just continue if steep_index has been a part of a discovered xward</span></div>
<div class="line"><span class="lineno">  942</span>        <span class="comment"># area.</span></div>
<div class="line"><span class="lineno">  943</span>        <span class="keywordflow">if</span> steep_index &lt; index:</div>
<div class="line"><span class="lineno">  944</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  945</span> </div>
<div class="line"><span class="lineno">  946</span>        mib = max(mib, np.max(reachability_plot[index : steep_index + 1]))</div>
<div class="line"><span class="lineno">  947</span> </div>
<div class="line"><span class="lineno">  948</span>        <span class="comment"># steep downward areas</span></div>
<div class="line"><span class="lineno">  949</span>        <span class="keywordflow">if</span> steep_downward[steep_index]:</div>
<div class="line"><span class="lineno">  950</span>            sdas = _update_filter_sdas(sdas, mib, xi_complement, reachability_plot)</div>
<div class="line"><span class="lineno">  951</span>            D_start = steep_index</div>
<div class="line"><span class="lineno">  952</span>            D_end = _extend_region(steep_downward, upward, D_start, min_samples)</div>
<div class="line"><span class="lineno">  953</span>            D = {<span class="stringliteral">&quot;start&quot;</span>: D_start, <span class="stringliteral">&quot;end&quot;</span>: D_end, <span class="stringliteral">&quot;mib&quot;</span>: 0.0}</div>
<div class="line"><span class="lineno">  954</span>            sdas.append(D)</div>
<div class="line"><span class="lineno">  955</span>            index = D_end + 1</div>
<div class="line"><span class="lineno">  956</span>            mib = reachability_plot[index]</div>
<div class="line"><span class="lineno">  957</span> </div>
<div class="line"><span class="lineno">  958</span>        <span class="comment"># steep upward areas</span></div>
<div class="line"><span class="lineno">  959</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  960</span>            sdas = _update_filter_sdas(sdas, mib, xi_complement, reachability_plot)</div>
<div class="line"><span class="lineno">  961</span>            U_start = steep_index</div>
<div class="line"><span class="lineno">  962</span>            U_end = _extend_region(steep_upward, downward, U_start, min_samples)</div>
<div class="line"><span class="lineno">  963</span>            index = U_end + 1</div>
<div class="line"><span class="lineno">  964</span>            mib = reachability_plot[index]</div>
<div class="line"><span class="lineno">  965</span> </div>
<div class="line"><span class="lineno">  966</span>            U_clusters = []</div>
<div class="line"><span class="lineno">  967</span>            <span class="keywordflow">for</span> D <span class="keywordflow">in</span> sdas:</div>
<div class="line"><span class="lineno">  968</span>                c_start = D[<span class="stringliteral">&quot;start&quot;</span>]</div>
<div class="line"><span class="lineno">  969</span>                c_end = U_end</div>
<div class="line"><span class="lineno">  970</span> </div>
<div class="line"><span class="lineno">  971</span>                <span class="comment"># line (**), sc2*</span></div>
<div class="line"><span class="lineno">  972</span>                <span class="keywordflow">if</span> reachability_plot[c_end + 1] * xi_complement &lt; D[<span class="stringliteral">&quot;mib&quot;</span>]:</div>
<div class="line"><span class="lineno">  973</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>                <span class="comment"># Definition 11: criterion 4</span></div>
<div class="line"><span class="lineno">  976</span>                D_max = reachability_plot[D[<span class="stringliteral">&quot;start&quot;</span>]]</div>
<div class="line"><span class="lineno">  977</span>                <span class="keywordflow">if</span> D_max * xi_complement &gt;= reachability_plot[c_end + 1]:</div>
<div class="line"><span class="lineno">  978</span>                    <span class="comment"># Find the first index from the left side which is almost</span></div>
<div class="line"><span class="lineno">  979</span>                    <span class="comment"># at the same level as the end of the detected cluster.</span></div>
<div class="line"><span class="lineno">  980</span>                    <span class="keywordflow">while</span> (</div>
<div class="line"><span class="lineno">  981</span>                        reachability_plot[c_start + 1] &gt; reachability_plot[c_end + 1]</div>
<div class="line"><span class="lineno">  982</span>                        <span class="keywordflow">and</span> c_start &lt; D[<span class="stringliteral">&quot;end&quot;</span>]</div>
<div class="line"><span class="lineno">  983</span>                    ):</div>
<div class="line"><span class="lineno">  984</span>                        c_start += 1</div>
<div class="line"><span class="lineno">  985</span>                <span class="keywordflow">elif</span> reachability_plot[c_end + 1] * xi_complement &gt;= D_max:</div>
<div class="line"><span class="lineno">  986</span>                    <span class="comment"># Find the first index from the right side which is almost</span></div>
<div class="line"><span class="lineno">  987</span>                    <span class="comment"># at the same level as the beginning of the detected</span></div>
<div class="line"><span class="lineno">  988</span>                    <span class="comment"># cluster.</span></div>
<div class="line"><span class="lineno">  989</span>                    <span class="comment"># Our implementation corrects a mistake in the original</span></div>
<div class="line"><span class="lineno">  990</span>                    <span class="comment"># paper, i.e., in Definition 11 4c, r(x) &lt; r(sD) should be</span></div>
<div class="line"><span class="lineno">  991</span>                    <span class="comment"># r(x) &gt; r(sD).</span></div>
<div class="line"><span class="lineno">  992</span>                    <span class="keywordflow">while</span> reachability_plot[c_end - 1] &gt; D_max <span class="keywordflow">and</span> c_end &gt; U_start:</div>
<div class="line"><span class="lineno">  993</span>                        c_end -= 1</div>
<div class="line"><span class="lineno">  994</span> </div>
<div class="line"><span class="lineno">  995</span>                <span class="comment"># predecessor correction</span></div>
<div class="line"><span class="lineno">  996</span>                <span class="keywordflow">if</span> predecessor_correction:</div>
<div class="line"><span class="lineno">  997</span>                    c_start, c_end = _correct_predecessor(</div>
<div class="line"><span class="lineno">  998</span>                        reachability_plot, predecessor_plot, ordering, c_start, c_end</div>
<div class="line"><span class="lineno">  999</span>                    )</div>
<div class="line"><span class="lineno"> 1000</span>                <span class="keywordflow">if</span> c_start <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1001</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1002</span> </div>
<div class="line"><span class="lineno"> 1003</span>                <span class="comment"># Definition 11: criterion 3.a</span></div>
<div class="line"><span class="lineno"> 1004</span>                <span class="keywordflow">if</span> c_end - c_start + 1 &lt; min_cluster_size:</div>
<div class="line"><span class="lineno"> 1005</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1006</span> </div>
<div class="line"><span class="lineno"> 1007</span>                <span class="comment"># Definition 11: criterion 1</span></div>
<div class="line"><span class="lineno"> 1008</span>                <span class="keywordflow">if</span> c_start &gt; D[<span class="stringliteral">&quot;end&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1009</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1010</span> </div>
<div class="line"><span class="lineno"> 1011</span>                <span class="comment"># Definition 11: criterion 2</span></div>
<div class="line"><span class="lineno"> 1012</span>                <span class="keywordflow">if</span> c_end &lt; U_start:</div>
<div class="line"><span class="lineno"> 1013</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1014</span> </div>
<div class="line"><span class="lineno"> 1015</span>                U_clusters.append((c_start, c_end))</div>
<div class="line"><span class="lineno"> 1016</span> </div>
<div class="line"><span class="lineno"> 1017</span>            <span class="comment"># add smaller clusters first.</span></div>
<div class="line"><span class="lineno"> 1018</span>            U_clusters.reverse()</div>
<div class="line"><span class="lineno"> 1019</span>            clusters.extend(U_clusters)</div>
<div class="line"><span class="lineno"> 1020</span> </div>
<div class="line"><span class="lineno"> 1021</span>    <span class="keywordflow">return</span> np.array(clusters)</div>
<div class="line"><span class="lineno"> 1022</span> </div>
<div class="line"><span class="lineno"> 1023</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acc94c07cba78b77a702fc6b8728375eb" name="acc94c07cba78b77a702fc6b8728375eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc94c07cba78b77a702fc6b8728375eb">&#9670;&#160;</a></span>cluster_optics_dbscan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics.cluster_optics_dbscan </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>reachability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>core_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform DBSCAN extraction for an arbitrary epsilon.

Extracting the clusters runs in linear time. Note that this results in
``labels_`` which are close to a :class:`~sklearn.cluster.DBSCAN` with
similar settings and ``eps``, only if ``eps`` is close to ``max_eps``.

Parameters
----------
reachability : array of shape (n_samples,)
    Reachability distances calculated by OPTICS (``reachability_``).

core_distances : array of shape (n_samples,)
    Distances at which points become core (``core_distances_``).

ordering : array of shape (n_samples,)
    OPTICS ordered point indices (``ordering_``).

eps : float
    DBSCAN ``eps`` parameter. Must be set to &lt; ``max_eps``. Results
    will be close to DBSCAN algorithm if ``eps`` and ``max_eps`` are close
    to one another.

Returns
-------
labels_ : array of shape (n_samples,)
    The estimated labels.
</pre> <div class="fragment"><div class="line"><span class="lineno">  652</span><span class="keyword">def </span>cluster_optics_dbscan(*, reachability, core_distances, ordering, eps):</div>
<div class="line"><span class="lineno">  653</span>    <span class="stringliteral">&quot;&quot;&quot;Perform DBSCAN extraction for an arbitrary epsilon.</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    Extracting the clusters runs in linear time. Note that this results in</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    ``labels_`` which are close to a :class:`~sklearn.cluster.DBSCAN` with</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    similar settings and ``eps``, only if ``eps`` is close to ``max_eps``.</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    reachability : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        Reachability distances calculated by OPTICS (``reachability_``).</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    core_distances : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        Distances at which points become core (``core_distances_``).</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    ordering : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">        OPTICS ordered point indices (``ordering_``).</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    eps : float</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        DBSCAN ``eps`` parameter. Must be set to &lt; ``max_eps``. Results</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        will be close to DBSCAN algorithm if ``eps`` and ``max_eps`` are close</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">        to one another.</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    labels_ : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">        The estimated labels.</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  680</span>    n_samples = len(core_distances)</div>
<div class="line"><span class="lineno">  681</span>    labels = np.zeros(n_samples, dtype=int)</div>
<div class="line"><span class="lineno">  682</span> </div>
<div class="line"><span class="lineno">  683</span>    far_reach = reachability &gt; eps</div>
<div class="line"><span class="lineno">  684</span>    near_core = core_distances &lt;= eps</div>
<div class="line"><span class="lineno">  685</span>    labels[ordering] = np.cumsum(far_reach[ordering] &amp; near_core[ordering]) - 1</div>
<div class="line"><span class="lineno">  686</span>    labels[far_reach &amp; ~near_core] = -1</div>
<div class="line"><span class="lineno">  687</span>    <span class="keywordflow">return</span> labels</div>
<div class="line"><span class="lineno">  688</span> </div>
<div class="line"><span class="lineno">  689</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8468854ca94951890b390907bdaaa731" name="a8468854ca94951890b390907bdaaa731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8468854ca94951890b390907bdaaa731">&#9670;&#160;</a></span>cluster_optics_xi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics.cluster_optics_xi </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>reachability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predecessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_cluster_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xi</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predecessor_correction</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Automatically extract clusters according to the Xi-steep method.

Parameters
----------
reachability : ndarray of shape (n_samples,)
    Reachability distances calculated by OPTICS (`reachability_`).

predecessor : ndarray of shape (n_samples,)
    Predecessors calculated by OPTICS.

ordering : ndarray of shape (n_samples,)
    OPTICS ordered point indices (`ordering_`).

min_samples : int &gt; 1 or float between 0 and 1
    The same as the min_samples given to OPTICS. Up and down steep regions
    can't have more then ``min_samples`` consecutive non-steep points.
    Expressed as an absolute number or a fraction of the number of samples
    (rounded to be at least 2).

min_cluster_size : int &gt; 1 or float between 0 and 1, default=None
    Minimum number of samples in an OPTICS cluster, expressed as an
    absolute number or a fraction of the number of samples (rounded to be
    at least 2). If ``None``, the value of ``min_samples`` is used instead.

xi : float between 0 and 1, default=0.05
    Determines the minimum steepness on the reachability plot that
    constitutes a cluster boundary. For example, an upwards point in the
    reachability plot is defined by the ratio from one point to its
    successor being at most 1-xi.

predecessor_correction : bool, default=True
    Correct clusters based on the calculated predecessors.

Returns
-------
labels : ndarray of shape (n_samples,)
    The labels assigned to samples. Points which are not included
    in any cluster are labeled as -1.

clusters : ndarray of shape (n_clusters, 2)
    The list of clusters in the form of ``[start, end]`` in each row, with
    all indices inclusive. The clusters are ordered according to ``(end,
    -start)`` (ascending) so that larger clusters encompassing smaller
    clusters come after such nested smaller clusters. Since ``labels`` does
    not reflect the hierarchy, usually ``len(clusters) &gt;
    np.unique(labels)``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  699</span>):</div>
<div class="line"><span class="lineno">  700</span>    <span class="stringliteral">&quot;&quot;&quot;Automatically extract clusters according to the Xi-steep method.</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    reachability : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">        Reachability distances calculated by OPTICS (`reachability_`).</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    predecessor : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        Predecessors calculated by OPTICS.</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    ordering : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        OPTICS ordered point indices (`ordering_`).</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    min_samples : int &gt; 1 or float between 0 and 1</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        The same as the min_samples given to OPTICS. Up and down steep regions</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">        can&#39;t have more then ``min_samples`` consecutive non-steep points.</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">        Expressed as an absolute number or a fraction of the number of samples</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        (rounded to be at least 2).</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    min_cluster_size : int &gt; 1 or float between 0 and 1, default=None</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">        Minimum number of samples in an OPTICS cluster, expressed as an</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">        absolute number or a fraction of the number of samples (rounded to be</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">        at least 2). If ``None``, the value of ``min_samples`` is used instead.</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    xi : float between 0 and 1, default=0.05</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">        Determines the minimum steepness on the reachability plot that</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">        constitutes a cluster boundary. For example, an upwards point in the</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">        reachability plot is defined by the ratio from one point to its</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        successor being at most 1-xi.</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    predecessor_correction : bool, default=True</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">        Correct clusters based on the calculated predecessors.</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    labels : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        The labels assigned to samples. Points which are not included</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">        in any cluster are labeled as -1.</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    clusters : ndarray of shape (n_clusters, 2)</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        The list of clusters in the form of ``[start, end]`` in each row, with</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">        all indices inclusive. The clusters are ordered according to ``(end,</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">        -start)`` (ascending) so that larger clusters encompassing smaller</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        clusters come after such nested smaller clusters. Since ``labels`` does</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        not reflect the hierarchy, usually ``len(clusters) &gt;</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        np.unique(labels)``.</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  747</span>    n_samples = len(reachability)</div>
<div class="line"><span class="lineno">  748</span>    _validate_size(min_samples, n_samples, <span class="stringliteral">&quot;min_samples&quot;</span>)</div>
<div class="line"><span class="lineno">  749</span>    <span class="keywordflow">if</span> min_samples &lt;= 1:</div>
<div class="line"><span class="lineno">  750</span>        min_samples = max(2, int(min_samples * n_samples))</div>
<div class="line"><span class="lineno">  751</span>    <span class="keywordflow">if</span> min_cluster_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  752</span>        min_cluster_size = min_samples</div>
<div class="line"><span class="lineno">  753</span>    _validate_size(min_cluster_size, n_samples, <span class="stringliteral">&quot;min_cluster_size&quot;</span>)</div>
<div class="line"><span class="lineno">  754</span>    <span class="keywordflow">if</span> min_cluster_size &lt;= 1:</div>
<div class="line"><span class="lineno">  755</span>        min_cluster_size = max(2, int(min_cluster_size * n_samples))</div>
<div class="line"><span class="lineno">  756</span> </div>
<div class="line"><span class="lineno">  757</span>    clusters = _xi_cluster(</div>
<div class="line"><span class="lineno">  758</span>        reachability[ordering],</div>
<div class="line"><span class="lineno">  759</span>        predecessor[ordering],</div>
<div class="line"><span class="lineno">  760</span>        ordering,</div>
<div class="line"><span class="lineno">  761</span>        xi,</div>
<div class="line"><span class="lineno">  762</span>        min_samples,</div>
<div class="line"><span class="lineno">  763</span>        min_cluster_size,</div>
<div class="line"><span class="lineno">  764</span>        predecessor_correction,</div>
<div class="line"><span class="lineno">  765</span>    )</div>
<div class="line"><span class="lineno">  766</span>    labels = _extract_xi_labels(ordering, clusters)</div>
<div class="line"><span class="lineno">  767</span>    <span class="keywordflow">return</span> labels, clusters</div>
<div class="line"><span class="lineno">  768</span> </div>
<div class="line"><span class="lineno">  769</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae463a6ca7d936104ee2b2cdb5c3e23b9" name="ae463a6ca7d936104ee2b2cdb5c3e23b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae463a6ca7d936104ee2b2cdb5c3e23b9">&#9670;&#160;</a></span>compute_optics_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._optics.compute_optics_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>min_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the OPTICS reachability graph.

Read more in the :ref:`User Guide &lt;optics&gt;`.

Parameters
----------
X : ndarray of shape (n_samples, n_features), or \
        (n_samples, n_samples) if metric='precomputed'
    A feature array, or array of distances between samples if
    metric='precomputed'.

min_samples : int &gt; 1 or float between 0 and 1
    The number of samples in a neighborhood for a point to be considered
    as a core point. Expressed as an absolute number or a fraction of the
    number of samples (rounded to be at least 2).

max_eps : float, default=np.inf
    The maximum distance between two samples for one to be considered as
    in the neighborhood of the other. Default value of ``np.inf`` will
    identify clusters across all scales; reducing ``max_eps`` will result
    in shorter run times.

metric : str or callable, default='minkowski'
    Metric to use for distance computation. Any metric from scikit-learn
    or scipy.spatial.distance can be used.

    If metric is a callable function, it is called on each
    pair of instances (rows) and the resulting value recorded. The callable
    should take two arrays as input and return one value indicating the
    distance between them. This works for Scipy's metrics, but is less
    efficient than passing the metric name as a string. If metric is
    "precomputed", X is assumed to be a distance matrix and must be square.

    Valid values for metric are:

    - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
      'manhattan']

    - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
      'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
      'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
      'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
      'yule']

    See the documentation for scipy.spatial.distance for details on these
    metrics.

p : int, default=2
    Parameter for the Minkowski metric from
    :class:`~sklearn.metrics.pairwise_distances`. When p = 1, this is
    equivalent to using manhattan_distance (l1), and euclidean_distance
    (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.

metric_params : dict, default=None
    Additional keyword arguments for the metric function.

algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, default='auto'
    Algorithm used to compute the nearest neighbors:

    - 'ball_tree' will use :class:`BallTree`.
    - 'kd_tree' will use :class:`KDTree`.
    - 'brute' will use a brute-force search.
    - 'auto' will attempt to decide the most appropriate algorithm
      based on the values passed to :meth:`fit` method. (default)

    Note: fitting on sparse input will override the setting of
    this parameter, using brute force.

leaf_size : int, default=30
    Leaf size passed to :class:`BallTree` or :class:`KDTree`. This can
    affect the speed of the construction and query, as well as the memory
    required to store the tree. The optimal value depends on the
    nature of the problem.

n_jobs : int, default=None
    The number of parallel jobs to run for neighbors search.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

Returns
-------
ordering_ : array of shape (n_samples,)
    The cluster ordered list of sample indices.

core_distances_ : array of shape (n_samples,)
    Distance at which each sample becomes a core point, indexed by object
    order. Points which will never be core have a distance of inf. Use
    ``clust.core_distances_[clust.ordering_]`` to access in cluster order.

reachability_ : array of shape (n_samples,)
    Reachability distances per sample, indexed by object order. Use
    ``clust.reachability_[clust.ordering_]`` to access in cluster order.

predecessor_ : array of shape (n_samples,)
    Point that a sample was reached from, indexed by object order.
    Seed points have a predecessor of -1.

References
----------
.. [1] Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel,
   and Jörg Sander. "OPTICS: ordering points to identify the clustering
   structure." ACM SIGMOD Record 28, no. 2 (1999): 49-60.
</pre> <div class="fragment"><div class="line"><span class="lineno">  428</span>):</div>
<div class="line"><span class="lineno">  429</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the OPTICS reachability graph.</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;optics&gt;`.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    X : ndarray of shape (n_samples, n_features), or \</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">            (n_samples, n_samples) if metric=&#39;precomputed&#39;</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">        A feature array, or array of distances between samples if</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        metric=&#39;precomputed&#39;.</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    min_samples : int &gt; 1 or float between 0 and 1</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">        The number of samples in a neighborhood for a point to be considered</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        as a core point. Expressed as an absolute number or a fraction of the</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        number of samples (rounded to be at least 2).</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    max_eps : float, default=np.inf</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        The maximum distance between two samples for one to be considered as</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        in the neighborhood of the other. Default value of ``np.inf`` will</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        identify clusters across all scales; reducing ``max_eps`` will result</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        in shorter run times.</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    metric : str or callable, default=&#39;minkowski&#39;</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        Metric to use for distance computation. Any metric from scikit-learn</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        or scipy.spatial.distance can be used.</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">        If metric is a callable function, it is called on each</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">        pair of instances (rows) and the resulting value recorded. The callable</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">        should take two arrays as input and return one value indicating the</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">        distance between them. This works for Scipy&#39;s metrics, but is less</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        efficient than passing the metric name as a string. If metric is</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        &quot;precomputed&quot;, X is assumed to be a distance matrix and must be square.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        Valid values for metric are:</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        - from scikit-learn: [&#39;cityblock&#39;, &#39;cosine&#39;, &#39;euclidean&#39;, &#39;l1&#39;, &#39;l2&#39;,</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">          &#39;manhattan&#39;]</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        - from scipy.spatial.distance: [&#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;,</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">          &#39;correlation&#39;, &#39;dice&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;kulsinski&#39;,</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">          &#39;mahalanobis&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;,</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">          &#39;seuclidean&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;,</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">          &#39;yule&#39;]</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        See the documentation for scipy.spatial.distance for details on these</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        metrics.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    p : int, default=2</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        Parameter for the Minkowski metric from</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        :class:`~sklearn.metrics.pairwise_distances`. When p = 1, this is</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        equivalent to using manhattan_distance (l1), and euclidean_distance</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    metric_params : dict, default=None</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        Additional keyword arguments for the metric function.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    algorithm : {&#39;auto&#39;, &#39;ball_tree&#39;, &#39;kd_tree&#39;, &#39;brute&#39;}, default=&#39;auto&#39;</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        Algorithm used to compute the nearest neighbors:</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        - &#39;ball_tree&#39; will use :class:`BallTree`.</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        - &#39;kd_tree&#39; will use :class:`KDTree`.</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        - &#39;brute&#39; will use a brute-force search.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        - &#39;auto&#39; will attempt to decide the most appropriate algorithm</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">          based on the values passed to :meth:`fit` method. (default)</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        Note: fitting on sparse input will override the setting of</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">        this parameter, using brute force.</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    leaf_size : int, default=30</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">        Leaf size passed to :class:`BallTree` or :class:`KDTree`. This can</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        affect the speed of the construction and query, as well as the memory</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        required to store the tree. The optimal value depends on the</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        nature of the problem.</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        The number of parallel jobs to run for neighbors search.</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    ordering_ : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        The cluster ordered list of sample indices.</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    core_distances_ : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        Distance at which each sample becomes a core point, indexed by object</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        order. Points which will never be core have a distance of inf. Use</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        ``clust.core_distances_[clust.ordering_]`` to access in cluster order.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    reachability_ : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        Reachability distances per sample, indexed by object order. Use</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        ``clust.reachability_[clust.ordering_]`` to access in cluster order.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    predecessor_ : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        Point that a sample was reached from, indexed by object order.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">        Seed points have a predecessor of -1.</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    .. [1] Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel,</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">       and Jörg Sander. &quot;OPTICS: ordering points to identify the clustering</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">       structure.&quot; ACM SIGMOD Record 28, no. 2 (1999): 49-60.</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  533</span>    n_samples = X.shape[0]</div>
<div class="line"><span class="lineno">  534</span>    _validate_size(min_samples, n_samples, <span class="stringliteral">&quot;min_samples&quot;</span>)</div>
<div class="line"><span class="lineno">  535</span>    <span class="keywordflow">if</span> min_samples &lt;= 1:</div>
<div class="line"><span class="lineno">  536</span>        min_samples = max(2, int(min_samples * n_samples))</div>
<div class="line"><span class="lineno">  537</span> </div>
<div class="line"><span class="lineno">  538</span>    <span class="comment"># Start all points as &#39;unprocessed&#39; ##</span></div>
<div class="line"><span class="lineno">  539</span>    reachability_ = np.empty(n_samples)</div>
<div class="line"><span class="lineno">  540</span>    reachability_.fill(np.inf)</div>
<div class="line"><span class="lineno">  541</span>    predecessor_ = np.empty(n_samples, dtype=int)</div>
<div class="line"><span class="lineno">  542</span>    predecessor_.fill(-1)</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  544</span>    nbrs = NearestNeighbors(</div>
<div class="line"><span class="lineno">  545</span>        n_neighbors=min_samples,</div>
<div class="line"><span class="lineno">  546</span>        algorithm=algorithm,</div>
<div class="line"><span class="lineno">  547</span>        leaf_size=leaf_size,</div>
<div class="line"><span class="lineno">  548</span>        metric=metric,</div>
<div class="line"><span class="lineno">  549</span>        metric_params=metric_params,</div>
<div class="line"><span class="lineno">  550</span>        p=p,</div>
<div class="line"><span class="lineno">  551</span>        n_jobs=n_jobs,</div>
<div class="line"><span class="lineno">  552</span>    )</div>
<div class="line"><span class="lineno">  553</span> </div>
<div class="line"><span class="lineno">  554</span>    nbrs.fit(X)</div>
<div class="line"><span class="lineno">  555</span>    <span class="comment"># Here we first do a kNN query for each point, this differs from</span></div>
<div class="line"><span class="lineno">  556</span>    <span class="comment"># the original OPTICS that only used epsilon range queries.</span></div>
<div class="line"><span class="lineno">  557</span>    <span class="comment"># TODO: handle working_memory somehow?</span></div>
<div class="line"><span class="lineno">  558</span>    core_distances_ = _compute_core_distances_(</div>
<div class="line"><span class="lineno">  559</span>        X=X, neighbors=nbrs, min_samples=min_samples, working_memory=<span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  560</span>    )</div>
<div class="line"><span class="lineno">  561</span>    <span class="comment"># OPTICS puts an upper limit on these, use inf for undefined.</span></div>
<div class="line"><span class="lineno">  562</span>    core_distances_[core_distances_ &gt; max_eps] = np.inf</div>
<div class="line"><span class="lineno">  563</span>    np.around(</div>
<div class="line"><span class="lineno">  564</span>        core_distances_,</div>
<div class="line"><span class="lineno">  565</span>        decimals=np.finfo(core_distances_.dtype).precision,</div>
<div class="line"><span class="lineno">  566</span>        out=core_distances_,</div>
<div class="line"><span class="lineno">  567</span>    )</div>
<div class="line"><span class="lineno">  568</span> </div>
<div class="line"><span class="lineno">  569</span>    <span class="comment"># Main OPTICS loop. Not parallelizable. The order that entries are</span></div>
<div class="line"><span class="lineno">  570</span>    <span class="comment"># written to the &#39;ordering_&#39; list is important!</span></div>
<div class="line"><span class="lineno">  571</span>    <span class="comment"># Note that this implementation is O(n^2) theoretically, but</span></div>
<div class="line"><span class="lineno">  572</span>    <span class="comment"># supposedly with very low constant factors.</span></div>
<div class="line"><span class="lineno">  573</span>    processed = np.zeros(X.shape[0], dtype=bool)</div>
<div class="line"><span class="lineno">  574</span>    ordering = np.zeros(X.shape[0], dtype=int)</div>
<div class="line"><span class="lineno">  575</span>    <span class="keywordflow">for</span> ordering_idx <span class="keywordflow">in</span> range(X.shape[0]):</div>
<div class="line"><span class="lineno">  576</span>        <span class="comment"># Choose next based on smallest reachability distance</span></div>
<div class="line"><span class="lineno">  577</span>        <span class="comment"># (And prefer smaller ids on ties, possibly np.inf!)</span></div>
<div class="line"><span class="lineno">  578</span>        index = np.where(processed == 0)[0]</div>
<div class="line"><span class="lineno">  579</span>        point = index[np.argmin(reachability_[index])]</div>
<div class="line"><span class="lineno">  580</span> </div>
<div class="line"><span class="lineno">  581</span>        processed[point] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  582</span>        ordering[ordering_idx] = point</div>
<div class="line"><span class="lineno">  583</span>        <span class="keywordflow">if</span> core_distances_[point] != np.inf:</div>
<div class="line"><span class="lineno">  584</span>            _set_reach_dist(</div>
<div class="line"><span class="lineno">  585</span>                core_distances_=core_distances_,</div>
<div class="line"><span class="lineno">  586</span>                reachability_=reachability_,</div>
<div class="line"><span class="lineno">  587</span>                predecessor_=predecessor_,</div>
<div class="line"><span class="lineno">  588</span>                point_index=point,</div>
<div class="line"><span class="lineno">  589</span>                processed=processed,</div>
<div class="line"><span class="lineno">  590</span>                X=X,</div>
<div class="line"><span class="lineno">  591</span>                nbrs=nbrs,</div>
<div class="line"><span class="lineno">  592</span>                metric=metric,</div>
<div class="line"><span class="lineno">  593</span>                metric_params=metric_params,</div>
<div class="line"><span class="lineno">  594</span>                p=p,</div>
<div class="line"><span class="lineno">  595</span>                max_eps=max_eps,</div>
<div class="line"><span class="lineno">  596</span>            )</div>
<div class="line"><span class="lineno">  597</span>    <span class="keywordflow">if</span> np.all(np.isinf(reachability_)):</div>
<div class="line"><span class="lineno">  598</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  599</span>            <span class="stringliteral">&quot;All reachability values are inf. Set a larger&quot;</span></div>
<div class="line"><span class="lineno">  600</span>            <span class="stringliteral">&quot; max_eps or all data will be considered outliers.&quot;</span>,</div>
<div class="line"><span class="lineno">  601</span>            UserWarning,</div>
<div class="line"><span class="lineno">  602</span>        )</div>
<div class="line"><span class="lineno">  603</span>    <span class="keywordflow">return</span> ordering, core_distances_, reachability_, predecessor_</div>
<div class="line"><span class="lineno">  604</span> </div>
<div class="line"><span class="lineno">  605</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
