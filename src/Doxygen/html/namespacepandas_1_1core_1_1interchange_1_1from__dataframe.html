<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.interchange.from_dataframe Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1interchange.html">interchange</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html">from_dataframe</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.interchange.from_dataframe Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af4407325f33561b3067fefc890a4f33f" id="r_af4407325f33561b3067fefc890a4f33f"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#af4407325f33561b3067fefc890a4f33f">from_dataframe</a> (<a class="el" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>, allow_copy=True)</td></tr>
<tr class="separator:af4407325f33561b3067fefc890a4f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a45d3361c3a7f65f21d373adfe2c09d" id="r_a8a45d3361c3a7f65f21d373adfe2c09d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a8a45d3361c3a7f65f21d373adfe2c09d">_from_dataframe</a> (DataFrameXchg <a class="el" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>, allow_copy=True)</td></tr>
<tr class="separator:a8a45d3361c3a7f65f21d373adfe2c09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76769d380372bb2f2fe9c80a8ac7863" id="r_ae76769d380372bb2f2fe9c80a8ac7863"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#ae76769d380372bb2f2fe9c80a8ac7863">protocol_df_chunk_to_pandas</a> (DataFrameXchg <a class="el" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>)</td></tr>
<tr class="separator:ae76769d380372bb2f2fe9c80a8ac7863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45abe1c14988c38e1424d26f4d8de481" id="r_a45abe1c14988c38e1424d26f4d8de481"><td class="memItemLeft" align="right" valign="top">tuple[np.ndarray, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a45abe1c14988c38e1424d26f4d8de481">primitive_column_to_ndarray</a> (<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a> col)</td></tr>
<tr class="separator:a45abe1c14988c38e1424d26f4d8de481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b69692a28061b8bd29fa0845c20a95d" id="r_a1b69692a28061b8bd29fa0845c20a95d"><td class="memItemLeft" align="right" valign="top">tuple[pd.Series, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a1b69692a28061b8bd29fa0845c20a95d">categorical_column_to_series</a> (<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a> col)</td></tr>
<tr class="separator:a1b69692a28061b8bd29fa0845c20a95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8850cd8ee012a7a5aae64000c293b2ca" id="r_a8850cd8ee012a7a5aae64000c293b2ca"><td class="memItemLeft" align="right" valign="top">tuple[np.ndarray, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a8850cd8ee012a7a5aae64000c293b2ca">string_column_to_ndarray</a> (<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a> col)</td></tr>
<tr class="separator:a8850cd8ee012a7a5aae64000c293b2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39429a3bb2b031562f8adefbfda7b8ab" id="r_a39429a3bb2b031562f8adefbfda7b8ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a39429a3bb2b031562f8adefbfda7b8ab">parse_datetime_format_str</a> (format_str, data)</td></tr>
<tr class="separator:a39429a3bb2b031562f8adefbfda7b8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d7cd4ec694d6a3920d4fcd1a4c63e8" id="r_a11d7cd4ec694d6a3920d4fcd1a4c63e8"><td class="memItemLeft" align="right" valign="top">tuple[np.ndarray, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a11d7cd4ec694d6a3920d4fcd1a4c63e8">datetime_column_to_ndarray</a> (<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a> col)</td></tr>
<tr class="separator:a11d7cd4ec694d6a3920d4fcd1a4c63e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35f45796b0505f27441c28818da7cd0" id="r_ae35f45796b0505f27441c28818da7cd0"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#ae35f45796b0505f27441c28818da7cd0">buffer_to_ndarray</a> (<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_buffer.html">Buffer</a> buffer, tuple[<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_dtype_kind.html">DtypeKind</a>, int, str, str] dtype, int <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0, int|None length=None)</td></tr>
<tr class="separator:ae35f45796b0505f27441c28818da7cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a83d3838f95bf27239ce2d45cde199a" id="r_a1a83d3838f95bf27239ce2d45cde199a"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a1a83d3838f95bf27239ce2d45cde199a">bitmask_to_bool_ndarray</a> (np.ndarray bitmask, int mask_length, int first_byte_offset=0)</td></tr>
<tr class="separator:a1a83d3838f95bf27239ce2d45cde199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45a2e6a796df3362f561f77bf278609" id="r_af45a2e6a796df3362f561f77bf278609"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#af45a2e6a796df3362f561f77bf278609">set_nulls</a> (np.ndarray|pd.Series data, <a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a> col, tuple[<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_buffer.html">Buffer</a>, tuple[<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_dtype_kind.html">DtypeKind</a>, int, str, str]]|None validity, bool allow_modify_inplace=True)</td></tr>
<tr class="separator:af45a2e6a796df3362f561f77bf278609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9cbe3b2f57c40bc5c970eb513486d7ea" id="r_a9cbe3b2f57c40bc5c970eb513486d7ea"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1interchange_1_1from__dataframe.html#a9cbe3b2f57c40bc5c970eb513486d7ea">_NP_DTYPES</a></td></tr>
<tr class="separator:a9cbe3b2f57c40bc5c970eb513486d7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8a45d3361c3a7f65f21d373adfe2c09d" name="a8a45d3361c3a7f65f21d373adfe2c09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a45d3361c3a7f65f21d373adfe2c09d">&#9670;&#160;</a></span>_from_dataframe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.interchange.from_dataframe._from_dataframe </td>
          <td>(</td>
          <td class="paramtype">DataFrameXchg&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Build a ``pd.DataFrame`` from the DataFrame interchange object.

Parameters
----------
df : DataFrameXchg
    Object supporting the interchange protocol, i.e. `__dataframe__` method.
allow_copy : bool, default: True
    Whether to allow copying the memory to perform the conversion
    (if false then zero-copy approach is requested).

Returns
-------
pd.DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno">   56</span><span class="keyword">def </span>_from_dataframe(df: DataFrameXchg, allow_copy=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">   57</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    Build a ``pd.DataFrame`` from the DataFrame interchange object.</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    df : DataFrameXchg</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">        Object supporting the interchange protocol, i.e. `__dataframe__` method.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    allow_copy : bool, default: True</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        Whether to allow copying the memory to perform the conversion</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        (if false then zero-copy approach is requested).</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    pd.DataFrame</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   72</span>    pandas_dfs = []</div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> df.get_chunks():</div>
<div class="line"><span class="lineno">   74</span>        pandas_df = protocol_df_chunk_to_pandas(chunk)</div>
<div class="line"><span class="lineno">   75</span>        pandas_dfs.append(pandas_df)</div>
<div class="line"><span class="lineno">   76</span> </div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> allow_copy <span class="keywordflow">and</span> len(pandas_dfs) &gt; 1:</div>
<div class="line"><span class="lineno">   78</span>        <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno">   79</span>            <span class="stringliteral">&quot;To join chunks a copy is required which is forbidden by allow_copy=False&quot;</span></div>
<div class="line"><span class="lineno">   80</span>        )</div>
<div class="line"><span class="lineno">   81</span>    <span class="keywordflow">if</span> len(pandas_dfs) == 1:</div>
<div class="line"><span class="lineno">   82</span>        pandas_df = pandas_dfs[0]</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   84</span>        pandas_df = pd.concat(pandas_dfs, axis=0, ignore_index=<span class="keyword">True</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>    index_obj = df.metadata.get(<span class="stringliteral">&quot;pandas.index&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">if</span> index_obj <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   88</span>        pandas_df.index = index_obj</div>
<div class="line"><span class="lineno">   89</span> </div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">return</span> pandas_df</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a83d3838f95bf27239ce2d45cde199a" name="a1a83d3838f95bf27239ce2d45cde199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a83d3838f95bf27239ce2d45cde199a">&#9670;&#160;</a></span>bitmask_to_bool_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.interchange.from_dataframe.bitmask_to_bool_ndarray </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>first_byte_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert bit-mask to a boolean NumPy array.

Parameters
----------
bitmask : np.ndarray[uint8]
    NumPy array of uint8 dtype representing the bitmask.
mask_length : int
    Number of elements in the mask to interpret.
first_byte_offset : int, default: 0
    Number of elements to offset from the start of the first byte.

Returns
-------
np.ndarray[bool]
</pre> <div class="fragment"><div class="line"><span class="lineno">  417</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  418</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    Convert bit-mask to a boolean NumPy array.</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    bitmask : np.ndarray[uint8]</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        NumPy array of uint8 dtype representing the bitmask.</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    mask_length : int</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        Number of elements in the mask to interpret.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    first_byte_offset : int, default: 0</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">        Number of elements to offset from the start of the first byte.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    np.ndarray[bool]</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  434</span>    bytes_to_skip = first_byte_offset // 8</div>
<div class="line"><span class="lineno">  435</span>    bitmask = bitmask[bytes_to_skip:]</div>
<div class="line"><span class="lineno">  436</span>    first_byte_offset %= 8</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span>    bool_mask = np.zeros(mask_length, dtype=bool)</div>
<div class="line"><span class="lineno">  439</span> </div>
<div class="line"><span class="lineno">  440</span>    <span class="comment"># Processing the first byte separately as it has its own offset</span></div>
<div class="line"><span class="lineno">  441</span>    val = bitmask[0]</div>
<div class="line"><span class="lineno">  442</span>    mask_idx = 0</div>
<div class="line"><span class="lineno">  443</span>    bits_in_first_byte = min(8 - first_byte_offset, mask_length)</div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(bits_in_first_byte):</div>
<div class="line"><span class="lineno">  445</span>        <span class="keywordflow">if</span> val &amp; (1 &lt;&lt; (j + first_byte_offset)):</div>
<div class="line"><span class="lineno">  446</span>            bool_mask[mask_idx] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  447</span>        mask_idx += 1</div>
<div class="line"><span class="lineno">  448</span> </div>
<div class="line"><span class="lineno">  449</span>    <span class="comment"># `mask_length // 8` describes how many full bytes to process</span></div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range((mask_length - bits_in_first_byte) // 8):</div>
<div class="line"><span class="lineno">  451</span>        <span class="comment"># doing `+ 1` as we already processed the first byte</span></div>
<div class="line"><span class="lineno">  452</span>        val = bitmask[i + 1]</div>
<div class="line"><span class="lineno">  453</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(8):</div>
<div class="line"><span class="lineno">  454</span>            <span class="keywordflow">if</span> val &amp; (1 &lt;&lt; j):</div>
<div class="line"><span class="lineno">  455</span>                bool_mask[mask_idx] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  456</span>            mask_idx += 1</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>    <span class="keywordflow">if</span> len(bitmask) &gt; 1:</div>
<div class="line"><span class="lineno">  459</span>        <span class="comment"># Processing reminder of last byte</span></div>
<div class="line"><span class="lineno">  460</span>        val = bitmask[-1]</div>
<div class="line"><span class="lineno">  461</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(len(bool_mask) - mask_idx):</div>
<div class="line"><span class="lineno">  462</span>            <span class="keywordflow">if</span> val &amp; (1 &lt;&lt; j):</div>
<div class="line"><span class="lineno">  463</span>                bool_mask[mask_idx] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  464</span>            mask_idx += 1</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">return</span> bool_mask</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae35f45796b0505f27441c28818da7cd0" name="ae35f45796b0505f27441c28818da7cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35f45796b0505f27441c28818da7cd0">&#9670;&#160;</a></span>buffer_to_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.interchange.from_dataframe.buffer_to_ndarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_dtype_kind.html">DtypeKind</a>, int, str, str]&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>length</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a NumPy array from the passed buffer.

Parameters
----------
buffer : Buffer
    Buffer to build a NumPy array from.
dtype : tuple
    Data type of the buffer conforming protocol dtypes format.
offset : int, default: 0
    Number of elements to offset from the start of the buffer.
length : int, optional
    If the buffer is a bit-mask, specifies a number of bits to read
    from the buffer. Has no effect otherwise.

Returns
-------
np.ndarray

Notes
-----
The returned array doesn't own the memory. The caller of this function is
responsible for keeping the memory owner object alive as long as
the returned NumPy array is being used.
</pre> <div class="fragment"><div class="line"><span class="lineno">  365</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  366</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Build a NumPy array from the passed buffer.</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    buffer : Buffer</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">        Buffer to build a NumPy array from.</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    dtype : tuple</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        Data type of the buffer conforming protocol dtypes format.</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    offset : int, default: 0</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        Number of elements to offset from the start of the buffer.</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    length : int, optional</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        If the buffer is a bit-mask, specifies a number of bits to read</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        from the buffer. Has no effect otherwise.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    np.ndarray</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    The returned array doesn&#39;t own the memory. The caller of this function is</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    responsible for keeping the memory owner object alive as long as</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    the returned NumPy array is being used.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  391</span>    kind, bit_width, _, _ = dtype</div>
<div class="line"><span class="lineno">  392</span> </div>
<div class="line"><span class="lineno">  393</span>    column_dtype = _NP_DTYPES.get(kind, {}).get(bit_width, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">if</span> column_dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  395</span>        <span class="keywordflow">raise</span> NotImplementedError(f<span class="stringliteral">&quot;Conversion for {dtype} is not yet supported.&quot;</span>)</div>
<div class="line"><span class="lineno">  396</span> </div>
<div class="line"><span class="lineno">  397</span>    <span class="comment"># TODO: No DLPack yet, so need to construct a new ndarray from the data pointer</span></div>
<div class="line"><span class="lineno">  398</span>    <span class="comment"># and size in the buffer plus the dtype on the column. Use DLPack as NumPy supports</span></div>
<div class="line"><span class="lineno">  399</span>    <span class="comment"># it since https://github.com/numpy/numpy/pull/19083</span></div>
<div class="line"><span class="lineno">  400</span>    ctypes_type = np.ctypeslib.as_ctypes_type(column_dtype)</div>
<div class="line"><span class="lineno">  401</span>    data_pointer = ctypes.cast(</div>
<div class="line"><span class="lineno">  402</span>        buffer.ptr + (offset * bit_width // 8), ctypes.POINTER(ctypes_type)</div>
<div class="line"><span class="lineno">  403</span>    )</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordflow">if</span> bit_width == 1:</div>
<div class="line"><span class="lineno">  406</span>        <span class="keyword">assert</span> length <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>, <span class="stringliteral">&quot;`length` must be specified for a bit-mask buffer.&quot;</span></div>
<div class="line"><span class="lineno">  407</span>        arr = np.ctypeslib.as_array(data_pointer, shape=(buffer.bufsize,))</div>
<div class="line"><span class="lineno">  408</span>        <span class="keywordflow">return</span> bitmask_to_bool_ndarray(arr, length, first_byte_offset=offset % 8)</div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">return</span> np.ctypeslib.as_array(</div>
<div class="line"><span class="lineno">  411</span>            data_pointer, shape=(buffer.bufsize // (bit_width // 8),)</div>
<div class="line"><span class="lineno">  412</span>        )</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b69692a28061b8bd29fa0845c20a95d" name="a1b69692a28061b8bd29fa0845c20a95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b69692a28061b8bd29fa0845c20a95d">&#9670;&#160;</a></span>categorical_column_to_series()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[pd.Series, Any] pandas.core.interchange.from_dataframe.categorical_column_to_series </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a>&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a column holding categorical data to a pandas Series.

Parameters
----------
col : Column

Returns
-------
tuple
    Tuple of pd.Series holding the data and the memory owner object
    that keeps the memory alive.
</pre> <div class="fragment"><div class="line"><span class="lineno">  164</span><span class="keyword">def </span>categorical_column_to_series(col: Column) -&gt; tuple[pd.Series, Any]:</div>
<div class="line"><span class="lineno">  165</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    Convert a column holding categorical data to a pandas Series.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    col : Column</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    tuple</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        Tuple of pd.Series holding the data and the memory owner object</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        that keeps the memory alive.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  178</span>    categorical = col.describe_categorical</div>
<div class="line"><span class="lineno">  179</span> </div>
<div class="line"><span class="lineno">  180</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> categorical[<span class="stringliteral">&quot;is_dictionary&quot;</span>]:</div>
<div class="line"><span class="lineno">  181</span>        <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;Non-dictionary categoricals not supported yet&quot;</span>)</div>
<div class="line"><span class="lineno">  182</span> </div>
<div class="line"><span class="lineno">  183</span>    cat_column = categorical[<span class="stringliteral">&quot;categories&quot;</span>]</div>
<div class="line"><span class="lineno">  184</span>    <span class="comment"># for mypy/pyright</span></div>
<div class="line"><span class="lineno">  185</span>    <span class="keyword">assert</span> isinstance(cat_column, PandasColumn), <span class="stringliteral">&quot;categories must be a PandasColumn&quot;</span></div>
<div class="line"><span class="lineno">  186</span>    categories = np.array(cat_column._col)</div>
<div class="line"><span class="lineno">  187</span>    buffers = col.get_buffers()</div>
<div class="line"><span class="lineno">  188</span> </div>
<div class="line"><span class="lineno">  189</span>    codes_buff, codes_dtype = buffers[<span class="stringliteral">&quot;data&quot;</span>]</div>
<div class="line"><span class="lineno">  190</span>    codes = buffer_to_ndarray(codes_buff, codes_dtype, col.offset, col.size)</div>
<div class="line"><span class="lineno">  191</span> </div>
<div class="line"><span class="lineno">  192</span>    <span class="comment"># Doing module in order to not get ``IndexError`` for</span></div>
<div class="line"><span class="lineno">  193</span>    <span class="comment"># out-of-bounds sentinel values in `codes`</span></div>
<div class="line"><span class="lineno">  194</span>    values = categories[codes % len(categories)]</div>
<div class="line"><span class="lineno">  195</span> </div>
<div class="line"><span class="lineno">  196</span>    cat = pd.Categorical(</div>
<div class="line"><span class="lineno">  197</span>        values, categories=categories, ordered=categorical[<span class="stringliteral">&quot;is_ordered&quot;</span>]</div>
<div class="line"><span class="lineno">  198</span>    )</div>
<div class="line"><span class="lineno">  199</span>    data = pd.Series(cat)</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span>    data = set_nulls(data, col, buffers[<span class="stringliteral">&quot;validity&quot;</span>])</div>
<div class="line"><span class="lineno">  202</span>    <span class="keywordflow">return</span> data, buffers</div>
<div class="line"><span class="lineno">  203</span> </div>
<div class="line"><span class="lineno">  204</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a11d7cd4ec694d6a3920d4fcd1a4c63e8" name="a11d7cd4ec694d6a3920d4fcd1a4c63e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d7cd4ec694d6a3920d4fcd1a4c63e8">&#9670;&#160;</a></span>datetime_column_to_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[np.ndarray, Any] pandas.core.interchange.from_dataframe.datetime_column_to_ndarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a>&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a column holding DateTime data to a NumPy array.

Parameters
----------
col : Column

Returns
-------
tuple
    Tuple of np.ndarray holding the data and the memory owner object
    that keeps the memory alive.
</pre> <div class="fragment"><div class="line"><span class="lineno">  324</span><span class="keyword">def </span>datetime_column_to_ndarray(col: Column) -&gt; tuple[np.ndarray, Any]:</div>
<div class="line"><span class="lineno">  325</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    Convert a column holding DateTime data to a NumPy array.</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    col : Column</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    tuple</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">        Tuple of np.ndarray holding the data and the memory owner object</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        that keeps the memory alive.</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  338</span>    buffers = col.get_buffers()</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>    _, _, format_str, _ = col.dtype</div>
<div class="line"><span class="lineno">  341</span>    dbuf, dtype = buffers[<span class="stringliteral">&quot;data&quot;</span>]</div>
<div class="line"><span class="lineno">  342</span>    <span class="comment"># Consider dtype being `uint` to get number of units passed since the 01.01.1970</span></div>
<div class="line"><span class="lineno">  343</span>    data = buffer_to_ndarray(</div>
<div class="line"><span class="lineno">  344</span>        dbuf,</div>
<div class="line"><span class="lineno">  345</span>        (</div>
<div class="line"><span class="lineno">  346</span>            DtypeKind.UINT,</div>
<div class="line"><span class="lineno">  347</span>            dtype[1],</div>
<div class="line"><span class="lineno">  348</span>            getattr(ArrowCTypes, f<span class="stringliteral">&quot;UINT{dtype[1]}&quot;</span>),</div>
<div class="line"><span class="lineno">  349</span>            Endianness.NATIVE,</div>
<div class="line"><span class="lineno">  350</span>        ),</div>
<div class="line"><span class="lineno">  351</span>        col.offset,</div>
<div class="line"><span class="lineno">  352</span>        col.size,</div>
<div class="line"><span class="lineno">  353</span>    )</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>    data = parse_datetime_format_str(format_str, data)</div>
<div class="line"><span class="lineno">  356</span>    data = set_nulls(data, col, buffers[<span class="stringliteral">&quot;validity&quot;</span>])</div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">return</span> data, buffers</div>
<div class="line"><span class="lineno">  358</span> </div>
<div class="line"><span class="lineno">  359</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af4407325f33561b3067fefc890a4f33f" name="af4407325f33561b3067fefc890a4f33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4407325f33561b3067fefc890a4f33f">&#9670;&#160;</a></span>from_dataframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame pandas.core.interchange.from_dataframe.from_dataframe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a ``pd.DataFrame`` from any DataFrame supporting the interchange protocol.

Parameters
----------
df : DataFrameXchg
    Object supporting the interchange protocol, i.e. `__dataframe__` method.
allow_copy : bool, default: True
    Whether to allow copying the memory to perform the conversion
    (if false then zero-copy approach is requested).

Returns
-------
pd.DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno">   31</span><span class="keyword">def </span>from_dataframe(df, allow_copy=True) -&gt; pd.DataFrame:</div>
<div class="line"><span class="lineno">   32</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    Build a ``pd.DataFrame`` from any DataFrame supporting the interchange protocol.</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    df : DataFrameXchg</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">        Object supporting the interchange protocol, i.e. `__dataframe__` method.</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    allow_copy : bool, default: True</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        Whether to allow copying the memory to perform the conversion</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">        (if false then zero-copy approach is requested).</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    pd.DataFrame</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   47</span>    <span class="keywordflow">if</span> isinstance(df, pd.DataFrame):</div>
<div class="line"><span class="lineno">   48</span>        <span class="keywordflow">return</span> df</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(df, <span class="stringliteral">&quot;__dataframe__&quot;</span>):</div>
<div class="line"><span class="lineno">   51</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`df` does not support __dataframe__&quot;</span>)</div>
<div class="line"><span class="lineno">   52</span> </div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordflow">return</span> _from_dataframe(df.__dataframe__(allow_copy=allow_copy))</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a39429a3bb2b031562f8adefbfda7b8ab" name="a39429a3bb2b031562f8adefbfda7b8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39429a3bb2b031562f8adefbfda7b8ab">&#9670;&#160;</a></span>parse_datetime_format_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.interchange.from_dataframe.parse_datetime_format_str </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse datetime `format_str` to interpret the `data`.</pre> <div class="fragment"><div class="line"><span class="lineno">  291</span><span class="keyword">def </span>parse_datetime_format_str(format_str, data):</div>
<div class="line"><span class="lineno">  292</span>    <span class="stringliteral">&quot;&quot;&quot;Parse datetime `format_str` to interpret the `data`.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  293</span>    <span class="comment"># timestamp &#39;ts{unit}:tz&#39;</span></div>
<div class="line"><span class="lineno">  294</span>    timestamp_meta = re.match(<span class="stringliteral">r&quot;ts([smun]):(.*)&quot;</span>, format_str)</div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">if</span> timestamp_meta:</div>
<div class="line"><span class="lineno">  296</span>        unit, tz = timestamp_meta.group(1), timestamp_meta.group(2)</div>
<div class="line"><span class="lineno">  297</span>        <span class="keywordflow">if</span> tz != <span class="stringliteral">&quot;&quot;</span>:</div>
<div class="line"><span class="lineno">  298</span>            <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;Timezones are not supported yet&quot;</span>)</div>
<div class="line"><span class="lineno">  299</span>        <span class="keywordflow">if</span> unit != <span class="stringliteral">&quot;s&quot;</span>:</div>
<div class="line"><span class="lineno">  300</span>            <span class="comment"># the format string describes only a first letter of the unit, so</span></div>
<div class="line"><span class="lineno">  301</span>            <span class="comment"># add one extra letter to convert the unit to numpy-style:</span></div>
<div class="line"><span class="lineno">  302</span>            <span class="comment"># &#39;m&#39; -&gt; &#39;ms&#39;, &#39;u&#39; -&gt; &#39;us&#39;, &#39;n&#39; -&gt; &#39;ns&#39;</span></div>
<div class="line"><span class="lineno">  303</span>            unit += <span class="stringliteral">&quot;s&quot;</span></div>
<div class="line"><span class="lineno">  304</span>        data = data.astype(f<span class="stringliteral">&quot;datetime64[{unit}]&quot;</span>)</div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordflow">return</span> data</div>
<div class="line"><span class="lineno">  306</span> </div>
<div class="line"><span class="lineno">  307</span>    <span class="comment"># date &#39;td{Days/Ms}&#39;</span></div>
<div class="line"><span class="lineno">  308</span>    date_meta = re.match(<span class="stringliteral">r&quot;td([Dm])&quot;</span>, format_str)</div>
<div class="line"><span class="lineno">  309</span>    <span class="keywordflow">if</span> date_meta:</div>
<div class="line"><span class="lineno">  310</span>        unit = date_meta.group(1)</div>
<div class="line"><span class="lineno">  311</span>        <span class="keywordflow">if</span> unit == <span class="stringliteral">&quot;D&quot;</span>:</div>
<div class="line"><span class="lineno">  312</span>            <span class="comment"># NumPy doesn&#39;t support DAY unit, so converting days to seconds</span></div>
<div class="line"><span class="lineno">  313</span>            <span class="comment"># (converting to uint64 to avoid overflow)</span></div>
<div class="line"><span class="lineno">  314</span>            data = (data.astype(np.uint64) * (24 * 60 * 60)).astype(<span class="stringliteral">&quot;datetime64[s]&quot;</span>)</div>
<div class="line"><span class="lineno">  315</span>        <span class="keywordflow">elif</span> unit == <span class="stringliteral">&quot;m&quot;</span>:</div>
<div class="line"><span class="lineno">  316</span>            data = data.astype(<span class="stringliteral">&quot;datetime64[ms]&quot;</span>)</div>
<div class="line"><span class="lineno">  317</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  318</span>            <span class="keywordflow">raise</span> NotImplementedError(f<span class="stringliteral">&quot;Date unit is not supported: {unit}&quot;</span>)</div>
<div class="line"><span class="lineno">  319</span>        <span class="keywordflow">return</span> data</div>
<div class="line"><span class="lineno">  320</span> </div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">raise</span> NotImplementedError(f<span class="stringliteral">&quot;DateTime kind is not supported: {format_str}&quot;</span>)</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a45abe1c14988c38e1424d26f4d8de481" name="a45abe1c14988c38e1424d26f4d8de481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45abe1c14988c38e1424d26f4d8de481">&#9670;&#160;</a></span>primitive_column_to_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[np.ndarray, Any] pandas.core.interchange.from_dataframe.primitive_column_to_ndarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a>&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a column holding one of the primitive dtypes to a NumPy array.

A primitive type is one of: int, uint, float, bool.

Parameters
----------
col : Column

Returns
-------
tuple
    Tuple of np.ndarray holding the data and the memory owner object
    that keeps the memory alive.
</pre> <div class="fragment"><div class="line"><span class="lineno">  139</span><span class="keyword">def </span>primitive_column_to_ndarray(col: Column) -&gt; tuple[np.ndarray, Any]:</div>
<div class="line"><span class="lineno">  140</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    Convert a column holding one of the primitive dtypes to a NumPy array.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    A primitive type is one of: int, uint, float, bool.</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    col : Column</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    tuple</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        Tuple of np.ndarray holding the data and the memory owner object</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        that keeps the memory alive.</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  155</span>    buffers = col.get_buffers()</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>    data_buff, data_dtype = buffers[<span class="stringliteral">&quot;data&quot;</span>]</div>
<div class="line"><span class="lineno">  158</span>    data = buffer_to_ndarray(data_buff, data_dtype, col.offset, col.size)</div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>    data = set_nulls(data, col, buffers[<span class="stringliteral">&quot;validity&quot;</span>])</div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">return</span> data, buffers</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae76769d380372bb2f2fe9c80a8ac7863" name="ae76769d380372bb2f2fe9c80a8ac7863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76769d380372bb2f2fe9c80a8ac7863">&#9670;&#160;</a></span>protocol_df_chunk_to_pandas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame pandas.core.interchange.from_dataframe.protocol_df_chunk_to_pandas </td>
          <td>(</td>
          <td class="paramtype">DataFrameXchg&#160;</td>
          <td class="paramname"><em>df</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert interchange protocol chunk to ``pd.DataFrame``.

Parameters
----------
df : DataFrameXchg

Returns
-------
pd.DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno">   93</span><span class="keyword">def </span>protocol_df_chunk_to_pandas(df: DataFrameXchg) -&gt; pd.DataFrame:</div>
<div class="line"><span class="lineno">   94</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    Convert interchange protocol chunk to ``pd.DataFrame``.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    df : DataFrameXchg</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    pd.DataFrame</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  105</span>    <span class="comment"># We need a dict of columns here, with each column being a NumPy array (at</span></div>
<div class="line"><span class="lineno">  106</span>    <span class="comment"># least for now, deal with non-NumPy dtypes later).</span></div>
<div class="line"><span class="lineno">  107</span>    columns: dict[str, Any] = {}</div>
<div class="line"><span class="lineno">  108</span>    buffers = []  <span class="comment"># hold on to buffers, keeps memory alive</span></div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> df.column_names():</div>
<div class="line"><span class="lineno">  110</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(name, str):</div>
<div class="line"><span class="lineno">  111</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Column {name} is not a string&quot;</span>)</div>
<div class="line"><span class="lineno">  112</span>        <span class="keywordflow">if</span> name <span class="keywordflow">in</span> columns:</div>
<div class="line"><span class="lineno">  113</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Column {name} is not unique&quot;</span>)</div>
<div class="line"><span class="lineno">  114</span>        col = df.get_column_by_name(name)</div>
<div class="line"><span class="lineno">  115</span>        dtype = col.dtype[0]</div>
<div class="line"><span class="lineno">  116</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">in</span> (</div>
<div class="line"><span class="lineno">  117</span>            DtypeKind.INT,</div>
<div class="line"><span class="lineno">  118</span>            DtypeKind.UINT,</div>
<div class="line"><span class="lineno">  119</span>            DtypeKind.FLOAT,</div>
<div class="line"><span class="lineno">  120</span>            DtypeKind.BOOL,</div>
<div class="line"><span class="lineno">  121</span>        ):</div>
<div class="line"><span class="lineno">  122</span>            columns[name], buf = primitive_column_to_ndarray(col)</div>
<div class="line"><span class="lineno">  123</span>        <span class="keywordflow">elif</span> dtype == DtypeKind.CATEGORICAL:</div>
<div class="line"><span class="lineno">  124</span>            columns[name], buf = categorical_column_to_series(col)</div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">elif</span> dtype == DtypeKind.STRING:</div>
<div class="line"><span class="lineno">  126</span>            columns[name], buf = string_column_to_ndarray(col)</div>
<div class="line"><span class="lineno">  127</span>        <span class="keywordflow">elif</span> dtype == DtypeKind.DATETIME:</div>
<div class="line"><span class="lineno">  128</span>            columns[name], buf = datetime_column_to_ndarray(col)</div>
<div class="line"><span class="lineno">  129</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  130</span>            <span class="keywordflow">raise</span> NotImplementedError(f<span class="stringliteral">&quot;Data type {dtype} not handled yet&quot;</span>)</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>        buffers.append(buf)</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>    pandas_df = pd.DataFrame(columns)</div>
<div class="line"><span class="lineno">  135</span>    pandas_df.attrs[<span class="stringliteral">&quot;_INTERCHANGE_PROTOCOL_BUFFERS&quot;</span>] = buffers</div>
<div class="line"><span class="lineno">  136</span>    <span class="keywordflow">return</span> pandas_df</div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af45a2e6a796df3362f561f77bf278609" name="af45a2e6a796df3362f561f77bf278609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45a2e6a796df3362f561f77bf278609">&#9670;&#160;</a></span>set_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.interchange.from_dataframe.set_nulls </td>
          <td>(</td>
          <td class="paramtype">np.ndarray | pd.Series&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a>&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_buffer.html">Buffer</a>, tuple[<a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_dtype_kind.html">DtypeKind</a>, int, str, str]] | None&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>allow_modify_inplace</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set null values for the data according to the column null kind.

Parameters
----------
data : np.ndarray or pd.Series
    Data to set nulls in.
col : Column
    Column object that describes the `data`.
validity : tuple(Buffer, dtype) or None
    The return value of ``col.buffers()``. We do not access the ``col.buffers()``
    here to not take the ownership of the memory of buffer objects.
allow_modify_inplace : bool, default: True
    Whether to modify the `data` inplace when zero-copy is possible (True) or always
    modify a copy of the `data` (False).

Returns
-------
np.ndarray or pd.Series
    Data with the nulls being set.
</pre> <div class="fragment"><div class="line"><span class="lineno">  474</span>):</div>
<div class="line"><span class="lineno">  475</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    Set null values for the data according to the column null kind.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    data : np.ndarray or pd.Series</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        Data to set nulls in.</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    col : Column</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        Column object that describes the `data`.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    validity : tuple(Buffer, dtype) or None</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        The return value of ``col.buffers()``. We do not access the ``col.buffers()``</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        here to not take the ownership of the memory of buffer objects.</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    allow_modify_inplace : bool, default: True</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        Whether to modify the `data` inplace when zero-copy is possible (True) or always</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        modify a copy of the `data` (False).</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    np.ndarray or pd.Series</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        Data with the nulls being set.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  496</span>    null_kind, sentinel_val = col.describe_null</div>
<div class="line"><span class="lineno">  497</span>    null_pos = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  498</span> </div>
<div class="line"><span class="lineno">  499</span>    <span class="keywordflow">if</span> null_kind == ColumnNullType.USE_SENTINEL:</div>
<div class="line"><span class="lineno">  500</span>        null_pos = pd.Series(data) == sentinel_val</div>
<div class="line"><span class="lineno">  501</span>    <span class="keywordflow">elif</span> null_kind <span class="keywordflow">in</span> (ColumnNullType.USE_BITMASK, ColumnNullType.USE_BYTEMASK):</div>
<div class="line"><span class="lineno">  502</span>        <span class="keyword">assert</span> validity, <span class="stringliteral">&quot;Expected to have a validity buffer for the mask&quot;</span></div>
<div class="line"><span class="lineno">  503</span>        valid_buff, valid_dtype = validity</div>
<div class="line"><span class="lineno">  504</span>        null_pos = buffer_to_ndarray(valid_buff, valid_dtype, col.offset, col.size)</div>
<div class="line"><span class="lineno">  505</span>        <span class="keywordflow">if</span> sentinel_val == 0:</div>
<div class="line"><span class="lineno">  506</span>            null_pos = ~null_pos</div>
<div class="line"><span class="lineno">  507</span>    <span class="keywordflow">elif</span> null_kind <span class="keywordflow">in</span> (ColumnNullType.NON_NULLABLE, ColumnNullType.USE_NAN):</div>
<div class="line"><span class="lineno">  508</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  509</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  510</span>        <span class="keywordflow">raise</span> NotImplementedError(f<span class="stringliteral">&quot;Null kind {null_kind} is not yet supported.&quot;</span>)</div>
<div class="line"><span class="lineno">  511</span> </div>
<div class="line"><span class="lineno">  512</span>    <span class="keywordflow">if</span> null_pos <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> np.any(null_pos):</div>
<div class="line"><span class="lineno">  513</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> allow_modify_inplace:</div>
<div class="line"><span class="lineno">  514</span>            data = data.copy()</div>
<div class="line"><span class="lineno">  515</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  516</span>            data[null_pos] = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  517</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  518</span>            <span class="comment"># TypeError happens if the `data` dtype appears to be non-nullable</span></div>
<div class="line"><span class="lineno">  519</span>            <span class="comment"># in numpy notation (bool, int, uint). If this happens,</span></div>
<div class="line"><span class="lineno">  520</span>            <span class="comment"># cast the `data` to nullable float dtype.</span></div>
<div class="line"><span class="lineno">  521</span>            data = data.astype(float)</div>
<div class="line"><span class="lineno">  522</span>            data[null_pos] = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  523</span> </div>
<div class="line"><span class="lineno">  524</span>    <span class="keywordflow">return</span> data</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8850cd8ee012a7a5aae64000c293b2ca" name="a8850cd8ee012a7a5aae64000c293b2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8850cd8ee012a7a5aae64000c293b2ca">&#9670;&#160;</a></span>string_column_to_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[np.ndarray, Any] pandas.core.interchange.from_dataframe.string_column_to_ndarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1interchange_1_1dataframe__protocol_1_1_column.html">Column</a>&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a column holding string data to a NumPy array.

Parameters
----------
col : Column

Returns
-------
tuple
    Tuple of np.ndarray holding the data and the memory owner object
    that keeps the memory alive.
</pre> <div class="fragment"><div class="line"><span class="lineno">  205</span><span class="keyword">def </span>string_column_to_ndarray(col: Column) -&gt; tuple[np.ndarray, Any]:</div>
<div class="line"><span class="lineno">  206</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    Convert a column holding string data to a NumPy array.</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    col : Column</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    tuple</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        Tuple of np.ndarray holding the data and the memory owner object</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        that keeps the memory alive.</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  219</span>    null_kind, sentinel_val = col.describe_null</div>
<div class="line"><span class="lineno">  220</span> </div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">if</span> null_kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> (</div>
<div class="line"><span class="lineno">  222</span>        ColumnNullType.NON_NULLABLE,</div>
<div class="line"><span class="lineno">  223</span>        ColumnNullType.USE_BITMASK,</div>
<div class="line"><span class="lineno">  224</span>        ColumnNullType.USE_BYTEMASK,</div>
<div class="line"><span class="lineno">  225</span>    ):</div>
<div class="line"><span class="lineno">  226</span>        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno">  227</span>            f<span class="stringliteral">&quot;{null_kind} null kind is not yet supported for string columns.&quot;</span></div>
<div class="line"><span class="lineno">  228</span>        )</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>    buffers = col.get_buffers()</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>    <span class="keyword">assert</span> buffers[<span class="stringliteral">&quot;offsets&quot;</span>], <span class="stringliteral">&quot;String buffers must contain offsets&quot;</span></div>
<div class="line"><span class="lineno">  233</span>    <span class="comment"># Retrieve the data buffer containing the UTF-8 code units</span></div>
<div class="line"><span class="lineno">  234</span>    data_buff, protocol_data_dtype = buffers[<span class="stringliteral">&quot;data&quot;</span>]</div>
<div class="line"><span class="lineno">  235</span>    <span class="comment"># We&#39;re going to reinterpret the buffer as uint8, so make sure we can do it safely</span></div>
<div class="line"><span class="lineno">  236</span>    <span class="keyword">assert</span> protocol_data_dtype[1] == 8  <span class="comment"># bitwidth == 8</span></div>
<div class="line"><span class="lineno">  237</span>    <span class="keyword">assert</span> protocol_data_dtype[2] == ArrowCTypes.STRING  <span class="comment"># format_str == utf-8</span></div>
<div class="line"><span class="lineno">  238</span>    <span class="comment"># Convert the buffers to NumPy arrays. In order to go from STRING to</span></div>
<div class="line"><span class="lineno">  239</span>    <span class="comment"># an equivalent ndarray, we claim that the buffer is uint8 (i.e., a byte array)</span></div>
<div class="line"><span class="lineno">  240</span>    data_dtype = (</div>
<div class="line"><span class="lineno">  241</span>        DtypeKind.UINT,</div>
<div class="line"><span class="lineno">  242</span>        8,</div>
<div class="line"><span class="lineno">  243</span>        ArrowCTypes.UINT8,</div>
<div class="line"><span class="lineno">  244</span>        Endianness.NATIVE,</div>
<div class="line"><span class="lineno">  245</span>    )</div>
<div class="line"><span class="lineno">  246</span>    <span class="comment"># Specify zero offset as we don&#39;t want to chunk the string data</span></div>
<div class="line"><span class="lineno">  247</span>    data = buffer_to_ndarray(data_buff, data_dtype, offset=0, length=col.size)</div>
<div class="line"><span class="lineno">  248</span> </div>
<div class="line"><span class="lineno">  249</span>    <span class="comment"># Retrieve the offsets buffer containing the index offsets demarcating</span></div>
<div class="line"><span class="lineno">  250</span>    <span class="comment"># the beginning and the ending of each string</span></div>
<div class="line"><span class="lineno">  251</span>    offset_buff, offset_dtype = buffers[<span class="stringliteral">&quot;offsets&quot;</span>]</div>
<div class="line"><span class="lineno">  252</span>    <span class="comment"># Offsets buffer contains start-stop positions of strings in the data buffer,</span></div>
<div class="line"><span class="lineno">  253</span>    <span class="comment"># meaning that it has more elements than in the data buffer, do `col.size + 1` here</span></div>
<div class="line"><span class="lineno">  254</span>    <span class="comment"># to pass a proper offsets buffer size</span></div>
<div class="line"><span class="lineno">  255</span>    offsets = buffer_to_ndarray(</div>
<div class="line"><span class="lineno">  256</span>        offset_buff, offset_dtype, col.offset, length=col.size + 1</div>
<div class="line"><span class="lineno">  257</span>    )</div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>    null_pos = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  260</span>    <span class="keywordflow">if</span> null_kind <span class="keywordflow">in</span> (ColumnNullType.USE_BITMASK, ColumnNullType.USE_BYTEMASK):</div>
<div class="line"><span class="lineno">  261</span>        <span class="keyword">assert</span> buffers[<span class="stringliteral">&quot;validity&quot;</span>], <span class="stringliteral">&quot;Validity buffers cannot be empty for masks&quot;</span></div>
<div class="line"><span class="lineno">  262</span>        valid_buff, valid_dtype = buffers[<span class="stringliteral">&quot;validity&quot;</span>]</div>
<div class="line"><span class="lineno">  263</span>        null_pos = buffer_to_ndarray(valid_buff, valid_dtype, col.offset, col.size)</div>
<div class="line"><span class="lineno">  264</span>        <span class="keywordflow">if</span> sentinel_val == 0:</div>
<div class="line"><span class="lineno">  265</span>            null_pos = ~null_pos</div>
<div class="line"><span class="lineno">  266</span> </div>
<div class="line"><span class="lineno">  267</span>    <span class="comment"># Assemble the strings from the code units</span></div>
<div class="line"><span class="lineno">  268</span>    str_list: list[<span class="keywordtype">None</span> | float | str] = [<span class="keywordtype">None</span>] * col.size</div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(col.size):</div>
<div class="line"><span class="lineno">  270</span>        <span class="comment"># Check for missing values</span></div>
<div class="line"><span class="lineno">  271</span>        <span class="keywordflow">if</span> null_pos <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> null_pos[i]:</div>
<div class="line"><span class="lineno">  272</span>            str_list[i] = np.nan</div>
<div class="line"><span class="lineno">  273</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  274</span> </div>
<div class="line"><span class="lineno">  275</span>        <span class="comment"># Extract a range of code units</span></div>
<div class="line"><span class="lineno">  276</span>        units = data[offsets[i] : offsets[i + 1]]</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>        <span class="comment"># Convert the list of code units to bytes</span></div>
<div class="line"><span class="lineno">  279</span>        str_bytes = bytes(units)</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>        <span class="comment"># Create the string</span></div>
<div class="line"><span class="lineno">  282</span>        string = str_bytes.decode(encoding=<span class="stringliteral">&quot;utf-8&quot;</span>)</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>        <span class="comment"># Add to our list of strings</span></div>
<div class="line"><span class="lineno">  285</span>        str_list[i] = string</div>
<div class="line"><span class="lineno">  286</span> </div>
<div class="line"><span class="lineno">  287</span>    <span class="comment"># Convert the string list to a NumPy array</span></div>
<div class="line"><span class="lineno">  288</span>    <span class="keywordflow">return</span> np.asarray(str_list, dtype=<span class="stringliteral">&quot;object&quot;</span>), buffers</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9cbe3b2f57c40bc5c970eb513486d7ea" name="a9cbe3b2f57c40bc5c970eb513486d7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbe3b2f57c40bc5c970eb513486d7ea">&#9670;&#160;</a></span>_NP_DTYPES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.interchange.from_dataframe._NP_DTYPES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    DtypeKind.INT: {8: np.int8, 16: np.int16, 32: np.int32, 64: np.int64},</div>
<div class="line"><span class="lineno">    3</span>    DtypeKind.UINT: {8: np.uint8, 16: np.uint16, 32: np.uint32, 64: np.uint64},</div>
<div class="line"><span class="lineno">    4</span>    DtypeKind.FLOAT: {32: np.float32, 64: np.float64},</div>
<div class="line"><span class="lineno">    5</span>    DtypeKind.BOOL: {8: bool},</div>
<div class="line"><span class="lineno">    6</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
