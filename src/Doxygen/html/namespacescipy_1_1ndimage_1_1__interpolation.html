<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.ndimage._interpolation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1ndimage.html">ndimage</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html">_interpolation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.ndimage._interpolation Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4633643f50ca2ab60dac0c772aa04f4b" id="r_a4633643f50ca2ab60dac0c772aa04f4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#a4633643f50ca2ab60dac0c772aa04f4b">spline_filter1d</a> (input, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, axis=-1, output=numpy.float64, mode='mirror')</td></tr>
<tr class="separator:a4633643f50ca2ab60dac0c772aa04f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12262008d7d2f963421cd92c9c015be0" id="r_a12262008d7d2f963421cd92c9c015be0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#a12262008d7d2f963421cd92c9c015be0">spline_filter</a> (input, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, output=numpy.float64, mode='mirror')</td></tr>
<tr class="separator:a12262008d7d2f963421cd92c9c015be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9118108328fb08d8fd900a524565e623" id="r_a9118108328fb08d8fd900a524565e623"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#a9118108328fb08d8fd900a524565e623">_prepad_for_spline_filter</a> (input, mode, cval)</td></tr>
<tr class="separator:a9118108328fb08d8fd900a524565e623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaf1ed27b34a877be24672a8009625e" id="r_afbaf1ed27b34a877be24672a8009625e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#afbaf1ed27b34a877be24672a8009625e">geometric_transform</a> (input, mapping, output_shape=None, output=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, mode='constant', cval=0.0, prefilter=True, extra_arguments=(), extra_keywords={})</td></tr>
<tr class="separator:afbaf1ed27b34a877be24672a8009625e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6f1bbee32816e75c58eb421c4c3160" id="r_aff6f1bbee32816e75c58eb421c4c3160"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#aff6f1bbee32816e75c58eb421c4c3160">map_coordinates</a> (input, coordinates, output=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, mode='constant', cval=0.0, prefilter=True)</td></tr>
<tr class="separator:aff6f1bbee32816e75c58eb421c4c3160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd95335ac6c151c9ec784c413edb6401" id="r_abd95335ac6c151c9ec784c413edb6401"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#abd95335ac6c151c9ec784c413edb6401">affine_transform</a> (input, matrix, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0.0, output_shape=None, output=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, mode='constant', cval=0.0, prefilter=True)</td></tr>
<tr class="separator:abd95335ac6c151c9ec784c413edb6401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6141e26d9a9aa095a6c8b0168fd552fa" id="r_a6141e26d9a9aa095a6c8b0168fd552fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#a6141e26d9a9aa095a6c8b0168fd552fa">shift</a> (input, shift, output=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, mode='constant', cval=0.0, prefilter=True)</td></tr>
<tr class="separator:a6141e26d9a9aa095a6c8b0168fd552fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e4074970ef924fb8a356fc60af1a60" id="r_aa1e4074970ef924fb8a356fc60af1a60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#aa1e4074970ef924fb8a356fc60af1a60">zoom</a> (input, zoom, output=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, mode='constant', cval=0.0, prefilter=True, *grid_mode=False)</td></tr>
<tr class="separator:aa1e4074970ef924fb8a356fc60af1a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf9560fc833b87edb39fba44a603172" id="r_a6bf9560fc833b87edb39fba44a603172"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1__interpolation.html#a6bf9560fc833b87edb39fba44a603172">rotate</a> (input, angle, axes=(1, 0), reshape=True, output=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=3, mode='constant', cval=0.0, prefilter=True)</td></tr>
<tr class="separator:a6bf9560fc833b87edb39fba44a603172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9118108328fb08d8fd900a524565e623" name="a9118108328fb08d8fd900a524565e623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9118108328fb08d8fd900a524565e623">&#9670;&#160;</a></span>_prepad_for_spline_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation._prepad_for_spline_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  196</span><span class="keyword">def </span>_prepad_for_spline_filter(input, mode, cval):</div>
<div class="line"><span class="lineno">  197</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">in</span> [<span class="stringliteral">&#39;nearest&#39;</span>, <span class="stringliteral">&#39;grid-constant&#39;</span>]:</div>
<div class="line"><span class="lineno">  198</span>        npad = 12</div>
<div class="line"><span class="lineno">  199</span>        <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;grid-constant&#39;</span>:</div>
<div class="line"><span class="lineno">  200</span>            padded = numpy.pad(input, npad, mode=<span class="stringliteral">&#39;constant&#39;</span>,</div>
<div class="line"><span class="lineno">  201</span>                               constant_values=cval)</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">elif</span> mode == <span class="stringliteral">&#39;nearest&#39;</span>:</div>
<div class="line"><span class="lineno">  203</span>            padded = numpy.pad(input, npad, mode=<span class="stringliteral">&#39;edge&#39;</span>)</div>
<div class="line"><span class="lineno">  204</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  205</span>        <span class="comment"># other modes have exact boundary conditions implemented so</span></div>
<div class="line"><span class="lineno">  206</span>        <span class="comment"># no prepadding is needed</span></div>
<div class="line"><span class="lineno">  207</span>        npad = 0</div>
<div class="line"><span class="lineno">  208</span>        padded = input</div>
<div class="line"><span class="lineno">  209</span>    <span class="keywordflow">return</span> padded, npad</div>
<div class="line"><span class="lineno">  210</span> </div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span><span class="preprocessor">@docfiller</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abd95335ac6c151c9ec784c413edb6401" name="abd95335ac6c151c9ec784c413edb6401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd95335ac6c151c9ec784c413edb6401">&#9670;&#160;</a></span>affine_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.affine_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_shape</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefilter</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply an affine transformation.

Given an output image pixel index vector ``o``, the pixel value
is determined from the input image at position
``np.dot(matrix, o) + offset``.

This does 'pull' (or 'backward') resampling, transforming the output space
to the input to locate data. Affine transformations are often described in
the 'push' (or 'forward') direction, transforming input to output. If you
have a matrix for the 'push' transformation, use its inverse
(:func:`numpy.linalg.inv`) in this function.

Parameters
----------
%(input)s
matrix : ndarray
    The inverse coordinate transformation matrix, mapping output
    coordinates to input coordinates. If ``ndim`` is the number of
    dimensions of ``input``, the given matrix must have one of the
    following shapes:

        - ``(ndim, ndim)``: the linear transformation matrix for each
          output coordinate.
        - ``(ndim,)``: assume that the 2-D transformation matrix is
          diagonal, with the diagonal specified by the given value. A more
          efficient algorithm is then used that exploits the separability
          of the problem.
        - ``(ndim + 1, ndim + 1)``: assume that the transformation is
          specified using homogeneous coordinates [1]_. In this case, any
          value passed to ``offset`` is ignored.
        - ``(ndim, ndim + 1)``: as above, but the bottom row of a
          homogeneous transformation matrix is always ``[0, 0, ..., 1]``,
          and may be omitted.

offset : float or sequence, optional
    The offset into the array where the transform is applied. If a float,
    `offset` is the same for each axis. If a sequence, `offset` should
    contain one value for each axis.
output_shape : tuple of ints, optional
    Shape tuple.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
affine_transform : ndarray
    The transformed input.

Notes
-----
The given matrix and offset are used to find for each point in the
output the corresponding coordinates in the input by an affine
transformation. The value of the input at those coordinates is
determined by spline interpolation of the requested order. Points
outside the boundaries of the input are filled according to the given
mode.

.. versionchanged:: 0.18.0
    Previously, the exact interpretation of the affine transformation
    depended on whether the matrix was supplied as a 1-D or a
    2-D array. If a 1-D array was supplied
    to the matrix parameter, the output pixel value at index ``o``
    was determined from the input image at position
    ``matrix * (o + offset)``.

For complex-valued `input`, this function transforms the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

References
----------
.. [1] https://en.wikipedia.org/wiki/Homogeneous_coordinates
</pre> <div class="fragment"><div class="line"><span class="lineno">  464</span>                     mode=<span class="stringliteral">&#39;constant&#39;</span>, cval=0.0, prefilter=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  465</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    Apply an affine transformation.</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    Given an output image pixel index vector ``o``, the pixel value</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    is determined from the input image at position</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    ``np.dot(matrix, o) + offset``.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    This does &#39;pull&#39; (or &#39;backward&#39;) resampling, transforming the output space</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    to the input to locate data. Affine transformations are often described in</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    the &#39;push&#39; (or &#39;forward&#39;) direction, transforming input to output. If you</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    have a matrix for the &#39;push&#39; transformation, use its inverse</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    (:func:`numpy.linalg.inv`) in this function.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    %(input)s</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    matrix : ndarray</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        The inverse coordinate transformation matrix, mapping output</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        coordinates to input coordinates. If ``ndim`` is the number of</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        dimensions of ``input``, the given matrix must have one of the</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        following shapes:</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">            - ``(ndim, ndim)``: the linear transformation matrix for each</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">              output coordinate.</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">            - ``(ndim,)``: assume that the 2-D transformation matrix is</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">              diagonal, with the diagonal specified by the given value. A more</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">              efficient algorithm is then used that exploits the separability</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">              of the problem.</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">            - ``(ndim + 1, ndim + 1)``: assume that the transformation is</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">              specified using homogeneous coordinates [1]_. In this case, any</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">              value passed to ``offset`` is ignored.</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">            - ``(ndim, ndim + 1)``: as above, but the bottom row of a</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">              homogeneous transformation matrix is always ``[0, 0, ..., 1]``,</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">              and may be omitted.</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    offset : float or sequence, optional</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        The offset into the array where the transform is applied. If a float,</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        `offset` is the same for each axis. If a sequence, `offset` should</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        contain one value for each axis.</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    output_shape : tuple of ints, optional</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        Shape tuple.</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    %(output)s</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        The order of the spline interpolation, default is 3.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        The order has to be in the range 0-5.</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    %(mode_interp_constant)s</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    %(cval)s</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    %(prefilter)s</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    affine_transform : ndarray</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        The transformed input.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    The given matrix and offset are used to find for each point in the</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    output the corresponding coordinates in the input by an affine</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    transformation. The value of the input at those coordinates is</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    determined by spline interpolation of the requested order. Points</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    outside the boundaries of the input are filled according to the given</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    mode.</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    .. versionchanged:: 0.18.0</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        Previously, the exact interpretation of the affine transformation</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        depended on whether the matrix was supplied as a 1-D or a</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        2-D array. If a 1-D array was supplied</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        to the matrix parameter, the output pixel value at index ``o``</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        was determined from the input image at position</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        ``matrix * (o + offset)``.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    For complex-valued `input`, this function transforms the real and imaginary</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    .. [1] https://en.wikipedia.org/wiki/Homogeneous_coordinates</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  546</span>    <span class="keywordflow">if</span> order &lt; 0 <span class="keywordflow">or</span> order &gt; 5:</div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;spline order not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  548</span>    input = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  549</span>    <span class="keywordflow">if</span> output_shape <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  550</span>        <span class="keywordflow">if</span> isinstance(output, numpy.ndarray):</div>
<div class="line"><span class="lineno">  551</span>            output_shape = output.shape</div>
<div class="line"><span class="lineno">  552</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  553</span>            output_shape = input.shape</div>
<div class="line"><span class="lineno">  554</span>    <span class="keywordflow">if</span> input.ndim &lt; 1 <span class="keywordflow">or</span> len(output_shape) &lt; 1:</div>
<div class="line"><span class="lineno">  555</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;input and output rank must be &gt; 0&#39;</span>)</div>
<div class="line"><span class="lineno">  556</span>    complex_output = numpy.iscomplexobj(input)</div>
<div class="line"><span class="lineno">  557</span>    output = _ni_support._get_output(output, input, shape=output_shape,</div>
<div class="line"><span class="lineno">  558</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  559</span>    <span class="keywordflow">if</span> complex_output:</div>
<div class="line"><span class="lineno">  560</span>        kwargs = dict(offset=offset, output_shape=output_shape, order=order,</div>
<div class="line"><span class="lineno">  561</span>                      mode=mode, prefilter=prefilter)</div>
<div class="line"><span class="lineno">  562</span>        affine_transform(input.real, matrix, output=output.real,</div>
<div class="line"><span class="lineno">  563</span>                         cval=numpy.real(cval), **kwargs)</div>
<div class="line"><span class="lineno">  564</span>        affine_transform(input.imag, matrix, output=output.imag,</div>
<div class="line"><span class="lineno">  565</span>                         cval=numpy.imag(cval), **kwargs)</div>
<div class="line"><span class="lineno">  566</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  567</span>    <span class="keywordflow">if</span> prefilter <span class="keywordflow">and</span> order &gt; 1:</div>
<div class="line"><span class="lineno">  568</span>        padded, npad = _prepad_for_spline_filter(input, mode, cval)</div>
<div class="line"><span class="lineno">  569</span>        filtered = spline_filter(padded, order, output=numpy.float64,</div>
<div class="line"><span class="lineno">  570</span>                                 mode=mode)</div>
<div class="line"><span class="lineno">  571</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  572</span>        npad = 0</div>
<div class="line"><span class="lineno">  573</span>        filtered = input</div>
<div class="line"><span class="lineno">  574</span>    mode = _ni_support._extend_mode_to_code(mode)</div>
<div class="line"><span class="lineno">  575</span>    matrix = numpy.asarray(matrix, dtype=numpy.float64)</div>
<div class="line"><span class="lineno">  576</span>    <span class="keywordflow">if</span> matrix.ndim <span class="keywordflow">not</span> <span class="keywordflow">in</span> [1, 2] <span class="keywordflow">or</span> matrix.shape[0] &lt; 1:</div>
<div class="line"><span class="lineno">  577</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;no proper affine matrix provided&#39;</span>)</div>
<div class="line"><span class="lineno">  578</span>    <span class="keywordflow">if</span> (matrix.ndim == 2 <span class="keywordflow">and</span> matrix.shape[1] == input.ndim + 1 <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  579</span>            (matrix.shape[0] <span class="keywordflow">in</span> [input.ndim, input.ndim + 1])):</div>
<div class="line"><span class="lineno">  580</span>        <span class="keywordflow">if</span> matrix.shape[0] == input.ndim + 1:</div>
<div class="line"><span class="lineno">  581</span>            exptd = [0] * input.ndim + [1]</div>
<div class="line"><span class="lineno">  582</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> numpy.all(matrix[input.ndim] == exptd):</div>
<div class="line"><span class="lineno">  583</span>                msg = (<span class="stringliteral">&#39;Expected homogeneous transformation matrix with &#39;</span></div>
<div class="line"><span class="lineno">  584</span>                       <span class="stringliteral">&#39;shape %s for image shape %s, but bottom row was &#39;</span></div>
<div class="line"><span class="lineno">  585</span>                       <span class="stringliteral">&#39;not equal to %s&#39;</span> % (matrix.shape, input.shape, exptd))</div>
<div class="line"><span class="lineno">  586</span>                <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  587</span>        <span class="comment"># assume input is homogeneous coordinate transformation matrix</span></div>
<div class="line"><span class="lineno">  588</span>        offset = matrix[:input.ndim, input.ndim]</div>
<div class="line"><span class="lineno">  589</span>        matrix = matrix[:input.ndim, :input.ndim]</div>
<div class="line"><span class="lineno">  590</span>    <span class="keywordflow">if</span> matrix.shape[0] != input.ndim:</div>
<div class="line"><span class="lineno">  591</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;affine matrix has wrong number of rows&#39;</span>)</div>
<div class="line"><span class="lineno">  592</span>    <span class="keywordflow">if</span> matrix.ndim == 2 <span class="keywordflow">and</span> matrix.shape[1] != output.ndim:</div>
<div class="line"><span class="lineno">  593</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;affine matrix has wrong number of columns&#39;</span>)</div>
<div class="line"><span class="lineno">  594</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> matrix.flags.contiguous:</div>
<div class="line"><span class="lineno">  595</span>        matrix = matrix.copy()</div>
<div class="line"><span class="lineno">  596</span>    offset = _ni_support._normalize_sequence(offset, input.ndim)</div>
<div class="line"><span class="lineno">  597</span>    offset = numpy.asarray(offset, dtype=numpy.float64)</div>
<div class="line"><span class="lineno">  598</span>    <span class="keywordflow">if</span> offset.ndim != 1 <span class="keywordflow">or</span> offset.shape[0] &lt; 1:</div>
<div class="line"><span class="lineno">  599</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;no proper offset provided&#39;</span>)</div>
<div class="line"><span class="lineno">  600</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> offset.flags.contiguous:</div>
<div class="line"><span class="lineno">  601</span>        offset = offset.copy()</div>
<div class="line"><span class="lineno">  602</span>    <span class="keywordflow">if</span> matrix.ndim == 1:</div>
<div class="line"><span class="lineno">  603</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  604</span>            <span class="stringliteral">&quot;The behavior of affine_transform with a 1-D &quot;</span></div>
<div class="line"><span class="lineno">  605</span>            <span class="stringliteral">&quot;array supplied for the matrix parameter has changed in &quot;</span></div>
<div class="line"><span class="lineno">  606</span>            <span class="stringliteral">&quot;SciPy 0.18.0.&quot;</span></div>
<div class="line"><span class="lineno">  607</span>        )</div>
<div class="line"><span class="lineno">  608</span>        _nd_image.zoom_shift(filtered, matrix, offset/matrix, output, order,</div>
<div class="line"><span class="lineno">  609</span>                             mode, cval, npad, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  610</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  611</span>        _nd_image.geometric_transform(filtered, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, matrix, offset,</div>
<div class="line"><span class="lineno">  612</span>                                      output, order, mode, cval, npad, <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  613</span>                                      <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  614</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  615</span> </div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span><span class="preprocessor">@docfiller</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afbaf1ed27b34a877be24672a8009625e" name="afbaf1ed27b34a877be24672a8009625e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaf1ed27b34a877be24672a8009625e">&#9670;&#160;</a></span>geometric_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.geometric_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_shape</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefilter</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra_arguments</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra_keywords</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply an arbitrary geometric transform.

The given mapping function is used to find, for each point in the
output, the corresponding coordinates in the input. The value of the
input at those coordinates is determined by spline interpolation of
the requested order.

Parameters
----------
%(input)s
mapping : {callable, scipy.LowLevelCallable}
    A callable object that accepts a tuple of length equal to the output
    array rank, and returns the corresponding input coordinates as a tuple
    of length equal to the input array rank.
output_shape : tuple of ints, optional
    Shape tuple.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s
extra_arguments : tuple, optional
    Extra arguments passed to `mapping`.
extra_keywords : dict, optional
    Extra keywords passed to `mapping`.

Returns
-------
output : ndarray
    The filtered input.

See Also
--------
map_coordinates, affine_transform, spline_filter1d


Notes
-----
This function also accepts low-level callback functions with one
the following signatures and wrapped in `scipy.LowLevelCallable`:

.. code:: c

   int mapping(npy_intp *output_coordinates, double *input_coordinates,
               int output_rank, int input_rank, void *user_data)
   int mapping(intptr_t *output_coordinates, double *input_coordinates,
               int output_rank, int input_rank, void *user_data)

The calling function iterates over the elements of the output array,
calling the callback function at each element. The coordinates of the
current output element are passed through ``output_coordinates``. The
callback function must return the coordinates at which the input must
be interpolated in ``input_coordinates``. The rank of the input and
output arrays are given by ``input_rank`` and ``output_rank``
respectively. ``user_data`` is the data pointer provided
to `scipy.LowLevelCallable` as-is.

The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the Python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.

In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.

For complex-valued `input`, this function transforms the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.ndimage import geometric_transform
&gt;&gt;&gt; a = np.arange(12.).reshape((4, 3))
&gt;&gt;&gt; def shift_func(output_coords):
...     return (output_coords[0] - 0.5, output_coords[1] - 0.5)
...
&gt;&gt;&gt; geometric_transform(a, shift_func)
array([[ 0.   ,  0.   ,  0.   ],
       [ 0.   ,  1.362,  2.738],
       [ 0.   ,  4.812,  6.187],
       [ 0.   ,  8.263,  9.637]])

&gt;&gt;&gt; b = [1, 2, 3, 4, 5]
&gt;&gt;&gt; def shift_func(output_coords):
...     return (output_coords[0] - 3,)
...
&gt;&gt;&gt; geometric_transform(b, shift_func, mode='constant')
array([0, 0, 0, 1, 2])
&gt;&gt;&gt; geometric_transform(b, shift_func, mode='nearest')
array([1, 1, 1, 1, 2])
&gt;&gt;&gt; geometric_transform(b, shift_func, mode='reflect')
array([3, 2, 1, 1, 2])
&gt;&gt;&gt; geometric_transform(b, shift_func, mode='wrap')
array([2, 3, 4, 1, 2])</pre> <div class="fragment"><div class="line"><span class="lineno">  216</span>                        extra_arguments=(), extra_keywords={}):</div>
<div class="line"><span class="lineno">  217</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    Apply an arbitrary geometric transform.</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    The given mapping function is used to find, for each point in the</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    output, the corresponding coordinates in the input. The value of the</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    input at those coordinates is determined by spline interpolation of</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    the requested order.</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    %(input)s</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    mapping : {callable, scipy.LowLevelCallable}</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        A callable object that accepts a tuple of length equal to the output</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        array rank, and returns the corresponding input coordinates as a tuple</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        of length equal to the input array rank.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    output_shape : tuple of ints, optional</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        Shape tuple.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    %(output)s</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        The order of the spline interpolation, default is 3.</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        The order has to be in the range 0-5.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    %(mode_interp_constant)s</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    %(cval)s</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    %(prefilter)s</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    extra_arguments : tuple, optional</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        Extra arguments passed to `mapping`.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    extra_keywords : dict, optional</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        Extra keywords passed to `mapping`.</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        The filtered input.</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    map_coordinates, affine_transform, spline_filter1d</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    This function also accepts low-level callback functions with one</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    the following signatures and wrapped in `scipy.LowLevelCallable`:</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    .. code:: c</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">       int mapping(npy_intp *output_coordinates, double *input_coordinates,</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">                   int output_rank, int input_rank, void *user_data)</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">       int mapping(intptr_t *output_coordinates, double *input_coordinates,</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">                   int output_rank, int input_rank, void *user_data)</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    The calling function iterates over the elements of the output array,</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    calling the callback function at each element. The coordinates of the</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    current output element are passed through ``output_coordinates``. The</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    callback function must return the coordinates at which the input must</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    be interpolated in ``input_coordinates``. The rank of the input and</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    output arrays are given by ``input_rank`` and ``output_rank``</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    respectively. ``user_data`` is the data pointer provided</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    to `scipy.LowLevelCallable` as-is.</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    The callback function must return an integer error status that is zero</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    if something went wrong and one otherwise. If an error occurs, you should</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    normally set the Python error status with an informative message</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    before returning, otherwise a default error message is set by the</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    calling function.</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    In addition, some other low-level function pointer specifications</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    are accepted, but these are for backward compatibility only and should</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    not be used in new code.</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    For complex-valued `input`, this function transforms the real and imaginary</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.ndimage import geometric_transform</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(12.).reshape((4, 3))</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    &gt;&gt;&gt; def shift_func(output_coords):</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    ...     return (output_coords[0] - 0.5, output_coords[1] - 0.5)</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    &gt;&gt;&gt; geometric_transform(a, shift_func)</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    array([[ 0.   ,  0.   ,  0.   ],</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">           [ 0.   ,  1.362,  2.738],</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">           [ 0.   ,  4.812,  6.187],</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">           [ 0.   ,  8.263,  9.637]])</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    &gt;&gt;&gt; b = [1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    &gt;&gt;&gt; def shift_func(output_coords):</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    ...     return (output_coords[0] - 3,)</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    &gt;&gt;&gt; geometric_transform(b, shift_func, mode=&#39;constant&#39;)</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    array([0, 0, 0, 1, 2])</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    &gt;&gt;&gt; geometric_transform(b, shift_func, mode=&#39;nearest&#39;)</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    array([1, 1, 1, 1, 2])</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    &gt;&gt;&gt; geometric_transform(b, shift_func, mode=&#39;reflect&#39;)</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    array([3, 2, 1, 1, 2])</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    &gt;&gt;&gt; geometric_transform(b, shift_func, mode=&#39;wrap&#39;)</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    array([2, 3, 4, 1, 2])</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">if</span> order &lt; 0 <span class="keywordflow">or</span> order &gt; 5:</div>
<div class="line"><span class="lineno">  322</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;spline order not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  323</span>    input = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  324</span>    <span class="keywordflow">if</span> output_shape <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  325</span>        output_shape = input.shape</div>
<div class="line"><span class="lineno">  326</span>    <span class="keywordflow">if</span> input.ndim &lt; 1 <span class="keywordflow">or</span> len(output_shape) &lt; 1:</div>
<div class="line"><span class="lineno">  327</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;input and output rank must be &gt; 0&#39;</span>)</div>
<div class="line"><span class="lineno">  328</span>    complex_output = numpy.iscomplexobj(input)</div>
<div class="line"><span class="lineno">  329</span>    output = _ni_support._get_output(output, input, shape=output_shape,</div>
<div class="line"><span class="lineno">  330</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  331</span>    <span class="keywordflow">if</span> complex_output:</div>
<div class="line"><span class="lineno">  332</span>        kwargs = dict(order=order, mode=mode, prefilter=prefilter,</div>
<div class="line"><span class="lineno">  333</span>                      output_shape=output_shape,</div>
<div class="line"><span class="lineno">  334</span>                      extra_arguments=extra_arguments,</div>
<div class="line"><span class="lineno">  335</span>                      extra_keywords=extra_keywords)</div>
<div class="line"><span class="lineno">  336</span>        geometric_transform(input.real, mapping, output=output.real,</div>
<div class="line"><span class="lineno">  337</span>                            cval=numpy.real(cval), **kwargs)</div>
<div class="line"><span class="lineno">  338</span>        geometric_transform(input.imag, mapping, output=output.imag,</div>
<div class="line"><span class="lineno">  339</span>                            cval=numpy.imag(cval), **kwargs)</div>
<div class="line"><span class="lineno">  340</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>    <span class="keywordflow">if</span> prefilter <span class="keywordflow">and</span> order &gt; 1:</div>
<div class="line"><span class="lineno">  343</span>        padded, npad = _prepad_for_spline_filter(input, mode, cval)</div>
<div class="line"><span class="lineno">  344</span>        filtered = spline_filter(padded, order, output=numpy.float64,</div>
<div class="line"><span class="lineno">  345</span>                                 mode=mode)</div>
<div class="line"><span class="lineno">  346</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  347</span>        npad = 0</div>
<div class="line"><span class="lineno">  348</span>        filtered = input</div>
<div class="line"><span class="lineno">  349</span>    mode = _ni_support._extend_mode_to_code(mode)</div>
<div class="line"><span class="lineno">  350</span>    _nd_image.geometric_transform(filtered, mapping, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, output,</div>
<div class="line"><span class="lineno">  351</span>                                  order, mode, cval, npad, extra_arguments,</div>
<div class="line"><span class="lineno">  352</span>                                  extra_keywords)</div>
<div class="line"><span class="lineno">  353</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span> </div>
<div class="line"><span class="lineno">  356</span><span class="preprocessor">@docfiller</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aff6f1bbee32816e75c58eb421c4c3160" name="aff6f1bbee32816e75c58eb421c4c3160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6f1bbee32816e75c58eb421c4c3160">&#9670;&#160;</a></span>map_coordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.map_coordinates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefilter</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Map the input array to new coordinates by interpolation.

The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.

The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.

Parameters
----------
%(input)s
coordinates : array_like
    The coordinates at which `input` is evaluated.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
map_coordinates : ndarray
    The result of transforming the input. The shape of the output is
    derived from that of `coordinates` by dropping the first axis.

See Also
--------
spline_filter, geometric_transform, scipy.interpolate

Notes
-----
For complex-valued `input`, this function maps the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; a = np.arange(12.).reshape((4, 3))
&gt;&gt;&gt; a
array([[  0.,   1.,   2.],
       [  3.,   4.,   5.],
       [  6.,   7.,   8.],
       [  9.,  10.,  11.]])
&gt;&gt;&gt; ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1)
array([ 2.,  7.])

Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].

&gt;&gt;&gt; inds = np.array([[0.5, 2], [0.5, 4]])
&gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=-33.3)
array([  2. , -33.3])
&gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, mode='nearest')
array([ 2.,  8.])
&gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=0, output=bool)
array([ True, False], dtype=bool)</pre> <div class="fragment"><div class="line"><span class="lineno">  358</span>                    mode=<span class="stringliteral">&#39;constant&#39;</span>, cval=0.0, prefilter=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  359</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    Map the input array to new coordinates by interpolation.</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    The array of coordinates is used to find, for each point in the output,</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    the corresponding coordinates in the input. The value of the input at</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    those coordinates is determined by spline interpolation of the</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    requested order.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    The shape of the output is derived from that of the coordinate</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    array by dropping the first axis. The values of the array along</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    the first axis are the coordinates in the input array at which the</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    output value is found.</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    %(input)s</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    coordinates : array_like</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        The coordinates at which `input` is evaluated.</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    %(output)s</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        The order of the spline interpolation, default is 3.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        The order has to be in the range 0-5.</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    %(mode_interp_constant)s</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    %(cval)s</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    %(prefilter)s</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    map_coordinates : ndarray</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        The result of transforming the input. The shape of the output is</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">        derived from that of `coordinates` by dropping the first axis.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    spline_filter, geometric_transform, scipy.interpolate</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    For complex-valued `input`, this function maps the real and imaginary</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import ndimage</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(12.).reshape((4, 3))</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    array([[  0.,   1.,   2.],</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">           [  3.,   4.,   5.],</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">           [  6.,   7.,   8.],</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">           [  9.,  10.,  11.]])</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    &gt;&gt;&gt; ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1)</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    array([ 2.,  7.])</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    Above, the interpolated value of a[0.5, 0.5] gives output[0], while</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    a[2, 1] is output[1].</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    &gt;&gt;&gt; inds = np.array([[0.5, 2], [0.5, 4]])</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=-33.3)</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    array([  2. , -33.3])</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    &gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, mode=&#39;nearest&#39;)</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    array([ 2.,  8.])</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    &gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=0, output=bool)</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    array([ True, False], dtype=bool)</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">if</span> order &lt; 0 <span class="keywordflow">or</span> order &gt; 5:</div>
<div class="line"><span class="lineno">  428</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;spline order not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  429</span>    input = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  430</span>    coordinates = numpy.asarray(coordinates)</div>
<div class="line"><span class="lineno">  431</span>    <span class="keywordflow">if</span> numpy.iscomplexobj(coordinates):</div>
<div class="line"><span class="lineno">  432</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;Complex type not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  433</span>    output_shape = coordinates.shape[1:]</div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">if</span> input.ndim &lt; 1 <span class="keywordflow">or</span> len(output_shape) &lt; 1:</div>
<div class="line"><span class="lineno">  435</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;input and output rank must be &gt; 0&#39;</span>)</div>
<div class="line"><span class="lineno">  436</span>    <span class="keywordflow">if</span> coordinates.shape[0] != input.ndim:</div>
<div class="line"><span class="lineno">  437</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;invalid shape for coordinate array&#39;</span>)</div>
<div class="line"><span class="lineno">  438</span>    complex_output = numpy.iscomplexobj(input)</div>
<div class="line"><span class="lineno">  439</span>    output = _ni_support._get_output(output, input, shape=output_shape,</div>
<div class="line"><span class="lineno">  440</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  441</span>    <span class="keywordflow">if</span> complex_output:</div>
<div class="line"><span class="lineno">  442</span>        kwargs = dict(order=order, mode=mode, prefilter=prefilter)</div>
<div class="line"><span class="lineno">  443</span>        map_coordinates(input.real, coordinates, output=output.real,</div>
<div class="line"><span class="lineno">  444</span>                        cval=numpy.real(cval), **kwargs)</div>
<div class="line"><span class="lineno">  445</span>        map_coordinates(input.imag, coordinates, output=output.imag,</div>
<div class="line"><span class="lineno">  446</span>                        cval=numpy.imag(cval), **kwargs)</div>
<div class="line"><span class="lineno">  447</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">if</span> prefilter <span class="keywordflow">and</span> order &gt; 1:</div>
<div class="line"><span class="lineno">  449</span>        padded, npad = _prepad_for_spline_filter(input, mode, cval)</div>
<div class="line"><span class="lineno">  450</span>        filtered = spline_filter(padded, order, output=numpy.float64,</div>
<div class="line"><span class="lineno">  451</span>                                 mode=mode)</div>
<div class="line"><span class="lineno">  452</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  453</span>        npad = 0</div>
<div class="line"><span class="lineno">  454</span>        filtered = input</div>
<div class="line"><span class="lineno">  455</span>    mode = _ni_support._extend_mode_to_code(mode)</div>
<div class="line"><span class="lineno">  456</span>    _nd_image.geometric_transform(filtered, <span class="keywordtype">None</span>, coordinates, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  457</span>                                  output, order, mode, cval, npad, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  458</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span><span class="preprocessor">@docfiller</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6bf9560fc833b87edb39fba44a603172" name="a6bf9560fc833b87edb39fba44a603172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf9560fc833b87edb39fba44a603172">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.rotate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>(1,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reshape</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefilter</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rotate an array.

The array is rotated in the plane defined by the two axes given by the
`axes` parameter using spline interpolation of the requested order.

Parameters
----------
%(input)s
angle : float
    The rotation angle in degrees.
axes : tuple of 2 ints, optional
    The two axes that define the plane of rotation. Default is the first
    two axes.
reshape : bool, optional
    If `reshape` is true, the output shape is adapted so that the input
    array is contained completely in the output. Default is True.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
rotate : ndarray
    The rotated input.

Notes
-----
For complex-valued `input`, this function rotates the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
&gt;&gt;&gt; from scipy import ndimage, misc
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure(figsize=(10, 3))
&gt;&gt;&gt; ax1, ax2, ax3 = fig.subplots(1, 3)
&gt;&gt;&gt; img = misc.ascent()
&gt;&gt;&gt; img_45 = ndimage.rotate(img, 45, reshape=False)
&gt;&gt;&gt; full_img_45 = ndimage.rotate(img, 45, reshape=True)
&gt;&gt;&gt; ax1.imshow(img, cmap='gray')
&gt;&gt;&gt; ax1.set_axis_off()
&gt;&gt;&gt; ax2.imshow(img_45, cmap='gray')
&gt;&gt;&gt; ax2.set_axis_off()
&gt;&gt;&gt; ax3.imshow(full_img_45, cmap='gray')
&gt;&gt;&gt; ax3.set_axis_off()
&gt;&gt;&gt; fig.set_layout_engine('tight')
&gt;&gt;&gt; plt.show()
&gt;&gt;&gt; print(img.shape)
(512, 512)
&gt;&gt;&gt; print(img_45.shape)
(512, 512)
&gt;&gt;&gt; print(full_img_45.shape)
(724, 724)</pre> <div class="fragment"><div class="line"><span class="lineno">  823</span>           mode=<span class="stringliteral">&#39;constant&#39;</span>, cval=0.0, prefilter=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  824</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    Rotate an array.</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    The array is rotated in the plane defined by the two axes given by the</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    `axes` parameter using spline interpolation of the requested order.</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    %(input)s</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    angle : float</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        The rotation angle in degrees.</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    axes : tuple of 2 ints, optional</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">        The two axes that define the plane of rotation. Default is the first</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">        two axes.</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    reshape : bool, optional</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        If `reshape` is true, the output shape is adapted so that the input</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        array is contained completely in the output. Default is True.</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    %(output)s</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        The order of the spline interpolation, default is 3.</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        The order has to be in the range 0-5.</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    %(mode_interp_constant)s</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    %(cval)s</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    %(prefilter)s</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    rotate : ndarray</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">        The rotated input.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    For complex-valued `input`, this function rotates the real and imaginary</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import ndimage, misc</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure(figsize=(10, 3))</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    &gt;&gt;&gt; ax1, ax2, ax3 = fig.subplots(1, 3)</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    &gt;&gt;&gt; img = misc.ascent()</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    &gt;&gt;&gt; img_45 = ndimage.rotate(img, 45, reshape=False)</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    &gt;&gt;&gt; full_img_45 = ndimage.rotate(img, 45, reshape=True)</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    &gt;&gt;&gt; ax1.imshow(img, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_axis_off()</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    &gt;&gt;&gt; ax2.imshow(img_45, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    &gt;&gt;&gt; ax2.set_axis_off()</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    &gt;&gt;&gt; ax3.imshow(full_img_45, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    &gt;&gt;&gt; ax3.set_axis_off()</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    &gt;&gt;&gt; fig.set_layout_engine(&#39;tight&#39;)</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    &gt;&gt;&gt; print(img.shape)</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    (512, 512)</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    &gt;&gt;&gt; print(img_45.shape)</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    (512, 512)</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    &gt;&gt;&gt; print(full_img_45.shape)</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    (724, 724)</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  887</span>    input_arr = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  888</span>    ndim = input_arr.ndim</div>
<div class="line"><span class="lineno">  889</span> </div>
<div class="line"><span class="lineno">  890</span>    <span class="keywordflow">if</span> ndim &lt; 2:</div>
<div class="line"><span class="lineno">  891</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;input array should be at least 2D&#39;</span>)</div>
<div class="line"><span class="lineno">  892</span> </div>
<div class="line"><span class="lineno">  893</span>    axes = list(axes)</div>
<div class="line"><span class="lineno">  894</span> </div>
<div class="line"><span class="lineno">  895</span>    <span class="keywordflow">if</span> len(axes) != 2:</div>
<div class="line"><span class="lineno">  896</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;axes should contain exactly two values&#39;</span>)</div>
<div class="line"><span class="lineno">  897</span> </div>
<div class="line"><span class="lineno">  898</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> all([float(ax).is_integer() <span class="keywordflow">for</span> ax <span class="keywordflow">in</span> axes]):</div>
<div class="line"><span class="lineno">  899</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;axes should contain only integer values&#39;</span>)</div>
<div class="line"><span class="lineno">  900</span> </div>
<div class="line"><span class="lineno">  901</span>    <span class="keywordflow">if</span> axes[0] &lt; 0:</div>
<div class="line"><span class="lineno">  902</span>        axes[0] += ndim</div>
<div class="line"><span class="lineno">  903</span>    <span class="keywordflow">if</span> axes[1] &lt; 0:</div>
<div class="line"><span class="lineno">  904</span>        axes[1] += ndim</div>
<div class="line"><span class="lineno">  905</span>    <span class="keywordflow">if</span> axes[0] &lt; 0 <span class="keywordflow">or</span> axes[1] &lt; 0 <span class="keywordflow">or</span> axes[0] &gt;= ndim <span class="keywordflow">or</span> axes[1] &gt;= ndim:</div>
<div class="line"><span class="lineno">  906</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;invalid rotation plane specified&#39;</span>)</div>
<div class="line"><span class="lineno">  907</span> </div>
<div class="line"><span class="lineno">  908</span>    axes.sort()</div>
<div class="line"><span class="lineno">  909</span> </div>
<div class="line"><span class="lineno">  910</span>    c, s = special.cosdg(angle), special.sindg(angle)</div>
<div class="line"><span class="lineno">  911</span> </div>
<div class="line"><span class="lineno">  912</span>    rot_matrix = numpy.array([[c, s],</div>
<div class="line"><span class="lineno">  913</span>                              [-s, c]])</div>
<div class="line"><span class="lineno">  914</span> </div>
<div class="line"><span class="lineno">  915</span>    img_shape = numpy.asarray(input_arr.shape)</div>
<div class="line"><span class="lineno">  916</span>    in_plane_shape = img_shape[axes]</div>
<div class="line"><span class="lineno">  917</span>    <span class="keywordflow">if</span> reshape:</div>
<div class="line"><span class="lineno">  918</span>        <span class="comment"># Compute transformed input bounds</span></div>
<div class="line"><span class="lineno">  919</span>        iy, ix = in_plane_shape</div>
<div class="line"><span class="lineno">  920</span>        out_bounds = rot_matrix @ [[0, 0, iy, iy],</div>
<div class="line"><span class="lineno">  921</span>                                   [0, ix, 0, ix]]</div>
<div class="line"><span class="lineno">  922</span>        <span class="comment"># Compute the shape of the transformed input plane</span></div>
<div class="line"><span class="lineno">  923</span>        out_plane_shape = (out_bounds.ptp(axis=1) + 0.5).astype(int)</div>
<div class="line"><span class="lineno">  924</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  925</span>        out_plane_shape = img_shape[axes]</div>
<div class="line"><span class="lineno">  926</span> </div>
<div class="line"><span class="lineno">  927</span>    out_center = rot_matrix @ ((out_plane_shape - 1) / 2)</div>
<div class="line"><span class="lineno">  928</span>    in_center = (in_plane_shape - 1) / 2</div>
<div class="line"><span class="lineno">  929</span>    offset = in_center - out_center</div>
<div class="line"><span class="lineno">  930</span> </div>
<div class="line"><span class="lineno">  931</span>    output_shape = img_shape</div>
<div class="line"><span class="lineno">  932</span>    output_shape[axes] = out_plane_shape</div>
<div class="line"><span class="lineno">  933</span>    output_shape = tuple(output_shape)</div>
<div class="line"><span class="lineno">  934</span> </div>
<div class="line"><span class="lineno">  935</span>    complex_output = numpy.iscomplexobj(input_arr)</div>
<div class="line"><span class="lineno">  936</span>    output = _ni_support._get_output(output, input_arr, shape=output_shape,</div>
<div class="line"><span class="lineno">  937</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span>    <span class="keywordflow">if</span> ndim &lt;= 2:</div>
<div class="line"><span class="lineno">  940</span>        affine_transform(input_arr, rot_matrix, offset, output_shape, output,</div>
<div class="line"><span class="lineno">  941</span>                         order, mode, cval, prefilter)</div>
<div class="line"><span class="lineno">  942</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  943</span>        <span class="comment"># If ndim &gt; 2, the rotation is applied over all the planes</span></div>
<div class="line"><span class="lineno">  944</span>        <span class="comment"># parallel to axes</span></div>
<div class="line"><span class="lineno">  945</span>        planes_coord = itertools.product(</div>
<div class="line"><span class="lineno">  946</span>            *[[slice(<span class="keywordtype">None</span>)] <span class="keywordflow">if</span> ax <span class="keywordflow">in</span> axes <span class="keywordflow">else</span> range(img_shape[ax])</div>
<div class="line"><span class="lineno">  947</span>              <span class="keywordflow">for</span> ax <span class="keywordflow">in</span> range(ndim)])</div>
<div class="line"><span class="lineno">  948</span> </div>
<div class="line"><span class="lineno">  949</span>        out_plane_shape = tuple(out_plane_shape)</div>
<div class="line"><span class="lineno">  950</span> </div>
<div class="line"><span class="lineno">  951</span>        <span class="keywordflow">for</span> coordinates <span class="keywordflow">in</span> planes_coord:</div>
<div class="line"><span class="lineno">  952</span>            ia = input_arr[coordinates]</div>
<div class="line"><span class="lineno">  953</span>            oa = output[coordinates]</div>
<div class="line"><span class="lineno">  954</span>            affine_transform(ia, rot_matrix, offset, out_plane_shape,</div>
<div class="line"><span class="lineno">  955</span>                             oa, order, mode, cval, prefilter)</div>
<div class="line"><span class="lineno">  956</span> </div>
<div class="line"><span class="lineno">  957</span>    <span class="keywordflow">return</span> output</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6141e26d9a9aa095a6c8b0168fd552fa" name="a6141e26d9a9aa095a6c8b0168fd552fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6141e26d9a9aa095a6c8b0168fd552fa">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefilter</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Shift an array.

The array is shifted using spline interpolation of the requested order.
Points outside the boundaries of the input are filled according to the
given mode.

Parameters
----------
%(input)s
shift : float or sequence
    The shift along the axes. If a float, `shift` is the same for each
    axis. If a sequence, `shift` should contain one value for each axis.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
shift : ndarray
    The shifted input.

Notes
-----
For complex-valued `input`, this function shifts the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.</pre> <div class="fragment"><div class="line"><span class="lineno">  619</span>          prefilter=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  620</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    Shift an array.</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    The array is shifted using spline interpolation of the requested order.</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    Points outside the boundaries of the input are filled according to the</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    given mode.</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    %(input)s</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    shift : float or sequence</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        The shift along the axes. If a float, `shift` is the same for each</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">        axis. If a sequence, `shift` should contain one value for each axis.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    %(output)s</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">        The order of the spline interpolation, default is 3.</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">        The order has to be in the range 0-5.</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    %(mode_interp_constant)s</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    %(cval)s</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    %(prefilter)s</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    shift : ndarray</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">        The shifted input.</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    For complex-valued `input`, this function shifts the real and imaginary</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  655</span>    <span class="keywordflow">if</span> order &lt; 0 <span class="keywordflow">or</span> order &gt; 5:</div>
<div class="line"><span class="lineno">  656</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;spline order not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  657</span>    input = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  658</span>    <span class="keywordflow">if</span> input.ndim &lt; 1:</div>
<div class="line"><span class="lineno">  659</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;input and output rank must be &gt; 0&#39;</span>)</div>
<div class="line"><span class="lineno">  660</span>    complex_output = numpy.iscomplexobj(input)</div>
<div class="line"><span class="lineno">  661</span>    output = _ni_support._get_output(output, input,</div>
<div class="line"><span class="lineno">  662</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  663</span>    <span class="keywordflow">if</span> complex_output:</div>
<div class="line"><span class="lineno">  664</span>        <span class="comment"># import under different name to avoid confusion with shift parameter</span></div>
<div class="line"><span class="lineno">  665</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1ndimage_1_1__interpolation.html">scipy.ndimage._interpolation</a> <span class="keyword">import</span> shift <span class="keyword">as</span> _shift</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span>        kwargs = dict(order=order, mode=mode, prefilter=prefilter)</div>
<div class="line"><span class="lineno">  668</span>        _shift(input.real, shift, output=output.real, cval=numpy.real(cval),</div>
<div class="line"><span class="lineno">  669</span>               **kwargs)</div>
<div class="line"><span class="lineno">  670</span>        _shift(input.imag, shift, output=output.imag, cval=numpy.imag(cval),</div>
<div class="line"><span class="lineno">  671</span>               **kwargs)</div>
<div class="line"><span class="lineno">  672</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  673</span>    <span class="keywordflow">if</span> prefilter <span class="keywordflow">and</span> order &gt; 1:</div>
<div class="line"><span class="lineno">  674</span>        padded, npad = _prepad_for_spline_filter(input, mode, cval)</div>
<div class="line"><span class="lineno">  675</span>        filtered = spline_filter(padded, order, output=numpy.float64,</div>
<div class="line"><span class="lineno">  676</span>                                 mode=mode)</div>
<div class="line"><span class="lineno">  677</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  678</span>        npad = 0</div>
<div class="line"><span class="lineno">  679</span>        filtered = input</div>
<div class="line"><span class="lineno">  680</span>    mode = _ni_support._extend_mode_to_code(mode)</div>
<div class="line"><span class="lineno">  681</span>    shift = _ni_support._normalize_sequence(shift, input.ndim)</div>
<div class="line"><span class="lineno">  682</span>    shift = [-ii <span class="keywordflow">for</span> ii <span class="keywordflow">in</span> shift]</div>
<div class="line"><span class="lineno">  683</span>    shift = numpy.asarray(shift, dtype=numpy.float64)</div>
<div class="line"><span class="lineno">  684</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> shift.flags.contiguous:</div>
<div class="line"><span class="lineno">  685</span>        shift = shift.copy()</div>
<div class="line"><span class="lineno">  686</span>    _nd_image.zoom_shift(filtered, <span class="keywordtype">None</span>, shift, output, order, mode, cval,</div>
<div class="line"><span class="lineno">  687</span>                         npad, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  688</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span> </div>
<div class="line"><span class="lineno">  691</span><span class="preprocessor">@docfiller</span></div>
<div class="ttc" id="anamespacescipy_1_1ndimage_1_1__interpolation_html"><div class="ttname"><a href="namespacescipy_1_1ndimage_1_1__interpolation.html">scipy.ndimage._interpolation</a></div><div class="ttdef"><b>Definition</b> _interpolation.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a12262008d7d2f963421cd92c9c015be0" name="a12262008d7d2f963421cd92c9c015be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12262008d7d2f963421cd92c9c015be0">&#9670;&#160;</a></span>spline_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.spline_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>numpy.float64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'mirror'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multidimensional spline filter.

For more details, see `spline_filter1d`.

See Also
--------
spline_filter1d : Calculate a 1-D spline filter along the given axis.

Notes
-----
The multidimensional filter is implemented as a sequence of
1-D spline filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.

For complex-valued `input`, this function processes the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
We can filter an image using multidimentional splines:

&gt;&gt;&gt; from scipy.ndimage import spline_filter
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; orig_img = np.eye(20)  # create an image
&gt;&gt;&gt; orig_img[10, :] = 1.0
&gt;&gt;&gt; sp_filter = spline_filter(orig_img, order=3)
&gt;&gt;&gt; f, ax = plt.subplots(1, 2, sharex=True)
&gt;&gt;&gt; for ind, data in enumerate([[orig_img, "original image"],
...                             [sp_filter, "spline filter"]]):
...     ax[ind].imshow(data[0], cmap='gray_r')
...     ax[ind].set_title(data[1])
&gt;&gt;&gt; plt.tight_layout()
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  135</span><span class="keyword">def </span>spline_filter(input, order=3, output=numpy.float64, mode=&#39;mirror&#39;):</div>
<div class="line"><span class="lineno">  136</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    Multidimensional spline filter.</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    For more details, see `spline_filter1d`.</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    spline_filter1d : Calculate a 1-D spline filter along the given axis.</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    The multidimensional filter is implemented as a sequence of</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    1-D spline filters. The intermediate arrays are stored</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    in the same data type as the output. Therefore, for output types</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    with a limited precision, the results may be imprecise because</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    intermediate results may be stored with insufficient precision.</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    For complex-valued `input`, this function processes the real and imaginary</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    We can filter an image using multidimentional splines:</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.ndimage import spline_filter</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    &gt;&gt;&gt; orig_img = np.eye(20)  # create an image</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    &gt;&gt;&gt; orig_img[10, :] = 1.0</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    &gt;&gt;&gt; sp_filter = spline_filter(orig_img, order=3)</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    &gt;&gt;&gt; f, ax = plt.subplots(1, 2, sharex=True)</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    &gt;&gt;&gt; for ind, data in enumerate([[orig_img, &quot;original image&quot;],</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    ...                             [sp_filter, &quot;spline filter&quot;]]):</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    ...     ax[ind].imshow(data[0], cmap=&#39;gray_r&#39;)</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    ...     ax[ind].set_title(data[1])</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    &gt;&gt;&gt; plt.tight_layout()</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  177</span>    <span class="keywordflow">if</span> order &lt; 2 <span class="keywordflow">or</span> order &gt; 5:</div>
<div class="line"><span class="lineno">  178</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;spline order not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  179</span>    input = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  180</span>    complex_output = numpy.iscomplexobj(input)</div>
<div class="line"><span class="lineno">  181</span>    output = _ni_support._get_output(output, input,</div>
<div class="line"><span class="lineno">  182</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  183</span>    <span class="keywordflow">if</span> complex_output:</div>
<div class="line"><span class="lineno">  184</span>        spline_filter(input.real, order, output.real, mode)</div>
<div class="line"><span class="lineno">  185</span>        spline_filter(input.imag, order, output.imag, mode)</div>
<div class="line"><span class="lineno">  186</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">if</span> order <span class="keywordflow">not</span> <span class="keywordflow">in</span> [0, 1] <span class="keywordflow">and</span> input.ndim &gt; 0:</div>
<div class="line"><span class="lineno">  188</span>        <span class="keywordflow">for</span> axis <span class="keywordflow">in</span> range(input.ndim):</div>
<div class="line"><span class="lineno">  189</span>            spline_filter1d(input, order, axis, output=output, mode=mode)</div>
<div class="line"><span class="lineno">  190</span>            input = output</div>
<div class="line"><span class="lineno">  191</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  192</span>        output[...] = input[...]</div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  194</span> </div>
<div class="line"><span class="lineno">  195</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4633643f50ca2ab60dac0c772aa04f4b" name="a4633643f50ca2ab60dac0c772aa04f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4633643f50ca2ab60dac0c772aa04f4b">&#9670;&#160;</a></span>spline_filter1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.spline_filter1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>numpy.float64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'mirror'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate a 1-D spline filter along the given axis.

The lines of the array along the given axis are filtered by a
spline filter. The order of the spline must be &gt;= 2 and &lt;= 5.

Parameters
----------
%(input)s
order : int, optional
    The order of the spline, default is 3.
axis : int, optional
    The axis along which the spline filter is applied. Default is the last
    axis.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array. Default is ``numpy.float64``.
%(mode_interp_mirror)s

Returns
-------
spline_filter1d : ndarray
    The filtered input.

Notes
-----
All of the interpolation functions in `ndimage` do spline interpolation of
the input image. If using B-splines of `order &gt; 1`, the input image
values have to be converted to B-spline coefficients first, which is
done by applying this 1-D filter sequentially along all
axes of the input. All functions that require B-spline coefficients
will automatically filter their inputs, a behavior controllable with
the `prefilter` keyword argument. For functions that accept a `mode`
parameter, the result will only be correct if it matches the `mode`
used when filtering.

For complex-valued `input`, this function processes the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

See Also
--------
spline_filter : Multidimensional spline filter.

Examples
--------
We can filter an image using 1-D spline along the given axis:

&gt;&gt;&gt; from scipy.ndimage import spline_filter1d
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; orig_img = np.eye(20)  # create an image
&gt;&gt;&gt; orig_img[10, :] = 1.0
&gt;&gt;&gt; sp_filter_axis_0 = spline_filter1d(orig_img, axis=0)
&gt;&gt;&gt; sp_filter_axis_1 = spline_filter1d(orig_img, axis=1)
&gt;&gt;&gt; f, ax = plt.subplots(1, 3, sharex=True)
&gt;&gt;&gt; for ind, data in enumerate([[orig_img, "original image"],
...             [sp_filter_axis_0, "spline filter (axis=0)"],
...             [sp_filter_axis_1, "spline filter (axis=1)"]]):
...     ax[ind].imshow(data[0], cmap='gray_r')
...     ax[ind].set_title(data[1])
&gt;&gt;&gt; plt.tight_layout()
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">   49</span>                    mode=<span class="stringliteral">&#39;mirror&#39;</span>):</div>
<div class="line"><span class="lineno">   50</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    Calculate a 1-D spline filter along the given axis.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    The lines of the array along the given axis are filtered by a</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    spline filter. The order of the spline must be &gt;= 2 and &lt;= 5.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    %(input)s</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        The order of the spline, default is 3.</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        The axis along which the spline filter is applied. Default is the last</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">        axis.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    output : ndarray or dtype, optional</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        The array in which to place the output, or the dtype of the returned</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        array. Default is ``numpy.float64``.</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    %(mode_interp_mirror)s</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    spline_filter1d : ndarray</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">        The filtered input.</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    All of the interpolation functions in `ndimage` do spline interpolation of</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    the input image. If using B-splines of `order &gt; 1`, the input image</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    values have to be converted to B-spline coefficients first, which is</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    done by applying this 1-D filter sequentially along all</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    axes of the input. All functions that require B-spline coefficients</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    will automatically filter their inputs, a behavior controllable with</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    the `prefilter` keyword argument. For functions that accept a `mode`</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    parameter, the result will only be correct if it matches the `mode`</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    used when filtering.</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    For complex-valued `input`, this function processes the real and imaginary</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    spline_filter : Multidimensional spline filter.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    We can filter an image using 1-D spline along the given axis:</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.ndimage import spline_filter1d</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    &gt;&gt;&gt; orig_img = np.eye(20)  # create an image</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    &gt;&gt;&gt; orig_img[10, :] = 1.0</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    &gt;&gt;&gt; sp_filter_axis_0 = spline_filter1d(orig_img, axis=0)</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    &gt;&gt;&gt; sp_filter_axis_1 = spline_filter1d(orig_img, axis=1)</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    &gt;&gt;&gt; f, ax = plt.subplots(1, 3, sharex=True)</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    &gt;&gt;&gt; for ind, data in enumerate([[orig_img, &quot;original image&quot;],</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    ...             [sp_filter_axis_0, &quot;spline filter (axis=0)&quot;],</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    ...             [sp_filter_axis_1, &quot;spline filter (axis=1)&quot;]]):</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    ...     ax[ind].imshow(data[0], cmap=&#39;gray_r&#39;)</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    ...     ax[ind].set_title(data[1])</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    &gt;&gt;&gt; plt.tight_layout()</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  116</span>    <span class="keywordflow">if</span> order &lt; 0 <span class="keywordflow">or</span> order &gt; 5:</div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;spline order not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  118</span>    input = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  119</span>    complex_output = numpy.iscomplexobj(input)</div>
<div class="line"><span class="lineno">  120</span>    output = _ni_support._get_output(output, input,</div>
<div class="line"><span class="lineno">  121</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  122</span>    <span class="keywordflow">if</span> complex_output:</div>
<div class="line"><span class="lineno">  123</span>        spline_filter1d(input.real, order, axis, output.real, mode)</div>
<div class="line"><span class="lineno">  124</span>        spline_filter1d(input.imag, order, axis, output.imag, mode)</div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">if</span> order <span class="keywordflow">in</span> [0, 1]:</div>
<div class="line"><span class="lineno">  127</span>        output[...] = numpy.array(input)</div>
<div class="line"><span class="lineno">  128</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  129</span>        mode = _ni_support._extend_mode_to_code(mode)</div>
<div class="line"><span class="lineno">  130</span>        axis = normalize_axis_index(axis, input.ndim)</div>
<div class="line"><span class="lineno">  131</span>        _nd_image.spline_filter1d(input, order, axis, output, mode)</div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1e4074970ef924fb8a356fc60af1a60" name="aa1e4074970ef924fb8a356fc60af1a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e4074970ef924fb8a356fc60af1a60">&#9670;&#160;</a></span>zoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.ndimage._interpolation.zoom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zoom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefilter</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>grid_mode</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Zoom an array.

The array is zoomed using spline interpolation of the requested order.

Parameters
----------
%(input)s
zoom : float or sequence
    The zoom factor along the axes. If a float, `zoom` is the same for each
    axis. If a sequence, `zoom` should contain one value for each axis.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s
grid_mode : bool, optional
    If False, the distance from the pixel centers is zoomed. Otherwise, the
    distance including the full pixel extent is used. For example, a 1d
    signal of length 5 is considered to have length 4 when `grid_mode` is
    False, but length 5 when `grid_mode` is True. See the following
    visual illustration:

    .. code-block:: text

            | pixel 1 | pixel 2 | pixel 3 | pixel 4 | pixel 5 |
                 |&lt;--------------------------------------&gt;|
                                    vs.
            |&lt;-----------------------------------------------&gt;|

    The starting point of the arrow in the diagram above corresponds to
    coordinate location 0 in each mode.

Returns
-------
zoom : ndarray
    The zoomed input.

Notes
-----
For complex-valued `input`, this function zooms the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
&gt;&gt;&gt; from scipy import ndimage, misc
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side
&gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side
&gt;&gt;&gt; ascent = misc.ascent()
&gt;&gt;&gt; result = ndimage.zoom(ascent, 3.0)
&gt;&gt;&gt; ax1.imshow(ascent, vmin=0, vmax=255)
&gt;&gt;&gt; ax2.imshow(result, vmin=0, vmax=255)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; print(ascent.shape)
(512, 512)

&gt;&gt;&gt; print(result.shape)
(1536, 1536)
</pre> <div class="fragment"><div class="line"><span class="lineno">  693</span>         prefilter=<span class="keyword">True</span>, *, grid_mode=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  694</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    Zoom an array.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    The array is zoomed using spline interpolation of the requested order.</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    %(input)s</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    zoom : float or sequence</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        The zoom factor along the axes. If a float, `zoom` is the same for each</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        axis. If a sequence, `zoom` should contain one value for each axis.</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    %(output)s</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">        The order of the spline interpolation, default is 3.</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        The order has to be in the range 0-5.</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    %(mode_interp_constant)s</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    %(cval)s</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    %(prefilter)s</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    grid_mode : bool, optional</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        If False, the distance from the pixel centers is zoomed. Otherwise, the</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        distance including the full pixel extent is used. For example, a 1d</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">        signal of length 5 is considered to have length 4 when `grid_mode` is</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">        False, but length 5 when `grid_mode` is True. See the following</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        visual illustration:</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        .. code-block:: text</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">                | pixel 1 | pixel 2 | pixel 3 | pixel 4 | pixel 5 |</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">                     |&lt;--------------------------------------&gt;|</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">                                        vs.</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">                |&lt;-----------------------------------------------&gt;|</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">        The starting point of the arrow in the diagram above corresponds to</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">        coordinate location 0 in each mode.</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    zoom : ndarray</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">        The zoomed input.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    For complex-valued `input`, this function zooms the real and imaginary</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    components independently.</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        Complex-valued support added.</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import ndimage, misc</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    &gt;&gt;&gt; ascent = misc.ascent()</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    &gt;&gt;&gt; result = ndimage.zoom(ascent, 3.0)</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    &gt;&gt;&gt; ax1.imshow(ascent, vmin=0, vmax=255)</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    &gt;&gt;&gt; ax2.imshow(result, vmin=0, vmax=255)</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    &gt;&gt;&gt; print(ascent.shape)</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    (512, 512)</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    &gt;&gt;&gt; print(result.shape)</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    (1536, 1536)</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  762</span>    <span class="keywordflow">if</span> order &lt; 0 <span class="keywordflow">or</span> order &gt; 5:</div>
<div class="line"><span class="lineno">  763</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;spline order not supported&#39;</span>)</div>
<div class="line"><span class="lineno">  764</span>    input = numpy.asarray(input)</div>
<div class="line"><span class="lineno">  765</span>    <span class="keywordflow">if</span> input.ndim &lt; 1:</div>
<div class="line"><span class="lineno">  766</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;input and output rank must be &gt; 0&#39;</span>)</div>
<div class="line"><span class="lineno">  767</span>    zoom = _ni_support._normalize_sequence(zoom, input.ndim)</div>
<div class="line"><span class="lineno">  768</span>    output_shape = tuple(</div>
<div class="line"><span class="lineno">  769</span>            [int(round(ii * jj)) <span class="keywordflow">for</span> ii, jj <span class="keywordflow">in</span> zip(input.shape, zoom)])</div>
<div class="line"><span class="lineno">  770</span>    complex_output = numpy.iscomplexobj(input)</div>
<div class="line"><span class="lineno">  771</span>    output = _ni_support._get_output(output, input, shape=output_shape,</div>
<div class="line"><span class="lineno">  772</span>                                     complex_output=complex_output)</div>
<div class="line"><span class="lineno">  773</span>    <span class="keywordflow">if</span> complex_output:</div>
<div class="line"><span class="lineno">  774</span>        <span class="comment"># import under different name to avoid confusion with zoom parameter</span></div>
<div class="line"><span class="lineno">  775</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1ndimage_1_1__interpolation.html">scipy.ndimage._interpolation</a> <span class="keyword">import</span> zoom <span class="keyword">as</span> _zoom</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span>        kwargs = dict(order=order, mode=mode, prefilter=prefilter)</div>
<div class="line"><span class="lineno">  778</span>        _zoom(input.real, zoom, output=output.real, cval=numpy.real(cval),</div>
<div class="line"><span class="lineno">  779</span>              **kwargs)</div>
<div class="line"><span class="lineno">  780</span>        _zoom(input.imag, zoom, output=output.imag, cval=numpy.imag(cval),</div>
<div class="line"><span class="lineno">  781</span>              **kwargs)</div>
<div class="line"><span class="lineno">  782</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  783</span>    <span class="keywordflow">if</span> prefilter <span class="keywordflow">and</span> order &gt; 1:</div>
<div class="line"><span class="lineno">  784</span>        padded, npad = _prepad_for_spline_filter(input, mode, cval)</div>
<div class="line"><span class="lineno">  785</span>        filtered = spline_filter(padded, order, output=numpy.float64,</div>
<div class="line"><span class="lineno">  786</span>                                 mode=mode)</div>
<div class="line"><span class="lineno">  787</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  788</span>        npad = 0</div>
<div class="line"><span class="lineno">  789</span>        filtered = input</div>
<div class="line"><span class="lineno">  790</span>    <span class="keywordflow">if</span> grid_mode:</div>
<div class="line"><span class="lineno">  791</span>        <span class="comment"># warn about modes that may have surprising behavior</span></div>
<div class="line"><span class="lineno">  792</span>        suggest_mode = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  793</span>        <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;constant&#39;</span>:</div>
<div class="line"><span class="lineno">  794</span>            suggest_mode = <span class="stringliteral">&#39;grid-constant&#39;</span></div>
<div class="line"><span class="lineno">  795</span>        <span class="keywordflow">elif</span> mode == <span class="stringliteral">&#39;wrap&#39;</span>:</div>
<div class="line"><span class="lineno">  796</span>            suggest_mode = <span class="stringliteral">&#39;grid-wrap&#39;</span></div>
<div class="line"><span class="lineno">  797</span>        <span class="keywordflow">if</span> suggest_mode <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  798</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  799</span>                (<span class="stringliteral">&quot;It is recommended to use mode = {} instead of {} when &quot;</span></div>
<div class="line"><span class="lineno">  800</span>                 <span class="stringliteral">&quot;grid_mode is True.&quot;</span>).format(suggest_mode, mode)</div>
<div class="line"><span class="lineno">  801</span>            )</div>
<div class="line"><span class="lineno">  802</span>    mode = _ni_support._extend_mode_to_code(mode)</div>
<div class="line"><span class="lineno">  803</span> </div>
<div class="line"><span class="lineno">  804</span>    zoom_div = numpy.array(output_shape)</div>
<div class="line"><span class="lineno">  805</span>    zoom_nominator = numpy.array(input.shape)</div>
<div class="line"><span class="lineno">  806</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> grid_mode:</div>
<div class="line"><span class="lineno">  807</span>        zoom_div -= 1</div>
<div class="line"><span class="lineno">  808</span>        zoom_nominator -= 1</div>
<div class="line"><span class="lineno">  809</span> </div>
<div class="line"><span class="lineno">  810</span>    <span class="comment"># Zooming to infinite values is unpredictable, so just choose</span></div>
<div class="line"><span class="lineno">  811</span>    <span class="comment"># zoom factor 1 instead</span></div>
<div class="line"><span class="lineno">  812</span>    zoom = numpy.divide(zoom_nominator, zoom_div,</div>
<div class="line"><span class="lineno">  813</span>                        out=numpy.ones_like(input.shape, dtype=numpy.float64),</div>
<div class="line"><span class="lineno">  814</span>                        where=zoom_div != 0)</div>
<div class="line"><span class="lineno">  815</span>    zoom = numpy.ascontiguousarray(zoom)</div>
<div class="line"><span class="lineno">  816</span>    _nd_image.zoom_shift(filtered, zoom, <span class="keywordtype">None</span>, output, order, mode, cval, npad,</div>
<div class="line"><span class="lineno">  817</span>                         grid_mode)</div>
<div class="line"><span class="lineno">  818</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span> </div>
<div class="line"><span class="lineno">  821</span><span class="preprocessor">@docfiller</span></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
