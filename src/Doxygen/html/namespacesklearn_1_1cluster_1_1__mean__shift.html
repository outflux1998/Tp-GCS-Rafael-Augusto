<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.cluster._mean_shift Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster_1_1__mean__shift.html">_mean_shift</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.cluster._mean_shift Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__mean__shift_1_1_mean_shift.html">MeanShift</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac197d034b61f23f04c341c80c72b6419" id="r_ac197d034b61f23f04c341c80c72b6419"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__mean__shift.html#ac197d034b61f23f04c341c80c72b6419">estimate_bandwidth</a> (X, *quantile=0.3, n_samples=None, random_state=0, n_jobs=None)</td></tr>
<tr class="separator:ac197d034b61f23f04c341c80c72b6419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f179e7a61a25b0b1939dd7e47ce457d" id="r_a0f179e7a61a25b0b1939dd7e47ce457d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__mean__shift.html#a0f179e7a61a25b0b1939dd7e47ce457d">_mean_shift_single_seed</a> (my_mean, X, nbrs, max_iter)</td></tr>
<tr class="separator:a0f179e7a61a25b0b1939dd7e47ce457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb179536bed12e81a5a4e50cc10351b6" id="r_afb179536bed12e81a5a4e50cc10351b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__mean__shift.html#afb179536bed12e81a5a4e50cc10351b6">mean_shift</a> (X, *bandwidth=None, seeds=None, bin_seeding=False, min_bin_freq=1, cluster_all=True, max_iter=300, n_jobs=None)</td></tr>
<tr class="separator:afb179536bed12e81a5a4e50cc10351b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d24a14a2a17c4ff00fbaf79c31fea96" id="r_a0d24a14a2a17c4ff00fbaf79c31fea96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__mean__shift.html#a0d24a14a2a17c4ff00fbaf79c31fea96">get_bin_seeds</a> (X, bin_size, min_bin_freq=1)</td></tr>
<tr class="separator:a0d24a14a2a17c4ff00fbaf79c31fea96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Mean shift clustering algorithm.

Mean shift clustering aims to discover *blobs* in a smooth density of
samples. It is a centroid based algorithm, which works by updating candidates
for centroids to be the mean of the points within a given region. These
candidates are then filtered in a post-processing stage to eliminate
near-duplicates to form the final set of centroids.

Seeding is performed using a binning technique for scalability.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a0f179e7a61a25b0b1939dd7e47ce457d" name="a0f179e7a61a25b0b1939dd7e47ce457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f179e7a61a25b0b1939dd7e47ce457d">&#9670;&#160;</a></span>_mean_shift_single_seed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._mean_shift._mean_shift_single_seed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>my_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   89</span><span class="keyword">def </span>_mean_shift_single_seed(my_mean, X, nbrs, max_iter):</div>
<div class="line"><span class="lineno">   90</span>    <span class="comment"># For each seed, climb gradient until convergence or max_iter</span></div>
<div class="line"><span class="lineno">   91</span>    bandwidth = nbrs.get_params()[<span class="stringliteral">&quot;radius&quot;</span>]</div>
<div class="line"><span class="lineno">   92</span>    stop_thresh = 1e-3 * bandwidth  <span class="comment"># when mean has converged</span></div>
<div class="line"><span class="lineno">   93</span>    completed_iterations = 0</div>
<div class="line"><span class="lineno">   94</span>    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">   95</span>        <span class="comment"># Find mean of points within bandwidth</span></div>
<div class="line"><span class="lineno">   96</span>        i_nbrs = nbrs.radius_neighbors([my_mean], bandwidth, return_distance=<span class="keyword">False</span>)[0]</div>
<div class="line"><span class="lineno">   97</span>        points_within = X[i_nbrs]</div>
<div class="line"><span class="lineno">   98</span>        <span class="keywordflow">if</span> len(points_within) == 0:</div>
<div class="line"><span class="lineno">   99</span>            <span class="keywordflow">break</span>  <span class="comment"># Depending on seeding strategy this condition may occur</span></div>
<div class="line"><span class="lineno">  100</span>        my_old_mean = my_mean  <span class="comment"># save the old mean</span></div>
<div class="line"><span class="lineno">  101</span>        my_mean = np.mean(points_within, axis=0)</div>
<div class="line"><span class="lineno">  102</span>        <span class="comment"># If converged or at max_iter, adds the cluster</span></div>
<div class="line"><span class="lineno">  103</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  104</span>            np.linalg.norm(my_mean - my_old_mean) &lt; stop_thresh</div>
<div class="line"><span class="lineno">  105</span>            <span class="keywordflow">or</span> completed_iterations == max_iter</div>
<div class="line"><span class="lineno">  106</span>        ):</div>
<div class="line"><span class="lineno">  107</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  108</span>        completed_iterations += 1</div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordflow">return</span> tuple(my_mean), len(points_within), completed_iterations</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac197d034b61f23f04c341c80c72b6419" name="ac197d034b61f23f04c341c80c72b6419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac197d034b61f23f04c341c80c72b6419">&#9670;&#160;</a></span>estimate_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._mean_shift.estimate_bandwidth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>quantile</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_samples</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate the bandwidth to use with the mean-shift algorithm.

That this function takes time at least quadratic in n_samples. For large
datasets, it's wise to set that parameter to a small value.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Input points.

quantile : float, default=0.3
    Should be between [0, 1]
    0.5 means that the median of all pairwise distances is used.

n_samples : int, default=None
    The number of samples to use. If not given, all samples are used.

random_state : int, RandomState instance, default=None
    The generator used to randomly select the samples from input points
    for bandwidth estimation. Use an int to make the randomness
    deterministic.
    See :term:`Glossary &lt;random_state&gt;`.

n_jobs : int, default=None
    The number of parallel jobs to run for neighbors search.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

Returns
-------
bandwidth : float
    The bandwidth parameter.
</pre> <div class="fragment"><div class="line"><span class="lineno">   33</span><span class="keyword">def </span>estimate_bandwidth(X, *, quantile=0.3, n_samples=None, random_state=0, n_jobs=None):</div>
<div class="line"><span class="lineno">   34</span>    <span class="stringliteral">&quot;&quot;&quot;Estimate the bandwidth to use with the mean-shift algorithm.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    That this function takes time at least quadratic in n_samples. For large</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    datasets, it&#39;s wise to set that parameter to a small value.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        Input points.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    quantile : float, default=0.3</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        Should be between [0, 1]</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        0.5 means that the median of all pairwise distances is used.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    n_samples : int, default=None</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        The number of samples to use. If not given, all samples are used.</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    random_state : int, RandomState instance, default=None</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">        The generator used to randomly select the samples from input points</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        for bandwidth estimation. Use an int to make the randomness</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        deterministic.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">        See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        The number of parallel jobs to run for neighbors search.</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    bandwidth : float</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        The bandwidth parameter.</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   68</span>    X = check_array(X)</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">if</span> n_samples <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   72</span>        idx = random_state.permutation(X.shape[0])[:n_samples]</div>
<div class="line"><span class="lineno">   73</span>        X = X[idx]</div>
<div class="line"><span class="lineno">   74</span>    n_neighbors = int(X.shape[0] * quantile)</div>
<div class="line"><span class="lineno">   75</span>    <span class="keywordflow">if</span> n_neighbors &lt; 1:  <span class="comment"># cannot fit NearestNeighbors with n_neighbors = 0</span></div>
<div class="line"><span class="lineno">   76</span>        n_neighbors = 1</div>
<div class="line"><span class="lineno">   77</span>    nbrs = NearestNeighbors(n_neighbors=n_neighbors, n_jobs=n_jobs)</div>
<div class="line"><span class="lineno">   78</span>    nbrs.fit(X)</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>    bandwidth = 0.0</div>
<div class="line"><span class="lineno">   81</span>    <span class="keywordflow">for</span> batch <span class="keywordflow">in</span> gen_batches(len(X), 500):</div>
<div class="line"><span class="lineno">   82</span>        d, _ = nbrs.kneighbors(X[batch, :], return_distance=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">   83</span>        bandwidth += np.max(d, axis=1).sum()</div>
<div class="line"><span class="lineno">   84</span> </div>
<div class="line"><span class="lineno">   85</span>    <span class="keywordflow">return</span> bandwidth / X.shape[0]</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span><span class="comment"># separate function for each seed&#39;s iterative loop</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d24a14a2a17c4ff00fbaf79c31fea96" name="a0d24a14a2a17c4ff00fbaf79c31fea96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d24a14a2a17c4ff00fbaf79c31fea96">&#9670;&#160;</a></span>get_bin_seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._mean_shift.get_bin_seeds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_bin_freq</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find seeds for mean_shift.

Finds seeds by first binning data onto a grid whose lines are
spaced bin_size apart, and then choosing those bins with at least
min_bin_freq points.

Parameters
----------

X : array-like of shape (n_samples, n_features)
    Input points, the same points that will be used in mean_shift.

bin_size : float
    Controls the coarseness of the binning. Smaller values lead
    to more seeding (which is computationally more expensive). If you're
    not sure how to set this, set it to the value of the bandwidth used
    in clustering.mean_shift.

min_bin_freq : int, default=1
    Only bins with at least min_bin_freq will be selected as seeds.
    Raising this value decreases the number of seeds found, which
    makes mean_shift computationally cheaper.

Returns
-------
bin_seeds : array-like of shape (n_samples, n_features)
    Points used as initial kernel positions in clustering.mean_shift.
</pre> <div class="fragment"><div class="line"><span class="lineno">  204</span><span class="keyword">def </span>get_bin_seeds(X, bin_size, min_bin_freq=1):</div>
<div class="line"><span class="lineno">  205</span>    <span class="stringliteral">&quot;&quot;&quot;Find seeds for mean_shift.</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    Finds seeds by first binning data onto a grid whose lines are</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    spaced bin_size apart, and then choosing those bins with at least</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    min_bin_freq points.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        Input points, the same points that will be used in mean_shift.</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    bin_size : float</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        Controls the coarseness of the binning. Smaller values lead</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        to more seeding (which is computationally more expensive). If you&#39;re</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        not sure how to set this, set it to the value of the bandwidth used</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">        in clustering.mean_shift.</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    min_bin_freq : int, default=1</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">        Only bins with at least min_bin_freq will be selected as seeds.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">        Raising this value decreases the number of seeds found, which</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        makes mean_shift computationally cheaper.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    bin_seeds : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        Points used as initial kernel positions in clustering.mean_shift.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  233</span>    <span class="keywordflow">if</span> bin_size == 0:</div>
<div class="line"><span class="lineno">  234</span>        <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span>    <span class="comment"># Bin points</span></div>
<div class="line"><span class="lineno">  237</span>    bin_sizes = defaultdict(int)</div>
<div class="line"><span class="lineno">  238</span>    <span class="keywordflow">for</span> point <span class="keywordflow">in</span> X:</div>
<div class="line"><span class="lineno">  239</span>        binned_point = np.round(point / bin_size)</div>
<div class="line"><span class="lineno">  240</span>        bin_sizes[tuple(binned_point)] += 1</div>
<div class="line"><span class="lineno">  241</span> </div>
<div class="line"><span class="lineno">  242</span>    <span class="comment"># Select only those bins as seeds which have enough members</span></div>
<div class="line"><span class="lineno">  243</span>    bin_seeds = np.array(</div>
<div class="line"><span class="lineno">  244</span>        [point <span class="keywordflow">for</span> point, freq <span class="keywordflow">in</span> bin_sizes.items() <span class="keywordflow">if</span> freq &gt;= min_bin_freq],</div>
<div class="line"><span class="lineno">  245</span>        dtype=np.float32,</div>
<div class="line"><span class="lineno">  246</span>    )</div>
<div class="line"><span class="lineno">  247</span>    <span class="keywordflow">if</span> len(bin_seeds) == len(X):</div>
<div class="line"><span class="lineno">  248</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  249</span>            <span class="stringliteral">&quot;Binning data failed with provided bin_size=%f, using data points as seeds.&quot;</span></div>
<div class="line"><span class="lineno">  250</span>            % bin_size</div>
<div class="line"><span class="lineno">  251</span>        )</div>
<div class="line"><span class="lineno">  252</span>        <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno">  253</span>    bin_seeds = bin_seeds * bin_size</div>
<div class="line"><span class="lineno">  254</span>    <span class="keywordflow">return</span> bin_seeds</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afb179536bed12e81a5a4e50cc10351b6" name="afb179536bed12e81a5a4e50cc10351b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb179536bed12e81a5a4e50cc10351b6">&#9670;&#160;</a></span>mean_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._mean_shift.mean_shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>bandwidth</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seeds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bin_seeding</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_bin_freq</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cluster_all</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>300</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform mean shift clustering of data using a flat kernel.

Read more in the :ref:`User Guide &lt;mean_shift&gt;`.

Parameters
----------

X : array-like of shape (n_samples, n_features)
    Input data.

bandwidth : float, default=None
    Kernel bandwidth.

    If bandwidth is not given, it is determined using a heuristic based on
    the median of all pairwise distances. This will take quadratic time in
    the number of samples. The sklearn.cluster.estimate_bandwidth function
    can be used to do this more efficiently.

seeds : array-like of shape (n_seeds, n_features) or None
    Point used as initial kernel locations. If None and bin_seeding=False,
    each data point is used as a seed. If None and bin_seeding=True,
    see bin_seeding.

bin_seeding : bool, default=False
    If true, initial kernel locations are not locations of all
    points, but rather the location of the discretized version of
    points, where points are binned onto a grid whose coarseness
    corresponds to the bandwidth. Setting this option to True will speed
    up the algorithm because fewer seeds will be initialized.
    Ignored if seeds argument is not None.

min_bin_freq : int, default=1
   To speed up the algorithm, accept only those bins with at least
   min_bin_freq points as seeds.

cluster_all : bool, default=True
    If true, then all points are clustered, even those orphans that are
    not within any kernel. Orphans are assigned to the nearest kernel.
    If false, then orphans are given cluster label -1.

max_iter : int, default=300
    Maximum number of iterations, per seed point before the clustering
    operation terminates (for that seed point), if has not converged yet.

n_jobs : int, default=None
    The number of jobs to use for the computation. This works by computing
    each of the n_init runs in parallel.

    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

    .. versionadded:: 0.17
       Parallel Execution using *n_jobs*.

Returns
-------

cluster_centers : ndarray of shape (n_clusters, n_features)
    Coordinates of cluster centers.

labels : ndarray of shape (n_samples,)
    Cluster labels for each point.

Notes
-----
For an example, see :ref:`examples/cluster/plot_mean_shift.py
&lt;sphx_glr_auto_examples_cluster_plot_mean_shift.py&gt;`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  122</span>):</div>
<div class="line"><span class="lineno">  123</span>    <span class="stringliteral">&quot;&quot;&quot;Perform mean shift clustering of data using a flat kernel.</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;mean_shift&gt;`.</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    bandwidth : float, default=None</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">        Kernel bandwidth.</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        If bandwidth is not given, it is determined using a heuristic based on</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        the median of all pairwise distances. This will take quadratic time in</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        the number of samples. The sklearn.cluster.estimate_bandwidth function</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        can be used to do this more efficiently.</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    seeds : array-like of shape (n_seeds, n_features) or None</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">        Point used as initial kernel locations. If None and bin_seeding=False,</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        each data point is used as a seed. If None and bin_seeding=True,</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        see bin_seeding.</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    bin_seeding : bool, default=False</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">        If true, initial kernel locations are not locations of all</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">        points, but rather the location of the discretized version of</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        points, where points are binned onto a grid whose coarseness</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">        corresponds to the bandwidth. Setting this option to True will speed</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        up the algorithm because fewer seeds will be initialized.</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        Ignored if seeds argument is not None.</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    min_bin_freq : int, default=1</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">       To speed up the algorithm, accept only those bins with at least</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">       min_bin_freq points as seeds.</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    cluster_all : bool, default=True</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">        If true, then all points are clustered, even those orphans that are</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        not within any kernel. Orphans are assigned to the nearest kernel.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        If false, then orphans are given cluster label -1.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    max_iter : int, default=300</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">        Maximum number of iterations, per seed point before the clustering</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        operation terminates (for that seed point), if has not converged yet.</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        The number of jobs to use for the computation. This works by computing</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        each of the n_init runs in parallel.</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        .. versionadded:: 0.17</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">           Parallel Execution using *n_jobs*.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    cluster_centers : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        Coordinates of cluster centers.</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    labels : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        Cluster labels for each point.</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    For an example, see :ref:`examples/cluster/plot_mean_shift.py</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    &lt;sphx_glr_auto_examples_cluster_plot_mean_shift.py&gt;`.</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  192</span>    model = MeanShift(</div>
<div class="line"><span class="lineno">  193</span>        bandwidth=bandwidth,</div>
<div class="line"><span class="lineno">  194</span>        seeds=seeds,</div>
<div class="line"><span class="lineno">  195</span>        min_bin_freq=min_bin_freq,</div>
<div class="line"><span class="lineno">  196</span>        bin_seeding=bin_seeding,</div>
<div class="line"><span class="lineno">  197</span>        cluster_all=cluster_all,</div>
<div class="line"><span class="lineno">  198</span>        n_jobs=n_jobs,</div>
<div class="line"><span class="lineno">  199</span>        max_iter=max_iter,</div>
<div class="line"><span class="lineno">  200</span>    ).fit(X)</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">return</span> model.cluster_centers_, model.labels_</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
