<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.indexing._iLocIndexer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1indexing.html">indexing</a></li><li class="navelem"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html">_iLocIndexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.indexing._iLocIndexer Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for pandas.core.indexing._iLocIndexer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.png" usemap="#pandas.core.indexing._5FiLocIndexer_map" alt=""/>
  <map id="pandas.core.indexing._5FiLocIndexer_map" name="pandas.core.indexing._5FiLocIndexer_map">
<area href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html" alt="pandas.core.indexing._LocationIndexer" shape="rect" coords="0,56,235,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a586e87f31d0b2ce0c6b0b77307b6f220" id="r_a586e87f31d0b2ce0c6b0b77307b6f220"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a586e87f31d0b2ce0c6b0b77307b6f220">obj</a></td></tr>
<tr class="separator:a586e87f31d0b2ce0c6b0b77307b6f220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3c2b6498bb5aaa62c5e5385fa9cef5" id="r_a5f3c2b6498bb5aaa62c5e5385fa9cef5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a5f3c2b6498bb5aaa62c5e5385fa9cef5">ndim</a></td></tr>
<tr class="separator:a5f3c2b6498bb5aaa62c5e5385fa9cef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html">pandas.core.indexing._LocationIndexer</a></td></tr>
<tr class="memitem:abd642e5f397c58862e1606b8d4ff25fd inherit pub_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_abd642e5f397c58862e1606b8d4ff25fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#abd642e5f397c58862e1606b8d4ff25fd">name</a></td></tr>
<tr class="separator:abd642e5f397c58862e1606b8d4ff25fd inherit pub_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40075186c45c8443cdd4aaa9516cbfc inherit pub_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_aa40075186c45c8443cdd4aaa9516cbfc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#aa40075186c45c8443cdd4aaa9516cbfc">obj</a></td></tr>
<tr class="separator:aa40075186c45c8443cdd4aaa9516cbfc inherit pub_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2ccd1233b1a2a8344513c2d353022ecf" id="r_a2ccd1233b1a2a8344513c2d353022ecf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a2ccd1233b1a2a8344513c2d353022ecf">_validate_key</a> (self, key, int <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>)</td></tr>
<tr class="separator:a2ccd1233b1a2a8344513c2d353022ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cfa4eb461b6f32e92f6e07a10be362" id="r_ad8cfa4eb461b6f32e92f6e07a10be362"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#ad8cfa4eb461b6f32e92f6e07a10be362">_has_valid_setitem_indexer</a> (self, indexer)</td></tr>
<tr class="separator:ad8cfa4eb461b6f32e92f6e07a10be362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e18c18328183de1da9ebfc4b5575e8" id="r_a48e18c18328183de1da9ebfc4b5575e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a48e18c18328183de1da9ebfc4b5575e8">_is_scalar_access</a> (self, tuple key)</td></tr>
<tr class="separator:a48e18c18328183de1da9ebfc4b5575e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29976f350693bb5eb9b2b031259193d5" id="r_a29976f350693bb5eb9b2b031259193d5"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a29976f350693bb5eb9b2b031259193d5">_validate_integer</a> (self, int key, int <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>)</td></tr>
<tr class="separator:a29976f350693bb5eb9b2b031259193d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d285f468a90f750cb07756ddf848c5" id="r_a95d285f468a90f750cb07756ddf848c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a95d285f468a90f750cb07756ddf848c5">_getitem_tuple</a> (self, tuple tup)</td></tr>
<tr class="separator:a95d285f468a90f750cb07756ddf848c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce9f71ef5d33d158eab5dcb7a061932" id="r_a2ce9f71ef5d33d158eab5dcb7a061932"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a2ce9f71ef5d33d158eab5dcb7a061932">_get_list_axis</a> (self, key, int <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>)</td></tr>
<tr class="separator:a2ce9f71ef5d33d158eab5dcb7a061932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5b3d9b9d2654895f2e956554ab0e7a" id="r_aab5b3d9b9d2654895f2e956554ab0e7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#aab5b3d9b9d2654895f2e956554ab0e7a">_getitem_axis</a> (self, key, int <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>)</td></tr>
<tr class="separator:aab5b3d9b9d2654895f2e956554ab0e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9e2c990d7c20846a0ce2a0ef2a3819" id="r_a4a9e2c990d7c20846a0ce2a0ef2a3819"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a4a9e2c990d7c20846a0ce2a0ef2a3819">_get_slice_axis</a> (self, slice slice_obj, int <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>)</td></tr>
<tr class="separator:a4a9e2c990d7c20846a0ce2a0ef2a3819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cce5a07097d271ad2d803f4a1fc9c4" id="r_a08cce5a07097d271ad2d803f4a1fc9c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a08cce5a07097d271ad2d803f4a1fc9c4">_convert_to_indexer</a> (self, key, int <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>)</td></tr>
<tr class="separator:a08cce5a07097d271ad2d803f4a1fc9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11538c2c502de5f62d103ca3f7a80434" id="r_a11538c2c502de5f62d103ca3f7a80434"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a11538c2c502de5f62d103ca3f7a80434">_get_setitem_indexer</a> (self, key)</td></tr>
<tr class="separator:a11538c2c502de5f62d103ca3f7a80434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a5edea974f55e669073bb441c98501" id="r_a35a5edea974f55e669073bb441c98501"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a35a5edea974f55e669073bb441c98501">_setitem_with_indexer</a> (self, indexer, value, <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#abd642e5f397c58862e1606b8d4ff25fd">name</a>=&quot;iloc&quot;)</td></tr>
<tr class="separator:a35a5edea974f55e669073bb441c98501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f18b43137aab9313af2750d73ad545" id="r_ac3f18b43137aab9313af2750d73ad545"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#ac3f18b43137aab9313af2750d73ad545">_setitem_with_indexer_split_path</a> (self, indexer, value, str <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#abd642e5f397c58862e1606b8d4ff25fd">name</a>)</td></tr>
<tr class="separator:ac3f18b43137aab9313af2750d73ad545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab995a80d18e7dedda92a9b59380e66cd" id="r_ab995a80d18e7dedda92a9b59380e66cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#ab995a80d18e7dedda92a9b59380e66cd">_setitem_with_indexer_2d_value</a> (self, indexer, value)</td></tr>
<tr class="separator:ab995a80d18e7dedda92a9b59380e66cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa5ffc8fcaa86b2f17f3b657e05a58b" id="r_a5fa5ffc8fcaa86b2f17f3b657e05a58b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a5fa5ffc8fcaa86b2f17f3b657e05a58b">_setitem_with_indexer_frame_value</a> (self, indexer, DataFrame value, str <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#abd642e5f397c58862e1606b8d4ff25fd">name</a>)</td></tr>
<tr class="separator:a5fa5ffc8fcaa86b2f17f3b657e05a58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2a1e441e9547c23ac9161d01ad8318" id="r_adb2a1e441e9547c23ac9161d01ad8318"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#adb2a1e441e9547c23ac9161d01ad8318">_setitem_single_column</a> (self, int loc, value, plane_indexer)</td></tr>
<tr class="separator:adb2a1e441e9547c23ac9161d01ad8318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ac78bd7ece37c80942ae425c117dbb" id="r_a67ac78bd7ece37c80942ae425c117dbb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a67ac78bd7ece37c80942ae425c117dbb">_setitem_single_block</a> (self, indexer, value, str <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#abd642e5f397c58862e1606b8d4ff25fd">name</a>)</td></tr>
<tr class="separator:a67ac78bd7ece37c80942ae425c117dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae280667ca4dbe740f5cfb7ac949c529f" id="r_ae280667ca4dbe740f5cfb7ac949c529f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#ae280667ca4dbe740f5cfb7ac949c529f">_setitem_with_indexer_missing</a> (self, indexer, value)</td></tr>
<tr class="separator:ae280667ca4dbe740f5cfb7ac949c529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fc43436fe25547cca6a5cba700304a" id="r_a01fc43436fe25547cca6a5cba700304a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a01fc43436fe25547cca6a5cba700304a">_ensure_iterable_column_indexer</a> (self, column_indexer)</td></tr>
<tr class="separator:a01fc43436fe25547cca6a5cba700304a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aa3525fd5b49c891ef68661732fdbf" id="r_a67aa3525fd5b49c891ef68661732fdbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a67aa3525fd5b49c891ef68661732fdbf">_align_series</a> (self, indexer, Series ser, bool multiindex_indexer=False)</td></tr>
<tr class="separator:a67aa3525fd5b49c891ef68661732fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c43ab5b8d679207871effa1240eed7" id="r_a03c43ab5b8d679207871effa1240eed7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a03c43ab5b8d679207871effa1240eed7">_align_frame</a> (self, indexer, DataFrame <a class="el" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>)</td></tr>
<tr class="separator:a03c43ab5b8d679207871effa1240eed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html">pandas.core.indexing._LocationIndexer</a></td></tr>
<tr class="memitem:a3cbe52b3650cdeeda38d7127b5e54721 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a3cbe52b3650cdeeda38d7127b5e54721"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a3cbe52b3650cdeeda38d7127b5e54721">_maybe_mask_setitem_value</a> (self, indexer, value)</td></tr>
<tr class="separator:a3cbe52b3650cdeeda38d7127b5e54721 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894655dc320da996b3dc8b1bfcc71dd8 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a894655dc320da996b3dc8b1bfcc71dd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a894655dc320da996b3dc8b1bfcc71dd8">_ensure_listlike_indexer</a> (self, key, <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>=None, value=None)</td></tr>
<tr class="separator:a894655dc320da996b3dc8b1bfcc71dd8 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4c65c105268a27d97535cee14cdc89 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a0e4c65c105268a27d97535cee14cdc89"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a0e4c65c105268a27d97535cee14cdc89">_expand_ellipsis</a> (self, tuple tup)</td></tr>
<tr class="separator:a0e4c65c105268a27d97535cee14cdc89 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d737474a8362ca5d894d7c3cecbd1a inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a49d737474a8362ca5d894d7c3cecbd1a"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a49d737474a8362ca5d894d7c3cecbd1a">_validate_tuple_indexer</a> (self, tuple key)</td></tr>
<tr class="separator:a49d737474a8362ca5d894d7c3cecbd1a inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295ccf8ea8d429847cf444dd999979ec inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a295ccf8ea8d429847cf444dd999979ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a295ccf8ea8d429847cf444dd999979ec">_is_nested_tuple_indexer</a> (self, tuple tup)</td></tr>
<tr class="separator:a295ccf8ea8d429847cf444dd999979ec inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795250f720cde1940f5fbbb6185f8de0 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a795250f720cde1940f5fbbb6185f8de0"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a795250f720cde1940f5fbbb6185f8de0">_convert_tuple</a> (self, tuple key)</td></tr>
<tr class="separator:a795250f720cde1940f5fbbb6185f8de0 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341b642a241976b767a76656fa370061 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a341b642a241976b767a76656fa370061"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a341b642a241976b767a76656fa370061">_validate_key_length</a> (self, tuple key)</td></tr>
<tr class="separator:a341b642a241976b767a76656fa370061 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac99e92755a7530b65a47b12b7e2063 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a4ac99e92755a7530b65a47b12b7e2063"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a4ac99e92755a7530b65a47b12b7e2063">_getitem_tuple_same_dim</a> (self, tuple tup)</td></tr>
<tr class="separator:a4ac99e92755a7530b65a47b12b7e2063 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00ab5cad68aa0adf7d66812da09d8bc inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_ae00ab5cad68aa0adf7d66812da09d8bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#ae00ab5cad68aa0adf7d66812da09d8bc">_getitem_lowerdim</a> (self, tuple tup)</td></tr>
<tr class="separator:ae00ab5cad68aa0adf7d66812da09d8bc inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03cc2f47bfc5d57bbffc48f69b6a541 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_ab03cc2f47bfc5d57bbffc48f69b6a541"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#ab03cc2f47bfc5d57bbffc48f69b6a541">_getitem_nested_tuple</a> (self, tuple tup)</td></tr>
<tr class="separator:ab03cc2f47bfc5d57bbffc48f69b6a541 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3496eed5938cfe97619b2b9ac089ca3 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_af3496eed5938cfe97619b2b9ac089ca3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af3496eed5938cfe97619b2b9ac089ca3">_getbool_axis</a> (self, key, int <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>)</td></tr>
<tr class="separator:af3496eed5938cfe97619b2b9ac089ca3 inherit pro_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a0e454324629549665c259133462e300c" id="r_a0e454324629549665c259133462e300c"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a0e454324629549665c259133462e300c">_valid_types</a></td></tr>
<tr class="separator:a0e454324629549665c259133462e300c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3dca75aac7538d60f5a085c09ee968" id="r_a1f3dca75aac7538d60f5a085c09ee968"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1__i_loc_indexer.html#a1f3dca75aac7538d60f5a085c09ee968">_takeable</a> = True</td></tr>
<tr class="separator:a1f3dca75aac7538d60f5a085c09ee968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html">pandas.core.indexing._LocationIndexer</a></td></tr>
<tr class="memitem:a2aac73c97f71c5ddc0753298537255cf inherit pro_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a2aac73c97f71c5ddc0753298537255cf"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a2aac73c97f71c5ddc0753298537255cf">_valid_types</a></td></tr>
<tr class="separator:a2aac73c97f71c5ddc0753298537255cf inherit pro_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc23b0efd2d59874fc24eb4267119f7 inherit pro_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a6fc23b0efd2d59874fc24eb4267119f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a6fc23b0efd2d59874fc24eb4267119f7">_takeable</a></td></tr>
<tr class="separator:a6fc23b0efd2d59874fc24eb4267119f7 inherit pro_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html">pandas.core.indexing._LocationIndexer</a></td></tr>
<tr class="memitem:aef1290b0668f2b0e97eb0d82e9b0898c inherit pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_aef1290b0668f2b0e97eb0d82e9b0898c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexing.html#a1d06f323106bc63b705f7e11780b7346">_LocationIndexerT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#aef1290b0668f2b0e97eb0d82e9b0898c">__call__</a> (<a class="el" href="namespacepandas_1_1core_1_1indexing.html#a1d06f323106bc63b705f7e11780b7346">_LocationIndexerT</a> self, <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a>=None)</td></tr>
<tr class="separator:aef1290b0668f2b0e97eb0d82e9b0898c inherit pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7315d6108ec07755a6626ad6cd4b77de inherit pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a7315d6108ec07755a6626ad6cd4b77de"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a7315d6108ec07755a6626ad6cd4b77de">__setitem__</a> (self, key, value)</td></tr>
<tr class="separator:a7315d6108ec07755a6626ad6cd4b77de inherit pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9e45f0c90ce61b0e9c4a140e1b72a9 inherit pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_a8a9e45f0c90ce61b0e9c4a140e1b72a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a8a9e45f0c90ce61b0e9c4a140e1b72a9">__getitem__</a> (self, key)</td></tr>
<tr class="separator:a8a9e45f0c90ce61b0e9c4a140e1b72a9 inherit pub_methods_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html">pandas.core.indexing._LocationIndexer</a></td></tr>
<tr class="memitem:af02c714d342108bc2684700ed7a4ac7e inherit pub_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer" id="r_af02c714d342108bc2684700ed7a4ac7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af02c714d342108bc2684700ed7a4ac7e">axis</a> = None</td></tr>
<tr class="separator:af02c714d342108bc2684700ed7a4ac7e inherit pub_static_attribs_classpandas_1_1core_1_1indexing_1_1___location_indexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a03c43ab5b8d679207871effa1240eed7" name="a03c43ab5b8d679207871effa1240eed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c43ab5b8d679207871effa1240eed7">&#9670;&#160;</a></span>_align_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._align_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataFrame&#160;</td>
          <td class="paramname"><em>df</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2308</span>    <span class="keyword">def </span>_align_frame(self, indexer, df: DataFrame):</div>
<div class="line"><span class="lineno"> 2309</span>        is_frame = self.ndim == 2</div>
<div class="line"><span class="lineno"> 2310</span> </div>
<div class="line"><span class="lineno"> 2311</span>        <span class="keywordflow">if</span> isinstance(indexer, tuple):</div>
<div class="line"><span class="lineno"> 2312</span> </div>
<div class="line"><span class="lineno"> 2313</span>            idx, cols = <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2314</span>            sindexers = []</div>
<div class="line"><span class="lineno"> 2315</span>            <span class="keywordflow">for</span> i, ix <span class="keywordflow">in</span> enumerate(indexer):</div>
<div class="line"><span class="lineno"> 2316</span>                ax = self.obj.axes[i]</div>
<div class="line"><span class="lineno"> 2317</span>                <span class="keywordflow">if</span> is_sequence(ix) <span class="keywordflow">or</span> isinstance(ix, slice):</div>
<div class="line"><span class="lineno"> 2318</span>                    <span class="keywordflow">if</span> isinstance(ix, np.ndarray):</div>
<div class="line"><span class="lineno"> 2319</span>                        ix = ix.ravel()</div>
<div class="line"><span class="lineno"> 2320</span>                    <span class="keywordflow">if</span> idx <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2321</span>                        idx = ax[ix]</div>
<div class="line"><span class="lineno"> 2322</span>                    <span class="keywordflow">elif</span> cols <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2323</span>                        cols = ax[ix]</div>
<div class="line"><span class="lineno"> 2324</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2325</span>                        <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 2326</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2327</span>                    sindexers.append(i)</div>
<div class="line"><span class="lineno"> 2328</span> </div>
<div class="line"><span class="lineno"> 2329</span>            <span class="keywordflow">if</span> idx <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> cols <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2330</span> </div>
<div class="line"><span class="lineno"> 2331</span>                <span class="keywordflow">if</span> df.index.equals(idx) <span class="keywordflow">and</span> df.columns.equals(cols):</div>
<div class="line"><span class="lineno"> 2332</span>                    val = df.copy()._values</div>
<div class="line"><span class="lineno"> 2333</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2334</span>                    val = df.reindex(idx, columns=cols)._values</div>
<div class="line"><span class="lineno"> 2335</span>                <span class="keywordflow">return</span> val</div>
<div class="line"><span class="lineno"> 2336</span> </div>
<div class="line"><span class="lineno"> 2337</span>        <span class="keywordflow">elif</span> (isinstance(indexer, slice) <span class="keywordflow">or</span> is_list_like_indexer(indexer)) <span class="keywordflow">and</span> is_frame:</div>
<div class="line"><span class="lineno"> 2338</span>            ax = self.obj.index[indexer]</div>
<div class="line"><span class="lineno"> 2339</span>            <span class="keywordflow">if</span> df.index.equals(ax):</div>
<div class="line"><span class="lineno"> 2340</span>                val = df.copy()._values</div>
<div class="line"><span class="lineno"> 2341</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2342</span> </div>
<div class="line"><span class="lineno"> 2343</span>                <span class="comment"># we have a multi-index and are trying to align</span></div>
<div class="line"><span class="lineno"> 2344</span>                <span class="comment"># with a particular, level GH3738</span></div>
<div class="line"><span class="lineno"> 2345</span>                <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 2346</span>                    isinstance(ax, MultiIndex)</div>
<div class="line"><span class="lineno"> 2347</span>                    <span class="keywordflow">and</span> isinstance(df.index, MultiIndex)</div>
<div class="line"><span class="lineno"> 2348</span>                    <span class="keywordflow">and</span> ax.nlevels != df.index.nlevels</div>
<div class="line"><span class="lineno"> 2349</span>                ):</div>
<div class="line"><span class="lineno"> 2350</span>                    <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 2351</span>                        <span class="stringliteral">&quot;cannot align on a multi-index with out &quot;</span></div>
<div class="line"><span class="lineno"> 2352</span>                        <span class="stringliteral">&quot;specifying the join levels&quot;</span></div>
<div class="line"><span class="lineno"> 2353</span>                    )</div>
<div class="line"><span class="lineno"> 2354</span> </div>
<div class="line"><span class="lineno"> 2355</span>                val = df.reindex(index=ax)._values</div>
<div class="line"><span class="lineno"> 2356</span>            <span class="keywordflow">return</span> val</div>
<div class="line"><span class="lineno"> 2357</span> </div>
<div class="line"><span class="lineno"> 2358</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Incompatible indexer with DataFrame&quot;</span>)</div>
<div class="line"><span class="lineno"> 2359</span> </div>
<div class="line"><span class="lineno"> 2360</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a67aa3525fd5b49c891ef68661732fdbf" name="a67aa3525fd5b49c891ef68661732fdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67aa3525fd5b49c891ef68661732fdbf">&#9670;&#160;</a></span>_align_series()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._align_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Series&#160;</td>
          <td class="paramname"><em>ser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>multiindex_indexer</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
indexer : tuple, slice, scalar
    Indexer used to get the locations that will be set to `ser`.
ser : pd.Series
    Values to assign to the locations specified by `indexer`.
multiindex_indexer : bool, optional
    Defaults to False. Should be set to True if `indexer` was from
    a `pd.MultiIndex`, to avoid unnecessary broadcasting.

Returns
-------
`np.array` of `ser` broadcast to the appropriate shape for assignment
to the locations selected by `indexer`
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2202</span>    <span class="keyword">def </span>_align_series(self, indexer, ser: Series, multiindex_indexer: bool = <span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 2203</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2204</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2206</span><span class="stringliteral">        indexer : tuple, slice, scalar</span></div>
<div class="line"><span class="lineno"> 2207</span><span class="stringliteral">            Indexer used to get the locations that will be set to `ser`.</span></div>
<div class="line"><span class="lineno"> 2208</span><span class="stringliteral">        ser : pd.Series</span></div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral">            Values to assign to the locations specified by `indexer`.</span></div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral">        multiindex_indexer : bool, optional</span></div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">            Defaults to False. Should be set to True if `indexer` was from</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral">            a `pd.MultiIndex`, to avoid unnecessary broadcasting.</span></div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">        `np.array` of `ser` broadcast to the appropriate shape for assignment</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral">        to the locations selected by `indexer`</span></div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2219</span>        <span class="keywordflow">if</span> isinstance(indexer, (slice, np.ndarray, list, Index)):</div>
<div class="line"><span class="lineno"> 2220</span>            indexer = (indexer,)</div>
<div class="line"><span class="lineno"> 2221</span> </div>
<div class="line"><span class="lineno"> 2222</span>        <span class="keywordflow">if</span> isinstance(indexer, tuple):</div>
<div class="line"><span class="lineno"> 2223</span> </div>
<div class="line"><span class="lineno"> 2224</span>            <span class="comment"># flatten np.ndarray indexers</span></div>
<div class="line"><span class="lineno"> 2225</span>            <span class="keyword">def </span>ravel(i):</div>
<div class="line"><span class="lineno"> 2226</span>                <span class="keywordflow">return</span> i.ravel() <span class="keywordflow">if</span> isinstance(i, np.ndarray) <span class="keywordflow">else</span> i</div>
<div class="line"><span class="lineno"> 2227</span> </div>
<div class="line"><span class="lineno"> 2228</span>            indexer = tuple(map(ravel, indexer))</div>
<div class="line"><span class="lineno"> 2229</span> </div>
<div class="line"><span class="lineno"> 2230</span>            aligners = [<span class="keywordflow">not</span> com.is_null_slice(idx) <span class="keywordflow">for</span> idx <span class="keywordflow">in</span> indexer]</div>
<div class="line"><span class="lineno"> 2231</span>            sum_aligners = sum(aligners)</div>
<div class="line"><span class="lineno"> 2232</span>            single_aligner = sum_aligners == 1</div>
<div class="line"><span class="lineno"> 2233</span>            is_frame = self.ndim == 2</div>
<div class="line"><span class="lineno"> 2234</span>            obj = self.obj</div>
<div class="line"><span class="lineno"> 2235</span> </div>
<div class="line"><span class="lineno"> 2236</span>            <span class="comment"># are we a single alignable value on a non-primary</span></div>
<div class="line"><span class="lineno"> 2237</span>            <span class="comment"># dim (e.g. panel: 1,2, or frame: 0) ?</span></div>
<div class="line"><span class="lineno"> 2238</span>            <span class="comment"># hence need to align to a single axis dimension</span></div>
<div class="line"><span class="lineno"> 2239</span>            <span class="comment"># rather that find all valid dims</span></div>
<div class="line"><span class="lineno"> 2240</span> </div>
<div class="line"><span class="lineno"> 2241</span>            <span class="comment"># frame</span></div>
<div class="line"><span class="lineno"> 2242</span>            <span class="keywordflow">if</span> is_frame:</div>
<div class="line"><span class="lineno"> 2243</span>                single_aligner = single_aligner <span class="keywordflow">and</span> aligners[0]</div>
<div class="line"><span class="lineno"> 2244</span> </div>
<div class="line"><span class="lineno"> 2245</span>            <span class="comment"># we have a frame, with multiple indexers on both axes; and a</span></div>
<div class="line"><span class="lineno"> 2246</span>            <span class="comment"># series, so need to broadcast (see GH5206)</span></div>
<div class="line"><span class="lineno"> 2247</span>            <span class="keywordflow">if</span> sum_aligners == self.ndim <span class="keywordflow">and</span> all(is_sequence(_) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> indexer):</div>
<div class="line"><span class="lineno"> 2248</span>                <span class="comment"># TODO: This is hacky, align Series and DataFrame behavior GH#45778</span></div>
<div class="line"><span class="lineno"> 2249</span>                <span class="keywordflow">if</span> obj.ndim == 2 <span class="keywordflow">and</span> is_empty_indexer(indexer[0]):</div>
<div class="line"><span class="lineno"> 2250</span>                    <span class="keywordflow">return</span> ser._values.copy()</div>
<div class="line"><span class="lineno"> 2251</span>                ser_values = ser.reindex(obj.axes[0][indexer[0]], copy=<span class="keyword">True</span>)._values</div>
<div class="line"><span class="lineno"> 2252</span> </div>
<div class="line"><span class="lineno"> 2253</span>                <span class="comment"># single indexer</span></div>
<div class="line"><span class="lineno"> 2254</span>                <span class="keywordflow">if</span> len(indexer) &gt; 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> multiindex_indexer:</div>
<div class="line"><span class="lineno"> 2255</span>                    len_indexer = len(indexer[1])</div>
<div class="line"><span class="lineno"> 2256</span>                    ser_values = (</div>
<div class="line"><span class="lineno"> 2257</span>                        np.tile(ser_values, len_indexer).reshape(len_indexer, -1).T</div>
<div class="line"><span class="lineno"> 2258</span>                    )</div>
<div class="line"><span class="lineno"> 2259</span> </div>
<div class="line"><span class="lineno"> 2260</span>                <span class="keywordflow">return</span> ser_values</div>
<div class="line"><span class="lineno"> 2261</span> </div>
<div class="line"><span class="lineno"> 2262</span>            <span class="keywordflow">for</span> i, idx <span class="keywordflow">in</span> enumerate(indexer):</div>
<div class="line"><span class="lineno"> 2263</span>                ax = obj.axes[i]</div>
<div class="line"><span class="lineno"> 2264</span> </div>
<div class="line"><span class="lineno"> 2265</span>                <span class="comment"># multiple aligners (or null slices)</span></div>
<div class="line"><span class="lineno"> 2266</span>                <span class="keywordflow">if</span> is_sequence(idx) <span class="keywordflow">or</span> isinstance(idx, slice):</div>
<div class="line"><span class="lineno"> 2267</span>                    <span class="keywordflow">if</span> single_aligner <span class="keywordflow">and</span> com.is_null_slice(idx):</div>
<div class="line"><span class="lineno"> 2268</span>                        <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2269</span>                    new_ix = ax[idx]</div>
<div class="line"><span class="lineno"> 2270</span>                    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like_indexer(new_ix):</div>
<div class="line"><span class="lineno"> 2271</span>                        new_ix = Index([new_ix])</div>
<div class="line"><span class="lineno"> 2272</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2273</span>                        new_ix = Index(new_ix)</div>
<div class="line"><span class="lineno"> 2274</span>                    <span class="keywordflow">if</span> ser.index.equals(new_ix) <span class="keywordflow">or</span> <span class="keywordflow">not</span> len(new_ix):</div>
<div class="line"><span class="lineno"> 2275</span>                        <span class="keywordflow">return</span> ser._values.copy()</div>
<div class="line"><span class="lineno"> 2276</span> </div>
<div class="line"><span class="lineno"> 2277</span>                    <span class="keywordflow">return</span> ser.reindex(new_ix)._values</div>
<div class="line"><span class="lineno"> 2278</span> </div>
<div class="line"><span class="lineno"> 2279</span>                <span class="comment"># 2 dims</span></div>
<div class="line"><span class="lineno"> 2280</span>                <span class="keywordflow">elif</span> single_aligner:</div>
<div class="line"><span class="lineno"> 2281</span> </div>
<div class="line"><span class="lineno"> 2282</span>                    <span class="comment"># reindex along index</span></div>
<div class="line"><span class="lineno"> 2283</span>                    ax = self.obj.axes[1]</div>
<div class="line"><span class="lineno"> 2284</span>                    <span class="keywordflow">if</span> ser.index.equals(ax) <span class="keywordflow">or</span> <span class="keywordflow">not</span> len(ax):</div>
<div class="line"><span class="lineno"> 2285</span>                        <span class="keywordflow">return</span> ser._values.copy()</div>
<div class="line"><span class="lineno"> 2286</span>                    <span class="keywordflow">return</span> ser.reindex(ax)._values</div>
<div class="line"><span class="lineno"> 2287</span> </div>
<div class="line"><span class="lineno"> 2288</span>        <span class="keywordflow">elif</span> is_integer(indexer) <span class="keywordflow">and</span> self.ndim == 1:</div>
<div class="line"><span class="lineno"> 2289</span>            <span class="keywordflow">if</span> is_object_dtype(self.obj):</div>
<div class="line"><span class="lineno"> 2290</span>                <span class="keywordflow">return</span> ser</div>
<div class="line"><span class="lineno"> 2291</span>            ax = self.obj._get_axis(0)</div>
<div class="line"><span class="lineno"> 2292</span> </div>
<div class="line"><span class="lineno"> 2293</span>            <span class="keywordflow">if</span> ser.index.equals(ax):</div>
<div class="line"><span class="lineno"> 2294</span>                <span class="keywordflow">return</span> ser._values.copy()</div>
<div class="line"><span class="lineno"> 2295</span> </div>
<div class="line"><span class="lineno"> 2296</span>            <span class="keywordflow">return</span> ser.reindex(ax)._values[indexer]</div>
<div class="line"><span class="lineno"> 2297</span> </div>
<div class="line"><span class="lineno"> 2298</span>        <span class="keywordflow">elif</span> is_integer(indexer):</div>
<div class="line"><span class="lineno"> 2299</span>            ax = self.obj._get_axis(1)</div>
<div class="line"><span class="lineno"> 2300</span> </div>
<div class="line"><span class="lineno"> 2301</span>            <span class="keywordflow">if</span> ser.index.equals(ax):</div>
<div class="line"><span class="lineno"> 2302</span>                <span class="keywordflow">return</span> ser._values.copy()</div>
<div class="line"><span class="lineno"> 2303</span> </div>
<div class="line"><span class="lineno"> 2304</span>            <span class="keywordflow">return</span> ser.reindex(ax)._values</div>
<div class="line"><span class="lineno"> 2305</span> </div>
<div class="line"><span class="lineno"> 2306</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Incompatible indexer with Series&quot;</span>)</div>
<div class="line"><span class="lineno"> 2307</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a08cce5a07097d271ad2d803f4a1fc9c4" name="a08cce5a07097d271ad2d803f4a1fc9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cce5a07097d271ad2d803f4a1fc9c4">&#9670;&#160;</a></span>_convert_to_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._convert_to_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Much simpler as we only have to deal with our valid types.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a9874e4e55b37bea8d11637c1a30e284e">pandas.core.indexing._LocationIndexer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1640</span>    <span class="keyword">def </span>_convert_to_indexer(self, key, axis: int):</div>
<div class="line"><span class="lineno"> 1641</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">        Much simpler as we only have to deal with our valid types.</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1644</span>        <span class="keywordflow">return</span> key</div>
<div class="line"><span class="lineno"> 1645</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a01fc43436fe25547cca6a5cba700304a" name="a01fc43436fe25547cca6a5cba700304a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fc43436fe25547cca6a5cba700304a">&#9670;&#160;</a></span>_ensure_iterable_column_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._ensure_iterable_column_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>column_indexer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure that our column indexer is something that can be iterated over.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2185</span>    <span class="keyword">def </span>_ensure_iterable_column_indexer(self, column_indexer):</div>
<div class="line"><span class="lineno"> 2186</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2187</span><span class="stringliteral">        Ensure that our column indexer is something that can be iterated over.</span></div>
<div class="line"><span class="lineno"> 2188</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2189</span>        ilocs: Sequence[int] | np.ndarray</div>
<div class="line"><span class="lineno"> 2190</span>        <span class="keywordflow">if</span> is_integer(column_indexer):</div>
<div class="line"><span class="lineno"> 2191</span>            ilocs = [column_indexer]</div>
<div class="line"><span class="lineno"> 2192</span>        <span class="keywordflow">elif</span> isinstance(column_indexer, slice):</div>
<div class="line"><span class="lineno"> 2193</span>            ilocs = np.arange(len(self.obj.columns))[column_indexer]</div>
<div class="line"><span class="lineno"> 2194</span>        <span class="keywordflow">elif</span> isinstance(column_indexer, np.ndarray) <span class="keywordflow">and</span> is_bool_dtype(</div>
<div class="line"><span class="lineno"> 2195</span>            column_indexer.dtype</div>
<div class="line"><span class="lineno"> 2196</span>        ):</div>
<div class="line"><span class="lineno"> 2197</span>            ilocs = np.arange(len(column_indexer))[column_indexer]</div>
<div class="line"><span class="lineno"> 2198</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2199</span>            ilocs = column_indexer</div>
<div class="line"><span class="lineno"> 2200</span>        <span class="keywordflow">return</span> ilocs</div>
<div class="line"><span class="lineno"> 2201</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ce9f71ef5d33d158eab5dcb7a061932" name="a2ce9f71ef5d33d158eab5dcb7a061932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce9f71ef5d33d158eab5dcb7a061932">&#9670;&#160;</a></span>_get_list_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._get_list_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return Series values by list or array of integers.

Parameters
----------
key : list-like positional indexer
axis : int

Returns
-------
Series object

Notes
-----
`axis` can only be zero.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1569</span>    <span class="keyword">def </span>_get_list_axis(self, key, axis: int):</div>
<div class="line"><span class="lineno"> 1570</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">        Return Series values by list or array of integers.</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">        key : list-like positional indexer</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">        axis : int</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">        Series object</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">        `axis` can only be zero.</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1586</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1587</span>            <span class="keywordflow">return</span> self.obj._take_with_is_copy(key, axis=axis)</div>
<div class="line"><span class="lineno"> 1588</span>        <span class="keywordflow">except</span> IndexError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1589</span>            <span class="comment"># re-raise with different error message</span></div>
<div class="line"><span class="lineno"> 1590</span>            <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&quot;positional indexers are out-of-bounds&quot;</span>) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 1591</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a11538c2c502de5f62d103ca3f7a80434" name="a11538c2c502de5f62d103ca3f7a80434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11538c2c502de5f62d103ca3f7a80434">&#9670;&#160;</a></span>_get_setitem_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._get_setitem_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a potentially-label-based key into a positional indexer.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a0053c2117b99389ffe7c649541db7da0">pandas.core.indexing._LocationIndexer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1646</span>    <span class="keyword">def </span>_get_setitem_indexer(self, key):</div>
<div class="line"><span class="lineno"> 1647</span>        <span class="comment"># GH#32257 Fall through to let numpy do validation</span></div>
<div class="line"><span class="lineno"> 1648</span>        <span class="keywordflow">if</span> is_iterator(key):</div>
<div class="line"><span class="lineno"> 1649</span>            key = list(key)</div>
<div class="line"><span class="lineno"> 1650</span> </div>
<div class="line"><span class="lineno"> 1651</span>        <span class="keywordflow">if</span> self.axis <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1652</span>            key = _tupleize_axis_indexer(self.ndim, self.axis, key)</div>
<div class="line"><span class="lineno"> 1653</span> </div>
<div class="line"><span class="lineno"> 1654</span>        <span class="keywordflow">return</span> key</div>
<div class="line"><span class="lineno"> 1655</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a9e2c990d7c20846a0ce2a0ef2a3819" name="a4a9e2c990d7c20846a0ce2a0ef2a3819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9e2c990d7c20846a0ce2a0ef2a3819">&#9670;&#160;</a></span>_get_slice_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._get_slice_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slice&#160;</td>
          <td class="paramname"><em>slice_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1629</span>    <span class="keyword">def </span>_get_slice_axis(self, slice_obj: slice, axis: int):</div>
<div class="line"><span class="lineno"> 1630</span>        <span class="comment"># caller is responsible for ensuring non-None axis</span></div>
<div class="line"><span class="lineno"> 1631</span>        obj = self.obj</div>
<div class="line"><span class="lineno"> 1632</span> </div>
<div class="line"><span class="lineno"> 1633</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> need_slice(slice_obj):</div>
<div class="line"><span class="lineno"> 1634</span>            <span class="keywordflow">return</span> obj.copy(deep=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1635</span> </div>
<div class="line"><span class="lineno"> 1636</span>        labels = obj._get_axis(axis)</div>
<div class="line"><span class="lineno"> 1637</span>        labels._validate_positional_slice(slice_obj)</div>
<div class="line"><span class="lineno"> 1638</span>        <span class="keywordflow">return</span> self.obj._slice(slice_obj, axis=axis)</div>
<div class="line"><span class="lineno"> 1639</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aab5b3d9b9d2654895f2e956554ab0e7a" name="aab5b3d9b9d2654895f2e956554ab0e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5b3d9b9d2654895f2e956554ab0e7a">&#9670;&#160;</a></span>_getitem_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._getitem_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#af469ee4b7fa881bd8790325930645527">pandas.core.indexing._LocationIndexer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1592</span>    <span class="keyword">def </span>_getitem_axis(self, key, axis: int):</div>
<div class="line"><span class="lineno"> 1593</span>        <span class="keywordflow">if</span> key <span class="keywordflow">is</span> Ellipsis:</div>
<div class="line"><span class="lineno"> 1594</span>            key = slice(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1595</span>        <span class="keywordflow">elif</span> isinstance(key, ABCDataFrame):</div>
<div class="line"><span class="lineno"> 1596</span>            <span class="keywordflow">raise</span> IndexError(</div>
<div class="line"><span class="lineno"> 1597</span>                <span class="stringliteral">&quot;DataFrame indexer is not allowed for .iloc\n&quot;</span></div>
<div class="line"><span class="lineno"> 1598</span>                <span class="stringliteral">&quot;Consider using .loc for automatic alignment.&quot;</span></div>
<div class="line"><span class="lineno"> 1599</span>            )</div>
<div class="line"><span class="lineno"> 1600</span> </div>
<div class="line"><span class="lineno"> 1601</span>        <span class="keywordflow">if</span> isinstance(key, slice):</div>
<div class="line"><span class="lineno"> 1602</span>            <span class="keywordflow">return</span> self._get_slice_axis(key, axis=axis)</div>
<div class="line"><span class="lineno"> 1603</span> </div>
<div class="line"><span class="lineno"> 1604</span>        <span class="keywordflow">if</span> is_iterator(key):</div>
<div class="line"><span class="lineno"> 1605</span>            key = list(key)</div>
<div class="line"><span class="lineno"> 1606</span> </div>
<div class="line"><span class="lineno"> 1607</span>        <span class="keywordflow">if</span> isinstance(key, list):</div>
<div class="line"><span class="lineno"> 1608</span>            key = np.asarray(key)</div>
<div class="line"><span class="lineno"> 1609</span> </div>
<div class="line"><span class="lineno"> 1610</span>        <span class="keywordflow">if</span> com.is_bool_indexer(key):</div>
<div class="line"><span class="lineno"> 1611</span>            self._validate_key(key, axis)</div>
<div class="line"><span class="lineno"> 1612</span>            <span class="keywordflow">return</span> self._getbool_axis(key, axis=axis)</div>
<div class="line"><span class="lineno"> 1613</span> </div>
<div class="line"><span class="lineno"> 1614</span>        <span class="comment"># a list of integers</span></div>
<div class="line"><span class="lineno"> 1615</span>        <span class="keywordflow">elif</span> is_list_like_indexer(key):</div>
<div class="line"><span class="lineno"> 1616</span>            <span class="keywordflow">return</span> self._get_list_axis(key, axis=axis)</div>
<div class="line"><span class="lineno"> 1617</span> </div>
<div class="line"><span class="lineno"> 1618</span>        <span class="comment"># a single integer</span></div>
<div class="line"><span class="lineno"> 1619</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1620</span>            key = item_from_zerodim(key)</div>
<div class="line"><span class="lineno"> 1621</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_integer(key):</div>
<div class="line"><span class="lineno"> 1622</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Cannot index by location index with a non-integer key&quot;</span>)</div>
<div class="line"><span class="lineno"> 1623</span> </div>
<div class="line"><span class="lineno"> 1624</span>            <span class="comment"># validate the location</span></div>
<div class="line"><span class="lineno"> 1625</span>            self._validate_integer(key, axis)</div>
<div class="line"><span class="lineno"> 1626</span> </div>
<div class="line"><span class="lineno"> 1627</span>            <span class="keywordflow">return</span> self.obj._ixs(key, axis=axis)</div>
<div class="line"><span class="lineno"> 1628</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a95d285f468a90f750cb07756ddf848c5" name="a95d285f468a90f750cb07756ddf848c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d285f468a90f750cb07756ddf848c5">&#9670;&#160;</a></span>_getitem_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._getitem_tuple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#aa8756253777e975c9c90afefc1202673">pandas.core.indexing._LocationIndexer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1561</span>    <span class="keyword">def </span>_getitem_tuple(self, tup: tuple):</div>
<div class="line"><span class="lineno"> 1562</span> </div>
<div class="line"><span class="lineno"> 1563</span>        tup = self._validate_tuple_indexer(tup)</div>
<div class="line"><span class="lineno"> 1564</span>        <span class="keyword">with</span> suppress(IndexingError):</div>
<div class="line"><span class="lineno"> 1565</span>            <span class="keywordflow">return</span> self._getitem_lowerdim(tup)</div>
<div class="line"><span class="lineno"> 1566</span> </div>
<div class="line"><span class="lineno"> 1567</span>        <span class="keywordflow">return</span> self._getitem_tuple_same_dim(tup)</div>
<div class="line"><span class="lineno"> 1568</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8cfa4eb461b6f32e92f6e07a10be362" name="ad8cfa4eb461b6f32e92f6e07a10be362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cfa4eb461b6f32e92f6e07a10be362">&#9670;&#160;</a></span>_has_valid_setitem_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexing._iLocIndexer._has_valid_setitem_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validate that a positional indexer cannot enlarge its target
will raise if needed, does not modify the indexer externally.

Returns
-------
bool
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a71ef8c176fd3ede08888bf675dbc1a91">pandas.core.indexing._LocationIndexer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1485</span>    <span class="keyword">def </span>_has_valid_setitem_indexer(self, indexer) -&gt; bool:</div>
<div class="line"><span class="lineno"> 1486</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">        Validate that a positional indexer cannot enlarge its target</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">        will raise if needed, does not modify the indexer externally.</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1494</span>        <span class="keywordflow">if</span> isinstance(indexer, dict):</div>
<div class="line"><span class="lineno"> 1495</span>            <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&quot;iloc cannot enlarge its target object&quot;</span>)</div>
<div class="line"><span class="lineno"> 1496</span> </div>
<div class="line"><span class="lineno"> 1497</span>        <span class="keywordflow">if</span> isinstance(indexer, ABCDataFrame):</div>
<div class="line"><span class="lineno"> 1498</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1499</span>                <span class="stringliteral">&quot;DataFrame indexer for .iloc is deprecated and will be removed in &quot;</span></div>
<div class="line"><span class="lineno"> 1500</span>                <span class="stringliteral">&quot;a future version.\n&quot;</span></div>
<div class="line"><span class="lineno"> 1501</span>                <span class="stringliteral">&quot;consider using .loc with a DataFrame indexer for automatic alignment.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1502</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 1503</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1504</span>            )</div>
<div class="line"><span class="lineno"> 1505</span> </div>
<div class="line"><span class="lineno"> 1506</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(indexer, tuple):</div>
<div class="line"><span class="lineno"> 1507</span>            indexer = _tuplify(self.ndim, indexer)</div>
<div class="line"><span class="lineno"> 1508</span> </div>
<div class="line"><span class="lineno"> 1509</span>        <span class="keywordflow">for</span> ax, i <span class="keywordflow">in</span> zip(self.obj.axes, indexer):</div>
<div class="line"><span class="lineno"> 1510</span>            <span class="keywordflow">if</span> isinstance(i, slice):</div>
<div class="line"><span class="lineno"> 1511</span>                <span class="comment"># should check the stop slice?</span></div>
<div class="line"><span class="lineno"> 1512</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1513</span>            <span class="keywordflow">elif</span> is_list_like_indexer(i):</div>
<div class="line"><span class="lineno"> 1514</span>                <span class="comment"># should check the elements?</span></div>
<div class="line"><span class="lineno"> 1515</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1516</span>            <span class="keywordflow">elif</span> is_integer(i):</div>
<div class="line"><span class="lineno"> 1517</span>                <span class="keywordflow">if</span> i &gt;= len(ax):</div>
<div class="line"><span class="lineno"> 1518</span>                    <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&quot;iloc cannot enlarge its target object&quot;</span>)</div>
<div class="line"><span class="lineno"> 1519</span>            <span class="keywordflow">elif</span> isinstance(i, dict):</div>
<div class="line"><span class="lineno"> 1520</span>                <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&quot;iloc cannot enlarge its target object&quot;</span>)</div>
<div class="line"><span class="lineno"> 1521</span> </div>
<div class="line"><span class="lineno"> 1522</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1523</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a48e18c18328183de1da9ebfc4b5575e8" name="a48e18c18328183de1da9ebfc4b5575e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e18c18328183de1da9ebfc4b5575e8">&#9670;&#160;</a></span>_is_scalar_access()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexing._iLocIndexer._is_scalar_access </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns
-------
bool
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#ab3ab6601f8af8aee235efef358167859">pandas.core.indexing._LocationIndexer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1524</span>    <span class="keyword">def </span>_is_scalar_access(self, key: tuple) -&gt; bool:</div>
<div class="line"><span class="lineno"> 1525</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1530</span>        <span class="comment"># this is a shortcut accessor to both .loc and .iloc</span></div>
<div class="line"><span class="lineno"> 1531</span>        <span class="comment"># that provide the equivalent access of .at and .iat</span></div>
<div class="line"><span class="lineno"> 1532</span>        <span class="comment"># a) avoid getting things via sections and (to minimize dtype changes)</span></div>
<div class="line"><span class="lineno"> 1533</span>        <span class="comment"># b) provide a performant path</span></div>
<div class="line"><span class="lineno"> 1534</span>        <span class="keywordflow">if</span> len(key) != self.ndim:</div>
<div class="line"><span class="lineno"> 1535</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1536</span> </div>
<div class="line"><span class="lineno"> 1537</span>        <span class="keywordflow">return</span> all(is_integer(k) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> key)</div>
<div class="line"><span class="lineno"> 1538</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a67ac78bd7ece37c80942ae425c117dbb" name="a67ac78bd7ece37c80942ae425c117dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ac78bd7ece37c80942ae425c117dbb">&#9670;&#160;</a></span>_setitem_single_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._setitem_single_block </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">_setitem_with_indexer for the case when we have a single Block.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2036</span>    <span class="keyword">def </span>_setitem_single_block(self, indexer, value, name: str):</div>
<div class="line"><span class="lineno"> 2037</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral">        _setitem_with_indexer for the case when we have a single Block.</span></div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2040</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno"> 2041</span> </div>
<div class="line"><span class="lineno"> 2042</span>        info_axis = self.obj._info_axis_number</div>
<div class="line"><span class="lineno"> 2043</span>        item_labels = self.obj._get_axis(info_axis)</div>
<div class="line"><span class="lineno"> 2044</span>        <span class="keywordflow">if</span> isinstance(indexer, tuple):</div>
<div class="line"><span class="lineno"> 2045</span> </div>
<div class="line"><span class="lineno"> 2046</span>            <span class="comment"># if we are setting on the info axis ONLY</span></div>
<div class="line"><span class="lineno"> 2047</span>            <span class="comment"># set using those methods to avoid block-splitting</span></div>
<div class="line"><span class="lineno"> 2048</span>            <span class="comment"># logic here</span></div>
<div class="line"><span class="lineno"> 2049</span>            <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 2050</span>                self.ndim == len(indexer) == 2</div>
<div class="line"><span class="lineno"> 2051</span>                <span class="keywordflow">and</span> is_integer(indexer[1])</div>
<div class="line"><span class="lineno"> 2052</span>                <span class="keywordflow">and</span> com.is_null_slice(indexer[0])</div>
<div class="line"><span class="lineno"> 2053</span>            ):</div>
<div class="line"><span class="lineno"> 2054</span>                col = item_labels[indexer[info_axis]]</div>
<div class="line"><span class="lineno"> 2055</span>                <span class="keywordflow">if</span> len(item_labels.get_indexer_for([col])) == 1:</div>
<div class="line"><span class="lineno"> 2056</span>                    <span class="comment"># e.g. test_loc_setitem_empty_append_expands_rows</span></div>
<div class="line"><span class="lineno"> 2057</span>                    loc = item_labels.get_loc(col)</div>
<div class="line"><span class="lineno"> 2058</span>                    <span class="comment"># Go through _setitem_single_column to get</span></div>
<div class="line"><span class="lineno"> 2059</span>                    <span class="comment">#  FutureWarning if relevant.</span></div>
<div class="line"><span class="lineno"> 2060</span>                    self._setitem_single_column(loc, value, indexer[0])</div>
<div class="line"><span class="lineno"> 2061</span>                    <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 2062</span> </div>
<div class="line"><span class="lineno"> 2063</span>            indexer = maybe_convert_ix(*indexer)  <span class="comment"># e.g. test_setitem_frame_align</span></div>
<div class="line"><span class="lineno"> 2064</span> </div>
<div class="line"><span class="lineno"> 2065</span>        <span class="keywordflow">if</span> (isinstance(value, ABCSeries) <span class="keywordflow">and</span> name != <span class="stringliteral">&quot;iloc&quot;</span>) <span class="keywordflow">or</span> isinstance(value, dict):</div>
<div class="line"><span class="lineno"> 2066</span>            <span class="comment"># TODO(EA): ExtensionBlock.setitem this causes issues with</span></div>
<div class="line"><span class="lineno"> 2067</span>            <span class="comment"># setting for extensionarrays that store dicts. Need to decide</span></div>
<div class="line"><span class="lineno"> 2068</span>            <span class="comment"># if it&#39;s worth supporting that.</span></div>
<div class="line"><span class="lineno"> 2069</span>            value = self._align_series(indexer, Series(value))</div>
<div class="line"><span class="lineno"> 2070</span> </div>
<div class="line"><span class="lineno"> 2071</span>        <span class="keywordflow">elif</span> isinstance(value, ABCDataFrame) <span class="keywordflow">and</span> name != <span class="stringliteral">&quot;iloc&quot;</span>:</div>
<div class="line"><span class="lineno"> 2072</span>            value = self._align_frame(indexer, value)</div>
<div class="line"><span class="lineno"> 2073</span> </div>
<div class="line"><span class="lineno"> 2074</span>        <span class="comment"># check for chained assignment</span></div>
<div class="line"><span class="lineno"> 2075</span>        self.obj._check_is_chained_assignment_possible()</div>
<div class="line"><span class="lineno"> 2076</span> </div>
<div class="line"><span class="lineno"> 2077</span>        <span class="comment"># actually do the set</span></div>
<div class="line"><span class="lineno"> 2078</span>        self.obj._mgr = self.obj._mgr.setitem(indexer=indexer, value=value)</div>
<div class="line"><span class="lineno"> 2079</span>        self.obj._maybe_update_cacher(clear=<span class="keyword">True</span>, inplace=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2080</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adb2a1e441e9547c23ac9161d01ad8318" name="adb2a1e441e9547c23ac9161d01ad8318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2a1e441e9547c23ac9161d01ad8318">&#9670;&#160;</a></span>_setitem_single_column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._setitem_single_column </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plane_indexer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
loc : int
    Indexer for column position
plane_indexer : int, slice, listlike[int]
    The indexer we use for setitem along axis=0.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1957</span>    <span class="keyword">def </span>_setitem_single_column(self, loc: int, value, plane_indexer):</div>
<div class="line"><span class="lineno"> 1958</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">        loc : int</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">            Indexer for column position</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral">        plane_indexer : int, slice, listlike[int]</span></div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">            The indexer we use for setitem along axis=0.</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1967</span>        pi = plane_indexer</div>
<div class="line"><span class="lineno"> 1968</span> </div>
<div class="line"><span class="lineno"> 1969</span>        orig_values = self.obj._get_column_array(loc)</div>
<div class="line"><span class="lineno"> 1970</span> </div>
<div class="line"><span class="lineno"> 1971</span>        <span class="comment"># perform the equivalent of a setitem on the info axis</span></div>
<div class="line"><span class="lineno"> 1972</span>        <span class="comment"># as we have a null slice or a slice with full bounds</span></div>
<div class="line"><span class="lineno"> 1973</span>        <span class="comment"># which means essentially reassign to the columns of a</span></div>
<div class="line"><span class="lineno"> 1974</span>        <span class="comment"># multi-dim object</span></div>
<div class="line"><span class="lineno"> 1975</span>        <span class="comment"># GH#6149 (null slice), GH#10408 (full bounds)</span></div>
<div class="line"><span class="lineno"> 1976</span>        <span class="keywordflow">if</span> com.is_null_slice(pi) <span class="keywordflow">or</span> com.is_full_slice(pi, len(self.obj)):</div>
<div class="line"><span class="lineno"> 1977</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1978</span>        <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno"> 1979</span>            is_array_like(value)</div>
<div class="line"><span class="lineno"> 1980</span>            <span class="keywordflow">and</span> len(value.shape) &gt; 0</div>
<div class="line"><span class="lineno"> 1981</span>            <span class="keywordflow">and</span> self.obj.shape[0] == value.shape[0]</div>
<div class="line"><span class="lineno"> 1982</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_empty_indexer(pi)</div>
<div class="line"><span class="lineno"> 1983</span>        ):</div>
<div class="line"><span class="lineno"> 1984</span>            <span class="keywordflow">if</span> is_list_like(pi) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_bool_dtype(pi):</div>
<div class="line"><span class="lineno"> 1985</span>                value = value[np.argsort(pi)]</div>
<div class="line"><span class="lineno"> 1986</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1987</span>                <span class="comment"># in case of slice</span></div>
<div class="line"><span class="lineno"> 1988</span>                value = value[pi]</div>
<div class="line"><span class="lineno"> 1989</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1990</span>            <span class="comment"># set value into the column (first attempting to operate inplace, then</span></div>
<div class="line"><span class="lineno"> 1991</span>            <span class="comment">#  falling back to casting if necessary)</span></div>
<div class="line"><span class="lineno"> 1992</span>            self.obj._mgr.column_setitem(loc, plane_indexer, value)</div>
<div class="line"><span class="lineno"> 1993</span>            self.obj._clear_item_cache()</div>
<div class="line"><span class="lineno"> 1994</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1995</span> </div>
<div class="line"><span class="lineno"> 1996</span>        self.obj._iset_item(loc, value)</div>
<div class="line"><span class="lineno"> 1997</span> </div>
<div class="line"><span class="lineno"> 1998</span>        <span class="comment"># We will not operate in-place, but will attempt to in the future.</span></div>
<div class="line"><span class="lineno"> 1999</span>        <span class="comment">#  To determine whether we need to issue a FutureWarning, see if the</span></div>
<div class="line"><span class="lineno"> 2000</span>        <span class="comment">#  setting in-place would work, i.e. behavior will change.</span></div>
<div class="line"><span class="lineno"> 2001</span> </div>
<div class="line"><span class="lineno"> 2002</span>        new_values = self.obj._get_column_array(loc)</div>
<div class="line"><span class="lineno"> 2003</span> </div>
<div class="line"><span class="lineno"> 2004</span>        <span class="keywordflow">if</span> can_hold_element(orig_values, new_values) <span class="keywordflow">and</span> <span class="keywordflow">not</span> len(new_values) == 0:</div>
<div class="line"><span class="lineno"> 2005</span>            <span class="comment"># Don&#39;t issue the warning yet, as we can still trim a few cases where</span></div>
<div class="line"><span class="lineno"> 2006</span>            <span class="comment">#  behavior will not change.</span></div>
<div class="line"><span class="lineno"> 2007</span> </div>
<div class="line"><span class="lineno"> 2008</span>            <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 2009</span>                isinstance(new_values, np.ndarray)</div>
<div class="line"><span class="lineno"> 2010</span>                <span class="keywordflow">and</span> isinstance(orig_values, np.ndarray)</div>
<div class="line"><span class="lineno"> 2011</span>                <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno"> 2012</span>                    np.shares_memory(new_values, orig_values)</div>
<div class="line"><span class="lineno"> 2013</span>                    <span class="keywordflow">or</span> new_values.shape != orig_values.shape</div>
<div class="line"><span class="lineno"> 2014</span>                )</div>
<div class="line"><span class="lineno"> 2015</span>            ):</div>
<div class="line"><span class="lineno"> 2016</span>                <span class="comment"># TODO: get something like tm.shares_memory working?</span></div>
<div class="line"><span class="lineno"> 2017</span>                <span class="comment"># The values were set inplace after all, no need to warn,</span></div>
<div class="line"><span class="lineno"> 2018</span>                <span class="comment">#  e.g. test_rename_nocopy</span></div>
<div class="line"><span class="lineno"> 2019</span>                <span class="comment"># In case of enlarging we can not set inplace, so need to</span></div>
<div class="line"><span class="lineno"> 2020</span>                <span class="comment"># warn either</span></div>
<div class="line"><span class="lineno"> 2021</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 2022</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2023</span>                warnings.warn(</div>
<div class="line"><span class="lineno"> 2024</span>                    <span class="stringliteral">&quot;In a future version, `df.iloc[:, i] = newvals` will attempt &quot;</span></div>
<div class="line"><span class="lineno"> 2025</span>                    <span class="stringliteral">&quot;to set the values inplace instead of always setting a new &quot;</span></div>
<div class="line"><span class="lineno"> 2026</span>                    <span class="stringliteral">&quot;array. To retain the old behavior, use either &quot;</span></div>
<div class="line"><span class="lineno"> 2027</span>                    <span class="stringliteral">&quot;`df[df.columns[i]] = newvals` or, if columns are non-unique, &quot;</span></div>
<div class="line"><span class="lineno"> 2028</span>                    <span class="stringliteral">&quot;`df.isetitem(i, newvals)`&quot;</span>,</div>
<div class="line"><span class="lineno"> 2029</span>                    FutureWarning,</div>
<div class="line"><span class="lineno"> 2030</span>                    stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 2031</span>                )</div>
<div class="line"><span class="lineno"> 2032</span>                <span class="comment"># TODO: how to get future behavior?</span></div>
<div class="line"><span class="lineno"> 2033</span>                <span class="comment"># TODO: what if we got here indirectly via loc?</span></div>
<div class="line"><span class="lineno"> 2034</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 2035</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a35a5edea974f55e669073bb441c98501" name="a35a5edea974f55e669073bb441c98501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a5edea974f55e669073bb441c98501">&#9670;&#160;</a></span>_setitem_with_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._setitem_with_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;iloc&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">_setitem_with_indexer is for setting values on a Series/DataFrame
using positional indexers.

If the relevant keys are not present, the Series/DataFrame may be
expanded.

This method is currently broken when dealing with non-unique Indexes,
since it goes from positional indexers back to labels when calling
BlockManager methods, see GH#12991, GH#22046, GH#15686.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1658</span>    <span class="keyword">def </span>_setitem_with_indexer(self, indexer, value, name=&quot;iloc&quot;):</div>
<div class="line"><span class="lineno"> 1659</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">        _setitem_with_indexer is for setting values on a Series/DataFrame</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">        using positional indexers.</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">        If the relevant keys are not present, the Series/DataFrame may be</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">        expanded.</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">        This method is currently broken when dealing with non-unique Indexes,</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">        since it goes from positional indexers back to labels when calling</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">        BlockManager methods, see GH#12991, GH#22046, GH#15686.</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1670</span>        info_axis = self.obj._info_axis_number</div>
<div class="line"><span class="lineno"> 1671</span> </div>
<div class="line"><span class="lineno"> 1672</span>        <span class="comment"># maybe partial set</span></div>
<div class="line"><span class="lineno"> 1673</span>        take_split_path = <span class="keywordflow">not</span> self.obj._mgr.is_single_block</div>
<div class="line"><span class="lineno"> 1674</span> </div>
<div class="line"><span class="lineno"> 1675</span>        <span class="comment"># if there is only one block/type, still have to take split path</span></div>
<div class="line"><span class="lineno"> 1676</span>        <span class="comment"># unless the block is one-dimensional or it can hold the value</span></div>
<div class="line"><span class="lineno"> 1677</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> take_split_path <span class="keywordflow">and</span> len(self.obj._mgr.arrays) <span class="keywordflow">and</span> self.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 1678</span>            <span class="comment"># in case of dict, keys are indices</span></div>
<div class="line"><span class="lineno"> 1679</span>            val = list(value.values()) <span class="keywordflow">if</span> isinstance(value, dict) <span class="keywordflow">else</span> value</div>
<div class="line"><span class="lineno"> 1680</span>            arr = self.obj._mgr.arrays[0]</div>
<div class="line"><span class="lineno"> 1681</span>            take_split_path = <span class="keywordflow">not</span> can_hold_element(</div>
<div class="line"><span class="lineno"> 1682</span>                arr, extract_array(val, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1683</span>            )</div>
<div class="line"><span class="lineno"> 1684</span> </div>
<div class="line"><span class="lineno"> 1685</span>        <span class="comment"># if we have any multi-indexes that have non-trivial slices</span></div>
<div class="line"><span class="lineno"> 1686</span>        <span class="comment"># (not null slices) then we must take the split path, xref</span></div>
<div class="line"><span class="lineno"> 1687</span>        <span class="comment"># GH 10360, GH 27841</span></div>
<div class="line"><span class="lineno"> 1688</span>        <span class="keywordflow">if</span> isinstance(indexer, tuple) <span class="keywordflow">and</span> len(indexer) == len(self.obj.axes):</div>
<div class="line"><span class="lineno"> 1689</span>            <span class="keywordflow">for</span> i, ax <span class="keywordflow">in</span> zip(indexer, self.obj.axes):</div>
<div class="line"><span class="lineno"> 1690</span>                <span class="keywordflow">if</span> isinstance(ax, MultiIndex) <span class="keywordflow">and</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno"> 1691</span>                    is_integer(i) <span class="keywordflow">or</span> com.is_null_slice(i)</div>
<div class="line"><span class="lineno"> 1692</span>                ):</div>
<div class="line"><span class="lineno"> 1693</span>                    take_split_path = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1694</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1695</span> </div>
<div class="line"><span class="lineno"> 1696</span>        <span class="keywordflow">if</span> isinstance(indexer, tuple):</div>
<div class="line"><span class="lineno"> 1697</span>            nindexer = []</div>
<div class="line"><span class="lineno"> 1698</span>            <span class="keywordflow">for</span> i, idx <span class="keywordflow">in</span> enumerate(indexer):</div>
<div class="line"><span class="lineno"> 1699</span>                <span class="keywordflow">if</span> isinstance(idx, dict):</div>
<div class="line"><span class="lineno"> 1700</span> </div>
<div class="line"><span class="lineno"> 1701</span>                    <span class="comment"># reindex the axis to the new value</span></div>
<div class="line"><span class="lineno"> 1702</span>                    <span class="comment"># and set inplace</span></div>
<div class="line"><span class="lineno"> 1703</span>                    key, _ = convert_missing_indexer(idx)</div>
<div class="line"><span class="lineno"> 1704</span> </div>
<div class="line"><span class="lineno"> 1705</span>                    <span class="comment"># if this is the items axes, then take the main missing</span></div>
<div class="line"><span class="lineno"> 1706</span>                    <span class="comment"># path first</span></div>
<div class="line"><span class="lineno"> 1707</span>                    <span class="comment"># this correctly sets the dtype and avoids cache issues</span></div>
<div class="line"><span class="lineno"> 1708</span>                    <span class="comment"># essentially this separates out the block that is needed</span></div>
<div class="line"><span class="lineno"> 1709</span>                    <span class="comment"># to possibly be modified</span></div>
<div class="line"><span class="lineno"> 1710</span>                    <span class="keywordflow">if</span> self.ndim &gt; 1 <span class="keywordflow">and</span> i == info_axis:</div>
<div class="line"><span class="lineno"> 1711</span> </div>
<div class="line"><span class="lineno"> 1712</span>                        <span class="comment"># add the new item, and set the value</span></div>
<div class="line"><span class="lineno"> 1713</span>                        <span class="comment"># must have all defined axes if we have a scalar</span></div>
<div class="line"><span class="lineno"> 1714</span>                        <span class="comment"># or a list-like on the non-info axes if we have a</span></div>
<div class="line"><span class="lineno"> 1715</span>                        <span class="comment"># list-like</span></div>
<div class="line"><span class="lineno"> 1716</span>                        <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self.obj):</div>
<div class="line"><span class="lineno"> 1717</span>                            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like_indexer(value):</div>
<div class="line"><span class="lineno"> 1718</span>                                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1719</span>                                    <span class="stringliteral">&quot;cannot set a frame with no &quot;</span></div>
<div class="line"><span class="lineno"> 1720</span>                                    <span class="stringliteral">&quot;defined index and a scalar&quot;</span></div>
<div class="line"><span class="lineno"> 1721</span>                                )</div>
<div class="line"><span class="lineno"> 1722</span>                            self.obj[key] = value</div>
<div class="line"><span class="lineno"> 1723</span>                            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1724</span> </div>
<div class="line"><span class="lineno"> 1725</span>                        <span class="comment"># add a new item with the dtype setup</span></div>
<div class="line"><span class="lineno"> 1726</span>                        <span class="keywordflow">if</span> com.is_null_slice(indexer[0]):</div>
<div class="line"><span class="lineno"> 1727</span>                            <span class="comment"># We are setting an entire column</span></div>
<div class="line"><span class="lineno"> 1728</span>                            self.obj[key] = value</div>
<div class="line"><span class="lineno"> 1729</span>                            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1730</span>                        <span class="keywordflow">elif</span> is_array_like(value):</div>
<div class="line"><span class="lineno"> 1731</span>                            <span class="comment"># GH#42099</span></div>
<div class="line"><span class="lineno"> 1732</span>                            arr = extract_array(value, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1733</span>                            taker = -1 * np.ones(len(self.obj), dtype=np.intp)</div>
<div class="line"><span class="lineno"> 1734</span>                            empty_value = algos.take_nd(arr, taker)</div>
<div class="line"><span class="lineno"> 1735</span>                            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(value, ABCSeries):</div>
<div class="line"><span class="lineno"> 1736</span>                                <span class="comment"># if not Series (in which case we need to align),</span></div>
<div class="line"><span class="lineno"> 1737</span>                                <span class="comment">#  we can short-circuit</span></div>
<div class="line"><span class="lineno"> 1738</span>                                empty_value[indexer[0]] = arr</div>
<div class="line"><span class="lineno"> 1739</span>                                self.obj[key] = empty_value</div>
<div class="line"><span class="lineno"> 1740</span>                                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1741</span> </div>
<div class="line"><span class="lineno"> 1742</span>                            self.obj[key] = empty_value</div>
<div class="line"><span class="lineno"> 1743</span> </div>
<div class="line"><span class="lineno"> 1744</span>                        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1745</span>                            self.obj[key] = infer_fill_value(value)</div>
<div class="line"><span class="lineno"> 1746</span> </div>
<div class="line"><span class="lineno"> 1747</span>                        new_indexer = convert_from_missing_indexer_tuple(</div>
<div class="line"><span class="lineno"> 1748</span>                            indexer, self.obj.axes</div>
<div class="line"><span class="lineno"> 1749</span>                        )</div>
<div class="line"><span class="lineno"> 1750</span>                        self._setitem_with_indexer(new_indexer, value, name)</div>
<div class="line"><span class="lineno"> 1751</span> </div>
<div class="line"><span class="lineno"> 1752</span>                        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1753</span> </div>
<div class="line"><span class="lineno"> 1754</span>                    <span class="comment"># reindex the axis</span></div>
<div class="line"><span class="lineno"> 1755</span>                    <span class="comment"># make sure to clear the cache because we are</span></div>
<div class="line"><span class="lineno"> 1756</span>                    <span class="comment"># just replacing the block manager here</span></div>
<div class="line"><span class="lineno"> 1757</span>                    <span class="comment"># so the object is the same</span></div>
<div class="line"><span class="lineno"> 1758</span>                    index = self.obj._get_axis(i)</div>
<div class="line"><span class="lineno"> 1759</span>                    labels = index.insert(len(index), key)</div>
<div class="line"><span class="lineno"> 1760</span> </div>
<div class="line"><span class="lineno"> 1761</span>                    <span class="comment"># We are expanding the Series/DataFrame values to match</span></div>
<div class="line"><span class="lineno"> 1762</span>                    <span class="comment">#  the length of thenew index `labels`.  GH#40096 ensure</span></div>
<div class="line"><span class="lineno"> 1763</span>                    <span class="comment">#  this is valid even if the index has duplicates.</span></div>
<div class="line"><span class="lineno"> 1764</span>                    taker = np.arange(len(index) + 1, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 1765</span>                    taker[-1] = -1</div>
<div class="line"><span class="lineno"> 1766</span>                    reindexers = {i: (labels, taker)}</div>
<div class="line"><span class="lineno"> 1767</span>                    new_obj = self.obj._reindex_with_indexers(</div>
<div class="line"><span class="lineno"> 1768</span>                        reindexers, allow_dups=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1769</span>                    )</div>
<div class="line"><span class="lineno"> 1770</span>                    self.obj._mgr = new_obj._mgr</div>
<div class="line"><span class="lineno"> 1771</span>                    self.obj._maybe_update_cacher(clear=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1772</span>                    self.obj._is_copy = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1773</span> </div>
<div class="line"><span class="lineno"> 1774</span>                    nindexer.append(labels.get_loc(key))</div>
<div class="line"><span class="lineno"> 1775</span> </div>
<div class="line"><span class="lineno"> 1776</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1777</span>                    nindexer.append(idx)</div>
<div class="line"><span class="lineno"> 1778</span> </div>
<div class="line"><span class="lineno"> 1779</span>            indexer = tuple(nindexer)</div>
<div class="line"><span class="lineno"> 1780</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1781</span> </div>
<div class="line"><span class="lineno"> 1782</span>            indexer, missing = convert_missing_indexer(indexer)</div>
<div class="line"><span class="lineno"> 1783</span> </div>
<div class="line"><span class="lineno"> 1784</span>            <span class="keywordflow">if</span> missing:</div>
<div class="line"><span class="lineno"> 1785</span>                self._setitem_with_indexer_missing(indexer, value)</div>
<div class="line"><span class="lineno"> 1786</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1787</span> </div>
<div class="line"><span class="lineno"> 1788</span>        <span class="keywordflow">if</span> name == <span class="stringliteral">&quot;loc&quot;</span>:</div>
<div class="line"><span class="lineno"> 1789</span>            <span class="comment"># must come after setting of missing</span></div>
<div class="line"><span class="lineno"> 1790</span>            indexer, value = self._maybe_mask_setitem_value(indexer, value)</div>
<div class="line"><span class="lineno"> 1791</span> </div>
<div class="line"><span class="lineno"> 1792</span>        <span class="comment"># align and set the values</span></div>
<div class="line"><span class="lineno"> 1793</span>        <span class="keywordflow">if</span> take_split_path:</div>
<div class="line"><span class="lineno"> 1794</span>            <span class="comment"># We have to operate column-wise</span></div>
<div class="line"><span class="lineno"> 1795</span>            self._setitem_with_indexer_split_path(indexer, value, name)</div>
<div class="line"><span class="lineno"> 1796</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1797</span>            self._setitem_single_block(indexer, value, name)</div>
<div class="line"><span class="lineno"> 1798</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab995a80d18e7dedda92a9b59380e66cd" name="ab995a80d18e7dedda92a9b59380e66cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab995a80d18e7dedda92a9b59380e66cd">&#9670;&#160;</a></span>_setitem_with_indexer_2d_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._setitem_with_indexer_2d_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1890</span>    <span class="keyword">def </span>_setitem_with_indexer_2d_value(self, indexer, value):</div>
<div class="line"><span class="lineno"> 1891</span>        <span class="comment"># We get here with np.ndim(value) == 2, excluding DataFrame,</span></div>
<div class="line"><span class="lineno"> 1892</span>        <span class="comment">#  which goes through _setitem_with_indexer_frame_value</span></div>
<div class="line"><span class="lineno"> 1893</span>        pi = indexer[0]</div>
<div class="line"><span class="lineno"> 1894</span> </div>
<div class="line"><span class="lineno"> 1895</span>        ilocs = self._ensure_iterable_column_indexer(indexer[1])</div>
<div class="line"><span class="lineno"> 1896</span> </div>
<div class="line"><span class="lineno"> 1897</span>        <span class="comment"># GH#7551 Note that this coerces the dtype if we are mixed</span></div>
<div class="line"><span class="lineno"> 1898</span>        value = np.array(value, dtype=object)</div>
<div class="line"><span class="lineno"> 1899</span>        <span class="keywordflow">if</span> len(ilocs) != value.shape[1]:</div>
<div class="line"><span class="lineno"> 1900</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1901</span>                <span class="stringliteral">&quot;Must have equal len keys and value when setting with an ndarray&quot;</span></div>
<div class="line"><span class="lineno"> 1902</span>            )</div>
<div class="line"><span class="lineno"> 1903</span> </div>
<div class="line"><span class="lineno"> 1904</span>        <span class="keywordflow">for</span> i, loc <span class="keywordflow">in</span> enumerate(ilocs):</div>
<div class="line"><span class="lineno"> 1905</span>            <span class="comment"># setting with a list, re-coerces</span></div>
<div class="line"><span class="lineno"> 1906</span>            self._setitem_single_column(loc, value[:, i].tolist(), pi)</div>
<div class="line"><span class="lineno"> 1907</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5fa5ffc8fcaa86b2f17f3b657e05a58b" name="a5fa5ffc8fcaa86b2f17f3b657e05a58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa5ffc8fcaa86b2f17f3b657e05a58b">&#9670;&#160;</a></span>_setitem_with_indexer_frame_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._setitem_with_indexer_frame_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataFrame&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1908</span>    <span class="keyword">def </span>_setitem_with_indexer_frame_value(self, indexer, value: DataFrame, name: str):</div>
<div class="line"><span class="lineno"> 1909</span>        ilocs = self._ensure_iterable_column_indexer(indexer[1])</div>
<div class="line"><span class="lineno"> 1910</span> </div>
<div class="line"><span class="lineno"> 1911</span>        sub_indexer = list(indexer)</div>
<div class="line"><span class="lineno"> 1912</span>        pi = indexer[0]</div>
<div class="line"><span class="lineno"> 1913</span> </div>
<div class="line"><span class="lineno"> 1914</span>        multiindex_indexer = isinstance(self.obj.columns, MultiIndex)</div>
<div class="line"><span class="lineno"> 1915</span> </div>
<div class="line"><span class="lineno"> 1916</span>        unique_cols = value.columns.is_unique</div>
<div class="line"><span class="lineno"> 1917</span> </div>
<div class="line"><span class="lineno"> 1918</span>        <span class="comment"># We do not want to align the value in case of iloc GH#37728</span></div>
<div class="line"><span class="lineno"> 1919</span>        <span class="keywordflow">if</span> name == <span class="stringliteral">&quot;iloc&quot;</span>:</div>
<div class="line"><span class="lineno"> 1920</span>            <span class="keywordflow">for</span> i, loc <span class="keywordflow">in</span> enumerate(ilocs):</div>
<div class="line"><span class="lineno"> 1921</span>                val = value.iloc[:, i]</div>
<div class="line"><span class="lineno"> 1922</span>                self._setitem_single_column(loc, val, pi)</div>
<div class="line"><span class="lineno"> 1923</span> </div>
<div class="line"><span class="lineno"> 1924</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> unique_cols <span class="keywordflow">and</span> value.columns.equals(self.obj.columns):</div>
<div class="line"><span class="lineno"> 1925</span>            <span class="comment"># We assume we are already aligned, see</span></div>
<div class="line"><span class="lineno"> 1926</span>            <span class="comment"># test_iloc_setitem_frame_duplicate_columns_multiple_blocks</span></div>
<div class="line"><span class="lineno"> 1927</span>            <span class="keywordflow">for</span> loc <span class="keywordflow">in</span> ilocs:</div>
<div class="line"><span class="lineno"> 1928</span>                item = self.obj.columns[loc]</div>
<div class="line"><span class="lineno"> 1929</span>                <span class="keywordflow">if</span> item <span class="keywordflow">in</span> value:</div>
<div class="line"><span class="lineno"> 1930</span>                    sub_indexer[1] = item</div>
<div class="line"><span class="lineno"> 1931</span>                    val = self._align_series(</div>
<div class="line"><span class="lineno"> 1932</span>                        tuple(sub_indexer),</div>
<div class="line"><span class="lineno"> 1933</span>                        value.iloc[:, loc],</div>
<div class="line"><span class="lineno"> 1934</span>                        multiindex_indexer,</div>
<div class="line"><span class="lineno"> 1935</span>                    )</div>
<div class="line"><span class="lineno"> 1936</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1937</span>                    val = np.nan</div>
<div class="line"><span class="lineno"> 1938</span> </div>
<div class="line"><span class="lineno"> 1939</span>                self._setitem_single_column(loc, val, pi)</div>
<div class="line"><span class="lineno"> 1940</span> </div>
<div class="line"><span class="lineno"> 1941</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> unique_cols:</div>
<div class="line"><span class="lineno"> 1942</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Setting with non-unique columns is not allowed.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1943</span> </div>
<div class="line"><span class="lineno"> 1944</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1945</span>            <span class="keywordflow">for</span> loc <span class="keywordflow">in</span> ilocs:</div>
<div class="line"><span class="lineno"> 1946</span>                item = self.obj.columns[loc]</div>
<div class="line"><span class="lineno"> 1947</span>                <span class="keywordflow">if</span> item <span class="keywordflow">in</span> value:</div>
<div class="line"><span class="lineno"> 1948</span>                    sub_indexer[1] = item</div>
<div class="line"><span class="lineno"> 1949</span>                    val = self._align_series(</div>
<div class="line"><span class="lineno"> 1950</span>                        tuple(sub_indexer), value[item], multiindex_indexer</div>
<div class="line"><span class="lineno"> 1951</span>                    )</div>
<div class="line"><span class="lineno"> 1952</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1953</span>                    val = np.nan</div>
<div class="line"><span class="lineno"> 1954</span> </div>
<div class="line"><span class="lineno"> 1955</span>                self._setitem_single_column(loc, val, pi)</div>
<div class="line"><span class="lineno"> 1956</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae280667ca4dbe740f5cfb7ac949c529f" name="ae280667ca4dbe740f5cfb7ac949c529f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae280667ca4dbe740f5cfb7ac949c529f">&#9670;&#160;</a></span>_setitem_with_indexer_missing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._setitem_with_indexer_missing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Insert new row(s) or column(s) into the Series or DataFrame.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2081</span>    <span class="keyword">def </span>_setitem_with_indexer_missing(self, indexer, value):</div>
<div class="line"><span class="lineno"> 2082</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral">        Insert new row(s) or column(s) into the Series or DataFrame.</span></div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2085</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno"> 2086</span> </div>
<div class="line"><span class="lineno"> 2087</span>        <span class="comment"># reindex the axis to the new value</span></div>
<div class="line"><span class="lineno"> 2088</span>        <span class="comment"># and set inplace</span></div>
<div class="line"><span class="lineno"> 2089</span>        <span class="keywordflow">if</span> self.ndim == 1:</div>
<div class="line"><span class="lineno"> 2090</span>            index = self.obj.index</div>
<div class="line"><span class="lineno"> 2091</span>            new_index = index.insert(len(index), indexer)</div>
<div class="line"><span class="lineno"> 2092</span> </div>
<div class="line"><span class="lineno"> 2093</span>            <span class="comment"># we have a coerced indexer, e.g. a float</span></div>
<div class="line"><span class="lineno"> 2094</span>            <span class="comment"># that matches in an Int64Index, so</span></div>
<div class="line"><span class="lineno"> 2095</span>            <span class="comment"># we will not create a duplicate index, rather</span></div>
<div class="line"><span class="lineno"> 2096</span>            <span class="comment"># index to that element</span></div>
<div class="line"><span class="lineno"> 2097</span>            <span class="comment"># e.g. 0.0 -&gt; 0</span></div>
<div class="line"><span class="lineno"> 2098</span>            <span class="comment"># GH#12246</span></div>
<div class="line"><span class="lineno"> 2099</span>            <span class="keywordflow">if</span> index.is_unique:</div>
<div class="line"><span class="lineno"> 2100</span>                <span class="comment"># pass new_index[-1:] instead if [new_index[-1]]</span></div>
<div class="line"><span class="lineno"> 2101</span>                <span class="comment">#  so that we retain dtype</span></div>
<div class="line"><span class="lineno"> 2102</span>                new_indexer = index.get_indexer(new_index[-1:])</div>
<div class="line"><span class="lineno"> 2103</span>                <span class="keywordflow">if</span> (new_indexer != -1).any():</div>
<div class="line"><span class="lineno"> 2104</span>                    <span class="comment"># We get only here with loc, so can hard code</span></div>
<div class="line"><span class="lineno"> 2105</span>                    <span class="keywordflow">return</span> self._setitem_with_indexer(new_indexer, value, <span class="stringliteral">&quot;loc&quot;</span>)</div>
<div class="line"><span class="lineno"> 2106</span> </div>
<div class="line"><span class="lineno"> 2107</span>            <span class="comment"># this preserves dtype of the value and of the object</span></div>
<div class="line"><span class="lineno"> 2108</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_scalar(value):</div>
<div class="line"><span class="lineno"> 2109</span>                new_dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2110</span> </div>
<div class="line"><span class="lineno"> 2111</span>            <span class="keywordflow">elif</span> is_valid_na_for_dtype(value, self.obj.dtype):</div>
<div class="line"><span class="lineno"> 2112</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_object_dtype(self.obj.dtype):</div>
<div class="line"><span class="lineno"> 2113</span>                    <span class="comment"># Every NA value is suitable for object, no conversion needed</span></div>
<div class="line"><span class="lineno"> 2114</span>                    value = na_value_for_dtype(self.obj.dtype, compat=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2115</span> </div>
<div class="line"><span class="lineno"> 2116</span>                new_dtype = maybe_promote(self.obj.dtype, value)[0]</div>
<div class="line"><span class="lineno"> 2117</span> </div>
<div class="line"><span class="lineno"> 2118</span>            <span class="keywordflow">elif</span> isna(value):</div>
<div class="line"><span class="lineno"> 2119</span>                new_dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2120</span>            <span class="keywordflow">elif</span> <span class="keywordflow">not</span> self.obj.empty <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_object_dtype(self.obj.dtype):</div>
<div class="line"><span class="lineno"> 2121</span>                <span class="comment"># We should not cast, if we have object dtype because we can</span></div>
<div class="line"><span class="lineno"> 2122</span>                <span class="comment"># set timedeltas into object series</span></div>
<div class="line"><span class="lineno"> 2123</span>                curr_dtype = self.obj.dtype</div>
<div class="line"><span class="lineno"> 2124</span>                curr_dtype = getattr(curr_dtype, <span class="stringliteral">&quot;numpy_dtype&quot;</span>, curr_dtype)</div>
<div class="line"><span class="lineno"> 2125</span>                new_dtype = maybe_promote(curr_dtype, value)[0]</div>
<div class="line"><span class="lineno"> 2126</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2127</span>                new_dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2128</span> </div>
<div class="line"><span class="lineno"> 2129</span>            new_values = Series([value], dtype=new_dtype)._values</div>
<div class="line"><span class="lineno"> 2130</span> </div>
<div class="line"><span class="lineno"> 2131</span>            <span class="keywordflow">if</span> len(self.obj._values):</div>
<div class="line"><span class="lineno"> 2132</span>                <span class="comment"># GH#22717 handle casting compatibility that np.concatenate</span></div>
<div class="line"><span class="lineno"> 2133</span>                <span class="comment">#  does incorrectly</span></div>
<div class="line"><span class="lineno"> 2134</span>                new_values = concat_compat([self.obj._values, new_values])</div>
<div class="line"><span class="lineno"> 2135</span>            self.obj._mgr = self.obj._constructor(</div>
<div class="line"><span class="lineno"> 2136</span>                new_values, index=new_index, name=self.obj.name</div>
<div class="line"><span class="lineno"> 2137</span>            )._mgr</div>
<div class="line"><span class="lineno"> 2138</span>            self.obj._maybe_update_cacher(clear=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2139</span> </div>
<div class="line"><span class="lineno"> 2140</span>        <span class="keywordflow">elif</span> self.ndim == 2:</div>
<div class="line"><span class="lineno"> 2141</span> </div>
<div class="line"><span class="lineno"> 2142</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self.obj.columns):</div>
<div class="line"><span class="lineno"> 2143</span>                <span class="comment"># no columns and scalar</span></div>
<div class="line"><span class="lineno"> 2144</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot set a frame with no defined columns&quot;</span>)</div>
<div class="line"><span class="lineno"> 2145</span> </div>
<div class="line"><span class="lineno"> 2146</span>            has_dtype = hasattr(value, <span class="stringliteral">&quot;dtype&quot;</span>)</div>
<div class="line"><span class="lineno"> 2147</span>            <span class="keywordflow">if</span> isinstance(value, ABCSeries):</div>
<div class="line"><span class="lineno"> 2148</span>                <span class="comment"># append a Series</span></div>
<div class="line"><span class="lineno"> 2149</span>                value = value.reindex(index=self.obj.columns, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2150</span>                value.name = indexer</div>
<div class="line"><span class="lineno"> 2151</span>            <span class="keywordflow">elif</span> isinstance(value, dict):</div>
<div class="line"><span class="lineno"> 2152</span>                value = Series(</div>
<div class="line"><span class="lineno"> 2153</span>                    value, index=self.obj.columns, name=indexer, dtype=object</div>
<div class="line"><span class="lineno"> 2154</span>                )</div>
<div class="line"><span class="lineno"> 2155</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2156</span>                <span class="comment"># a list-list</span></div>
<div class="line"><span class="lineno"> 2157</span>                <span class="keywordflow">if</span> is_list_like_indexer(value):</div>
<div class="line"><span class="lineno"> 2158</span>                    <span class="comment"># must have conforming columns</span></div>
<div class="line"><span class="lineno"> 2159</span>                    <span class="keywordflow">if</span> len(value) != len(self.obj.columns):</div>
<div class="line"><span class="lineno"> 2160</span>                        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot set a row with mismatched columns&quot;</span>)</div>
<div class="line"><span class="lineno"> 2161</span> </div>
<div class="line"><span class="lineno"> 2162</span>                value = Series(value, index=self.obj.columns, name=indexer)</div>
<div class="line"><span class="lineno"> 2163</span> </div>
<div class="line"><span class="lineno"> 2164</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self.obj):</div>
<div class="line"><span class="lineno"> 2165</span>                <span class="comment"># We will ignore the existing dtypes instead of using</span></div>
<div class="line"><span class="lineno"> 2166</span>                <span class="comment">#  internals.concat logic</span></div>
<div class="line"><span class="lineno"> 2167</span>                df = value.to_frame().T</div>
<div class="line"><span class="lineno"> 2168</span> </div>
<div class="line"><span class="lineno"> 2169</span>                idx = self.obj.index</div>
<div class="line"><span class="lineno"> 2170</span>                <span class="keywordflow">if</span> isinstance(idx, MultiIndex):</div>
<div class="line"><span class="lineno"> 2171</span>                    name = idx.names</div>
<div class="line"><span class="lineno"> 2172</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2173</span>                    name = idx.name</div>
<div class="line"><span class="lineno"> 2174</span> </div>
<div class="line"><span class="lineno"> 2175</span>                df.index = Index([indexer], name=name)</div>
<div class="line"><span class="lineno"> 2176</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> has_dtype:</div>
<div class="line"><span class="lineno"> 2177</span>                    <span class="comment"># i.e. if we already had a Series or ndarray, keep that</span></div>
<div class="line"><span class="lineno"> 2178</span>                    <span class="comment">#  dtype.  But if we had a list or dict, then do inference</span></div>
<div class="line"><span class="lineno"> 2179</span>                    df = df.infer_objects()</div>
<div class="line"><span class="lineno"> 2180</span>                self.obj._mgr = df._mgr</div>
<div class="line"><span class="lineno"> 2181</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2182</span>                self.obj._mgr = self.obj._append(value)._mgr</div>
<div class="line"><span class="lineno"> 2183</span>            self.obj._maybe_update_cacher(clear=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2184</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac3f18b43137aab9313af2750d73ad545" name="ac3f18b43137aab9313af2750d73ad545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f18b43137aab9313af2750d73ad545">&#9670;&#160;</a></span>_setitem_with_indexer_split_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._setitem_with_indexer_split_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Setitem column-wise.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1799</span>    <span class="keyword">def </span>_setitem_with_indexer_split_path(self, indexer, value, name: str):</div>
<div class="line"><span class="lineno"> 1800</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">        Setitem column-wise.</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1803</span>        <span class="comment"># Above we only set take_split_path to True for 2D cases</span></div>
<div class="line"><span class="lineno"> 1804</span>        <span class="keyword">assert</span> self.ndim == 2</div>
<div class="line"><span class="lineno"> 1805</span> </div>
<div class="line"><span class="lineno"> 1806</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(indexer, tuple):</div>
<div class="line"><span class="lineno"> 1807</span>            indexer = _tuplify(self.ndim, indexer)</div>
<div class="line"><span class="lineno"> 1808</span>        <span class="keywordflow">if</span> len(indexer) &gt; self.ndim:</div>
<div class="line"><span class="lineno"> 1809</span>            <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&quot;too many indices for array&quot;</span>)</div>
<div class="line"><span class="lineno"> 1810</span>        <span class="keywordflow">if</span> isinstance(indexer[0], np.ndarray) <span class="keywordflow">and</span> indexer[0].ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 1811</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">r&quot;Cannot set values with ndim &gt; 2&quot;</span>)</div>
<div class="line"><span class="lineno"> 1812</span> </div>
<div class="line"><span class="lineno"> 1813</span>        <span class="keywordflow">if</span> (isinstance(value, ABCSeries) <span class="keywordflow">and</span> name != <span class="stringliteral">&quot;iloc&quot;</span>) <span class="keywordflow">or</span> isinstance(value, dict):</div>
<div class="line"><span class="lineno"> 1814</span>            <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno"> 1815</span> </div>
<div class="line"><span class="lineno"> 1816</span>            value = self._align_series(indexer, Series(value))</div>
<div class="line"><span class="lineno"> 1817</span> </div>
<div class="line"><span class="lineno"> 1818</span>        <span class="comment"># Ensure we have something we can iterate over</span></div>
<div class="line"><span class="lineno"> 1819</span>        info_axis = indexer[1]</div>
<div class="line"><span class="lineno"> 1820</span>        ilocs = self._ensure_iterable_column_indexer(info_axis)</div>
<div class="line"><span class="lineno"> 1821</span> </div>
<div class="line"><span class="lineno"> 1822</span>        pi = indexer[0]</div>
<div class="line"><span class="lineno"> 1823</span>        lplane_indexer = length_of_indexer(pi, self.obj.index)</div>
<div class="line"><span class="lineno"> 1824</span>        <span class="comment"># lplane_indexer gives the expected length of obj[indexer[0]]</span></div>
<div class="line"><span class="lineno"> 1825</span> </div>
<div class="line"><span class="lineno"> 1826</span>        <span class="comment"># we need an iterable, with a ndim of at least 1</span></div>
<div class="line"><span class="lineno"> 1827</span>        <span class="comment"># eg. don&#39;t pass through np.array(0)</span></div>
<div class="line"><span class="lineno"> 1828</span>        <span class="keywordflow">if</span> is_list_like_indexer(value) <span class="keywordflow">and</span> getattr(value, <span class="stringliteral">&quot;ndim&quot;</span>, 1) &gt; 0:</div>
<div class="line"><span class="lineno"> 1829</span> </div>
<div class="line"><span class="lineno"> 1830</span>            <span class="keywordflow">if</span> isinstance(value, ABCDataFrame):</div>
<div class="line"><span class="lineno"> 1831</span>                self._setitem_with_indexer_frame_value(indexer, value, name)</div>
<div class="line"><span class="lineno"> 1832</span> </div>
<div class="line"><span class="lineno"> 1833</span>            <span class="keywordflow">elif</span> np.ndim(value) == 2:</div>
<div class="line"><span class="lineno"> 1834</span>                self._setitem_with_indexer_2d_value(indexer, value)</div>
<div class="line"><span class="lineno"> 1835</span> </div>
<div class="line"><span class="lineno"> 1836</span>            <span class="keywordflow">elif</span> len(ilocs) == 1 <span class="keywordflow">and</span> lplane_indexer == len(value) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_scalar(pi):</div>
<div class="line"><span class="lineno"> 1837</span>                <span class="comment"># We are setting multiple rows in a single column.</span></div>
<div class="line"><span class="lineno"> 1838</span>                self._setitem_single_column(ilocs[0], value, pi)</div>
<div class="line"><span class="lineno"> 1839</span> </div>
<div class="line"><span class="lineno"> 1840</span>            <span class="keywordflow">elif</span> len(ilocs) == 1 <span class="keywordflow">and</span> 0 != lplane_indexer != len(value):</div>
<div class="line"><span class="lineno"> 1841</span>                <span class="comment"># We are trying to set N values into M entries of a single</span></div>
<div class="line"><span class="lineno"> 1842</span>                <span class="comment">#  column, which is invalid for N != M</span></div>
<div class="line"><span class="lineno"> 1843</span>                <span class="comment"># Exclude zero-len for e.g. boolean masking that is all-false</span></div>
<div class="line"><span class="lineno"> 1844</span> </div>
<div class="line"><span class="lineno"> 1845</span>                <span class="keywordflow">if</span> len(value) == 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_integer(info_axis):</div>
<div class="line"><span class="lineno"> 1846</span>                    <span class="comment"># This is a case like df.iloc[:3, [1]] = [0]</span></div>
<div class="line"><span class="lineno"> 1847</span>                    <span class="comment">#  where we treat as df.iloc[:3, 1] = 0</span></div>
<div class="line"><span class="lineno"> 1848</span>                    <span class="keywordflow">return</span> self._setitem_with_indexer((pi, info_axis[0]), value[0])</div>
<div class="line"><span class="lineno"> 1849</span> </div>
<div class="line"><span class="lineno"> 1850</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1851</span>                    <span class="stringliteral">&quot;Must have equal len keys and value &quot;</span></div>
<div class="line"><span class="lineno"> 1852</span>                    <span class="stringliteral">&quot;when setting with an iterable&quot;</span></div>
<div class="line"><span class="lineno"> 1853</span>                )</div>
<div class="line"><span class="lineno"> 1854</span> </div>
<div class="line"><span class="lineno"> 1855</span>            <span class="keywordflow">elif</span> lplane_indexer == 0 <span class="keywordflow">and</span> len(value) == len(self.obj.index):</div>
<div class="line"><span class="lineno"> 1856</span>                <span class="comment"># We get here in one case via .loc with a all-False mask</span></div>
<div class="line"><span class="lineno"> 1857</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1858</span> </div>
<div class="line"><span class="lineno"> 1859</span>            <span class="keywordflow">elif</span> self._is_scalar_access(indexer) <span class="keywordflow">and</span> is_object_dtype(</div>
<div class="line"><span class="lineno"> 1860</span>                self.obj.dtypes[ilocs[0]]</div>
<div class="line"><span class="lineno"> 1861</span>            ):</div>
<div class="line"><span class="lineno"> 1862</span>                <span class="comment"># We are setting nested data, only possible for object dtype data</span></div>
<div class="line"><span class="lineno"> 1863</span>                self._setitem_single_column(indexer[1], value, pi)</div>
<div class="line"><span class="lineno"> 1864</span> </div>
<div class="line"><span class="lineno"> 1865</span>            <span class="keywordflow">elif</span> len(ilocs) == len(value):</div>
<div class="line"><span class="lineno"> 1866</span>                <span class="comment"># We are setting multiple columns in a single row.</span></div>
<div class="line"><span class="lineno"> 1867</span>                <span class="keywordflow">for</span> loc, v <span class="keywordflow">in</span> zip(ilocs, value):</div>
<div class="line"><span class="lineno"> 1868</span>                    self._setitem_single_column(loc, v, pi)</div>
<div class="line"><span class="lineno"> 1869</span> </div>
<div class="line"><span class="lineno"> 1870</span>            <span class="keywordflow">elif</span> len(ilocs) == 1 <span class="keywordflow">and</span> com.is_null_slice(pi) <span class="keywordflow">and</span> len(self.obj) == 0:</div>
<div class="line"><span class="lineno"> 1871</span>                <span class="comment"># This is a setitem-with-expansion, see</span></div>
<div class="line"><span class="lineno"> 1872</span>                <span class="comment">#  test_loc_setitem_empty_append_expands_rows_mixed_dtype</span></div>
<div class="line"><span class="lineno"> 1873</span>                <span class="comment"># e.g. df = DataFrame(columns=[&quot;x&quot;, &quot;y&quot;])</span></div>
<div class="line"><span class="lineno"> 1874</span>                <span class="comment">#  df[&quot;x&quot;] = df[&quot;x&quot;].astype(np.int64)</span></div>
<div class="line"><span class="lineno"> 1875</span>                <span class="comment">#  df.loc[:, &quot;x&quot;] = [1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1876</span>                self._setitem_single_column(ilocs[0], value, pi)</div>
<div class="line"><span class="lineno"> 1877</span> </div>
<div class="line"><span class="lineno"> 1878</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1879</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1880</span>                    <span class="stringliteral">&quot;Must have equal len keys and value &quot;</span></div>
<div class="line"><span class="lineno"> 1881</span>                    <span class="stringliteral">&quot;when setting with an iterable&quot;</span></div>
<div class="line"><span class="lineno"> 1882</span>                )</div>
<div class="line"><span class="lineno"> 1883</span> </div>
<div class="line"><span class="lineno"> 1884</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1885</span> </div>
<div class="line"><span class="lineno"> 1886</span>            <span class="comment"># scalar value</span></div>
<div class="line"><span class="lineno"> 1887</span>            <span class="keywordflow">for</span> loc <span class="keywordflow">in</span> ilocs:</div>
<div class="line"><span class="lineno"> 1888</span>                self._setitem_single_column(loc, value, pi)</div>
<div class="line"><span class="lineno"> 1889</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a29976f350693bb5eb9b2b031259193d5" name="a29976f350693bb5eb9b2b031259193d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29976f350693bb5eb9b2b031259193d5">&#9670;&#160;</a></span>_validate_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexing._iLocIndexer._validate_integer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check that 'key' is a valid position in the desired axis.

Parameters
----------
key : int
    Requested position.
axis : int
    Desired axis.

Raises
------
IndexError
    If 'key' is not a valid position in axis 'axis'.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1539</span>    <span class="keyword">def </span>_validate_integer(self, key: int, axis: int) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1540</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">        Check that &#39;key&#39; is a valid position in the desired axis.</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">        key : int</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">            Requested position.</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">        axis : int</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">            Desired axis.</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">        IndexError</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">            If &#39;key&#39; is not a valid position in axis &#39;axis&#39;.</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1555</span>        len_axis = len(self.obj._get_axis(axis))</div>
<div class="line"><span class="lineno"> 1556</span>        <span class="keywordflow">if</span> key &gt;= len_axis <span class="keywordflow">or</span> key &lt; -len_axis:</div>
<div class="line"><span class="lineno"> 1557</span>            <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&quot;single positional indexer is out-of-bounds&quot;</span>)</div>
<div class="line"><span class="lineno"> 1558</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ccd1233b1a2a8344513c2d353022ecf" name="a2ccd1233b1a2a8344513c2d353022ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccd1233b1a2a8344513c2d353022ecf">&#9670;&#160;</a></span>_validate_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer._validate_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure that key is valid for current indexer.

Parameters
----------
key : scalar, slice or list-like
    Key requested.
axis : int
    Dimension on which the indexing is being made.

Raises
------
TypeError
    If the key (or some element of it) has wrong type.
IndexError
    If the key (or some element of it) is out of bounds.
KeyError
    If the key was not found.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1indexing_1_1___location_indexer.html#a6668081c375403f4f9f0ba2befa368b8">pandas.core.indexing._LocationIndexer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1448</span>    <span class="keyword">def </span>_validate_key(self, key, axis: int):</div>
<div class="line"><span class="lineno"> 1449</span>        <span class="keywordflow">if</span> com.is_bool_indexer(key):</div>
<div class="line"><span class="lineno"> 1450</span>            <span class="keywordflow">if</span> hasattr(key, <span class="stringliteral">&quot;index&quot;</span>) <span class="keywordflow">and</span> isinstance(key.index, Index):</div>
<div class="line"><span class="lineno"> 1451</span>                <span class="keywordflow">if</span> key.index.inferred_type == <span class="stringliteral">&quot;integer&quot;</span>:</div>
<div class="line"><span class="lineno"> 1452</span>                    <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 1453</span>                        <span class="stringliteral">&quot;iLocation based boolean &quot;</span></div>
<div class="line"><span class="lineno"> 1454</span>                        <span class="stringliteral">&quot;indexing on an integer type &quot;</span></div>
<div class="line"><span class="lineno"> 1455</span>                        <span class="stringliteral">&quot;is not available&quot;</span></div>
<div class="line"><span class="lineno"> 1456</span>                    )</div>
<div class="line"><span class="lineno"> 1457</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1458</span>                    <span class="stringliteral">&quot;iLocation based boolean indexing cannot use &quot;</span></div>
<div class="line"><span class="lineno"> 1459</span>                    <span class="stringliteral">&quot;an indexable as a mask&quot;</span></div>
<div class="line"><span class="lineno"> 1460</span>                )</div>
<div class="line"><span class="lineno"> 1461</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1462</span> </div>
<div class="line"><span class="lineno"> 1463</span>        <span class="keywordflow">if</span> isinstance(key, slice):</div>
<div class="line"><span class="lineno"> 1464</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1465</span>        <span class="keywordflow">elif</span> is_integer(key):</div>
<div class="line"><span class="lineno"> 1466</span>            self._validate_integer(key, axis)</div>
<div class="line"><span class="lineno"> 1467</span>        <span class="keywordflow">elif</span> isinstance(key, tuple):</div>
<div class="line"><span class="lineno"> 1468</span>            <span class="comment"># a tuple should already have been caught by this point</span></div>
<div class="line"><span class="lineno"> 1469</span>            <span class="comment"># so don&#39;t treat a tuple as a valid indexer</span></div>
<div class="line"><span class="lineno"> 1470</span>            <span class="keywordflow">raise</span> IndexingError(<span class="stringliteral">&quot;Too many indexers&quot;</span>)</div>
<div class="line"><span class="lineno"> 1471</span>        <span class="keywordflow">elif</span> is_list_like_indexer(key):</div>
<div class="line"><span class="lineno"> 1472</span>            arr = np.array(key)</div>
<div class="line"><span class="lineno"> 1473</span>            len_axis = len(self.obj._get_axis(axis))</div>
<div class="line"><span class="lineno"> 1474</span> </div>
<div class="line"><span class="lineno"> 1475</span>            <span class="comment"># check that the key has a numeric dtype</span></div>
<div class="line"><span class="lineno"> 1476</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_numeric_dtype(arr.dtype):</div>
<div class="line"><span class="lineno"> 1477</span>                <span class="keywordflow">raise</span> IndexError(f<span class="stringliteral">&quot;.iloc requires numeric indexers, got {arr}&quot;</span>)</div>
<div class="line"><span class="lineno"> 1478</span> </div>
<div class="line"><span class="lineno"> 1479</span>            <span class="comment"># check that the key does not exceed the maximum size of the index</span></div>
<div class="line"><span class="lineno"> 1480</span>            <span class="keywordflow">if</span> len(arr) <span class="keywordflow">and</span> (arr.max() &gt;= len_axis <span class="keywordflow">or</span> arr.min() &lt; -len_axis):</div>
<div class="line"><span class="lineno"> 1481</span>                <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&quot;positional indexers are out-of-bounds&quot;</span>)</div>
<div class="line"><span class="lineno"> 1482</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1483</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Can only index by location with a [{self._valid_types}]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1484</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1f3dca75aac7538d60f5a085c09ee968" name="a1f3dca75aac7538d60f5a085c09ee968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3dca75aac7538d60f5a085c09ee968">&#9670;&#160;</a></span>_takeable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.indexing._iLocIndexer._takeable = True</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e454324629549665c259133462e300c" name="a0e454324629549665c259133462e300c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e454324629549665c259133462e300c">&#9670;&#160;</a></span>_valid_types</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pandas.core.indexing._iLocIndexer._valid_types</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  (</div>
<div class="line">        <span class="stringliteral">&quot;integer, integer slice (START point is INCLUDED, END &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;point is EXCLUDED), listlike of integers, boolean array&quot;</span></div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f3c2b6498bb5aaa62c5e5385fa9cef5" name="a5f3c2b6498bb5aaa62c5e5385fa9cef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3c2b6498bb5aaa62c5e5385fa9cef5">&#9670;&#160;</a></span>ndim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer.ndim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a586e87f31d0b2ce0c6b0b77307b6f220" name="a586e87f31d0b2ce0c6b0b77307b6f220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586e87f31d0b2ce0c6b0b77307b6f220">&#9670;&#160;</a></span>obj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexing._iLocIndexer.obj</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/pandas/core/<a class="el" href="indexing_8py.html">indexing.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
