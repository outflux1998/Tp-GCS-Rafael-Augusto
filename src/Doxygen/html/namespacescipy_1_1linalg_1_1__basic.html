<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.linalg._basic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html">_basic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg._basic Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1df65d9545835366e2b31a1fcff7243" id="r_ae1df65d9545835366e2b31a1fcff7243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#ae1df65d9545835366e2b31a1fcff7243">_solve_check</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, info, lamch=None, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=None)</td></tr>
<tr class="separator:ae1df65d9545835366e2b31a1fcff7243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8df315d0101b470abb0ec264115a02" id="r_adf8df315d0101b470abb0ec264115a02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#adf8df315d0101b470abb0ec264115a02">solve</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, sym_pos=False, lower=False, overwrite_a=False, overwrite_b=False, check_finite=True, assume_a='gen', transposed=False)</td></tr>
<tr class="separator:adf8df315d0101b470abb0ec264115a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebf69aafbab343a582ea7441b8eebe1" id="r_a0ebf69aafbab343a582ea7441b8eebe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a0ebf69aafbab343a582ea7441b8eebe1">solve_triangular</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, <a class="el" href="__blas__subroutines_8h.html#ac2c81d916d6b7d6ad26c81ad7cfe575f">trans</a>=0, lower=False, unit_diagonal=False, overwrite_b=False, check_finite=True)</td></tr>
<tr class="separator:a0ebf69aafbab343a582ea7441b8eebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02f4acec8b4e87fc786930661a61e9c" id="r_ac02f4acec8b4e87fc786930661a61e9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#ac02f4acec8b4e87fc786930661a61e9c">solve_banded</a> (l_and_u, <a class="el" href="__lapack__subroutines_8h.html#ac5085aa45a46dc3bb6b493f94e6c91f4">ab</a>, b, overwrite_ab=False, overwrite_b=False, check_finite=True)</td></tr>
<tr class="separator:ac02f4acec8b4e87fc786930661a61e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a424ac351c88519ec403e156cf825f" id="r_a80a424ac351c88519ec403e156cf825f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a80a424ac351c88519ec403e156cf825f">solveh_banded</a> (<a class="el" href="__lapack__subroutines_8h.html#ac5085aa45a46dc3bb6b493f94e6c91f4">ab</a>, b, overwrite_ab=False, overwrite_b=False, lower=False, check_finite=True)</td></tr>
<tr class="separator:a80a424ac351c88519ec403e156cf825f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0a809357e4f6af2a1ca9252de7e89d" id="r_aaa0a809357e4f6af2a1ca9252de7e89d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#aaa0a809357e4f6af2a1ca9252de7e89d">solve_toeplitz</a> (c_or_cr, b, check_finite=True)</td></tr>
<tr class="separator:aaa0a809357e4f6af2a1ca9252de7e89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab607415c7afb8cfd4e44d9c511539491" id="r_ab607415c7afb8cfd4e44d9c511539491"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#ab607415c7afb8cfd4e44d9c511539491">_get_axis_len</a> (aname, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis)</td></tr>
<tr class="separator:ab607415c7afb8cfd4e44d9c511539491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcc964a58db08fcf7179c91657abb1e" id="r_a1dcc964a58db08fcf7179c91657abb1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a1dcc964a58db08fcf7179c91657abb1e">solve_circulant</a> (c, b, singular='raise', <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=None, caxis=-1, baxis=0, outaxis=0)</td></tr>
<tr class="separator:a1dcc964a58db08fcf7179c91657abb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1fe25cb9553c34356d69a8055f6c81" id="r_acd1fe25cb9553c34356d69a8055f6c81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#acd1fe25cb9553c34356d69a8055f6c81">inv</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, overwrite_a=False, check_finite=True)</td></tr>
<tr class="separator:acd1fe25cb9553c34356d69a8055f6c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a64c16a907f334b37020c3db1af2a4" id="r_a16a64c16a907f334b37020c3db1af2a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a16a64c16a907f334b37020c3db1af2a4">det</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, overwrite_a=False, check_finite=True)</td></tr>
<tr class="separator:a16a64c16a907f334b37020c3db1af2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae339af002324f7cb4bb893c90ef8bdd7" id="r_ae339af002324f7cb4bb893c90ef8bdd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#ae339af002324f7cb4bb893c90ef8bdd7">lstsq</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, cond=None, overwrite_a=False, overwrite_b=False, check_finite=True, lapack_driver=None)</td></tr>
<tr class="separator:ae339af002324f7cb4bb893c90ef8bdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ec828515cdb5d103a6a188a5f20736" id="r_a97ec828515cdb5d103a6a188a5f20736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a97ec828515cdb5d103a6a188a5f20736">pinv</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, atol=None, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=None, return_rank=False, check_finite=True, cond=None, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=None)</td></tr>
<tr class="separator:a97ec828515cdb5d103a6a188a5f20736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835075f4103e045f22553954b9d60ea1" id="r_a835075f4103e045f22553954b9d60ea1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a835075f4103e045f22553954b9d60ea1">pinvh</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, atol=None, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=None, lower=True, return_rank=False, check_finite=True, cond=None, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=None)</td></tr>
<tr class="separator:a835075f4103e045f22553954b9d60ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bd21f408415af3c400d75e0dbe3b8e" id="r_a57bd21f408415af3c400d75e0dbe3b8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a57bd21f408415af3c400d75e0dbe3b8e">matrix_balance</a> (A, permute=True, scale=True, separate=False, overwrite_a=False)</td></tr>
<tr class="separator:a57bd21f408415af3c400d75e0dbe3b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6959880d7b5b5271effe39d19d780ac3" id="r_a6959880d7b5b5271effe39d19d780ac3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a6959880d7b5b5271effe39d19d780ac3">_validate_args_for_toeplitz_ops</a> (c_or_cr, b, check_finite, keep_b_shape, enforce_square=True)</td></tr>
<tr class="separator:a6959880d7b5b5271effe39d19d780ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5916cf56041809a8d8fc176c8a72038c" id="r_a5916cf56041809a8d8fc176c8a72038c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a5916cf56041809a8d8fc176c8a72038c">matmul_toeplitz</a> (c_or_cr, x, check_finite=False, workers=None)</td></tr>
<tr class="separator:a5916cf56041809a8d8fc176c8a72038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a86596f567fe32523d12b4fe39d115492" id="r_a86596f567fe32523d12b4fe39d115492"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__basic.html#a86596f567fe32523d12b4fe39d115492">default_lapack_driver</a></td></tr>
<tr class="separator:a86596f567fe32523d12b4fe39d115492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab607415c7afb8cfd4e44d9c511539491" name="ab607415c7afb8cfd4e44d9c511539491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab607415c7afb8cfd4e44d9c511539491">&#9670;&#160;</a></span>_get_axis_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic._get_axis_len </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  681</span><span class="keyword">def </span>_get_axis_len(aname, a, axis):</div>
<div class="line"><span class="lineno">  682</span>    ax = axis</div>
<div class="line"><span class="lineno">  683</span>    <span class="keywordflow">if</span> ax &lt; 0:</div>
<div class="line"><span class="lineno">  684</span>        ax += a.ndim</div>
<div class="line"><span class="lineno">  685</span>    <span class="keywordflow">if</span> 0 &lt;= ax &lt; a.ndim:</div>
<div class="line"><span class="lineno">  686</span>        <span class="keywordflow">return</span> a.shape[ax]</div>
<div class="line"><span class="lineno">  687</span>    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;%saxis&#39; entry is out of bounds&quot;</span> % (aname,))</div>
<div class="line"><span class="lineno">  688</span> </div>
<div class="line"><span class="lineno">  689</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae1df65d9545835366e2b31a1fcff7243" name="ae1df65d9545835366e2b31a1fcff7243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1df65d9545835366e2b31a1fcff7243">&#9670;&#160;</a></span>_solve_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic._solve_check </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Check arguments during the different steps of the solution phase </pre> <div class="fragment"><div class="line"><span class="lineno">   23</span><span class="keyword">def </span>_solve_check(n, info, lamch=None, rcond=None):</div>
<div class="line"><span class="lineno">   24</span>    <span class="stringliteral">&quot;&quot;&quot; Check arguments during the different steps of the solution phase &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   25</span>    <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno">   26</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;LAPACK reported an illegal value in {}-th argument&#39;</span></div>
<div class="line"><span class="lineno">   27</span>                         <span class="stringliteral">&#39;.&#39;</span>.format(-info))</div>
<div class="line"><span class="lineno">   28</span>    <span class="keywordflow">elif</span> 0 &lt; info:</div>
<div class="line"><span class="lineno">   29</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&#39;Matrix is singular.&#39;</span>)</div>
<div class="line"><span class="lineno">   30</span> </div>
<div class="line"><span class="lineno">   31</span>    <span class="keywordflow">if</span> lamch <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   32</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">   33</span>    E = lamch(<span class="stringliteral">&#39;E&#39;</span>)</div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">if</span> rcond &lt; E:</div>
<div class="line"><span class="lineno">   35</span>        warn(<span class="stringliteral">&#39;Ill-conditioned matrix (rcond={:.6g}): &#39;</span></div>
<div class="line"><span class="lineno">   36</span>             <span class="stringliteral">&#39;result may not be accurate.&#39;</span>.format(rcond),</div>
<div class="line"><span class="lineno">   37</span>             LinAlgWarning, stacklevel=3)</div>
<div class="line"><span class="lineno">   38</span> </div>
<div class="line"><span class="lineno">   39</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6959880d7b5b5271effe39d19d780ac3" name="a6959880d7b5b5271effe39d19d780ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6959880d7b5b5271effe39d19d780ac3">&#9670;&#160;</a></span>_validate_args_for_toeplitz_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic._validate_args_for_toeplitz_ops </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c_or_cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_b_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enforce_square</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validate arguments and format inputs for toeplitz functions

Parameters
----------
c_or_cr : array_like or tuple of (array_like, array_like)
    The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
    actual shape of ``c``, it will be converted to a 1-D array. If not
    supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape
    of ``r``, it will be converted to a 1-D array.
b : (M,) or (M, K) array_like
    Right-hand side in ``T x = b``.
check_finite : bool
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.
keep_b_shape : bool
    Whether to convert a (M,) dimensional b into a (M, 1) dimensional
    matrix.
enforce_square : bool, optional
    If True (default), this verifies that the Toeplitz matrix is square.

Returns
-------
r : array
    1d array corresponding to the first row of the Toeplitz matrix.
c: array
    1d array corresponding to the first column of the Toeplitz matrix.
b: array
    (M,), (M, 1) or (M, K) dimensional array, post validation,
    corresponding to ``b``.
dtype: numpy datatype
    ``dtype`` stores the datatype of ``r``, ``c`` and ``b``. If any of
    ``r``, ``c`` or ``b`` are complex, ``dtype`` is ``np.complex128``,
    otherwise, it is ``np.float``.
b_shape: tuple
    Shape of ``b`` after passing it through ``_asarray_validated``.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1594</span>                                    enforce_square=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 1595</span>    <span class="stringliteral">&quot;&quot;&quot;Validate arguments and format inputs for toeplitz functions</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    c_or_cr : array_like or tuple of (array_like, array_like)</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">        actual shape of ``c``, it will be converted to a 1-D array. If not</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">        supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">        real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">        of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        of ``r``, it will be converted to a 1-D array.</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">    b : (M,) or (M, K) array_like</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">        Right-hand side in ``T x = b``.</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    check_finite : bool</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">        (result entirely NaNs) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">    keep_b_shape : bool</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">        Whether to convert a (M,) dimensional b into a (M, 1) dimensional</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">        matrix.</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral">    enforce_square : bool, optional</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        If True (default), this verifies that the Toeplitz matrix is square.</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">    r : array</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">        1d array corresponding to the first row of the Toeplitz matrix.</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    c: array</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">        1d array corresponding to the first column of the Toeplitz matrix.</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    b: array</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">        (M,), (M, 1) or (M, K) dimensional array, post validation,</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">        corresponding to ``b``.</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    dtype: numpy datatype</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">        ``dtype`` stores the datatype of ``r``, ``c`` and ``b``. If any of</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">        ``r``, ``c`` or ``b`` are complex, ``dtype`` is ``np.complex128``,</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">        otherwise, it is ``np.float``.</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    b_shape: tuple</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">        Shape of ``b`` after passing it through ``_asarray_validated``.</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1635</span> </div>
<div class="line"><span class="lineno"> 1636</span>    <span class="keywordflow">if</span> isinstance(c_or_cr, tuple):</div>
<div class="line"><span class="lineno"> 1637</span>        c, r = c_or_cr</div>
<div class="line"><span class="lineno"> 1638</span>        c = _asarray_validated(c, check_finite=check_finite).ravel()</div>
<div class="line"><span class="lineno"> 1639</span>        r = _asarray_validated(r, check_finite=check_finite).ravel()</div>
<div class="line"><span class="lineno"> 1640</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1641</span>        c = _asarray_validated(c_or_cr, check_finite=check_finite).ravel()</div>
<div class="line"><span class="lineno"> 1642</span>        r = c.conjugate()</div>
<div class="line"><span class="lineno"> 1643</span> </div>
<div class="line"><span class="lineno"> 1644</span>    <span class="keywordflow">if</span> b <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1645</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;`b` must be an array, not None.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1646</span> </div>
<div class="line"><span class="lineno"> 1647</span>    b = _asarray_validated(b, check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1648</span>    b_shape = b.shape</div>
<div class="line"><span class="lineno"> 1649</span> </div>
<div class="line"><span class="lineno"> 1650</span>    is_not_square = r.shape[0] != c.shape[0]</div>
<div class="line"><span class="lineno"> 1651</span>    <span class="keywordflow">if</span> (enforce_square <span class="keywordflow">and</span> is_not_square) <span class="keywordflow">or</span> b.shape[0] != r.shape[0]:</div>
<div class="line"><span class="lineno"> 1652</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Incompatible dimensions.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1653</span> </div>
<div class="line"><span class="lineno"> 1654</span>    is_cmplx = np.iscomplexobj(r) <span class="keywordflow">or</span> np.iscomplexobj(c) <span class="keywordflow">or</span> np.iscomplexobj(b)</div>
<div class="line"><span class="lineno"> 1655</span>    dtype = np.complex128 <span class="keywordflow">if</span> is_cmplx <span class="keywordflow">else</span> np.double</div>
<div class="line"><span class="lineno"> 1656</span>    r, c, b = (np.asarray(i, dtype=dtype) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> (r, c, b))</div>
<div class="line"><span class="lineno"> 1657</span> </div>
<div class="line"><span class="lineno"> 1658</span>    <span class="keywordflow">if</span> b.ndim == 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> keep_b_shape:</div>
<div class="line"><span class="lineno"> 1659</span>        b = b.reshape(-1, 1)</div>
<div class="line"><span class="lineno"> 1660</span>    <span class="keywordflow">elif</span> b.ndim != 1:</div>
<div class="line"><span class="lineno"> 1661</span>        b = b.reshape(b.shape[0], -1)</div>
<div class="line"><span class="lineno"> 1662</span> </div>
<div class="line"><span class="lineno"> 1663</span>    <span class="keywordflow">return</span> r, c, b, dtype, b_shape</div>
<div class="line"><span class="lineno"> 1664</span> </div>
<div class="line"><span class="lineno"> 1665</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a16a64c16a907f334b37020c3db1af2a4" name="a16a64c16a907f334b37020c3db1af2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a64c16a907f334b37020c3db1af2a4">&#9670;&#160;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the determinant of a matrix

The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.

The determinant for a 3x3 matrix, for example, is computed as follows::

    a    b    c
    d    e    f = A
    g    h    i

    det(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h

Parameters
----------
a : (M, M) array_like
    A square matrix.
overwrite_a : bool, optional
    Allow overwriting data in a (may enhance performance).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
det : float or complex
    Determinant of `a`.

Notes
-----
The determinant is computed via LU factorization, LAPACK routine z/dgetrf.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; linalg.det(a)
0.0
&gt;&gt;&gt; a = np.array([[0,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; linalg.det(a)
3.0</pre> <div class="fragment"><div class="line"><span class="lineno">  965</span><span class="keyword">def </span>det(a, overwrite_a=False, check_finite=True):</div>
<div class="line"><span class="lineno">  966</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    Compute the determinant of a matrix</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    The determinant of a square matrix is a value derived arithmetically</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    from the coefficients of the matrix.</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">    The determinant for a 3x3 matrix, for example, is computed as follows::</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        a    b    c</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">        d    e    f = A</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">        g    h    i</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">        det(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    a : (M, M) array_like</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">        A square matrix.</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    overwrite_a : bool, optional</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">        Allow overwriting data in a (may enhance performance).</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">        Whether to check that the input matrix contains only finite numbers.</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    det : float or complex</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">        Determinant of `a`.</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    The determinant is computed via LU factorization, LAPACK routine z/dgetrf.</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import linalg</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6], [7,8,9]])</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    &gt;&gt;&gt; linalg.det(a)</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[0,2,3], [4,5,6], [7,8,9]])</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    &gt;&gt;&gt; linalg.det(a)</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1011</span>    a1 = _asarray_validated(a, check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1012</span>    <span class="keywordflow">if</span> len(a1.shape) != 2 <span class="keywordflow">or</span> a1.shape[0] != a1.shape[1]:</div>
<div class="line"><span class="lineno"> 1013</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected square matrix&#39;</span>)</div>
<div class="line"><span class="lineno"> 1014</span>    overwrite_a = overwrite_a <span class="keywordflow">or</span> _datacopied(a1, a)</div>
<div class="line"><span class="lineno"> 1015</span>    fdet, = get_flinalg_funcs((<span class="stringliteral">&#39;det&#39;</span>,), (a1,))</div>
<div class="line"><span class="lineno"> 1016</span>    a_det, info = fdet(a1, overwrite_a=overwrite_a)</div>
<div class="line"><span class="lineno"> 1017</span>    <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno"> 1018</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value in %d-th argument of internal &#39;</span></div>
<div class="line"><span class="lineno"> 1019</span>                         <span class="stringliteral">&#39;det.getrf&#39;</span> % -info)</div>
<div class="line"><span class="lineno"> 1020</span>    <span class="keywordflow">return</span> a_det</div>
<div class="line"><span class="lineno"> 1021</span> </div>
<div class="line"><span class="lineno"> 1022</span> </div>
<div class="line"><span class="lineno"> 1023</span><span class="comment"># Linear Least Squares</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="acd1fe25cb9553c34356d69a8055f6c81" name="acd1fe25cb9553c34356d69a8055f6c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1fe25cb9553c34356d69a8055f6c81">&#9670;&#160;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.inv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the inverse of a matrix.

Parameters
----------
a : array_like
    Square matrix to be inverted.
overwrite_a : bool, optional
    Discard data in `a` (may improve performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
ainv : ndarray
    Inverse of the matrix `a`.

Raises
------
LinAlgError
    If `a` is singular.
ValueError
    If `a` is not square, or not 2D.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])
&gt;&gt;&gt; linalg.inv(a)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
&gt;&gt;&gt; np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
       [ 0.,  1.]])</pre> <div class="fragment"><div class="line"><span class="lineno">  888</span><span class="keyword">def </span>inv(a, overwrite_a=False, check_finite=True):</div>
<div class="line"><span class="lineno">  889</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    Compute the inverse of a matrix.</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">        Square matrix to be inverted.</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    overwrite_a : bool, optional</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">        Discard data in `a` (may improve performance). Default is False.</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">        Whether to check that the input matrix contains only finite numbers.</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    ainv : ndarray</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">        Inverse of the matrix `a`.</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        If `a` is singular.</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        If `a` is not square, or not 2D.</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import linalg</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    &gt;&gt;&gt; linalg.inv(a)</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    array([[-2. ,  1. ],</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">           [ 1.5, -0.5]])</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(a, linalg.inv(a))</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    array([[ 1.,  0.],</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">           [ 0.,  1.]])</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  927</span>    a1 = _asarray_validated(a, check_finite=check_finite)</div>
<div class="line"><span class="lineno">  928</span>    <span class="keywordflow">if</span> len(a1.shape) != 2 <span class="keywordflow">or</span> a1.shape[0] != a1.shape[1]:</div>
<div class="line"><span class="lineno">  929</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  930</span>    overwrite_a = overwrite_a <span class="keywordflow">or</span> _datacopied(a1, a)</div>
<div class="line"><span class="lineno">  931</span>    <span class="comment"># XXX: I found no advantage or disadvantage of using finv.</span></div>
<div class="line"><span class="lineno">  932</span><span class="comment">#     finv, = get_flinalg_funcs((&#39;inv&#39;,),(a1,))</span></div>
<div class="line"><span class="lineno">  933</span><span class="comment">#     if finv is not None:</span></div>
<div class="line"><span class="lineno">  934</span><span class="comment">#         a_inv,info = finv(a1,overwrite_a=overwrite_a)</span></div>
<div class="line"><span class="lineno">  935</span><span class="comment">#         if info==0:</span></div>
<div class="line"><span class="lineno">  936</span><span class="comment">#             return a_inv</span></div>
<div class="line"><span class="lineno">  937</span><span class="comment">#         if info&gt;0: raise LinAlgError, &quot;singular matrix&quot;</span></div>
<div class="line"><span class="lineno">  938</span><span class="comment">#         if info&lt;0: raise ValueError(&#39;illegal value in %d-th argument of &#39;</span></div>
<div class="line"><span class="lineno">  939</span><span class="comment">#                                     &#39;internal inv.getrf|getri&#39;%(-info))</span></div>
<div class="line"><span class="lineno">  940</span>    getrf, getri, getri_lwork = get_lapack_funcs((<span class="stringliteral">&#39;getrf&#39;</span>, <span class="stringliteral">&#39;getri&#39;</span>,</div>
<div class="line"><span class="lineno">  941</span>                                                  <span class="stringliteral">&#39;getri_lwork&#39;</span>),</div>
<div class="line"><span class="lineno">  942</span>                                                 (a1,))</div>
<div class="line"><span class="lineno">  943</span>    lu, piv, info = getrf(a1, overwrite_a=overwrite_a)</div>
<div class="line"><span class="lineno">  944</span>    <span class="keywordflow">if</span> info == 0:</div>
<div class="line"><span class="lineno">  945</span>        lwork = _compute_lwork(getri_lwork, a1.shape[0])</div>
<div class="line"><span class="lineno">  946</span> </div>
<div class="line"><span class="lineno">  947</span>        <span class="comment"># XXX: the following line fixes curious SEGFAULT when</span></div>
<div class="line"><span class="lineno">  948</span>        <span class="comment"># benchmarking 500x500 matrix inverse. This seems to</span></div>
<div class="line"><span class="lineno">  949</span>        <span class="comment"># be a bug in LAPACK ?getri routine because if lwork is</span></div>
<div class="line"><span class="lineno">  950</span>        <span class="comment"># minimal (when using lwork[0] instead of lwork[1]) then</span></div>
<div class="line"><span class="lineno">  951</span>        <span class="comment"># all tests pass. Further investigation is required if</span></div>
<div class="line"><span class="lineno">  952</span>        <span class="comment"># more such SEGFAULTs occur.</span></div>
<div class="line"><span class="lineno">  953</span>        lwork = int(1.01 * lwork)</div>
<div class="line"><span class="lineno">  954</span>        inv_a, info = getri(lu, piv, lwork=lwork, overwrite_lu=1)</div>
<div class="line"><span class="lineno">  955</span>    <span class="keywordflow">if</span> info &gt; 0:</div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;singular matrix&quot;</span>)</div>
<div class="line"><span class="lineno">  957</span>    <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno">  958</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value in %d-th argument of internal &#39;</span></div>
<div class="line"><span class="lineno">  959</span>                         <span class="stringliteral">&#39;getrf|getri&#39;</span> % -info)</div>
<div class="line"><span class="lineno">  960</span>    <span class="keywordflow">return</span> inv_a</div>
<div class="line"><span class="lineno">  961</span> </div>
<div class="line"><span class="lineno">  962</span> </div>
<div class="line"><span class="lineno">  963</span><span class="comment"># Determinant</span></div>
<div class="line"><span class="lineno">  964</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae339af002324f7cb4bb893c90ef8bdd7" name="ae339af002324f7cb4bb893c90ef8bdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae339af002324f7cb4bb893c90ef8bdd7">&#9670;&#160;</a></span>lstsq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.lstsq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cond</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lapack_driver</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute least-squares solution to equation Ax = b.

Compute a vector x such that the 2-norm ``|b - A x|`` is minimized.

Parameters
----------
a : (M, N) array_like
    Left-hand side array
b : (M,) or (M, K) array_like
    Right hand side array
cond : float, optional
    Cutoff for 'small' singular values; used to determine effective
    rank of a. Singular values smaller than
    ``cond * largest_singular_value`` are considered zero.
overwrite_a : bool, optional
    Discard data in `a` (may enhance performance). Default is False.
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : str, optional
    Which LAPACK driver is used to solve the least-squares problem.
    Options are ``'gelsd'``, ``'gelsy'``, ``'gelss'``. Default
    (``'gelsd'``) is a good choice.  However, ``'gelsy'`` can be slightly
    faster on many problems.  ``'gelss'`` was used historically.  It is
    generally slow but uses less memory.

    .. versionadded:: 0.17.0

Returns
-------
x : (N,) or (N, K) ndarray
    Least-squares solution.
residues : (K,) ndarray or float
    Square of the 2-norm for each column in ``b - a x``, if ``M &gt; N`` and
    ``ndim(A) == n`` (returns a scalar if ``b`` is 1-D). Otherwise a
    (0,)-shaped array is returned.
rank : int
    Effective rank of `a`.
s : (min(M, N),) ndarray or None
    Singular values of `a`. The condition number of ``a`` is
    ``s[0] / s[-1]``.

Raises
------
LinAlgError
    If computation does not converge.

ValueError
    When parameters are not compatible.

See Also
--------
scipy.optimize.nnls : linear least squares with non-negativity constraint

Notes
-----
When ``'gelsy'`` is used as a driver, `residues` is set to a (0,)-shaped
array and `s` is always ``None``.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import lstsq
&gt;&gt;&gt; import matplotlib.pyplot as plt

Suppose we have the following data:

&gt;&gt;&gt; x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])
&gt;&gt;&gt; y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])

We want to fit a quadratic polynomial of the form ``y = a + b*x**2``
to this data.  We first form the "design matrix" M, with a constant
column of 1s and a column containing ``x**2``:

&gt;&gt;&gt; M = x[:, np.newaxis]**[0, 2]
&gt;&gt;&gt; M
array([[  1.  ,   1.  ],
       [  1.  ,   6.25],
       [  1.  ,  12.25],
       [  1.  ,  16.  ],
       [  1.  ,  25.  ],
       [  1.  ,  49.  ],
       [  1.  ,  72.25]])

We want to find the least-squares solution to ``M.dot(p) = y``,
where ``p`` is a vector with length 2 that holds the parameters
``a`` and ``b``.

&gt;&gt;&gt; p, res, rnk, s = lstsq(M, y)
&gt;&gt;&gt; p
array([ 0.20925829,  0.12013861])

Plot the data and the fitted curve.

&gt;&gt;&gt; plt.plot(x, y, 'o', label='data')
&gt;&gt;&gt; xx = np.linspace(0, 9, 101)
&gt;&gt;&gt; yy = p[0] + p[1]*xx**2
&gt;&gt;&gt; plt.plot(xx, yy, label='least squares fit, $y = a + bx^2$')
&gt;&gt;&gt; plt.xlabel('x')
&gt;&gt;&gt; plt.ylabel('y')
&gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)
&gt;&gt;&gt; plt.grid(alpha=0.25)
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1025</span>          check_finite=<span class="keyword">True</span>, lapack_driver=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1026</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    Compute least-squares solution to equation Ax = b.</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    Compute a vector x such that the 2-norm ``|b - A x|`` is minimized.</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    a : (M, N) array_like</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">        Left-hand side array</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    b : (M,) or (M, K) array_like</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">        Right hand side array</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    cond : float, optional</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">        Cutoff for &#39;small&#39; singular values; used to determine effective</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">        rank of a. Singular values smaller than</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">        ``cond * largest_singular_value`` are considered zero.</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    overwrite_a : bool, optional</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        Discard data in `a` (may enhance performance). Default is False.</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    overwrite_b : bool, optional</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">        Discard data in `b` (may enhance performance). Default is False.</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    lapack_driver : str, optional</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">        Which LAPACK driver is used to solve the least-squares problem.</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">        Options are ``&#39;gelsd&#39;``, ``&#39;gelsy&#39;``, ``&#39;gelss&#39;``. Default</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">        (``&#39;gelsd&#39;``) is a good choice.  However, ``&#39;gelsy&#39;`` can be slightly</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">        faster on many problems.  ``&#39;gelss&#39;`` was used historically.  It is</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">        generally slow but uses less memory.</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">        .. versionadded:: 0.17.0</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    x : (N,) or (N, K) ndarray</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">        Least-squares solution.</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    residues : (K,) ndarray or float</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">        Square of the 2-norm for each column in ``b - a x``, if ``M &gt; N`` and</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        ``ndim(A) == n`` (returns a scalar if ``b`` is 1-D). Otherwise a</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">        (0,)-shaped array is returned.</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    rank : int</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">        Effective rank of `a`.</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    s : (min(M, N),) ndarray or None</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">        Singular values of `a`. The condition number of ``a`` is</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">        ``s[0] / s[-1]``.</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        If computation does not converge.</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">        When parameters are not compatible.</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    scipy.optimize.nnls : linear least squares with non-negativity constraint</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    When ``&#39;gelsy&#39;`` is used as a driver, `residues` is set to a (0,)-shaped</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    array and `s` is always ``None``.</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import lstsq</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    Suppose we have the following data:</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    We want to fit a quadratic polynomial of the form ``y = a + b*x**2``</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">    to this data.  We first form the &quot;design matrix&quot; M, with a constant</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    column of 1s and a column containing ``x**2``:</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    &gt;&gt;&gt; M = x[:, np.newaxis]**[0, 2]</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    &gt;&gt;&gt; M</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">    array([[  1.  ,   1.  ],</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">           [  1.  ,   6.25],</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">           [  1.  ,  12.25],</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">           [  1.  ,  16.  ],</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">           [  1.  ,  25.  ],</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">           [  1.  ,  49.  ],</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">           [  1.  ,  72.25]])</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">    We want to find the least-squares solution to ``M.dot(p) = y``,</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    where ``p`` is a vector with length 2 that holds the parameters</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    ``a`` and ``b``.</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    &gt;&gt;&gt; p, res, rnk, s = lstsq(M, y)</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    array([ 0.20925829,  0.12013861])</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    Plot the data and the fitted curve.</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;, label=&#39;data&#39;)</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    &gt;&gt;&gt; xx = np.linspace(0, 9, 101)</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    &gt;&gt;&gt; yy = p[0] + p[1]*xx**2</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(xx, yy, label=&#39;least squares fit, $y = a + bx^2$&#39;)</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;x&#39;)</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;y&#39;)</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(alpha=0.25)</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1134</span>    a1 = _asarray_validated(a, check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1135</span>    b1 = _asarray_validated(b, check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1136</span>    <span class="keywordflow">if</span> len(a1.shape) != 2:</div>
<div class="line"><span class="lineno"> 1137</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Input array a should be 2D&#39;</span>)</div>
<div class="line"><span class="lineno"> 1138</span>    m, n = a1.shape</div>
<div class="line"><span class="lineno"> 1139</span>    <span class="keywordflow">if</span> len(b1.shape) == 2:</div>
<div class="line"><span class="lineno"> 1140</span>        nrhs = b1.shape[1]</div>
<div class="line"><span class="lineno"> 1141</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1142</span>        nrhs = 1</div>
<div class="line"><span class="lineno"> 1143</span>    <span class="keywordflow">if</span> m != b1.shape[0]:</div>
<div class="line"><span class="lineno"> 1144</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Shape mismatch: a and b should have the same number&#39;</span></div>
<div class="line"><span class="lineno"> 1145</span>                         <span class="stringliteral">&#39; of rows ({} != {}).&#39;</span>.format(m, b1.shape[0]))</div>
<div class="line"><span class="lineno"> 1146</span>    <span class="keywordflow">if</span> m == 0 <span class="keywordflow">or</span> n == 0:  <span class="comment"># Zero-sized problem, confuses LAPACK</span></div>
<div class="line"><span class="lineno"> 1147</span>        x = np.zeros((n,) + b1.shape[1:], dtype=np.common_type(a1, b1))</div>
<div class="line"><span class="lineno"> 1148</span>        <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno"> 1149</span>            residues = np.linalg.norm(b1, axis=0)**2</div>
<div class="line"><span class="lineno"> 1150</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1151</span>            residues = np.empty((0,))</div>
<div class="line"><span class="lineno"> 1152</span>        <span class="keywordflow">return</span> x, residues, 0, np.empty((0,))</div>
<div class="line"><span class="lineno"> 1153</span> </div>
<div class="line"><span class="lineno"> 1154</span>    driver = lapack_driver</div>
<div class="line"><span class="lineno"> 1155</span>    <span class="keywordflow">if</span> driver <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1156</span>        driver = lstsq.default_lapack_driver</div>
<div class="line"><span class="lineno"> 1157</span>    <span class="keywordflow">if</span> driver <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;gelsd&#39;</span>, <span class="stringliteral">&#39;gelsy&#39;</span>, <span class="stringliteral">&#39;gelss&#39;</span>):</div>
<div class="line"><span class="lineno"> 1158</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;LAPACK driver &quot;%s&quot; is not found&#39;</span> % driver)</div>
<div class="line"><span class="lineno"> 1159</span> </div>
<div class="line"><span class="lineno"> 1160</span>    lapack_func, lapack_lwork = get_lapack_funcs((driver,</div>
<div class="line"><span class="lineno"> 1161</span>                                                 <span class="stringliteral">&#39;%s_lwork&#39;</span> % driver),</div>
<div class="line"><span class="lineno"> 1162</span>                                                 (a1, b1))</div>
<div class="line"><span class="lineno"> 1163</span>    real_data = <span class="keyword">True</span> <span class="keywordflow">if</span> (lapack_func.dtype.kind == <span class="stringliteral">&#39;f&#39;</span>) <span class="keywordflow">else</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1164</span> </div>
<div class="line"><span class="lineno"> 1165</span>    <span class="keywordflow">if</span> m &lt; n:</div>
<div class="line"><span class="lineno"> 1166</span>        <span class="comment"># need to extend b matrix as it will be filled with</span></div>
<div class="line"><span class="lineno"> 1167</span>        <span class="comment"># a larger solution matrix</span></div>
<div class="line"><span class="lineno"> 1168</span>        <span class="keywordflow">if</span> len(b1.shape) == 2:</div>
<div class="line"><span class="lineno"> 1169</span>            b2 = np.zeros((n, nrhs), dtype=lapack_func.dtype)</div>
<div class="line"><span class="lineno"> 1170</span>            b2[:m, :] = b1</div>
<div class="line"><span class="lineno"> 1171</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1172</span>            b2 = np.zeros(n, dtype=lapack_func.dtype)</div>
<div class="line"><span class="lineno"> 1173</span>            b2[:m] = b1</div>
<div class="line"><span class="lineno"> 1174</span>        b1 = b2</div>
<div class="line"><span class="lineno"> 1175</span> </div>
<div class="line"><span class="lineno"> 1176</span>    overwrite_a = overwrite_a <span class="keywordflow">or</span> _datacopied(a1, a)</div>
<div class="line"><span class="lineno"> 1177</span>    overwrite_b = overwrite_b <span class="keywordflow">or</span> _datacopied(b1, b)</div>
<div class="line"><span class="lineno"> 1178</span> </div>
<div class="line"><span class="lineno"> 1179</span>    <span class="keywordflow">if</span> cond <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1180</span>        cond = np.finfo(lapack_func.dtype).eps</div>
<div class="line"><span class="lineno"> 1181</span> </div>
<div class="line"><span class="lineno"> 1182</span>    <span class="keywordflow">if</span> driver <span class="keywordflow">in</span> (<span class="stringliteral">&#39;gelss&#39;</span>, <span class="stringliteral">&#39;gelsd&#39;</span>):</div>
<div class="line"><span class="lineno"> 1183</span>        <span class="keywordflow">if</span> driver == <span class="stringliteral">&#39;gelss&#39;</span>:</div>
<div class="line"><span class="lineno"> 1184</span>            lwork = _compute_lwork(lapack_lwork, m, n, nrhs, cond)</div>
<div class="line"><span class="lineno"> 1185</span>            v, x, s, rank, work, info = lapack_func(a1, b1, cond, lwork,</div>
<div class="line"><span class="lineno"> 1186</span>                                                    overwrite_a=overwrite_a,</div>
<div class="line"><span class="lineno"> 1187</span>                                                    overwrite_b=overwrite_b)</div>
<div class="line"><span class="lineno"> 1188</span> </div>
<div class="line"><span class="lineno"> 1189</span>        <span class="keywordflow">elif</span> driver == <span class="stringliteral">&#39;gelsd&#39;</span>:</div>
<div class="line"><span class="lineno"> 1190</span>            <span class="keywordflow">if</span> real_data:</div>
<div class="line"><span class="lineno"> 1191</span>                lwork, iwork = _compute_lwork(lapack_lwork, m, n, nrhs, cond)</div>
<div class="line"><span class="lineno"> 1192</span>                x, s, rank, info = lapack_func(a1, b1, lwork,</div>
<div class="line"><span class="lineno"> 1193</span>                                               iwork, cond, <span class="keyword">False</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1194</span>            <span class="keywordflow">else</span>:  <span class="comment"># complex data</span></div>
<div class="line"><span class="lineno"> 1195</span>                lwork, rwork, iwork = _compute_lwork(lapack_lwork, m, n,</div>
<div class="line"><span class="lineno"> 1196</span>                                                     nrhs, cond)</div>
<div class="line"><span class="lineno"> 1197</span>                x, s, rank, info = lapack_func(a1, b1, lwork, rwork, iwork,</div>
<div class="line"><span class="lineno"> 1198</span>                                               cond, <span class="keyword">False</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1199</span>        <span class="keywordflow">if</span> info &gt; 0:</div>
<div class="line"><span class="lineno"> 1200</span>            <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;SVD did not converge in Linear Least Squares&quot;</span>)</div>
<div class="line"><span class="lineno"> 1201</span>        <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno"> 1202</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value in %d-th argument of internal %s&#39;</span></div>
<div class="line"><span class="lineno"> 1203</span>                             % (-info, lapack_driver))</div>
<div class="line"><span class="lineno"> 1204</span>        resids = np.asarray([], dtype=x.dtype)</div>
<div class="line"><span class="lineno"> 1205</span>        <span class="keywordflow">if</span> m &gt; n:</div>
<div class="line"><span class="lineno"> 1206</span>            x1 = x[:n]</div>
<div class="line"><span class="lineno"> 1207</span>            <span class="keywordflow">if</span> rank == n:</div>
<div class="line"><span class="lineno"> 1208</span>                resids = np.sum(np.abs(x[n:])**2, axis=0)</div>
<div class="line"><span class="lineno"> 1209</span>            x = x1</div>
<div class="line"><span class="lineno"> 1210</span>        <span class="keywordflow">return</span> x, resids, rank, s</div>
<div class="line"><span class="lineno"> 1211</span> </div>
<div class="line"><span class="lineno"> 1212</span>    <span class="keywordflow">elif</span> driver == <span class="stringliteral">&#39;gelsy&#39;</span>:</div>
<div class="line"><span class="lineno"> 1213</span>        lwork = _compute_lwork(lapack_lwork, m, n, nrhs, cond)</div>
<div class="line"><span class="lineno"> 1214</span>        jptv = np.zeros((a1.shape[1], 1), dtype=np.int32)</div>
<div class="line"><span class="lineno"> 1215</span>        v, x, j, rank, info = lapack_func(a1, b1, jptv, cond,</div>
<div class="line"><span class="lineno"> 1216</span>                                          lwork, <span class="keyword">False</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1217</span>        <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno"> 1218</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;illegal value in %d-th argument of internal &quot;</span></div>
<div class="line"><span class="lineno"> 1219</span>                             <span class="stringliteral">&quot;gelsy&quot;</span> % -info)</div>
<div class="line"><span class="lineno"> 1220</span>        <span class="keywordflow">if</span> m &gt; n:</div>
<div class="line"><span class="lineno"> 1221</span>            x1 = x[:n]</div>
<div class="line"><span class="lineno"> 1222</span>            x = x1</div>
<div class="line"><span class="lineno"> 1223</span>        <span class="keywordflow">return</span> x, np.array([], x.dtype), rank, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1224</span> </div>
<div class="line"><span class="lineno"> 1225</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5916cf56041809a8d8fc176c8a72038c" name="a5916cf56041809a8d8fc176c8a72038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5916cf56041809a8d8fc176c8a72038c">&#9670;&#160;</a></span>matmul_toeplitz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.matmul_toeplitz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c_or_cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>workers</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Efficient Toeplitz Matrix-Matrix Multiplication using FFT

This function returns the matrix multiplication between a Toeplitz
matrix and a dense matrix.

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c_or_cr : array_like or tuple of (array_like, array_like)
    The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
    actual shape of ``c``, it will be converted to a 1-D array. If not
    supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape
    of ``r``, it will be converted to a 1-D array.
x : (M,) or (M, K) array_like
    Matrix with which to multiply.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.
workers : int, optional
    To pass to scipy.fft.fft and ifft. Maximum number of workers to use
    for parallel computation. If negative, the value wraps around from
    ``os.cpu_count()``. See scipy.fft.fft for more details.

Returns
-------
T @ x : (M,) or (M, K) ndarray
    The result of the matrix multiplication ``T @ x``. Shape of return
    matches shape of `x`.

See Also
--------
toeplitz : Toeplitz matrix
solve_toeplitz : Solve a Toeplitz system using Levinson Recursion

Notes
-----
The Toeplitz matrix is embedded in a circulant matrix and the FFT is used
to efficiently calculate the matrix-matrix product.

Because the computation is based on the FFT, integer inputs will
result in floating point outputs.  This is unlike NumPy's `matmul`,
which preserves the data type of the input.

This is partly based on the implementation that can be found in [1]_,
licensed under the MIT license. More information about the method can be
found in reference [2]_. References [3]_ and [4]_ have more reference
implementations in Python.

.. versionadded:: 1.6.0

References
----------
.. [1] Jacob R Gardner, Geoff Pleiss, David Bindel, Kilian
   Q Weinberger, Andrew Gordon Wilson, "GPyTorch: Blackbox Matrix-Matrix
   Gaussian Process Inference with GPU Acceleration" with contributions
   from Max Balandat and Ruihan Wu. Available online:
   https://github.com/cornellius-gp/gpytorch

.. [2] J. Demmel, P. Koev, and X. Li, "A Brief Survey of Direct Linear
   Solvers". In Z. Bai, J. Demmel, J. Dongarra, A. Ruhe, and H. van der
   Vorst, editors. Templates for the Solution of Algebraic Eigenvalue
   Problems: A Practical Guide. SIAM, Philadelphia, 2000. Available at:
   http://www.netlib.org/utk/people/JackDongarra/etemplates/node384.html

.. [3] R. Scheibler, E. Bezzam, I. Dokmanic, Pyroomacoustics: A Python
   package for audio room simulations and array processing algorithms,
   Proc. IEEE ICASSP, Calgary, CA, 2018.
   https://github.com/LCAV/pyroomacoustics/blob/pypi-release/
   pyroomacoustics/adaptive/util.py

.. [4] Marano S, Edwards B, Ferrari G and Fah D (2017), "Fitting
   Earthquake Spectra: Colored Noise and Incomplete Data", Bulletin of
   the Seismological Society of America., January, 2017. Vol. 107(1),
   pp. 276-291.

Examples
--------
Multiply the Toeplitz matrix T with matrix x::

        [ 1 -1 -2 -3]       [1 10]
    T = [ 3  1 -1 -2]   x = [2 11]
        [ 6  3  1 -1]       [2 11]
        [10  6  3  1]       [5 19]

To specify the Toeplitz matrix, only the first column and the first
row are needed.

&gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T
&gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T
&gt;&gt;&gt; x = np.array([[1, 10], [2, 11], [2, 11], [5, 19]])

&gt;&gt;&gt; from scipy.linalg import toeplitz, matmul_toeplitz
&gt;&gt;&gt; matmul_toeplitz((c, r), x)
array([[-20., -80.],
       [ -7.,  -8.],
       [  9.,  85.],
       [ 33., 218.]])

Check the result by creating the full Toeplitz matrix and
multiplying it by ``x``.

&gt;&gt;&gt; toeplitz(c, r) @ x
array([[-20, -80],
       [ -7,  -8],
       [  9,  85],
       [ 33, 218]])

The full matrix is never formed explicitly, so this routine
is suitable for very large Toeplitz matrices.

&gt;&gt;&gt; n = 1000000
&gt;&gt;&gt; matmul_toeplitz([1] + [0]*(n-1), np.ones(n))
array([1., 1., 1., ..., 1., 1., 1.])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1666</span><span class="keyword">def </span>matmul_toeplitz(c_or_cr, x, check_finite=False, workers=None):</div>
<div class="line"><span class="lineno"> 1667</span>    <span class="stringliteral">&quot;&quot;&quot;Efficient Toeplitz Matrix-Matrix Multiplication using FFT</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    This function returns the matrix multiplication between a Toeplitz</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">    matrix and a dense matrix.</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">    The Toeplitz matrix has constant diagonals, with c as its first column</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    and r as its first row. If r is not given, ``r == conjugate(c)`` is</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">    assumed.</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    c_or_cr : array_like or tuple of (array_like, array_like)</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">        The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">        actual shape of ``c``, it will be converted to a 1-D array. If not</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">        supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">        real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">        of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">        of ``r``, it will be converted to a 1-D array.</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">    x : (M,) or (M, K) array_like</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        Matrix with which to multiply.</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">        (result entirely NaNs) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">    workers : int, optional</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">        To pass to scipy.fft.fft and ifft. Maximum number of workers to use</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">        for parallel computation. If negative, the value wraps around from</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">        ``os.cpu_count()``. See scipy.fft.fft for more details.</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">    T @ x : (M,) or (M, K) ndarray</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">        The result of the matrix multiplication ``T @ x``. Shape of return</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">        matches shape of `x`.</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral">    toeplitz : Toeplitz matrix</span></div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    solve_toeplitz : Solve a Toeplitz system using Levinson Recursion</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">    The Toeplitz matrix is embedded in a circulant matrix and the FFT is used</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">    to efficiently calculate the matrix-matrix product.</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">    Because the computation is based on the FFT, integer inputs will</span></div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">    result in floating point outputs.  This is unlike NumPy&#39;s `matmul`,</span></div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral">    which preserves the data type of the input.</span></div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">    This is partly based on the implementation that can be found in [1]_,</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral">    licensed under the MIT license. More information about the method can be</span></div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    found in reference [2]_. References [3]_ and [4]_ have more reference</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">    implementations in Python.</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral">    .. [1] Jacob R Gardner, Geoff Pleiss, David Bindel, Kilian</span></div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">       Q Weinberger, Andrew Gordon Wilson, &quot;GPyTorch: Blackbox Matrix-Matrix</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">       Gaussian Process Inference with GPU Acceleration&quot; with contributions</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">       from Max Balandat and Ruihan Wu. Available online:</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">       https://github.com/cornellius-gp/gpytorch</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">    .. [2] J. Demmel, P. Koev, and X. Li, &quot;A Brief Survey of Direct Linear</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral">       Solvers&quot;. In Z. Bai, J. Demmel, J. Dongarra, A. Ruhe, and H. van der</span></div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">       Vorst, editors. Templates for the Solution of Algebraic Eigenvalue</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">       Problems: A Practical Guide. SIAM, Philadelphia, 2000. Available at:</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">       http://www.netlib.org/utk/people/JackDongarra/etemplates/node384.html</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral">    .. [3] R. Scheibler, E. Bezzam, I. Dokmanic, Pyroomacoustics: A Python</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">       package for audio room simulations and array processing algorithms,</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">       Proc. IEEE ICASSP, Calgary, CA, 2018.</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">       https://github.com/LCAV/pyroomacoustics/blob/pypi-release/</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">       pyroomacoustics/adaptive/util.py</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">    .. [4] Marano S, Edwards B, Ferrari G and Fah D (2017), &quot;Fitting</span></div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral">       Earthquake Spectra: Colored Noise and Incomplete Data&quot;, Bulletin of</span></div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">       the Seismological Society of America., January, 2017. Vol. 107(1),</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral">       pp. 276-291.</span></div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">    Multiply the Toeplitz matrix T with matrix x::</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">            [ 1 -1 -2 -3]       [1 10]</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">        T = [ 3  1 -1 -2]   x = [2 11]</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">            [ 6  3  1 -1]       [2 11]</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">            [10  6  3  1]       [5 19]</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">    To specify the Toeplitz matrix, only the first column and the first</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">    row are needed.</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">    &gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">    &gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[1, 10], [2, 11], [2, 11], [5, 19]])</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import toeplitz, matmul_toeplitz</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    &gt;&gt;&gt; matmul_toeplitz((c, r), x)</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">    array([[-20., -80.],</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">           [ -7.,  -8.],</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">           [  9.,  85.],</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">           [ 33., 218.]])</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    Check the result by creating the full Toeplitz matrix and</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">    multiplying it by ``x``.</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">    &gt;&gt;&gt; toeplitz(c, r) @ x</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">    array([[-20, -80],</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">           [ -7,  -8],</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">           [  9,  85],</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">           [ 33, 218]])</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    The full matrix is never formed explicitly, so this routine</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">    is suitable for very large Toeplitz matrices.</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">    &gt;&gt;&gt; n = 1000000</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">    &gt;&gt;&gt; matmul_toeplitz([1] + [0]*(n-1), np.ones(n))</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">    array([1., 1., 1., ..., 1., 1., 1.])</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1788</span> </div>
<div class="line"><span class="lineno"> 1789</span>    <span class="keyword">from</span> ..fft <span class="keyword">import</span> fft, ifft, rfft, irfft</div>
<div class="line"><span class="lineno"> 1790</span> </div>
<div class="line"><span class="lineno"> 1791</span>    r, c, x, dtype, x_shape = _validate_args_for_toeplitz_ops(</div>
<div class="line"><span class="lineno"> 1792</span>        c_or_cr, x, check_finite, keep_b_shape=<span class="keyword">False</span>, enforce_square=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1793</span>    n, m = x.shape</div>
<div class="line"><span class="lineno"> 1794</span> </div>
<div class="line"><span class="lineno"> 1795</span>    T_nrows = len(c)</div>
<div class="line"><span class="lineno"> 1796</span>    T_ncols = len(r)</div>
<div class="line"><span class="lineno"> 1797</span>    p = T_nrows + T_ncols - 1  <span class="comment"># equivalent to len(embedded_col)</span></div>
<div class="line"><span class="lineno"> 1798</span> </div>
<div class="line"><span class="lineno"> 1799</span>    embedded_col = np.concatenate((c, r[-1:0:-1]))</div>
<div class="line"><span class="lineno"> 1800</span> </div>
<div class="line"><span class="lineno"> 1801</span>    <span class="keywordflow">if</span> np.iscomplexobj(embedded_col) <span class="keywordflow">or</span> np.iscomplexobj(x):</div>
<div class="line"><span class="lineno"> 1802</span>        fft_mat = fft(embedded_col, axis=0, workers=workers).reshape(-1, 1)</div>
<div class="line"><span class="lineno"> 1803</span>        fft_x = fft(x, n=p, axis=0, workers=workers)</div>
<div class="line"><span class="lineno"> 1804</span> </div>
<div class="line"><span class="lineno"> 1805</span>        mat_times_x = ifft(fft_mat*fft_x, axis=0,</div>
<div class="line"><span class="lineno"> 1806</span>                           workers=workers)[:T_nrows, :]</div>
<div class="line"><span class="lineno"> 1807</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1808</span>        <span class="comment"># Real inputs; using rfft is faster</span></div>
<div class="line"><span class="lineno"> 1809</span>        fft_mat = rfft(embedded_col, axis=0, workers=workers).reshape(-1, 1)</div>
<div class="line"><span class="lineno"> 1810</span>        fft_x = rfft(x, n=p, axis=0, workers=workers)</div>
<div class="line"><span class="lineno"> 1811</span> </div>
<div class="line"><span class="lineno"> 1812</span>        mat_times_x = irfft(fft_mat*fft_x, axis=0,</div>
<div class="line"><span class="lineno"> 1813</span>                            workers=workers, n=p)[:T_nrows, :]</div>
<div class="line"><span class="lineno"> 1814</span> </div>
<div class="line"><span class="lineno"> 1815</span>    return_shape = (T_nrows,) <span class="keywordflow">if</span> len(x_shape) == 1 <span class="keywordflow">else</span> (T_nrows, m)</div>
<div class="line"><span class="lineno"> 1816</span>    <span class="keywordflow">return</span> mat_times_x.reshape(*return_shape)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57bd21f408415af3c400d75e0dbe3b8e" name="a57bd21f408415af3c400d75e0dbe3b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bd21f408415af3c400d75e0dbe3b8e">&#9670;&#160;</a></span>matrix_balance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.matrix_balance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permute</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>separate</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a diagonal similarity transformation for row/column balancing.

The balancing tries to equalize the row and column 1-norms by applying
a similarity transformation such that the magnitude variation of the
matrix entries is reflected to the scaling matrices.

Moreover, if enabled, the matrix is first permuted to isolate the upper
triangular parts of the matrix and, again if scaling is also enabled,
only the remaining subblocks are subjected to scaling.

The balanced matrix satisfies the following equality

.. math::

                    B = T^{-1} A T

The scaling coefficients are approximated to the nearest power of 2
to avoid round-off errors.

Parameters
----------
A : (n, n) array_like
    Square data matrix for the balancing.
permute : bool, optional
    The selector to define whether permutation of A is also performed
    prior to scaling.
scale : bool, optional
    The selector to turn on and off the scaling. If False, the matrix
    will not be scaled.
separate : bool, optional
    This switches from returning a full matrix of the transformation
    to a tuple of two separate 1-D permutation and scaling arrays.
overwrite_a : bool, optional
    This is passed to xGEBAL directly. Essentially, overwrites the result
    to the data. It might increase the space efficiency. See LAPACK manual
    for details. This is False by default.

Returns
-------
B : (n, n) ndarray
    Balanced matrix
T : (n, n) ndarray
    A possibly permuted diagonal matrix whose nonzero entries are
    integer powers of 2 to avoid numerical truncation errors.
scale, perm : (n,) ndarray
    If ``separate`` keyword is set to True then instead of the array
    ``T`` above, the scaling and the permutation vectors are given
    separately as a tuple without allocating the full array ``T``.

Notes
-----
This algorithm is particularly useful for eigenvalue and matrix
decompositions and in many cases it is already called by various
LAPACK routines.

The algorithm is based on the well-known technique of [1]_ and has
been modified to account for special cases. See [2]_ for details
which have been implemented since LAPACK v3.5.0. Before this version
there are corner cases where balancing can actually worsen the
conditioning. See [3]_ for such examples.

The code is a wrapper around LAPACK's xGEBAL routine family for matrix
balancing.

.. versionadded:: 0.19.0

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; x = np.array([[1,2,0], [9,1,0.01], [1,2,10*np.pi]])

&gt;&gt;&gt; y, permscale = linalg.matrix_balance(x)
&gt;&gt;&gt; np.abs(x).sum(axis=0) / np.abs(x).sum(axis=1)
array([ 3.66666667,  0.4995005 ,  0.91312162])

&gt;&gt;&gt; np.abs(y).sum(axis=0) / np.abs(y).sum(axis=1)
array([ 1.2       ,  1.27041742,  0.92658316])  # may vary

&gt;&gt;&gt; permscale  # only powers of 2 (0.5 == 2^(-1))
array([[  0.5,   0. ,  0. ],  # may vary
       [  0. ,   1. ,  0. ],
       [  0. ,   0. ,  1. ]])

References
----------
.. [1] : B.N. Parlett and C. Reinsch, "Balancing a Matrix for
   Calculation of Eigenvalues and Eigenvectors", Numerische Mathematik,
   Vol.13(4), 1969, :doi:`10.1007/BF02165404`

.. [2] : R. James, J. Langou, B.R. Lowery, "On matrix balancing and
   eigenvector computation", 2014, :arxiv:`1401.5766`

.. [3] :  D.S. Watkins. A case where balancing is harmful.
   Electron. Trans. Numer. Anal, Vol.23, 2006.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1447</span>                   overwrite_a=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 1448</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">    Compute a diagonal similarity transformation for row/column balancing.</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">    The balancing tries to equalize the row and column 1-norms by applying</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">    a similarity transformation such that the magnitude variation of the</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    matrix entries is reflected to the scaling matrices.</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">    Moreover, if enabled, the matrix is first permuted to isolate the upper</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">    triangular parts of the matrix and, again if scaling is also enabled,</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">    only the remaining subblocks are subjected to scaling.</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">    The balanced matrix satisfies the following equality</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">                        B = T^{-1} A T</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">    The scaling coefficients are approximated to the nearest power of 2</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    to avoid round-off errors.</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">    A : (n, n) array_like</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">        Square data matrix for the balancing.</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    permute : bool, optional</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">        The selector to define whether permutation of A is also performed</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">        prior to scaling.</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    scale : bool, optional</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">        The selector to turn on and off the scaling. If False, the matrix</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">        will not be scaled.</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">    separate : bool, optional</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">        This switches from returning a full matrix of the transformation</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">        to a tuple of two separate 1-D permutation and scaling arrays.</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">    overwrite_a : bool, optional</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">        This is passed to xGEBAL directly. Essentially, overwrites the result</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">        to the data. It might increase the space efficiency. See LAPACK manual</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">        for details. This is False by default.</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">    B : (n, n) ndarray</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">        Balanced matrix</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">    T : (n, n) ndarray</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">        A possibly permuted diagonal matrix whose nonzero entries are</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">        integer powers of 2 to avoid numerical truncation errors.</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">    scale, perm : (n,) ndarray</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">        If ``separate`` keyword is set to True then instead of the array</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">        ``T`` above, the scaling and the permutation vectors are given</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">        separately as a tuple without allocating the full array ``T``.</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">    This algorithm is particularly useful for eigenvalue and matrix</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    decompositions and in many cases it is already called by various</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">    LAPACK routines.</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    The algorithm is based on the well-known technique of [1]_ and has</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    been modified to account for special cases. See [2]_ for details</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">    which have been implemented since LAPACK v3.5.0. Before this version</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    there are corner cases where balancing can actually worsen the</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">    conditioning. See [3]_ for such examples.</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    The code is a wrapper around LAPACK&#39;s xGEBAL routine family for matrix</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    balancing.</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    .. versionadded:: 0.19.0</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import linalg</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[1,2,0], [9,1,0.01], [1,2,10*np.pi]])</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    &gt;&gt;&gt; y, permscale = linalg.matrix_balance(x)</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    &gt;&gt;&gt; np.abs(x).sum(axis=0) / np.abs(x).sum(axis=1)</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    array([ 3.66666667,  0.4995005 ,  0.91312162])</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">    &gt;&gt;&gt; np.abs(y).sum(axis=0) / np.abs(y).sum(axis=1)</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    array([ 1.2       ,  1.27041742,  0.92658316])  # may vary</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">    &gt;&gt;&gt; permscale  # only powers of 2 (0.5 == 2^(-1))</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    array([[  0.5,   0. ,  0. ],  # may vary</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">           [  0. ,   1. ,  0. ],</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">           [  0. ,   0. ,  1. ]])</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">    .. [1] : B.N. Parlett and C. Reinsch, &quot;Balancing a Matrix for</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">       Calculation of Eigenvalues and Eigenvectors&quot;, Numerische Mathematik,</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">       Vol.13(4), 1969, :doi:`10.1007/BF02165404`</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    .. [2] : R. James, J. Langou, B.R. Lowery, &quot;On matrix balancing and</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">       eigenvector computation&quot;, 2014, :arxiv:`1401.5766`</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    .. [3] :  D.S. Watkins. A case where balancing is harmful.</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">       Electron. Trans. Numer. Anal, Vol.23, 2006.</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1545</span> </div>
<div class="line"><span class="lineno"> 1546</span>    A = np.atleast_2d(_asarray_validated(A, check_finite=<span class="keyword">True</span>))</div>
<div class="line"><span class="lineno"> 1547</span> </div>
<div class="line"><span class="lineno"> 1548</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.equal(*A.shape):</div>
<div class="line"><span class="lineno"> 1549</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The data matrix for balancing should be square.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1550</span> </div>
<div class="line"><span class="lineno"> 1551</span>    gebal = get_lapack_funcs((<span class="stringliteral">&#39;gebal&#39;</span>), (A,))</div>
<div class="line"><span class="lineno"> 1552</span>    B, lo, hi, ps, info = gebal(A, scale=scale, permute=permute,</div>
<div class="line"><span class="lineno"> 1553</span>                                overwrite_a=overwrite_a)</div>
<div class="line"><span class="lineno"> 1554</span> </div>
<div class="line"><span class="lineno"> 1555</span>    <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno"> 1556</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;xGEBAL exited with the internal error &#39;</span></div>
<div class="line"><span class="lineno"> 1557</span>                         <span class="stringliteral">&#39;&quot;illegal value in argument number {}.&quot;. See &#39;</span></div>
<div class="line"><span class="lineno"> 1558</span>                         <span class="stringliteral">&#39;LAPACK documentation for the xGEBAL error codes.&#39;</span></div>
<div class="line"><span class="lineno"> 1559</span>                         <span class="stringliteral">&#39;&#39;</span>.format(-info))</div>
<div class="line"><span class="lineno"> 1560</span> </div>
<div class="line"><span class="lineno"> 1561</span>    <span class="comment"># Separate the permutations from the scalings and then convert to int</span></div>
<div class="line"><span class="lineno"> 1562</span>    scaling = np.ones_like(ps, dtype=float)</div>
<div class="line"><span class="lineno"> 1563</span>    scaling[lo:hi+1] = ps[lo:hi+1]</div>
<div class="line"><span class="lineno"> 1564</span> </div>
<div class="line"><span class="lineno"> 1565</span>    <span class="comment"># gebal uses 1-indexing</span></div>
<div class="line"><span class="lineno"> 1566</span>    ps = ps.astype(int, copy=<span class="keyword">False</span>) - 1</div>
<div class="line"><span class="lineno"> 1567</span>    n = A.shape[0]</div>
<div class="line"><span class="lineno"> 1568</span>    perm = np.arange(n)</div>
<div class="line"><span class="lineno"> 1569</span> </div>
<div class="line"><span class="lineno"> 1570</span>    <span class="comment"># LAPACK permutes with the ordering n --&gt; hi, then 0--&gt; lo</span></div>
<div class="line"><span class="lineno"> 1571</span>    <span class="keywordflow">if</span> hi &lt; n:</div>
<div class="line"><span class="lineno"> 1572</span>        <span class="keywordflow">for</span> ind, x <span class="keywordflow">in</span> enumerate(ps[hi+1:][::-1], 1):</div>
<div class="line"><span class="lineno"> 1573</span>            <span class="keywordflow">if</span> n-ind == x:</div>
<div class="line"><span class="lineno"> 1574</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1575</span>            perm[[x, n-ind]] = perm[[n-ind, x]]</div>
<div class="line"><span class="lineno"> 1576</span> </div>
<div class="line"><span class="lineno"> 1577</span>    <span class="keywordflow">if</span> lo &gt; 0:</div>
<div class="line"><span class="lineno"> 1578</span>        <span class="keywordflow">for</span> ind, x <span class="keywordflow">in</span> enumerate(ps[:lo]):</div>
<div class="line"><span class="lineno"> 1579</span>            <span class="keywordflow">if</span> ind == x:</div>
<div class="line"><span class="lineno"> 1580</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1581</span>            perm[[x, ind]] = perm[[ind, x]]</div>
<div class="line"><span class="lineno"> 1582</span> </div>
<div class="line"><span class="lineno"> 1583</span>    <span class="keywordflow">if</span> separate:</div>
<div class="line"><span class="lineno"> 1584</span>        <span class="keywordflow">return</span> B, (scaling, perm)</div>
<div class="line"><span class="lineno"> 1585</span> </div>
<div class="line"><span class="lineno"> 1586</span>    <span class="comment"># get the inverse permutation</span></div>
<div class="line"><span class="lineno"> 1587</span>    iperm = np.empty_like(perm)</div>
<div class="line"><span class="lineno"> 1588</span>    iperm[perm] = np.arange(n)</div>
<div class="line"><span class="lineno"> 1589</span> </div>
<div class="line"><span class="lineno"> 1590</span>    <span class="keywordflow">return</span> B, np.diag(scaling)[iperm, :]</div>
<div class="line"><span class="lineno"> 1591</span> </div>
<div class="line"><span class="lineno"> 1592</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a97ec828515cdb5d103a6a188a5f20736" name="a97ec828515cdb5d103a6a188a5f20736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ec828515cdb5d103a6a188a5f20736">&#9670;&#160;</a></span>pinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.pinv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_rank</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cond</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate a generalized inverse of a matrix using its
singular-value decomposition ``U @ S @ V`` in the economy mode and picking
up only the columns/rows that are associated with significant singular
values.

If ``s`` is the maximum singular value of ``a``, then the
significance cut-off value is determined by ``atol + rtol * s``. Any
singular value below this value is assumed insignificant.

Parameters
----------
a : (M, N) array_like
    Matrix to be pseudo-inverted.
atol : float, optional
    Absolute threshold term, default value is 0.

    .. versionadded:: 1.7.0

rtol : float, optional
    Relative threshold term, default value is ``max(M, N) * eps`` where
    ``eps`` is the machine precision value of the datatype of ``a``.

    .. versionadded:: 1.7.0

return_rank : bool, optional
    If True, return the effective rank of the matrix.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
cond, rcond : float, optional
    In older versions, these values were meant to be used as ``atol`` with
    ``rtol=0``. If both were given ``rcond`` overwrote ``cond`` and hence
    the code was not correct. Thus using these are strongly discouraged and
    the tolerances above are recommended instead. In fact, if provided,
    atol, rtol takes precedence over these keywords.

    .. versionchanged:: 1.7.0
        Deprecated in favor of ``rtol`` and ``atol`` parameters above and
        will be removed in future versions of SciPy.

    .. versionchanged:: 1.3.0
        Previously the default cutoff value was just ``eps*f`` where ``f``
        was ``1e3`` for single precision and ``1e6`` for double precision.

Returns
-------
B : (N, M) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix. Returned if `return_rank` is True.

Raises
------
LinAlgError
    If SVD computation does not converge.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; a = rng.standard_normal((9, 6))
&gt;&gt;&gt; B = linalg.pinv(a)
&gt;&gt;&gt; np.allclose(a, a @ B @ a)
True
&gt;&gt;&gt; np.allclose(B, B @ a @ B)
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1230</span>         cond=<span class="keywordtype">None</span>, rcond=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1231</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    Compute the (Moore-Penrose) pseudo-inverse of a matrix.</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">    Calculate a generalized inverse of a matrix using its</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    singular-value decomposition ``U @ S @ V`` in the economy mode and picking</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    up only the columns/rows that are associated with significant singular</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">    values.</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">    If ``s`` is the maximum singular value of ``a``, then the</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    significance cut-off value is determined by ``atol + rtol * s``. Any</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    singular value below this value is assumed insignificant.</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    a : (M, N) array_like</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">        Matrix to be pseudo-inverted.</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    atol : float, optional</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">        Absolute threshold term, default value is 0.</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    rtol : float, optional</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">        Relative threshold term, default value is ``max(M, N) * eps`` where</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">        ``eps`` is the machine precision value of the datatype of ``a``.</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    return_rank : bool, optional</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">        If True, return the effective rank of the matrix.</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">        Whether to check that the input matrix contains only finite numbers.</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    cond, rcond : float, optional</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">        In older versions, these values were meant to be used as ``atol`` with</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        ``rtol=0``. If both were given ``rcond`` overwrote ``cond`` and hence</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        the code was not correct. Thus using these are strongly discouraged and</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        the tolerances above are recommended instead. In fact, if provided,</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">        atol, rtol takes precedence over these keywords.</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">        .. versionchanged:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">            Deprecated in favor of ``rtol`` and ``atol`` parameters above and</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">            will be removed in future versions of SciPy.</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">        .. versionchanged:: 1.3.0</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">            Previously the default cutoff value was just ``eps*f`` where ``f``</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">            was ``1e3`` for single precision and ``1e6`` for double precision.</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    B : (N, M) ndarray</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">        The pseudo-inverse of matrix `a`.</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">    rank : int</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">        The effective rank of the matrix. Returned if `return_rank` is True.</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">        If SVD computation does not converge.</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import linalg</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    &gt;&gt;&gt; a = rng.standard_normal((9, 6))</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    &gt;&gt;&gt; B = linalg.pinv(a)</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, a @ B @ a)</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(B, B @ a @ B)</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1303</span>    a = _asarray_validated(a, check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1304</span>    u, s, vh = _decomp_svd.svd(a, full_matrices=<span class="keyword">False</span>, check_finite=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1305</span>    t = u.dtype.char.lower()</div>
<div class="line"><span class="lineno"> 1306</span>    maxS = np.max(s)</div>
<div class="line"><span class="lineno"> 1307</span> </div>
<div class="line"><span class="lineno"> 1308</span>    <span class="keywordflow">if</span> rcond <span class="keywordflow">or</span> cond:</div>
<div class="line"><span class="lineno"> 1309</span>        warn(<span class="stringliteral">&#39;Use of the &quot;cond&quot; and &quot;rcond&quot; keywords are deprecated and &#39;</span></div>
<div class="line"><span class="lineno"> 1310</span>             <span class="stringliteral">&#39;will be removed in future versions of SciPy. Use &quot;atol&quot; and &#39;</span></div>
<div class="line"><span class="lineno"> 1311</span>             <span class="stringliteral">&#39;&quot;rtol&quot; keywords instead&#39;</span>, DeprecationWarning, stacklevel=2)</div>
<div class="line"><span class="lineno"> 1312</span> </div>
<div class="line"><span class="lineno"> 1313</span>    <span class="comment"># backwards compatible only atol and rtol are both missing</span></div>
<div class="line"><span class="lineno"> 1314</span>    <span class="keywordflow">if</span> (rcond <span class="keywordflow">or</span> cond) <span class="keywordflow">and</span> (atol <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (rtol <span class="keywordflow">is</span> <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1315</span>        atol = rcond <span class="keywordflow">or</span> cond</div>
<div class="line"><span class="lineno"> 1316</span>        rtol = 0.</div>
<div class="line"><span class="lineno"> 1317</span> </div>
<div class="line"><span class="lineno"> 1318</span>    atol = 0. <span class="keywordflow">if</span> atol <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> atol</div>
<div class="line"><span class="lineno"> 1319</span>    rtol = max(a.shape) * np.finfo(t).eps <span class="keywordflow">if</span> (rtol <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> rtol</div>
<div class="line"><span class="lineno"> 1320</span> </div>
<div class="line"><span class="lineno"> 1321</span>    <span class="keywordflow">if</span> (atol &lt; 0.) <span class="keywordflow">or</span> (rtol &lt; 0.):</div>
<div class="line"><span class="lineno"> 1322</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;atol and rtol values must be positive.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1323</span> </div>
<div class="line"><span class="lineno"> 1324</span>    val = atol + maxS * rtol</div>
<div class="line"><span class="lineno"> 1325</span>    rank = np.sum(s &gt; val)</div>
<div class="line"><span class="lineno"> 1326</span> </div>
<div class="line"><span class="lineno"> 1327</span>    u = u[:, :rank]</div>
<div class="line"><span class="lineno"> 1328</span>    u /= s[:rank]</div>
<div class="line"><span class="lineno"> 1329</span>    B = (u @ vh[:rank]).conj().T</div>
<div class="line"><span class="lineno"> 1330</span> </div>
<div class="line"><span class="lineno"> 1331</span>    <span class="keywordflow">if</span> return_rank:</div>
<div class="line"><span class="lineno"> 1332</span>        <span class="keywordflow">return</span> B, rank</div>
<div class="line"><span class="lineno"> 1333</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1334</span>        <span class="keywordflow">return</span> B</div>
<div class="line"><span class="lineno"> 1335</span> </div>
<div class="line"><span class="lineno"> 1336</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a835075f4103e045f22553954b9d60ea1" name="a835075f4103e045f22553954b9d60ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835075f4103e045f22553954b9d60ea1">&#9670;&#160;</a></span>pinvh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.pinvh </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lower</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_rank</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cond</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.

Calculate a generalized inverse of a complex Hermitian/real symmetric
matrix using its eigenvalue decomposition and including all eigenvalues
with 'large' absolute value.

Parameters
----------
a : (N, N) array_like
    Real symmetric or complex hermetian matrix to be pseudo-inverted

atol : float, optional
    Absolute threshold term, default value is 0.

    .. versionadded:: 1.7.0

rtol : float, optional
    Relative threshold term, default value is ``N * eps`` where
    ``eps`` is the machine precision value of the datatype of ``a``.

    .. versionadded:: 1.7.0

lower : bool, optional
    Whether the pertinent array data is taken from the lower or upper
    triangle of `a`. (Default: lower)
return_rank : bool, optional
    If True, return the effective rank of the matrix.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
cond, rcond : float, optional
    In older versions, these values were meant to be used as ``atol`` with
    ``rtol=0``. If both were given ``rcond`` overwrote ``cond`` and hence
    the code was not correct. Thus using these are strongly discouraged and
    the tolerances above are recommended instead.  In fact, if provided,
    atol, rtol takes precedence over these keywords.

    .. versionchanged:: 1.7.0
        Deprecated in favor of ``rtol`` and ``atol`` parameters above and
        will be removed in future versions of SciPy.

    .. versionchanged:: 1.3.0
        Previously the default cutoff value was just ``eps*f`` where ``f``
        was ``1e3`` for single precision and ``1e6`` for double precision.

Returns
-------
B : (N, N) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if `return_rank` is True.

Raises
------
LinAlgError
    If eigenvalue algorithm does not converge.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import pinvh
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; a = rng.standard_normal((9, 6))
&gt;&gt;&gt; a = np.dot(a, a.T)
&gt;&gt;&gt; B = pinvh(a)
&gt;&gt;&gt; np.allclose(a, a @ B @ a)
True
&gt;&gt;&gt; np.allclose(B, B @ a @ B)
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1338</span>          check_finite=<span class="keyword">True</span>, cond=<span class="keywordtype">None</span>, rcond=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1339</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    Calculate a generalized inverse of a complex Hermitian/real symmetric</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    matrix using its eigenvalue decomposition and including all eigenvalues</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    with &#39;large&#39; absolute value.</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    a : (N, N) array_like</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">        Real symmetric or complex hermetian matrix to be pseudo-inverted</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    atol : float, optional</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">        Absolute threshold term, default value is 0.</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    rtol : float, optional</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">        Relative threshold term, default value is ``N * eps`` where</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">        ``eps`` is the machine precision value of the datatype of ``a``.</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    lower : bool, optional</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">        Whether the pertinent array data is taken from the lower or upper</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">        triangle of `a`. (Default: lower)</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    return_rank : bool, optional</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">        If True, return the effective rank of the matrix.</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">        Whether to check that the input matrix contains only finite numbers.</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    cond, rcond : float, optional</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">        In older versions, these values were meant to be used as ``atol`` with</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">        ``rtol=0``. If both were given ``rcond`` overwrote ``cond`` and hence</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">        the code was not correct. Thus using these are strongly discouraged and</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">        the tolerances above are recommended instead.  In fact, if provided,</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">        atol, rtol takes precedence over these keywords.</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">        .. versionchanged:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">            Deprecated in favor of ``rtol`` and ``atol`` parameters above and</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">            will be removed in future versions of SciPy.</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">        .. versionchanged:: 1.3.0</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">            Previously the default cutoff value was just ``eps*f`` where ``f``</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">            was ``1e3`` for single precision and ``1e6`` for double precision.</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    B : (N, N) ndarray</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">        The pseudo-inverse of matrix `a`.</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    rank : int</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">        The effective rank of the matrix.  Returned if `return_rank` is True.</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">        If eigenvalue algorithm does not converge.</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import pinvh</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    &gt;&gt;&gt; a = rng.standard_normal((9, 6))</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    &gt;&gt;&gt; a = np.dot(a, a.T)</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    &gt;&gt;&gt; B = pinvh(a)</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, a @ B @ a)</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(B, B @ a @ B)</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1411</span>    a = _asarray_validated(a, check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1412</span>    s, u = _decomp.eigh(a, lower=lower, check_finite=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1413</span>    t = u.dtype.char.lower()</div>
<div class="line"><span class="lineno"> 1414</span>    maxS = np.max(np.abs(s))</div>
<div class="line"><span class="lineno"> 1415</span> </div>
<div class="line"><span class="lineno"> 1416</span>    <span class="keywordflow">if</span> rcond <span class="keywordflow">or</span> cond:</div>
<div class="line"><span class="lineno"> 1417</span>        warn(<span class="stringliteral">&#39;Use of the &quot;cond&quot; and &quot;rcond&quot; keywords are deprecated and &#39;</span></div>
<div class="line"><span class="lineno"> 1418</span>             <span class="stringliteral">&#39;will be removed in future versions of SciPy. Use &quot;atol&quot; and &#39;</span></div>
<div class="line"><span class="lineno"> 1419</span>             <span class="stringliteral">&#39;&quot;rtol&quot; keywords instead&#39;</span>, DeprecationWarning, stacklevel=2)</div>
<div class="line"><span class="lineno"> 1420</span> </div>
<div class="line"><span class="lineno"> 1421</span>    <span class="comment"># backwards compatible only atol and rtol are both missing</span></div>
<div class="line"><span class="lineno"> 1422</span>    <span class="keywordflow">if</span> (rcond <span class="keywordflow">or</span> cond) <span class="keywordflow">and</span> (atol <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (rtol <span class="keywordflow">is</span> <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1423</span>        atol = rcond <span class="keywordflow">or</span> cond</div>
<div class="line"><span class="lineno"> 1424</span>        rtol = 0.</div>
<div class="line"><span class="lineno"> 1425</span> </div>
<div class="line"><span class="lineno"> 1426</span>    atol = 0. <span class="keywordflow">if</span> atol <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> atol</div>
<div class="line"><span class="lineno"> 1427</span>    rtol = max(a.shape) * np.finfo(t).eps <span class="keywordflow">if</span> (rtol <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> rtol</div>
<div class="line"><span class="lineno"> 1428</span> </div>
<div class="line"><span class="lineno"> 1429</span>    <span class="keywordflow">if</span> (atol &lt; 0.) <span class="keywordflow">or</span> (rtol &lt; 0.):</div>
<div class="line"><span class="lineno"> 1430</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;atol and rtol values must be positive.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1431</span> </div>
<div class="line"><span class="lineno"> 1432</span>    val = atol + maxS * rtol</div>
<div class="line"><span class="lineno"> 1433</span>    above_cutoff = (abs(s) &gt; val)</div>
<div class="line"><span class="lineno"> 1434</span> </div>
<div class="line"><span class="lineno"> 1435</span>    psigma_diag = 1.0 / s[above_cutoff]</div>
<div class="line"><span class="lineno"> 1436</span>    u = u[:, above_cutoff]</div>
<div class="line"><span class="lineno"> 1437</span> </div>
<div class="line"><span class="lineno"> 1438</span>    B = (u * psigma_diag) @ u.conj().T</div>
<div class="line"><span class="lineno"> 1439</span> </div>
<div class="line"><span class="lineno"> 1440</span>    <span class="keywordflow">if</span> return_rank:</div>
<div class="line"><span class="lineno"> 1441</span>        <span class="keywordflow">return</span> B, len(psigma_diag)</div>
<div class="line"><span class="lineno"> 1442</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1443</span>        <span class="keywordflow">return</span> B</div>
<div class="line"><span class="lineno"> 1444</span> </div>
<div class="line"><span class="lineno"> 1445</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adf8df315d0101b470abb0ec264115a02" name="adf8df315d0101b470abb0ec264115a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8df315d0101b470abb0ec264115a02">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sym_pos</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lower</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assume_a</em> = <code>'gen'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transposed</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the linear equation set ``a * x = b`` for the unknown ``x``
for square ``a`` matrix.

If the data matrix is known to be a particular type then supplying the
corresponding string to ``assume_a`` key chooses the dedicated solver.
The available options are

===================  ========
 generic matrix       'gen'
 symmetric            'sym'
 hermitian            'her'
 positive definite    'pos'
===================  ========

If omitted, ``'gen'`` is the default structure.

The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.

Parameters
----------
a : (N, N) array_like
    Square input data
b : (N, NRHS) array_like
    Input data for the right hand side.
sym_pos : bool, optional, deprecated
    Assume `a` is symmetric and positive definite.

    .. deprecated:: 0.19.0
        This keyword is deprecated and should be replaced by using
       ``assume_a = 'pos'``. `sym_pos` will be removed in SciPy 1.11.0.

lower : bool, optional
    If True, only the data contained in the lower triangle of `a`. Default
    is to use upper triangle. (ignored for ``'gen'``)
overwrite_a : bool, optional
    Allow overwriting data in `a` (may enhance performance).
    Default is False.
overwrite_b : bool, optional
    Allow overwriting data in `b` (may enhance performance).
    Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
    Valid entries are explained above.
transposed : bool, optional
    If True, ``a^T x = b`` for real matrices, raises `NotImplementedError`
    for complex matrices (only for True).

Returns
-------
x : (N, NRHS) ndarray
    The solution array.

Raises
------
ValueError
    If size mismatches detected or input a is not square.
LinAlgError
    If the matrix is singular.
LinAlgWarning
    If an ill-conditioned input a is detected.
NotImplementedError
    If transposed is True and input a is a complex matrix.

Examples
--------
Given `a` and `b`, solve for `x`:

&gt;&gt;&gt; a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
&gt;&gt;&gt; b = np.array([2, 4, -1])
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; x = linalg.solve(a, b)
&gt;&gt;&gt; x
array([ 2., -2.,  9.])
&gt;&gt;&gt; np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)

Notes
-----
If the input b matrix is a 1-D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1-D array.

The generic, symmetric, Hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.
</pre> <div class="fragment"><div class="line"><span class="lineno">   42</span>          transposed=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">   43</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    Solves the linear equation set ``a * x = b`` for the unknown ``x``</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    for square ``a`` matrix.</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    If the data matrix is known to be a particular type then supplying the</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    corresponding string to ``assume_a`` key chooses the dedicated solver.</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    The available options are</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    ===================  ========</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">     generic matrix       &#39;gen&#39;</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">     symmetric            &#39;sym&#39;</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">     hermitian            &#39;her&#39;</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">     positive definite    &#39;pos&#39;</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    ===================  ========</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    If omitted, ``&#39;gen&#39;`` is the default structure.</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    The datatype of the arrays define which solver is called regardless</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    of the values. In other words, even when the complex array entries have</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    precisely zero imaginary parts, the complex solver will be called based</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    on the data type of the array.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    a : (N, N) array_like</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">        Square input data</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    b : (N, NRHS) array_like</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">        Input data for the right hand side.</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    sym_pos : bool, optional, deprecated</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">        Assume `a` is symmetric and positive definite.</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">        .. deprecated:: 0.19.0</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">            This keyword is deprecated and should be replaced by using</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">           ``assume_a = &#39;pos&#39;``. `sym_pos` will be removed in SciPy 1.11.0.</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    lower : bool, optional</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        If True, only the data contained in the lower triangle of `a`. Default</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">        is to use upper triangle. (ignored for ``&#39;gen&#39;``)</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    overwrite_a : bool, optional</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        Allow overwriting data in `a` (may enhance performance).</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">        Default is False.</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    overwrite_b : bool, optional</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        Allow overwriting data in `b` (may enhance performance).</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        Default is False.</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    assume_a : str, optional</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        Valid entries are explained above.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    transposed : bool, optional</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        If True, ``a^T x = b`` for real matrices, raises `NotImplementedError`</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        for complex matrices (only for True).</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    x : (N, NRHS) ndarray</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        The solution array.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        If size mismatches detected or input a is not square.</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        If the matrix is singular.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    LinAlgWarning</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        If an ill-conditioned input a is detected.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    NotImplementedError</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        If transposed is True and input a is a complex matrix.</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    Given `a` and `b`, solve for `x`:</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([2, 4, -1])</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import linalg</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; x = linalg.solve(a, b)</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    array([ 2., -2.,  9.])</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(a, x) == b</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    array([ True,  True,  True], dtype=bool)</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    If the input b matrix is a 1-D array with N elements, when supplied</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    together with an NxN input a, it is assumed as a valid column vector</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    despite the apparent size mismatch. This is compatible with the</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    numpy.dot() behavior and the returned result is still 1-D array.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    The generic, symmetric, Hermitian and positive definite solutions are</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    LAPACK respectively.</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  137</span>    <span class="comment"># Flags for 1-D or N-D right-hand side</span></div>
<div class="line"><span class="lineno">  138</span>    b_is_1D = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>    a1 = atleast_2d(_asarray_validated(a, check_finite=check_finite))</div>
<div class="line"><span class="lineno">  141</span>    b1 = atleast_1d(_asarray_validated(b, check_finite=check_finite))</div>
<div class="line"><span class="lineno">  142</span>    n = a1.shape[0]</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>    overwrite_a = overwrite_a <span class="keywordflow">or</span> _datacopied(a1, a)</div>
<div class="line"><span class="lineno">  145</span>    overwrite_b = overwrite_b <span class="keywordflow">or</span> _datacopied(b1, b)</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">if</span> a1.shape[0] != a1.shape[1]:</div>
<div class="line"><span class="lineno">  148</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Input a needs to be a square matrix.&#39;</span>)</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span>    <span class="keywordflow">if</span> n != b1.shape[0]:</div>
<div class="line"><span class="lineno">  151</span>        <span class="comment"># Last chance to catch 1x1 scalar a and 1-D b arrays</span></div>
<div class="line"><span class="lineno">  152</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (n == 1 <span class="keywordflow">and</span> b1.size != 0):</div>
<div class="line"><span class="lineno">  153</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Input b has to have same number of rows as &#39;</span></div>
<div class="line"><span class="lineno">  154</span>                             <span class="stringliteral">&#39;input a&#39;</span>)</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>    <span class="comment"># accommodate empty arrays</span></div>
<div class="line"><span class="lineno">  157</span>    <span class="keywordflow">if</span> b1.size == 0:</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">return</span> np.asfortranarray(b1.copy())</div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>    <span class="comment"># regularize 1-D b arrays to 2D</span></div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">if</span> b1.ndim == 1:</div>
<div class="line"><span class="lineno">  162</span>        <span class="keywordflow">if</span> n == 1:</div>
<div class="line"><span class="lineno">  163</span>            b1 = b1[<span class="keywordtype">None</span>, :]</div>
<div class="line"><span class="lineno">  164</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  165</span>            b1 = b1[:, <span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno">  166</span>        b_is_1D = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span>    <span class="comment"># Backwards compatibility - old keyword.</span></div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">if</span> sym_pos:</div>
<div class="line"><span class="lineno">  170</span>        message = (<span class="stringliteral">&quot;The &#39;sym_pos&#39; keyword is deprecated and should be &quot;</span></div>
<div class="line"><span class="lineno">  171</span>                   <span class="stringliteral">&quot;replaced by using &#39;assume_a = \&quot;pos\&quot;&#39;. &#39;sym_pos&#39; will be&quot;</span></div>
<div class="line"><span class="lineno">  172</span>                   <span class="stringliteral">&quot; removed in SciPy 1.11.0.&quot;</span>)</div>
<div class="line"><span class="lineno">  173</span>        warn(message, DeprecationWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  174</span>        assume_a = <span class="stringliteral">&#39;pos&#39;</span></div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordflow">if</span> assume_a <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;gen&#39;</span>, <span class="stringliteral">&#39;sym&#39;</span>, <span class="stringliteral">&#39;her&#39;</span>, <span class="stringliteral">&#39;pos&#39;</span>):</div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;{} is not a recognized matrix structure&#39;</span></div>
<div class="line"><span class="lineno">  178</span>                         <span class="stringliteral">&#39;&#39;</span>.format(assume_a))</div>
<div class="line"><span class="lineno">  179</span> </div>
<div class="line"><span class="lineno">  180</span>    <span class="comment"># for a real matrix, describe it as &quot;symmetric&quot;, not &quot;hermitian&quot;</span></div>
<div class="line"><span class="lineno">  181</span>    <span class="comment"># (lapack doesn&#39;t know what to do with real hermitian matrices)</span></div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordflow">if</span> assume_a == <span class="stringliteral">&#39;her&#39;</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.iscomplexobj(a1):</div>
<div class="line"><span class="lineno">  183</span>        assume_a = <span class="stringliteral">&#39;sym&#39;</span></div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span>    <span class="comment"># Get the correct lamch function.</span></div>
<div class="line"><span class="lineno">  186</span>    <span class="comment"># The LAMCH functions only exists for S and D</span></div>
<div class="line"><span class="lineno">  187</span>    <span class="comment"># So for complex values we have to convert to real/double.</span></div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">if</span> a1.dtype.char <span class="keywordflow">in</span> <span class="stringliteral">&#39;fF&#39;</span>:  <span class="comment"># single precision</span></div>
<div class="line"><span class="lineno">  189</span>        lamch = get_lapack_funcs(<span class="stringliteral">&#39;lamch&#39;</span>, dtype=<span class="stringliteral">&#39;f&#39;</span>)</div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  191</span>        lamch = get_lapack_funcs(<span class="stringliteral">&#39;lamch&#39;</span>, dtype=<span class="stringliteral">&#39;d&#39;</span>)</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span>    <span class="comment"># Currently we do not have the other forms of the norm calculators</span></div>
<div class="line"><span class="lineno">  194</span>    <span class="comment">#   lansy, lanpo, lanhe.</span></div>
<div class="line"><span class="lineno">  195</span>    <span class="comment"># However, in any case they only reduce computations slightly...</span></div>
<div class="line"><span class="lineno">  196</span>    lange = get_lapack_funcs(<span class="stringliteral">&#39;lange&#39;</span>, (a1,))</div>
<div class="line"><span class="lineno">  197</span> </div>
<div class="line"><span class="lineno">  198</span>    <span class="comment"># Since the I-norm and 1-norm are the same for symmetric matrices</span></div>
<div class="line"><span class="lineno">  199</span>    <span class="comment"># we can collect them all in this one call</span></div>
<div class="line"><span class="lineno">  200</span>    <span class="comment"># Note however, that when issuing &#39;gen&#39; and form!=&#39;none&#39;, then</span></div>
<div class="line"><span class="lineno">  201</span>    <span class="comment"># the I-norm should be used</span></div>
<div class="line"><span class="lineno">  202</span>    <span class="keywordflow">if</span> transposed:</div>
<div class="line"><span class="lineno">  203</span>        trans = 1</div>
<div class="line"><span class="lineno">  204</span>        norm = <span class="stringliteral">&#39;I&#39;</span></div>
<div class="line"><span class="lineno">  205</span>        <span class="keywordflow">if</span> np.iscomplexobj(a1):</div>
<div class="line"><span class="lineno">  206</span>            <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&#39;scipy.linalg.solve can currently &#39;</span></div>
<div class="line"><span class="lineno">  207</span>                                      <span class="stringliteral">&#39;not solve a^T x = b or a^H x = b &#39;</span></div>
<div class="line"><span class="lineno">  208</span>                                      <span class="stringliteral">&#39;for complex matrices.&#39;</span>)</div>
<div class="line"><span class="lineno">  209</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  210</span>        trans = 0</div>
<div class="line"><span class="lineno">  211</span>        norm = <span class="stringliteral">&#39;1&#39;</span></div>
<div class="line"><span class="lineno">  212</span> </div>
<div class="line"><span class="lineno">  213</span>    anorm = lange(norm, a1)</div>
<div class="line"><span class="lineno">  214</span> </div>
<div class="line"><span class="lineno">  215</span>    <span class="comment"># Generalized case &#39;gesv&#39;</span></div>
<div class="line"><span class="lineno">  216</span>    <span class="keywordflow">if</span> assume_a == <span class="stringliteral">&#39;gen&#39;</span>:</div>
<div class="line"><span class="lineno">  217</span>        gecon, getrf, getrs = get_lapack_funcs((<span class="stringliteral">&#39;gecon&#39;</span>, <span class="stringliteral">&#39;getrf&#39;</span>, <span class="stringliteral">&#39;getrs&#39;</span>),</div>
<div class="line"><span class="lineno">  218</span>                                               (a1, b1))</div>
<div class="line"><span class="lineno">  219</span>        lu, ipvt, info = getrf(a1, overwrite_a=overwrite_a)</div>
<div class="line"><span class="lineno">  220</span>        _solve_check(n, info)</div>
<div class="line"><span class="lineno">  221</span>        x, info = getrs(lu, ipvt, b1,</div>
<div class="line"><span class="lineno">  222</span>                        trans=trans, overwrite_b=overwrite_b)</div>
<div class="line"><span class="lineno">  223</span>        _solve_check(n, info)</div>
<div class="line"><span class="lineno">  224</span>        rcond, info = gecon(lu, anorm, norm=norm)</div>
<div class="line"><span class="lineno">  225</span>    <span class="comment"># Hermitian case &#39;hesv&#39;</span></div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">elif</span> assume_a == <span class="stringliteral">&#39;her&#39;</span>:</div>
<div class="line"><span class="lineno">  227</span>        hecon, hesv, hesv_lw = get_lapack_funcs((<span class="stringliteral">&#39;hecon&#39;</span>, <span class="stringliteral">&#39;hesv&#39;</span>,</div>
<div class="line"><span class="lineno">  228</span>                                                 <span class="stringliteral">&#39;hesv_lwork&#39;</span>), (a1, b1))</div>
<div class="line"><span class="lineno">  229</span>        lwork = _compute_lwork(hesv_lw, n, lower)</div>
<div class="line"><span class="lineno">  230</span>        lu, ipvt, x, info = hesv(a1, b1, lwork=lwork,</div>
<div class="line"><span class="lineno">  231</span>                                 lower=lower,</div>
<div class="line"><span class="lineno">  232</span>                                 overwrite_a=overwrite_a,</div>
<div class="line"><span class="lineno">  233</span>                                 overwrite_b=overwrite_b)</div>
<div class="line"><span class="lineno">  234</span>        _solve_check(n, info)</div>
<div class="line"><span class="lineno">  235</span>        rcond, info = hecon(lu, ipvt, anorm)</div>
<div class="line"><span class="lineno">  236</span>    <span class="comment"># Symmetric case &#39;sysv&#39;</span></div>
<div class="line"><span class="lineno">  237</span>    <span class="keywordflow">elif</span> assume_a == <span class="stringliteral">&#39;sym&#39;</span>:</div>
<div class="line"><span class="lineno">  238</span>        sycon, sysv, sysv_lw = get_lapack_funcs((<span class="stringliteral">&#39;sycon&#39;</span>, <span class="stringliteral">&#39;sysv&#39;</span>,</div>
<div class="line"><span class="lineno">  239</span>                                                 <span class="stringliteral">&#39;sysv_lwork&#39;</span>), (a1, b1))</div>
<div class="line"><span class="lineno">  240</span>        lwork = _compute_lwork(sysv_lw, n, lower)</div>
<div class="line"><span class="lineno">  241</span>        lu, ipvt, x, info = sysv(a1, b1, lwork=lwork,</div>
<div class="line"><span class="lineno">  242</span>                                 lower=lower,</div>
<div class="line"><span class="lineno">  243</span>                                 overwrite_a=overwrite_a,</div>
<div class="line"><span class="lineno">  244</span>                                 overwrite_b=overwrite_b)</div>
<div class="line"><span class="lineno">  245</span>        _solve_check(n, info)</div>
<div class="line"><span class="lineno">  246</span>        rcond, info = sycon(lu, ipvt, anorm)</div>
<div class="line"><span class="lineno">  247</span>    <span class="comment"># Positive definite case &#39;posv&#39;</span></div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  249</span>        pocon, posv = get_lapack_funcs((<span class="stringliteral">&#39;pocon&#39;</span>, <span class="stringliteral">&#39;posv&#39;</span>),</div>
<div class="line"><span class="lineno">  250</span>                                       (a1, b1))</div>
<div class="line"><span class="lineno">  251</span>        lu, x, info = posv(a1, b1, lower=lower,</div>
<div class="line"><span class="lineno">  252</span>                           overwrite_a=overwrite_a,</div>
<div class="line"><span class="lineno">  253</span>                           overwrite_b=overwrite_b)</div>
<div class="line"><span class="lineno">  254</span>        _solve_check(n, info)</div>
<div class="line"><span class="lineno">  255</span>        rcond, info = pocon(lu, anorm)</div>
<div class="line"><span class="lineno">  256</span> </div>
<div class="line"><span class="lineno">  257</span>    _solve_check(n, info, lamch, rcond)</div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>    <span class="keywordflow">if</span> b_is_1D:</div>
<div class="line"><span class="lineno">  260</span>        x = x.ravel()</div>
<div class="line"><span class="lineno">  261</span> </div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac02f4acec8b4e87fc786930661a61e9c" name="ac02f4acec8b4e87fc786930661a61e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02f4acec8b4e87fc786930661a61e9c">&#9670;&#160;</a></span>solve_banded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_banded </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l_and_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_ab</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the equation a x = b for x, assuming a is banded matrix.

The matrix a is stored in `ab` using the matrix diagonal ordered form::

    ab[u + i - j, j] == a[i,j]

Example of `ab` (shape of a is (6,6), `u` =1, `l` =2)::

    *    a01  a12  a23  a34  a45
    a00  a11  a22  a33  a44  a55
    a10  a21  a32  a43  a54   *
    a20  a31  a42  a53   *    *

Parameters
----------
(l, u) : (integer, integer)
    Number of non-zero lower and upper diagonals
ab : (`l` + `u` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : bool, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system a x = b. Returned shape depends on the
    shape of `b`.

Examples
--------
Solve the banded system a x = b, where::

        [5  2 -1  0  0]       [0]
        [1  4  2 -1  0]       [1]
    a = [0  1  3  2 -1]   b = [2]
        [0  0  1  2  2]       [2]
        [0  0  0  1  1]       [3]

There is one nonzero diagonal below the main diagonal (l = 1), and
two above (u = 2). The diagonal banded form of the matrix is::

         [*  * -1 -1 -1]
    ab = [*  2  2  2  2]
         [5  4  3  2  1]
         [1  1  1  1  *]

&gt;&gt;&gt; from scipy.linalg import solve_banded
&gt;&gt;&gt; ab = np.array([[0,  0, -1, -1, -1],
...                [0,  2,  2,  2,  2],
...                [5,  4,  3,  2,  1],
...                [1,  1,  1,  1,  0]])
&gt;&gt;&gt; b = np.array([0, 1, 2, 2, 3])
&gt;&gt;&gt; x = solve_banded((1, 2), ab, b)
&gt;&gt;&gt; x
array([-2.37288136,  3.93220339, -4.        ,  4.3559322 , -1.3559322 ])</pre> <div class="fragment"><div class="line"><span class="lineno">  362</span>                 check_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  363</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    Solve the equation a x = b for x, assuming a is banded matrix.</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    The matrix a is stored in `ab` using the matrix diagonal ordered form::</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">        ab[u + i - j, j] == a[i,j]</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    Example of `ab` (shape of a is (6,6), `u` =1, `l` =2)::</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">        *    a01  a12  a23  a34  a45</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">        a00  a11  a22  a33  a44  a55</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        a10  a21  a32  a43  a54   *</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        a20  a31  a42  a53   *    *</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    (l, u) : (integer, integer)</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        Number of non-zero lower and upper diagonals</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    ab : (`l` + `u` + 1, M) array_like</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">        Banded matrix</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    b : (M,) or (M, K) array_like</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">        Right-hand side</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    overwrite_ab : bool, optional</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">        Discard data in `ab` (may enhance performance)</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    overwrite_b : bool, optional</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        Discard data in `b` (may enhance performance)</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    x : (M,) or (M, K) ndarray</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">        The solution to the system a x = b. Returned shape depends on the</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        shape of `b`.</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    Solve the banded system a x = b, where::</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">            [5  2 -1  0  0]       [0]</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">            [1  4  2 -1  0]       [1]</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">        a = [0  1  3  2 -1]   b = [2]</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">            [0  0  1  2  2]       [2]</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">            [0  0  0  1  1]       [3]</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    There is one nonzero diagonal below the main diagonal (l = 1), and</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    two above (u = 2). The diagonal banded form of the matrix is::</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">             [*  * -1 -1 -1]</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">        ab = [*  2  2  2  2]</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">             [5  4  3  2  1]</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">             [1  1  1  1  *]</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import solve_banded</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; ab = np.array([[0,  0, -1, -1, -1],</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    ...                [0,  2,  2,  2,  2],</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    ...                [5,  4,  3,  2,  1],</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    ...                [1,  1,  1,  1,  0]])</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([0, 1, 2, 2, 3])</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    &gt;&gt;&gt; x = solve_banded((1, 2), ab, b)</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    array([-2.37288136,  3.93220339, -4.        ,  4.3559322 , -1.3559322 ])</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  429</span> </div>
<div class="line"><span class="lineno">  430</span>    a1 = _asarray_validated(ab, check_finite=check_finite, as_inexact=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  431</span>    b1 = _asarray_validated(b, check_finite=check_finite, as_inexact=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  432</span>    <span class="comment"># Validate shapes.</span></div>
<div class="line"><span class="lineno">  433</span>    <span class="keywordflow">if</span> a1.shape[-1] != b1.shape[0]:</div>
<div class="line"><span class="lineno">  434</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;shapes of ab and b are not compatible.&quot;</span>)</div>
<div class="line"><span class="lineno">  435</span>    (nlower, nupper) = l_and_u</div>
<div class="line"><span class="lineno">  436</span>    <span class="keywordflow">if</span> nlower + nupper + 1 != a1.shape[0]:</div>
<div class="line"><span class="lineno">  437</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;invalid values for the number of lower and upper &quot;</span></div>
<div class="line"><span class="lineno">  438</span>                         <span class="stringliteral">&quot;diagonals: l+u+1 (%d) does not equal ab.shape[0] &quot;</span></div>
<div class="line"><span class="lineno">  439</span>                         <span class="stringliteral">&quot;(%d)&quot;</span> % (nlower + nupper + 1, ab.shape[0]))</div>
<div class="line"><span class="lineno">  440</span> </div>
<div class="line"><span class="lineno">  441</span>    overwrite_b = overwrite_b <span class="keywordflow">or</span> _datacopied(b1, b)</div>
<div class="line"><span class="lineno">  442</span>    <span class="keywordflow">if</span> a1.shape[-1] == 1:</div>
<div class="line"><span class="lineno">  443</span>        b2 = np.array(b1, copy=(<span class="keywordflow">not</span> overwrite_b))</div>
<div class="line"><span class="lineno">  444</span>        b2 /= a1[1, 0]</div>
<div class="line"><span class="lineno">  445</span>        <span class="keywordflow">return</span> b2</div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordflow">if</span> nlower == nupper == 1:</div>
<div class="line"><span class="lineno">  447</span>        overwrite_ab = overwrite_ab <span class="keywordflow">or</span> _datacopied(a1, ab)</div>
<div class="line"><span class="lineno">  448</span>        gtsv, = get_lapack_funcs((<span class="stringliteral">&#39;gtsv&#39;</span>,), (a1, b1))</div>
<div class="line"><span class="lineno">  449</span>        du = a1[0, 1:]</div>
<div class="line"><span class="lineno">  450</span>        d = a1[1, :]</div>
<div class="line"><span class="lineno">  451</span>        dl = a1[2, :-1]</div>
<div class="line"><span class="lineno">  452</span>        du2, d, du, x, info = gtsv(dl, d, du, b1, overwrite_ab, overwrite_ab,</div>
<div class="line"><span class="lineno">  453</span>                                   overwrite_ab, overwrite_b)</div>
<div class="line"><span class="lineno">  454</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  455</span>        gbsv, = get_lapack_funcs((<span class="stringliteral">&#39;gbsv&#39;</span>,), (a1, b1))</div>
<div class="line"><span class="lineno">  456</span>        a2 = np.zeros((2*nlower + nupper + 1, a1.shape[1]), dtype=gbsv.dtype)</div>
<div class="line"><span class="lineno">  457</span>        a2[nlower:, :] = a1</div>
<div class="line"><span class="lineno">  458</span>        lu, piv, x, info = gbsv(nlower, nupper, a2, b1, overwrite_ab=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  459</span>                                overwrite_b=overwrite_b)</div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">if</span> info == 0:</div>
<div class="line"><span class="lineno">  461</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  462</span>    <span class="keywordflow">if</span> info &gt; 0:</div>
<div class="line"><span class="lineno">  463</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;singular matrix&quot;</span>)</div>
<div class="line"><span class="lineno">  464</span>    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value in %d-th argument of internal &#39;</span></div>
<div class="line"><span class="lineno">  465</span>                     <span class="stringliteral">&#39;gbsv/gtsv&#39;</span> % -info)</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1dcc964a58db08fcf7179c91657abb1e" name="a1dcc964a58db08fcf7179c91657abb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcc964a58db08fcf7179c91657abb1e">&#9670;&#160;</a></span>solve_circulant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_circulant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>singular</em> = <code>'raise'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>caxis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>baxis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outaxis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve C x = b for x, where C is a circulant matrix.

`C` is the circulant matrix associated with the vector `c`.

The system is solved by doing division in Fourier space. The
calculation is::

    x = ifft(fft(b) / fft(c))

where `fft` and `ifft` are the fast Fourier transform and its inverse,
respectively. For a large vector `c`, this is *much* faster than
solving the system with the full circulant matrix.

Parameters
----------
c : array_like
    The coefficients of the circulant matrix.
b : array_like
    Right-hand side matrix in ``a x = b``.
singular : str, optional
    This argument controls how a near singular circulant matrix is
    handled.  If `singular` is "raise" and the circulant matrix is
    near singular, a `LinAlgError` is raised. If `singular` is
    "lstsq", the least squares solution is returned. Default is "raise".
tol : float, optional
    If any eigenvalue of the circulant matrix has an absolute value
    that is less than or equal to `tol`, the matrix is considered to be
    near singular. If not given, `tol` is set to::

        tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps

    where `abs_eigs` is the array of absolute values of the eigenvalues
    of the circulant matrix.
caxis : int
    When `c` has dimension greater than 1, it is viewed as a collection
    of circulant vectors. In this case, `caxis` is the axis of `c` that
    holds the vectors of circulant coefficients.
baxis : int
    When `b` has dimension greater than 1, it is viewed as a collection
    of vectors. In this case, `baxis` is the axis of `b` that holds the
    right-hand side vectors.
outaxis : int
    When `c` or `b` are multidimensional, the value returned by
    `solve_circulant` is multidimensional. In this case, `outaxis` is
    the axis of the result that holds the solution vectors.

Returns
-------
x : ndarray
    Solution to the system ``C x = b``.

Raises
------
LinAlgError
    If the circulant matrix associated with `c` is near singular.

See Also
--------
circulant : circulant matrix

Notes
-----
For a 1-D vector `c` with length `m`, and an array `b`
with shape ``(m, ...)``,

    solve_circulant(c, b)

returns the same result as

    solve(circulant(c), b)

where `solve` and `circulant` are from `scipy.linalg`.

.. versionadded:: 0.16.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import solve_circulant, solve, circulant, lstsq

&gt;&gt;&gt; c = np.array([2, 2, 4])
&gt;&gt;&gt; b = np.array([1, 2, 3])
&gt;&gt;&gt; solve_circulant(c, b)
array([ 0.75, -0.25,  0.25])

Compare that result to solving the system with `scipy.linalg.solve`:

&gt;&gt;&gt; solve(circulant(c), b)
array([ 0.75, -0.25,  0.25])

A singular example:

&gt;&gt;&gt; c = np.array([1, 1, 0, 0])
&gt;&gt;&gt; b = np.array([1, 2, 3, 4])

Calling ``solve_circulant(c, b)`` will raise a `LinAlgError`.  For the
least square solution, use the option ``singular='lstsq'``:

&gt;&gt;&gt; solve_circulant(c, b, singular='lstsq')
array([ 0.25,  1.25,  2.25,  1.25])

Compare to `scipy.linalg.lstsq`:

&gt;&gt;&gt; x, resid, rnk, s = lstsq(circulant(c), b)
&gt;&gt;&gt; x
array([ 0.25,  1.25,  2.25,  1.25])

A broadcasting example:

Suppose we have the vectors of two circulant matrices stored in an array
with shape (2, 5), and three `b` vectors stored in an array with shape
(3, 5).  For example,

&gt;&gt;&gt; c = np.array([[1.5, 2, 3, 0, 0], [1, 1, 4, 3, 2]])
&gt;&gt;&gt; b = np.arange(15).reshape(-1, 5)

We want to solve all combinations of circulant matrices and `b` vectors,
with the result stored in an array with shape (2, 3, 5). When we
disregard the axes of `c` and `b` that hold the vectors of coefficients,
the shapes of the collections are (2,) and (3,), respectively, which are
not compatible for broadcasting. To have a broadcast result with shape
(2, 3), we add a trivial dimension to `c`: ``c[:, np.newaxis, :]`` has
shape (2, 1, 5). The last dimension holds the coefficients of the
circulant matrices, so when we call `solve_circulant`, we can use the
default ``caxis=-1``. The coefficients of the `b` vectors are in the last
dimension of the array `b`, so we use ``baxis=-1``. If we use the
default `outaxis`, the result will have shape (5, 2, 3), so we'll use
``outaxis=-1`` to put the solution vectors in the last dimension.

&gt;&gt;&gt; x = solve_circulant(c[:, np.newaxis, :], b, baxis=-1, outaxis=-1)
&gt;&gt;&gt; x.shape
(2, 3, 5)
&gt;&gt;&gt; np.set_printoptions(precision=3)  # For compact output of numbers.
&gt;&gt;&gt; x
array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],
        [ 0.651,  0.989,  2.046,  0.627,  1.072],
        [ 1.42 ,  1.758,  2.816,  1.396,  1.841]],
       [[ 0.401,  0.304,  0.694, -0.867,  0.377],
        [ 0.856,  0.758,  1.149, -0.412,  0.831],
        [ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])

Check by solving one pair of `c` and `b` vectors (cf. ``x[1, 1, :]``):

&gt;&gt;&gt; solve_circulant(c[1], b[1, :])
array([ 0.856,  0.758,  1.149, -0.412,  0.831])</pre> <div class="fragment"><div class="line"><span class="lineno">  691</span>                    caxis=-1, baxis=0, outaxis=0):</div>
<div class="line"><span class="lineno">  692</span>    <span class="stringliteral">&quot;&quot;&quot;Solve C x = b for x, where C is a circulant matrix.</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    `C` is the circulant matrix associated with the vector `c`.</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    The system is solved by doing division in Fourier space. The</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    calculation is::</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        x = ifft(fft(b) / fft(c))</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    where `fft` and `ifft` are the fast Fourier transform and its inverse,</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    respectively. For a large vector `c`, this is *much* faster than</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    solving the system with the full circulant matrix.</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        The coefficients of the circulant matrix.</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">        Right-hand side matrix in ``a x = b``.</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    singular : str, optional</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">        This argument controls how a near singular circulant matrix is</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        handled.  If `singular` is &quot;raise&quot; and the circulant matrix is</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        near singular, a `LinAlgError` is raised. If `singular` is</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">        &quot;lstsq&quot;, the least squares solution is returned. Default is &quot;raise&quot;.</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        If any eigenvalue of the circulant matrix has an absolute value</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">        that is less than or equal to `tol`, the matrix is considered to be</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        near singular. If not given, `tol` is set to::</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">            tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">        where `abs_eigs` is the array of absolute values of the eigenvalues</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">        of the circulant matrix.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    caxis : int</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">        When `c` has dimension greater than 1, it is viewed as a collection</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">        of circulant vectors. In this case, `caxis` is the axis of `c` that</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        holds the vectors of circulant coefficients.</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    baxis : int</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">        When `b` has dimension greater than 1, it is viewed as a collection</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">        of vectors. In this case, `baxis` is the axis of `b` that holds the</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">        right-hand side vectors.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    outaxis : int</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">        When `c` or `b` are multidimensional, the value returned by</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        `solve_circulant` is multidimensional. In this case, `outaxis` is</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        the axis of the result that holds the solution vectors.</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">        Solution to the system ``C x = b``.</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        If the circulant matrix associated with `c` is near singular.</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    circulant : circulant matrix</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    For a 1-D vector `c` with length `m`, and an array `b`</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    with shape ``(m, ...)``,</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">        solve_circulant(c, b)</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    returns the same result as</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        solve(circulant(c), b)</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    where `solve` and `circulant` are from `scipy.linalg`.</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import solve_circulant, solve, circulant, lstsq</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    &gt;&gt;&gt; c = np.array([2, 2, 4])</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    &gt;&gt;&gt; solve_circulant(c, b)</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    array([ 0.75, -0.25,  0.25])</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    Compare that result to solving the system with `scipy.linalg.solve`:</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    &gt;&gt;&gt; solve(circulant(c), b)</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    array([ 0.75, -0.25,  0.25])</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    A singular example:</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    &gt;&gt;&gt; c = np.array([1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    Calling ``solve_circulant(c, b)`` will raise a `LinAlgError`.  For the</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    least square solution, use the option ``singular=&#39;lstsq&#39;``:</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    &gt;&gt;&gt; solve_circulant(c, b, singular=&#39;lstsq&#39;)</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    array([ 0.25,  1.25,  2.25,  1.25])</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    Compare to `scipy.linalg.lstsq`:</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    &gt;&gt;&gt; x, resid, rnk, s = lstsq(circulant(c), b)</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    array([ 0.25,  1.25,  2.25,  1.25])</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    A broadcasting example:</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    Suppose we have the vectors of two circulant matrices stored in an array</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    with shape (2, 5), and three `b` vectors stored in an array with shape</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    (3, 5).  For example,</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    &gt;&gt;&gt; c = np.array([[1.5, 2, 3, 0, 0], [1, 1, 4, 3, 2]])</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(15).reshape(-1, 5)</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    We want to solve all combinations of circulant matrices and `b` vectors,</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    with the result stored in an array with shape (2, 3, 5). When we</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    disregard the axes of `c` and `b` that hold the vectors of coefficients,</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    the shapes of the collections are (2,) and (3,), respectively, which are</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    not compatible for broadcasting. To have a broadcast result with shape</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    (2, 3), we add a trivial dimension to `c`: ``c[:, np.newaxis, :]`` has</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    shape (2, 1, 5). The last dimension holds the coefficients of the</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    circulant matrices, so when we call `solve_circulant`, we can use the</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    default ``caxis=-1``. The coefficients of the `b` vectors are in the last</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    dimension of the array `b`, so we use ``baxis=-1``. If we use the</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    default `outaxis`, the result will have shape (5, 2, 3), so we&#39;ll use</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    ``outaxis=-1`` to put the solution vectors in the last dimension.</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    &gt;&gt;&gt; x = solve_circulant(c[:, np.newaxis, :], b, baxis=-1, outaxis=-1)</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    &gt;&gt;&gt; x.shape</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    (2, 3, 5)</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    &gt;&gt;&gt; np.set_printoptions(precision=3)  # For compact output of numbers.</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">            [ 0.651,  0.989,  2.046,  0.627,  1.072],</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">            [ 1.42 ,  1.758,  2.816,  1.396,  1.841]],</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">           [[ 0.401,  0.304,  0.694, -0.867,  0.377],</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">            [ 0.856,  0.758,  1.149, -0.412,  0.831],</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">            [ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    Check by solving one pair of `c` and `b` vectors (cf. ``x[1, 1, :]``):</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    &gt;&gt;&gt; solve_circulant(c[1], b[1, :])</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    array([ 0.856,  0.758,  1.149, -0.412,  0.831])</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  838</span>    c = np.atleast_1d(c)</div>
<div class="line"><span class="lineno">  839</span>    nc = _get_axis_len(<span class="stringliteral">&quot;c&quot;</span>, c, caxis)</div>
<div class="line"><span class="lineno">  840</span>    b = np.atleast_1d(b)</div>
<div class="line"><span class="lineno">  841</span>    nb = _get_axis_len(<span class="stringliteral">&quot;b&quot;</span>, b, baxis)</div>
<div class="line"><span class="lineno">  842</span>    <span class="keywordflow">if</span> nc != nb:</div>
<div class="line"><span class="lineno">  843</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Shapes of c {} and b {} are incompatible&#39;</span></div>
<div class="line"><span class="lineno">  844</span>                         .format(c.shape, b.shape))</div>
<div class="line"><span class="lineno">  845</span> </div>
<div class="line"><span class="lineno">  846</span>    fc = np.fft.fft(np.moveaxis(c, caxis, -1), axis=-1)</div>
<div class="line"><span class="lineno">  847</span>    abs_fc = np.abs(fc)</div>
<div class="line"><span class="lineno">  848</span>    <span class="keywordflow">if</span> tol <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  849</span>        <span class="comment"># This is the same tolerance as used in np.linalg.matrix_rank.</span></div>
<div class="line"><span class="lineno">  850</span>        tol = abs_fc.max(axis=-1) * nc * np.finfo(np.float64).eps</div>
<div class="line"><span class="lineno">  851</span>        <span class="keywordflow">if</span> tol.shape != ():</div>
<div class="line"><span class="lineno">  852</span>            tol.shape = tol.shape + (1,)</div>
<div class="line"><span class="lineno">  853</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  854</span>            tol = np.atleast_1d(tol)</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span>    near_zeros = abs_fc &lt;= tol</div>
<div class="line"><span class="lineno">  857</span>    is_near_singular = np.any(near_zeros)</div>
<div class="line"><span class="lineno">  858</span>    <span class="keywordflow">if</span> is_near_singular:</div>
<div class="line"><span class="lineno">  859</span>        <span class="keywordflow">if</span> singular == <span class="stringliteral">&#39;raise&#39;</span>:</div>
<div class="line"><span class="lineno">  860</span>            <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;near singular circulant matrix.&quot;</span>)</div>
<div class="line"><span class="lineno">  861</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  862</span>            <span class="comment"># Replace the small values with 1 to avoid errors in the</span></div>
<div class="line"><span class="lineno">  863</span>            <span class="comment"># division fb/fc below.</span></div>
<div class="line"><span class="lineno">  864</span>            fc[near_zeros] = 1</div>
<div class="line"><span class="lineno">  865</span> </div>
<div class="line"><span class="lineno">  866</span>    fb = np.fft.fft(np.moveaxis(b, baxis, -1), axis=-1)</div>
<div class="line"><span class="lineno">  867</span> </div>
<div class="line"><span class="lineno">  868</span>    q = fb / fc</div>
<div class="line"><span class="lineno">  869</span> </div>
<div class="line"><span class="lineno">  870</span>    <span class="keywordflow">if</span> is_near_singular:</div>
<div class="line"><span class="lineno">  871</span>        <span class="comment"># `near_zeros` is a boolean array, same shape as `c`, that is</span></div>
<div class="line"><span class="lineno">  872</span>        <span class="comment"># True where `fc` is (near) zero. `q` is the broadcasted result</span></div>
<div class="line"><span class="lineno">  873</span>        <span class="comment"># of fb / fc, so to set the values of `q` to 0 where `fc` is near</span></div>
<div class="line"><span class="lineno">  874</span>        <span class="comment"># zero, we use a mask that is the broadcast result of an array</span></div>
<div class="line"><span class="lineno">  875</span>        <span class="comment"># of True values shaped like `b` with `near_zeros`.</span></div>
<div class="line"><span class="lineno">  876</span>        mask = np.ones_like(b, dtype=bool) &amp; near_zeros</div>
<div class="line"><span class="lineno">  877</span>        q[mask] = 0</div>
<div class="line"><span class="lineno">  878</span> </div>
<div class="line"><span class="lineno">  879</span>    x = np.fft.ifft(q, axis=-1)</div>
<div class="line"><span class="lineno">  880</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (np.iscomplexobj(c) <span class="keywordflow">or</span> np.iscomplexobj(b)):</div>
<div class="line"><span class="lineno">  881</span>        x = x.real</div>
<div class="line"><span class="lineno">  882</span>    <span class="keywordflow">if</span> outaxis != -1:</div>
<div class="line"><span class="lineno">  883</span>        x = np.moveaxis(x, -1, outaxis)</div>
<div class="line"><span class="lineno">  884</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  885</span> </div>
<div class="line"><span class="lineno">  886</span> </div>
<div class="line"><span class="lineno">  887</span><span class="comment"># matrix inversion</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa0a809357e4f6af2a1ca9252de7e89d" name="aaa0a809357e4f6af2a1ca9252de7e89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0a809357e4f6af2a1ca9252de7e89d">&#9670;&#160;</a></span>solve_toeplitz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_toeplitz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c_or_cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a Toeplitz system using Levinson Recursion

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c_or_cr : array_like or tuple of (array_like, array_like)
    The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
    actual shape of ``c``, it will be converted to a 1-D array. If not
    supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape
    of ``r``, it will be converted to a 1-D array.
b : (M,) or (M, K) array_like
    Right-hand side in ``T x = b``.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system ``T x = b``. Shape of return matches shape
    of `b`.

See Also
--------
toeplitz : Toeplitz matrix

Notes
-----
The solution is computed using Levinson-Durbin recursion, which is faster
than generic least-squares methods, but can be less numerically stable.

Examples
--------
Solve the Toeplitz system T x = b, where::

        [ 1 -1 -2 -3]       [1]
    T = [ 3  1 -1 -2]   b = [2]
        [ 6  3  1 -1]       [2]
        [10  6  3  1]       [5]

To specify the Toeplitz matrix, only the first column and the first
row are needed.

&gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T
&gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T
&gt;&gt;&gt; b = np.array([1, 2, 2, 5])

&gt;&gt;&gt; from scipy.linalg import solve_toeplitz, toeplitz
&gt;&gt;&gt; x = solve_toeplitz((c, r), b)
&gt;&gt;&gt; x
array([ 1.66666667, -1.        , -2.66666667,  2.33333333])

Check the result by creating the full Toeplitz matrix and
multiplying it by `x`.  We should get `b`.

&gt;&gt;&gt; T = toeplitz(c, r)
&gt;&gt;&gt; T.dot(x)
array([ 1.,  2.,  2.,  5.])</pre> <div class="fragment"><div class="line"><span class="lineno">  591</span><span class="keyword">def </span>solve_toeplitz(c_or_cr, b, check_finite=True):</div>
<div class="line"><span class="lineno">  592</span>    <span class="stringliteral">&quot;&quot;&quot;Solve a Toeplitz system using Levinson Recursion</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    The Toeplitz matrix has constant diagonals, with c as its first column</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    and r as its first row. If r is not given, ``r == conjugate(c)`` is</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    assumed.</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    c_or_cr : array_like or tuple of (array_like, array_like)</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        actual shape of ``c``, it will be converted to a 1-D array. If not</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">        supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        of ``r``, it will be converted to a 1-D array.</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    b : (M,) or (M, K) array_like</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">        Right-hand side in ``T x = b``.</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">        (result entirely NaNs) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    x : (M,) or (M, K) ndarray</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">        The solution to the system ``T x = b``. Shape of return matches shape</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        of `b`.</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    toeplitz : Toeplitz matrix</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    The solution is computed using Levinson-Durbin recursion, which is faster</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    than generic least-squares methods, but can be less numerically stable.</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    Solve the Toeplitz system T x = b, where::</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">            [ 1 -1 -2 -3]       [1]</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">        T = [ 3  1 -1 -2]   b = [2]</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">            [ 6  3  1 -1]       [2]</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">            [10  6  3  1]       [5]</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    To specify the Toeplitz matrix, only the first column and the first</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    row are needed.</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    &gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    &gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 2, 2, 5])</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import solve_toeplitz, toeplitz</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    &gt;&gt;&gt; x = solve_toeplitz((c, r), b)</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    array([ 1.66666667, -1.        , -2.66666667,  2.33333333])</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    Check the result by creating the full Toeplitz matrix and</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    multiplying it by `x`.  We should get `b`.</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    &gt;&gt;&gt; T = toeplitz(c, r)</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    &gt;&gt;&gt; T.dot(x)</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    array([ 1.,  2.,  2.,  5.])</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  658</span>    <span class="comment"># If numerical stability of this algorithm is a problem, a future</span></div>
<div class="line"><span class="lineno">  659</span>    <span class="comment"># developer might consider implementing other O(N^2) Toeplitz solvers,</span></div>
<div class="line"><span class="lineno">  660</span>    <span class="comment"># such as GKO (https://www.jstor.org/stable/2153371) or Bareiss.</span></div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span>    r, c, b, dtype, b_shape = _validate_args_for_toeplitz_ops(</div>
<div class="line"><span class="lineno">  663</span>        c_or_cr, b, check_finite, keep_b_shape=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  664</span> </div>
<div class="line"><span class="lineno">  665</span>    <span class="comment"># Form a 1-D array of values to be used in the matrix, containing a</span></div>
<div class="line"><span class="lineno">  666</span>    <span class="comment"># reversed copy of r[1:], followed by c.</span></div>
<div class="line"><span class="lineno">  667</span>    vals = np.concatenate((r[-1:0:-1], c))</div>
<div class="line"><span class="lineno">  668</span>    <span class="keywordflow">if</span> b <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  669</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value, `b` is a required argument&#39;</span>)</div>
<div class="line"><span class="lineno">  670</span> </div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">if</span> b.ndim == 1:</div>
<div class="line"><span class="lineno">  672</span>        x, _ = levinson(vals, np.ascontiguousarray(b))</div>
<div class="line"><span class="lineno">  673</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  674</span>        x = np.column_stack([levinson(vals, np.ascontiguousarray(b[:, i]))[0]</div>
<div class="line"><span class="lineno">  675</span>                             <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(b.shape[1])])</div>
<div class="line"><span class="lineno">  676</span>        x = x.reshape(*b_shape)</div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  679</span> </div>
<div class="line"><span class="lineno">  680</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ebf69aafbab343a582ea7441b8eebe1" name="a0ebf69aafbab343a582ea7441b8eebe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebf69aafbab343a582ea7441b8eebe1">&#9670;&#160;</a></span>solve_triangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_triangular </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trans</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lower</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unit_diagonal</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the equation `a x = b` for `x`, assuming a is a triangular matrix.

Parameters
----------
a : (M, M) array_like
    A triangular matrix
b : (M,) or (M, N) array_like
    Right-hand side matrix in `a x = b`
lower : bool, optional
    Use only data contained in the lower triangle of `a`.
    Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
    Type of system to solve:

    ========  =========
    trans     system
    ========  =========
    0 or 'N'  a x  = b
    1 or 'T'  a^T x = b
    2 or 'C'  a^H x = b
    ========  =========
unit_diagonal : bool, optional
    If True, diagonal elements of `a` are assumed to be 1 and
    will not be referenced.
overwrite_b : bool, optional
    Allow overwriting data in `b` (may enhance performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, N) ndarray
    Solution to the system `a x = b`.  Shape of return matches `b`.

Raises
------
LinAlgError
    If `a` is singular

Notes
-----
.. versionadded:: 0.9.0

Examples
--------
Solve the lower triangular system a x = b, where::

         [3  0  0  0]       [4]
    a =  [2  1  0  0]   b = [2]
         [1  0  1  0]       [4]
         [1  1  1  1]       [2]

&gt;&gt;&gt; from scipy.linalg import solve_triangular
&gt;&gt;&gt; a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])
&gt;&gt;&gt; b = np.array([4, 2, 4, 2])
&gt;&gt;&gt; x = solve_triangular(a, b, lower=True)
&gt;&gt;&gt; x
array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])
&gt;&gt;&gt; a.dot(x)  # Check the result
array([ 4.,  2.,  4.,  2.])</pre> <div class="fragment"><div class="line"><span class="lineno">  266</span>                     overwrite_b=<span class="keyword">False</span>, check_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  267</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    Solve the equation `a x = b` for `x`, assuming a is a triangular matrix.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    a : (M, M) array_like</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">        A triangular matrix</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    b : (M,) or (M, N) array_like</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        Right-hand side matrix in `a x = b`</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    lower : bool, optional</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        Use only data contained in the lower triangle of `a`.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        Default is to use upper triangle.</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    trans : {0, 1, 2, &#39;N&#39;, &#39;T&#39;, &#39;C&#39;}, optional</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        Type of system to solve:</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        ========  =========</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        trans     system</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        ========  =========</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        0 or &#39;N&#39;  a x  = b</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        1 or &#39;T&#39;  a^T x = b</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">        2 or &#39;C&#39;  a^H x = b</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        ========  =========</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    unit_diagonal : bool, optional</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">        If True, diagonal elements of `a` are assumed to be 1 and</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        will not be referenced.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    overwrite_b : bool, optional</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        Allow overwriting data in `b` (may enhance performance)</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    x : (M,) or (M, N) ndarray</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">        Solution to the system `a x = b`.  Shape of return matches `b`.</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        If `a` is singular</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    .. versionadded:: 0.9.0</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    Solve the lower triangular system a x = b, where::</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">             [3  0  0  0]       [4]</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        a =  [2  1  0  0]   b = [2]</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">             [1  0  1  0]       [4]</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">             [1  1  1  1]       [2]</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import solve_triangular</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([4, 2, 4, 2])</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    &gt;&gt;&gt; x = solve_triangular(a, b, lower=True)</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    &gt;&gt;&gt; a.dot(x)  # Check the result</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    array([ 4.,  2.,  4.,  2.])</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>    a1 = _asarray_validated(a, check_finite=check_finite)</div>
<div class="line"><span class="lineno">  334</span>    b1 = _asarray_validated(b, check_finite=check_finite)</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">if</span> len(a1.shape) != 2 <span class="keywordflow">or</span> a1.shape[0] != a1.shape[1]:</div>
<div class="line"><span class="lineno">  336</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  337</span>    <span class="keywordflow">if</span> a1.shape[0] != b1.shape[0]:</div>
<div class="line"><span class="lineno">  338</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;shapes of a {} and b {} are incompatible&#39;</span></div>
<div class="line"><span class="lineno">  339</span>                         .format(a1.shape, b1.shape))</div>
<div class="line"><span class="lineno">  340</span>    overwrite_b = overwrite_b <span class="keywordflow">or</span> _datacopied(b1, b)</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>    trans = {<span class="stringliteral">&#39;N&#39;</span>: 0, <span class="stringliteral">&#39;T&#39;</span>: 1, <span class="stringliteral">&#39;C&#39;</span>: 2}.get(trans, trans)</div>
<div class="line"><span class="lineno">  343</span>    trtrs, = get_lapack_funcs((<span class="stringliteral">&#39;trtrs&#39;</span>,), (a1, b1))</div>
<div class="line"><span class="lineno">  344</span>    <span class="keywordflow">if</span> a1.flags.f_contiguous <span class="keywordflow">or</span> trans == 2:</div>
<div class="line"><span class="lineno">  345</span>        x, info = trtrs(a1, b1, overwrite_b=overwrite_b, lower=lower,</div>
<div class="line"><span class="lineno">  346</span>                        trans=trans, unitdiag=unit_diagonal)</div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  348</span>        <span class="comment"># transposed system is solved since trtrs expects Fortran ordering</span></div>
<div class="line"><span class="lineno">  349</span>        x, info = trtrs(a1.T, b1, overwrite_b=overwrite_b, lower=<span class="keywordflow">not</span> lower,</div>
<div class="line"><span class="lineno">  350</span>                        trans=<span class="keywordflow">not</span> trans, unitdiag=unit_diagonal)</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">if</span> info == 0:</div>
<div class="line"><span class="lineno">  353</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  354</span>    <span class="keywordflow">if</span> info &gt; 0:</div>
<div class="line"><span class="lineno">  355</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;singular matrix: resolution failed at diagonal %d&quot;</span> %</div>
<div class="line"><span class="lineno">  356</span>                          (info-1))</div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value in %dth argument of internal trtrs&#39;</span> %</div>
<div class="line"><span class="lineno">  358</span>                     (-info))</div>
<div class="line"><span class="lineno">  359</span> </div>
<div class="line"><span class="lineno">  360</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a80a424ac351c88519ec403e156cf825f" name="a80a424ac351c88519ec403e156cf825f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a424ac351c88519ec403e156cf825f">&#9670;&#160;</a></span>solveh_banded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solveh_banded </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_ab</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lower</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve equation a x = b. a is Hermitian positive-definite banded matrix.

The matrix a is stored in `ab` either in lower diagonal or upper
diagonal ordered form:

    ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
    ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)

Example of `ab` (shape of a is (6, 6), `u` =2)::

    upper form:
    *   *   a02 a13 a24 a35
    *   a01 a12 a23 a34 a45
    a00 a11 a22 a33 a44 a55

    lower form:
    a00 a11 a22 a33 a44 a55
    a10 a21 a32 a43 a54 *
    a20 a31 a42 a53 *   *

Cells marked with * are not used.

Parameters
----------
ab : (`u` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : bool, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance)
lower : bool, optional
    Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system a x = b. Shape of return matches shape
    of `b`.

Examples
--------
Solve the banded system A x = b, where::

        [ 4  2 -1  0  0  0]       [1]
        [ 2  5  2 -1  0  0]       [2]
    A = [-1  2  6  2 -1  0]   b = [2]
        [ 0 -1  2  7  2 -1]       [3]
        [ 0  0 -1  2  8  2]       [3]
        [ 0  0  0 -1  2  9]       [3]

&gt;&gt;&gt; from scipy.linalg import solveh_banded

`ab` contains the main diagonal and the nonzero diagonals below the
main diagonal. That is, we use the lower form:

&gt;&gt;&gt; ab = np.array([[ 4,  5,  6,  7, 8, 9],
...                [ 2,  2,  2,  2, 2, 0],
...                [-1, -1, -1, -1, 0, 0]])
&gt;&gt;&gt; b = np.array([1, 2, 2, 3, 3, 3])
&gt;&gt;&gt; x = solveh_banded(ab, b, lower=True)
&gt;&gt;&gt; x
array([ 0.03431373,  0.45938375,  0.05602241,  0.47759104,  0.17577031,
        0.34733894])


Solve the Hermitian banded system H x = b, where::

        [ 8   2-1j   0     0  ]        [ 1  ]
    H = [2+1j  5     1j    0  ]    b = [1+1j]
        [ 0   -1j    9   -2-1j]        [1-2j]
        [ 0    0   -2+1j   6  ]        [ 0  ]

In this example, we put the upper diagonals in the array `hb`:

&gt;&gt;&gt; hb = np.array([[0, 2-1j, 1j, -2-1j],
...                [8,  5,    9,   6  ]])
&gt;&gt;&gt; b = np.array([1, 1+1j, 1-2j, 0])
&gt;&gt;&gt; x = solveh_banded(hb, b)
&gt;&gt;&gt; x
array([ 0.07318536-0.02939412j,  0.11877624+0.17696461j,
        0.10077984-0.23035393j, -0.00479904-0.09358128j])</pre> <div class="fragment"><div class="line"><span class="lineno">  469</span>                  check_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  470</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    Solve equation a x = b. a is Hermitian positive-definite banded matrix.</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    The matrix a is stored in `ab` either in lower diagonal or upper</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    diagonal ordered form:</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    Example of `ab` (shape of a is (6, 6), `u` =2)::</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        upper form:</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        *   *   a02 a13 a24 a35</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        *   a01 a12 a23 a34 a45</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        a00 a11 a22 a33 a44 a55</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        lower form:</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        a00 a11 a22 a33 a44 a55</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        a10 a21 a32 a43 a54 *</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        a20 a31 a42 a53 *   *</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    Cells marked with * are not used.</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    ab : (`u` + 1, M) array_like</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        Banded matrix</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    b : (M,) or (M, K) array_like</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">        Right-hand side</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    overwrite_ab : bool, optional</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        Discard data in `ab` (may enhance performance)</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    overwrite_b : bool, optional</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        Discard data in `b` (may enhance performance)</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    lower : bool, optional</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        Is the matrix in the lower form. (Default is upper form)</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        Whether to check that the input matrices contain only finite numbers.</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    x : (M,) or (M, K) ndarray</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        The solution to the system a x = b. Shape of return matches shape</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        of `b`.</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    Solve the banded system A x = b, where::</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">            [ 4  2 -1  0  0  0]       [1]</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">            [ 2  5  2 -1  0  0]       [2]</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        A = [-1  2  6  2 -1  0]   b = [2]</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">            [ 0 -1  2  7  2 -1]       [3]</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">            [ 0  0 -1  2  8  2]       [3]</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">            [ 0  0  0 -1  2  9]       [3]</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import solveh_banded</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    `ab` contains the main diagonal and the nonzero diagonals below the</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    main diagonal. That is, we use the lower form:</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    &gt;&gt;&gt; ab = np.array([[ 4,  5,  6,  7, 8, 9],</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    ...                [ 2,  2,  2,  2, 2, 0],</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    ...                [-1, -1, -1, -1, 0, 0]])</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 2, 2, 3, 3, 3])</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    &gt;&gt;&gt; x = solveh_banded(ab, b, lower=True)</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    array([ 0.03431373,  0.45938375,  0.05602241,  0.47759104,  0.17577031,</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">            0.34733894])</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    Solve the Hermitian banded system H x = b, where::</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">            [ 8   2-1j   0     0  ]        [ 1  ]</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        H = [2+1j  5     1j    0  ]    b = [1+1j]</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">            [ 0   -1j    9   -2-1j]        [1-2j]</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">            [ 0    0   -2+1j   6  ]        [ 0  ]</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    In this example, we put the upper diagonals in the array `hb`:</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    &gt;&gt;&gt; hb = np.array([[0, 2-1j, 1j, -2-1j],</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    ...                [8,  5,    9,   6  ]])</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 1+1j, 1-2j, 0])</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    &gt;&gt;&gt; x = solveh_banded(hb, b)</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    array([ 0.07318536-0.02939412j,  0.11877624+0.17696461j,</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">            0.10077984-0.23035393j, -0.00479904-0.09358128j])</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  560</span>    a1 = _asarray_validated(ab, check_finite=check_finite)</div>
<div class="line"><span class="lineno">  561</span>    b1 = _asarray_validated(b, check_finite=check_finite)</div>
<div class="line"><span class="lineno">  562</span>    <span class="comment"># Validate shapes.</span></div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">if</span> a1.shape[-1] != b1.shape[0]:</div>
<div class="line"><span class="lineno">  564</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;shapes of ab and b are not compatible.&quot;</span>)</div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span>    overwrite_b = overwrite_b <span class="keywordflow">or</span> _datacopied(b1, b)</div>
<div class="line"><span class="lineno">  567</span>    overwrite_ab = overwrite_ab <span class="keywordflow">or</span> _datacopied(a1, ab)</div>
<div class="line"><span class="lineno">  568</span> </div>
<div class="line"><span class="lineno">  569</span>    <span class="keywordflow">if</span> a1.shape[0] == 2:</div>
<div class="line"><span class="lineno">  570</span>        ptsv, = get_lapack_funcs((<span class="stringliteral">&#39;ptsv&#39;</span>,), (a1, b1))</div>
<div class="line"><span class="lineno">  571</span>        <span class="keywordflow">if</span> lower:</div>
<div class="line"><span class="lineno">  572</span>            d = a1[0, :].real</div>
<div class="line"><span class="lineno">  573</span>            e = a1[1, :-1]</div>
<div class="line"><span class="lineno">  574</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  575</span>            d = a1[1, :].real</div>
<div class="line"><span class="lineno">  576</span>            e = a1[0, 1:].conj()</div>
<div class="line"><span class="lineno">  577</span>        d, du, x, info = ptsv(d, e, b1, overwrite_ab, overwrite_ab,</div>
<div class="line"><span class="lineno">  578</span>                              overwrite_b)</div>
<div class="line"><span class="lineno">  579</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  580</span>        pbsv, = get_lapack_funcs((<span class="stringliteral">&#39;pbsv&#39;</span>,), (a1, b1))</div>
<div class="line"><span class="lineno">  581</span>        c, x, info = pbsv(a1, b1, lower=lower, overwrite_ab=overwrite_ab,</div>
<div class="line"><span class="lineno">  582</span>                          overwrite_b=overwrite_b)</div>
<div class="line"><span class="lineno">  583</span>    <span class="keywordflow">if</span> info &gt; 0:</div>
<div class="line"><span class="lineno">  584</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;%dth leading minor not positive definite&quot;</span> % info)</div>
<div class="line"><span class="lineno">  585</span>    <span class="keywordflow">if</span> info &lt; 0:</div>
<div class="line"><span class="lineno">  586</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value in %dth argument of internal &#39;</span></div>
<div class="line"><span class="lineno">  587</span>                         <span class="stringliteral">&#39;pbsv&#39;</span> % -info)</div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  589</span> </div>
<div class="line"><span class="lineno">  590</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a86596f567fe32523d12b4fe39d115492" name="a86596f567fe32523d12b4fe39d115492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86596f567fe32523d12b4fe39d115492">&#9670;&#160;</a></span>default_lapack_driver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.default_lapack_driver</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
