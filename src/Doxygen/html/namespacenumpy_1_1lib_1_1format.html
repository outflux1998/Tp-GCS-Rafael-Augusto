<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.format Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1format.html">format</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.format Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac0ca853806342a737108256b62a15a12" id="r_ac0ca853806342a737108256b62a15a12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ac0ca853806342a737108256b62a15a12">_check_version</a> (version)</td></tr>
<tr class="separator:ac0ca853806342a737108256b62a15a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13663fe6f8d9b52354f3fad05dfd37c6" id="r_a13663fe6f8d9b52354f3fad05dfd37c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a13663fe6f8d9b52354f3fad05dfd37c6">magic</a> (major, minor)</td></tr>
<tr class="separator:a13663fe6f8d9b52354f3fad05dfd37c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1aea029d05724a019a8b3f5039bc0f" id="r_a5e1aea029d05724a019a8b3f5039bc0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a5e1aea029d05724a019a8b3f5039bc0f">read_magic</a> (fp)</td></tr>
<tr class="separator:a5e1aea029d05724a019a8b3f5039bc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6f2566af6989a042d2e35947d6dcbf" id="r_abb6f2566af6989a042d2e35947d6dcbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#abb6f2566af6989a042d2e35947d6dcbf">_has_metadata</a> (dt)</td></tr>
<tr class="separator:abb6f2566af6989a042d2e35947d6dcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77421712330dbc063b7fbc3e62900fc4" id="r_a77421712330dbc063b7fbc3e62900fc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a77421712330dbc063b7fbc3e62900fc4">dtype_to_descr</a> (dtype)</td></tr>
<tr class="separator:a77421712330dbc063b7fbc3e62900fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394dd4b07c00d459974f9062ce524a7" id="r_a7394dd4b07c00d459974f9062ce524a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a7394dd4b07c00d459974f9062ce524a7">descr_to_dtype</a> (descr)</td></tr>
<tr class="separator:a7394dd4b07c00d459974f9062ce524a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f682f7260515fee7dfca0a2c47363dc" id="r_a5f682f7260515fee7dfca0a2c47363dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a5f682f7260515fee7dfca0a2c47363dc">header_data_from_array_1_0</a> (array)</td></tr>
<tr class="separator:a5f682f7260515fee7dfca0a2c47363dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5743b8903a9aefd1b78f85ae56b6fd" id="r_a4d5743b8903a9aefd1b78f85ae56b6fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a4d5743b8903a9aefd1b78f85ae56b6fd">_wrap_header</a> (header, version)</td></tr>
<tr class="separator:a4d5743b8903a9aefd1b78f85ae56b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40bbbde1a48400720b5a24350ce8d31" id="r_ae40bbbde1a48400720b5a24350ce8d31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ae40bbbde1a48400720b5a24350ce8d31">_wrap_header_guess_version</a> (header)</td></tr>
<tr class="separator:ae40bbbde1a48400720b5a24350ce8d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ccbfcb3ac4d734bbaee3e27b92ebb5" id="r_ac6ccbfcb3ac4d734bbaee3e27b92ebb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ac6ccbfcb3ac4d734bbaee3e27b92ebb5">_write_array_header</a> (fp, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>, version=None)</td></tr>
<tr class="separator:ac6ccbfcb3ac4d734bbaee3e27b92ebb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f2f0c37d656ed720cabfdccfde9c03" id="r_af8f2f0c37d656ed720cabfdccfde9c03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#af8f2f0c37d656ed720cabfdccfde9c03">write_array_header_1_0</a> (fp, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>)</td></tr>
<tr class="separator:af8f2f0c37d656ed720cabfdccfde9c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de58f169f5808e03f9b15e25b3cc4ba" id="r_a1de58f169f5808e03f9b15e25b3cc4ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a1de58f169f5808e03f9b15e25b3cc4ba">write_array_header_2_0</a> (fp, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>)</td></tr>
<tr class="separator:a1de58f169f5808e03f9b15e25b3cc4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9ad9707fe293d136999f2b1c029bea" id="r_a4d9ad9707fe293d136999f2b1c029bea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a4d9ad9707fe293d136999f2b1c029bea">read_array_header_1_0</a> (fp, max_header_size=<a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a>)</td></tr>
<tr class="separator:a4d9ad9707fe293d136999f2b1c029bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165e24908a970b112a9e04d69351333b" id="r_a165e24908a970b112a9e04d69351333b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a165e24908a970b112a9e04d69351333b">read_array_header_2_0</a> (fp, max_header_size=<a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a>)</td></tr>
<tr class="separator:a165e24908a970b112a9e04d69351333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72800025dff1debc7f20d85c3a984a45" id="r_a72800025dff1debc7f20d85c3a984a45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a72800025dff1debc7f20d85c3a984a45">_filter_header</a> (s)</td></tr>
<tr class="separator:a72800025dff1debc7f20d85c3a984a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc600cbfefe9e63f9c29ef229fe0e15" id="r_aacc600cbfefe9e63f9c29ef229fe0e15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#aacc600cbfefe9e63f9c29ef229fe0e15">_read_array_header</a> (fp, version, max_header_size=<a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a>)</td></tr>
<tr class="separator:aacc600cbfefe9e63f9c29ef229fe0e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fe5b2446c9a06bf4c1c84ab1c383e8" id="r_af7fe5b2446c9a06bf4c1c84ab1c383e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#af7fe5b2446c9a06bf4c1c84ab1c383e8">write_array</a> (fp, array, version=None, allow_pickle=True, pickle_kwargs=None)</td></tr>
<tr class="separator:af7fe5b2446c9a06bf4c1c84ab1c383e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bf04af902c69065e0642a4ecf04765" id="r_a95bf04af902c69065e0642a4ecf04765"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a95bf04af902c69065e0642a4ecf04765">read_array</a> (fp, allow_pickle=False, pickle_kwargs=None, *max_header_size=<a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a>)</td></tr>
<tr class="separator:a95bf04af902c69065e0642a4ecf04765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e30ad134d4c644b702a4335e7371a6" id="r_ab0e30ad134d4c644b702a4335e7371a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab0e30ad134d4c644b702a4335e7371a6">open_memmap</a> (filename, mode='<a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>+', dtype=None, <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>=None, fortran_order=False, version=None, *max_header_size=<a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a>)</td></tr>
<tr class="separator:ab0e30ad134d4c644b702a4335e7371a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac937ddc972a32e45e37661a12b5c7caa" id="r_ac937ddc972a32e45e37661a12b5c7caa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ac937ddc972a32e45e37661a12b5c7caa">_read_bytes</a> (fp, <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a0d731b579c770accbe47efa0d327b36e">size</a>, error_template=&quot;ran out of data&quot;)</td></tr>
<tr class="separator:ac937ddc972a32e45e37661a12b5c7caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4eb42bfc405375befeb4f625b0df5950" id="r_a4eb42bfc405375befeb4f625b0df5950"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a4eb42bfc405375befeb4f625b0df5950">EXPECTED_KEYS</a> = {'descr', 'fortran_order', '<a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>'}</td></tr>
<tr class="separator:a4eb42bfc405375befeb4f625b0df5950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ed04ba05fc05cf9540453092ba4936" id="r_aa1ed04ba05fc05cf9540453092ba4936"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#aa1ed04ba05fc05cf9540453092ba4936">MAGIC_PREFIX</a> = b'\x93NUMPY'</td></tr>
<tr class="separator:aa1ed04ba05fc05cf9540453092ba4936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f9be3c01b0c6f44a3f1032d1e6ca5d" id="r_a37f9be3c01b0c6f44a3f1032d1e6ca5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a37f9be3c01b0c6f44a3f1032d1e6ca5d">MAGIC_LEN</a> = len(<a class="el" href="namespacenumpy_1_1lib_1_1format.html#aa1ed04ba05fc05cf9540453092ba4936">MAGIC_PREFIX</a>) + 2</td></tr>
<tr class="separator:a37f9be3c01b0c6f44a3f1032d1e6ca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404e4d42ca389ce34e609b900e971155" id="r_a404e4d42ca389ce34e609b900e971155"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a404e4d42ca389ce34e609b900e971155">ARRAY_ALIGN</a> = 64</td></tr>
<tr class="separator:a404e4d42ca389ce34e609b900e971155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6499cae034b0938029effa8853d1629c" id="r_a6499cae034b0938029effa8853d1629c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a6499cae034b0938029effa8853d1629c">BUFFER_SIZE</a> = 2**18</td></tr>
<tr class="separator:a6499cae034b0938029effa8853d1629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545ec631cafb4205aca4f67effdbee0" id="r_a5545ec631cafb4205aca4f67effdbee0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a5545ec631cafb4205aca4f67effdbee0">GROWTH_AXIS_MAX_DIGITS</a> = 21</td></tr>
<tr class="separator:a5545ec631cafb4205aca4f67effdbee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694f277f3bec0e61b0254d68b61c4a3f" id="r_a694f277f3bec0e61b0254d68b61c4a3f"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#a694f277f3bec0e61b0254d68b61c4a3f">_header_size_info</a></td></tr>
<tr class="separator:a694f277f3bec0e61b0254d68b61c4a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f49de29655c78cd4a4126b2090f22b" id="r_ab2f49de29655c78cd4a4126b2090f22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a> = 10000</td></tr>
<tr class="separator:ab2f49de29655c78cd4a4126b2090f22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Binary serialization

NPY format
==========

A simple format for saving numpy arrays to disk with the full
information about them.

The ``.npy`` format is the standard binary file format in NumPy for
persisting a *single* arbitrary NumPy array on disk. The format stores all
of the shape and dtype information necessary to reconstruct the array
correctly even on another machine with a different architecture.
The format is designed to be as simple as possible while achieving
its limited goals.

The ``.npz`` format is the standard format for persisting *multiple* NumPy
arrays on disk. A ``.npz`` file is a zip file containing multiple ``.npy``
files, one for each array.

Capabilities
------------

- Can represent all NumPy arrays including nested record arrays and
  object arrays.

- Represents the data in its native binary form.

- Supports Fortran-contiguous arrays directly.

- Stores all of the necessary information to reconstruct the array
  including shape and dtype on a machine of a different
  architecture.  Both little-endian and big-endian arrays are
  supported, and a file with little-endian numbers will yield
  a little-endian array on any machine reading the file. The
  types are described in terms of their actual sizes. For example,
  if a machine with a 64-bit C "long int" writes out an array with
  "long ints", a reading machine with 32-bit C "long ints" will yield
  an array with 64-bit integers.

- Is straightforward to reverse engineer. Datasets often live longer than
  the programs that created them. A competent developer should be
  able to create a solution in their preferred programming language to
  read most ``.npy`` files that they have been given without much
  documentation.

- Allows memory-mapping of the data. See `open_memmap`.

- Can be read from a filelike stream object instead of an actual file.

- Stores object arrays, i.e. arrays containing elements that are arbitrary
  Python objects. Files with object arrays are not to be mmapable, but
  can be read and written to disk.

Limitations
-----------

- Arbitrary subclasses of numpy.ndarray are not completely preserved.
  Subclasses will be accepted for writing, but only the array data will
  be written out. A regular numpy.ndarray object will be created
  upon reading the file.

.. warning::

  Due to limitations in the interpretation of structured dtypes, dtypes
  with fields with empty names will have the names replaced by 'f0', 'f1',
  etc. Such arrays will not round-trip through the format entirely
  accurately. The data is intact; only the field names will differ. We are
  working on a fix for this. This fix will not require a change in the
  file format. The arrays with such structures can still be saved and
  restored, and the correct dtype may be restored by using the
  ``loadedarray.view(correct_dtype)`` method.

File extensions
---------------

We recommend using the ``.npy`` and ``.npz`` extensions for files saved
in this format. This is by no means a requirement; applications may wish
to use these file formats but use an extension specific to the
application. In the absence of an obvious alternative, however,
we suggest using ``.npy`` and ``.npz``.

Version numbering
-----------------

The version numbering of these formats is independent of NumPy version
numbering. If the format is upgraded, the code in `numpy.io` will still
be able to read and write Version 1.0 files.

Format Version 1.0
------------------

The first 6 bytes are a magic string: exactly ``\\x93NUMPY``.

The next 1 byte is an unsigned byte: the major version number of the file
format, e.g. ``\\x01``.

The next 1 byte is an unsigned byte: the minor version number of the file
format, e.g. ``\\x00``. Note: the version of the file format is not tied
to the version of the numpy package.

The next 2 bytes form a little-endian unsigned short int: the length of
the header data HEADER_LEN.

The next HEADER_LEN bytes form the header data describing the array's
format. It is an ASCII string which contains a Python literal expression
of a dictionary. It is terminated by a newline (``\\n``) and padded with
spaces (``\\x20``) to make the total of
``len(magic string) + 2 + len(length) + HEADER_LEN`` be evenly divisible
by 64 for alignment purposes.

The dictionary contains three keys:

    "descr" : dtype.descr
      An object that can be passed as an argument to the `numpy.dtype`
      constructor to create the array's dtype.
    "fortran_order" : bool
      Whether the array data is Fortran-contiguous or not. Since
      Fortran-contiguous arrays are a common form of non-C-contiguity,
      we allow them to be written directly to disk for efficiency.
    "shape" : tuple of int
      The shape of the array.

For repeatability and readability, the dictionary keys are sorted in
alphabetic order. This is for convenience only. A writer SHOULD implement
this if possible. A reader MUST NOT depend on this.

Following the header comes the array data. If the dtype contains Python
objects (i.e. ``dtype.hasobject is True``), then the data is a Python
pickle of the array. Otherwise the data is the contiguous (either C-
or Fortran-, depending on ``fortran_order``) bytes of the array.
Consumers can figure out the number of bytes by multiplying the number
of elements given by the shape (noting that ``shape=()`` means there is
1 element) by ``dtype.itemsize``.

Format Version 2.0
------------------

The version 1.0 format only allowed the array header to have a total size of
65535 bytes.  This can be exceeded by structured arrays with a large number of
columns.  The version 2.0 format extends the header size to 4 GiB.
`numpy.save` will automatically save in 2.0 format if the data requires it,
else it will always use the more compatible 1.0 format.

The description of the fourth element of the header therefore has become:
"The next 4 bytes form a little-endian unsigned int: the length of the header
data HEADER_LEN."

Format Version 3.0
------------------

This version replaces the ASCII string (which in practice was latin1) with
a utf8-encoded string, so supports structured types with any unicode field
names.

Notes
-----
The ``.npy`` format, including motivation for creating it and a comparison of
alternatives, is described in the
:doc:`"npy-format" NEP &lt;neps:nep-0001-npy-format&gt;`, however details have
evolved with time and this document is more current.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ac0ca853806342a737108256b62a15a12" name="ac0ca853806342a737108256b62a15a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ca853806342a737108256b62a15a12">&#9670;&#160;</a></span>_check_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._check_version </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  196</span><span class="keyword">def </span>_check_version(version):</div>
<div class="line"><span class="lineno">  197</span>    <span class="keywordflow">if</span> version <span class="keywordflow">not</span> <span class="keywordflow">in</span> [(1, 0), (2, 0), (3, 0), <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno">  198</span>        msg = <span class="stringliteral">&quot;we only support format version (1,0), (2,0), and (3,0), not %s&quot;</span></div>
<div class="line"><span class="lineno">  199</span>        <span class="keywordflow">raise</span> ValueError(msg % (version,))</div>
<div class="line"><span class="lineno">  200</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a72800025dff1debc7f20d85c3a984a45" name="a72800025dff1debc7f20d85c3a984a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72800025dff1debc7f20d85c3a984a45">&#9670;&#160;</a></span>_filter_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._filter_header </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Clean up 'L' in npz header ints.

Cleans up the 'L' in strings representing integers. Needed to allow npz
headers produced in Python2 to be read in Python3.

Parameters
----------
s : string
    Npy file header.

Returns
-------
header : str
    Cleaned up header.</pre> <div class="fragment"><div class="line"><span class="lineno">  558</span><span class="keyword">def </span>_filter_header(s):</div>
<div class="line"><span class="lineno">  559</span>    <span class="stringliteral">&quot;&quot;&quot;Clean up &#39;L&#39; in npz header ints.</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    Cleans up the &#39;L&#39; in strings representing integers. Needed to allow npz</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    headers produced in Python2 to be read in Python3.</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    s : string</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        Npy file header.</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    header : str</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        Cleaned up header.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  575</span>    <span class="keyword">import</span> tokenize</div>
<div class="line"><span class="lineno">  576</span>    <span class="keyword">from</span> io <span class="keyword">import</span> StringIO</div>
<div class="line"><span class="lineno">  577</span> </div>
<div class="line"><span class="lineno">  578</span>    tokens = []</div>
<div class="line"><span class="lineno">  579</span>    last_token_was_number = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  580</span>    <span class="keywordflow">for</span> token <span class="keywordflow">in</span> tokenize.generate_tokens(StringIO(s).readline):</div>
<div class="line"><span class="lineno">  581</span>        token_type = token[0]</div>
<div class="line"><span class="lineno">  582</span>        token_string = token[1]</div>
<div class="line"><span class="lineno">  583</span>        <span class="keywordflow">if</span> (last_token_was_number <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  584</span>                token_type == tokenize.NAME <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  585</span>                token_string == <span class="stringliteral">&quot;L&quot;</span>):</div>
<div class="line"><span class="lineno">  586</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  587</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  588</span>            tokens.append(token)</div>
<div class="line"><span class="lineno">  589</span>        last_token_was_number = (token_type == tokenize.NUMBER)</div>
<div class="line"><span class="lineno">  590</span>    <span class="keywordflow">return</span> tokenize.untokenize(tokens)</div>
<div class="line"><span class="lineno">  591</span> </div>
<div class="line"><span class="lineno">  592</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abb6f2566af6989a042d2e35947d6dcbf" name="abb6f2566af6989a042d2e35947d6dcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6f2566af6989a042d2e35947d6dcbf">&#9670;&#160;</a></span>_has_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._has_metadata </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  242</span><span class="keyword">def </span>_has_metadata(dt):</div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordflow">if</span> dt.metadata <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  245</span>    <span class="keywordflow">elif</span> dt.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  246</span>        <span class="keywordflow">return</span> any(_has_metadata(dt[k]) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> dt.names)</div>
<div class="line"><span class="lineno">  247</span>    <span class="keywordflow">elif</span> dt.subdtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  248</span>        <span class="keywordflow">return</span> _has_metadata(dt.base)</div>
<div class="line"><span class="lineno">  249</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  250</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  251</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aacc600cbfefe9e63f9c29ef229fe0e15" name="aacc600cbfefe9e63f9c29ef229fe0e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc600cbfefe9e63f9c29ef229fe0e15">&#9670;&#160;</a></span>_read_array_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._read_array_header </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_header_size</em> = <code><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">see read_array_header_1_0
</pre> <div class="fragment"><div class="line"><span class="lineno">  593</span><span class="keyword">def </span>_read_array_header(fp, version, max_header_size=_MAX_HEADER_SIZE):</div>
<div class="line"><span class="lineno">  594</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    see read_array_header_1_0</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  597</span>    <span class="comment"># Read an unsigned, little-endian short int which has the length of the</span></div>
<div class="line"><span class="lineno">  598</span>    <span class="comment"># header.</span></div>
<div class="line"><span class="lineno">  599</span>    <span class="keyword">import</span> struct</div>
<div class="line"><span class="lineno">  600</span>    hinfo = _header_size_info.get(version)</div>
<div class="line"><span class="lineno">  601</span>    <span class="keywordflow">if</span> hinfo <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  602</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid version {!r}&quot;</span>.format(version))</div>
<div class="line"><span class="lineno">  603</span>    hlength_type, encoding = hinfo</div>
<div class="line"><span class="lineno">  604</span> </div>
<div class="line"><span class="lineno">  605</span>    hlength_str = _read_bytes(fp, struct.calcsize(hlength_type), <span class="stringliteral">&quot;array header length&quot;</span>)</div>
<div class="line"><span class="lineno">  606</span>    header_length = struct.unpack(hlength_type, hlength_str)[0]</div>
<div class="line"><span class="lineno">  607</span>    header = _read_bytes(fp, header_length, <span class="stringliteral">&quot;array header&quot;</span>)</div>
<div class="line"><span class="lineno">  608</span>    header = header.decode(encoding)</div>
<div class="line"><span class="lineno">  609</span>    <span class="keywordflow">if</span> len(header) &gt; max_header_size:</div>
<div class="line"><span class="lineno">  610</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  611</span>            f<span class="stringliteral">&quot;Header info length ({len(header)}) is large and may not be safe &quot;</span></div>
<div class="line"><span class="lineno">  612</span>            <span class="stringliteral">&quot;to load securely.\n&quot;</span></div>
<div class="line"><span class="lineno">  613</span>            <span class="stringliteral">&quot;To allow loading, adjust `max_header_size` or fully trust &quot;</span></div>
<div class="line"><span class="lineno">  614</span>            <span class="stringliteral">&quot;the `.npy` file using `allow_pickle=True`.\n&quot;</span></div>
<div class="line"><span class="lineno">  615</span>            <span class="stringliteral">&quot;For safety against large resource use or crashes, sandboxing &quot;</span></div>
<div class="line"><span class="lineno">  616</span>            <span class="stringliteral">&quot;may be necessary.&quot;</span>)</div>
<div class="line"><span class="lineno">  617</span> </div>
<div class="line"><span class="lineno">  618</span>    <span class="comment"># The header is a pretty-printed string representation of a literal</span></div>
<div class="line"><span class="lineno">  619</span>    <span class="comment"># Python dictionary with trailing newlines padded to a ARRAY_ALIGN byte</span></div>
<div class="line"><span class="lineno">  620</span>    <span class="comment"># boundary. The keys are strings.</span></div>
<div class="line"><span class="lineno">  621</span>    <span class="comment">#   &quot;shape&quot; : tuple of int</span></div>
<div class="line"><span class="lineno">  622</span>    <span class="comment">#   &quot;fortran_order&quot; : bool</span></div>
<div class="line"><span class="lineno">  623</span>    <span class="comment">#   &quot;descr&quot; : dtype.descr</span></div>
<div class="line"><span class="lineno">  624</span>    <span class="comment"># Versions (2, 0) and (1, 0) could have been created by a Python 2</span></div>
<div class="line"><span class="lineno">  625</span>    <span class="comment"># implementation before header filtering was implemented.</span></div>
<div class="line"><span class="lineno">  626</span>    <span class="keywordflow">if</span> version &lt;= (2, 0):</div>
<div class="line"><span class="lineno">  627</span>        header = _filter_header(header)</div>
<div class="line"><span class="lineno">  628</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  629</span>        d = safe_eval(header)</div>
<div class="line"><span class="lineno">  630</span>    <span class="keywordflow">except</span> SyntaxError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  631</span>        msg = <span class="stringliteral">&quot;Cannot parse header: {!r}&quot;</span></div>
<div class="line"><span class="lineno">  632</span>        <span class="keywordflow">raise</span> ValueError(msg.format(header)) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  633</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(d, dict):</div>
<div class="line"><span class="lineno">  634</span>        msg = <span class="stringliteral">&quot;Header is not a dictionary: {!r}&quot;</span></div>
<div class="line"><span class="lineno">  635</span>        <span class="keywordflow">raise</span> ValueError(msg.format(d))</div>
<div class="line"><span class="lineno">  636</span> </div>
<div class="line"><span class="lineno">  637</span>    <span class="keywordflow">if</span> EXPECTED_KEYS != d.keys():</div>
<div class="line"><span class="lineno">  638</span>        keys = sorted(d.keys())</div>
<div class="line"><span class="lineno">  639</span>        msg = <span class="stringliteral">&quot;Header does not contain the correct keys: {!r}&quot;</span></div>
<div class="line"><span class="lineno">  640</span>        <span class="keywordflow">raise</span> ValueError(msg.format(keys))</div>
<div class="line"><span class="lineno">  641</span> </div>
<div class="line"><span class="lineno">  642</span>    <span class="comment"># Sanity-check the values.</span></div>
<div class="line"><span class="lineno">  643</span>    <span class="keywordflow">if</span> (<span class="keywordflow">not</span> isinstance(d[<span class="stringliteral">&#39;shape&#39;</span>], tuple) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  644</span>            <span class="keywordflow">not</span> all(isinstance(x, int) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> d[<span class="stringliteral">&#39;shape&#39;</span>])):</div>
<div class="line"><span class="lineno">  645</span>        msg = <span class="stringliteral">&quot;shape is not valid: {!r}&quot;</span></div>
<div class="line"><span class="lineno">  646</span>        <span class="keywordflow">raise</span> ValueError(msg.format(d[<span class="stringliteral">&#39;shape&#39;</span>]))</div>
<div class="line"><span class="lineno">  647</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(d[<span class="stringliteral">&#39;fortran_order&#39;</span>], bool):</div>
<div class="line"><span class="lineno">  648</span>        msg = <span class="stringliteral">&quot;fortran_order is not a valid bool: {!r}&quot;</span></div>
<div class="line"><span class="lineno">  649</span>        <span class="keywordflow">raise</span> ValueError(msg.format(d[<span class="stringliteral">&#39;fortran_order&#39;</span>]))</div>
<div class="line"><span class="lineno">  650</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  651</span>        dtype = descr_to_dtype(d[<span class="stringliteral">&#39;descr&#39;</span>])</div>
<div class="line"><span class="lineno">  652</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  653</span>        msg = <span class="stringliteral">&quot;descr is not a valid dtype descriptor: {!r}&quot;</span></div>
<div class="line"><span class="lineno">  654</span>        <span class="keywordflow">raise</span> ValueError(msg.format(d[<span class="stringliteral">&#39;descr&#39;</span>])) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span>    <span class="keywordflow">return</span> d[<span class="stringliteral">&#39;shape&#39;</span>], d[<span class="stringliteral">&#39;fortran_order&#39;</span>], dtype</div>
<div class="line"><span class="lineno">  657</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac937ddc972a32e45e37661a12b5c7caa" name="ac937ddc972a32e45e37661a12b5c7caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac937ddc972a32e45e37661a12b5c7caa">&#9670;&#160;</a></span>_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._read_bytes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_template</em> = <code>&quot;ran&#160;out&#160;of&#160;data&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Read from file-like object until size bytes are read.
Raises ValueError if not EOF is encountered before size bytes are read.
Non-blocking objects only supported if they derive from io objects.

Required as e.g. ZipExtFile in python 2.6 can return less data than
requested.
</pre> <div class="fragment"><div class="line"><span class="lineno">  943</span><span class="keyword">def </span>_read_bytes(fp, size, error_template=&quot;ran out of data&quot;):</div>
<div class="line"><span class="lineno">  944</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    Read from file-like object until size bytes are read.</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">    Raises ValueError if not EOF is encountered before size bytes are read.</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    Non-blocking objects only supported if they derive from io objects.</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">    Required as e.g. ZipExtFile in python 2.6 can return less data than</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    requested.</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  952</span>    data = bytes()</div>
<div class="line"><span class="lineno">  953</span>    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  954</span>        <span class="comment"># io files (default in python3) return None or raise on</span></div>
<div class="line"><span class="lineno">  955</span>        <span class="comment"># would-block, python2 file will truncate, probably nothing can be</span></div>
<div class="line"><span class="lineno">  956</span>        <span class="comment"># done about that.  note that regular files can&#39;t be non-blocking</span></div>
<div class="line"><span class="lineno">  957</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  958</span>            r = fp.read(size - len(data))</div>
<div class="line"><span class="lineno">  959</span>            data += r</div>
<div class="line"><span class="lineno">  960</span>            <span class="keywordflow">if</span> len(r) == 0 <span class="keywordflow">or</span> len(data) == size:</div>
<div class="line"><span class="lineno">  961</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  962</span>        <span class="keywordflow">except</span> BlockingIOError:</div>
<div class="line"><span class="lineno">  963</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  964</span>    <span class="keywordflow">if</span> len(data) != size:</div>
<div class="line"><span class="lineno">  965</span>        msg = <span class="stringliteral">&quot;EOF: reading %s, expected %d bytes got %d&quot;</span></div>
<div class="line"><span class="lineno">  966</span>        <span class="keywordflow">raise</span> ValueError(msg % (error_template, size, len(data)))</div>
<div class="line"><span class="lineno">  967</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  968</span>        <span class="keywordflow">return</span> data</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d5743b8903a9aefd1b78f85ae56b6fd" name="a4d5743b8903a9aefd1b78f85ae56b6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5743b8903a9aefd1b78f85ae56b6fd">&#9670;&#160;</a></span>_wrap_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._wrap_header </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Takes a stringified header, and attaches the prefix and padding to it
</pre> <div class="fragment"><div class="line"><span class="lineno">  372</span><span class="keyword">def </span>_wrap_header(header, version):</div>
<div class="line"><span class="lineno">  373</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    Takes a stringified header, and attaches the prefix and padding to it</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="keyword">import</span> struct</div>
<div class="line"><span class="lineno">  377</span>    <span class="keyword">assert</span> version <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  378</span>    fmt, encoding = _header_size_info[version]</div>
<div class="line"><span class="lineno">  379</span>    header = header.encode(encoding)</div>
<div class="line"><span class="lineno">  380</span>    hlen = len(header) + 1</div>
<div class="line"><span class="lineno">  381</span>    padlen = ARRAY_ALIGN - ((MAGIC_LEN + struct.calcsize(fmt) + hlen) % ARRAY_ALIGN)</div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  383</span>        header_prefix = magic(*version) + struct.pack(fmt, hlen + padlen)</div>
<div class="line"><span class="lineno">  384</span>    <span class="keywordflow">except</span> struct.error:</div>
<div class="line"><span class="lineno">  385</span>        msg = <span class="stringliteral">&quot;Header length {} too big for version={}&quot;</span>.format(hlen, version)</div>
<div class="line"><span class="lineno">  386</span>        <span class="keywordflow">raise</span> ValueError(msg) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span>    <span class="comment"># Pad the header with spaces and a final newline such that the magic</span></div>
<div class="line"><span class="lineno">  389</span>    <span class="comment"># string, the header-length short and the header are aligned on a</span></div>
<div class="line"><span class="lineno">  390</span>    <span class="comment"># ARRAY_ALIGN byte boundary.  This supports memory mapping of dtypes</span></div>
<div class="line"><span class="lineno">  391</span>    <span class="comment"># aligned up to ARRAY_ALIGN on systems like Linux where mmap()</span></div>
<div class="line"><span class="lineno">  392</span>    <span class="comment"># offset must be page-aligned (i.e. the beginning of the file).</span></div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">return</span> header_prefix + header + b<span class="stringliteral">&#39; &#39;</span>*padlen + b<span class="stringliteral">&#39;\n&#39;</span></div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae40bbbde1a48400720b5a24350ce8d31" name="ae40bbbde1a48400720b5a24350ce8d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40bbbde1a48400720b5a24350ce8d31">&#9670;&#160;</a></span>_wrap_header_guess_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._wrap_header_guess_version </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Like `_wrap_header`, but chooses an appropriate version given the contents
</pre> <div class="fragment"><div class="line"><span class="lineno">  396</span><span class="keyword">def </span>_wrap_header_guess_version(header):</div>
<div class="line"><span class="lineno">  397</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    Like `_wrap_header`, but chooses an appropriate version given the contents</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  400</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  401</span>        <span class="keywordflow">return</span> _wrap_header(header, (1, 0))</div>
<div class="line"><span class="lineno">  402</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  403</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  406</span>        ret = _wrap_header(header, (2, 0))</div>
<div class="line"><span class="lineno">  407</span>    <span class="keywordflow">except</span> UnicodeEncodeError:</div>
<div class="line"><span class="lineno">  408</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  410</span>        warnings.warn(<span class="stringliteral">&quot;Stored array in format 2.0. It can only be&quot;</span></div>
<div class="line"><span class="lineno">  411</span>                      <span class="stringliteral">&quot;read by NumPy &gt;= 1.9&quot;</span>, UserWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  412</span>        <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>    header = _wrap_header(header, (3, 0))</div>
<div class="line"><span class="lineno">  415</span>    warnings.warn(<span class="stringliteral">&quot;Stored array in format 3.0. It can only be &quot;</span></div>
<div class="line"><span class="lineno">  416</span>                  <span class="stringliteral">&quot;read by NumPy &gt;= 1.17&quot;</span>, UserWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">return</span> header</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6ccbfcb3ac4d734bbaee3e27b92ebb5" name="ac6ccbfcb3ac4d734bbaee3e27b92ebb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ccbfcb3ac4d734bbaee3e27b92ebb5">&#9670;&#160;</a></span>_write_array_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format._write_array_header </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>version</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Write the header for an array and returns the version used

Parameters
----------
fp : filelike object
d : dict
    This has the appropriate entries for writing its string representation
    to the header of the file.
version : tuple or None
    None means use oldest that works. Providing an explicit version will
    raise a ValueError if the format does not allow saving this data.
    Default: None
</pre> <div class="fragment"><div class="line"><span class="lineno">  420</span><span class="keyword">def </span>_write_array_header(fp, d, version=None):</div>
<div class="line"><span class="lineno">  421</span>    <span class="stringliteral">&quot;&quot;&quot; Write the header for an array and returns the version used</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    fp : filelike object</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    d : dict</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">        This has the appropriate entries for writing its string representation</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">        to the header of the file.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    version : tuple or None</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        None means use oldest that works. Providing an explicit version will</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        raise a ValueError if the format does not allow saving this data.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        Default: None</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  434</span>    header = [<span class="stringliteral">&quot;{&quot;</span>]</div>
<div class="line"><span class="lineno">  435</span>    <span class="keywordflow">for</span> key, value <span class="keywordflow">in</span> sorted(d.items()):</div>
<div class="line"><span class="lineno">  436</span>        <span class="comment"># Need to use repr here, since we eval these when reading</span></div>
<div class="line"><span class="lineno">  437</span>        header.append(<span class="stringliteral">&quot;&#39;%s&#39;: %s, &quot;</span> % (key, repr(value)))</div>
<div class="line"><span class="lineno">  438</span>    header.append(<span class="stringliteral">&quot;}&quot;</span>)</div>
<div class="line"><span class="lineno">  439</span>    header = <span class="stringliteral">&quot;&quot;</span>.join(header)</div>
<div class="line"><span class="lineno">  440</span>    </div>
<div class="line"><span class="lineno">  441</span>    <span class="comment"># Add some spare space so that the array header can be modified in-place</span></div>
<div class="line"><span class="lineno">  442</span>    <span class="comment"># when changing the array size, e.g. when growing it by appending data at</span></div>
<div class="line"><span class="lineno">  443</span>    <span class="comment"># the end. </span></div>
<div class="line"><span class="lineno">  444</span>    shape = d[<span class="stringliteral">&#39;shape&#39;</span>]</div>
<div class="line"><span class="lineno">  445</span>    header += <span class="stringliteral">&quot; &quot;</span> * ((GROWTH_AXIS_MAX_DIGITS - len(repr(</div>
<div class="line"><span class="lineno">  446</span>        shape[-1 <span class="keywordflow">if</span> d[<span class="stringliteral">&#39;fortran_order&#39;</span>] <span class="keywordflow">else</span> 0]</div>
<div class="line"><span class="lineno">  447</span>    ))) <span class="keywordflow">if</span> len(shape) &gt; 0 <span class="keywordflow">else</span> 0)</div>
<div class="line"><span class="lineno">  448</span>    </div>
<div class="line"><span class="lineno">  449</span>    <span class="keywordflow">if</span> version <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  450</span>        header = _wrap_header_guess_version(header)</div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  452</span>        header = _wrap_header(header, version)</div>
<div class="line"><span class="lineno">  453</span>    fp.write(header)</div>
<div class="line"><span class="lineno">  454</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7394dd4b07c00d459974f9062ce524a7" name="a7394dd4b07c00d459974f9062ce524a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7394dd4b07c00d459974f9062ce524a7">&#9670;&#160;</a></span>descr_to_dtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.descr_to_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a dtype based off the given description.

This is essentially the reverse of `dtype_to_descr()`. It will remove
the valueless padding fields created by, i.e. simple fields like
dtype('float32'), and then convert the description to its corresponding
dtype.

Parameters
----------
descr : object
    The object retrieved by dtype.descr. Can be passed to
    `numpy.dtype()` in order to replicate the input dtype.

Returns
-------
dtype : dtype
    The dtype constructed by the description.</pre> <div class="fragment"><div class="line"><span class="lineno">  288</span><span class="keyword">def </span>descr_to_dtype(descr):</div>
<div class="line"><span class="lineno">  289</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    Returns a dtype based off the given description.</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    This is essentially the reverse of `dtype_to_descr()`. It will remove</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    the valueless padding fields created by, i.e. simple fields like</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    dtype(&#39;float32&#39;), and then convert the description to its corresponding</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    dtype.</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    descr : object</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        The object retrieved by dtype.descr. Can be passed to</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        `numpy.dtype()` in order to replicate the input dtype.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    dtype : dtype</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">        The dtype constructed by the description.</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  309</span>    <span class="keywordflow">if</span> isinstance(descr, str):</div>
<div class="line"><span class="lineno">  310</span>        <span class="comment"># No padding removal needed</span></div>
<div class="line"><span class="lineno">  311</span>        <span class="keywordflow">return</span> numpy.dtype(descr)</div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">elif</span> isinstance(descr, tuple):</div>
<div class="line"><span class="lineno">  313</span>        <span class="comment"># subtype, will always have a shape descr[1]</span></div>
<div class="line"><span class="lineno">  314</span>        dt = descr_to_dtype(descr[0])</div>
<div class="line"><span class="lineno">  315</span>        <span class="keywordflow">return</span> numpy.dtype((dt, descr[1]))</div>
<div class="line"><span class="lineno">  316</span> </div>
<div class="line"><span class="lineno">  317</span>    titles = []</div>
<div class="line"><span class="lineno">  318</span>    names = []</div>
<div class="line"><span class="lineno">  319</span>    formats = []</div>
<div class="line"><span class="lineno">  320</span>    offsets = []</div>
<div class="line"><span class="lineno">  321</span>    offset = 0</div>
<div class="line"><span class="lineno">  322</span>    <span class="keywordflow">for</span> field <span class="keywordflow">in</span> descr:</div>
<div class="line"><span class="lineno">  323</span>        <span class="keywordflow">if</span> len(field) == 2:</div>
<div class="line"><span class="lineno">  324</span>            name, descr_str = field</div>
<div class="line"><span class="lineno">  325</span>            dt = descr_to_dtype(descr_str)</div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  327</span>            name, descr_str, shape = field</div>
<div class="line"><span class="lineno">  328</span>            dt = numpy.dtype((descr_to_dtype(descr_str), shape))</div>
<div class="line"><span class="lineno">  329</span> </div>
<div class="line"><span class="lineno">  330</span>        <span class="comment"># Ignore padding bytes, which will be void bytes with &#39;&#39; as name</span></div>
<div class="line"><span class="lineno">  331</span>        <span class="comment"># Once support for blank names is removed, only &quot;if name == &#39;&#39;&quot; needed)</span></div>
<div class="line"><span class="lineno">  332</span>        is_pad = (name == <span class="stringliteral">&#39;&#39;</span> <span class="keywordflow">and</span> dt.type <span class="keywordflow">is</span> numpy.void <span class="keywordflow">and</span> dt.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  333</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_pad:</div>
<div class="line"><span class="lineno">  334</span>            title, name = name <span class="keywordflow">if</span> isinstance(name, tuple) <span class="keywordflow">else</span> (<span class="keywordtype">None</span>, name)</div>
<div class="line"><span class="lineno">  335</span>            titles.append(title)</div>
<div class="line"><span class="lineno">  336</span>            names.append(name)</div>
<div class="line"><span class="lineno">  337</span>            formats.append(dt)</div>
<div class="line"><span class="lineno">  338</span>            offsets.append(offset)</div>
<div class="line"><span class="lineno">  339</span>        offset += dt.itemsize</div>
<div class="line"><span class="lineno">  340</span> </div>
<div class="line"><span class="lineno">  341</span>    <span class="keywordflow">return</span> numpy.dtype({<span class="stringliteral">&#39;names&#39;</span>: names, <span class="stringliteral">&#39;formats&#39;</span>: formats, <span class="stringliteral">&#39;titles&#39;</span>: titles,</div>
<div class="line"><span class="lineno">  342</span>                        <span class="stringliteral">&#39;offsets&#39;</span>: offsets, <span class="stringliteral">&#39;itemsize&#39;</span>: offset})</div>
<div class="line"><span class="lineno">  343</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a77421712330dbc063b7fbc3e62900fc4" name="a77421712330dbc063b7fbc3e62900fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77421712330dbc063b7fbc3e62900fc4">&#9670;&#160;</a></span>dtype_to_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.dtype_to_descr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get a serializable descriptor from the dtype.

The .descr attribute of a dtype object cannot be round-tripped through
the dtype() constructor. Simple types, like dtype('float32'), have
a descr which looks like a record array with one field with '' as
a name. The dtype() constructor interprets this as a request to give
a default name.  Instead, we construct descriptor that can be passed to
dtype().

Parameters
----------
dtype : dtype
    The dtype of the array that will be written to disk.

Returns
-------
descr : object
    An object that can be passed to `numpy.dtype()` in order to
    replicate the input dtype.</pre> <div class="fragment"><div class="line"><span class="lineno">  252</span><span class="keyword">def </span>dtype_to_descr(dtype):</div>
<div class="line"><span class="lineno">  253</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    Get a serializable descriptor from the dtype.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    The .descr attribute of a dtype object cannot be round-tripped through</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    the dtype() constructor. Simple types, like dtype(&#39;float32&#39;), have</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    a descr which looks like a record array with one field with &#39;&#39; as</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    a name. The dtype() constructor interprets this as a request to give</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    a default name.  Instead, we construct descriptor that can be passed to</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    dtype().</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    dtype : dtype</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">        The dtype of the array that will be written to disk.</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    descr : object</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        An object that can be passed to `numpy.dtype()` in order to</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        replicate the input dtype.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  275</span>    <span class="keywordflow">if</span> _has_metadata(dtype):</div>
<div class="line"><span class="lineno">  276</span>        warnings.warn(<span class="stringliteral">&quot;metadata on a dtype may be saved or ignored, but will &quot;</span></div>
<div class="line"><span class="lineno">  277</span>                      <span class="stringliteral">&quot;raise if saved when read. Use another form of storage.&quot;</span>,</div>
<div class="line"><span class="lineno">  278</span>                      UserWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  279</span>    <span class="keywordflow">if</span> dtype.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  280</span>        <span class="comment"># This is a record array. The .descr is fine.  XXX: parts of the</span></div>
<div class="line"><span class="lineno">  281</span>        <span class="comment"># record array with an empty name, like padding bytes, still get</span></div>
<div class="line"><span class="lineno">  282</span>        <span class="comment"># fiddled with. This needs to be fixed in the C implementation of</span></div>
<div class="line"><span class="lineno">  283</span>        <span class="comment"># dtype().</span></div>
<div class="line"><span class="lineno">  284</span>        <span class="keywordflow">return</span> dtype.descr</div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  286</span>        <span class="keywordflow">return</span> dtype.str</div>
<div class="line"><span class="lineno">  287</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f682f7260515fee7dfca0a2c47363dc" name="a5f682f7260515fee7dfca0a2c47363dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f682f7260515fee7dfca0a2c47363dc">&#9670;&#160;</a></span>header_data_from_array_1_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.header_data_from_array_1_0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Get the dictionary of header metadata from a numpy.ndarray.

Parameters
----------
array : numpy.ndarray

Returns
-------
d : dict
    This has the appropriate entries for writing its string representation
    to the header of the file.
</pre> <div class="fragment"><div class="line"><span class="lineno">  344</span><span class="keyword">def </span>header_data_from_array_1_0(array):</div>
<div class="line"><span class="lineno">  345</span>    <span class="stringliteral">&quot;&quot;&quot; Get the dictionary of header metadata from a numpy.ndarray.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    array : numpy.ndarray</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    d : dict</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">        This has the appropriate entries for writing its string representation</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        to the header of the file.</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  357</span>    d = {<span class="stringliteral">&#39;shape&#39;</span>: array.shape}</div>
<div class="line"><span class="lineno">  358</span>    <span class="keywordflow">if</span> array.flags.c_contiguous:</div>
<div class="line"><span class="lineno">  359</span>        d[<span class="stringliteral">&#39;fortran_order&#39;</span>] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  360</span>    <span class="keywordflow">elif</span> array.flags.f_contiguous:</div>
<div class="line"><span class="lineno">  361</span>        d[<span class="stringliteral">&#39;fortran_order&#39;</span>] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  362</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  363</span>        <span class="comment"># Totally non-contiguous data. We will have to make it C-contiguous</span></div>
<div class="line"><span class="lineno">  364</span>        <span class="comment"># before writing. Note that we need to test for C_CONTIGUOUS first</span></div>
<div class="line"><span class="lineno">  365</span>        <span class="comment"># because a 1-D array is both C_CONTIGUOUS and F_CONTIGUOUS.</span></div>
<div class="line"><span class="lineno">  366</span>        d[<span class="stringliteral">&#39;fortran_order&#39;</span>] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  367</span> </div>
<div class="line"><span class="lineno">  368</span>    d[<span class="stringliteral">&#39;descr&#39;</span>] = dtype_to_descr(array.dtype)</div>
<div class="line"><span class="lineno">  369</span>    <span class="keywordflow">return</span> d</div>
<div class="line"><span class="lineno">  370</span> </div>
<div class="line"><span class="lineno">  371</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a13663fe6f8d9b52354f3fad05dfd37c6" name="a13663fe6f8d9b52354f3fad05dfd37c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13663fe6f8d9b52354f3fad05dfd37c6">&#9670;&#160;</a></span>magic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.magic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the magic string for the given file format version.

Parameters
----------
major : int in [0, 255]
minor : int in [0, 255]

Returns
-------
magic : str

Raises
------
ValueError if the version cannot be formatted.
</pre> <div class="fragment"><div class="line"><span class="lineno">  201</span><span class="keyword">def </span>magic(major, minor):</div>
<div class="line"><span class="lineno">  202</span>    <span class="stringliteral">&quot;&quot;&quot; Return the magic string for the given file format version.</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    major : int in [0, 255]</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    minor : int in [0, 255]</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    magic : str</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    ValueError if the version cannot be formatted.</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  217</span>    <span class="keywordflow">if</span> major &lt; 0 <span class="keywordflow">or</span> major &gt; 255:</div>
<div class="line"><span class="lineno">  218</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;major version must be 0 &lt;= major &lt; 256&quot;</span>)</div>
<div class="line"><span class="lineno">  219</span>    <span class="keywordflow">if</span> minor &lt; 0 <span class="keywordflow">or</span> minor &gt; 255:</div>
<div class="line"><span class="lineno">  220</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;minor version must be 0 &lt;= minor &lt; 256&quot;</span>)</div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">return</span> MAGIC_PREFIX + bytes([major, minor])</div>
<div class="line"><span class="lineno">  222</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0e30ad134d4c644b702a4335e7371a6" name="ab0e30ad134d4c644b702a4335e7371a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e30ad134d4c644b702a4335e7371a6">&#9670;&#160;</a></span>open_memmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.open_memmap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'<a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>+'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fortran_order</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>version</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>max_header_size</em> = <code><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Open a .npy file as a memory-mapped array.

This may be used to read an existing file or create a new one.

Parameters
----------
filename : str or path-like
    The name of the file on disk.  This may *not* be a file-like
    object.
mode : str, optional
    The mode in which to open the file; the default is 'r+'.  In
    addition to the standard file modes, 'c' is also accepted to mean
    "copy on write."  See `memmap` for the available mode strings.
dtype : data-type, optional
    The data type of the array if we are creating a new file in "write"
    mode, if not, `dtype` is ignored.  The default value is None, which
    results in a data-type of `float64`.
shape : tuple of int
    The shape of the array if we are creating a new file in "write"
    mode, in which case this parameter is required.  Otherwise, this
    parameter is ignored and is thus optional.
fortran_order : bool, optional
    Whether the array should be Fortran-contiguous (True) or
    C-contiguous (False, the default) if we are creating a new file in
    "write" mode.
version : tuple of int (major, minor) or None
    If the mode is a "write" mode, then this is the version of the file
    format used to create the file.  None means use the oldest
    supported version that is able to store the data.  Default: None
max_header_size : int, optional
    Maximum allowed size of the header.  Large headers may not be safe
    to load securely and thus require explicitly passing a larger value.
    See :py:meth:`ast.literal_eval()` for details.

Returns
-------
marray : memmap
    The memory-mapped array.

Raises
------
ValueError
    If the data or the mode is invalid.
OSError
    If the file is not found or cannot be opened correctly.

See Also
--------
numpy.memmap</pre> <div class="fragment"><div class="line"><span class="lineno">  838</span>                max_header_size=_MAX_HEADER_SIZE):</div>
<div class="line"><span class="lineno">  839</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    Open a .npy file as a memory-mapped array.</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    This may be used to read an existing file or create a new one.</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    filename : str or path-like</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        The name of the file on disk.  This may *not* be a file-like</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">        object.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    mode : str, optional</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">        The mode in which to open the file; the default is &#39;r+&#39;.  In</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">        addition to the standard file modes, &#39;c&#39; is also accepted to mean</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">        &quot;copy on write.&quot;  See `memmap` for the available mode strings.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">        The data type of the array if we are creating a new file in &quot;write&quot;</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">        mode, if not, `dtype` is ignored.  The default value is None, which</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">        results in a data-type of `float64`.</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    shape : tuple of int</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">        The shape of the array if we are creating a new file in &quot;write&quot;</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">        mode, in which case this parameter is required.  Otherwise, this</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">        parameter is ignored and is thus optional.</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    fortran_order : bool, optional</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">        Whether the array should be Fortran-contiguous (True) or</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">        C-contiguous (False, the default) if we are creating a new file in</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">        &quot;write&quot; mode.</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    version : tuple of int (major, minor) or None</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">        If the mode is a &quot;write&quot; mode, then this is the version of the file</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">        format used to create the file.  None means use the oldest</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">        supported version that is able to store the data.  Default: None</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    max_header_size : int, optional</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">        Maximum allowed size of the header.  Large headers may not be safe</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">        to load securely and thus require explicitly passing a larger value.</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">        See :py:meth:`ast.literal_eval()` for details.</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    marray : memmap</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">        The memory-mapped array.</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        If the data or the mode is invalid.</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    OSError</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">        If the file is not found or cannot be opened correctly.</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    numpy.memmap</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  891</span>    <span class="keywordflow">if</span> isfileobj(filename):</div>
<div class="line"><span class="lineno">  892</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Filename must be a string or a path-like object.&quot;</span></div>
<div class="line"><span class="lineno">  893</span>                         <span class="stringliteral">&quot;  Memmap cannot use existing file handles.&quot;</span>)</div>
<div class="line"><span class="lineno">  894</span> </div>
<div class="line"><span class="lineno">  895</span>    <span class="keywordflow">if</span> <span class="stringliteral">&#39;w&#39;</span> <span class="keywordflow">in</span> mode:</div>
<div class="line"><span class="lineno">  896</span>        <span class="comment"># We are creating the file, not reading it.</span></div>
<div class="line"><span class="lineno">  897</span>        <span class="comment"># Check if we ought to create the file.</span></div>
<div class="line"><span class="lineno">  898</span>        _check_version(version)</div>
<div class="line"><span class="lineno">  899</span>        <span class="comment"># Ensure that the given dtype is an authentic dtype object rather</span></div>
<div class="line"><span class="lineno">  900</span>        <span class="comment"># than just something that can be interpreted as a dtype object.</span></div>
<div class="line"><span class="lineno">  901</span>        dtype = numpy.dtype(dtype)</div>
<div class="line"><span class="lineno">  902</span>        <span class="keywordflow">if</span> dtype.hasobject:</div>
<div class="line"><span class="lineno">  903</span>            msg = <span class="stringliteral">&quot;Array can&#39;t be memory-mapped: Python objects in dtype.&quot;</span></div>
<div class="line"><span class="lineno">  904</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  905</span>        d = dict(</div>
<div class="line"><span class="lineno">  906</span>            descr=dtype_to_descr(dtype),</div>
<div class="line"><span class="lineno">  907</span>            fortran_order=fortran_order,</div>
<div class="line"><span class="lineno">  908</span>            shape=shape,</div>
<div class="line"><span class="lineno">  909</span>        )</div>
<div class="line"><span class="lineno">  910</span>        <span class="comment"># If we got here, then it should be safe to create the file.</span></div>
<div class="line"><span class="lineno">  911</span>        <span class="keyword">with</span> open(os_fspath(filename), mode+<span class="stringliteral">&#39;b&#39;</span>) <span class="keyword">as</span> fp:</div>
<div class="line"><span class="lineno">  912</span>            _write_array_header(fp, d, version)</div>
<div class="line"><span class="lineno">  913</span>            offset = fp.tell()</div>
<div class="line"><span class="lineno">  914</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  915</span>        <span class="comment"># Read the header of the file first.</span></div>
<div class="line"><span class="lineno">  916</span>        <span class="keyword">with</span> open(os_fspath(filename), <span class="stringliteral">&#39;rb&#39;</span>) <span class="keyword">as</span> fp:</div>
<div class="line"><span class="lineno">  917</span>            version = read_magic(fp)</div>
<div class="line"><span class="lineno">  918</span>            _check_version(version)</div>
<div class="line"><span class="lineno">  919</span> </div>
<div class="line"><span class="lineno">  920</span>            shape, fortran_order, dtype = _read_array_header(</div>
<div class="line"><span class="lineno">  921</span>                    fp, version, max_header_size=max_header_size)</div>
<div class="line"><span class="lineno">  922</span>            <span class="keywordflow">if</span> dtype.hasobject:</div>
<div class="line"><span class="lineno">  923</span>                msg = <span class="stringliteral">&quot;Array can&#39;t be memory-mapped: Python objects in dtype.&quot;</span></div>
<div class="line"><span class="lineno">  924</span>                <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  925</span>            offset = fp.tell()</div>
<div class="line"><span class="lineno">  926</span> </div>
<div class="line"><span class="lineno">  927</span>    <span class="keywordflow">if</span> fortran_order:</div>
<div class="line"><span class="lineno">  928</span>        order = <span class="stringliteral">&#39;F&#39;</span></div>
<div class="line"><span class="lineno">  929</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  930</span>        order = <span class="stringliteral">&#39;C&#39;</span></div>
<div class="line"><span class="lineno">  931</span> </div>
<div class="line"><span class="lineno">  932</span>    <span class="comment"># We need to change a write-only mode to a read-write mode since we&#39;ve</span></div>
<div class="line"><span class="lineno">  933</span>    <span class="comment"># already written data to the file.</span></div>
<div class="line"><span class="lineno">  934</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;w+&#39;</span>:</div>
<div class="line"><span class="lineno">  935</span>        mode = <span class="stringliteral">&#39;r+&#39;</span></div>
<div class="line"><span class="lineno">  936</span> </div>
<div class="line"><span class="lineno">  937</span>    marray = <a class="code hl_class" href="classnumpy_1_1core_1_1memmap_1_1memmap.html">numpy.memmap</a>(filename, dtype=dtype, shape=shape, order=order,</div>
<div class="line"><span class="lineno">  938</span>        mode=mode, offset=offset)</div>
<div class="line"><span class="lineno">  939</span> </div>
<div class="line"><span class="lineno">  940</span>    <span class="keywordflow">return</span> marray</div>
<div class="line"><span class="lineno">  941</span> </div>
<div class="line"><span class="lineno">  942</span> </div>
<div class="ttc" id="aclassnumpy_1_1core_1_1memmap_1_1memmap_html"><div class="ttname"><a href="classnumpy_1_1core_1_1memmap_1_1memmap.html">numpy.core.memmap.memmap</a></div><div class="ttdef"><b>Definition</b> memmap.py:23</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a95bf04af902c69065e0642a4ecf04765" name="a95bf04af902c69065e0642a4ecf04765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bf04af902c69065e0642a4ecf04765">&#9670;&#160;</a></span>read_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.read_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_pickle</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pickle_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>max_header_size</em> = <code><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read an array from an NPY file.

Parameters
----------
fp : file_like object
    If this is not a real file object, then this may take extra memory
    and time.
allow_pickle : bool, optional
    Whether to allow writing pickled data. Default: False

    .. versionchanged:: 1.16.3
        Made default False in response to CVE-2019-6446.

pickle_kwargs : dict
    Additional keyword arguments to pass to pickle.load. These are only
    useful when loading object arrays saved on Python 2 when using
    Python 3.
max_header_size : int, optional
    Maximum allowed size of the header.  Large headers may not be safe
    to load securely and thus require explicitly passing a larger value.
    See :py:meth:`ast.literal_eval()` for details.
    This option is ignored when `allow_pickle` is passed.  In that case
    the file is by definition trusted and the limit is unnecessary.

Returns
-------
array : ndarray
    The array from the data on disk.

Raises
------
ValueError
    If the data is invalid, or allow_pickle=False and the file contains
    an object array.</pre> <div class="fragment"><div class="line"><span class="lineno">  731</span>               max_header_size=_MAX_HEADER_SIZE):</div>
<div class="line"><span class="lineno">  732</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    Read an array from an NPY file.</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    fp : file_like object</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">        If this is not a real file object, then this may take extra memory</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        and time.</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    allow_pickle : bool, optional</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">        Whether to allow writing pickled data. Default: False</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        .. versionchanged:: 1.16.3</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">            Made default False in response to CVE-2019-6446.</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    pickle_kwargs : dict</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        Additional keyword arguments to pass to pickle.load. These are only</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        useful when loading object arrays saved on Python 2 when using</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        Python 3.</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    max_header_size : int, optional</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        Maximum allowed size of the header.  Large headers may not be safe</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        to load securely and thus require explicitly passing a larger value.</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        See :py:meth:`ast.literal_eval()` for details.</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        This option is ignored when `allow_pickle` is passed.  In that case</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        the file is by definition trusted and the limit is unnecessary.</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    array : ndarray</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        The array from the data on disk.</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        If the data is invalid, or allow_pickle=False and the file contains</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        an object array.</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  769</span>    <span class="keywordflow">if</span> allow_pickle:</div>
<div class="line"><span class="lineno">  770</span>        <span class="comment"># Effectively ignore max_header_size, since `allow_pickle` indicates</span></div>
<div class="line"><span class="lineno">  771</span>        <span class="comment"># that the input is fully trusted.</span></div>
<div class="line"><span class="lineno">  772</span>        max_header_size = 2**64</div>
<div class="line"><span class="lineno">  773</span> </div>
<div class="line"><span class="lineno">  774</span>    version = read_magic(fp)</div>
<div class="line"><span class="lineno">  775</span>    _check_version(version)</div>
<div class="line"><span class="lineno">  776</span>    shape, fortran_order, dtype = _read_array_header(</div>
<div class="line"><span class="lineno">  777</span>            fp, version, max_header_size=max_header_size)</div>
<div class="line"><span class="lineno">  778</span>    <span class="keywordflow">if</span> len(shape) == 0:</div>
<div class="line"><span class="lineno">  779</span>        count = 1</div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  781</span>        count = numpy.multiply.reduce(shape, dtype=numpy.int64)</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>    <span class="comment"># Now read the actual data.</span></div>
<div class="line"><span class="lineno">  784</span>    <span class="keywordflow">if</span> dtype.hasobject:</div>
<div class="line"><span class="lineno">  785</span>        <span class="comment"># The array contained Python objects. We need to unpickle the data.</span></div>
<div class="line"><span class="lineno">  786</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> allow_pickle:</div>
<div class="line"><span class="lineno">  787</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Object arrays cannot be loaded when &quot;</span></div>
<div class="line"><span class="lineno">  788</span>                             <span class="stringliteral">&quot;allow_pickle=False&quot;</span>)</div>
<div class="line"><span class="lineno">  789</span>        <span class="keywordflow">if</span> pickle_kwargs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  790</span>            pickle_kwargs = {}</div>
<div class="line"><span class="lineno">  791</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  792</span>            array = pickle.load(fp, **pickle_kwargs)</div>
<div class="line"><span class="lineno">  793</span>        <span class="keywordflow">except</span> UnicodeError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  794</span>            <span class="comment"># Friendlier error message</span></div>
<div class="line"><span class="lineno">  795</span>            <span class="keywordflow">raise</span> UnicodeError(<span class="stringliteral">&quot;Unpickling a python object failed: %r\n&quot;</span></div>
<div class="line"><span class="lineno">  796</span>                               <span class="stringliteral">&quot;You may need to pass the encoding= option &quot;</span></div>
<div class="line"><span class="lineno">  797</span>                               <span class="stringliteral">&quot;to numpy.load&quot;</span> % (err,)) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  798</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  799</span>        <span class="keywordflow">if</span> isfileobj(fp):</div>
<div class="line"><span class="lineno">  800</span>            <span class="comment"># We can use the fast fromfile() function.</span></div>
<div class="line"><span class="lineno">  801</span>            array = numpy.fromfile(fp, dtype=dtype, count=count)</div>
<div class="line"><span class="lineno">  802</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  803</span>            <span class="comment"># This is not a real file. We have to read it the</span></div>
<div class="line"><span class="lineno">  804</span>            <span class="comment"># memory-intensive way.</span></div>
<div class="line"><span class="lineno">  805</span>            <span class="comment"># crc32 module fails on reads greater than 2 ** 32 bytes,</span></div>
<div class="line"><span class="lineno">  806</span>            <span class="comment"># breaking large reads from gzip streams. Chunk reads to</span></div>
<div class="line"><span class="lineno">  807</span>            <span class="comment"># BUFFER_SIZE bytes to avoid issue and reduce memory overhead</span></div>
<div class="line"><span class="lineno">  808</span>            <span class="comment"># of the read. In non-chunked case count &lt; max_read_count, so</span></div>
<div class="line"><span class="lineno">  809</span>            <span class="comment"># only one read is performed.</span></div>
<div class="line"><span class="lineno">  810</span> </div>
<div class="line"><span class="lineno">  811</span>            <span class="comment"># Use np.ndarray instead of np.empty since the latter does</span></div>
<div class="line"><span class="lineno">  812</span>            <span class="comment"># not correctly instantiate zero-width string dtypes; see</span></div>
<div class="line"><span class="lineno">  813</span>            <span class="comment"># https://github.com/numpy/numpy/pull/6430</span></div>
<div class="line"><span class="lineno">  814</span>            array = numpy.ndarray(count, dtype=dtype)</div>
<div class="line"><span class="lineno">  815</span> </div>
<div class="line"><span class="lineno">  816</span>            <span class="keywordflow">if</span> dtype.itemsize &gt; 0:</div>
<div class="line"><span class="lineno">  817</span>                <span class="comment"># If dtype.itemsize == 0 then there&#39;s nothing more to read</span></div>
<div class="line"><span class="lineno">  818</span>                max_read_count = BUFFER_SIZE // min(BUFFER_SIZE, dtype.itemsize)</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, count, max_read_count):</div>
<div class="line"><span class="lineno">  821</span>                    read_count = min(max_read_count, count - i)</div>
<div class="line"><span class="lineno">  822</span>                    read_size = int(read_count * dtype.itemsize)</div>
<div class="line"><span class="lineno">  823</span>                    data = _read_bytes(fp, read_size, <span class="stringliteral">&quot;array data&quot;</span>)</div>
<div class="line"><span class="lineno">  824</span>                    array[i:i+read_count] = numpy.frombuffer(data, dtype=dtype,</div>
<div class="line"><span class="lineno">  825</span>                                                             count=read_count)</div>
<div class="line"><span class="lineno">  826</span> </div>
<div class="line"><span class="lineno">  827</span>        <span class="keywordflow">if</span> fortran_order:</div>
<div class="line"><span class="lineno">  828</span>            array.shape = shape[::-1]</div>
<div class="line"><span class="lineno">  829</span>            array = array.transpose()</div>
<div class="line"><span class="lineno">  830</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  831</span>            array.shape = shape</div>
<div class="line"><span class="lineno">  832</span> </div>
<div class="line"><span class="lineno">  833</span>    <span class="keywordflow">return</span> array</div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d9ad9707fe293d136999f2b1c029bea" name="a4d9ad9707fe293d136999f2b1c029bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9ad9707fe293d136999f2b1c029bea">&#9670;&#160;</a></span>read_array_header_1_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.read_array_header_1_0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_header_size</em> = <code><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read an array header from a filelike object using the 1.0 file format
version.

This will leave the file object located just after the header.

Parameters
----------
fp : filelike object
    A file object or something with a `.read()` method like a file.

Returns
-------
shape : tuple of int
    The shape of the array.
fortran_order : bool
    The array data will be written out directly if it is either
    C-contiguous or Fortran-contiguous. Otherwise, it will be made
    contiguous before writing it out.
dtype : dtype
    The dtype of the file's data.
max_header_size : int, optional
    Maximum allowed size of the header.  Large headers may not be safe
    to load securely and thus require explicitly passing a larger value.
    See :py:meth:`ast.literal_eval()` for details.

Raises
------
ValueError
    If the data is invalid.</pre> <div class="fragment"><div class="line"><span class="lineno">  483</span><span class="keyword">def </span>read_array_header_1_0(fp, max_header_size=_MAX_HEADER_SIZE):</div>
<div class="line"><span class="lineno">  484</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    Read an array header from a filelike object using the 1.0 file format</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    version.</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    This will leave the file object located just after the header.</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    fp : filelike object</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        A file object or something with a `.read()` method like a file.</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    shape : tuple of int</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">        The shape of the array.</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    fortran_order : bool</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        The array data will be written out directly if it is either</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        C-contiguous or Fortran-contiguous. Otherwise, it will be made</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        contiguous before writing it out.</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    dtype : dtype</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        The dtype of the file&#39;s data.</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    max_header_size : int, optional</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        Maximum allowed size of the header.  Large headers may not be safe</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        to load securely and thus require explicitly passing a larger value.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        See :py:meth:`ast.literal_eval()` for details.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        If the data is invalid.</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">return</span> _read_array_header(</div>
<div class="line"><span class="lineno">  517</span>            fp, version=(1, 0), max_header_size=max_header_size)</div>
<div class="line"><span class="lineno">  518</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a165e24908a970b112a9e04d69351333b" name="a165e24908a970b112a9e04d69351333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165e24908a970b112a9e04d69351333b">&#9670;&#160;</a></span>read_array_header_2_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.read_array_header_2_0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_header_size</em> = <code><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">_MAX_HEADER_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read an array header from a filelike object using the 2.0 file format
version.

This will leave the file object located just after the header.

.. versionadded:: 1.9.0

Parameters
----------
fp : filelike object
    A file object or something with a `.read()` method like a file.
max_header_size : int, optional
    Maximum allowed size of the header.  Large headers may not be safe
    to load securely and thus require explicitly passing a larger value.
    See :py:meth:`ast.literal_eval()` for details.

Returns
-------
shape : tuple of int
    The shape of the array.
fortran_order : bool
    The array data will be written out directly if it is either
    C-contiguous or Fortran-contiguous. Otherwise, it will be made
    contiguous before writing it out.
dtype : dtype
    The dtype of the file's data.

Raises
------
ValueError
    If the data is invalid.</pre> <div class="fragment"><div class="line"><span class="lineno">  519</span><span class="keyword">def </span>read_array_header_2_0(fp, max_header_size=_MAX_HEADER_SIZE):</div>
<div class="line"><span class="lineno">  520</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    Read an array header from a filelike object using the 2.0 file format</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    version.</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    This will leave the file object located just after the header.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    fp : filelike object</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        A file object or something with a `.read()` method like a file.</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    max_header_size : int, optional</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        Maximum allowed size of the header.  Large headers may not be safe</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        to load securely and thus require explicitly passing a larger value.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        See :py:meth:`ast.literal_eval()` for details.</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    shape : tuple of int</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">        The shape of the array.</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    fortran_order : bool</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        The array data will be written out directly if it is either</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        C-contiguous or Fortran-contiguous. Otherwise, it will be made</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        contiguous before writing it out.</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    dtype : dtype</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        The dtype of the file&#39;s data.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        If the data is invalid.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  554</span>    <span class="keywordflow">return</span> _read_array_header(</div>
<div class="line"><span class="lineno">  555</span>            fp, version=(2, 0), max_header_size=max_header_size)</div>
<div class="line"><span class="lineno">  556</span> </div>
<div class="line"><span class="lineno">  557</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e1aea029d05724a019a8b3f5039bc0f" name="a5e1aea029d05724a019a8b3f5039bc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1aea029d05724a019a8b3f5039bc0f">&#9670;&#160;</a></span>read_magic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.read_magic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Read the magic string to get the version of the file format.

Parameters
----------
fp : filelike object

Returns
-------
major : int
minor : int
</pre> <div class="fragment"><div class="line"><span class="lineno">  223</span><span class="keyword">def </span>read_magic(fp):</div>
<div class="line"><span class="lineno">  224</span>    <span class="stringliteral">&quot;&quot;&quot; Read the magic string to get the version of the file format.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    fp : filelike object</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    major : int</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    minor : int</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  235</span>    magic_str = _read_bytes(fp, MAGIC_LEN, <span class="stringliteral">&quot;magic string&quot;</span>)</div>
<div class="line"><span class="lineno">  236</span>    <span class="keywordflow">if</span> magic_str[:-2] != MAGIC_PREFIX:</div>
<div class="line"><span class="lineno">  237</span>        msg = <span class="stringliteral">&quot;the magic string is not correct; expected %r, got %r&quot;</span></div>
<div class="line"><span class="lineno">  238</span>        <span class="keywordflow">raise</span> ValueError(msg % (MAGIC_PREFIX, magic_str[:-2]))</div>
<div class="line"><span class="lineno">  239</span>    major, minor = magic_str[-2:]</div>
<div class="line"><span class="lineno">  240</span>    <span class="keywordflow">return</span> major, minor</div>
<div class="line"><span class="lineno">  241</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af7fe5b2446c9a06bf4c1c84ab1c383e8" name="af7fe5b2446c9a06bf4c1c84ab1c383e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fe5b2446c9a06bf4c1c84ab1c383e8">&#9670;&#160;</a></span>write_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.write_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>version</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_pickle</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pickle_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write an array to an NPY file, including a header.

If the array is neither C-contiguous nor Fortran-contiguous AND the
file_like object is not a real file object, this function will have to
copy data in memory.

Parameters
----------
fp : file_like object
    An open, writable file object, or similar object with a
    ``.write()`` method.
array : ndarray
    The array to write to disk.
version : (int, int) or None, optional
    The version number of the format. None means use the oldest
    supported version that is able to store the data.  Default: None
allow_pickle : bool, optional
    Whether to allow writing pickled data. Default: True
pickle_kwargs : dict, optional
    Additional keyword arguments to pass to pickle.dump, excluding
    'protocol'. These are only useful when pickling objects in object
    arrays on Python 3 to Python 2 compatible format.

Raises
------
ValueError
    If the array cannot be persisted. This includes the case of
    allow_pickle=False and array being an object array.
Various other errors
    If the array contains Python objects as part of its dtype, the
    process of pickling them may raise various errors if the objects
    are not picklable.</pre> <div class="fragment"><div class="line"><span class="lineno">  658</span><span class="keyword">def </span>write_array(fp, array, version=None, allow_pickle=True, pickle_kwargs=None):</div>
<div class="line"><span class="lineno">  659</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    Write an array to an NPY file, including a header.</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    If the array is neither C-contiguous nor Fortran-contiguous AND the</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    file_like object is not a real file object, this function will have to</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    copy data in memory.</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    fp : file_like object</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">        An open, writable file object, or similar object with a</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        ``.write()`` method.</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    array : ndarray</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        The array to write to disk.</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    version : (int, int) or None, optional</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">        The version number of the format. None means use the oldest</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">        supported version that is able to store the data.  Default: None</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    allow_pickle : bool, optional</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        Whether to allow writing pickled data. Default: True</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    pickle_kwargs : dict, optional</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">        Additional keyword arguments to pass to pickle.dump, excluding</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">        &#39;protocol&#39;. These are only useful when pickling objects in object</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">        arrays on Python 3 to Python 2 compatible format.</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">        If the array cannot be persisted. This includes the case of</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        allow_pickle=False and array being an object array.</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    Various other errors</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        If the array contains Python objects as part of its dtype, the</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        process of pickling them may raise various errors if the objects</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        are not picklable.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  694</span>    _check_version(version)</div>
<div class="line"><span class="lineno">  695</span>    _write_array_header(fp, header_data_from_array_1_0(array), version)</div>
<div class="line"><span class="lineno">  696</span> </div>
<div class="line"><span class="lineno">  697</span>    <span class="keywordflow">if</span> array.itemsize == 0:</div>
<div class="line"><span class="lineno">  698</span>        buffersize = 0</div>
<div class="line"><span class="lineno">  699</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  700</span>        <span class="comment"># Set buffer size to 16 MiB to hide the Python loop overhead.</span></div>
<div class="line"><span class="lineno">  701</span>        buffersize = max(16 * 1024 ** 2 // array.itemsize, 1)</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <span class="keywordflow">if</span> array.dtype.hasobject:</div>
<div class="line"><span class="lineno">  704</span>        <span class="comment"># We contain Python objects so we cannot write out the data</span></div>
<div class="line"><span class="lineno">  705</span>        <span class="comment"># directly.  Instead, we will pickle it out</span></div>
<div class="line"><span class="lineno">  706</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> allow_pickle:</div>
<div class="line"><span class="lineno">  707</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Object arrays cannot be saved when &quot;</span></div>
<div class="line"><span class="lineno">  708</span>                             <span class="stringliteral">&quot;allow_pickle=False&quot;</span>)</div>
<div class="line"><span class="lineno">  709</span>        <span class="keywordflow">if</span> pickle_kwargs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  710</span>            pickle_kwargs = {}</div>
<div class="line"><span class="lineno">  711</span>        pickle.dump(array, fp, protocol=3, **pickle_kwargs)</div>
<div class="line"><span class="lineno">  712</span>    <span class="keywordflow">elif</span> array.flags.f_contiguous <span class="keywordflow">and</span> <span class="keywordflow">not</span> array.flags.c_contiguous:</div>
<div class="line"><span class="lineno">  713</span>        <span class="keywordflow">if</span> isfileobj(fp):</div>
<div class="line"><span class="lineno">  714</span>            array.T.tofile(fp)</div>
<div class="line"><span class="lineno">  715</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  716</span>            <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> numpy.nditer(</div>
<div class="line"><span class="lineno">  717</span>                    array, flags=[<span class="stringliteral">&#39;external_loop&#39;</span>, <span class="stringliteral">&#39;buffered&#39;</span>, <span class="stringliteral">&#39;zerosize_ok&#39;</span>],</div>
<div class="line"><span class="lineno">  718</span>                    buffersize=buffersize, order=<span class="stringliteral">&#39;F&#39;</span>):</div>
<div class="line"><span class="lineno">  719</span>                fp.write(chunk.tobytes(<span class="stringliteral">&#39;C&#39;</span>))</div>
<div class="line"><span class="lineno">  720</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  721</span>        <span class="keywordflow">if</span> isfileobj(fp):</div>
<div class="line"><span class="lineno">  722</span>            array.tofile(fp)</div>
<div class="line"><span class="lineno">  723</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  724</span>            <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> numpy.nditer(</div>
<div class="line"><span class="lineno">  725</span>                    array, flags=[<span class="stringliteral">&#39;external_loop&#39;</span>, <span class="stringliteral">&#39;buffered&#39;</span>, <span class="stringliteral">&#39;zerosize_ok&#39;</span>],</div>
<div class="line"><span class="lineno">  726</span>                    buffersize=buffersize, order=<span class="stringliteral">&#39;C&#39;</span>):</div>
<div class="line"><span class="lineno">  727</span>                fp.write(chunk.tobytes(<span class="stringliteral">&#39;C&#39;</span>))</div>
<div class="line"><span class="lineno">  728</span> </div>
<div class="line"><span class="lineno">  729</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af8f2f0c37d656ed720cabfdccfde9c03" name="af8f2f0c37d656ed720cabfdccfde9c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f2f0c37d656ed720cabfdccfde9c03">&#9670;&#160;</a></span>write_array_header_1_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.write_array_header_1_0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Write the header for an array using the 1.0 format.

Parameters
----------
fp : filelike object
d : dict
    This has the appropriate entries for writing its string
    representation to the header of the file.
</pre> <div class="fragment"><div class="line"><span class="lineno">  455</span><span class="keyword">def </span>write_array_header_1_0(fp, d):</div>
<div class="line"><span class="lineno">  456</span>    <span class="stringliteral">&quot;&quot;&quot; Write the header for an array using the 1.0 format.</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    fp : filelike object</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    d : dict</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        This has the appropriate entries for writing its string</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        representation to the header of the file.</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  465</span>    _write_array_header(fp, d, (1, 0))</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1de58f169f5808e03f9b15e25b3cc4ba" name="a1de58f169f5808e03f9b15e25b3cc4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de58f169f5808e03f9b15e25b3cc4ba">&#9670;&#160;</a></span>write_array_header_2_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.format.write_array_header_2_0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Write the header for an array using the 2.0 format.
    The 2.0 format allows storing very large structured arrays.

.. versionadded:: 1.9.0

Parameters
----------
fp : filelike object
d : dict
    This has the appropriate entries for writing its string
    representation to the header of the file.
</pre> <div class="fragment"><div class="line"><span class="lineno">  468</span><span class="keyword">def </span>write_array_header_2_0(fp, d):</div>
<div class="line"><span class="lineno">  469</span>    <span class="stringliteral">&quot;&quot;&quot; Write the header for an array using the 2.0 format.</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        The 2.0 format allows storing very large structured arrays.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    fp : filelike object</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    d : dict</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        This has the appropriate entries for writing its string</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        representation to the header of the file.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  481</span>    _write_array_header(fp, d, (2, 0))</div>
<div class="line"><span class="lineno">  482</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a694f277f3bec0e61b0254d68b61c4a3f" name="a694f277f3bec0e61b0254d68b61c4a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694f277f3bec0e61b0254d68b61c4a3f">&#9670;&#160;</a></span>_header_size_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict numpy.lib.format._header_size_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    (1, 0): (<span class="stringliteral">&#39;&lt;H&#39;</span>, <span class="stringliteral">&#39;latin1&#39;</span>),</div>
<div class="line"><span class="lineno">    3</span>    (2, 0): (<span class="stringliteral">&#39;&lt;I&#39;</span>, <span class="stringliteral">&#39;latin1&#39;</span>),</div>
<div class="line"><span class="lineno">    4</span>    (3, 0): (<span class="stringliteral">&#39;&lt;I&#39;</span>, <span class="stringliteral">&#39;utf8&#39;</span>),</div>
<div class="line"><span class="lineno">    5</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2f49de29655c78cd4a4126b2090f22b" name="ab2f49de29655c78cd4a4126b2090f22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f49de29655c78cd4a4126b2090f22b">&#9670;&#160;</a></span>_MAX_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int numpy.lib.format._MAX_HEADER_SIZE = 10000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a404e4d42ca389ce34e609b900e971155" name="a404e4d42ca389ce34e609b900e971155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404e4d42ca389ce34e609b900e971155">&#9670;&#160;</a></span>ARRAY_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int numpy.lib.format.ARRAY_ALIGN = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6499cae034b0938029effa8853d1629c" name="a6499cae034b0938029effa8853d1629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6499cae034b0938029effa8853d1629c">&#9670;&#160;</a></span>BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int numpy.lib.format.BUFFER_SIZE = 2**18</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eb42bfc405375befeb4f625b0df5950" name="a4eb42bfc405375befeb4f625b0df5950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb42bfc405375befeb4f625b0df5950">&#9670;&#160;</a></span>EXPECTED_KEYS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict numpy.lib.format.EXPECTED_KEYS = {'descr', 'fortran_order', '<a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>'}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5545ec631cafb4205aca4f67effdbee0" name="a5545ec631cafb4205aca4f67effdbee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5545ec631cafb4205aca4f67effdbee0">&#9670;&#160;</a></span>GROWTH_AXIS_MAX_DIGITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int numpy.lib.format.GROWTH_AXIS_MAX_DIGITS = 21</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37f9be3c01b0c6f44a3f1032d1e6ca5d" name="a37f9be3c01b0c6f44a3f1032d1e6ca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f9be3c01b0c6f44a3f1032d1e6ca5d">&#9670;&#160;</a></span>MAGIC_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int numpy.lib.format.MAGIC_LEN = len(<a class="el" href="namespacenumpy_1_1lib_1_1format.html#aa1ed04ba05fc05cf9540453092ba4936">MAGIC_PREFIX</a>) + 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1ed04ba05fc05cf9540453092ba4936" name="aa1ed04ba05fc05cf9540453092ba4936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ed04ba05fc05cf9540453092ba4936">&#9670;&#160;</a></span>MAGIC_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str numpy.lib.format.MAGIC_PREFIX = b'\x93NUMPY'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
