<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.cluster._agglomerative Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html">_agglomerative</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sklearn.cluster._agglomerative Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__agglomerative_1_1_agglomerative_clustering.html">AgglomerativeClustering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__agglomerative_1_1_feature_agglomeration.html">FeatureAgglomeration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b13ca3962b9ec0e5bcb2be861306e2e" id="r_a0b13ca3962b9ec0e5bcb2be861306e2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#a0b13ca3962b9ec0e5bcb2be861306e2e">_fix_connectivity</a> (X, connectivity, affinity)</td></tr>
<tr class="memdesc:a0b13ca3962b9ec0e5bcb2be861306e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For non fully-connected graphs.  <br /></td></tr>
<tr class="separator:a0b13ca3962b9ec0e5bcb2be861306e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65876a4f74782f89c454de63e0f4310" id="r_ad65876a4f74782f89c454de63e0f4310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#ad65876a4f74782f89c454de63e0f4310">_single_linkage_tree</a> (connectivity, n_samples, n_nodes, n_clusters, n_connected_components, return_distance)</td></tr>
<tr class="separator:ad65876a4f74782f89c454de63e0f4310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fe1f0c91e0e27b8be425adf0a3f359" id="r_a19fe1f0c91e0e27b8be425adf0a3f359"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#a19fe1f0c91e0e27b8be425adf0a3f359">ward_tree</a> (X, *connectivity=None, n_clusters=None, return_distance=False)</td></tr>
<tr class="memdesc:a19fe1f0c91e0e27b8be425adf0a3f359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical tree building functions.  <br /></td></tr>
<tr class="separator:a19fe1f0c91e0e27b8be425adf0a3f359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38921d78a1744f9449ba29ce8bfd0e49" id="r_a38921d78a1744f9449ba29ce8bfd0e49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#a38921d78a1744f9449ba29ce8bfd0e49">linkage_tree</a> (X, connectivity=None, n_clusters=None, linkage=&quot;complete&quot;, affinity=&quot;euclidean&quot;, return_distance=False)</td></tr>
<tr class="separator:a38921d78a1744f9449ba29ce8bfd0e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bd194f2944183b66e9cb9fd7d025b6" id="r_a74bd194f2944183b66e9cb9fd7d025b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#a74bd194f2944183b66e9cb9fd7d025b6">_complete_linkage</a> (*args, **kwargs)</td></tr>
<tr class="separator:a74bd194f2944183b66e9cb9fd7d025b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae673b271cfd3a443e0adf8d540112875" id="r_ae673b271cfd3a443e0adf8d540112875"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#ae673b271cfd3a443e0adf8d540112875">_average_linkage</a> (*args, **kwargs)</td></tr>
<tr class="separator:ae673b271cfd3a443e0adf8d540112875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac529c06cbb70f05802322a9dbd3a7769" id="r_ac529c06cbb70f05802322a9dbd3a7769"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#ac529c06cbb70f05802322a9dbd3a7769">_single_linkage</a> (*args, **kwargs)</td></tr>
<tr class="separator:ac529c06cbb70f05802322a9dbd3a7769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4100f38e807bc25c3d687cd064e8468" id="r_aa4100f38e807bc25c3d687cd064e8468"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#aa4100f38e807bc25c3d687cd064e8468">_hc_cut</a> (n_clusters, children, n_leaves)</td></tr>
<tr class="memdesc:aa4100f38e807bc25c3d687cd064e8468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for cutting hierarchical clustering tree.  <br /></td></tr>
<tr class="separator:aa4100f38e807bc25c3d687cd064e8468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2b1947c000f96fb6a39bbaafc58697aa" id="r_a2b1947c000f96fb6a39bbaafc58697aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__agglomerative.html#a2b1947c000f96fb6a39bbaafc58697aa">_TREE_BUILDERS</a></td></tr>
<tr class="separator:a2b1947c000f96fb6a39bbaafc58697aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Hierarchical Agglomerative Clustering

These routines perform some hierarchical agglomerative clustering of some
input data.

Authors : Vincent Michel, Bertrand Thirion, Alexandre Gramfort,
          Gael Varoquaux
License: BSD 3 clause
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae673b271cfd3a443e0adf8d540112875" name="ae673b271cfd3a443e0adf8d540112875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae673b271cfd3a443e0adf8d540112875">&#9670;&#160;</a></span>_average_linkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._average_linkage </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  668</span><span class="keyword">def </span>_average_linkage(*args, **kwargs):</div>
<div class="line"><span class="lineno">  669</span>    kwargs[<span class="stringliteral">&quot;linkage&quot;</span>] = <span class="stringliteral">&quot;average&quot;</span></div>
<div class="line"><span class="lineno">  670</span>    <span class="keywordflow">return</span> linkage_tree(*args, **kwargs)</div>
<div class="line"><span class="lineno">  671</span> </div>
<div class="line"><span class="lineno">  672</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a74bd194f2944183b66e9cb9fd7d025b6" name="a74bd194f2944183b66e9cb9fd7d025b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bd194f2944183b66e9cb9fd7d025b6">&#9670;&#160;</a></span>_complete_linkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._complete_linkage </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  663</span><span class="keyword">def </span>_complete_linkage(*args, **kwargs):</div>
<div class="line"><span class="lineno">  664</span>    kwargs[<span class="stringliteral">&quot;linkage&quot;</span>] = <span class="stringliteral">&quot;complete&quot;</span></div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">return</span> linkage_tree(*args, **kwargs)</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b13ca3962b9ec0e5bcb2be861306e2e" name="a0b13ca3962b9ec0e5bcb2be861306e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b13ca3962b9ec0e5bcb2be861306e2e">&#9670;&#160;</a></span>_fix_connectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._fix_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>affinity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For non fully-connected graphs. </p>
<pre class="fragment">Fixes the connectivity matrix.

The different steps are:

- copies it
- makes it symmetric
- converts it to LIL if necessary
- completes it if necessary.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : sparse matrix, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is `None`, i.e, the Ward algorithm is unstructured.

affinity : {"euclidean", "precomputed"}, default="euclidean"
    Which affinity to use. At the moment `precomputed` and
    ``euclidean`` are supported. `euclidean` uses the
    negative squared Euclidean distance between points.

Returns
-------
connectivity : sparse matrix
    The fixed connectivity matrix.

n_connected_components : int
    The number of connected components in the graph.
</pre> <div class="fragment"><div class="line"><span class="lineno">   37</span><span class="keyword">def </span>_fix_connectivity(X, connectivity, affinity):</div>
<div class="line"><span class="lineno">   38</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    Fixes the connectivity matrix.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    The different steps are:</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    - copies it</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    - makes it symmetric</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    - converts it to LIL if necessary</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    - completes it if necessary.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        Feature matrix representing `n_samples` samples to be clustered.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    connectivity : sparse matrix, default=None</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        Connectivity matrix. Defines for each sample the neighboring samples</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">        following a given structure of the data. The matrix is assumed to</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">        be symmetric and only the upper triangular half is used.</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">        Default is `None`, i.e, the Ward algorithm is unstructured.</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    affinity : {&quot;euclidean&quot;, &quot;precomputed&quot;}, default=&quot;euclidean&quot;</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        Which affinity to use. At the moment `precomputed` and</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        ``euclidean`` are supported. `euclidean` uses the</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        negative squared Euclidean distance between points.</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    connectivity : sparse matrix</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">        The fixed connectivity matrix.</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    n_connected_components : int</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">        The number of connected components in the graph.</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   72</span>    n_samples = X.shape[0]</div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">if</span> connectivity.shape[0] != n_samples <span class="keywordflow">or</span> connectivity.shape[1] != n_samples:</div>
<div class="line"><span class="lineno">   74</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">   75</span>            <span class="stringliteral">&quot;Wrong shape for connectivity matrix: %s when X is %s&quot;</span></div>
<div class="line"><span class="lineno">   76</span>            % (connectivity.shape, X.shape)</div>
<div class="line"><span class="lineno">   77</span>        )</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>    <span class="comment"># Make the connectivity matrix symmetric:</span></div>
<div class="line"><span class="lineno">   80</span>    connectivity = connectivity + connectivity.T</div>
<div class="line"><span class="lineno">   81</span> </div>
<div class="line"><span class="lineno">   82</span>    <span class="comment"># Convert connectivity matrix to LIL</span></div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> sparse.isspmatrix_lil(connectivity):</div>
<div class="line"><span class="lineno">   84</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> sparse.isspmatrix(connectivity):</div>
<div class="line"><span class="lineno">   85</span>            connectivity = sparse.lil_matrix(connectivity)</div>
<div class="line"><span class="lineno">   86</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   87</span>            connectivity = connectivity.tolil()</div>
<div class="line"><span class="lineno">   88</span> </div>
<div class="line"><span class="lineno">   89</span>    <span class="comment"># Compute the number of nodes</span></div>
<div class="line"><span class="lineno">   90</span>    n_connected_components, labels = connected_components(connectivity)</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>    <span class="keywordflow">if</span> n_connected_components &gt; 1:</div>
<div class="line"><span class="lineno">   93</span>        warnings.warn(</div>
<div class="line"><span class="lineno">   94</span>            <span class="stringliteral">&quot;the number of connected components of the &quot;</span></div>
<div class="line"><span class="lineno">   95</span>            <span class="stringliteral">&quot;connectivity matrix is %d &gt; 1. Completing it to avoid &quot;</span></div>
<div class="line"><span class="lineno">   96</span>            <span class="stringliteral">&quot;stopping the tree early.&quot;</span> % n_connected_components,</div>
<div class="line"><span class="lineno">   97</span>            stacklevel=2,</div>
<div class="line"><span class="lineno">   98</span>        )</div>
<div class="line"><span class="lineno">   99</span>        <span class="comment"># XXX: Can we do without completing the matrix?</span></div>
<div class="line"><span class="lineno">  100</span>        connectivity = _fix_connected_components(</div>
<div class="line"><span class="lineno">  101</span>            X=X,</div>
<div class="line"><span class="lineno">  102</span>            graph=connectivity,</div>
<div class="line"><span class="lineno">  103</span>            n_connected_components=n_connected_components,</div>
<div class="line"><span class="lineno">  104</span>            component_labels=labels,</div>
<div class="line"><span class="lineno">  105</span>            metric=affinity,</div>
<div class="line"><span class="lineno">  106</span>            mode=<span class="stringliteral">&quot;connectivity&quot;</span>,</div>
<div class="line"><span class="lineno">  107</span>        )</div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordflow">return</span> connectivity, n_connected_components</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4100f38e807bc25c3d687cd064e8468" name="aa4100f38e807bc25c3d687cd064e8468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4100f38e807bc25c3d687cd064e8468">&#9670;&#160;</a></span>_hc_cut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._hc_cut </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_leaves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functions for cutting hierarchical clustering tree. </p>
<pre class="fragment">Function cutting the ward tree for a given number of clusters.

Parameters
----------
n_clusters : int or ndarray
    The number of clusters to form.

children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_leaves : int
    Number of leaves of the tree.

Returns
-------
labels : array [n_samples]
    Cluster labels for each point.
</pre> <div class="fragment"><div class="line"><span class="lineno">  689</span><span class="keyword">def </span>_hc_cut(n_clusters, children, n_leaves):</div>
<div class="line"><span class="lineno">  690</span>    <span class="stringliteral">&quot;&quot;&quot;Function cutting the ward tree for a given number of clusters.</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    n_clusters : int or ndarray</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        The number of clusters to form.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    children : ndarray of shape (n_nodes-1, 2)</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        The children of each non-leaf node. Values less than `n_samples`</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        correspond to leaves of the tree which are the original samples.</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        A node `i` greater than or equal to `n_samples` is a non-leaf</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        node and has children `children_[i - n_samples]`. Alternatively</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        at the i-th iteration, children[i][0] and children[i][1]</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        are merged to form node `n_samples + i`.</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    n_leaves : int</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">        Number of leaves of the tree.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    labels : array [n_samples]</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        Cluster labels for each point.</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  713</span>    <span class="keywordflow">if</span> n_clusters &gt; n_leaves:</div>
<div class="line"><span class="lineno">  714</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  715</span>            <span class="stringliteral">&quot;Cannot extract more clusters than samples: &quot;</span></div>
<div class="line"><span class="lineno">  716</span>            <span class="stringliteral">&quot;%s clusters where given for a tree with %s leaves.&quot;</span></div>
<div class="line"><span class="lineno">  717</span>            % (n_clusters, n_leaves)</div>
<div class="line"><span class="lineno">  718</span>        )</div>
<div class="line"><span class="lineno">  719</span>    <span class="comment"># In this function, we store nodes as a heap to avoid recomputing</span></div>
<div class="line"><span class="lineno">  720</span>    <span class="comment"># the max of the nodes: the first element is always the smallest</span></div>
<div class="line"><span class="lineno">  721</span>    <span class="comment"># We use negated indices as heaps work on smallest elements, and we</span></div>
<div class="line"><span class="lineno">  722</span>    <span class="comment"># are interested in largest elements</span></div>
<div class="line"><span class="lineno">  723</span>    <span class="comment"># children[-1] is the root of the tree</span></div>
<div class="line"><span class="lineno">  724</span>    nodes = [-(max(children[-1]) + 1)]</div>
<div class="line"><span class="lineno">  725</span>    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(n_clusters - 1):</div>
<div class="line"><span class="lineno">  726</span>        <span class="comment"># As we have a heap, nodes[0] is the smallest element</span></div>
<div class="line"><span class="lineno">  727</span>        these_children = children[-nodes[0] - n_leaves]</div>
<div class="line"><span class="lineno">  728</span>        <span class="comment"># Insert the 2 children and remove the largest node</span></div>
<div class="line"><span class="lineno">  729</span>        heappush(nodes, -these_children[0])</div>
<div class="line"><span class="lineno">  730</span>        heappushpop(nodes, -these_children[1])</div>
<div class="line"><span class="lineno">  731</span>    label = np.zeros(n_leaves, dtype=np.intp)</div>
<div class="line"><span class="lineno">  732</span>    <span class="keywordflow">for</span> i, node <span class="keywordflow">in</span> enumerate(nodes):</div>
<div class="line"><span class="lineno">  733</span>        label[_hierarchical._hc_get_descendent(-node, children, n_leaves)] = i</div>
<div class="line"><span class="lineno">  734</span>    <span class="keywordflow">return</span> label</div>
<div class="line"><span class="lineno">  735</span> </div>
<div class="line"><span class="lineno">  736</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac529c06cbb70f05802322a9dbd3a7769" name="ac529c06cbb70f05802322a9dbd3a7769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac529c06cbb70f05802322a9dbd3a7769">&#9670;&#160;</a></span>_single_linkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._single_linkage </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  673</span><span class="keyword">def </span>_single_linkage(*args, **kwargs):</div>
<div class="line"><span class="lineno">  674</span>    kwargs[<span class="stringliteral">&quot;linkage&quot;</span>] = <span class="stringliteral">&quot;single&quot;</span></div>
<div class="line"><span class="lineno">  675</span>    <span class="keywordflow">return</span> linkage_tree(*args, **kwargs)</div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad65876a4f74782f89c454de63e0f4310" name="ad65876a4f74782f89c454de63e0f4310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65876a4f74782f89c454de63e0f4310">&#9670;&#160;</a></span>_single_linkage_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._single_linkage_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_connected_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Perform single linkage clustering on sparse data via the minimum
spanning tree from scipy.sparse.csgraph, then using union-find to label.
The parent array is then generated by walking through the tree.
</pre> <div class="fragment"><div class="line"><span class="lineno">  119</span>):</div>
<div class="line"><span class="lineno">  120</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    Perform single linkage clustering on sparse data via the minimum</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    spanning tree from scipy.sparse.csgraph, then using union-find to label.</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    The parent array is then generated by walking through the tree.</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  125</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1sparse_1_1csgraph.html">scipy.sparse.csgraph</a> <span class="keyword">import</span> minimum_spanning_tree</div>
<div class="line"><span class="lineno">  126</span> </div>
<div class="line"><span class="lineno">  127</span>    <span class="comment"># explicitly cast connectivity to ensure safety</span></div>
<div class="line"><span class="lineno">  128</span>    connectivity = connectivity.astype(np.float64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  129</span> </div>
<div class="line"><span class="lineno">  130</span>    <span class="comment"># Ensure zero distances aren&#39;t ignored by setting them to &quot;epsilon&quot;</span></div>
<div class="line"><span class="lineno">  131</span>    epsilon_value = np.finfo(dtype=connectivity.data.dtype).eps</div>
<div class="line"><span class="lineno">  132</span>    connectivity.data[connectivity.data == 0] = epsilon_value</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>    <span class="comment"># Use scipy.sparse.csgraph to generate a minimum spanning tree</span></div>
<div class="line"><span class="lineno">  135</span>    mst = minimum_spanning_tree(connectivity.tocsr())</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span>    <span class="comment"># Convert the graph to scipy.cluster.hierarchy array format</span></div>
<div class="line"><span class="lineno">  138</span>    mst = mst.tocoo()</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>    <span class="comment"># Undo the epsilon values</span></div>
<div class="line"><span class="lineno">  141</span>    mst.data[mst.data == epsilon_value] = 0</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    mst_array = np.vstack([mst.row, mst.col, mst.data]).T</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>    <span class="comment"># Sort edges of the min_spanning_tree by weight</span></div>
<div class="line"><span class="lineno">  146</span>    mst_array = mst_array[np.argsort(mst_array.T[2], kind=<span class="stringliteral">&quot;mergesort&quot;</span>), :]</div>
<div class="line"><span class="lineno">  147</span> </div>
<div class="line"><span class="lineno">  148</span>    <span class="comment"># Convert edge list into standard hierarchical clustering format</span></div>
<div class="line"><span class="lineno">  149</span>    single_linkage_tree = _hierarchical._single_linkage_label(mst_array)</div>
<div class="line"><span class="lineno">  150</span>    children_ = single_linkage_tree[:, :2].astype(int)</div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span>    <span class="comment"># Compute parents</span></div>
<div class="line"><span class="lineno">  153</span>    parent = np.arange(n_nodes, dtype=np.intp)</div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">for</span> i, (left, right) <span class="keywordflow">in</span> enumerate(children_, n_samples):</div>
<div class="line"><span class="lineno">  155</span>        <span class="keywordflow">if</span> n_clusters <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> i &gt;= n_nodes:</div>
<div class="line"><span class="lineno">  156</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  157</span>        <span class="keywordflow">if</span> left &lt; n_nodes:</div>
<div class="line"><span class="lineno">  158</span>            parent[left] = i</div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">if</span> right &lt; n_nodes:</div>
<div class="line"><span class="lineno">  160</span>            parent[right] = i</div>
<div class="line"><span class="lineno">  161</span> </div>
<div class="line"><span class="lineno">  162</span>    <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  163</span>        distances = single_linkage_tree[:, 2]</div>
<div class="line"><span class="lineno">  164</span>        <span class="keywordflow">return</span> children_, n_connected_components, n_samples, parent, distances</div>
<div class="line"><span class="lineno">  165</span>    <span class="keywordflow">return</span> children_, n_connected_components, n_samples, parent</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="ttc" id="anamespacescipy_1_1sparse_1_1csgraph_html"><div class="ttname"><a href="namespacescipy_1_1sparse_1_1csgraph.html">scipy.sparse.csgraph</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a38921d78a1744f9449ba29ce8bfd0e49" name="a38921d78a1744f9449ba29ce8bfd0e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38921d78a1744f9449ba29ce8bfd0e49">&#9670;&#160;</a></span>linkage_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative.linkage_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connectivity</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linkage</em> = <code>&quot;complete&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>affinity</em> = <code>&quot;euclidean&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_distance</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Linkage agglomerative clustering based on a Feature matrix.

The inertia matrix uses a Heapq-based representation.

This is the structured version, that takes into account some topological
structure between samples.

Read more in the :ref:`User Guide &lt;hierarchical_clustering&gt;`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : sparse matrix, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is `None`, i.e, the Ward algorithm is unstructured.

n_clusters : int, default=None
    Stop early the construction of the tree at `n_clusters`. This is
    useful to decrease computation time if the number of clusters is
    not small compared to the number of samples. In this case, the
    complete tree is not computed, thus the 'children' output is of
    limited use, and the 'parents' output should rather be used.
    This option is valid only when specifying a connectivity matrix.

linkage : {"average", "complete", "single"}, default="complete"
    Which linkage criteria to use. The linkage criterion determines which
    distance to use between sets of observation.
        - "average" uses the average of the distances of each observation of
          the two sets.
        - "complete" or maximum linkage uses the maximum distances between
          all observations of the two sets.
        - "single" uses the minimum of the distances between all
          observations of the two sets.

affinity : str or callable, default='euclidean'
    Which metric to use. Can be 'euclidean', 'manhattan', or any
    distance known to paired distance (see metric.pairwise).

return_distance : bool, default=False
    Whether or not to return the distances between the clusters.

Returns
-------
children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_connected_components : int
    The number of connected components in the graph.

n_leaves : int
    The number of leaves in the tree.

parents : ndarray of shape (n_nodes, ) or None
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.

distances : ndarray of shape (n_nodes-1,)
    Returned when `return_distance` is set to `True`.

    distances[i] refers to the distance between children[i][0] and
    children[i][1] when they are merged.

See Also
--------
ward_tree : Hierarchical clustering with ward linkage.
</pre> <div class="fragment"><div class="line"><span class="lineno">  394</span>):</div>
<div class="line"><span class="lineno">  395</span>    <span class="stringliteral">&quot;&quot;&quot;Linkage agglomerative clustering based on a Feature matrix.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    The inertia matrix uses a Heapq-based representation.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    This is the structured version, that takes into account some topological</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    structure between samples.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;hierarchical_clustering&gt;`.</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">        Feature matrix representing `n_samples` samples to be clustered.</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    connectivity : sparse matrix, default=None</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        Connectivity matrix. Defines for each sample the neighboring samples</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        following a given structure of the data. The matrix is assumed to</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">        be symmetric and only the upper triangular half is used.</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        Default is `None`, i.e, the Ward algorithm is unstructured.</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    n_clusters : int, default=None</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        Stop early the construction of the tree at `n_clusters`. This is</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        useful to decrease computation time if the number of clusters is</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">        not small compared to the number of samples. In this case, the</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        complete tree is not computed, thus the &#39;children&#39; output is of</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">        limited use, and the &#39;parents&#39; output should rather be used.</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">        This option is valid only when specifying a connectivity matrix.</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    linkage : {&quot;average&quot;, &quot;complete&quot;, &quot;single&quot;}, default=&quot;complete&quot;</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        Which linkage criteria to use. The linkage criterion determines which</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">        distance to use between sets of observation.</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">            - &quot;average&quot; uses the average of the distances of each observation of</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">              the two sets.</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">            - &quot;complete&quot; or maximum linkage uses the maximum distances between</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">              all observations of the two sets.</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">            - &quot;single&quot; uses the minimum of the distances between all</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">              observations of the two sets.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    affinity : str or callable, default=&#39;euclidean&#39;</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        Which metric to use. Can be &#39;euclidean&#39;, &#39;manhattan&#39;, or any</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        distance known to paired distance (see metric.pairwise).</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    return_distance : bool, default=False</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        Whether or not to return the distances between the clusters.</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    children : ndarray of shape (n_nodes-1, 2)</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        The children of each non-leaf node. Values less than `n_samples`</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        correspond to leaves of the tree which are the original samples.</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        A node `i` greater than or equal to `n_samples` is a non-leaf</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        node and has children `children_[i - n_samples]`. Alternatively</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        at the i-th iteration, children[i][0] and children[i][1]</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        are merged to form node `n_samples + i`.</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    n_connected_components : int</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        The number of connected components in the graph.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    n_leaves : int</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">        The number of leaves in the tree.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    parents : ndarray of shape (n_nodes, ) or None</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">        The parent of each node. Only returned when a connectivity matrix</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">        is specified, elsewhere &#39;None&#39; is returned.</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    distances : ndarray of shape (n_nodes-1,)</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">        Returned when `return_distance` is set to `True`.</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        distances[i] refers to the distance between children[i][0] and</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        children[i][1] when they are merged.</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    ward_tree : Hierarchical clustering with ward linkage.</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  470</span>    X = np.asarray(X)</div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordflow">if</span> X.ndim == 1:</div>
<div class="line"><span class="lineno">  472</span>        X = np.reshape(X, (-1, 1))</div>
<div class="line"><span class="lineno">  473</span>    n_samples, n_features = X.shape</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span>    linkage_choices = {</div>
<div class="line"><span class="lineno">  476</span>        <span class="stringliteral">&quot;complete&quot;</span>: _hierarchical.max_merge,</div>
<div class="line"><span class="lineno">  477</span>        <span class="stringliteral">&quot;average&quot;</span>: _hierarchical.average_merge,</div>
<div class="line"><span class="lineno">  478</span>        <span class="stringliteral">&quot;single&quot;</span>: <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  479</span>    }  <span class="comment"># Single linkage is handled differently</span></div>
<div class="line"><span class="lineno">  480</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  481</span>        join_func = linkage_choices[linkage]</div>
<div class="line"><span class="lineno">  482</span>    <span class="keywordflow">except</span> KeyError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  483</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  484</span>            <span class="stringliteral">&quot;Unknown linkage option, linkage should be one of %s, but %s was given&quot;</span></div>
<div class="line"><span class="lineno">  485</span>            % (linkage_choices.keys(), linkage)</div>
<div class="line"><span class="lineno">  486</span>        ) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  487</span> </div>
<div class="line"><span class="lineno">  488</span>    <span class="keywordflow">if</span> affinity == <span class="stringliteral">&quot;cosine&quot;</span> <span class="keywordflow">and</span> np.any(~np.any(X, axis=1)):</div>
<div class="line"><span class="lineno">  489</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Cosine affinity cannot be used when X contains zero vectors&quot;</span>)</div>
<div class="line"><span class="lineno">  490</span> </div>
<div class="line"><span class="lineno">  491</span>    <span class="keywordflow">if</span> connectivity <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  492</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1cluster.html">scipy.cluster</a> <span class="keyword">import</span> hierarchy  <span class="comment"># imports PIL</span></div>
<div class="line"><span class="lineno">  493</span> </div>
<div class="line"><span class="lineno">  494</span>        <span class="keywordflow">if</span> n_clusters <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  495</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  496</span>                <span class="stringliteral">&quot;Partial build of the tree is implemented &quot;</span></div>
<div class="line"><span class="lineno">  497</span>                <span class="stringliteral">&quot;only for structured clustering (i.e. with &quot;</span></div>
<div class="line"><span class="lineno">  498</span>                <span class="stringliteral">&quot;explicit connectivity). The algorithm &quot;</span></div>
<div class="line"><span class="lineno">  499</span>                <span class="stringliteral">&quot;will build the full tree and only &quot;</span></div>
<div class="line"><span class="lineno">  500</span>                <span class="stringliteral">&quot;retain the lower branches required &quot;</span></div>
<div class="line"><span class="lineno">  501</span>                <span class="stringliteral">&quot;for the specified number of clusters&quot;</span>,</div>
<div class="line"><span class="lineno">  502</span>                stacklevel=2,</div>
<div class="line"><span class="lineno">  503</span>            )</div>
<div class="line"><span class="lineno">  504</span> </div>
<div class="line"><span class="lineno">  505</span>        <span class="keywordflow">if</span> affinity == <span class="stringliteral">&quot;precomputed&quot;</span>:</div>
<div class="line"><span class="lineno">  506</span>            <span class="comment"># for the linkage function of hierarchy to work on precomputed</span></div>
<div class="line"><span class="lineno">  507</span>            <span class="comment"># data, provide as first argument an ndarray of the shape returned</span></div>
<div class="line"><span class="lineno">  508</span>            <span class="comment"># by sklearn.metrics.pairwise_distances.</span></div>
<div class="line"><span class="lineno">  509</span>            <span class="keywordflow">if</span> X.shape[0] != X.shape[1]:</div>
<div class="line"><span class="lineno">  510</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  511</span>                    f<span class="stringliteral">&quot;Distance matrix should be square, got matrix of shape {X.shape}&quot;</span></div>
<div class="line"><span class="lineno">  512</span>                )</div>
<div class="line"><span class="lineno">  513</span>            i, j = np.triu_indices(X.shape[0], k=1)</div>
<div class="line"><span class="lineno">  514</span>            X = X[i, j]</div>
<div class="line"><span class="lineno">  515</span>        <span class="keywordflow">elif</span> affinity == <span class="stringliteral">&quot;l2&quot;</span>:</div>
<div class="line"><span class="lineno">  516</span>            <span class="comment"># Translate to something understood by scipy</span></div>
<div class="line"><span class="lineno">  517</span>            affinity = <span class="stringliteral">&quot;euclidean&quot;</span></div>
<div class="line"><span class="lineno">  518</span>        <span class="keywordflow">elif</span> affinity <span class="keywordflow">in</span> (<span class="stringliteral">&quot;l1&quot;</span>, <span class="stringliteral">&quot;manhattan&quot;</span>):</div>
<div class="line"><span class="lineno">  519</span>            affinity = <span class="stringliteral">&quot;cityblock&quot;</span></div>
<div class="line"><span class="lineno">  520</span>        <span class="keywordflow">elif</span> callable(affinity):</div>
<div class="line"><span class="lineno">  521</span>            X = affinity(X)</div>
<div class="line"><span class="lineno">  522</span>            i, j = np.triu_indices(X.shape[0], k=1)</div>
<div class="line"><span class="lineno">  523</span>            X = X[i, j]</div>
<div class="line"><span class="lineno">  524</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  525</span>            linkage == <span class="stringliteral">&quot;single&quot;</span></div>
<div class="line"><span class="lineno">  526</span>            <span class="keywordflow">and</span> affinity != <span class="stringliteral">&quot;precomputed&quot;</span></div>
<div class="line"><span class="lineno">  527</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> callable(affinity)</div>
<div class="line"><span class="lineno">  528</span>            <span class="keywordflow">and</span> affinity <span class="keywordflow">in</span> METRIC_MAPPING</div>
<div class="line"><span class="lineno">  529</span>        ):</div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span>            <span class="comment"># We need the fast cythonized metric from neighbors</span></div>
<div class="line"><span class="lineno">  532</span>            dist_metric = DistanceMetric.get_metric(affinity)</div>
<div class="line"><span class="lineno">  533</span> </div>
<div class="line"><span class="lineno">  534</span>            <span class="comment"># The Cython routines used require contiguous arrays</span></div>
<div class="line"><span class="lineno">  535</span>            X = np.ascontiguousarray(X, dtype=np.double)</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>            mst = _hierarchical.mst_linkage_core(X, dist_metric)</div>
<div class="line"><span class="lineno">  538</span>            <span class="comment"># Sort edges of the min_spanning_tree by weight</span></div>
<div class="line"><span class="lineno">  539</span>            mst = mst[np.argsort(mst.T[2], kind=<span class="stringliteral">&quot;mergesort&quot;</span>), :]</div>
<div class="line"><span class="lineno">  540</span> </div>
<div class="line"><span class="lineno">  541</span>            <span class="comment"># Convert edge list into standard hierarchical clustering format</span></div>
<div class="line"><span class="lineno">  542</span>            out = _hierarchical.single_linkage_label(mst)</div>
<div class="line"><span class="lineno">  543</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  544</span>            out = hierarchy.linkage(X, method=linkage, metric=affinity)</div>
<div class="line"><span class="lineno">  545</span>        children_ = out[:, :2].astype(int, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  546</span> </div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  548</span>            distances = out[:, 2]</div>
<div class="line"><span class="lineno">  549</span>            <span class="keywordflow">return</span> children_, 1, n_samples, <span class="keywordtype">None</span>, distances</div>
<div class="line"><span class="lineno">  550</span>        <span class="keywordflow">return</span> children_, 1, n_samples, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  551</span> </div>
<div class="line"><span class="lineno">  552</span>    connectivity, n_connected_components = _fix_connectivity(</div>
<div class="line"><span class="lineno">  553</span>        X, connectivity, affinity=affinity</div>
<div class="line"><span class="lineno">  554</span>    )</div>
<div class="line"><span class="lineno">  555</span>    connectivity = connectivity.tocoo()</div>
<div class="line"><span class="lineno">  556</span>    <span class="comment"># Put the diagonal to zero</span></div>
<div class="line"><span class="lineno">  557</span>    diag_mask = connectivity.row != connectivity.col</div>
<div class="line"><span class="lineno">  558</span>    connectivity.row = connectivity.row[diag_mask]</div>
<div class="line"><span class="lineno">  559</span>    connectivity.col = connectivity.col[diag_mask]</div>
<div class="line"><span class="lineno">  560</span>    connectivity.data = connectivity.data[diag_mask]</div>
<div class="line"><span class="lineno">  561</span>    del diag_mask</div>
<div class="line"><span class="lineno">  562</span> </div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">if</span> affinity == <span class="stringliteral">&quot;precomputed&quot;</span>:</div>
<div class="line"><span class="lineno">  564</span>        distances = X[connectivity.row, connectivity.col].astype(np.float64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  565</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  566</span>        <span class="comment"># FIXME We compute all the distances, while we could have only computed</span></div>
<div class="line"><span class="lineno">  567</span>        <span class="comment"># the &quot;interesting&quot; distances</span></div>
<div class="line"><span class="lineno">  568</span>        distances = paired_distances(</div>
<div class="line"><span class="lineno">  569</span>            X[connectivity.row], X[connectivity.col], metric=affinity</div>
<div class="line"><span class="lineno">  570</span>        )</div>
<div class="line"><span class="lineno">  571</span>    connectivity.data = distances</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span>    <span class="keywordflow">if</span> n_clusters <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  574</span>        n_nodes = 2 * n_samples - 1</div>
<div class="line"><span class="lineno">  575</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  576</span>        <span class="keyword">assert</span> n_clusters &lt;= n_samples</div>
<div class="line"><span class="lineno">  577</span>        n_nodes = 2 * n_samples - n_clusters</div>
<div class="line"><span class="lineno">  578</span> </div>
<div class="line"><span class="lineno">  579</span>    <span class="keywordflow">if</span> linkage == <span class="stringliteral">&quot;single&quot;</span>:</div>
<div class="line"><span class="lineno">  580</span>        <span class="keywordflow">return</span> _single_linkage_tree(</div>
<div class="line"><span class="lineno">  581</span>            connectivity,</div>
<div class="line"><span class="lineno">  582</span>            n_samples,</div>
<div class="line"><span class="lineno">  583</span>            n_nodes,</div>
<div class="line"><span class="lineno">  584</span>            n_clusters,</div>
<div class="line"><span class="lineno">  585</span>            n_connected_components,</div>
<div class="line"><span class="lineno">  586</span>            return_distance,</div>
<div class="line"><span class="lineno">  587</span>        )</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span>    <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  590</span>        distances = np.empty(n_nodes - n_samples)</div>
<div class="line"><span class="lineno">  591</span>    <span class="comment"># create inertia heap and connection matrix</span></div>
<div class="line"><span class="lineno">  592</span>    A = np.empty(n_nodes, dtype=object)</div>
<div class="line"><span class="lineno">  593</span>    inertia = list()</div>
<div class="line"><span class="lineno">  594</span> </div>
<div class="line"><span class="lineno">  595</span>    <span class="comment"># LIL seems to the best format to access the rows quickly,</span></div>
<div class="line"><span class="lineno">  596</span>    <span class="comment"># without the numpy overhead of slicing CSR indices and data.</span></div>
<div class="line"><span class="lineno">  597</span>    connectivity = connectivity.tolil()</div>
<div class="line"><span class="lineno">  598</span>    <span class="comment"># We are storing the graph in a list of IntFloatDict</span></div>
<div class="line"><span class="lineno">  599</span>    <span class="keywordflow">for</span> ind, (data, row) <span class="keywordflow">in</span> enumerate(zip(connectivity.data, connectivity.rows)):</div>
<div class="line"><span class="lineno">  600</span>        A[ind] = IntFloatDict(</div>
<div class="line"><span class="lineno">  601</span>            np.asarray(row, dtype=np.intp), np.asarray(data, dtype=np.float64)</div>
<div class="line"><span class="lineno">  602</span>        )</div>
<div class="line"><span class="lineno">  603</span>        <span class="comment"># We keep only the upper triangular for the heap</span></div>
<div class="line"><span class="lineno">  604</span>        <span class="comment"># Generator expressions are faster than arrays on the following</span></div>
<div class="line"><span class="lineno">  605</span>        inertia.extend(</div>
<div class="line"><span class="lineno">  606</span>            _hierarchical.WeightedEdge(d, ind, r) <span class="keywordflow">for</span> r, d <span class="keywordflow">in</span> zip(row, data) <span class="keywordflow">if</span> r &lt; ind</div>
<div class="line"><span class="lineno">  607</span>        )</div>
<div class="line"><span class="lineno">  608</span>    del connectivity</div>
<div class="line"><span class="lineno">  609</span> </div>
<div class="line"><span class="lineno">  610</span>    heapify(inertia)</div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>    <span class="comment"># prepare the main fields</span></div>
<div class="line"><span class="lineno">  613</span>    parent = np.arange(n_nodes, dtype=np.intp)</div>
<div class="line"><span class="lineno">  614</span>    used_node = np.ones(n_nodes, dtype=np.intp)</div>
<div class="line"><span class="lineno">  615</span>    children = []</div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span>    <span class="comment"># recursive merge loop</span></div>
<div class="line"><span class="lineno">  618</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(n_samples, n_nodes):</div>
<div class="line"><span class="lineno">  619</span>        <span class="comment"># identify the merge</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  621</span>            edge = heappop(inertia)</div>
<div class="line"><span class="lineno">  622</span>            <span class="keywordflow">if</span> used_node[edge.a] <span class="keywordflow">and</span> used_node[edge.b]:</div>
<div class="line"><span class="lineno">  623</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  624</span>        i = edge.a</div>
<div class="line"><span class="lineno">  625</span>        j = edge.b</div>
<div class="line"><span class="lineno">  626</span> </div>
<div class="line"><span class="lineno">  627</span>        <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  628</span>            <span class="comment"># store distances</span></div>
<div class="line"><span class="lineno">  629</span>            distances[k - n_samples] = edge.weight</div>
<div class="line"><span class="lineno">  630</span> </div>
<div class="line"><span class="lineno">  631</span>        parent[i] = parent[j] = k</div>
<div class="line"><span class="lineno">  632</span>        children.append((i, j))</div>
<div class="line"><span class="lineno">  633</span>        <span class="comment"># Keep track of the number of elements per cluster</span></div>
<div class="line"><span class="lineno">  634</span>        n_i = used_node[i]</div>
<div class="line"><span class="lineno">  635</span>        n_j = used_node[j]</div>
<div class="line"><span class="lineno">  636</span>        used_node[k] = n_i + n_j</div>
<div class="line"><span class="lineno">  637</span>        used_node[i] = used_node[j] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span>        <span class="comment"># update the structure matrix A and the inertia matrix</span></div>
<div class="line"><span class="lineno">  640</span>        <span class="comment"># a clever &#39;min&#39;, or &#39;max&#39; operation between A[i] and A[j]</span></div>
<div class="line"><span class="lineno">  641</span>        coord_col = join_func(A[i], A[j], used_node, n_i, n_j)</div>
<div class="line"><span class="lineno">  642</span>        <span class="keywordflow">for</span> col, d <span class="keywordflow">in</span> coord_col:</div>
<div class="line"><span class="lineno">  643</span>            A[col].append(k, d)</div>
<div class="line"><span class="lineno">  644</span>            <span class="comment"># Here we use the information from coord_col (containing the</span></div>
<div class="line"><span class="lineno">  645</span>            <span class="comment"># distances) to update the heap</span></div>
<div class="line"><span class="lineno">  646</span>            heappush(inertia, _hierarchical.WeightedEdge(d, k, col))</div>
<div class="line"><span class="lineno">  647</span>        A[k] = coord_col</div>
<div class="line"><span class="lineno">  648</span>        <span class="comment"># Clear A[i] and A[j] to save memory</span></div>
<div class="line"><span class="lineno">  649</span>        A[i] = A[j] = 0</div>
<div class="line"><span class="lineno">  650</span> </div>
<div class="line"><span class="lineno">  651</span>    <span class="comment"># Separate leaves in children (empty lists up to now)</span></div>
<div class="line"><span class="lineno">  652</span>    n_leaves = n_samples</div>
<div class="line"><span class="lineno">  653</span> </div>
<div class="line"><span class="lineno">  654</span>    <span class="comment"># # return numpy array for efficient caching</span></div>
<div class="line"><span class="lineno">  655</span>    children = np.array(children)[:, ::-1]</div>
<div class="line"><span class="lineno">  656</span> </div>
<div class="line"><span class="lineno">  657</span>    <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  658</span>        <span class="keywordflow">return</span> children, n_connected_components, n_leaves, parent, distances</div>
<div class="line"><span class="lineno">  659</span>    <span class="keywordflow">return</span> children, n_connected_components, n_leaves, parent</div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span><span class="comment"># Matching names to tree-building strategies</span></div>
<div class="ttc" id="anamespacescipy_1_1cluster_html"><div class="ttname"><a href="namespacescipy_1_1cluster.html">scipy.cluster</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a19fe1f0c91e0e27b8be425adf0a3f359" name="a19fe1f0c91e0e27b8be425adf0a3f359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fe1f0c91e0e27b8be425adf0a3f359">&#9670;&#160;</a></span>ward_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative.ward_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>connectivity</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_distance</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hierarchical tree building functions. </p>
<pre class="fragment">Ward clustering based on a Feature matrix.

Recursively merges the pair of clusters that minimally increases
within-cluster variance.

The inertia matrix uses a Heapq-based representation.

This is the structured version, that takes into account some topological
structure between samples.

Read more in the :ref:`User Guide &lt;hierarchical_clustering&gt;`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : sparse matrix, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is None, i.e, the Ward algorithm is unstructured.

n_clusters : int, default=None
    `n_clusters` should be less than `n_samples`.  Stop early the
    construction of the tree at `n_clusters.` This is useful to decrease
    computation time if the number of clusters is not small compared to the
    number of samples. In this case, the complete tree is not computed, thus
    the 'children' output is of limited use, and the 'parents' output should
    rather be used. This option is valid only when specifying a connectivity
    matrix.

return_distance : bool, default=False
    If `True`, return the distance between the clusters.

Returns
-------
children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_connected_components : int
    The number of connected components in the graph.

n_leaves : int
    The number of leaves in the tree.

parents : ndarray of shape (n_nodes,) or None
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.

distances : ndarray of shape (n_nodes-1,)
    Only returned if `return_distance` is set to `True` (for compatibility).
    The distances between the centers of the nodes. `distances[i]`
    corresponds to a weighted Euclidean distance between
    the nodes `children[i, 1]` and `children[i, 2]`. If the nodes refer to
    leaves of the tree, then `distances[i]` is their unweighted Euclidean
    distance. Distances are updated in the following way
    (from scipy.hierarchy.linkage):

    The new entry :math:`d(u,v)` is computed as follows,

    .. math::

       d(u,v) = \\sqrt{\\frac{|v|+|s|}
                           {T}d(v,s)^2
                    + \\frac{|v|+|t|}
                           {T}d(v,t)^2
                    - \\frac{|v|}
                           {T}d(s,t)^2}

    where :math:`u` is the newly joined cluster consisting of
    clusters :math:`s` and :math:`t`, :math:`v` is an unused
    cluster in the forest, :math:`T=|v|+|s|+|t|`, and
    :math:`|*|` is the cardinality of its argument. This is also
    known as the incremental algorithm.
</pre> <div class="fragment"><div class="line"><span class="lineno">  172</span><span class="keyword">def </span>ward_tree(X, *, connectivity=None, n_clusters=None, return_distance=False):</div>
<div class="line"><span class="lineno">  173</span>    <span class="stringliteral">&quot;&quot;&quot;Ward clustering based on a Feature matrix.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    Recursively merges the pair of clusters that minimally increases</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    within-cluster variance.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    The inertia matrix uses a Heapq-based representation.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    This is the structured version, that takes into account some topological</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    structure between samples.</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;hierarchical_clustering&gt;`.</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        Feature matrix representing `n_samples` samples to be clustered.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    connectivity : sparse matrix, default=None</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">        Connectivity matrix. Defines for each sample the neighboring samples</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        following a given structure of the data. The matrix is assumed to</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        be symmetric and only the upper triangular half is used.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">        Default is None, i.e, the Ward algorithm is unstructured.</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    n_clusters : int, default=None</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        `n_clusters` should be less than `n_samples`.  Stop early the</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">        construction of the tree at `n_clusters.` This is useful to decrease</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">        computation time if the number of clusters is not small compared to the</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        number of samples. In this case, the complete tree is not computed, thus</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        the &#39;children&#39; output is of limited use, and the &#39;parents&#39; output should</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        rather be used. This option is valid only when specifying a connectivity</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        matrix.</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    return_distance : bool, default=False</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        If `True`, return the distance between the clusters.</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    children : ndarray of shape (n_nodes-1, 2)</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        The children of each non-leaf node. Values less than `n_samples`</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        correspond to leaves of the tree which are the original samples.</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        A node `i` greater than or equal to `n_samples` is a non-leaf</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        node and has children `children_[i - n_samples]`. Alternatively</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        at the i-th iteration, children[i][0] and children[i][1]</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        are merged to form node `n_samples + i`.</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    n_connected_components : int</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        The number of connected components in the graph.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    n_leaves : int</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        The number of leaves in the tree.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    parents : ndarray of shape (n_nodes,) or None</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">        The parent of each node. Only returned when a connectivity matrix</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        is specified, elsewhere &#39;None&#39; is returned.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    distances : ndarray of shape (n_nodes-1,)</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        Only returned if `return_distance` is set to `True` (for compatibility).</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        The distances between the centers of the nodes. `distances[i]`</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        corresponds to a weighted Euclidean distance between</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        the nodes `children[i, 1]` and `children[i, 2]`. If the nodes refer to</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        leaves of the tree, then `distances[i]` is their unweighted Euclidean</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        distance. Distances are updated in the following way</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">        (from scipy.hierarchy.linkage):</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        The new entry :math:`d(u,v)` is computed as follows,</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">           d(u,v) = \\sqrt{\\frac{|v|+|s|}</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">                               {T}d(v,s)^2</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">                        + \\frac{|v|+|t|}</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">                               {T}d(v,t)^2</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">                        - \\frac{|v|}</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">                               {T}d(s,t)^2}</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        where :math:`u` is the newly joined cluster consisting of</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        clusters :math:`s` and :math:`t`, :math:`v` is an unused</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">        cluster in the forest, :math:`T=|v|+|s|+|t|`, and</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        :math:`|*|` is the cardinality of its argument. This is also</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        known as the incremental algorithm.</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  254</span>    X = np.asarray(X)</div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">if</span> X.ndim == 1:</div>
<div class="line"><span class="lineno">  256</span>        X = np.reshape(X, (-1, 1))</div>
<div class="line"><span class="lineno">  257</span>    n_samples, n_features = X.shape</div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>    <span class="keywordflow">if</span> connectivity <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  260</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1cluster.html">scipy.cluster</a> <span class="keyword">import</span> hierarchy  <span class="comment"># imports PIL</span></div>
<div class="line"><span class="lineno">  261</span> </div>
<div class="line"><span class="lineno">  262</span>        <span class="keywordflow">if</span> n_clusters <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  263</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  264</span>                <span class="stringliteral">&quot;Partial build of the tree is implemented &quot;</span></div>
<div class="line"><span class="lineno">  265</span>                <span class="stringliteral">&quot;only for structured clustering (i.e. with &quot;</span></div>
<div class="line"><span class="lineno">  266</span>                <span class="stringliteral">&quot;explicit connectivity). The algorithm &quot;</span></div>
<div class="line"><span class="lineno">  267</span>                <span class="stringliteral">&quot;will build the full tree and only &quot;</span></div>
<div class="line"><span class="lineno">  268</span>                <span class="stringliteral">&quot;retain the lower branches required &quot;</span></div>
<div class="line"><span class="lineno">  269</span>                <span class="stringliteral">&quot;for the specified number of clusters&quot;</span>,</div>
<div class="line"><span class="lineno">  270</span>                stacklevel=2,</div>
<div class="line"><span class="lineno">  271</span>            )</div>
<div class="line"><span class="lineno">  272</span>        X = np.require(X, requirements=<span class="stringliteral">&quot;W&quot;</span>)</div>
<div class="line"><span class="lineno">  273</span>        out = hierarchy.ward(X)</div>
<div class="line"><span class="lineno">  274</span>        children_ = out[:, :2].astype(np.intp)</div>
<div class="line"><span class="lineno">  275</span> </div>
<div class="line"><span class="lineno">  276</span>        <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  277</span>            distances = out[:, 2]</div>
<div class="line"><span class="lineno">  278</span>            <span class="keywordflow">return</span> children_, 1, n_samples, <span class="keywordtype">None</span>, distances</div>
<div class="line"><span class="lineno">  279</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  280</span>            <span class="keywordflow">return</span> children_, 1, n_samples, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  281</span> </div>
<div class="line"><span class="lineno">  282</span>    connectivity, n_connected_components = _fix_connectivity(</div>
<div class="line"><span class="lineno">  283</span>        X, connectivity, affinity=<span class="stringliteral">&quot;euclidean&quot;</span></div>
<div class="line"><span class="lineno">  284</span>    )</div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">if</span> n_clusters <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  286</span>        n_nodes = 2 * n_samples - 1</div>
<div class="line"><span class="lineno">  287</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  288</span>        <span class="keywordflow">if</span> n_clusters &gt; n_samples:</div>
<div class="line"><span class="lineno">  289</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  290</span>                <span class="stringliteral">&quot;Cannot provide more clusters than samples. &quot;</span></div>
<div class="line"><span class="lineno">  291</span>                <span class="stringliteral">&quot;%i n_clusters was asked, and there are %i &quot;</span></div>
<div class="line"><span class="lineno">  292</span>                <span class="stringliteral">&quot;samples.&quot;</span> % (n_clusters, n_samples)</div>
<div class="line"><span class="lineno">  293</span>            )</div>
<div class="line"><span class="lineno">  294</span>        n_nodes = 2 * n_samples - n_clusters</div>
<div class="line"><span class="lineno">  295</span> </div>
<div class="line"><span class="lineno">  296</span>    <span class="comment"># create inertia matrix</span></div>
<div class="line"><span class="lineno">  297</span>    coord_row = []</div>
<div class="line"><span class="lineno">  298</span>    coord_col = []</div>
<div class="line"><span class="lineno">  299</span>    A = []</div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">for</span> ind, row <span class="keywordflow">in</span> enumerate(connectivity.rows):</div>
<div class="line"><span class="lineno">  301</span>        A.append(row)</div>
<div class="line"><span class="lineno">  302</span>        <span class="comment"># We keep only the upper triangular for the moments</span></div>
<div class="line"><span class="lineno">  303</span>        <span class="comment"># Generator expressions are faster than arrays on the following</span></div>
<div class="line"><span class="lineno">  304</span>        row = [i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> row <span class="keywordflow">if</span> i &lt; ind]</div>
<div class="line"><span class="lineno">  305</span>        coord_row.extend(</div>
<div class="line"><span class="lineno">  306</span>            len(row)</div>
<div class="line"><span class="lineno">  307</span>            * [</div>
<div class="line"><span class="lineno">  308</span>                ind,</div>
<div class="line"><span class="lineno">  309</span>            ]</div>
<div class="line"><span class="lineno">  310</span>        )</div>
<div class="line"><span class="lineno">  311</span>        coord_col.extend(row)</div>
<div class="line"><span class="lineno">  312</span> </div>
<div class="line"><span class="lineno">  313</span>    coord_row = np.array(coord_row, dtype=np.intp, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  314</span>    coord_col = np.array(coord_col, dtype=np.intp, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span>    <span class="comment"># build moments as a list</span></div>
<div class="line"><span class="lineno">  317</span>    moments_1 = np.zeros(n_nodes, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  318</span>    moments_1[:n_samples] = 1</div>
<div class="line"><span class="lineno">  319</span>    moments_2 = np.zeros((n_nodes, n_features), order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  320</span>    moments_2[:n_samples] = X</div>
<div class="line"><span class="lineno">  321</span>    inertia = np.empty(len(coord_row), dtype=np.float64, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  322</span>    _hierarchical.compute_ward_dist(moments_1, moments_2, coord_row, coord_col, inertia)</div>
<div class="line"><span class="lineno">  323</span>    inertia = list(zip(inertia, coord_row, coord_col))</div>
<div class="line"><span class="lineno">  324</span>    heapify(inertia)</div>
<div class="line"><span class="lineno">  325</span> </div>
<div class="line"><span class="lineno">  326</span>    <span class="comment"># prepare the main fields</span></div>
<div class="line"><span class="lineno">  327</span>    parent = np.arange(n_nodes, dtype=np.intp)</div>
<div class="line"><span class="lineno">  328</span>    used_node = np.ones(n_nodes, dtype=bool)</div>
<div class="line"><span class="lineno">  329</span>    children = []</div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  331</span>        distances = np.empty(n_nodes - n_samples)</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>    not_visited = np.empty(n_nodes, dtype=np.int8, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  334</span> </div>
<div class="line"><span class="lineno">  335</span>    <span class="comment"># recursive merge loop</span></div>
<div class="line"><span class="lineno">  336</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(n_samples, n_nodes):</div>
<div class="line"><span class="lineno">  337</span>        <span class="comment"># identify the merge</span></div>
<div class="line"><span class="lineno">  338</span>        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  339</span>            inert, i, j = heappop(inertia)</div>
<div class="line"><span class="lineno">  340</span>            <span class="keywordflow">if</span> used_node[i] <span class="keywordflow">and</span> used_node[j]:</div>
<div class="line"><span class="lineno">  341</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  342</span>        parent[i], parent[j] = k, k</div>
<div class="line"><span class="lineno">  343</span>        children.append((i, j))</div>
<div class="line"><span class="lineno">  344</span>        used_node[i] = used_node[j] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  345</span>        <span class="keywordflow">if</span> return_distance:  <span class="comment"># store inertia value</span></div>
<div class="line"><span class="lineno">  346</span>            distances[k - n_samples] = inert</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>        <span class="comment"># update the moments</span></div>
<div class="line"><span class="lineno">  349</span>        moments_1[k] = moments_1[i] + moments_1[j]</div>
<div class="line"><span class="lineno">  350</span>        moments_2[k] = moments_2[i] + moments_2[j]</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>        <span class="comment"># update the structure matrix A and the inertia matrix</span></div>
<div class="line"><span class="lineno">  353</span>        coord_col = []</div>
<div class="line"><span class="lineno">  354</span>        not_visited.fill(1)</div>
<div class="line"><span class="lineno">  355</span>        not_visited[k] = 0</div>
<div class="line"><span class="lineno">  356</span>        _hierarchical._get_parents(A[i], coord_col, parent, not_visited)</div>
<div class="line"><span class="lineno">  357</span>        _hierarchical._get_parents(A[j], coord_col, parent, not_visited)</div>
<div class="line"><span class="lineno">  358</span>        <span class="comment"># List comprehension is faster than a for loop</span></div>
<div class="line"><span class="lineno">  359</span>        [A[col].append(k) <span class="keywordflow">for</span> col <span class="keywordflow">in</span> coord_col]</div>
<div class="line"><span class="lineno">  360</span>        A.append(coord_col)</div>
<div class="line"><span class="lineno">  361</span>        coord_col = np.array(coord_col, dtype=np.intp, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  362</span>        coord_row = np.empty(coord_col.shape, dtype=np.intp, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  363</span>        coord_row.fill(k)</div>
<div class="line"><span class="lineno">  364</span>        n_additions = len(coord_row)</div>
<div class="line"><span class="lineno">  365</span>        ini = np.empty(n_additions, dtype=np.float64, order=<span class="stringliteral">&quot;C&quot;</span>)</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span>        _hierarchical.compute_ward_dist(moments_1, moments_2, coord_row, coord_col, ini)</div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span>        <span class="comment"># List comprehension is faster than a for loop</span></div>
<div class="line"><span class="lineno">  370</span>        [heappush(inertia, (ini[idx], k, coord_col[idx])) <span class="keywordflow">for</span> idx <span class="keywordflow">in</span> range(n_additions)]</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span>    <span class="comment"># Separate leaves in children (empty lists up to now)</span></div>
<div class="line"><span class="lineno">  373</span>    n_leaves = n_samples</div>
<div class="line"><span class="lineno">  374</span>    <span class="comment"># sort children to get consistent output with unstructured version</span></div>
<div class="line"><span class="lineno">  375</span>    children = [c[::-1] <span class="keywordflow">for</span> c <span class="keywordflow">in</span> children]</div>
<div class="line"><span class="lineno">  376</span>    children = np.array(children)  <span class="comment"># return numpy array for efficient caching</span></div>
<div class="line"><span class="lineno">  377</span> </div>
<div class="line"><span class="lineno">  378</span>    <span class="keywordflow">if</span> return_distance:</div>
<div class="line"><span class="lineno">  379</span>        <span class="comment"># 2 is scaling factor to compare w/ unstructured version</span></div>
<div class="line"><span class="lineno">  380</span>        distances = np.sqrt(2.0 * distances)</div>
<div class="line"><span class="lineno">  381</span>        <span class="keywordflow">return</span> children, n_connected_components, n_leaves, parent, distances</div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  383</span>        <span class="keywordflow">return</span> children, n_connected_components, n_leaves, parent</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span> </div>
<div class="line"><span class="lineno">  386</span><span class="comment"># single average and complete linkage</span></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2b1947c000f96fb6a39bbaafc58697aa" name="a2b1947c000f96fb6a39bbaafc58697aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1947c000f96fb6a39bbaafc58697aa">&#9670;&#160;</a></span>_TREE_BUILDERS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._TREE_BUILDERS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  dict(</div>
<div class="line"><span class="lineno">    2</span>    ward=ward_tree,</div>
<div class="line"><span class="lineno">    3</span>    complete=_complete_linkage,</div>
<div class="line"><span class="lineno">    4</span>    average=_average_linkage,</div>
<div class="line"><span class="lineno">    5</span>    single=_single_linkage,</div>
<div class="line"><span class="lineno">    6</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
