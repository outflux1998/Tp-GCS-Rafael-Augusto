<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.cluster._kmeans Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html">_kmeans</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.cluster._kmeans Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__kmeans_1_1___base_k_means.html">_BaseKMeans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__kmeans_1_1_k_means.html">KMeans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1cluster_1_1__kmeans_1_1_mini_batch_k_means.html">MiniBatchKMeans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a705c640615be3435c8c74a10b6e636d3" id="r_a705c640615be3435c8c74a10b6e636d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#a705c640615be3435c8c74a10b6e636d3">kmeans_plusplus</a> (X, n_clusters, *x_squared_norms=None, random_state=None, n_local_trials=None)</td></tr>
<tr class="memdesc:a705c640615be3435c8c74a10b6e636d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization heuristic.  <br /></td></tr>
<tr class="separator:a705c640615be3435c8c74a10b6e636d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbc74b35a26395a9fb4488f18f9870d" id="r_a8dbc74b35a26395a9fb4488f18f9870d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#a8dbc74b35a26395a9fb4488f18f9870d">_kmeans_plusplus</a> (X, n_clusters, x_squared_norms, random_state, n_local_trials=None)</td></tr>
<tr class="separator:a8dbc74b35a26395a9fb4488f18f9870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0356aeee2ae6949ea63f88544e6c001c" id="r_a0356aeee2ae6949ea63f88544e6c001c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#a0356aeee2ae6949ea63f88544e6c001c">_tolerance</a> (X, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>)</td></tr>
<tr class="memdesc:a0356aeee2ae6949ea63f88544e6c001c"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-means batch estimation by EM (expectation maximization)  <br /></td></tr>
<tr class="separator:a0356aeee2ae6949ea63f88544e6c001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb89c688c2f4117534b6702993e82f58" id="r_afb89c688c2f4117534b6702993e82f58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#afb89c688c2f4117534b6702993e82f58">k_means</a> (X, n_clusters, *sample_weight=None, init=&quot;k-means++&quot;, n_init=&quot;warn&quot;, max_iter=300, verbose=False, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-4, random_state=None, copy_x=True, algorithm=&quot;lloyd&quot;, return_n_iter=False)</td></tr>
<tr class="separator:afb89c688c2f4117534b6702993e82f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb8b78ac11a704cb89b6e39861434a1" id="r_afbb8b78ac11a704cb89b6e39861434a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#afbb8b78ac11a704cb89b6e39861434a1">_kmeans_single_elkan</a> (X, sample_weight, centers_init, max_iter=300, verbose=False, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-4, n_threads=1)</td></tr>
<tr class="separator:afbb8b78ac11a704cb89b6e39861434a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0ac50b409c45c08e0df1b7395caf84" id="r_a4a0ac50b409c45c08e0df1b7395caf84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#a4a0ac50b409c45c08e0df1b7395caf84">_kmeans_single_lloyd</a> (X, sample_weight, centers_init, max_iter=300, verbose=False, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-4, n_threads=1)</td></tr>
<tr class="separator:a4a0ac50b409c45c08e0df1b7395caf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84655647c43732303456d530f53626a7" id="r_a84655647c43732303456d530f53626a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#a84655647c43732303456d530f53626a7">_labels_inertia</a> (X, sample_weight, centers, n_threads=1, return_inertia=True)</td></tr>
<tr class="separator:a84655647c43732303456d530f53626a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aefcf8e4a6ef78e7ebdec66cef692d" id="r_ae6aefcf8e4a6ef78e7ebdec66cef692d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#ae6aefcf8e4a6ef78e7ebdec66cef692d">_labels_inertia_threadpool_limit</a> (X, sample_weight, centers, n_threads=1, return_inertia=True)</td></tr>
<tr class="separator:ae6aefcf8e4a6ef78e7ebdec66cef692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6f192df3fc71b46fb71270278cbdb8" id="r_ace6f192df3fc71b46fb71270278cbdb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1cluster_1_1__kmeans.html#ace6f192df3fc71b46fb71270278cbdb8">_mini_batch_step</a> (X, sample_weight, centers, centers_new, weight_sums, random_state, random_reassign=False, reassignment_ratio=0.01, verbose=False, n_threads=1)</td></tr>
<tr class="separator:ace6f192df3fc71b46fb71270278cbdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">K-means clustering.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a8dbc74b35a26395a9fb4488f18f9870d" name="a8dbc74b35a26395a9fb4488f18f9870d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbc74b35a26395a9fb4488f18f9870d">&#9670;&#160;</a></span>_kmeans_plusplus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans._kmeans_plusplus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_squared_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_local_trials</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computational component for initialization of n_clusters by
k-means++. Prior validation of data is assumed.

Parameters
----------
X : {ndarray, sparse matrix} of shape (n_samples, n_features)
    The data to pick seeds for.

n_clusters : int
    The number of seeds to choose.

x_squared_norms : ndarray of shape (n_samples,)
    Squared Euclidean norm of each data point.

random_state : RandomState instance
    The generator used to initialize the centers.
    See :term:`Glossary &lt;random_state&gt;`.

n_local_trials : int, default=None
    The number of seeding trials for each center (except the first),
    of which the one reducing inertia the most is greedily chosen.
    Set to None to make the number of trials depend logarithmically
    on the number of seeds (2+log(k)); this is the default.

Returns
-------
centers : ndarray of shape (n_clusters, n_features)
    The initial centers for k-means.

indices : ndarray of shape (n_clusters,)
    The index location of the chosen centers in the data array X. For a
    given index and center, X[index] = center.
</pre> <div class="fragment"><div class="line"><span class="lineno">  164</span><span class="keyword">def </span>_kmeans_plusplus(X, n_clusters, x_squared_norms, random_state, n_local_trials=None):</div>
<div class="line"><span class="lineno">  165</span>    <span class="stringliteral">&quot;&quot;&quot;Computational component for initialization of n_clusters by</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    k-means++. Prior validation of data is assumed.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    X : {ndarray, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        The data to pick seeds for.</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    n_clusters : int</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        The number of seeds to choose.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    x_squared_norms : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">        Squared Euclidean norm of each data point.</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    random_state : RandomState instance</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        The generator used to initialize the centers.</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    n_local_trials : int, default=None</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        The number of seeding trials for each center (except the first),</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        of which the one reducing inertia the most is greedily chosen.</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        Set to None to make the number of trials depend logarithmically</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">        on the number of seeds (2+log(k)); this is the default.</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    centers : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        The initial centers for k-means.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    indices : ndarray of shape (n_clusters,)</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        The index location of the chosen centers in the data array X. For a</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">        given index and center, X[index] = center.</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  198</span>    n_samples, n_features = X.shape</div>
<div class="line"><span class="lineno">  199</span> </div>
<div class="line"><span class="lineno">  200</span>    centers = np.empty((n_clusters, n_features), dtype=X.dtype)</div>
<div class="line"><span class="lineno">  201</span> </div>
<div class="line"><span class="lineno">  202</span>    <span class="comment"># Set the number of local seeding trials if none is given</span></div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">if</span> n_local_trials <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  204</span>        <span class="comment"># This is what Arthur/Vassilvitskii tried, but did not report</span></div>
<div class="line"><span class="lineno">  205</span>        <span class="comment"># specific results for other than mentioning in the conclusion</span></div>
<div class="line"><span class="lineno">  206</span>        <span class="comment"># that it helped.</span></div>
<div class="line"><span class="lineno">  207</span>        n_local_trials = 2 + int(np.log(n_clusters))</div>
<div class="line"><span class="lineno">  208</span> </div>
<div class="line"><span class="lineno">  209</span>    <span class="comment"># Pick first center randomly and track index of point</span></div>
<div class="line"><span class="lineno">  210</span>    center_id = random_state.randint(n_samples)</div>
<div class="line"><span class="lineno">  211</span>    indices = np.full(n_clusters, -1, dtype=int)</div>
<div class="line"><span class="lineno">  212</span>    <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno">  213</span>        centers[0] = X[center_id].toarray()</div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  215</span>        centers[0] = X[center_id]</div>
<div class="line"><span class="lineno">  216</span>    indices[0] = center_id</div>
<div class="line"><span class="lineno">  217</span> </div>
<div class="line"><span class="lineno">  218</span>    <span class="comment"># Initialize list of closest distances and calculate current potential</span></div>
<div class="line"><span class="lineno">  219</span>    closest_dist_sq = _euclidean_distances(</div>
<div class="line"><span class="lineno">  220</span>        centers[0, np.newaxis], X, Y_norm_squared=x_squared_norms, squared=<span class="keyword">True</span></div>
<div class="line"><span class="lineno">  221</span>    )</div>
<div class="line"><span class="lineno">  222</span>    current_pot = closest_dist_sq.sum()</div>
<div class="line"><span class="lineno">  223</span> </div>
<div class="line"><span class="lineno">  224</span>    <span class="comment"># Pick the remaining n_clusters-1 points</span></div>
<div class="line"><span class="lineno">  225</span>    <span class="keywordflow">for</span> c <span class="keywordflow">in</span> range(1, n_clusters):</div>
<div class="line"><span class="lineno">  226</span>        <span class="comment"># Choose center candidates by sampling with probability proportional</span></div>
<div class="line"><span class="lineno">  227</span>        <span class="comment"># to the squared distance to the closest existing center</span></div>
<div class="line"><span class="lineno">  228</span>        rand_vals = random_state.uniform(size=n_local_trials) * current_pot</div>
<div class="line"><span class="lineno">  229</span>        candidate_ids = np.searchsorted(stable_cumsum(closest_dist_sq), rand_vals)</div>
<div class="line"><span class="lineno">  230</span>        <span class="comment"># XXX: numerical imprecision can result in a candidate_id out of range</span></div>
<div class="line"><span class="lineno">  231</span>        np.clip(candidate_ids, <span class="keywordtype">None</span>, closest_dist_sq.size - 1, out=candidate_ids)</div>
<div class="line"><span class="lineno">  232</span> </div>
<div class="line"><span class="lineno">  233</span>        <span class="comment"># Compute distances to center candidates</span></div>
<div class="line"><span class="lineno">  234</span>        distance_to_candidates = _euclidean_distances(</div>
<div class="line"><span class="lineno">  235</span>            X[candidate_ids], X, Y_norm_squared=x_squared_norms, squared=<span class="keyword">True</span></div>
<div class="line"><span class="lineno">  236</span>        )</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>        <span class="comment"># update closest distances squared and potential for each candidate</span></div>
<div class="line"><span class="lineno">  239</span>        np.minimum(closest_dist_sq, distance_to_candidates, out=distance_to_candidates)</div>
<div class="line"><span class="lineno">  240</span>        candidates_pot = distance_to_candidates.sum(axis=1)</div>
<div class="line"><span class="lineno">  241</span> </div>
<div class="line"><span class="lineno">  242</span>        <span class="comment"># Decide which candidate is the best</span></div>
<div class="line"><span class="lineno">  243</span>        best_candidate = np.argmin(candidates_pot)</div>
<div class="line"><span class="lineno">  244</span>        current_pot = candidates_pot[best_candidate]</div>
<div class="line"><span class="lineno">  245</span>        closest_dist_sq = distance_to_candidates[best_candidate]</div>
<div class="line"><span class="lineno">  246</span>        best_candidate = candidate_ids[best_candidate]</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span>        <span class="comment"># Permanently add best center candidate found in local tries</span></div>
<div class="line"><span class="lineno">  249</span>        <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno">  250</span>            centers[c] = X[best_candidate].toarray()</div>
<div class="line"><span class="lineno">  251</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  252</span>            centers[c] = X[best_candidate]</div>
<div class="line"><span class="lineno">  253</span>        indices[c] = best_candidate</div>
<div class="line"><span class="lineno">  254</span> </div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">return</span> centers, indices</div>
<div class="line"><span class="lineno">  256</span> </div>
<div class="line"><span class="lineno">  257</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afbb8b78ac11a704cb89b6e39861434a1" name="afbb8b78ac11a704cb89b6e39861434a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb8b78ac11a704cb89b6e39861434a1">&#9670;&#160;</a></span>_kmeans_single_elkan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans._kmeans_single_elkan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centers_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>300</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A single run of k-means elkan, assumes preparation completed prior.

Parameters
----------
X : {ndarray, sparse matrix} of shape (n_samples, n_features)
    The observations to cluster. If sparse matrix, must be in CSR format.

sample_weight : array-like of shape (n_samples,)
    The weights for each observation in X.

centers_init : ndarray of shape (n_clusters, n_features)
    The initial centers.

max_iter : int, default=300
    Maximum number of iterations of the k-means algorithm to run.

verbose : bool, default=False
    Verbosity mode.

tol : float, default=1e-4
    Relative tolerance with regards to Frobenius norm of the difference
    in the cluster centers of two consecutive iterations to declare
    convergence.
    It's not advised to set `tol=0` since convergence might never be
    declared due to rounding errors. Use a very small number instead.

n_threads : int, default=1
    The number of OpenMP threads to use for the computation. Parallelism is
    sample-wise on the main cython loop which assigns each sample to its
    closest center.

Returns
-------
centroid : ndarray of shape (n_clusters, n_features)
    Centroids found at the last iteration of k-means.

label : ndarray of shape (n_samples,)
    label[i] is the code or index of the centroid the
    i'th observation is closest to.

inertia : float
    The final value of the inertia criterion (sum of squared distances to
    the closest centroid for all observations in the training set).

n_iter : int
    Number of iterations run.
</pre> <div class="fragment"><div class="line"><span class="lineno">  445</span>):</div>
<div class="line"><span class="lineno">  446</span>    <span class="stringliteral">&quot;&quot;&quot;A single run of k-means elkan, assumes preparation completed prior.</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    X : {ndarray, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        The observations to cluster. If sparse matrix, must be in CSR format.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    sample_weight : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">        The weights for each observation in X.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    centers_init : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">        The initial centers.</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    max_iter : int, default=300</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        Maximum number of iterations of the k-means algorithm to run.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    verbose : bool, default=False</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        Verbosity mode.</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    tol : float, default=1e-4</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">        Relative tolerance with regards to Frobenius norm of the difference</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        in the cluster centers of two consecutive iterations to declare</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        convergence.</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        It&#39;s not advised to set `tol=0` since convergence might never be</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        declared due to rounding errors. Use a very small number instead.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    n_threads : int, default=1</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        The number of OpenMP threads to use for the computation. Parallelism is</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        sample-wise on the main cython loop which assigns each sample to its</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        closest center.</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    centroid : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        Centroids found at the last iteration of k-means.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    label : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        label[i] is the code or index of the centroid the</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        i&#39;th observation is closest to.</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    inertia : float</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        The final value of the inertia criterion (sum of squared distances to</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        the closest centroid for all observations in the training set).</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    n_iter : int</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        Number of iterations run.</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  493</span>    n_samples = X.shape[0]</div>
<div class="line"><span class="lineno">  494</span>    n_clusters = centers_init.shape[0]</div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span>    <span class="comment"># Buffers to avoid new allocations at each iteration.</span></div>
<div class="line"><span class="lineno">  497</span>    centers = centers_init</div>
<div class="line"><span class="lineno">  498</span>    centers_new = np.zeros_like(centers)</div>
<div class="line"><span class="lineno">  499</span>    weight_in_clusters = np.zeros(n_clusters, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  500</span>    labels = np.full(n_samples, -1, dtype=np.int32)</div>
<div class="line"><span class="lineno">  501</span>    labels_old = labels.copy()</div>
<div class="line"><span class="lineno">  502</span>    center_half_distances = euclidean_distances(centers) / 2</div>
<div class="line"><span class="lineno">  503</span>    distance_next_center = np.partition(</div>
<div class="line"><span class="lineno">  504</span>        np.asarray(center_half_distances), kth=1, axis=0</div>
<div class="line"><span class="lineno">  505</span>    )[1]</div>
<div class="line"><span class="lineno">  506</span>    upper_bounds = np.zeros(n_samples, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  507</span>    lower_bounds = np.zeros((n_samples, n_clusters), dtype=X.dtype)</div>
<div class="line"><span class="lineno">  508</span>    center_shift = np.zeros(n_clusters, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  509</span> </div>
<div class="line"><span class="lineno">  510</span>    <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno">  511</span>        init_bounds = init_bounds_sparse</div>
<div class="line"><span class="lineno">  512</span>        elkan_iter = elkan_iter_chunked_sparse</div>
<div class="line"><span class="lineno">  513</span>        _inertia = _inertia_sparse</div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  515</span>        init_bounds = init_bounds_dense</div>
<div class="line"><span class="lineno">  516</span>        elkan_iter = elkan_iter_chunked_dense</div>
<div class="line"><span class="lineno">  517</span>        _inertia = _inertia_dense</div>
<div class="line"><span class="lineno">  518</span> </div>
<div class="line"><span class="lineno">  519</span>    init_bounds(</div>
<div class="line"><span class="lineno">  520</span>        X,</div>
<div class="line"><span class="lineno">  521</span>        centers,</div>
<div class="line"><span class="lineno">  522</span>        center_half_distances,</div>
<div class="line"><span class="lineno">  523</span>        labels,</div>
<div class="line"><span class="lineno">  524</span>        upper_bounds,</div>
<div class="line"><span class="lineno">  525</span>        lower_bounds,</div>
<div class="line"><span class="lineno">  526</span>        n_threads=n_threads,</div>
<div class="line"><span class="lineno">  527</span>    )</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>    strict_convergence = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(max_iter):</div>
<div class="line"><span class="lineno">  532</span>        elkan_iter(</div>
<div class="line"><span class="lineno">  533</span>            X,</div>
<div class="line"><span class="lineno">  534</span>            sample_weight,</div>
<div class="line"><span class="lineno">  535</span>            centers,</div>
<div class="line"><span class="lineno">  536</span>            centers_new,</div>
<div class="line"><span class="lineno">  537</span>            weight_in_clusters,</div>
<div class="line"><span class="lineno">  538</span>            center_half_distances,</div>
<div class="line"><span class="lineno">  539</span>            distance_next_center,</div>
<div class="line"><span class="lineno">  540</span>            upper_bounds,</div>
<div class="line"><span class="lineno">  541</span>            lower_bounds,</div>
<div class="line"><span class="lineno">  542</span>            labels,</div>
<div class="line"><span class="lineno">  543</span>            center_shift,</div>
<div class="line"><span class="lineno">  544</span>            n_threads,</div>
<div class="line"><span class="lineno">  545</span>        )</div>
<div class="line"><span class="lineno">  546</span> </div>
<div class="line"><span class="lineno">  547</span>        <span class="comment"># compute new pairwise distances between centers and closest other</span></div>
<div class="line"><span class="lineno">  548</span>        <span class="comment"># center of each center for next iterations</span></div>
<div class="line"><span class="lineno">  549</span>        center_half_distances = euclidean_distances(centers_new) / 2</div>
<div class="line"><span class="lineno">  550</span>        distance_next_center = np.partition(</div>
<div class="line"><span class="lineno">  551</span>            np.asarray(center_half_distances), kth=1, axis=0</div>
<div class="line"><span class="lineno">  552</span>        )[1]</div>
<div class="line"><span class="lineno">  553</span> </div>
<div class="line"><span class="lineno">  554</span>        <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  555</span>            inertia = _inertia(X, sample_weight, centers, labels, n_threads)</div>
<div class="line"><span class="lineno">  556</span>            print(f<span class="stringliteral">&quot;Iteration {i}, inertia {inertia}&quot;</span>)</div>
<div class="line"><span class="lineno">  557</span> </div>
<div class="line"><span class="lineno">  558</span>        centers, centers_new = centers_new, centers</div>
<div class="line"><span class="lineno">  559</span> </div>
<div class="line"><span class="lineno">  560</span>        <span class="keywordflow">if</span> np.array_equal(labels, labels_old):</div>
<div class="line"><span class="lineno">  561</span>            <span class="comment"># First check the labels for strict convergence.</span></div>
<div class="line"><span class="lineno">  562</span>            <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  563</span>                print(f<span class="stringliteral">&quot;Converged at iteration {i}: strict convergence.&quot;</span>)</div>
<div class="line"><span class="lineno">  564</span>            strict_convergence = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  565</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  566</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  567</span>            <span class="comment"># No strict convergence, check for tol based convergence.</span></div>
<div class="line"><span class="lineno">  568</span>            center_shift_tot = (center_shift**2).sum()</div>
<div class="line"><span class="lineno">  569</span>            <span class="keywordflow">if</span> center_shift_tot &lt;= tol:</div>
<div class="line"><span class="lineno">  570</span>                <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  571</span>                    print(</div>
<div class="line"><span class="lineno">  572</span>                        f<span class="stringliteral">&quot;Converged at iteration {i}: center shift &quot;</span></div>
<div class="line"><span class="lineno">  573</span>                        f<span class="stringliteral">&quot;{center_shift_tot} within tolerance {tol}.&quot;</span></div>
<div class="line"><span class="lineno">  574</span>                    )</div>
<div class="line"><span class="lineno">  575</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  576</span> </div>
<div class="line"><span class="lineno">  577</span>        labels_old[:] = labels</div>
<div class="line"><span class="lineno">  578</span> </div>
<div class="line"><span class="lineno">  579</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> strict_convergence:</div>
<div class="line"><span class="lineno">  580</span>        <span class="comment"># rerun E-step so that predicted labels match cluster centers</span></div>
<div class="line"><span class="lineno">  581</span>        elkan_iter(</div>
<div class="line"><span class="lineno">  582</span>            X,</div>
<div class="line"><span class="lineno">  583</span>            sample_weight,</div>
<div class="line"><span class="lineno">  584</span>            centers,</div>
<div class="line"><span class="lineno">  585</span>            centers,</div>
<div class="line"><span class="lineno">  586</span>            weight_in_clusters,</div>
<div class="line"><span class="lineno">  587</span>            center_half_distances,</div>
<div class="line"><span class="lineno">  588</span>            distance_next_center,</div>
<div class="line"><span class="lineno">  589</span>            upper_bounds,</div>
<div class="line"><span class="lineno">  590</span>            lower_bounds,</div>
<div class="line"><span class="lineno">  591</span>            labels,</div>
<div class="line"><span class="lineno">  592</span>            center_shift,</div>
<div class="line"><span class="lineno">  593</span>            n_threads,</div>
<div class="line"><span class="lineno">  594</span>            update_centers=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  595</span>        )</div>
<div class="line"><span class="lineno">  596</span> </div>
<div class="line"><span class="lineno">  597</span>    inertia = _inertia(X, sample_weight, centers, labels, n_threads)</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span>    <span class="keywordflow">return</span> labels, inertia, centers, i + 1</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a0ac50b409c45c08e0df1b7395caf84" name="a4a0ac50b409c45c08e0df1b7395caf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0ac50b409c45c08e0df1b7395caf84">&#9670;&#160;</a></span>_kmeans_single_lloyd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans._kmeans_single_lloyd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centers_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>300</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A single run of k-means lloyd, assumes preparation completed prior.

Parameters
----------
X : {ndarray, sparse matrix} of shape (n_samples, n_features)
    The observations to cluster. If sparse matrix, must be in CSR format.

sample_weight : ndarray of shape (n_samples,)
    The weights for each observation in X.

centers_init : ndarray of shape (n_clusters, n_features)
    The initial centers.

max_iter : int, default=300
    Maximum number of iterations of the k-means algorithm to run.

verbose : bool, default=False
    Verbosity mode

tol : float, default=1e-4
    Relative tolerance with regards to Frobenius norm of the difference
    in the cluster centers of two consecutive iterations to declare
    convergence.
    It's not advised to set `tol=0` since convergence might never be
    declared due to rounding errors. Use a very small number instead.

n_threads : int, default=1
    The number of OpenMP threads to use for the computation. Parallelism is
    sample-wise on the main cython loop which assigns each sample to its
    closest center.

Returns
-------
centroid : ndarray of shape (n_clusters, n_features)
    Centroids found at the last iteration of k-means.

label : ndarray of shape (n_samples,)
    label[i] is the code or index of the centroid the
    i'th observation is closest to.

inertia : float
    The final value of the inertia criterion (sum of squared distances to
    the closest centroid for all observations in the training set).

n_iter : int
    Number of iterations run.
</pre> <div class="fragment"><div class="line"><span class="lineno">  610</span>):</div>
<div class="line"><span class="lineno">  611</span>    <span class="stringliteral">&quot;&quot;&quot;A single run of k-means lloyd, assumes preparation completed prior.</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    X : {ndarray, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">        The observations to cluster. If sparse matrix, must be in CSR format.</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    sample_weight : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">        The weights for each observation in X.</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    centers_init : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">        The initial centers.</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    max_iter : int, default=300</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        Maximum number of iterations of the k-means algorithm to run.</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    verbose : bool, default=False</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">        Verbosity mode</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    tol : float, default=1e-4</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        Relative tolerance with regards to Frobenius norm of the difference</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">        in the cluster centers of two consecutive iterations to declare</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">        convergence.</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">        It&#39;s not advised to set `tol=0` since convergence might never be</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">        declared due to rounding errors. Use a very small number instead.</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    n_threads : int, default=1</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">        The number of OpenMP threads to use for the computation. Parallelism is</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">        sample-wise on the main cython loop which assigns each sample to its</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">        closest center.</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    centroid : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        Centroids found at the last iteration of k-means.</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    label : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">        label[i] is the code or index of the centroid the</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        i&#39;th observation is closest to.</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    inertia : float</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        The final value of the inertia criterion (sum of squared distances to</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        the closest centroid for all observations in the training set).</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    n_iter : int</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        Number of iterations run.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  658</span>    n_clusters = centers_init.shape[0]</div>
<div class="line"><span class="lineno">  659</span> </div>
<div class="line"><span class="lineno">  660</span>    <span class="comment"># Buffers to avoid new allocations at each iteration.</span></div>
<div class="line"><span class="lineno">  661</span>    centers = centers_init</div>
<div class="line"><span class="lineno">  662</span>    centers_new = np.zeros_like(centers)</div>
<div class="line"><span class="lineno">  663</span>    labels = np.full(X.shape[0], -1, dtype=np.int32)</div>
<div class="line"><span class="lineno">  664</span>    labels_old = labels.copy()</div>
<div class="line"><span class="lineno">  665</span>    weight_in_clusters = np.zeros(n_clusters, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  666</span>    center_shift = np.zeros(n_clusters, dtype=X.dtype)</div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span>    <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno">  669</span>        lloyd_iter = lloyd_iter_chunked_sparse</div>
<div class="line"><span class="lineno">  670</span>        _inertia = _inertia_sparse</div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  672</span>        lloyd_iter = lloyd_iter_chunked_dense</div>
<div class="line"><span class="lineno">  673</span>        _inertia = _inertia_dense</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span>    strict_convergence = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span>    <span class="comment"># Threadpoolctl context to limit the number of threads in second level of</span></div>
<div class="line"><span class="lineno">  678</span>    <span class="comment"># nested parallelism (i.e. BLAS) to avoid oversubscription.</span></div>
<div class="line"><span class="lineno">  679</span>    <span class="keyword">with</span> threadpool_limits(limits=1, user_api=<span class="stringliteral">&quot;blas&quot;</span>):</div>
<div class="line"><span class="lineno">  680</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(max_iter):</div>
<div class="line"><span class="lineno">  681</span>            lloyd_iter(</div>
<div class="line"><span class="lineno">  682</span>                X,</div>
<div class="line"><span class="lineno">  683</span>                sample_weight,</div>
<div class="line"><span class="lineno">  684</span>                centers,</div>
<div class="line"><span class="lineno">  685</span>                centers_new,</div>
<div class="line"><span class="lineno">  686</span>                weight_in_clusters,</div>
<div class="line"><span class="lineno">  687</span>                labels,</div>
<div class="line"><span class="lineno">  688</span>                center_shift,</div>
<div class="line"><span class="lineno">  689</span>                n_threads,</div>
<div class="line"><span class="lineno">  690</span>            )</div>
<div class="line"><span class="lineno">  691</span> </div>
<div class="line"><span class="lineno">  692</span>            <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  693</span>                inertia = _inertia(X, sample_weight, centers, labels, n_threads)</div>
<div class="line"><span class="lineno">  694</span>                print(f<span class="stringliteral">&quot;Iteration {i}, inertia {inertia}.&quot;</span>)</div>
<div class="line"><span class="lineno">  695</span> </div>
<div class="line"><span class="lineno">  696</span>            centers, centers_new = centers_new, centers</div>
<div class="line"><span class="lineno">  697</span> </div>
<div class="line"><span class="lineno">  698</span>            <span class="keywordflow">if</span> np.array_equal(labels, labels_old):</div>
<div class="line"><span class="lineno">  699</span>                <span class="comment"># First check the labels for strict convergence.</span></div>
<div class="line"><span class="lineno">  700</span>                <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  701</span>                    print(f<span class="stringliteral">&quot;Converged at iteration {i}: strict convergence.&quot;</span>)</div>
<div class="line"><span class="lineno">  702</span>                strict_convergence = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  703</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  704</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  705</span>                <span class="comment"># No strict convergence, check for tol based convergence.</span></div>
<div class="line"><span class="lineno">  706</span>                center_shift_tot = (center_shift**2).sum()</div>
<div class="line"><span class="lineno">  707</span>                <span class="keywordflow">if</span> center_shift_tot &lt;= tol:</div>
<div class="line"><span class="lineno">  708</span>                    <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno">  709</span>                        print(</div>
<div class="line"><span class="lineno">  710</span>                            f<span class="stringliteral">&quot;Converged at iteration {i}: center shift &quot;</span></div>
<div class="line"><span class="lineno">  711</span>                            f<span class="stringliteral">&quot;{center_shift_tot} within tolerance {tol}.&quot;</span></div>
<div class="line"><span class="lineno">  712</span>                        )</div>
<div class="line"><span class="lineno">  713</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  714</span> </div>
<div class="line"><span class="lineno">  715</span>            labels_old[:] = labels</div>
<div class="line"><span class="lineno">  716</span> </div>
<div class="line"><span class="lineno">  717</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> strict_convergence:</div>
<div class="line"><span class="lineno">  718</span>            <span class="comment"># rerun E-step so that predicted labels match cluster centers</span></div>
<div class="line"><span class="lineno">  719</span>            lloyd_iter(</div>
<div class="line"><span class="lineno">  720</span>                X,</div>
<div class="line"><span class="lineno">  721</span>                sample_weight,</div>
<div class="line"><span class="lineno">  722</span>                centers,</div>
<div class="line"><span class="lineno">  723</span>                centers,</div>
<div class="line"><span class="lineno">  724</span>                weight_in_clusters,</div>
<div class="line"><span class="lineno">  725</span>                labels,</div>
<div class="line"><span class="lineno">  726</span>                center_shift,</div>
<div class="line"><span class="lineno">  727</span>                n_threads,</div>
<div class="line"><span class="lineno">  728</span>                update_centers=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  729</span>            )</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span>    inertia = _inertia(X, sample_weight, centers, labels, n_threads)</div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="line"><span class="lineno">  733</span>    <span class="keywordflow">return</span> labels, inertia, centers, i + 1</div>
<div class="line"><span class="lineno">  734</span> </div>
<div class="line"><span class="lineno">  735</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a84655647c43732303456d530f53626a7" name="a84655647c43732303456d530f53626a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84655647c43732303456d530f53626a7">&#9670;&#160;</a></span>_labels_inertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans._labels_inertia </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_inertia</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">E step of the K-means EM algorithm.

Compute the labels and the inertia of the given samples and centers.

Parameters
----------
X : {ndarray, sparse matrix} of shape (n_samples, n_features)
    The input samples to assign to the labels. If sparse matrix, must
    be in CSR format.

sample_weight : ndarray of shape (n_samples,)
    The weights for each observation in X.

x_squared_norms : ndarray of shape (n_samples,)
    Precomputed squared euclidean norm of each data point, to speed up
    computations.

centers : ndarray of shape (n_clusters, n_features)
    The cluster centers.

n_threads : int, default=1
    The number of OpenMP threads to use for the computation. Parallelism is
    sample-wise on the main cython loop which assigns each sample to its
    closest center.

return_inertia : bool, default=True
    Whether to compute and return the inertia.

Returns
-------
labels : ndarray of shape (n_samples,)
    The resulting assignment.

inertia : float
    Sum of squared distances of samples to their closest cluster center.
    Inertia is only returned if return_inertia is True.
</pre> <div class="fragment"><div class="line"><span class="lineno">  736</span><span class="keyword">def </span>_labels_inertia(X, sample_weight, centers, n_threads=1, return_inertia=True):</div>
<div class="line"><span class="lineno">  737</span>    <span class="stringliteral">&quot;&quot;&quot;E step of the K-means EM algorithm.</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    Compute the labels and the inertia of the given samples and centers.</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    X : {ndarray, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        The input samples to assign to the labels. If sparse matrix, must</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        be in CSR format.</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    sample_weight : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        The weights for each observation in X.</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    x_squared_norms : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        Precomputed squared euclidean norm of each data point, to speed up</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        computations.</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    centers : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        The cluster centers.</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    n_threads : int, default=1</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">        The number of OpenMP threads to use for the computation. Parallelism is</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        sample-wise on the main cython loop which assigns each sample to its</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        closest center.</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    return_inertia : bool, default=True</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        Whether to compute and return the inertia.</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    labels : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">        The resulting assignment.</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    inertia : float</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        Sum of squared distances of samples to their closest cluster center.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">        Inertia is only returned if return_inertia is True.</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  774</span>    n_samples = X.shape[0]</div>
<div class="line"><span class="lineno">  775</span>    n_clusters = centers.shape[0]</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span>    labels = np.full(n_samples, -1, dtype=np.int32)</div>
<div class="line"><span class="lineno">  778</span>    center_shift = np.zeros(n_clusters, dtype=centers.dtype)</div>
<div class="line"><span class="lineno">  779</span> </div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno">  781</span>        _labels = lloyd_iter_chunked_sparse</div>
<div class="line"><span class="lineno">  782</span>        _inertia = _inertia_sparse</div>
<div class="line"><span class="lineno">  783</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  784</span>        _labels = lloyd_iter_chunked_dense</div>
<div class="line"><span class="lineno">  785</span>        _inertia = _inertia_dense</div>
<div class="line"><span class="lineno">  786</span>        X = ReadonlyArrayWrapper(X)</div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    centers = ReadonlyArrayWrapper(centers)</div>
<div class="line"><span class="lineno">  789</span>    _labels(</div>
<div class="line"><span class="lineno">  790</span>        X,</div>
<div class="line"><span class="lineno">  791</span>        sample_weight,</div>
<div class="line"><span class="lineno">  792</span>        centers,</div>
<div class="line"><span class="lineno">  793</span>        centers_new=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  794</span>        weight_in_clusters=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  795</span>        labels=labels,</div>
<div class="line"><span class="lineno">  796</span>        center_shift=center_shift,</div>
<div class="line"><span class="lineno">  797</span>        n_threads=n_threads,</div>
<div class="line"><span class="lineno">  798</span>        update_centers=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  799</span>    )</div>
<div class="line"><span class="lineno">  800</span> </div>
<div class="line"><span class="lineno">  801</span>    <span class="keywordflow">if</span> return_inertia:</div>
<div class="line"><span class="lineno">  802</span>        inertia = _inertia(X, sample_weight, centers, labels, n_threads)</div>
<div class="line"><span class="lineno">  803</span>        <span class="keywordflow">return</span> labels, inertia</div>
<div class="line"><span class="lineno">  804</span> </div>
<div class="line"><span class="lineno">  805</span>    <span class="keywordflow">return</span> labels</div>
<div class="line"><span class="lineno">  806</span> </div>
<div class="line"><span class="lineno">  807</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6aefcf8e4a6ef78e7ebdec66cef692d" name="ae6aefcf8e4a6ef78e7ebdec66cef692d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aefcf8e4a6ef78e7ebdec66cef692d">&#9670;&#160;</a></span>_labels_inertia_threadpool_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans._labels_inertia_threadpool_limit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_inertia</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Same as _labels_inertia but in a threadpool_limits context.</pre> <div class="fragment"><div class="line"><span class="lineno">  810</span>):</div>
<div class="line"><span class="lineno">  811</span>    <span class="stringliteral">&quot;&quot;&quot;Same as _labels_inertia but in a threadpool_limits context.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  812</span>    <span class="keyword">with</span> threadpool_limits(limits=1, user_api=<span class="stringliteral">&quot;blas&quot;</span>):</div>
<div class="line"><span class="lineno">  813</span>        result = _labels_inertia(X, sample_weight, centers, n_threads, return_inertia)</div>
<div class="line"><span class="lineno">  814</span> </div>
<div class="line"><span class="lineno">  815</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  816</span> </div>
<div class="line"><span class="lineno">  817</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ace6f192df3fc71b46fb71270278cbdb8" name="ace6f192df3fc71b46fb71270278cbdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6f192df3fc71b46fb71270278cbdb8">&#9670;&#160;</a></span>_mini_batch_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans._mini_batch_step </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centers_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_reassign</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reassignment_ratio</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Incremental update of the centers for the Minibatch K-Means algorithm.

Parameters
----------

X : {ndarray, sparse matrix} of shape (n_samples, n_features)
    The original data array. If sparse, must be in CSR format.

x_squared_norms : ndarray of shape (n_samples,)
    Squared euclidean norm of each data point.

sample_weight : ndarray of shape (n_samples,)
    The weights for each observation in X.

centers : ndarray of shape (n_clusters, n_features)
    The cluster centers before the current iteration

centers_new : ndarray of shape (n_clusters, n_features)
    The cluster centers after the current iteration. Modified in-place.

weight_sums : ndarray of shape (n_clusters,)
    The vector in which we keep track of the numbers of points in a
    cluster. This array is modified in place.

random_state : RandomState instance
    Determines random number generation for low count centers reassignment.
    See :term:`Glossary &lt;random_state&gt;`.

random_reassign : boolean, default=False
    If True, centers with very low counts are randomly reassigned
    to observations.

reassignment_ratio : float, default=0.01
    Control the fraction of the maximum number of counts for a
    center to be reassigned. A higher value means that low count
    centers are more likely to be reassigned, which means that the
    model will take longer to converge, but should converge in a
    better clustering.

verbose : bool, default=False
    Controls the verbosity.

n_threads : int, default=1
    The number of OpenMP threads to use for the computation.

Returns
-------
inertia : float
    Sum of squared distances of samples to their closest cluster center.
    The inertia is computed after finding the labels and before updating
    the centers.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1526</span>):</div>
<div class="line"><span class="lineno"> 1527</span>    <span class="stringliteral">&quot;&quot;&quot;Incremental update of the centers for the Minibatch K-Means algorithm.</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    X : {ndarray, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">        The original data array. If sparse, must be in CSR format.</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">    x_squared_norms : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">        Squared euclidean norm of each data point.</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    sample_weight : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">        The weights for each observation in X.</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    centers : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">        The cluster centers before the current iteration</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    centers_new : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">        The cluster centers after the current iteration. Modified in-place.</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    weight_sums : ndarray of shape (n_clusters,)</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">        The vector in which we keep track of the numbers of points in a</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">        cluster. This array is modified in place.</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    random_state : RandomState instance</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">        Determines random number generation for low count centers reassignment.</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">        See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    random_reassign : boolean, default=False</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">        If True, centers with very low counts are randomly reassigned</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">        to observations.</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    reassignment_ratio : float, default=0.01</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">        Control the fraction of the maximum number of counts for a</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">        center to be reassigned. A higher value means that low count</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">        centers are more likely to be reassigned, which means that the</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">        model will take longer to converge, but should converge in a</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">        better clustering.</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">    verbose : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">        Controls the verbosity.</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">    n_threads : int, default=1</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">        The number of OpenMP threads to use for the computation.</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">    inertia : float</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">        Sum of squared distances of samples to their closest cluster center.</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">        The inertia is computed after finding the labels and before updating</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">        the centers.</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1579</span>    <span class="comment"># Perform label assignment to nearest centers</span></div>
<div class="line"><span class="lineno"> 1580</span>    <span class="comment"># For better efficiency, it&#39;s better to run _mini_batch_step in a</span></div>
<div class="line"><span class="lineno"> 1581</span>    <span class="comment"># threadpool_limit context than using _labels_inertia_threadpool_limit here</span></div>
<div class="line"><span class="lineno"> 1582</span>    labels, inertia = _labels_inertia(X, sample_weight, centers, n_threads=n_threads)</div>
<div class="line"><span class="lineno"> 1583</span> </div>
<div class="line"><span class="lineno"> 1584</span>    <span class="comment"># Update centers according to the labels</span></div>
<div class="line"><span class="lineno"> 1585</span>    <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno"> 1586</span>        _minibatch_update_sparse(</div>
<div class="line"><span class="lineno"> 1587</span>            X, sample_weight, centers, centers_new, weight_sums, labels, n_threads</div>
<div class="line"><span class="lineno"> 1588</span>        )</div>
<div class="line"><span class="lineno"> 1589</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1590</span>        _minibatch_update_dense(</div>
<div class="line"><span class="lineno"> 1591</span>            ReadonlyArrayWrapper(X),</div>
<div class="line"><span class="lineno"> 1592</span>            sample_weight,</div>
<div class="line"><span class="lineno"> 1593</span>            centers,</div>
<div class="line"><span class="lineno"> 1594</span>            centers_new,</div>
<div class="line"><span class="lineno"> 1595</span>            weight_sums,</div>
<div class="line"><span class="lineno"> 1596</span>            labels,</div>
<div class="line"><span class="lineno"> 1597</span>            n_threads,</div>
<div class="line"><span class="lineno"> 1598</span>        )</div>
<div class="line"><span class="lineno"> 1599</span> </div>
<div class="line"><span class="lineno"> 1600</span>    <span class="comment"># Reassign clusters that have very low weight</span></div>
<div class="line"><span class="lineno"> 1601</span>    <span class="keywordflow">if</span> random_reassign <span class="keywordflow">and</span> reassignment_ratio &gt; 0:</div>
<div class="line"><span class="lineno"> 1602</span>        to_reassign = weight_sums &lt; reassignment_ratio * weight_sums.max()</div>
<div class="line"><span class="lineno"> 1603</span> </div>
<div class="line"><span class="lineno"> 1604</span>        <span class="comment"># pick at most .5 * batch_size samples as new centers</span></div>
<div class="line"><span class="lineno"> 1605</span>        <span class="keywordflow">if</span> to_reassign.sum() &gt; 0.5 * X.shape[0]:</div>
<div class="line"><span class="lineno"> 1606</span>            indices_dont_reassign = np.argsort(weight_sums)[int(0.5 * X.shape[0]) :]</div>
<div class="line"><span class="lineno"> 1607</span>            to_reassign[indices_dont_reassign] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1608</span>        n_reassigns = to_reassign.sum()</div>
<div class="line"><span class="lineno"> 1609</span> </div>
<div class="line"><span class="lineno"> 1610</span>        <span class="keywordflow">if</span> n_reassigns:</div>
<div class="line"><span class="lineno"> 1611</span>            <span class="comment"># Pick new clusters amongst observations with uniform probability</span></div>
<div class="line"><span class="lineno"> 1612</span>            new_centers = random_state.choice(</div>
<div class="line"><span class="lineno"> 1613</span>                X.shape[0], replace=<span class="keyword">False</span>, size=n_reassigns</div>
<div class="line"><span class="lineno"> 1614</span>            )</div>
<div class="line"><span class="lineno"> 1615</span>            <span class="keywordflow">if</span> verbose:</div>
<div class="line"><span class="lineno"> 1616</span>                print(f<span class="stringliteral">&quot;[MiniBatchKMeans] Reassigning {n_reassigns} cluster centers.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1617</span> </div>
<div class="line"><span class="lineno"> 1618</span>            <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno"> 1619</span>                assign_rows_csr(</div>
<div class="line"><span class="lineno"> 1620</span>                    X,</div>
<div class="line"><span class="lineno"> 1621</span>                    new_centers.astype(np.intp, copy=<span class="keyword">False</span>),</div>
<div class="line"><span class="lineno"> 1622</span>                    np.where(to_reassign)[0].astype(np.intp, copy=<span class="keyword">False</span>),</div>
<div class="line"><span class="lineno"> 1623</span>                    centers_new,</div>
<div class="line"><span class="lineno"> 1624</span>                )</div>
<div class="line"><span class="lineno"> 1625</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1626</span>                centers_new[to_reassign] = X[new_centers]</div>
<div class="line"><span class="lineno"> 1627</span> </div>
<div class="line"><span class="lineno"> 1628</span>        <span class="comment"># reset counts of reassigned centers, but don&#39;t reset them too small</span></div>
<div class="line"><span class="lineno"> 1629</span>        <span class="comment"># to avoid instant reassignment. This is a pretty dirty hack as it</span></div>
<div class="line"><span class="lineno"> 1630</span>        <span class="comment"># also modifies the learning rates.</span></div>
<div class="line"><span class="lineno"> 1631</span>        weight_sums[to_reassign] = np.min(weight_sums[~to_reassign])</div>
<div class="line"><span class="lineno"> 1632</span> </div>
<div class="line"><span class="lineno"> 1633</span>    <span class="keywordflow">return</span> inertia</div>
<div class="line"><span class="lineno"> 1634</span> </div>
<div class="line"><span class="lineno"> 1635</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0356aeee2ae6949ea63f88544e6c001c" name="a0356aeee2ae6949ea63f88544e6c001c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0356aeee2ae6949ea63f88544e6c001c">&#9670;&#160;</a></span>_tolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans._tolerance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>K-means batch estimation by EM (expectation maximization) </p>
<pre class="fragment">Return a tolerance which is dependent on the dataset.</pre> <div class="fragment"><div class="line"><span class="lineno">  262</span><span class="keyword">def </span>_tolerance(X, tol):</div>
<div class="line"><span class="lineno">  263</span>    <span class="stringliteral">&quot;&quot;&quot;Return a tolerance which is dependent on the dataset.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  264</span>    <span class="keywordflow">if</span> tol == 0:</div>
<div class="line"><span class="lineno">  265</span>        <span class="keywordflow">return</span> 0</div>
<div class="line"><span class="lineno">  266</span>    <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno">  267</span>        variances = mean_variance_axis(X, axis=0)[1]</div>
<div class="line"><span class="lineno">  268</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  269</span>        variances = np.var(X, axis=0)</div>
<div class="line"><span class="lineno">  270</span>    <span class="keywordflow">return</span> np.mean(variances) * tol</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  273</span><span class="preprocessor">@validate_params</span>(</div>
<div class="line"><span class="lineno">  274</span>    {</div>
<div class="line"><span class="lineno">  275</span>        <span class="stringliteral">&quot;X&quot;</span>: [<span class="stringliteral">&quot;array-like&quot;</span>, <span class="stringliteral">&quot;sparse matrix&quot;</span>],</div>
<div class="line"><span class="lineno">  276</span>        <span class="stringliteral">&quot;n_clusters&quot;</span>: [Interval(Integral, 1, <span class="keywordtype">None</span>, closed=<span class="stringliteral">&quot;left&quot;</span>)],</div>
<div class="line"><span class="lineno">  277</span>        <span class="stringliteral">&quot;sample_weight&quot;</span>: [<span class="stringliteral">&quot;array-like&quot;</span>, <span class="keywordtype">None</span>],</div>
<div class="line"><span class="lineno">  278</span>        <span class="stringliteral">&quot;init&quot;</span>: [StrOptions({<span class="stringliteral">&quot;k-means++&quot;</span>, <span class="stringliteral">&quot;random&quot;</span>}), callable, <span class="stringliteral">&quot;array-like&quot;</span>],</div>
<div class="line"><span class="lineno">  279</span>        <span class="stringliteral">&quot;n_init&quot;</span>: [</div>
<div class="line"><span class="lineno">  280</span>            StrOptions({<span class="stringliteral">&quot;auto&quot;</span>}),</div>
<div class="line"><span class="lineno">  281</span>            Hidden(StrOptions({<span class="stringliteral">&quot;warn&quot;</span>})),</div>
<div class="line"><span class="lineno">  282</span>            Interval(Integral, 1, <span class="keywordtype">None</span>, closed=<span class="stringliteral">&quot;left&quot;</span>),</div>
<div class="line"><span class="lineno">  283</span>        ],</div>
<div class="line"><span class="lineno">  284</span>        <span class="stringliteral">&quot;max_iter&quot;</span>: [Interval(Integral, 1, <span class="keywordtype">None</span>, closed=<span class="stringliteral">&quot;left&quot;</span>)],</div>
<div class="line"><span class="lineno">  285</span>        <span class="stringliteral">&quot;verbose&quot;</span>: [Interval(Integral, 0, <span class="keywordtype">None</span>, closed=<span class="stringliteral">&quot;left&quot;</span>), bool],</div>
<div class="line"><span class="lineno">  286</span>        <span class="stringliteral">&quot;tol&quot;</span>: [Interval(Real, 0, <span class="keywordtype">None</span>, closed=<span class="stringliteral">&quot;left&quot;</span>)],</div>
<div class="line"><span class="lineno">  287</span>        <span class="stringliteral">&quot;random_state&quot;</span>: [<span class="stringliteral">&quot;random_state&quot;</span>],</div>
<div class="line"><span class="lineno">  288</span>        <span class="stringliteral">&quot;copy_x&quot;</span>: [bool],</div>
<div class="line"><span class="lineno">  289</span>        <span class="stringliteral">&quot;algorithm&quot;</span>: [</div>
<div class="line"><span class="lineno">  290</span>            StrOptions({<span class="stringliteral">&quot;lloyd&quot;</span>, <span class="stringliteral">&quot;elkan&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;full&quot;</span>}, deprecated={<span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;full&quot;</span>})</div>
<div class="line"><span class="lineno">  291</span>        ],</div>
<div class="line"><span class="lineno">  292</span>        <span class="stringliteral">&quot;return_n_iter&quot;</span>: [bool],</div>
<div class="line"><span class="lineno">  293</span>    }</div>
<div class="line"><span class="lineno">  294</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="afb89c688c2f4117534b6702993e82f58" name="afb89c688c2f4117534b6702993e82f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb89c688c2f4117534b6702993e82f58">&#9670;&#160;</a></span>k_means()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans.k_means </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>sample_weight</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init</em> = <code>&quot;k-means++&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_init</em> = <code>&quot;warn&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>300</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy_x</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>&quot;lloyd&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_n_iter</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform K-means clustering algorithm.

Read more in the :ref:`User Guide &lt;k_means&gt;`.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    The observations to cluster. It must be noted that the data
    will be converted to C ordering, which will cause a memory copy
    if the given data is not C-contiguous.

n_clusters : int
    The number of clusters to form as well as the number of
    centroids to generate.

sample_weight : array-like of shape (n_samples,), default=None
    The weights for each observation in `X`. If `None`, all observations
    are assigned equal weight.

init : {'k-means++', 'random'}, callable or array-like of shape \
        (n_clusters, n_features), default='k-means++'
    Method for initialization:

    - `'k-means++'` : selects initial cluster centers for k-mean
      clustering in a smart way to speed up convergence. See section
      Notes in k_init for more details.
    - `'random'`: choose `n_clusters` observations (rows) at random from data
      for the initial centroids.
    - If an array is passed, it should be of shape `(n_clusters, n_features)`
      and gives the initial centers.
    - If a callable is passed, it should take arguments `X`, `n_clusters` and a
      random state and return an initialization.

n_init : 'auto' or int, default=10
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of
    n_init consecutive runs in terms of inertia.

    When `n_init='auto'`, the number of runs will be 10 if using
    `init='random'`, and 1 if using `init='kmeans++'`.

    .. versionadded:: 1.2
       Added 'auto' option for `n_init`.

    .. versionchanged:: 1.4
       Default value for `n_init` will change from 10 to `'auto'` in version 1.4.

max_iter : int, default=300
    Maximum number of iterations of the k-means algorithm to run.

verbose : bool, default=False
    Verbosity mode.

tol : float, default=1e-4
    Relative tolerance with regards to Frobenius norm of the difference
    in the cluster centers of two consecutive iterations to declare
    convergence.

random_state : int, RandomState instance or None, default=None
    Determines random number generation for centroid initialization. Use
    an int to make the randomness deterministic.
    See :term:`Glossary &lt;random_state&gt;`.

copy_x : bool, default=True
    When pre-computing distances it is more numerically accurate to center
    the data first. If `copy_x` is True (default), then the original data is
    not modified. If False, the original data is modified, and put back
    before the function returns, but small numerical differences may be
    introduced by subtracting and then adding the data mean. Note that if
    the original data is not C-contiguous, a copy will be made even if
    `copy_x` is False. If the original data is sparse, but not in CSR format,
    a copy will be made even if `copy_x` is False.

algorithm : {"lloyd", "elkan", "auto", "full"}, default="lloyd"
    K-means algorithm to use. The classical EM-style algorithm is `"lloyd"`.
    The `"elkan"` variation can be more efficient on some datasets with
    well-defined clusters, by using the triangle inequality. However it's
    more memory intensive due to the allocation of an extra array of shape
    `(n_samples, n_clusters)`.

    `"auto"` and `"full"` are deprecated and they will be removed in
    Scikit-Learn 1.3. They are both aliases for `"lloyd"`.

    .. versionchanged:: 0.18
        Added Elkan algorithm

    .. versionchanged:: 1.1
        Renamed "full" to "lloyd", and deprecated "auto" and "full".
        Changed "auto" to use "lloyd" instead of "elkan".

return_n_iter : bool, default=False
    Whether or not to return the number of iterations.

Returns
-------
centroid : ndarray of shape (n_clusters, n_features)
    Centroids found at the last iteration of k-means.

label : ndarray of shape (n_samples,)
    The `label[i]` is the code or index of the centroid the
    i'th observation is closest to.

inertia : float
    The final value of the inertia criterion (sum of squared distances to
    the closest centroid for all observations in the training set).

best_n_iter : int
    Number of iterations corresponding to the best results.
    Returned only if `return_n_iter` is set to True.
</pre> <div class="fragment"><div class="line"><span class="lineno">  309</span>):</div>
<div class="line"><span class="lineno">  310</span>    <span class="stringliteral">&quot;&quot;&quot;Perform K-means clustering algorithm.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;k_means&gt;`.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        The observations to cluster. It must be noted that the data</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        will be converted to C ordering, which will cause a memory copy</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        if the given data is not C-contiguous.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    n_clusters : int</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">        The number of clusters to form as well as the number of</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">        centroids to generate.</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    sample_weight : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">        The weights for each observation in `X`. If `None`, all observations</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        are assigned equal weight.</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    init : {&#39;k-means++&#39;, &#39;random&#39;}, callable or array-like of shape \</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">            (n_clusters, n_features), default=&#39;k-means++&#39;</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        Method for initialization:</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">        - `&#39;k-means++&#39;` : selects initial cluster centers for k-mean</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">          clustering in a smart way to speed up convergence. See section</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">          Notes in k_init for more details.</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        - `&#39;random&#39;`: choose `n_clusters` observations (rows) at random from data</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">          for the initial centroids.</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        - If an array is passed, it should be of shape `(n_clusters, n_features)`</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">          and gives the initial centers.</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">        - If a callable is passed, it should take arguments `X`, `n_clusters` and a</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">          random state and return an initialization.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    n_init : &#39;auto&#39; or int, default=10</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">        Number of time the k-means algorithm will be run with different</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">        centroid seeds. The final results will be the best output of</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">        n_init consecutive runs in terms of inertia.</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        When `n_init=&#39;auto&#39;`, the number of runs will be 10 if using</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">        `init=&#39;random&#39;`, and 1 if using `init=&#39;kmeans++&#39;`.</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">        .. versionadded:: 1.2</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">           Added &#39;auto&#39; option for `n_init`.</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">        .. versionchanged:: 1.4</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">           Default value for `n_init` will change from 10 to `&#39;auto&#39;` in version 1.4.</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    max_iter : int, default=300</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">        Maximum number of iterations of the k-means algorithm to run.</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    verbose : bool, default=False</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">        Verbosity mode.</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    tol : float, default=1e-4</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">        Relative tolerance with regards to Frobenius norm of the difference</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">        in the cluster centers of two consecutive iterations to declare</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">        convergence.</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    random_state : int, RandomState instance or None, default=None</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">        Determines random number generation for centroid initialization. Use</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">        an int to make the randomness deterministic.</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">        See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    copy_x : bool, default=True</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        When pre-computing distances it is more numerically accurate to center</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        the data first. If `copy_x` is True (default), then the original data is</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        not modified. If False, the original data is modified, and put back</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        before the function returns, but small numerical differences may be</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        introduced by subtracting and then adding the data mean. Note that if</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        the original data is not C-contiguous, a copy will be made even if</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        `copy_x` is False. If the original data is sparse, but not in CSR format,</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        a copy will be made even if `copy_x` is False.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    algorithm : {&quot;lloyd&quot;, &quot;elkan&quot;, &quot;auto&quot;, &quot;full&quot;}, default=&quot;lloyd&quot;</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">        K-means algorithm to use. The classical EM-style algorithm is `&quot;lloyd&quot;`.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">        The `&quot;elkan&quot;` variation can be more efficient on some datasets with</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">        well-defined clusters, by using the triangle inequality. However it&#39;s</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        more memory intensive due to the allocation of an extra array of shape</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        `(n_samples, n_clusters)`.</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">        `&quot;auto&quot;` and `&quot;full&quot;` are deprecated and they will be removed in</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        Scikit-Learn 1.3. They are both aliases for `&quot;lloyd&quot;`.</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">        .. versionchanged:: 0.18</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">            Added Elkan algorithm</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">        .. versionchanged:: 1.1</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">            Renamed &quot;full&quot; to &quot;lloyd&quot;, and deprecated &quot;auto&quot; and &quot;full&quot;.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">            Changed &quot;auto&quot; to use &quot;lloyd&quot; instead of &quot;elkan&quot;.</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    return_n_iter : bool, default=False</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">        Whether or not to return the number of iterations.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    centroid : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">        Centroids found at the last iteration of k-means.</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    label : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        The `label[i]` is the code or index of the centroid the</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        i&#39;th observation is closest to.</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    inertia : float</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        The final value of the inertia criterion (sum of squared distances to</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">        the closest centroid for all observations in the training set).</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    best_n_iter : int</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        Number of iterations corresponding to the best results.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">        Returned only if `return_n_iter` is set to True.</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  420</span>    est = KMeans(</div>
<div class="line"><span class="lineno">  421</span>        n_clusters=n_clusters,</div>
<div class="line"><span class="lineno">  422</span>        init=init,</div>
<div class="line"><span class="lineno">  423</span>        n_init=n_init,</div>
<div class="line"><span class="lineno">  424</span>        max_iter=max_iter,</div>
<div class="line"><span class="lineno">  425</span>        verbose=verbose,</div>
<div class="line"><span class="lineno">  426</span>        tol=tol,</div>
<div class="line"><span class="lineno">  427</span>        random_state=random_state,</div>
<div class="line"><span class="lineno">  428</span>        copy_x=copy_x,</div>
<div class="line"><span class="lineno">  429</span>        algorithm=algorithm,</div>
<div class="line"><span class="lineno">  430</span>    ).fit(X, sample_weight=sample_weight)</div>
<div class="line"><span class="lineno">  431</span>    <span class="keywordflow">if</span> return_n_iter:</div>
<div class="line"><span class="lineno">  432</span>        <span class="keywordflow">return</span> est.cluster_centers_, est.labels_, est.inertia_, est.n_iter_</div>
<div class="line"><span class="lineno">  433</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  434</span>        <span class="keywordflow">return</span> est.cluster_centers_, est.labels_, est.inertia_</div>
<div class="line"><span class="lineno">  435</span> </div>
<div class="line"><span class="lineno">  436</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a705c640615be3435c8c74a10b6e636d3" name="a705c640615be3435c8c74a10b6e636d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705c640615be3435c8c74a10b6e636d3">&#9670;&#160;</a></span>kmeans_plusplus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._kmeans.kmeans_plusplus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>x_squared_norms</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_local_trials</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization heuristic. </p>
<pre class="fragment">Init n_clusters seeds according to k-means++.

.. versionadded:: 0.24

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    The data to pick seeds from.

n_clusters : int
    The number of centroids to initialize.

x_squared_norms : array-like of shape (n_samples,), default=None
    Squared Euclidean norm of each data point.

random_state : int or RandomState instance, default=None
    Determines random number generation for centroid initialization. Pass
    an int for reproducible output across multiple function calls.
    See :term:`Glossary &lt;random_state&gt;`.

n_local_trials : int, default=None
    The number of seeding trials for each center (except the first),
    of which the one reducing inertia the most is greedily chosen.
    Set to None to make the number of trials depend logarithmically
    on the number of seeds (2+log(k)) which is the recommended setting.
    Setting to 1 disables the greedy cluster selection and recovers the
    vanilla k-means++ algorithm which was empirically shown to work less
    well than its greedy variant.

Returns
-------
centers : ndarray of shape (n_clusters, n_features)
    The initial centers for k-means.

indices : ndarray of shape (n_clusters,)
    The index location of the chosen centers in the data array X. For a
    given index and center, X[index] = center.

Notes
-----
Selects initial cluster centers for k-mean clustering in a smart way
to speed up convergence. see: Arthur, D. and Vassilvitskii, S.
"k-means++: the advantages of careful seeding". ACM-SIAM symposium
on Discrete algorithms. 2007

Examples
--------

&gt;&gt;&gt; from sklearn.cluster import kmeans_plusplus
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.array([[1, 2], [1, 4], [1, 0],
...               [10, 2], [10, 4], [10, 0]])
&gt;&gt;&gt; centers, indices = kmeans_plusplus(X, n_clusters=2, random_state=0)
&gt;&gt;&gt; centers
array([[10,  4],
       [ 1,  0]])
&gt;&gt;&gt; indices
array([4, 2])
</pre> <div class="fragment"><div class="line"><span class="lineno">   74</span>):</div>
<div class="line"><span class="lineno">   75</span>    <span class="stringliteral">&quot;&quot;&quot;Init n_clusters seeds according to k-means++.</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    .. versionadded:: 0.24</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        The data to pick seeds from.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    n_clusters : int</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        The number of centroids to initialize.</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    x_squared_norms : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        Squared Euclidean norm of each data point.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    random_state : int or RandomState instance, default=None</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        Determines random number generation for centroid initialization. Pass</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        an int for reproducible output across multiple function calls.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    n_local_trials : int, default=None</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        The number of seeding trials for each center (except the first),</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        of which the one reducing inertia the most is greedily chosen.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        Set to None to make the number of trials depend logarithmically</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">        on the number of seeds (2+log(k)) which is the recommended setting.</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        Setting to 1 disables the greedy cluster selection and recovers the</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        vanilla k-means++ algorithm which was empirically shown to work less</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        well than its greedy variant.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    centers : ndarray of shape (n_clusters, n_features)</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        The initial centers for k-means.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    indices : ndarray of shape (n_clusters,)</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        The index location of the chosen centers in the data array X. For a</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        given index and center, X[index] = center.</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    Selects initial cluster centers for k-mean clustering in a smart way</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    to speed up convergence. see: Arthur, D. and Vassilvitskii, S.</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &quot;k-means++: the advantages of careful seeding&quot;. ACM-SIAM symposium</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    on Discrete algorithms. 2007</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.cluster import kmeans_plusplus</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    &gt;&gt;&gt; X = np.array([[1, 2], [1, 4], [1, 0],</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    ...               [10, 2], [10, 4], [10, 0]])</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &gt;&gt;&gt; centers, indices = kmeans_plusplus(X, n_clusters=2, random_state=0)</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    &gt;&gt;&gt; centers</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    array([[10,  4],</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">           [ 1,  0]])</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    &gt;&gt;&gt; indices</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    array([4, 2])</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  134</span>    <span class="comment"># Check data</span></div>
<div class="line"><span class="lineno">  135</span>    check_array(X, accept_sparse=<span class="stringliteral">&quot;csr&quot;</span>, dtype=[np.float64, np.float32])</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">if</span> X.shape[0] &lt; n_clusters:</div>
<div class="line"><span class="lineno">  138</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  139</span>            f<span class="stringliteral">&quot;n_samples={X.shape[0]} should be &gt;= n_clusters={n_clusters}.&quot;</span></div>
<div class="line"><span class="lineno">  140</span>        )</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>    <span class="comment"># Check parameters</span></div>
<div class="line"><span class="lineno">  143</span>    <span class="keywordflow">if</span> x_squared_norms <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  144</span>        x_squared_norms = row_norms(X, squared=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  146</span>        x_squared_norms = check_array(x_squared_norms, dtype=X.dtype, ensure_2d=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  147</span> </div>
<div class="line"><span class="lineno">  148</span>    <span class="keywordflow">if</span> x_squared_norms.shape[0] != X.shape[0]:</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  150</span>            f<span class="stringliteral">&quot;The length of x_squared_norms {x_squared_norms.shape[0]} should &quot;</span></div>
<div class="line"><span class="lineno">  151</span>            f<span class="stringliteral">&quot;be equal to the length of n_samples {X.shape[0]}.&quot;</span></div>
<div class="line"><span class="lineno">  152</span>        )</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>    <span class="comment"># Call private k-means++</span></div>
<div class="line"><span class="lineno">  157</span>    centers, indices = _kmeans_plusplus(</div>
<div class="line"><span class="lineno">  158</span>        X, n_clusters, x_squared_norms, random_state, n_local_trials</div>
<div class="line"><span class="lineno">  159</span>    )</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">return</span> centers, indices</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
