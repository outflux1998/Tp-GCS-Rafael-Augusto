<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.strings.accessor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html">accessor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.strings.accessor Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html">StringMethods</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9f2e3b4f406d000402503766afff59f" id="r_ad9f2e3b4f406d000402503766afff59f"><td class="memItemLeft" align="right" valign="top">Callable[[F], F]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#ad9f2e3b4f406d000402503766afff59f">forbid_nonstring_types</a> (list[str]|None forbidden, str|None name=None)</td></tr>
<tr class="separator:ad9f2e3b4f406d000402503766afff59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d416b3472f9c1544826cc8b13493366" id="r_a7d416b3472f9c1544826cc8b13493366"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#a7d416b3472f9c1544826cc8b13493366">_map_and_wrap</a> (name, docstring)</td></tr>
<tr class="separator:a7d416b3472f9c1544826cc8b13493366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5776506052c664a268c09f3bb3d3b4a4" id="r_a5776506052c664a268c09f3bb3d3b4a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#a5776506052c664a268c09f3bb3d3b4a4">cat_safe</a> (list list_of_columns, str sep)</td></tr>
<tr class="separator:a5776506052c664a268c09f3bb3d3b4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad7cda6348843d49eaf6dd03f5dc060" id="r_a6ad7cda6348843d49eaf6dd03f5dc060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#a6ad7cda6348843d49eaf6dd03f5dc060">cat_core</a> (list list_of_columns, str sep)</td></tr>
<tr class="separator:a6ad7cda6348843d49eaf6dd03f5dc060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667a69f03314b76b2ac330b5b6b20c26" id="r_a667a69f03314b76b2ac330b5b6b20c26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#a667a69f03314b76b2ac330b5b6b20c26">_result_dtype</a> (arr)</td></tr>
<tr class="separator:a667a69f03314b76b2ac330b5b6b20c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b863f85685700ec53b082668a83fed" id="r_a25b863f85685700ec53b082668a83fed"><td class="memItemLeft" align="right" valign="top">Hashable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#a25b863f85685700ec53b082668a83fed">_get_single_group_name</a> (re.Pattern regex)</td></tr>
<tr class="separator:a25b863f85685700ec53b082668a83fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf80ce1c383e328ee4390c67dc068f7f" id="r_abf80ce1c383e328ee4390c67dc068f7f"><td class="memItemLeft" align="right" valign="top">list[Hashable]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#abf80ce1c383e328ee4390c67dc068f7f">_get_group_names</a> (re.Pattern regex)</td></tr>
<tr class="separator:abf80ce1c383e328ee4390c67dc068f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3739a1fc0e78b5493a3a4d53c172ae60" id="r_a3739a1fc0e78b5493a3a4d53c172ae60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#a3739a1fc0e78b5493a3a4d53c172ae60">str_extractall</a> (arr, pat, flags=0)</td></tr>
<tr class="separator:a3739a1fc0e78b5493a3a4d53c172ae60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa1da89e71af66d6b67c35e56e50cdb24" id="r_aa1da89e71af66d6b67c35e56e50cdb24"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#aa1da89e71af66d6b67c35e56e50cdb24">_shared_docs</a> = {}</td></tr>
<tr class="separator:aa1da89e71af66d6b67c35e56e50cdb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad44a42d7a9b36891b869d8b9a67c583" id="r_aad44a42d7a9b36891b869d8b9a67c583"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#aad44a42d7a9b36891b869d8b9a67c583">_cpython_optimized_encoders</a></td></tr>
<tr class="separator:aad44a42d7a9b36891b869d8b9a67c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2ee2c8352a0ad5829573ade495507b" id="r_aef2ee2c8352a0ad5829573ade495507b"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#aef2ee2c8352a0ad5829573ade495507b">_cpython_optimized_decoders</a> = <a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#aad44a42d7a9b36891b869d8b9a67c583">_cpython_optimized_encoders</a> + (&quot;utf-16&quot;, &quot;utf-32&quot;)</td></tr>
<tr class="separator:aef2ee2c8352a0ad5829573ade495507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abf80ce1c383e328ee4390c67dc068f7f" name="abf80ce1c383e328ee4390c67dc068f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf80ce1c383e328ee4390c67dc068f7f">&#9670;&#160;</a></span>_get_group_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[Hashable] pandas.core.strings.accessor._get_group_names </td>
          <td>(</td>
          <td class="paramtype">re.Pattern&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get named groups from compiled regex.

Unnamed groups are numbered.

Parameters
----------
regex : compiled regex

Returns
-------
list of column labels
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3313</span><span class="keyword">def </span>_get_group_names(regex: re.Pattern) -&gt; list[Hashable]:</div>
<div class="line"><span class="lineno"> 3314</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3315</span><span class="stringliteral">    Get named groups from compiled regex.</span></div>
<div class="line"><span class="lineno"> 3316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3317</span><span class="stringliteral">    Unnamed groups are numbered.</span></div>
<div class="line"><span class="lineno"> 3318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3319</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3320</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3321</span><span class="stringliteral">    regex : compiled regex</span></div>
<div class="line"><span class="lineno"> 3322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3323</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3324</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3325</span><span class="stringliteral">    list of column labels</span></div>
<div class="line"><span class="lineno"> 3326</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3327</span>    names = {v: k <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> regex.groupindex.items()}</div>
<div class="line"><span class="lineno"> 3328</span>    <span class="keywordflow">return</span> [names.get(1 + i, i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(regex.groups)]</div>
<div class="line"><span class="lineno"> 3329</span> </div>
<div class="line"><span class="lineno"> 3330</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a25b863f85685700ec53b082668a83fed" name="a25b863f85685700ec53b082668a83fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b863f85685700ec53b082668a83fed">&#9670;&#160;</a></span>_get_single_group_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Hashable pandas.core.strings.accessor._get_single_group_name </td>
          <td>(</td>
          <td class="paramtype">re.Pattern&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3306</span><span class="keyword">def </span>_get_single_group_name(regex: re.Pattern) -&gt; Hashable:</div>
<div class="line"><span class="lineno"> 3307</span>    <span class="keywordflow">if</span> regex.groupindex:</div>
<div class="line"><span class="lineno"> 3308</span>        <span class="keywordflow">return</span> next(<a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(regex.groupindex))</div>
<div class="line"><span class="lineno"> 3309</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3310</span>        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3311</span> </div>
<div class="line"><span class="lineno"> 3312</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d416b3472f9c1544826cc8b13493366" name="a7d416b3472f9c1544826cc8b13493366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d416b3472f9c1544826cc8b13493366">&#9670;&#160;</a></span>_map_and_wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor._map_and_wrap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>docstring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  137</span><span class="keyword">def </span>_map_and_wrap(name, docstring):</div>
<div class="line"><span class="lineno">  138</span>    <span class="preprocessor">@forbid_nonstring_types([&quot;bytes&quot;], name=name)</span></div>
<div class="line"><span class="lineno">  139</span>    <span class="keyword">def </span>wrapper(self):</div>
<div class="line"><span class="lineno">  140</span>        result = getattr(self._data.array, f<span class="stringliteral">&quot;_str_{name}&quot;</span>)()</div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordflow">return</span> self._wrap_result(result)</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    wrapper.__doc__ = docstring</div>
<div class="line"><span class="lineno">  144</span>    <span class="keywordflow">return</span> wrapper</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a667a69f03314b76b2ac330b5b6b20c26" name="a667a69f03314b76b2ac330b5b6b20c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667a69f03314b76b2ac330b5b6b20c26">&#9670;&#160;</a></span>_result_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor._result_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3294</span><span class="keyword">def </span>_result_dtype(arr):</div>
<div class="line"><span class="lineno"> 3295</span>    <span class="comment"># workaround #27953</span></div>
<div class="line"><span class="lineno"> 3296</span>    <span class="comment"># ideally we just pass `dtype=arr.dtype` unconditionally, but this fails</span></div>
<div class="line"><span class="lineno"> 3297</span>    <span class="comment"># when the list of values is empty.</span></div>
<div class="line"><span class="lineno"> 3298</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a> <span class="keyword">import</span> StringDtype</div>
<div class="line"><span class="lineno"> 3299</span> </div>
<div class="line"><span class="lineno"> 3300</span>    <span class="keywordflow">if</span> isinstance(arr.dtype, StringDtype):</div>
<div class="line"><span class="lineno"> 3301</span>        <span class="keywordflow">return</span> arr.dtype</div>
<div class="line"><span class="lineno"> 3302</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3303</span>        <span class="keywordflow">return</span> object</div>
<div class="line"><span class="lineno"> 3304</span> </div>
<div class="line"><span class="lineno"> 3305</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1string___html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a></div><div class="ttdef"><b>Definition</b> string_.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ad7cda6348843d49eaf6dd03f5dc060" name="a6ad7cda6348843d49eaf6dd03f5dc060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad7cda6348843d49eaf6dd03f5dc060">&#9670;&#160;</a></span>cat_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.cat_core </td>
          <td>(</td>
          <td class="paramtype">list&#160;</td>
          <td class="paramname"><em>list_of_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Auxiliary function for :meth:`str.cat`

Parameters
----------
list_of_columns : list of numpy arrays
    List of arrays to be concatenated with sep;
    these arrays may not contain NaNs!
sep : string
    The separator string for concatenating the columns.

Returns
-------
nd.array
    The concatenation of list_of_columns with sep.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3267</span><span class="keyword">def </span>cat_core(list_of_columns: list, sep: str):</div>
<div class="line"><span class="lineno"> 3268</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral">    Auxiliary function for :meth:`str.cat`</span></div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3271</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3272</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3273</span><span class="stringliteral">    list_of_columns : list of numpy arrays</span></div>
<div class="line"><span class="lineno"> 3274</span><span class="stringliteral">        List of arrays to be concatenated with sep;</span></div>
<div class="line"><span class="lineno"> 3275</span><span class="stringliteral">        these arrays may not contain NaNs!</span></div>
<div class="line"><span class="lineno"> 3276</span><span class="stringliteral">    sep : string</span></div>
<div class="line"><span class="lineno"> 3277</span><span class="stringliteral">        The separator string for concatenating the columns.</span></div>
<div class="line"><span class="lineno"> 3278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3279</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3280</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3281</span><span class="stringliteral">    nd.array</span></div>
<div class="line"><span class="lineno"> 3282</span><span class="stringliteral">        The concatenation of list_of_columns with sep.</span></div>
<div class="line"><span class="lineno"> 3283</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3284</span>    <span class="keywordflow">if</span> sep == <span class="stringliteral">&quot;&quot;</span>:</div>
<div class="line"><span class="lineno"> 3285</span>        <span class="comment"># no need to interleave sep if it is empty</span></div>
<div class="line"><span class="lineno"> 3286</span>        arr_of_cols = np.asarray(list_of_columns, dtype=object)</div>
<div class="line"><span class="lineno"> 3287</span>        <span class="keywordflow">return</span> np.sum(arr_of_cols, axis=0)</div>
<div class="line"><span class="lineno"> 3288</span>    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)</div>
<div class="line"><span class="lineno"> 3289</span>    list_with_sep[::2] = list_of_columns</div>
<div class="line"><span class="lineno"> 3290</span>    arr_with_sep = np.asarray(list_with_sep, dtype=object)</div>
<div class="line"><span class="lineno"> 3291</span>    <span class="keywordflow">return</span> np.sum(arr_with_sep, axis=0)</div>
<div class="line"><span class="lineno"> 3292</span> </div>
<div class="line"><span class="lineno"> 3293</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5776506052c664a268c09f3bb3d3b4a4" name="a5776506052c664a268c09f3bb3d3b4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5776506052c664a268c09f3bb3d3b4a4">&#9670;&#160;</a></span>cat_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.cat_safe </td>
          <td>(</td>
          <td class="paramtype">list&#160;</td>
          <td class="paramname"><em>list_of_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Auxiliary function for :meth:`str.cat`.

Same signature as cat_core, but handles TypeErrors in concatenation, which
happen if the arrays in list_of columns have the wrong dtypes or content.

Parameters
----------
list_of_columns : list of numpy arrays
    List of arrays to be concatenated with sep;
    these arrays may not contain NaNs!
sep : string
    The separator string for concatenating the columns.

Returns
-------
nd.array
    The concatenation of list_of_columns with sep.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3231</span><span class="keyword">def </span>cat_safe(list_of_columns: list, sep: str):</div>
<div class="line"><span class="lineno"> 3232</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3233</span><span class="stringliteral">    Auxiliary function for :meth:`str.cat`.</span></div>
<div class="line"><span class="lineno"> 3234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3235</span><span class="stringliteral">    Same signature as cat_core, but handles TypeErrors in concatenation, which</span></div>
<div class="line"><span class="lineno"> 3236</span><span class="stringliteral">    happen if the arrays in list_of columns have the wrong dtypes or content.</span></div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">    list_of_columns : list of numpy arrays</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral">        List of arrays to be concatenated with sep;</span></div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral">        these arrays may not contain NaNs!</span></div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral">    sep : string</span></div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral">        The separator string for concatenating the columns.</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">    nd.array</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral">        The concatenation of list_of_columns with sep.</span></div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3251</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3252</span>        result = cat_core(list_of_columns, sep)</div>
<div class="line"><span class="lineno"> 3253</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 3254</span>        <span class="comment"># if there are any non-string values (wrong dtype or hidden behind</span></div>
<div class="line"><span class="lineno"> 3255</span>        <span class="comment"># object dtype), np.sum will fail; catch and return with better message</span></div>
<div class="line"><span class="lineno"> 3256</span>        <span class="keywordflow">for</span> column <span class="keywordflow">in</span> list_of_columns:</div>
<div class="line"><span class="lineno"> 3257</span>            dtype = lib.infer_dtype(column, skipna=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3258</span>            <span class="keywordflow">if</span> dtype <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;empty&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3259</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 3260</span>                    <span class="stringliteral">&quot;Concatenation requires list-likes containing only &quot;</span></div>
<div class="line"><span class="lineno"> 3261</span>                    <span class="stringliteral">&quot;strings (or missing values). Offending values found in &quot;</span></div>
<div class="line"><span class="lineno"> 3262</span>                    f<span class="stringliteral">&quot;column {dtype}&quot;</span></div>
<div class="line"><span class="lineno"> 3263</span>                ) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3264</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3265</span> </div>
<div class="line"><span class="lineno"> 3266</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9f2e3b4f406d000402503766afff59f" name="ad9f2e3b4f406d000402503766afff59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f2e3b4f406d000402503766afff59f">&#9670;&#160;</a></span>forbid_nonstring_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Callable[[F], F] pandas.core.strings.accessor.forbid_nonstring_types </td>
          <td>(</td>
          <td class="paramtype">list[str] | None&#160;</td>
          <td class="paramname"><em>forbidden</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decorator to forbid specific types for a method of StringMethods.

For calling `.str.{method}` on a Series or Index, it is necessary to first
initialize the :class:`StringMethods` object, and then call the method.
However, different methods allow different input types, and so this can not
be checked during :meth:`StringMethods.__init__`, but must be done on a
per-method basis. This decorator exists to facilitate this process, and
make it explicit which (inferred) types are disallowed by the method.

:meth:`StringMethods.__init__` allows the *union* of types its different
methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),
namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].

The default string types ['string', 'empty'] are allowed for all methods.
For the additional types ['bytes', 'mixed', 'mixed-integer'], each method
then needs to forbid the types it is not intended for.

Parameters
----------
forbidden : list-of-str or None
    List of forbidden non-string types, may be one or more of
    `['bytes', 'mixed', 'mixed-integer']`.
name : str, default None
    Name of the method to use in the error message. By default, this is
    None, in which case the name from the method being wrapped will be
    copied. However, for working with further wrappers (like _pat_wrapper
    and _noarg_wrapper), it is necessary to specify the name.

Returns
-------
func : wrapper
    The method to which the decorator is applied, with an added check that
    enforces the inferred type to not be in the list of forbidden types.

Raises
------
TypeError
    If the inferred type of the underlying data is in `forbidden`.
</pre> <div class="fragment"><div class="line"><span class="lineno">   70</span>) -&gt; Callable[[F], F]:</div>
<div class="line"><span class="lineno">   71</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    Decorator to forbid specific types for a method of StringMethods.</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    For calling `.str.{method}` on a Series or Index, it is necessary to first</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    initialize the :class:`StringMethods` object, and then call the method.</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    However, different methods allow different input types, and so this can not</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    be checked during :meth:`StringMethods.__init__`, but must be done on a</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    per-method basis. This decorator exists to facilitate this process, and</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    make it explicit which (inferred) types are disallowed by the method.</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    :meth:`StringMethods.__init__` allows the *union* of types its different</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    namely: [&#39;string&#39;, &#39;empty&#39;, &#39;bytes&#39;, &#39;mixed&#39;, &#39;mixed-integer&#39;].</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    The default string types [&#39;string&#39;, &#39;empty&#39;] are allowed for all methods.</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    For the additional types [&#39;bytes&#39;, &#39;mixed&#39;, &#39;mixed-integer&#39;], each method</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    then needs to forbid the types it is not intended for.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    forbidden : list-of-str or None</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        List of forbidden non-string types, may be one or more of</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        `[&#39;bytes&#39;, &#39;mixed&#39;, &#39;mixed-integer&#39;]`.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    name : str, default None</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        Name of the method to use in the error message. By default, this is</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        None, in which case the name from the method being wrapped will be</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        copied. However, for working with further wrappers (like _pat_wrapper</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        and _noarg_wrapper), it is necessary to specify the name.</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    func : wrapper</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        The method to which the decorator is applied, with an added check that</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        enforces the inferred type to not be in the list of forbidden types.</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        If the inferred type of the underlying data is in `forbidden`.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  111</span>    <span class="comment"># deal with None</span></div>
<div class="line"><span class="lineno">  112</span>    forbidden = [] <span class="keywordflow">if</span> forbidden <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> forbidden</div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span>    allowed_types = {<span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;empty&quot;</span>, <span class="stringliteral">&quot;bytes&quot;</span>, <span class="stringliteral">&quot;mixed&quot;</span>, <span class="stringliteral">&quot;mixed-integer&quot;</span>} - set(</div>
<div class="line"><span class="lineno">  115</span>        forbidden</div>
<div class="line"><span class="lineno">  116</span>    )</div>
<div class="line"><span class="lineno">  117</span> </div>
<div class="line"><span class="lineno">  118</span>    <span class="keyword">def </span>_forbid_nonstring_types(func: F) -&gt; F:</div>
<div class="line"><span class="lineno">  119</span>        func_name = func.__name__ <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> name</div>
<div class="line"><span class="lineno">  120</span> </div>
<div class="line"><span class="lineno">  121</span>        <span class="preprocessor">@wraps(func)</span></div>
<div class="line"><span class="lineno">  122</span>        <span class="keyword">def </span>wrapper(self, *args, **kwargs):</div>
<div class="line"><span class="lineno">  123</span>            <span class="keywordflow">if</span> self._inferred_dtype <span class="keywordflow">not</span> <span class="keywordflow">in</span> allowed_types:</div>
<div class="line"><span class="lineno">  124</span>                msg = (</div>
<div class="line"><span class="lineno">  125</span>                    f<span class="stringliteral">&quot;Cannot use .str.{func_name} with values of &quot;</span></div>
<div class="line"><span class="lineno">  126</span>                    f<span class="stringliteral">&quot;inferred dtype &#39;{self._inferred_dtype}&#39;.&quot;</span></div>
<div class="line"><span class="lineno">  127</span>                )</div>
<div class="line"><span class="lineno">  128</span>                <span class="keywordflow">raise</span> TypeError(msg)</div>
<div class="line"><span class="lineno">  129</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(self, *args, **kwargs)</div>
<div class="line"><span class="lineno">  130</span> </div>
<div class="line"><span class="lineno">  131</span>        wrapper.__name__ = func_name</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">return</span> cast(F, wrapper)</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordflow">return</span> _forbid_nonstring_types</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3739a1fc0e78b5493a3a4d53c172ae60" name="a3739a1fc0e78b5493a3a4d53c172ae60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3739a1fc0e78b5493a3a4d53c172ae60">&#9670;&#160;</a></span>str_extractall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.strings.accessor.str_extractall </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3331</span><span class="keyword">def </span>str_extractall(arr, pat, flags=0):</div>
<div class="line"><span class="lineno"> 3332</span>    regex = re.compile(pat, flags=flags)</div>
<div class="line"><span class="lineno"> 3333</span>    <span class="comment"># the regex must contain capture groups.</span></div>
<div class="line"><span class="lineno"> 3334</span>    <span class="keywordflow">if</span> regex.groups == 0:</div>
<div class="line"><span class="lineno"> 3335</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;pattern contains no capture groups&quot;</span>)</div>
<div class="line"><span class="lineno"> 3336</span> </div>
<div class="line"><span class="lineno"> 3337</span>    <span class="keywordflow">if</span> isinstance(arr, ABCIndex):</div>
<div class="line"><span class="lineno"> 3338</span>        arr = arr.to_series().reset_index(drop=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3339</span> </div>
<div class="line"><span class="lineno"> 3340</span>    columns = _get_group_names(regex)</div>
<div class="line"><span class="lineno"> 3341</span>    match_list = []</div>
<div class="line"><span class="lineno"> 3342</span>    index_list = []</div>
<div class="line"><span class="lineno"> 3343</span>    is_mi = arr.index.nlevels &gt; 1</div>
<div class="line"><span class="lineno"> 3344</span> </div>
<div class="line"><span class="lineno"> 3345</span>    <span class="keywordflow">for</span> subject_key, subject <span class="keywordflow">in</span> arr.items():</div>
<div class="line"><span class="lineno"> 3346</span>        <span class="keywordflow">if</span> isinstance(subject, str):</div>
<div class="line"><span class="lineno"> 3347</span> </div>
<div class="line"><span class="lineno"> 3348</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_mi:</div>
<div class="line"><span class="lineno"> 3349</span>                subject_key = (subject_key,)</div>
<div class="line"><span class="lineno"> 3350</span> </div>
<div class="line"><span class="lineno"> 3351</span>            <span class="keywordflow">for</span> match_i, match_tuple <span class="keywordflow">in</span> enumerate(regex.findall(subject)):</div>
<div class="line"><span class="lineno"> 3352</span>                <span class="keywordflow">if</span> isinstance(match_tuple, str):</div>
<div class="line"><span class="lineno"> 3353</span>                    match_tuple = (match_tuple,)</div>
<div class="line"><span class="lineno"> 3354</span>                na_tuple = [np.NaN <span class="keywordflow">if</span> group == <span class="stringliteral">&quot;&quot;</span> <span class="keywordflow">else</span> group <span class="keywordflow">for</span> group <span class="keywordflow">in</span> match_tuple]</div>
<div class="line"><span class="lineno"> 3355</span>                match_list.append(na_tuple)</div>
<div class="line"><span class="lineno"> 3356</span>                result_key = tuple(subject_key + (match_i,))</div>
<div class="line"><span class="lineno"> 3357</span>                index_list.append(result_key)</div>
<div class="line"><span class="lineno"> 3358</span> </div>
<div class="line"><span class="lineno"> 3359</span>    <span class="keyword">from</span> pandas <span class="keyword">import</span> MultiIndex</div>
<div class="line"><span class="lineno"> 3360</span> </div>
<div class="line"><span class="lineno"> 3361</span>    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [<span class="stringliteral">&quot;match&quot;</span>])</div>
<div class="line"><span class="lineno"> 3362</span>    dtype = _result_dtype(arr)</div>
<div class="line"><span class="lineno"> 3363</span> </div>
<div class="line"><span class="lineno"> 3364</span>    result = arr._constructor_expanddim(</div>
<div class="line"><span class="lineno"> 3365</span>        match_list, index=index, columns=columns, dtype=dtype</div>
<div class="line"><span class="lineno"> 3366</span>    )</div>
<div class="line"><span class="lineno"> 3367</span>    <span class="keywordflow">return</span> result</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aef2ee2c8352a0ad5829573ade495507b" name="aef2ee2c8352a0ad5829573ade495507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2ee2c8352a0ad5829573ade495507b">&#9670;&#160;</a></span>_cpython_optimized_decoders</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pandas.core.strings.accessor._cpython_optimized_decoders = <a class="el" href="namespacepandas_1_1core_1_1strings_1_1accessor.html#aad44a42d7a9b36891b869d8b9a67c583">_cpython_optimized_encoders</a> + (&quot;utf-16&quot;, &quot;utf-32&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad44a42d7a9b36891b869d8b9a67c583" name="aad44a42d7a9b36891b869d8b9a67c583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad44a42d7a9b36891b869d8b9a67c583">&#9670;&#160;</a></span>_cpython_optimized_encoders</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pandas.core.strings.accessor._cpython_optimized_encoders</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  (</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;utf-8&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;utf8&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;latin-1&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;latin1&quot;</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;iso-8859-1&quot;</span>,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;mbcs&quot;</span>,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;ascii&quot;</span>,</div>
<div class="line"><span class="lineno">    9</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1da89e71af66d6b67c35e56e50cdb24" name="aa1da89e71af66d6b67c35e56e50cdb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1da89e71af66d6b67c35e56e50cdb24">&#9670;&#160;</a></span>_shared_docs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.strings.accessor._shared_docs = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
