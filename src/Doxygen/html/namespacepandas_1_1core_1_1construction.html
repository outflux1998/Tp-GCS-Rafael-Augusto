<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.construction Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1construction.html">construction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.construction Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a08f468c886498751dcb7648c932eeaed" id="r_a08f468c886498751dcb7648c932eeaed"><td class="memItemLeft" align="right" valign="top">ExtensionArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a08f468c886498751dcb7648c932eeaed">array</a> (Sequence[object]|AnyArrayLike data, Dtype|None dtype=None, bool copy=True)</td></tr>
<tr class="separator:a08f468c886498751dcb7648c932eeaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd587f222eb5f66aa10dd69a8cdd689" id="r_abbd587f222eb5f66aa10dd69a8cdd689"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#abbd587f222eb5f66aa10dd69a8cdd689">extract_array</a> (Series|Index obj, bool extract_numpy=..., bool extract_range=...)</td></tr>
<tr class="separator:abbd587f222eb5f66aa10dd69a8cdd689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6667f09c9e05e99cbd38edb267c1c8" id="r_aeb6667f09c9e05e99cbd38edb267c1c8"><td class="memItemLeft" align="right" valign="top">T|ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#aeb6667f09c9e05e99cbd38edb267c1c8">extract_array</a> (T obj, bool extract_numpy=..., bool extract_range=...)</td></tr>
<tr class="separator:aeb6667f09c9e05e99cbd38edb267c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeb79cb38bf8bae6784b950612444df" id="r_a4eeb79cb38bf8bae6784b950612444df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a4eeb79cb38bf8bae6784b950612444df">ensure_wrapped_if_datetimelike</a> (arr)</td></tr>
<tr class="separator:a4eeb79cb38bf8bae6784b950612444df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40144a6be7d8844b260cbbbb21a31762" id="r_a40144a6be7d8844b260cbbbb21a31762"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a40144a6be7d8844b260cbbbb21a31762">sanitize_masked_array</a> (ma.MaskedArray data)</td></tr>
<tr class="separator:a40144a6be7d8844b260cbbbb21a31762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ac41d69083a7e2a24667b7b83a1b86" id="r_ae8ac41d69083a7e2a24667b7b83a1b86"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#ae8ac41d69083a7e2a24667b7b83a1b86">sanitize_array</a> (data, Index|None index, DtypeObj|None dtype=None, bool copy=False, bool raise_cast_failure=True, *bool allow_2d=False)</td></tr>
<tr class="separator:ae8ac41d69083a7e2a24667b7b83a1b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb73d6fc3e1d4455259be9f7435b8bfb" id="r_adb73d6fc3e1d4455259be9f7435b8bfb"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#adb73d6fc3e1d4455259be9f7435b8bfb">range_to_ndarray</a> (range rng)</td></tr>
<tr class="separator:adb73d6fc3e1d4455259be9f7435b8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f7c9cd6c9ac7464020e9d4a79fc6a" id="r_a469f7c9cd6c9ac7464020e9d4a79fc6a"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a469f7c9cd6c9ac7464020e9d4a79fc6a">_sanitize_ndim</a> (ArrayLike result, data, DtypeObj|None dtype, Index|None index, *bool allow_2d=False)</td></tr>
<tr class="separator:a469f7c9cd6c9ac7464020e9d4a79fc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419720fadb0c5b7e523a9612274783b0" id="r_a419720fadb0c5b7e523a9612274783b0"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a419720fadb0c5b7e523a9612274783b0">_sanitize_str_dtypes</a> (np.ndarray result, data, np.dtype|None dtype, bool copy)</td></tr>
<tr class="separator:a419720fadb0c5b7e523a9612274783b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d405681fd786e40fcb028ed8489b03" id="r_ac5d405681fd786e40fcb028ed8489b03"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#ac5d405681fd786e40fcb028ed8489b03">_maybe_repeat</a> (ArrayLike arr, Index|None index)</td></tr>
<tr class="separator:ac5d405681fd786e40fcb028ed8489b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e39ca315b6e7b39b09e53bc960a16" id="r_a991e39ca315b6e7b39b09e53bc960a16"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a991e39ca315b6e7b39b09e53bc960a16">_try_cast</a> (list|np.ndarray arr, DtypeObj|None dtype, bool copy, bool raise_cast_failure)</td></tr>
<tr class="separator:a991e39ca315b6e7b39b09e53bc960a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fffc0115b6967978fc16241383e635" id="r_a92fffc0115b6967978fc16241383e635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a92fffc0115b6967978fc16241383e635">is_empty_data</a> (Any data)</td></tr>
<tr class="separator:a92fffc0115b6967978fc16241383e635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6b12edcb352eee2bbef7cc915abdd7" id="r_a7c6b12edcb352eee2bbef7cc915abdd7"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1construction.html#a7c6b12edcb352eee2bbef7cc915abdd7">create_series_with_explicit_dtype</a> (Any data=None, ArrayLike|Index|None index=None, Dtype|None dtype=None, str|None name=None, bool copy=False, bool fastpath=False, Dtype dtype_if_empty=object)</td></tr>
<tr class="separator:a7c6b12edcb352eee2bbef7cc915abdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Constructor functions intended to be shared by pd.array, Series.__init__,
and Index.__new__.

These should not depend on core.internals.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ac5d405681fd786e40fcb028ed8489b03" name="ac5d405681fd786e40fcb028ed8489b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d405681fd786e40fcb028ed8489b03">&#9670;&#160;</a></span>_maybe_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.construction._maybe_repeat </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index | None&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">If we have a length-1 array and an index describing how long we expect
the result to be, repeat the array.
</pre> <div class="fragment"><div class="line"><span class="lineno">  733</span><span class="keyword">def </span>_maybe_repeat(arr: ArrayLike, index: Index | <span class="keywordtype">None</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  734</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    If we have a length-1 array and an index describing how long we expect</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    the result to be, repeat the array.</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  738</span>    <span class="keywordflow">if</span> index <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  739</span>        <span class="keywordflow">if</span> 1 == len(arr) != len(index):</div>
<div class="line"><span class="lineno">  740</span>            arr = arr.repeat(len(index))</div>
<div class="line"><span class="lineno">  741</span>    <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno">  742</span> </div>
<div class="line"><span class="lineno">  743</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a469f7c9cd6c9ac7464020e9d4a79fc6a" name="a469f7c9cd6c9ac7464020e9d4a79fc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469f7c9cd6c9ac7464020e9d4a79fc6a">&#9670;&#160;</a></span>_sanitize_ndim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.construction._sanitize_ndim </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj | None&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index | None&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>allow_2d</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure we have a 1-dimensional result array.
</pre> <div class="fragment"><div class="line"><span class="lineno">  683</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  684</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    Ensure we have a 1-dimensional result array.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  687</span>    <span class="keywordflow">if</span> getattr(result, <span class="stringliteral">&quot;ndim&quot;</span>, 0) == 0:</div>
<div class="line"><span class="lineno">  688</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;result should be arraylike with ndim &gt; 0&quot;</span>)</div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span>    <span class="keywordflow">elif</span> result.ndim == 1:</div>
<div class="line"><span class="lineno">  691</span>        <span class="comment"># the result that we want</span></div>
<div class="line"><span class="lineno">  692</span>        result = _maybe_repeat(result, index)</div>
<div class="line"><span class="lineno">  693</span> </div>
<div class="line"><span class="lineno">  694</span>    <span class="keywordflow">elif</span> result.ndim &gt; 1:</div>
<div class="line"><span class="lineno">  695</span>        <span class="keywordflow">if</span> isinstance(data, np.ndarray):</div>
<div class="line"><span class="lineno">  696</span>            <span class="keywordflow">if</span> allow_2d:</div>
<div class="line"><span class="lineno">  697</span>                <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  698</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data must be 1-dimensional&quot;</span>)</div>
<div class="line"><span class="lineno">  699</span>        <span class="keywordflow">if</span> is_object_dtype(dtype) <span class="keywordflow">and</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno">  700</span>            <span class="comment"># i.e. PandasDtype(&quot;O&quot;)</span></div>
<div class="line"><span class="lineno">  701</span> </div>
<div class="line"><span class="lineno">  702</span>            result = com.asarray_tuplesafe(data, dtype=np.dtype(<span class="stringliteral">&quot;object&quot;</span>))</div>
<div class="line"><span class="lineno">  703</span>            cls = dtype.construct_array_type()</div>
<div class="line"><span class="lineno">  704</span>            result = cls._from_sequence(result, dtype=dtype)</div>
<div class="line"><span class="lineno">  705</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  706</span>            <span class="comment"># error: Argument &quot;dtype&quot; to &quot;asarray_tuplesafe&quot; has incompatible type</span></div>
<div class="line"><span class="lineno">  707</span>            <span class="comment"># &quot;Union[dtype[Any], ExtensionDtype, None]&quot;; expected &quot;Union[str,</span></div>
<div class="line"><span class="lineno">  708</span>            <span class="comment"># dtype[Any], None]&quot;</span></div>
<div class="line"><span class="lineno">  709</span>            result = com.asarray_tuplesafe(data, dtype=dtype)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  710</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  711</span> </div>
<div class="line"><span class="lineno">  712</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a419720fadb0c5b7e523a9612274783b0" name="a419720fadb0c5b7e523a9612274783b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419720fadb0c5b7e523a9612274783b0">&#9670;&#160;</a></span>_sanitize_str_dtypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.construction._sanitize_str_dtypes </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype | None&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure we have a dtype that is supported by pandas.
</pre> <div class="fragment"><div class="line"><span class="lineno">  715</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  716</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    Ensure we have a dtype that is supported by pandas.</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  719</span> </div>
<div class="line"><span class="lineno">  720</span>    <span class="comment"># This is to prevent mixed-type Series getting all casted to</span></div>
<div class="line"><span class="lineno">  721</span>    <span class="comment"># NumPy string type, e.g. NaN --&gt; &#39;-1#IND&#39;.</span></div>
<div class="line"><span class="lineno">  722</span>    <span class="keywordflow">if</span> issubclass(result.dtype.type, str):</div>
<div class="line"><span class="lineno">  723</span>        <span class="comment"># GH#16605</span></div>
<div class="line"><span class="lineno">  724</span>        <span class="comment"># If not empty convert the data to dtype</span></div>
<div class="line"><span class="lineno">  725</span>        <span class="comment"># GH#19853: If data is a scalar, result has already the result</span></div>
<div class="line"><span class="lineno">  726</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> lib.is_scalar(data):</div>
<div class="line"><span class="lineno">  727</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.all(isna(data)):</div>
<div class="line"><span class="lineno">  728</span>                data = np.array(data, dtype=dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  729</span>            result = np.array(data, dtype=object, copy=copy)</div>
<div class="line"><span class="lineno">  730</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  731</span> </div>
<div class="line"><span class="lineno">  732</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a991e39ca315b6e7b39b09e53bc960a16" name="a991e39ca315b6e7b39b09e53bc960a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e39ca315b6e7b39b09e53bc960a16">&#9670;&#160;</a></span>_try_cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.construction._try_cast </td>
          <td>(</td>
          <td class="paramtype">list | np.ndarray&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj | None&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>raise_cast_failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert input to numpy ndarray and optionally cast to a given dtype.

Parameters
----------
arr : ndarray or list
    Excludes: ExtensionArray, Series, Index.
dtype : np.dtype, ExtensionDtype or None
copy : bool
    If False, don't copy the data if not needed.
raise_cast_failure : bool
    If True, and if a dtype is specified, raise errors during casting.
    Otherwise an object array is returned.

Returns
-------
np.ndarray or ExtensionArray
</pre> <div class="fragment"><div class="line"><span class="lineno">  749</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  750</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    Convert input to numpy ndarray and optionally cast to a given dtype.</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    arr : ndarray or list</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        Excludes: ExtensionArray, Series, Index.</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    dtype : np.dtype, ExtensionDtype or None</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    copy : bool</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        If False, don&#39;t copy the data if not needed.</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    raise_cast_failure : bool</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        If True, and if a dtype is specified, raise errors during casting.</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        Otherwise an object array is returned.</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  768</span>    is_ndarray = isinstance(arr, np.ndarray)</div>
<div class="line"><span class="lineno">  769</span> </div>
<div class="line"><span class="lineno">  770</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  771</span>        <span class="comment"># perf shortcut as this is the most common case</span></div>
<div class="line"><span class="lineno">  772</span>        <span class="keywordflow">if</span> is_ndarray:</div>
<div class="line"><span class="lineno">  773</span>            arr = cast(np.ndarray, arr)</div>
<div class="line"><span class="lineno">  774</span>            <span class="keywordflow">if</span> arr.dtype != object:</div>
<div class="line"><span class="lineno">  775</span>                <span class="keywordflow">return</span> sanitize_to_nanoseconds(arr, copy=copy)</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span>            out = maybe_infer_to_datetimelike(arr)</div>
<div class="line"><span class="lineno">  778</span>            <span class="keywordflow">if</span> out <span class="keywordflow">is</span> arr <span class="keywordflow">and</span> copy:</div>
<div class="line"><span class="lineno">  779</span>                out = out.copy()</div>
<div class="line"><span class="lineno">  780</span>            <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  781</span> </div>
<div class="line"><span class="lineno">  782</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  783</span>            <span class="comment"># i.e. list</span></div>
<div class="line"><span class="lineno">  784</span>            varr = np.array(arr, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  785</span>            <span class="comment"># filter out cases that we _dont_ want to go through</span></div>
<div class="line"><span class="lineno">  786</span>            <span class="comment">#  maybe_infer_to_datetimelike</span></div>
<div class="line"><span class="lineno">  787</span>            <span class="keywordflow">if</span> varr.dtype != object <span class="keywordflow">or</span> varr.size == 0:</div>
<div class="line"><span class="lineno">  788</span>                <span class="keywordflow">return</span> varr</div>
<div class="line"><span class="lineno">  789</span>            <span class="keywordflow">return</span> maybe_infer_to_datetimelike(varr)</div>
<div class="line"><span class="lineno">  790</span> </div>
<div class="line"><span class="lineno">  791</span>    <span class="keywordflow">elif</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno">  792</span>        <span class="comment"># create an extension array from its dtype</span></div>
<div class="line"><span class="lineno">  793</span>        <span class="keywordflow">if</span> isinstance(dtype, DatetimeTZDtype):</div>
<div class="line"><span class="lineno">  794</span>            <span class="comment"># We can&#39;t go through _from_sequence because it handles dt64naive</span></div>
<div class="line"><span class="lineno">  795</span>            <span class="comment">#  data differently; _from_sequence treats naive as wall times,</span></div>
<div class="line"><span class="lineno">  796</span>            <span class="comment">#  while maybe_cast_to_datetime treats it as UTC</span></div>
<div class="line"><span class="lineno">  797</span>            <span class="comment">#  see test_maybe_promote_any_numpy_dtype_with_datetimetz</span></div>
<div class="line"><span class="lineno">  798</span>            <span class="comment"># TODO(2.0): with deprecations enforced, should be able to remove</span></div>
<div class="line"><span class="lineno">  799</span>            <span class="comment">#  special case.</span></div>
<div class="line"><span class="lineno">  800</span>            <span class="keywordflow">return</span> maybe_cast_to_datetime(arr, dtype)</div>
<div class="line"><span class="lineno">  801</span>            <span class="comment"># TODO: copy?</span></div>
<div class="line"><span class="lineno">  802</span> </div>
<div class="line"><span class="lineno">  803</span>        array_type = dtype.construct_array_type()._from_sequence</div>
<div class="line"><span class="lineno">  804</span>        subarr = array_type(arr, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  805</span>        <span class="keywordflow">return</span> subarr</div>
<div class="line"><span class="lineno">  806</span> </div>
<div class="line"><span class="lineno">  807</span>    <span class="keywordflow">elif</span> is_object_dtype(dtype):</div>
<div class="line"><span class="lineno">  808</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_ndarray:</div>
<div class="line"><span class="lineno">  809</span>            subarr = construct_1d_object_array_from_listlike(arr)</div>
<div class="line"><span class="lineno">  810</span>            <span class="keywordflow">return</span> subarr</div>
<div class="line"><span class="lineno">  811</span>        <span class="keywordflow">return</span> ensure_wrapped_if_datetimelike(arr).astype(dtype, copy=copy)</div>
<div class="line"><span class="lineno">  812</span> </div>
<div class="line"><span class="lineno">  813</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;U&quot;</span>:</div>
<div class="line"><span class="lineno">  814</span>        <span class="comment"># TODO: test cases with arr.dtype.kind in [&quot;m&quot;, &quot;M&quot;]</span></div>
<div class="line"><span class="lineno">  815</span>        <span class="keywordflow">if</span> is_ndarray:</div>
<div class="line"><span class="lineno">  816</span>            arr = cast(np.ndarray, arr)</div>
<div class="line"><span class="lineno">  817</span>            shape = arr.shape</div>
<div class="line"><span class="lineno">  818</span>            <span class="keywordflow">if</span> arr.ndim &gt; 1:</div>
<div class="line"><span class="lineno">  819</span>                arr = arr.ravel()</div>
<div class="line"><span class="lineno">  820</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  821</span>            shape = (len(arr),)</div>
<div class="line"><span class="lineno">  822</span>        <span class="keywordflow">return</span> lib.ensure_string_array(arr, convert_na_value=<span class="keyword">False</span>, copy=copy).reshape(</div>
<div class="line"><span class="lineno">  823</span>            shape</div>
<div class="line"><span class="lineno">  824</span>        )</div>
<div class="line"><span class="lineno">  825</span> </div>
<div class="line"><span class="lineno">  826</span>    <span class="keywordflow">elif</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno">  827</span>        <span class="keywordflow">return</span> maybe_cast_to_datetime(arr, dtype)</div>
<div class="line"><span class="lineno">  828</span> </div>
<div class="line"><span class="lineno">  829</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  830</span>        <span class="comment"># GH#15832: Check if we are requesting a numeric dtype and</span></div>
<div class="line"><span class="lineno">  831</span>        <span class="comment"># that we can convert the data to the requested dtype.</span></div>
<div class="line"><span class="lineno">  832</span>        <span class="keywordflow">if</span> is_integer_dtype(dtype):</div>
<div class="line"><span class="lineno">  833</span>            <span class="comment"># this will raise if we have e.g. floats</span></div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span>            subarr = maybe_cast_to_integer_array(arr, dtype)</div>
<div class="line"><span class="lineno">  836</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  837</span>            <span class="comment"># 4 tests fail if we move this to a try/except/else; see</span></div>
<div class="line"><span class="lineno">  838</span>            <span class="comment">#  test_constructor_compound_dtypes, test_constructor_cast_failure</span></div>
<div class="line"><span class="lineno">  839</span>            <span class="comment">#  test_constructor_dict_cast2, test_loc_setitem_dtype</span></div>
<div class="line"><span class="lineno">  840</span>            subarr = np.array(arr, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  841</span> </div>
<div class="line"><span class="lineno">  842</span>    <span class="keywordflow">except</span> (ValueError, TypeError):</div>
<div class="line"><span class="lineno">  843</span>        <span class="keywordflow">if</span> raise_cast_failure:</div>
<div class="line"><span class="lineno">  844</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  845</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  846</span>            <span class="comment"># we only get here with raise_cast_failure False, which means</span></div>
<div class="line"><span class="lineno">  847</span>            <span class="comment">#  called via the DataFrame constructor</span></div>
<div class="line"><span class="lineno">  848</span>            <span class="comment"># GH#24435</span></div>
<div class="line"><span class="lineno">  849</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  850</span>                f<span class="stringliteral">&quot;Could not cast to {dtype}, falling back to object. This &quot;</span></div>
<div class="line"><span class="lineno">  851</span>                <span class="stringliteral">&quot;behavior is deprecated. In a future version, when a dtype is &quot;</span></div>
<div class="line"><span class="lineno">  852</span>                <span class="stringliteral">&quot;passed to &#39;DataFrame&#39;, either all columns will be cast to that &quot;</span></div>
<div class="line"><span class="lineno">  853</span>                <span class="stringliteral">&quot;dtype, or a TypeError will be raised.&quot;</span>,</div>
<div class="line"><span class="lineno">  854</span>                FutureWarning,</div>
<div class="line"><span class="lineno">  855</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  856</span>            )</div>
<div class="line"><span class="lineno">  857</span>            subarr = np.array(arr, dtype=object, copy=copy)</div>
<div class="line"><span class="lineno">  858</span>    <span class="keywordflow">return</span> subarr</div>
<div class="line"><span class="lineno">  859</span> </div>
<div class="line"><span class="lineno">  860</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a08f468c886498751dcb7648c932eeaed" name="a08f468c886498751dcb7648c932eeaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f468c886498751dcb7648c932eeaed">&#9670;&#160;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ExtensionArray pandas.core.construction.array </td>
          <td>(</td>
          <td class="paramtype">Sequence[object] | AnyArrayLike&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dtype | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create an array.

Parameters
----------
data : Sequence of objects
    The scalars inside `data` should be instances of the
    scalar type for `dtype`. It's expected that `data`
    represents a 1-dimensional array of data.

    When `data` is an Index or Series, the underlying array
    will be extracted from `data`.

dtype : str, np.dtype, or ExtensionDtype, optional
    The dtype to use for the array. This may be a NumPy
    dtype or an extension type registered with pandas using
    :meth:`pandas.api.extensions.register_extension_dtype`.

    If not specified, there are two possibilities:

    1. When `data` is a :class:`Series`, :class:`Index`, or
       :class:`ExtensionArray`, the `dtype` will be taken
       from the data.
    2. Otherwise, pandas will attempt to infer the `dtype`
       from the data.

    Note that when `data` is a NumPy array, ``data.dtype`` is
    *not* used for inferring the array type. This is because
    NumPy cannot represent all the types of data that can be
    held in extension arrays.

    Currently, pandas will infer an extension dtype for sequences of

    ============================== =======================================
    Scalar Type                    Array Type
    ============================== =======================================
    :class:`pandas.Interval`       :class:`pandas.arrays.IntervalArray`
    :class:`pandas.Period`         :class:`pandas.arrays.PeriodArray`
    :class:`datetime.datetime`     :class:`pandas.arrays.DatetimeArray`
    :class:`datetime.timedelta`    :class:`pandas.arrays.TimedeltaArray`
    :class:`int`                   :class:`pandas.arrays.IntegerArray`
    :class:`float`                 :class:`pandas.arrays.FloatingArray`
    :class:`str`                   :class:`pandas.arrays.StringArray` or
                                   :class:`pandas.arrays.ArrowStringArray`
    :class:`bool`                  :class:`pandas.arrays.BooleanArray`
    ============================== =======================================

    The ExtensionArray created when the scalar type is :class:`str` is determined by
    ``pd.options.mode.string_storage`` if the dtype is not explicitly given.

    For all other cases, NumPy's usual inference rules will be used.

    .. versionchanged:: 1.0.0

       Pandas infers nullable-integer dtype for integer data,
       string dtype for string data, and nullable-boolean dtype
       for boolean data.

    .. versionchanged:: 1.2.0

        Pandas now also infers nullable-floating dtype for float-like
        input data

copy : bool, default True
    Whether to copy the data, even if not necessary. Depending
    on the type of `data`, creating the new array may require
    copying data, even if ``copy=False``.

Returns
-------
ExtensionArray
    The newly created array.

Raises
------
ValueError
    When `data` is not 1-dimensional.

See Also
--------
numpy.array : Construct a NumPy array.
Series : Construct a pandas Series.
Index : Construct a pandas Index.
arrays.PandasArray : ExtensionArray wrapping a NumPy array.
Series.array : Extract the array stored within a Series.

Notes
-----
Omitting the `dtype` argument means pandas will attempt to infer the
best array type from the values in the data. As new array types are
added by pandas and 3rd party libraries, the "best" array type may
change. We recommend specifying `dtype` to ensure that

1. the correct array type for the data is returned
2. the returned array type doesn't change as new extension types
   are added by pandas and third-party libraries

Additionally, if the underlying memory representation of the returned
array matters, we recommend specifying the `dtype` as a concrete object
rather than a string alias or allowing it to be inferred. For example,
a future version of pandas or a 3rd-party library may include a
dedicated ExtensionArray for string data. In this event, the following
would no longer return a :class:`arrays.PandasArray` backed by a NumPy
array.

&gt;&gt;&gt; pd.array(['a', 'b'], dtype=str)
&lt;PandasArray&gt;
['a', 'b']
Length: 2, dtype: str32

This would instead return the new ExtensionArray dedicated for string
data. If you really need the new array to be backed by a  NumPy array,
specify that in the dtype.

&gt;&gt;&gt; pd.array(['a', 'b'], dtype=np.dtype("&lt;U1"))
&lt;PandasArray&gt;
['a', 'b']
Length: 2, dtype: str32

Finally, Pandas has arrays that mostly overlap with NumPy

  * :class:`arrays.DatetimeArray`
  * :class:`arrays.TimedeltaArray`

When data with a ``datetime64[ns]`` or ``timedelta64[ns]`` dtype is
passed, pandas will always return a ``DatetimeArray`` or ``TimedeltaArray``
rather than a ``PandasArray``. This is for symmetry with the case of
timezone-aware data, which NumPy does not natively support.

&gt;&gt;&gt; pd.array(['2015', '2016'], dtype='datetime64[ns]')
&lt;DatetimeArray&gt;
['2015-01-01 00:00:00', '2016-01-01 00:00:00']
Length: 2, dtype: datetime64[ns]

&gt;&gt;&gt; pd.array(["1H", "2H"], dtype='timedelta64[ns]')
&lt;TimedeltaArray&gt;
['0 days 01:00:00', '0 days 02:00:00']
Length: 2, dtype: timedelta64[ns]

Examples
--------
If a dtype is not specified, pandas will infer the best dtype from the values.
See the description of `dtype` for the types pandas infers for.

&gt;&gt;&gt; pd.array([1, 2])
&lt;IntegerArray&gt;
[1, 2]
Length: 2, dtype: Int64

&gt;&gt;&gt; pd.array([1, 2, np.nan])
&lt;IntegerArray&gt;
[1, 2, &lt;NA&gt;]
Length: 3, dtype: Int64

&gt;&gt;&gt; pd.array([1.1, 2.2])
&lt;FloatingArray&gt;
[1.1, 2.2]
Length: 2, dtype: Float64

&gt;&gt;&gt; pd.array(["a", None, "c"])
&lt;StringArray&gt;
['a', &lt;NA&gt;, 'c']
Length: 3, dtype: string

&gt;&gt;&gt; with pd.option_context("string_storage", "pyarrow"):
...     arr = pd.array(["a", None, "c"])
...
&gt;&gt;&gt; arr
&lt;ArrowStringArray&gt;
['a', &lt;NA&gt;, 'c']
Length: 3, dtype: string

&gt;&gt;&gt; pd.array([pd.Period('2000', freq="D"), pd.Period("2000", freq="D")])
&lt;PeriodArray&gt;
['2000-01-01', '2000-01-01']
Length: 2, dtype: period[D]

You can use the string alias for `dtype`

&gt;&gt;&gt; pd.array(['a', 'b', 'a'], dtype='category')
['a', 'b', 'a']
Categories (2, object): ['a', 'b']

Or specify the actual dtype

&gt;&gt;&gt; pd.array(['a', 'b', 'a'],
...          dtype=pd.CategoricalDtype(['a', 'b', 'c'], ordered=True))
['a', 'b', 'a']
Categories (3, object): ['a' &lt; 'b' &lt; 'c']

If pandas does not infer a dedicated extension type a
:class:`arrays.PandasArray` is returned.

&gt;&gt;&gt; pd.array([1 + 1j, 3 + 2j])
&lt;PandasArray&gt;
[(1+1j), (3+2j)]
Length: 2, dtype: complex128

As mentioned in the "Notes" section, new extension types may be added
in the future (by pandas or 3rd party libraries), causing the return
value to no longer be a :class:`arrays.PandasArray`. Specify the `dtype`
as a NumPy dtype if you need to ensure there's no future change in
behavior.

&gt;&gt;&gt; pd.array([1, 2], dtype=np.dtype("int32"))
&lt;PandasArray&gt;
[1, 2]
Length: 2, dtype: int32

`data` must be 1-dimensional. A ValueError is raised when the input
has the wrong dimensionality.

&gt;&gt;&gt; pd.array(1)
Traceback (most recent call last):
  ...
ValueError: Cannot pass scalar '1' to 'pandas.array'.
</pre> <div class="fragment"><div class="line"><span class="lineno">   85</span>) -&gt; ExtensionArray:</div>
<div class="line"><span class="lineno">   86</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    Create an array.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    data : Sequence of objects</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        The scalars inside `data` should be instances of the</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        scalar type for `dtype`. It&#39;s expected that `data`</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        represents a 1-dimensional array of data.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        When `data` is an Index or Series, the underlying array</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        will be extracted from `data`.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    dtype : str, np.dtype, or ExtensionDtype, optional</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        The dtype to use for the array. This may be a NumPy</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        dtype or an extension type registered with pandas using</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        :meth:`pandas.api.extensions.register_extension_dtype`.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        If not specified, there are two possibilities:</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        1. When `data` is a :class:`Series`, :class:`Index`, or</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">           :class:`ExtensionArray`, the `dtype` will be taken</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">           from the data.</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        2. Otherwise, pandas will attempt to infer the `dtype`</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">           from the data.</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        Note that when `data` is a NumPy array, ``data.dtype`` is</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        *not* used for inferring the array type. This is because</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        NumPy cannot represent all the types of data that can be</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        held in extension arrays.</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">        Currently, pandas will infer an extension dtype for sequences of</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        ============================== =======================================</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        Scalar Type                    Array Type</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        ============================== =======================================</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        :class:`pandas.Interval`       :class:`pandas.arrays.IntervalArray`</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">        :class:`pandas.Period`         :class:`pandas.arrays.PeriodArray`</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">        :class:`datetime.datetime`     :class:`pandas.arrays.DatetimeArray`</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        :class:`datetime.timedelta`    :class:`pandas.arrays.TimedeltaArray`</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        :class:`int`                   :class:`pandas.arrays.IntegerArray`</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        :class:`float`                 :class:`pandas.arrays.FloatingArray`</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        :class:`str`                   :class:`pandas.arrays.StringArray` or</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">                                       :class:`pandas.arrays.ArrowStringArray`</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">        :class:`bool`                  :class:`pandas.arrays.BooleanArray`</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        ============================== =======================================</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">        The ExtensionArray created when the scalar type is :class:`str` is determined by</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">        ``pd.options.mode.string_storage`` if the dtype is not explicitly given.</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        For all other cases, NumPy&#39;s usual inference rules will be used.</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        .. versionchanged:: 1.0.0</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">           Pandas infers nullable-integer dtype for integer data,</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">           string dtype for string data, and nullable-boolean dtype</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">           for boolean data.</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        .. versionchanged:: 1.2.0</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">            Pandas now also infers nullable-floating dtype for float-like</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">            input data</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    copy : bool, default True</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">        Whether to copy the data, even if not necessary. Depending</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        on the type of `data`, creating the new array may require</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        copying data, even if ``copy=False``.</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    ExtensionArray</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">        The newly created array.</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        When `data` is not 1-dimensional.</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    numpy.array : Construct a NumPy array.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    Series : Construct a pandas Series.</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    Index : Construct a pandas Index.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    arrays.PandasArray : ExtensionArray wrapping a NumPy array.</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    Series.array : Extract the array stored within a Series.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    Omitting the `dtype` argument means pandas will attempt to infer the</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    best array type from the values in the data. As new array types are</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    added by pandas and 3rd party libraries, the &quot;best&quot; array type may</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    change. We recommend specifying `dtype` to ensure that</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    1. the correct array type for the data is returned</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    2. the returned array type doesn&#39;t change as new extension types</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">       are added by pandas and third-party libraries</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    Additionally, if the underlying memory representation of the returned</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    array matters, we recommend specifying the `dtype` as a concrete object</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    rather than a string alias or allowing it to be inferred. For example,</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    a future version of pandas or a 3rd-party library may include a</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    dedicated ExtensionArray for string data. In this event, the following</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    would no longer return a :class:`arrays.PandasArray` backed by a NumPy</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    array.</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([&#39;a&#39;, &#39;b&#39;], dtype=str)</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    &lt;PandasArray&gt;</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    [&#39;a&#39;, &#39;b&#39;]</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    Length: 2, dtype: str32</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    This would instead return the new ExtensionArray dedicated for string</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    data. If you really need the new array to be backed by a  NumPy array,</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    specify that in the dtype.</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([&#39;a&#39;, &#39;b&#39;], dtype=np.dtype(&quot;&lt;U1&quot;))</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    &lt;PandasArray&gt;</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    [&#39;a&#39;, &#39;b&#39;]</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Length: 2, dtype: str32</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    Finally, Pandas has arrays that mostly overlap with NumPy</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">      * :class:`arrays.DatetimeArray`</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">      * :class:`arrays.TimedeltaArray`</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    When data with a ``datetime64[ns]`` or ``timedelta64[ns]`` dtype is</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    passed, pandas will always return a ``DatetimeArray`` or ``TimedeltaArray``</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    rather than a ``PandasArray``. This is for symmetry with the case of</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    timezone-aware data, which NumPy does not natively support.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([&#39;2015&#39;, &#39;2016&#39;], dtype=&#39;datetime64[ns]&#39;)</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &lt;DatetimeArray&gt;</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    [&#39;2015-01-01 00:00:00&#39;, &#39;2016-01-01 00:00:00&#39;]</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    Length: 2, dtype: datetime64[ns]</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([&quot;1H&quot;, &quot;2H&quot;], dtype=&#39;timedelta64[ns]&#39;)</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    &lt;TimedeltaArray&gt;</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    [&#39;0 days 01:00:00&#39;, &#39;0 days 02:00:00&#39;]</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    Length: 2, dtype: timedelta64[ns]</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    If a dtype is not specified, pandas will infer the best dtype from the values.</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    See the description of `dtype` for the types pandas infers for.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([1, 2])</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    &lt;IntegerArray&gt;</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    [1, 2]</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    Length: 2, dtype: Int64</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([1, 2, np.nan])</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    &lt;IntegerArray&gt;</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    [1, 2, &lt;NA&gt;]</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    Length: 3, dtype: Int64</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([1.1, 2.2])</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    &lt;FloatingArray&gt;</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    [1.1, 2.2]</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    Length: 2, dtype: Float64</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([&quot;a&quot;, None, &quot;c&quot;])</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    &lt;StringArray&gt;</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    [&#39;a&#39;, &lt;NA&gt;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    Length: 3, dtype: string</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    &gt;&gt;&gt; with pd.option_context(&quot;string_storage&quot;, &quot;pyarrow&quot;):</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    ...     arr = pd.array([&quot;a&quot;, None, &quot;c&quot;])</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    &gt;&gt;&gt; arr</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    &lt;ArrowStringArray&gt;</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    [&#39;a&#39;, &lt;NA&gt;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    Length: 3, dtype: string</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([pd.Period(&#39;2000&#39;, freq=&quot;D&quot;), pd.Period(&quot;2000&quot;, freq=&quot;D&quot;)])</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    &lt;PeriodArray&gt;</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    [&#39;2000-01-01&#39;, &#39;2000-01-01&#39;]</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    Length: 2, dtype: period[D]</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    You can use the string alias for `dtype`</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([&#39;a&#39;, &#39;b&#39;, &#39;a&#39;], dtype=&#39;category&#39;)</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;]</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    Categories (2, object): [&#39;a&#39;, &#39;b&#39;]</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    Or specify the actual dtype</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([&#39;a&#39;, &#39;b&#39;, &#39;a&#39;],</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    ...          dtype=pd.CategoricalDtype([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], ordered=True))</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;]</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    Categories (3, object): [&#39;a&#39; &lt; &#39;b&#39; &lt; &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    If pandas does not infer a dedicated extension type a</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    :class:`arrays.PandasArray` is returned.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([1 + 1j, 3 + 2j])</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    &lt;PandasArray&gt;</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    [(1+1j), (3+2j)]</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    Length: 2, dtype: complex128</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    As mentioned in the &quot;Notes&quot; section, new extension types may be added</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    in the future (by pandas or 3rd party libraries), causing the return</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    value to no longer be a :class:`arrays.PandasArray`. Specify the `dtype`</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    as a NumPy dtype if you need to ensure there&#39;s no future change in</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    behavior.</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    &gt;&gt;&gt; pd.array([1, 2], dtype=np.dtype(&quot;int32&quot;))</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    &lt;PandasArray&gt;</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    [1, 2]</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    Length: 2, dtype: int32</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    `data` must be 1-dimensional. A ValueError is raised when the input</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    has the wrong dimensionality.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    &gt;&gt;&gt; pd.array(1)</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">      ...</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    ValueError: Cannot pass scalar &#39;1&#39; to &#39;pandas.array&#39;.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  303</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a> <span class="keyword">import</span> (</div>
<div class="line"><span class="lineno">  304</span>        BooleanArray,</div>
<div class="line"><span class="lineno">  305</span>        DatetimeArray,</div>
<div class="line"><span class="lineno">  306</span>        ExtensionArray,</div>
<div class="line"><span class="lineno">  307</span>        FloatingArray,</div>
<div class="line"><span class="lineno">  308</span>        IntegerArray,</div>
<div class="line"><span class="lineno">  309</span>        IntervalArray,</div>
<div class="line"><span class="lineno">  310</span>        PandasArray,</div>
<div class="line"><span class="lineno">  311</span>        PeriodArray,</div>
<div class="line"><span class="lineno">  312</span>        TimedeltaArray,</div>
<div class="line"><span class="lineno">  313</span>    )</div>
<div class="line"><span class="lineno">  314</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a> <span class="keyword">import</span> StringDtype</div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span>    <span class="keywordflow">if</span> lib.is_scalar(data):</div>
<div class="line"><span class="lineno">  317</span>        msg = f<span class="stringliteral">&quot;Cannot pass scalar &#39;{data}&#39; to &#39;pandas.array&#39;.&quot;</span></div>
<div class="line"><span class="lineno">  318</span>        <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> isinstance(data, (ABCSeries, ABCIndex, ExtensionArray)):</div>
<div class="line"><span class="lineno">  321</span>        <span class="comment"># Note: we exclude np.ndarray here, will do type inference on it</span></div>
<div class="line"><span class="lineno">  322</span>        dtype = data.dtype</div>
<div class="line"><span class="lineno">  323</span> </div>
<div class="line"><span class="lineno">  324</span>    data = extract_array(data, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  325</span> </div>
<div class="line"><span class="lineno">  326</span>    <span class="comment"># this returns None for not-found dtypes.</span></div>
<div class="line"><span class="lineno">  327</span>    <span class="keywordflow">if</span> isinstance(dtype, str):</div>
<div class="line"><span class="lineno">  328</span>        dtype = registry.find(dtype) <span class="keywordflow">or</span> dtype</div>
<div class="line"><span class="lineno">  329</span> </div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">if</span> is_extension_array_dtype(dtype):</div>
<div class="line"><span class="lineno">  331</span>        cls = cast(ExtensionDtype, dtype).construct_array_type()</div>
<div class="line"><span class="lineno">  332</span>        <span class="keywordflow">return</span> cls._from_sequence(data, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  335</span>        inferred_dtype = lib.infer_dtype(data, skipna=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  336</span>        <span class="keywordflow">if</span> inferred_dtype == <span class="stringliteral">&quot;period&quot;</span>:</div>
<div class="line"><span class="lineno">  337</span>            period_data = cast(Union[Sequence[Optional[Period]], AnyArrayLike], data)</div>
<div class="line"><span class="lineno">  338</span>            <span class="keywordflow">return</span> PeriodArray._from_sequence(period_data, copy=copy)</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>        <span class="keywordflow">elif</span> inferred_dtype == <span class="stringliteral">&quot;interval&quot;</span>:</div>
<div class="line"><span class="lineno">  341</span>            <span class="keywordflow">return</span> IntervalArray(data, copy=copy)</div>
<div class="line"><span class="lineno">  342</span> </div>
<div class="line"><span class="lineno">  343</span>        <span class="keywordflow">elif</span> inferred_dtype.startswith(<span class="stringliteral">&quot;datetime&quot;</span>):</div>
<div class="line"><span class="lineno">  344</span>            <span class="comment"># datetime, datetime64</span></div>
<div class="line"><span class="lineno">  345</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  346</span>                <span class="keywordflow">return</span> DatetimeArray._from_sequence(data, copy=copy)</div>
<div class="line"><span class="lineno">  347</span>            <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  348</span>                <span class="comment"># Mixture of timezones, fall back to PandasArray</span></div>
<div class="line"><span class="lineno">  349</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">elif</span> inferred_dtype.startswith(<span class="stringliteral">&quot;timedelta&quot;</span>):</div>
<div class="line"><span class="lineno">  352</span>            <span class="comment"># timedelta, timedelta64</span></div>
<div class="line"><span class="lineno">  353</span>            <span class="keywordflow">return</span> TimedeltaArray._from_sequence(data, copy=copy)</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>        <span class="keywordflow">elif</span> inferred_dtype == <span class="stringliteral">&quot;string&quot;</span>:</div>
<div class="line"><span class="lineno">  356</span>            <span class="comment"># StringArray/ArrowStringArray depending on pd.options.mode.string_storage</span></div>
<div class="line"><span class="lineno">  357</span>            <span class="keywordflow">return</span> StringDtype().construct_array_type()._from_sequence(data, copy=copy)</div>
<div class="line"><span class="lineno">  358</span> </div>
<div class="line"><span class="lineno">  359</span>        <span class="keywordflow">elif</span> inferred_dtype == <span class="stringliteral">&quot;integer&quot;</span>:</div>
<div class="line"><span class="lineno">  360</span>            <span class="keywordflow">return</span> IntegerArray._from_sequence(data, copy=copy)</div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>        <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno">  363</span>            inferred_dtype <span class="keywordflow">in</span> (<span class="stringliteral">&quot;floating&quot;</span>, <span class="stringliteral">&quot;mixed-integer-float&quot;</span>)</div>
<div class="line"><span class="lineno">  364</span>            <span class="keywordflow">and</span> getattr(data, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>) != np.float16</div>
<div class="line"><span class="lineno">  365</span>        ):</div>
<div class="line"><span class="lineno">  366</span>            <span class="comment"># GH#44715 Exclude np.float16 bc FloatingArray does not support it;</span></div>
<div class="line"><span class="lineno">  367</span>            <span class="comment">#  we will fall back to PandasArray.</span></div>
<div class="line"><span class="lineno">  368</span>            <span class="keywordflow">return</span> FloatingArray._from_sequence(data, copy=copy)</div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>        <span class="keywordflow">elif</span> inferred_dtype == <span class="stringliteral">&quot;boolean&quot;</span>:</div>
<div class="line"><span class="lineno">  371</span>            <span class="keywordflow">return</span> BooleanArray._from_sequence(data, copy=copy)</div>
<div class="line"><span class="lineno">  372</span> </div>
<div class="line"><span class="lineno">  373</span>    <span class="comment"># Pandas overrides NumPy for</span></div>
<div class="line"><span class="lineno">  374</span>    <span class="comment">#   1. datetime64[ns]</span></div>
<div class="line"><span class="lineno">  375</span>    <span class="comment">#   2. timedelta64[ns]</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="comment"># so that a DatetimeArray is returned.</span></div>
<div class="line"><span class="lineno">  377</span>    <span class="keywordflow">if</span> is_datetime64_ns_dtype(dtype):</div>
<div class="line"><span class="lineno">  378</span>        <span class="keywordflow">return</span> DatetimeArray._from_sequence(data, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  379</span>    <span class="keywordflow">elif</span> is_timedelta64_ns_dtype(dtype):</div>
<div class="line"><span class="lineno">  380</span>        <span class="keywordflow">return</span> TimedeltaArray._from_sequence(data, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  381</span> </div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">return</span> PandasArray._from_sequence(data, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  383</span> </div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span><span class="preprocessor">@overload</span></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1string___html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1string__.html">pandas.core.arrays.string_</a></div><div class="ttdef"><b>Definition</b> string_.py:1</div></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c6b12edcb352eee2bbef7cc915abdd7" name="a7c6b12edcb352eee2bbef7cc915abdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6b12edcb352eee2bbef7cc915abdd7">&#9670;&#160;</a></span>create_series_with_explicit_dtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Series pandas.core.construction.create_series_with_explicit_dtype </td>
          <td>(</td>
          <td class="paramtype">Any &#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayLike | Index | None &#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dtype | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>fastpath</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dtype &#160;</td>
          <td class="paramname"><em>dtype_if_empty</em> = <code>object</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to pass an explicit dtype when instantiating an empty Series.

This silences a DeprecationWarning described in GitHub-17261.

Parameters
----------
data : Mirrored from Series.__init__
index : Mirrored from Series.__init__
dtype : Mirrored from Series.__init__
name : Mirrored from Series.__init__
copy : Mirrored from Series.__init__
fastpath : Mirrored from Series.__init__
dtype_if_empty : str, numpy.dtype, or ExtensionDtype
    This dtype will be passed explicitly if an empty Series will
    be instantiated.

Returns
-------
Series
</pre> <div class="fragment"><div class="line"><span class="lineno">  889</span>) -&gt; Series:</div>
<div class="line"><span class="lineno">  890</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    Helper to pass an explicit dtype when instantiating an empty Series.</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    This silences a DeprecationWarning described in GitHub-17261.</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    data : Mirrored from Series.__init__</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    index : Mirrored from Series.__init__</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    dtype : Mirrored from Series.__init__</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    name : Mirrored from Series.__init__</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    copy : Mirrored from Series.__init__</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    fastpath : Mirrored from Series.__init__</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    dtype_if_empty : str, numpy.dtype, or ExtensionDtype</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">        This dtype will be passed explicitly if an empty Series will</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">        be instantiated.</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    Series</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  911</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1series.html">pandas.core.series</a> <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno">  912</span> </div>
<div class="line"><span class="lineno">  913</span>    <span class="keywordflow">if</span> is_empty_data(data) <span class="keywordflow">and</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  914</span>        dtype = dtype_if_empty</div>
<div class="line"><span class="lineno">  915</span>    <span class="keywordflow">return</span> Series(</div>
<div class="line"><span class="lineno">  916</span>        data=data, index=index, dtype=dtype, name=name, copy=copy, fastpath=fastpath</div>
<div class="line"><span class="lineno">  917</span>    )</div>
<div class="ttc" id="anamespacepandas_1_1core_1_1series_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1series.html">pandas.core.series</a></div><div class="ttdef"><b>Definition</b> series.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4eeb79cb38bf8bae6784b950612444df" name="a4eeb79cb38bf8bae6784b950612444df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eeb79cb38bf8bae6784b950612444df">&#9670;&#160;</a></span>ensure_wrapped_if_datetimelike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.construction.ensure_wrapped_if_datetimelike </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrap datetime64 and timedelta64 ndarrays in DatetimeArray/TimedeltaArray.
</pre> <div class="fragment"><div class="line"><span class="lineno">  461</span><span class="keyword">def </span>ensure_wrapped_if_datetimelike(arr):</div>
<div class="line"><span class="lineno">  462</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    Wrap datetime64 and timedelta64 ndarrays in DatetimeArray/TimedeltaArray.</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  465</span>    <span class="keywordflow">if</span> isinstance(arr, np.ndarray):</div>
<div class="line"><span class="lineno">  466</span>        <span class="keywordflow">if</span> arr.dtype.kind == <span class="stringliteral">&quot;M&quot;</span>:</div>
<div class="line"><span class="lineno">  467</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a> <span class="keyword">import</span> DatetimeArray</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>            <span class="keywordflow">return</span> DatetimeArray._from_sequence(arr)</div>
<div class="line"><span class="lineno">  470</span> </div>
<div class="line"><span class="lineno">  471</span>        <span class="keywordflow">elif</span> arr.dtype.kind == <span class="stringliteral">&quot;m&quot;</span>:</div>
<div class="line"><span class="lineno">  472</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a> <span class="keyword">import</span> TimedeltaArray</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span>            <span class="keywordflow">return</span> TimedeltaArray._from_sequence(arr)</div>
<div class="line"><span class="lineno">  475</span> </div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno">  477</span> </div>
<div class="line"><span class="lineno">  478</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abbd587f222eb5f66aa10dd69a8cdd689" name="abbd587f222eb5f66aa10dd69a8cdd689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd587f222eb5f66aa10dd69a8cdd689">&#9670;&#160;</a></span>extract_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.construction.extract_array </td>
          <td>(</td>
          <td class="paramtype">Series | Index&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>extract_numpy</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>extract_range</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  388</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  389</span>    ...</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span> </div>
<div class="line"><span class="lineno">  392</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb6667f09c9e05e99cbd38edb267c1c8" name="aeb6667f09c9e05e99cbd38edb267c1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6667f09c9e05e99cbd38edb267c1c8">&#9670;&#160;</a></span>extract_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T ArrayLike pandas.core.construction.extract_array </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extract_numpy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extract_range</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract the ndarray or ExtensionArray from a Series or Index.

For all other types, `obj` is just returned as is.

Parameters
----------
obj : object
    For Series / Index, the underlying ExtensionArray is unboxed.

extract_numpy : bool, default False
    Whether to extract the ndarray from a PandasArray.

extract_range : bool, default False
    If we have a RangeIndex, return range._values if True
    (which is a materialized integer ndarray), otherwise return unchanged.

Returns
-------
arr : object

Examples
--------
&gt;&gt;&gt; extract_array(pd.Series(['a', 'b', 'c'], dtype='category'))
['a', 'b', 'c']
Categories (3, object): ['a', 'b', 'c']

Other objects like lists, arrays, and DataFrames are just passed through.

&gt;&gt;&gt; extract_array([1, 2, 3])
[1, 2, 3]

For an ndarray-backed Series / Index the ndarray is returned.

&gt;&gt;&gt; extract_array(pd.Series([1, 2, 3]))
array([1, 2, 3])

To extract all the way down to the ndarray, pass ``extract_numpy=True``.

&gt;&gt;&gt; extract_array(pd.Series([1, 2, 3]), extract_numpy=True)
array([1, 2, 3])
</pre> <div class="fragment"><div class="line"><span class="lineno">  395</span>) -&gt; T | ArrayLike:</div>
<div class="line"><span class="lineno">  396</span>    ...</div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a92fffc0115b6967978fc16241383e635" name="a92fffc0115b6967978fc16241383e635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fffc0115b6967978fc16241383e635">&#9670;&#160;</a></span>is_empty_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.construction.is_empty_data </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Utility to check if a Series is instantiated with empty data,
which does not contain dtype information.

Parameters
----------
data : array-like, Iterable, dict, or scalar value
    Contains data stored in Series.

Returns
-------
bool
</pre> <div class="fragment"><div class="line"><span class="lineno">  861</span><span class="keyword">def </span>is_empty_data(data: Any) -&gt; bool:</div>
<div class="line"><span class="lineno">  862</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    Utility to check if a Series is instantiated with empty data,</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    which does not contain dtype information.</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    data : array-like, Iterable, dict, or scalar value</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">        Contains data stored in Series.</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    bool</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  875</span>    is_none = data <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  876</span>    is_list_like_without_dtype = is_list_like(data) <span class="keywordflow">and</span> <span class="keywordflow">not</span> hasattr(data, <span class="stringliteral">&quot;dtype&quot;</span>)</div>
<div class="line"><span class="lineno">  877</span>    is_simple_empty = is_list_like_without_dtype <span class="keywordflow">and</span> <span class="keywordflow">not</span> data</div>
<div class="line"><span class="lineno">  878</span>    <span class="keywordflow">return</span> is_none <span class="keywordflow">or</span> is_simple_empty</div>
<div class="line"><span class="lineno">  879</span> </div>
<div class="line"><span class="lineno">  880</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adb73d6fc3e1d4455259be9f7435b8bfb" name="adb73d6fc3e1d4455259be9f7435b8bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb73d6fc3e1d4455259be9f7435b8bfb">&#9670;&#160;</a></span>range_to_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.construction.range_to_ndarray </td>
          <td>(</td>
          <td class="paramtype">range&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cast a range object to ndarray.
</pre> <div class="fragment"><div class="line"><span class="lineno">  657</span><span class="keyword">def </span>range_to_ndarray(rng: range) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  658</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    Cast a range object to ndarray.</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  661</span>    <span class="comment"># GH#30171 perf avoid realizing range as a list in np.array</span></div>
<div class="line"><span class="lineno">  662</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  663</span>        arr = np.arange(rng.start, rng.stop, rng.step, dtype=<span class="stringliteral">&quot;int64&quot;</span>)</div>
<div class="line"><span class="lineno">  664</span>    <span class="keywordflow">except</span> OverflowError:</div>
<div class="line"><span class="lineno">  665</span>        <span class="comment"># GH#30173 handling for ranges that overflow int64</span></div>
<div class="line"><span class="lineno">  666</span>        <span class="keywordflow">if</span> (rng.start &gt;= 0 <span class="keywordflow">and</span> rng.step &gt; 0) <span class="keywordflow">or</span> (rng.stop &gt;= 0 <span class="keywordflow">and</span> rng.step &lt; 0):</div>
<div class="line"><span class="lineno">  667</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  668</span>                arr = np.arange(rng.start, rng.stop, rng.step, dtype=<span class="stringliteral">&quot;uint64&quot;</span>)</div>
<div class="line"><span class="lineno">  669</span>            <span class="keywordflow">except</span> OverflowError:</div>
<div class="line"><span class="lineno">  670</span>                arr = construct_1d_object_array_from_listlike(list(rng))</div>
<div class="line"><span class="lineno">  671</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  672</span>            arr = construct_1d_object_array_from_listlike(list(rng))</div>
<div class="line"><span class="lineno">  673</span>    <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8ac41d69083a7e2a24667b7b83a1b86" name="ae8ac41d69083a7e2a24667b7b83a1b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ac41d69083a7e2a24667b7b83a1b86">&#9670;&#160;</a></span>sanitize_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.construction.sanitize_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index | None&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raise_cast_failure</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>allow_2d</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sanitize input data to an ndarray or ExtensionArray, copy if specified,
coerce to the dtype if specified.

Parameters
----------
data : Any
index : Index or None, default None
dtype : np.dtype, ExtensionDtype, or None, default None
copy : bool, default False
raise_cast_failure : bool, default True
allow_2d : bool, default False
    If False, raise if we have a 2D Arraylike.

Returns
-------
np.ndarray or ExtensionArray

Notes
-----
raise_cast_failure=False is only intended to be True when called from the
DataFrame constructor, as the dtype keyword there may be interpreted as only
applying to a subset of columns, see GH#24435.
</pre> <div class="fragment"><div class="line"><span class="lineno">  501</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  502</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    Sanitize input data to an ndarray or ExtensionArray, copy if specified,</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    coerce to the dtype if specified.</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    data : Any</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    index : Index or None, default None</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    dtype : np.dtype, ExtensionDtype, or None, default None</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    copy : bool, default False</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    raise_cast_failure : bool, default True</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    allow_2d : bool, default False</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        If False, raise if we have a 2D Arraylike.</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    raise_cast_failure=False is only intended to be True when called from the</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    DataFrame constructor, as the dtype keyword there may be interpreted as only</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    applying to a subset of columns, see GH#24435.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  526</span>    <span class="keywordflow">if</span> isinstance(data, ma.MaskedArray):</div>
<div class="line"><span class="lineno">  527</span>        data = sanitize_masked_array(data)</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>    <span class="keywordflow">if</span> isinstance(dtype, PandasDtype):</div>
<div class="line"><span class="lineno">  530</span>        <span class="comment"># Avoid ending up with a PandasArray</span></div>
<div class="line"><span class="lineno">  531</span>        dtype = dtype.numpy_dtype</div>
<div class="line"><span class="lineno">  532</span> </div>
<div class="line"><span class="lineno">  533</span>    <span class="comment"># extract ndarray or ExtensionArray, ensure we have no PandasArray</span></div>
<div class="line"><span class="lineno">  534</span>    data = extract_array(data, extract_numpy=<span class="keyword">True</span>, extract_range=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  535</span> </div>
<div class="line"><span class="lineno">  536</span>    <span class="keywordflow">if</span> isinstance(data, np.ndarray) <span class="keywordflow">and</span> data.ndim == 0:</div>
<div class="line"><span class="lineno">  537</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  538</span>            dtype = data.dtype</div>
<div class="line"><span class="lineno">  539</span>        data = lib.item_from_zerodim(data)</div>
<div class="line"><span class="lineno">  540</span>    <span class="keywordflow">elif</span> isinstance(data, range):</div>
<div class="line"><span class="lineno">  541</span>        <span class="comment"># GH#16804</span></div>
<div class="line"><span class="lineno">  542</span>        data = range_to_ndarray(data)</div>
<div class="line"><span class="lineno">  543</span>        copy = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(data):</div>
<div class="line"><span class="lineno">  546</span>        <span class="keywordflow">if</span> index <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  547</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;index must be specified when data is not list-like&quot;</span>)</div>
<div class="line"><span class="lineno">  548</span>        data = construct_1d_arraylike_from_scalar(data, len(index), dtype)</div>
<div class="line"><span class="lineno">  549</span>        <span class="keywordflow">return</span> data</div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>    <span class="comment"># GH#846</span></div>
<div class="line"><span class="lineno">  552</span>    <span class="keywordflow">if</span> isinstance(data, np.ndarray):</div>
<div class="line"><span class="lineno">  553</span>        <span class="keywordflow">if</span> isinstance(data, np.matrix):</div>
<div class="line"><span class="lineno">  554</span>            data = data.A</div>
<div class="line"><span class="lineno">  555</span> </div>
<div class="line"><span class="lineno">  556</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> is_float_dtype(data.dtype) <span class="keywordflow">and</span> is_integer_dtype(dtype):</div>
<div class="line"><span class="lineno">  557</span>            <span class="comment"># possibility of nan -&gt; garbage</span></div>
<div class="line"><span class="lineno">  558</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  559</span>                <span class="comment"># GH 47391 numpy &gt; 1.24 will raise a RuntimeError for nan -&gt; int</span></div>
<div class="line"><span class="lineno">  560</span>                <span class="comment"># casting aligning with IntCastingNaNError below</span></div>
<div class="line"><span class="lineno">  561</span>                <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno">  562</span>                    subarr = _try_cast(data, dtype, copy, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  563</span>            <span class="keywordflow">except</span> IntCastingNaNError:</div>
<div class="line"><span class="lineno">  564</span>                warnings.warn(</div>
<div class="line"><span class="lineno">  565</span>                    <span class="stringliteral">&quot;In a future version, passing float-dtype values containing NaN &quot;</span></div>
<div class="line"><span class="lineno">  566</span>                    <span class="stringliteral">&quot;and an integer dtype will raise IntCastingNaNError &quot;</span></div>
<div class="line"><span class="lineno">  567</span>                    <span class="stringliteral">&quot;(subclass of ValueError) instead of silently ignoring the &quot;</span></div>
<div class="line"><span class="lineno">  568</span>                    <span class="stringliteral">&quot;passed dtype. To retain the old behavior, call Series(arr) or &quot;</span></div>
<div class="line"><span class="lineno">  569</span>                    <span class="stringliteral">&quot;DataFrame(arr) without passing a dtype.&quot;</span>,</div>
<div class="line"><span class="lineno">  570</span>                    FutureWarning,</div>
<div class="line"><span class="lineno">  571</span>                    stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  572</span>                )</div>
<div class="line"><span class="lineno">  573</span>                subarr = np.array(data, copy=copy)</div>
<div class="line"><span class="lineno">  574</span>            <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  575</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> raise_cast_failure:</div>
<div class="line"><span class="lineno">  576</span>                    <span class="comment"># i.e. called via DataFrame constructor</span></div>
<div class="line"><span class="lineno">  577</span>                    warnings.warn(</div>
<div class="line"><span class="lineno">  578</span>                        <span class="stringliteral">&quot;In a future version, passing float-dtype values and an &quot;</span></div>
<div class="line"><span class="lineno">  579</span>                        <span class="stringliteral">&quot;integer dtype to DataFrame will retain floating dtype &quot;</span></div>
<div class="line"><span class="lineno">  580</span>                        <span class="stringliteral">&quot;if they cannot be cast losslessly (matching Series behavior). &quot;</span></div>
<div class="line"><span class="lineno">  581</span>                        <span class="stringliteral">&quot;To retain the old behavior, use DataFrame(data).astype(dtype)&quot;</span>,</div>
<div class="line"><span class="lineno">  582</span>                        FutureWarning,</div>
<div class="line"><span class="lineno">  583</span>                        stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  584</span>                    )</div>
<div class="line"><span class="lineno">  585</span>                    <span class="comment"># GH#40110 until the deprecation is enforced, we _dont_</span></div>
<div class="line"><span class="lineno">  586</span>                    <span class="comment">#  ignore the dtype for DataFrame, and _do_ cast even though</span></div>
<div class="line"><span class="lineno">  587</span>                    <span class="comment">#  it is lossy.</span></div>
<div class="line"><span class="lineno">  588</span>                    dtype = cast(np.dtype, dtype)</div>
<div class="line"><span class="lineno">  589</span>                    <span class="keywordflow">return</span> np.array(data, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  590</span> </div>
<div class="line"><span class="lineno">  591</span>                <span class="comment"># We ignore the dtype arg and return floating values,</span></div>
<div class="line"><span class="lineno">  592</span>                <span class="comment">#  e.g. test_constructor_floating_data_int_dtype</span></div>
<div class="line"><span class="lineno">  593</span>                <span class="comment"># TODO: where is the discussion that documents the reason for this?</span></div>
<div class="line"><span class="lineno">  594</span>                subarr = np.array(data, copy=copy)</div>
<div class="line"><span class="lineno">  595</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  596</span>            <span class="comment"># we will try to copy by-definition here</span></div>
<div class="line"><span class="lineno">  597</span>            subarr = _try_cast(data, dtype, copy, raise_cast_failure)</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span>    <span class="keywordflow">elif</span> isinstance(data, ABCExtensionArray):</div>
<div class="line"><span class="lineno">  600</span>        <span class="comment"># it is already ensured above this is not a PandasArray</span></div>
<div class="line"><span class="lineno">  601</span>        subarr = data</div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  604</span>            subarr = subarr.astype(dtype, copy=copy)</div>
<div class="line"><span class="lineno">  605</span>        <span class="keywordflow">elif</span> copy:</div>
<div class="line"><span class="lineno">  606</span>            subarr = subarr.copy()</div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  609</span>        <span class="keywordflow">if</span> isinstance(data, (set, frozenset)):</div>
<div class="line"><span class="lineno">  610</span>            <span class="comment"># Raise only for unordered sets, e.g., not for dict_keys</span></div>
<div class="line"><span class="lineno">  611</span>            <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;&#39;{type(data).__name__}&#39; type is unordered&quot;</span>)</div>
<div class="line"><span class="lineno">  612</span> </div>
<div class="line"><span class="lineno">  613</span>        <span class="comment"># materialize e.g. generators, convert e.g. tuples, abc.ValueView</span></div>
<div class="line"><span class="lineno">  614</span>        <span class="keywordflow">if</span> hasattr(data, <span class="stringliteral">&quot;__array__&quot;</span>):</div>
<div class="line"><span class="lineno">  615</span>            <span class="comment"># e.g. dask array GH#38645</span></div>
<div class="line"><span class="lineno">  616</span>            data = np.array(data, copy=copy)</div>
<div class="line"><span class="lineno">  617</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  618</span>            data = list(data)</div>
<div class="line"><span class="lineno">  619</span> </div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> len(data) == 0:</div>
<div class="line"><span class="lineno">  621</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  622</span>                subarr = _try_cast(data, dtype, copy, raise_cast_failure)</div>
<div class="line"><span class="lineno">  623</span>            <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  624</span>                <span class="keywordflow">if</span> is_integer_dtype(dtype):</div>
<div class="line"><span class="lineno">  625</span>                    casted = np.array(data, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  626</span>                    <span class="keywordflow">if</span> casted.dtype.kind == <span class="stringliteral">&quot;f&quot;</span>:</div>
<div class="line"><span class="lineno">  627</span>                        <span class="comment"># GH#40110 match the behavior we have if we passed</span></div>
<div class="line"><span class="lineno">  628</span>                        <span class="comment">#  a ndarray[float] to begin with</span></div>
<div class="line"><span class="lineno">  629</span>                        <span class="keywordflow">return</span> sanitize_array(</div>
<div class="line"><span class="lineno">  630</span>                            casted,</div>
<div class="line"><span class="lineno">  631</span>                            index,</div>
<div class="line"><span class="lineno">  632</span>                            dtype,</div>
<div class="line"><span class="lineno">  633</span>                            copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  634</span>                            raise_cast_failure=raise_cast_failure,</div>
<div class="line"><span class="lineno">  635</span>                            allow_2d=allow_2d,</div>
<div class="line"><span class="lineno">  636</span>                        )</div>
<div class="line"><span class="lineno">  637</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  638</span>                        <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  639</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  640</span>                    <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  641</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  642</span>            subarr = maybe_convert_platform(data)</div>
<div class="line"><span class="lineno">  643</span>            <span class="keywordflow">if</span> subarr.dtype == object:</div>
<div class="line"><span class="lineno">  644</span>                subarr = cast(np.ndarray, subarr)</div>
<div class="line"><span class="lineno">  645</span>                subarr = maybe_infer_to_datetimelike(subarr)</div>
<div class="line"><span class="lineno">  646</span> </div>
<div class="line"><span class="lineno">  647</span>    subarr = _sanitize_ndim(subarr, data, dtype, index, allow_2d=allow_2d)</div>
<div class="line"><span class="lineno">  648</span> </div>
<div class="line"><span class="lineno">  649</span>    <span class="keywordflow">if</span> isinstance(subarr, np.ndarray):</div>
<div class="line"><span class="lineno">  650</span>        <span class="comment"># at this point we should have dtype be None or subarr.dtype == dtype</span></div>
<div class="line"><span class="lineno">  651</span>        dtype = cast(np.dtype, dtype)</div>
<div class="line"><span class="lineno">  652</span>        subarr = _sanitize_str_dtypes(subarr, data, dtype, copy)</div>
<div class="line"><span class="lineno">  653</span> </div>
<div class="line"><span class="lineno">  654</span>    <span class="keywordflow">return</span> subarr</div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40144a6be7d8844b260cbbbb21a31762" name="a40144a6be7d8844b260cbbbb21a31762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40144a6be7d8844b260cbbbb21a31762">&#9670;&#160;</a></span>sanitize_masked_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.construction.sanitize_masked_array </td>
          <td>(</td>
          <td class="paramtype">ma.MaskedArray&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert numpy MaskedArray to ensure mask is softened.
</pre> <div class="fragment"><div class="line"><span class="lineno">  479</span><span class="keyword">def </span>sanitize_masked_array(data: ma.MaskedArray) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  480</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    Convert numpy MaskedArray to ensure mask is softened.</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  483</span>    mask = ma.getmaskarray(data)</div>
<div class="line"><span class="lineno">  484</span>    <span class="keywordflow">if</span> mask.any():</div>
<div class="line"><span class="lineno">  485</span>        data, fill_value = maybe_upcast(data, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  486</span>        data.soften_mask()  <span class="comment"># set hardmask False if it was True</span></div>
<div class="line"><span class="lineno">  487</span>        data[mask] = fill_value</div>
<div class="line"><span class="lineno">  488</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  489</span>        data = data.copy()</div>
<div class="line"><span class="lineno">  490</span>    <span class="keywordflow">return</span> data</div>
<div class="line"><span class="lineno">  491</span> </div>
<div class="line"><span class="lineno">  492</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
