<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.sparse._construct Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse.html">sparse</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html">_construct</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.sparse._construct Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a791718fb9c41528476ee23151df753b9" id="r_a791718fb9c41528476ee23151df753b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a791718fb9c41528476ee23151df753b9">spdiags</a> (data, <a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a704412b4887282338f59536a054707f2">diags</a>, m=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, format=None)</td></tr>
<tr class="separator:a791718fb9c41528476ee23151df753b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704412b4887282338f59536a054707f2" id="r_a704412b4887282338f59536a054707f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a704412b4887282338f59536a054707f2">diags</a> (diagonals, offsets=0, shape=None, format=None, dtype=None)</td></tr>
<tr class="separator:a704412b4887282338f59536a054707f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2071b7b050559c6611572872f295b746" id="r_a2071b7b050559c6611572872f295b746"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a2071b7b050559c6611572872f295b746">identity</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, dtype='<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>', format=None)</td></tr>
<tr class="separator:a2071b7b050559c6611572872f295b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d5e7ae3589a4ac454349b1b38f5f00" id="r_a10d5e7ae3589a4ac454349b1b38f5f00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a10d5e7ae3589a4ac454349b1b38f5f00">eye</a> (m, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>=0, dtype=float, format=None)</td></tr>
<tr class="separator:a10d5e7ae3589a4ac454349b1b38f5f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07c2c9378c41369bb9ce06d8abd08f7" id="r_af07c2c9378c41369bb9ce06d8abd08f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#af07c2c9378c41369bb9ce06d8abd08f7">kron</a> (A, B, format=None)</td></tr>
<tr class="separator:af07c2c9378c41369bb9ce06d8abd08f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6e248d7663161229470792183a26f4" id="r_a9a6e248d7663161229470792183a26f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a9a6e248d7663161229470792183a26f4">kronsum</a> (A, B, format=None)</td></tr>
<tr class="separator:a9a6e248d7663161229470792183a26f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5283e4974abf4f0fa04041204ad6c5" id="r_a1b5283e4974abf4f0fa04041204ad6c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a1b5283e4974abf4f0fa04041204ad6c5">_compressed_sparse_stack</a> (blocks, axis)</td></tr>
<tr class="separator:a1b5283e4974abf4f0fa04041204ad6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31819b72e75791cb47d1919e0fa740a1" id="r_a31819b72e75791cb47d1919e0fa740a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a31819b72e75791cb47d1919e0fa740a1">_stack_along_minor_axis</a> (blocks, axis)</td></tr>
<tr class="separator:a31819b72e75791cb47d1919e0fa740a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5b77ab74b255553c3da738e27b6a10" id="r_a5b5b77ab74b255553c3da738e27b6a10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a5b5b77ab74b255553c3da738e27b6a10">hstack</a> (blocks, format=None, dtype=None)</td></tr>
<tr class="separator:a5b5b77ab74b255553c3da738e27b6a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98518cff890bf4844a76539c498e9428" id="r_a98518cff890bf4844a76539c498e9428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a98518cff890bf4844a76539c498e9428">vstack</a> (blocks, format=None, dtype=None)</td></tr>
<tr class="separator:a98518cff890bf4844a76539c498e9428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1fc04a0109e1ba5a0507531e940504" id="r_a6d1fc04a0109e1ba5a0507531e940504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a6d1fc04a0109e1ba5a0507531e940504">bmat</a> (blocks, format=None, dtype=None)</td></tr>
<tr class="separator:a6d1fc04a0109e1ba5a0507531e940504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674c838b459a86c137ffbcff0b5411fc" id="r_a674c838b459a86c137ffbcff0b5411fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a674c838b459a86c137ffbcff0b5411fc">block_diag</a> (mats, format=None, dtype=None)</td></tr>
<tr class="separator:a674c838b459a86c137ffbcff0b5411fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5138f0a780dddcca900cdbdfa987d1" id="r_acb5138f0a780dddcca900cdbdfa987d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#acb5138f0a780dddcca900cdbdfa987d1">random</a> (m, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, density=0.01, format='coo', dtype=None, random_state=None, data_rvs=None)</td></tr>
<tr class="separator:acb5138f0a780dddcca900cdbdfa987d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5233d128bc20de71666ce8bf68d46e" id="r_a2f5233d128bc20de71666ce8bf68d46e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1__construct.html#a2f5233d128bc20de71666ce8bf68d46e">rand</a> (m, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, density=0.01, format=&quot;coo&quot;, dtype=None, random_state=None)</td></tr>
<tr class="separator:a2f5233d128bc20de71666ce8bf68d46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions to construct sparse matrices
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a1b5283e4974abf4f0fa04041204ad6c5" name="a1b5283e4974abf4f0fa04041204ad6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5283e4974abf4f0fa04041204ad6c5">&#9670;&#160;</a></span>_compressed_sparse_stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct._compressed_sparse_stack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Stacking fast path for CSR/CSC matrices
(i) vstack for CSR, (ii) hstack for CSC.
</pre> <div class="fragment"><div class="line"><span class="lineno">  411</span><span class="keyword">def </span>_compressed_sparse_stack(blocks, axis):</div>
<div class="line"><span class="lineno">  412</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    Stacking fast path for CSR/CSC matrices</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    (i) vstack for CSR, (ii) hstack for CSC.</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  416</span>    other_axis = 1 <span class="keywordflow">if</span> axis == 0 <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno">  417</span>    data = np.concatenate([b.data <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks])</div>
<div class="line"><span class="lineno">  418</span>    constant_dim = blocks[0].shape[other_axis]</div>
<div class="line"><span class="lineno">  419</span>    idx_dtype = get_index_dtype(arrays=[b.indptr <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks],</div>
<div class="line"><span class="lineno">  420</span>                                maxval=max(data.size, constant_dim))</div>
<div class="line"><span class="lineno">  421</span>    indices = np.empty(data.size, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  422</span>    indptr = np.empty(sum(b.shape[axis] <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks) + 1, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  423</span>    last_indptr = idx_dtype(0)</div>
<div class="line"><span class="lineno">  424</span>    sum_dim = 0</div>
<div class="line"><span class="lineno">  425</span>    sum_indices = 0</div>
<div class="line"><span class="lineno">  426</span>    <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks:</div>
<div class="line"><span class="lineno">  427</span>        <span class="keywordflow">if</span> b.shape[other_axis] != constant_dim:</div>
<div class="line"><span class="lineno">  428</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;incompatible dimensions for axis {other_axis}&#39;</span>)</div>
<div class="line"><span class="lineno">  429</span>        indices[sum_indices:sum_indices+b.indices.size] = b.indices</div>
<div class="line"><span class="lineno">  430</span>        sum_indices += b.indices.size</div>
<div class="line"><span class="lineno">  431</span>        idxs = slice(sum_dim, sum_dim + b.shape[axis])</div>
<div class="line"><span class="lineno">  432</span>        indptr[idxs] = b.indptr[:-1]</div>
<div class="line"><span class="lineno">  433</span>        indptr[idxs] += last_indptr</div>
<div class="line"><span class="lineno">  434</span>        sum_dim += b.shape[axis]</div>
<div class="line"><span class="lineno">  435</span>        last_indptr += b.indptr[-1]</div>
<div class="line"><span class="lineno">  436</span>    indptr[-1] = last_indptr</div>
<div class="line"><span class="lineno">  437</span>    <span class="keywordflow">if</span> axis == 0:</div>
<div class="line"><span class="lineno">  438</span>        <span class="keywordflow">return</span> csr_matrix((data, indices, indptr),</div>
<div class="line"><span class="lineno">  439</span>                          shape=(sum_dim, constant_dim))</div>
<div class="line"><span class="lineno">  440</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  441</span>        <span class="keywordflow">return</span> csc_matrix((data, indices, indptr),</div>
<div class="line"><span class="lineno">  442</span>                          shape=(constant_dim, sum_dim))</div>
<div class="line"><span class="lineno">  443</span> </div>
<div class="line"><span class="lineno">  444</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a31819b72e75791cb47d1919e0fa740a1" name="a31819b72e75791cb47d1919e0fa740a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31819b72e75791cb47d1919e0fa740a1">&#9670;&#160;</a></span>_stack_along_minor_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct._stack_along_minor_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Stacking fast path for CSR/CSC matrices along the minor axis
(i) hstack for CSR, (ii) vstack for CSC.
</pre> <div class="fragment"><div class="line"><span class="lineno">  445</span><span class="keyword">def </span>_stack_along_minor_axis(blocks, axis):</div>
<div class="line"><span class="lineno">  446</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    Stacking fast path for CSR/CSC matrices along the minor axis</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    (i) hstack for CSR, (ii) vstack for CSC.</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  450</span>    n_blocks = len(blocks)</div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">if</span> n_blocks == 0:</div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Missing block matrices&#39;</span>)</div>
<div class="line"><span class="lineno">  453</span> </div>
<div class="line"><span class="lineno">  454</span>    <span class="keywordflow">if</span> n_blocks == 1:</div>
<div class="line"><span class="lineno">  455</span>        <span class="keywordflow">return</span> blocks[0]</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    <span class="comment"># check for incompatible dimensions</span></div>
<div class="line"><span class="lineno">  458</span>    other_axis = 1 <span class="keywordflow">if</span> axis == 0 <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno">  459</span>    other_axis_dims = set(b.shape[other_axis] <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks)</div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">if</span> len(other_axis_dims) &gt; 1:</div>
<div class="line"><span class="lineno">  461</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;Mismatching dimensions along axis {other_axis}: &#39;</span></div>
<div class="line"><span class="lineno">  462</span>                         f<span class="stringliteral">&#39;{other_axis_dims}&#39;</span>)</div>
<div class="line"><span class="lineno">  463</span>    constant_dim, = other_axis_dims</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span>    <span class="comment"># Do the stacking</span></div>
<div class="line"><span class="lineno">  466</span>    indptr_list = [b.indptr <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks]</div>
<div class="line"><span class="lineno">  467</span>    data_cat = np.concatenate([b.data <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks])</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>    <span class="comment"># Need to check if any indices/indptr, would be too large post-</span></div>
<div class="line"><span class="lineno">  470</span>    <span class="comment"># concatenation for np.int32:</span></div>
<div class="line"><span class="lineno">  471</span>    <span class="comment"># - The max value of indices is the output array&#39;s stacking-axis length - 1</span></div>
<div class="line"><span class="lineno">  472</span>    <span class="comment"># - The max value in indptr is the number of non-zero entries. This is</span></div>
<div class="line"><span class="lineno">  473</span>    <span class="comment">#   exceedingly unlikely to require int64, but is checked out of an</span></div>
<div class="line"><span class="lineno">  474</span>    <span class="comment">#   abundance of caution.</span></div>
<div class="line"><span class="lineno">  475</span>    sum_dim = sum(b.shape[axis] <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks)</div>
<div class="line"><span class="lineno">  476</span>    nnz = sum(len(b.indices) <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks)</div>
<div class="line"><span class="lineno">  477</span>    idx_dtype = get_index_dtype(maxval=max(sum_dim - 1, nnz))</div>
<div class="line"><span class="lineno">  478</span>    stack_dim_cat = np.array([b.shape[axis] <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks], dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  479</span>    <span class="keywordflow">if</span> data_cat.size &gt; 0:</div>
<div class="line"><span class="lineno">  480</span>        indptr_cat = np.concatenate(indptr_list).astype(idx_dtype)</div>
<div class="line"><span class="lineno">  481</span>        indices_cat = (np.concatenate([b.indices <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks])</div>
<div class="line"><span class="lineno">  482</span>                       .astype(idx_dtype))</div>
<div class="line"><span class="lineno">  483</span>        indptr = np.empty(constant_dim + 1, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  484</span>        indices = np.empty_like(indices_cat)</div>
<div class="line"><span class="lineno">  485</span>        data = np.empty_like(data_cat)</div>
<div class="line"><span class="lineno">  486</span>        csr_hstack(n_blocks, constant_dim, stack_dim_cat,</div>
<div class="line"><span class="lineno">  487</span>                   indptr_cat, indices_cat, data_cat,</div>
<div class="line"><span class="lineno">  488</span>                   indptr, indices, data)</div>
<div class="line"><span class="lineno">  489</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  490</span>        indptr = np.zeros(constant_dim + 1, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  491</span>        indices = np.empty(0, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  492</span>        data = np.empty(0, dtype=data_cat.dtype)</div>
<div class="line"><span class="lineno">  493</span> </div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">if</span> axis == 0:</div>
<div class="line"><span class="lineno">  495</span>        <span class="keywordflow">return</span> csc_matrix((data, indices, indptr),</div>
<div class="line"><span class="lineno">  496</span>                          shape=(sum_dim, constant_dim))</div>
<div class="line"><span class="lineno">  497</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  498</span>        <span class="keywordflow">return</span> csr_matrix((data, indices, indptr),</div>
<div class="line"><span class="lineno">  499</span>                          shape=(constant_dim, sum_dim))</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a674c838b459a86c137ffbcff0b5411fc" name="a674c838b459a86c137ffbcff0b5411fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674c838b459a86c137ffbcff0b5411fc">&#9670;&#160;</a></span>block_diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.block_diag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a block diagonal sparse matrix from provided matrices.

Parameters
----------
mats : sequence of matrices
    Input matrices.
format : str, optional
    The sparse format of the result (e.g., "csr"). If not given, the matrix
    is returned in "coo" format.
dtype : dtype specifier, optional
    The data-type of the output matrix. If not given, the dtype is
    determined from that of `blocks`.

Returns
-------
res : sparse matrix

Notes
-----

.. versionadded:: 0.11.0

See Also
--------
bmat, diags

Examples
--------
&gt;&gt;&gt; from scipy.sparse import coo_matrix, block_diag
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5], [6]])
&gt;&gt;&gt; C = coo_matrix([[7]])
&gt;&gt;&gt; block_diag((A, B, C)).toarray()
array([[1, 2, 0, 0],
       [3, 4, 0, 0],
       [0, 0, 5, 0],
       [0, 0, 6, 0],
       [0, 0, 0, 7]])</pre> <div class="fragment"><div class="line"><span class="lineno">  704</span><span class="keyword">def </span>block_diag(mats, format=None, dtype=None):</div>
<div class="line"><span class="lineno">  705</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    Build a block diagonal sparse matrix from provided matrices.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    mats : sequence of matrices</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        Input matrices.</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        The sparse format of the result (e.g., &quot;csr&quot;). If not given, the matrix</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        is returned in &quot;coo&quot; format.</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    dtype : dtype specifier, optional</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">        The data-type of the output matrix. If not given, the dtype is</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        determined from that of `blocks`.</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    res : sparse matrix</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    bmat, diags</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import coo_matrix, block_diag</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    &gt;&gt;&gt; B = coo_matrix([[5], [6]])</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    &gt;&gt;&gt; C = coo_matrix([[7]])</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    &gt;&gt;&gt; block_diag((A, B, C)).toarray()</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    array([[1, 2, 0, 0],</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">           [3, 4, 0, 0],</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">           [0, 0, 5, 0],</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">           [0, 0, 6, 0],</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">           [0, 0, 0, 7]])</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  746</span>    row = []</div>
<div class="line"><span class="lineno">  747</span>    col = []</div>
<div class="line"><span class="lineno">  748</span>    data = []</div>
<div class="line"><span class="lineno">  749</span>    r_idx = 0</div>
<div class="line"><span class="lineno">  750</span>    c_idx = 0</div>
<div class="line"><span class="lineno">  751</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> mats:</div>
<div class="line"><span class="lineno">  752</span>        <span class="keywordflow">if</span> isinstance(a, (list, numbers.Number)):</div>
<div class="line"><span class="lineno">  753</span>            a = coo_matrix(a)</div>
<div class="line"><span class="lineno">  754</span>        nrows, ncols = a.shape</div>
<div class="line"><span class="lineno">  755</span>        <span class="keywordflow">if</span> issparse(a):</div>
<div class="line"><span class="lineno">  756</span>            a = a.tocoo()</div>
<div class="line"><span class="lineno">  757</span>            row.append(a.row + r_idx)</div>
<div class="line"><span class="lineno">  758</span>            col.append(a.col + c_idx)</div>
<div class="line"><span class="lineno">  759</span>            data.append(a.data)</div>
<div class="line"><span class="lineno">  760</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  761</span>            a_row, a_col = np.divmod(np.arange(nrows*ncols), ncols)</div>
<div class="line"><span class="lineno">  762</span>            row.append(a_row + r_idx)</div>
<div class="line"><span class="lineno">  763</span>            col.append(a_col + c_idx)</div>
<div class="line"><span class="lineno">  764</span>            data.append(a.ravel())</div>
<div class="line"><span class="lineno">  765</span>        r_idx += nrows</div>
<div class="line"><span class="lineno">  766</span>        c_idx += ncols</div>
<div class="line"><span class="lineno">  767</span>    row = np.concatenate(row)</div>
<div class="line"><span class="lineno">  768</span>    col = np.concatenate(col)</div>
<div class="line"><span class="lineno">  769</span>    data = np.concatenate(data)</div>
<div class="line"><span class="lineno">  770</span>    <span class="keywordflow">return</span> coo_matrix((data, (row, col)),</div>
<div class="line"><span class="lineno">  771</span>                      shape=(r_idx, c_idx),</div>
<div class="line"><span class="lineno">  772</span>                      dtype=dtype).asformat(format)</div>
<div class="line"><span class="lineno">  773</span> </div>
<div class="line"><span class="lineno">  774</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d1fc04a0109e1ba5a0507531e940504" name="a6d1fc04a0109e1ba5a0507531e940504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1fc04a0109e1ba5a0507531e940504">&#9670;&#160;</a></span>bmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.bmat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a sparse matrix from sparse sub-blocks

Parameters
----------
blocks : array_like
    Grid of sparse matrices with compatible shapes.
    An entry of None implies an all-zero matrix.
format : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional
    The sparse format of the result (e.g. "csr"). By default an
    appropriate sparse matrix format is returned.
    This choice is subject to change.
dtype : dtype, optional
    The data-type of the output matrix. If not given, the dtype is
    determined from that of `blocks`.

Returns
-------
bmat : sparse matrix

See Also
--------
block_diag, diags

Examples
--------
&gt;&gt;&gt; from scipy.sparse import coo_matrix, bmat
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5], [6]])
&gt;&gt;&gt; C = coo_matrix([[7]])
&gt;&gt;&gt; bmat([[A, B], [None, C]]).toarray()
array([[1, 2, 5],
       [3, 4, 6],
       [0, 0, 7]])

&gt;&gt;&gt; bmat([[A, None], [None, C]]).toarray()
array([[1, 2, 0],
       [3, 4, 0],
       [0, 0, 7]])</pre> <div class="fragment"><div class="line"><span class="lineno">  569</span><span class="keyword">def </span>bmat(blocks, format=None, dtype=None):</div>
<div class="line"><span class="lineno">  570</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    Build a sparse matrix from sparse sub-blocks</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    blocks : array_like</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        Grid of sparse matrices with compatible shapes.</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        An entry of None implies an all-zero matrix.</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    format : {&#39;bsr&#39;, &#39;coo&#39;, &#39;csc&#39;, &#39;csr&#39;, &#39;dia&#39;, &#39;dok&#39;, &#39;lil&#39;}, optional</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        The sparse format of the result (e.g. &quot;csr&quot;). By default an</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">        appropriate sparse matrix format is returned.</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        This choice is subject to change.</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        The data-type of the output matrix. If not given, the dtype is</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        determined from that of `blocks`.</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    bmat : sparse matrix</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    block_diag, diags</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import coo_matrix, bmat</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    &gt;&gt;&gt; B = coo_matrix([[5], [6]])</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    &gt;&gt;&gt; C = coo_matrix([[7]])</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    &gt;&gt;&gt; bmat([[A, B], [None, C]]).toarray()</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    array([[1, 2, 5],</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">           [3, 4, 6],</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">           [0, 0, 7]])</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    &gt;&gt;&gt; bmat([[A, None], [None, C]]).toarray()</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    array([[1, 2, 0],</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">           [3, 4, 0],</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">           [0, 0, 7]])</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>    blocks = np.asarray(blocks, dtype=<span class="stringliteral">&#39;object&#39;</span>)</div>
<div class="line"><span class="lineno">  613</span> </div>
<div class="line"><span class="lineno">  614</span>    <span class="keywordflow">if</span> blocks.ndim != 2:</div>
<div class="line"><span class="lineno">  615</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;blocks must be 2-D&#39;</span>)</div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span>    M,N = blocks.shape</div>
<div class="line"><span class="lineno">  618</span> </div>
<div class="line"><span class="lineno">  619</span>    <span class="comment"># check for fast path cases</span></div>
<div class="line"><span class="lineno">  620</span>    <span class="keywordflow">if</span> (format <span class="keywordflow">in</span> (<span class="keywordtype">None</span>, <span class="stringliteral">&#39;csr&#39;</span>) <span class="keywordflow">and</span> all(isinstance(b, csr_matrix)</div>
<div class="line"><span class="lineno">  621</span>                                        <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks.flat)):</div>
<div class="line"><span class="lineno">  622</span>        <span class="keywordflow">if</span> N &gt; 1:</div>
<div class="line"><span class="lineno">  623</span>            <span class="comment"># stack along columns (axis 1):</span></div>
<div class="line"><span class="lineno">  624</span>            blocks = [[_stack_along_minor_axis(blocks[b, :], 1)]</div>
<div class="line"><span class="lineno">  625</span>                      <span class="keywordflow">for</span> b <span class="keywordflow">in</span> range(M)]   <span class="comment"># must have shape: (M, 1)</span></div>
<div class="line"><span class="lineno">  626</span>            blocks = np.asarray(blocks, dtype=<span class="stringliteral">&#39;object&#39;</span>)</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>        <span class="comment"># stack along rows (axis 0):</span></div>
<div class="line"><span class="lineno">  629</span>        A = _compressed_sparse_stack(blocks[:, 0], 0)</div>
<div class="line"><span class="lineno">  630</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  631</span>            A = A.astype(dtype)</div>
<div class="line"><span class="lineno">  632</span>        <span class="keywordflow">return</span> A</div>
<div class="line"><span class="lineno">  633</span>    <span class="keywordflow">elif</span> (format <span class="keywordflow">in</span> (<span class="keywordtype">None</span>, <span class="stringliteral">&#39;csc&#39;</span>) <span class="keywordflow">and</span> all(isinstance(b, csc_matrix)</div>
<div class="line"><span class="lineno">  634</span>                                          <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks.flat)):</div>
<div class="line"><span class="lineno">  635</span>        <span class="keywordflow">if</span> M &gt; 1:</div>
<div class="line"><span class="lineno">  636</span>            <span class="comment"># stack along rows (axis 0):</span></div>
<div class="line"><span class="lineno">  637</span>            blocks = [[_stack_along_minor_axis(blocks[:, b], 0)</div>
<div class="line"><span class="lineno">  638</span>                       <span class="keywordflow">for</span> b <span class="keywordflow">in</span> range(N)]]   <span class="comment"># must have shape: (1, N)</span></div>
<div class="line"><span class="lineno">  639</span>            blocks = np.asarray(blocks, dtype=<span class="stringliteral">&#39;object&#39;</span>)</div>
<div class="line"><span class="lineno">  640</span> </div>
<div class="line"><span class="lineno">  641</span>        <span class="comment"># stack along columns (axis 1):</span></div>
<div class="line"><span class="lineno">  642</span>        A = _compressed_sparse_stack(blocks[0, :], 1)</div>
<div class="line"><span class="lineno">  643</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  644</span>            A = A.astype(dtype)</div>
<div class="line"><span class="lineno">  645</span>        <span class="keywordflow">return</span> A</div>
<div class="line"><span class="lineno">  646</span> </div>
<div class="line"><span class="lineno">  647</span>    block_mask = np.zeros(blocks.shape, dtype=bool)</div>
<div class="line"><span class="lineno">  648</span>    brow_lengths = np.zeros(M, dtype=np.int64)</div>
<div class="line"><span class="lineno">  649</span>    bcol_lengths = np.zeros(N, dtype=np.int64)</div>
<div class="line"><span class="lineno">  650</span> </div>
<div class="line"><span class="lineno">  651</span>    <span class="comment"># convert everything to COO format</span></div>
<div class="line"><span class="lineno">  652</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(M):</div>
<div class="line"><span class="lineno">  653</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(N):</div>
<div class="line"><span class="lineno">  654</span>            <span class="keywordflow">if</span> blocks[i,j] <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  655</span>                A = coo_matrix(blocks[i,j])</div>
<div class="line"><span class="lineno">  656</span>                blocks[i,j] = A</div>
<div class="line"><span class="lineno">  657</span>                block_mask[i,j] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span>                <span class="keywordflow">if</span> brow_lengths[i] == 0:</div>
<div class="line"><span class="lineno">  660</span>                    brow_lengths[i] = A.shape[0]</div>
<div class="line"><span class="lineno">  661</span>                <span class="keywordflow">elif</span> brow_lengths[i] != A.shape[0]:</div>
<div class="line"><span class="lineno">  662</span>                    msg = (f<span class="stringliteral">&#39;blocks[{i},:] has incompatible row dimensions. &#39;</span></div>
<div class="line"><span class="lineno">  663</span>                           f<span class="stringliteral">&#39;Got blocks[{i},{j}].shape[0] == {A.shape[0]}, &#39;</span></div>
<div class="line"><span class="lineno">  664</span>                           f<span class="stringliteral">&#39;expected {brow_lengths[i]}.&#39;</span>)</div>
<div class="line"><span class="lineno">  665</span>                    <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span>                <span class="keywordflow">if</span> bcol_lengths[j] == 0:</div>
<div class="line"><span class="lineno">  668</span>                    bcol_lengths[j] = A.shape[1]</div>
<div class="line"><span class="lineno">  669</span>                <span class="keywordflow">elif</span> bcol_lengths[j] != A.shape[1]:</div>
<div class="line"><span class="lineno">  670</span>                    msg = (f<span class="stringliteral">&#39;blocks[:,{j}] has incompatible column &#39;</span></div>
<div class="line"><span class="lineno">  671</span>                           f<span class="stringliteral">&#39;dimensions. &#39;</span></div>
<div class="line"><span class="lineno">  672</span>                           f<span class="stringliteral">&#39;Got blocks[{i},{j}].shape[1] == {A.shape[1]}, &#39;</span></div>
<div class="line"><span class="lineno">  673</span>                           f<span class="stringliteral">&#39;expected {bcol_lengths[j]}.&#39;</span>)</div>
<div class="line"><span class="lineno">  674</span>                    <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  675</span> </div>
<div class="line"><span class="lineno">  676</span>    nnz = sum(block.nnz <span class="keywordflow">for</span> block <span class="keywordflow">in</span> blocks[block_mask])</div>
<div class="line"><span class="lineno">  677</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  678</span>        all_dtypes = [blk.dtype <span class="keywordflow">for</span> blk <span class="keywordflow">in</span> blocks[block_mask]]</div>
<div class="line"><span class="lineno">  679</span>        dtype = upcast(*all_dtypes) <span class="keywordflow">if</span> all_dtypes <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  680</span> </div>
<div class="line"><span class="lineno">  681</span>    row_offsets = np.append(0, np.cumsum(brow_lengths))</div>
<div class="line"><span class="lineno">  682</span>    col_offsets = np.append(0, np.cumsum(bcol_lengths))</div>
<div class="line"><span class="lineno">  683</span> </div>
<div class="line"><span class="lineno">  684</span>    shape = (row_offsets[-1], col_offsets[-1])</div>
<div class="line"><span class="lineno">  685</span> </div>
<div class="line"><span class="lineno">  686</span>    data = np.empty(nnz, dtype=dtype)</div>
<div class="line"><span class="lineno">  687</span>    idx_dtype = get_index_dtype(maxval=max(shape))</div>
<div class="line"><span class="lineno">  688</span>    row = np.empty(nnz, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  689</span>    col = np.empty(nnz, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  690</span> </div>
<div class="line"><span class="lineno">  691</span>    nnz = 0</div>
<div class="line"><span class="lineno">  692</span>    ii, jj = np.nonzero(block_mask)</div>
<div class="line"><span class="lineno">  693</span>    <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> zip(ii, jj):</div>
<div class="line"><span class="lineno">  694</span>        B = blocks[i, j]</div>
<div class="line"><span class="lineno">  695</span>        idx = slice(nnz, nnz + B.nnz)</div>
<div class="line"><span class="lineno">  696</span>        data[idx] = B.data</div>
<div class="line"><span class="lineno">  697</span>        np.add(B.row, row_offsets[i], out=row[idx], dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  698</span>        np.add(B.col, col_offsets[j], out=col[idx], dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  699</span>        nnz += B.nnz</div>
<div class="line"><span class="lineno">  700</span> </div>
<div class="line"><span class="lineno">  701</span>    <span class="keywordflow">return</span> coo_matrix((data, (row, col)), shape=shape).asformat(format)</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a704412b4887282338f59536a054707f2" name="a704412b4887282338f59536a054707f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704412b4887282338f59536a054707f2">&#9670;&#160;</a></span>diags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.diags </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diagonals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a sparse matrix from diagonals.

Parameters
----------
diagonals : sequence of array_like
    Sequence of arrays containing the matrix diagonals,
    corresponding to `offsets`.
offsets : sequence of int or an int, optional
    Diagonals to set:
      - k = 0  the main diagonal (default)
      - k &gt; 0  the kth upper diagonal
      - k &lt; 0  the kth lower diagonal
shape : tuple of int, optional
    Shape of the result. If omitted, a square matrix large enough
    to contain the diagonals is returned.
format : {"dia", "csr", "csc", "lil", ...}, optional
    Matrix format of the result. By default (format=None) an
    appropriate sparse matrix format is returned. This choice is
    subject to change.
dtype : dtype, optional
    Data type of the matrix.

See Also
--------
spdiags : construct matrix from diagonals

Notes
-----
This function differs from `spdiags` in the way it handles
off-diagonals.

The result from `diags` is the sparse equivalent of::

    np.diag(diagonals[0], offsets[0])
    + ...
    + np.diag(diagonals[k], offsets[k])

Repeated diagonal offsets are disallowed.

.. versionadded:: 0.11

Examples
--------
&gt;&gt;&gt; from scipy.sparse import diags
&gt;&gt;&gt; diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]]
&gt;&gt;&gt; diags(diagonals, [0, -1, 2]).toarray()
array([[1, 0, 1, 0],
       [1, 2, 0, 2],
       [0, 2, 3, 0],
       [0, 0, 3, 4]])

Broadcasting of scalars is supported (but shape needs to be
specified):

&gt;&gt;&gt; diags([1, -2, 1], [-1, 0, 1], shape=(4, 4)).toarray()
array([[-2.,  1.,  0.,  0.],
       [ 1., -2.,  1.,  0.],
       [ 0.,  1., -2.,  1.],
       [ 0.,  0.,  1., -2.]])


If only one diagonal is wanted (as in `numpy.diag`), the following
works as well:

&gt;&gt;&gt; diags([1, 2, 3], 1).toarray()
array([[ 0.,  1.,  0.,  0.],
       [ 0.,  0.,  2.,  0.],
       [ 0.,  0.,  0.,  3.],
       [ 0.,  0.,  0.,  0.]])
</pre> <div class="fragment"><div class="line"><span class="lineno">   72</span><span class="keyword">def </span>diags(diagonals, offsets=0, shape=None, format=None, dtype=None):</div>
<div class="line"><span class="lineno">   73</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    Construct a sparse matrix from diagonals.</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    diagonals : sequence of array_like</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        Sequence of arrays containing the matrix diagonals,</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">        corresponding to `offsets`.</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    offsets : sequence of int or an int, optional</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        Diagonals to set:</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">          - k = 0  the main diagonal (default)</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">          - k &gt; 0  the kth upper diagonal</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">          - k &lt; 0  the kth lower diagonal</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    shape : tuple of int, optional</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        Shape of the result. If omitted, a square matrix large enough</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        to contain the diagonals is returned.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    format : {&quot;dia&quot;, &quot;csr&quot;, &quot;csc&quot;, &quot;lil&quot;, ...}, optional</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        Matrix format of the result. By default (format=None) an</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        appropriate sparse matrix format is returned. This choice is</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        subject to change.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        Data type of the matrix.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    spdiags : construct matrix from diagonals</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    This function differs from `spdiags` in the way it handles</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    off-diagonals.</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    The result from `diags` is the sparse equivalent of::</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        np.diag(diagonals[0], offsets[0])</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        + ...</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        + np.diag(diagonals[k], offsets[k])</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    Repeated diagonal offsets are disallowed.</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    .. versionadded:: 0.11</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import diags</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &gt;&gt;&gt; diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]]</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    &gt;&gt;&gt; diags(diagonals, [0, -1, 2]).toarray()</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    array([[1, 0, 1, 0],</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">           [1, 2, 0, 2],</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">           [0, 2, 3, 0],</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">           [0, 0, 3, 4]])</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    Broadcasting of scalars is supported (but shape needs to be</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    specified):</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    &gt;&gt;&gt; diags([1, -2, 1], [-1, 0, 1], shape=(4, 4)).toarray()</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    array([[-2.,  1.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">           [ 1., -2.,  1.,  0.],</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">           [ 0.,  1., -2.,  1.],</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">           [ 0.,  0.,  1., -2.]])</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    If only one diagonal is wanted (as in `numpy.diag`), the following</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    works as well:</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    &gt;&gt;&gt; diags([1, 2, 3], 1).toarray()</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    array([[ 0.,  1.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">           [ 0.,  0.,  2.,  0.],</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">           [ 0.,  0.,  0.,  3.],</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">           [ 0.,  0.,  0.,  0.]])</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  144</span>    <span class="comment"># if offsets is not a sequence, assume that there&#39;s only one diagonal</span></div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">if</span> isscalarlike(offsets):</div>
<div class="line"><span class="lineno">  146</span>        <span class="comment"># now check that there&#39;s actually only one diagonal</span></div>
<div class="line"><span class="lineno">  147</span>        <span class="keywordflow">if</span> len(diagonals) == 0 <span class="keywordflow">or</span> isscalarlike(diagonals[0]):</div>
<div class="line"><span class="lineno">  148</span>            diagonals = [np.atleast_1d(diagonals)]</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  150</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Different number of diagonals and offsets.&quot;</span>)</div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  152</span>        diagonals = list(map(np.atleast_1d, diagonals))</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span>    offsets = np.atleast_1d(offsets)</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>    <span class="comment"># Basic check</span></div>
<div class="line"><span class="lineno">  157</span>    <span class="keywordflow">if</span> len(diagonals) != len(offsets):</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Different number of diagonals and offsets.&quot;</span>)</div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>    <span class="comment"># Determine shape, if omitted</span></div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">if</span> shape <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  162</span>        m = len(diagonals[0]) + abs(int(offsets[0]))</div>
<div class="line"><span class="lineno">  163</span>        shape = (m, m)</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    <span class="comment"># Determine data type, if omitted</span></div>
<div class="line"><span class="lineno">  166</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  167</span>        dtype = np.common_type(*diagonals)</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>    <span class="comment"># Construct data array</span></div>
<div class="line"><span class="lineno">  170</span>    m, n = shape</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>    M = max([min(m + offset, n - offset) + max(0, offset)</div>
<div class="line"><span class="lineno">  173</span>             <span class="keywordflow">for</span> offset <span class="keywordflow">in</span> offsets])</div>
<div class="line"><span class="lineno">  174</span>    M = max(0, M)</div>
<div class="line"><span class="lineno">  175</span>    data_arr = np.zeros((len(offsets), M), dtype=dtype)</div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span>    K = min(m, n)</div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>    <span class="keywordflow">for</span> j, diagonal <span class="keywordflow">in</span> enumerate(diagonals):</div>
<div class="line"><span class="lineno">  180</span>        offset = offsets[j]</div>
<div class="line"><span class="lineno">  181</span>        k = max(0, offset)</div>
<div class="line"><span class="lineno">  182</span>        length = min(m + offset, n - offset, K)</div>
<div class="line"><span class="lineno">  183</span>        <span class="keywordflow">if</span> length &lt; 0:</div>
<div class="line"><span class="lineno">  184</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Offset %d (index %d) out of bounds&quot;</span> % (offset, j))</div>
<div class="line"><span class="lineno">  185</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  186</span>            data_arr[j, k:k+length] = diagonal[...,:length]</div>
<div class="line"><span class="lineno">  187</span>        <span class="keywordflow">except</span> ValueError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  188</span>            <span class="keywordflow">if</span> len(diagonal) != length <span class="keywordflow">and</span> len(diagonal) != 1:</div>
<div class="line"><span class="lineno">  189</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  190</span>                    <span class="stringliteral">&quot;Diagonal length (index %d: %d at offset %d) does not &quot;</span></div>
<div class="line"><span class="lineno">  191</span>                    <span class="stringliteral">&quot;agree with matrix size (%d, %d).&quot;</span> % (</div>
<div class="line"><span class="lineno">  192</span>                    j, len(diagonal), offset, m, n)) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  193</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  194</span> </div>
<div class="line"><span class="lineno">  195</span>    <span class="keywordflow">return</span> dia_matrix((data_arr, offsets), shape=(m, n)).asformat(format)</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a10d5e7ae3589a4ac454349b1b38f5f00" name="a10d5e7ae3589a4ac454349b1b38f5f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d5e7ae3589a4ac454349b1b38f5f00">&#9670;&#160;</a></span>eye()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.eye </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sparse matrix with ones on diagonal

Returns a sparse (m x n) matrix where the kth diagonal
is all ones and everything else is zeros.

Parameters
----------
m : int
    Number of rows in the matrix.
n : int, optional
    Number of columns. Default: `m`.
k : int, optional
    Diagonal to place ones on. Default: 0 (main diagonal).
dtype : dtype, optional
    Data type of the matrix.
format : str, optional
    Sparse format of the result, e.g., format="csr", etc.

Examples
--------
&gt;&gt;&gt; from scipy import sparse
&gt;&gt;&gt; sparse.eye(3).toarray()
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; sparse.eye(3, dtype=np.int8)
&lt;3x3 sparse matrix of type '&lt;class 'numpy.int8'&gt;'
    with 3 stored elements (1 diagonals) in DIAgonal format&gt;</pre> <div class="fragment"><div class="line"><span class="lineno">  228</span><span class="keyword">def </span>eye(m, n=None, k=0, dtype=float, format=None):</div>
<div class="line"><span class="lineno">  229</span>    <span class="stringliteral">&quot;&quot;&quot;Sparse matrix with ones on diagonal</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Returns a sparse (m x n) matrix where the kth diagonal</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    is all ones and everything else is zeros.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    m : int</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        Number of rows in the matrix.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        Number of columns. Default: `m`.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    k : int, optional</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">        Diagonal to place ones on. Default: 0 (main diagonal).</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">        Data type of the matrix.</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        Sparse format of the result, e.g., format=&quot;csr&quot;, etc.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import sparse</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    &gt;&gt;&gt; sparse.eye(3).toarray()</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    array([[ 1.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">           [ 0.,  1.,  0.],</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">           [ 0.,  0.,  1.]])</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    &gt;&gt;&gt; sparse.eye(3, dtype=np.int8)</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    &lt;3x3 sparse matrix of type &#39;&lt;class &#39;numpy.int8&#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        with 3 stored elements (1 diagonals) in DIAgonal format&gt;</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  259</span>    <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  260</span>        n = m</div>
<div class="line"><span class="lineno">  261</span>    m,n = int(m),int(n)</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span>    <span class="keywordflow">if</span> m == n <span class="keywordflow">and</span> k == 0:</div>
<div class="line"><span class="lineno">  264</span>        <span class="comment"># fast branch for special formats</span></div>
<div class="line"><span class="lineno">  265</span>        <span class="keywordflow">if</span> format <span class="keywordflow">in</span> [<span class="stringliteral">&#39;csr&#39;</span>, <span class="stringliteral">&#39;csc&#39;</span>]:</div>
<div class="line"><span class="lineno">  266</span>            idx_dtype = get_index_dtype(maxval=n)</div>
<div class="line"><span class="lineno">  267</span>            indptr = np.arange(n+1, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  268</span>            indices = np.arange(n, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  269</span>            data = np.ones(n, dtype=dtype)</div>
<div class="line"><span class="lineno">  270</span>            cls = {<span class="stringliteral">&#39;csr&#39;</span>: csr_matrix, <span class="stringliteral">&#39;csc&#39;</span>: csc_matrix}[format]</div>
<div class="line"><span class="lineno">  271</span>            <span class="keywordflow">return</span> cls((data,indices,indptr),(n,n))</div>
<div class="line"><span class="lineno">  272</span>        <span class="keywordflow">elif</span> format == <span class="stringliteral">&#39;coo&#39;</span>:</div>
<div class="line"><span class="lineno">  273</span>            idx_dtype = get_index_dtype(maxval=n)</div>
<div class="line"><span class="lineno">  274</span>            row = np.arange(n, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  275</span>            col = np.arange(n, dtype=idx_dtype)</div>
<div class="line"><span class="lineno">  276</span>            data = np.ones(n, dtype=dtype)</div>
<div class="line"><span class="lineno">  277</span>            <span class="keywordflow">return</span> coo_matrix((data, (row, col)), (n, n))</div>
<div class="line"><span class="lineno">  278</span> </div>
<div class="line"><span class="lineno">  279</span>    diags = np.ones((1, max(0, min(m + k, n))), dtype=dtype)</div>
<div class="line"><span class="lineno">  280</span>    <span class="keywordflow">return</span> spdiags(diags, k, m, n).asformat(format)</div>
<div class="line"><span class="lineno">  281</span> </div>
<div class="line"><span class="lineno">  282</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b5b77ab74b255553c3da738e27b6a10" name="a5b5b77ab74b255553c3da738e27b6a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5b77ab74b255553c3da738e27b6a10">&#9670;&#160;</a></span>hstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.hstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stack sparse matrices horizontally (column wise)

Parameters
----------
blocks
    sequence of sparse matrices with compatible shapes
format : str
    sparse format of the result (e.g., "csr")
    by default an appropriate sparse matrix format is returned.
    This choice is subject to change.
dtype : dtype, optional
    The data-type of the output matrix. If not given, the dtype is
    determined from that of `blocks`.

See Also
--------
vstack : stack sparse matrices vertically (row wise)

Examples
--------
&gt;&gt;&gt; from scipy.sparse import coo_matrix, hstack
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5], [6]])
&gt;&gt;&gt; hstack([A,B]).toarray()
array([[1, 2, 5],
       [3, 4, 6]])</pre> <div class="fragment"><div class="line"><span class="lineno">  502</span><span class="keyword">def </span>hstack(blocks, format=None, dtype=None):</div>
<div class="line"><span class="lineno">  503</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    Stack sparse matrices horizontally (column wise)</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    blocks</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        sequence of sparse matrices with compatible shapes</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    format : str</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        sparse format of the result (e.g., &quot;csr&quot;)</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        by default an appropriate sparse matrix format is returned.</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        This choice is subject to change.</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        The data-type of the output matrix. If not given, the dtype is</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        determined from that of `blocks`.</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    vstack : stack sparse matrices vertically (row wise)</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import coo_matrix, hstack</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    &gt;&gt;&gt; B = coo_matrix([[5], [6]])</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    &gt;&gt;&gt; hstack([A,B]).toarray()</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    array([[1, 2, 5],</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">           [3, 4, 6]])</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  532</span>    <span class="keywordflow">return</span> bmat([blocks], format=format, dtype=dtype)</div>
<div class="line"><span class="lineno">  533</span> </div>
<div class="line"><span class="lineno">  534</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2071b7b050559c6611572872f295b746" name="a2071b7b050559c6611572872f295b746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2071b7b050559c6611572872f295b746">&#9670;&#160;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.identity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>'<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Identity matrix in sparse format

Returns an identity matrix with shape (n,n) using a given
sparse format and dtype.

Parameters
----------
n : int
    Shape of the identity matrix.
dtype : dtype, optional
    Data type of the matrix
format : str, optional
    Sparse format of the result, e.g., format="csr", etc.

Examples
--------
&gt;&gt;&gt; from scipy.sparse import identity
&gt;&gt;&gt; identity(3).toarray()
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; identity(3, dtype='int8', format='dia')
&lt;3x3 sparse matrix of type '&lt;class 'numpy.int8'&gt;'
        with 3 stored elements (1 diagonals) in DIAgonal format&gt;</pre> <div class="fragment"><div class="line"><span class="lineno">  198</span><span class="keyword">def </span>identity(n, dtype=&#39;d&#39;, format=None):</div>
<div class="line"><span class="lineno">  199</span>    <span class="stringliteral">&quot;&quot;&quot;Identity matrix in sparse format</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    Returns an identity matrix with shape (n,n) using a given</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    sparse format and dtype.</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        Shape of the identity matrix.</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        Data type of the matrix</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        Sparse format of the result, e.g., format=&quot;csr&quot;, etc.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import identity</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &gt;&gt;&gt; identity(3).toarray()</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    array([[ 1.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">           [ 0.,  1.,  0.],</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">           [ 0.,  0.,  1.]])</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    &gt;&gt;&gt; identity(3, dtype=&#39;int8&#39;, format=&#39;dia&#39;)</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    &lt;3x3 sparse matrix of type &#39;&lt;class &#39;numpy.int8&#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">            with 3 stored elements (1 diagonals) in DIAgonal format&gt;</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  225</span>    <span class="keywordflow">return</span> eye(n, n, dtype=dtype, format=format)</div>
<div class="line"><span class="lineno">  226</span> </div>
<div class="line"><span class="lineno">  227</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af07c2c9378c41369bb9ce06d8abd08f7" name="af07c2c9378c41369bb9ce06d8abd08f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07c2c9378c41369bb9ce06d8abd08f7">&#9670;&#160;</a></span>kron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.kron </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">kronecker product of sparse matrices A and B

Parameters
----------
A : sparse or dense matrix
    first matrix of the product
B : sparse or dense matrix
    second matrix of the product
format : str, optional
    format of the result (e.g. "csr")

Returns
-------
kronecker product in a sparse matrix format


Examples
--------
&gt;&gt;&gt; from scipy import sparse
&gt;&gt;&gt; A = sparse.csr_matrix(np.array([[0, 2], [5, 0]]))
&gt;&gt;&gt; B = sparse.csr_matrix(np.array([[1, 2], [3, 4]]))
&gt;&gt;&gt; sparse.kron(A, B).toarray()
array([[ 0,  0,  2,  4],
       [ 0,  0,  6,  8],
       [ 5, 10,  0,  0],
       [15, 20,  0,  0]])

&gt;&gt;&gt; sparse.kron(A, [[1, 2], [3, 4]]).toarray()
array([[ 0,  0,  2,  4],
       [ 0,  0,  6,  8],
       [ 5, 10,  0,  0],
       [15, 20,  0,  0]])</pre> <div class="fragment"><div class="line"><span class="lineno">  283</span><span class="keyword">def </span>kron(A, B, format=None):</div>
<div class="line"><span class="lineno">  284</span>    <span class="stringliteral">&quot;&quot;&quot;kronecker product of sparse matrices A and B</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    A : sparse or dense matrix</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">        first matrix of the product</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    B : sparse or dense matrix</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        second matrix of the product</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        format of the result (e.g. &quot;csr&quot;)</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    kronecker product in a sparse matrix format</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import sparse</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    &gt;&gt;&gt; A = sparse.csr_matrix(np.array([[0, 2], [5, 0]]))</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    &gt;&gt;&gt; B = sparse.csr_matrix(np.array([[1, 2], [3, 4]]))</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    &gt;&gt;&gt; sparse.kron(A, B).toarray()</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    array([[ 0,  0,  2,  4],</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">           [ 0,  0,  6,  8],</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">           [ 5, 10,  0,  0],</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">           [15, 20,  0,  0]])</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    &gt;&gt;&gt; sparse.kron(A, [[1, 2], [3, 4]]).toarray()</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    array([[ 0,  0,  2,  4],</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">           [ 0,  0,  6,  8],</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">           [ 5, 10,  0,  0],</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">           [15, 20,  0,  0]])</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  318</span>    B = coo_matrix(B)</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>    <span class="keywordflow">if</span> (format <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> format == <span class="stringliteral">&quot;bsr&quot;</span>) <span class="keywordflow">and</span> 2*B.nnz &gt;= B.shape[0] * B.shape[1]:</div>
<div class="line"><span class="lineno">  321</span>        <span class="comment"># B is fairly dense, use BSR</span></div>
<div class="line"><span class="lineno">  322</span>        A = csr_matrix(A,copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  323</span>        output_shape = (A.shape[0]*B.shape[0], A.shape[1]*B.shape[1])</div>
<div class="line"><span class="lineno">  324</span> </div>
<div class="line"><span class="lineno">  325</span>        <span class="keywordflow">if</span> A.nnz == 0 <span class="keywordflow">or</span> B.nnz == 0:</div>
<div class="line"><span class="lineno">  326</span>            <span class="comment"># kronecker product is the zero matrix</span></div>
<div class="line"><span class="lineno">  327</span>            <span class="keywordflow">return</span> coo_matrix(output_shape).asformat(format)</div>
<div class="line"><span class="lineno">  328</span> </div>
<div class="line"><span class="lineno">  329</span>        B = B.toarray()</div>
<div class="line"><span class="lineno">  330</span>        data = A.data.repeat(B.size).reshape(-1,B.shape[0],B.shape[1])</div>
<div class="line"><span class="lineno">  331</span>        data = data * B</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>        <span class="keywordflow">return</span> bsr_matrix((data,A.indices,A.indptr), shape=output_shape)</div>
<div class="line"><span class="lineno">  334</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  335</span>        <span class="comment"># use COO</span></div>
<div class="line"><span class="lineno">  336</span>        A = coo_matrix(A)</div>
<div class="line"><span class="lineno">  337</span>        output_shape = (A.shape[0]*B.shape[0], A.shape[1]*B.shape[1])</div>
<div class="line"><span class="lineno">  338</span> </div>
<div class="line"><span class="lineno">  339</span>        <span class="keywordflow">if</span> A.nnz == 0 <span class="keywordflow">or</span> B.nnz == 0:</div>
<div class="line"><span class="lineno">  340</span>            <span class="comment"># kronecker product is the zero matrix</span></div>
<div class="line"><span class="lineno">  341</span>            <span class="keywordflow">return</span> coo_matrix(output_shape).asformat(format)</div>
<div class="line"><span class="lineno">  342</span> </div>
<div class="line"><span class="lineno">  343</span>        <span class="comment"># expand entries of a into blocks</span></div>
<div class="line"><span class="lineno">  344</span>        row = A.row.repeat(B.nnz)</div>
<div class="line"><span class="lineno">  345</span>        col = A.col.repeat(B.nnz)</div>
<div class="line"><span class="lineno">  346</span>        data = A.data.repeat(B.nnz)</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>        <span class="keywordflow">if</span> max(A.shape[0]*B.shape[0], A.shape[1]*B.shape[1]) &gt; np.iinfo(<span class="stringliteral">&#39;int32&#39;</span>).max:</div>
<div class="line"><span class="lineno">  349</span>            row = row.astype(np.int64)</div>
<div class="line"><span class="lineno">  350</span>            col = col.astype(np.int64)</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>        row *= B.shape[0]</div>
<div class="line"><span class="lineno">  353</span>        col *= B.shape[1]</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>        <span class="comment"># increment block indices</span></div>
<div class="line"><span class="lineno">  356</span>        row,col = row.reshape(-1,B.nnz),col.reshape(-1,B.nnz)</div>
<div class="line"><span class="lineno">  357</span>        row += B.row</div>
<div class="line"><span class="lineno">  358</span>        col += B.col</div>
<div class="line"><span class="lineno">  359</span>        row,col = row.reshape(-1),col.reshape(-1)</div>
<div class="line"><span class="lineno">  360</span> </div>
<div class="line"><span class="lineno">  361</span>        <span class="comment"># compute block entries</span></div>
<div class="line"><span class="lineno">  362</span>        data = data.reshape(-1,B.nnz) * B.data</div>
<div class="line"><span class="lineno">  363</span>        data = data.reshape(-1)</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>        <span class="keywordflow">return</span> coo_matrix((data,(row,col)), shape=output_shape).asformat(format)</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a6e248d7663161229470792183a26f4" name="a9a6e248d7663161229470792183a26f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6e248d7663161229470792183a26f4">&#9670;&#160;</a></span>kronsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.kronsum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">kronecker sum of sparse matrices A and B

Kronecker sum of two sparse matrices is a sum of two Kronecker
products kron(I_n,A) + kron(B,I_m) where A has shape (m,m)
and B has shape (n,n) and I_m and I_n are identity matrices
of shape (m,m) and (n,n), respectively.

Parameters
----------
A
    square matrix
B
    square matrix
format : str
    format of the result (e.g. "csr")

Returns
-------
kronecker sum in a sparse matrix format

Examples
--------</pre> <div class="fragment"><div class="line"><span class="lineno">  368</span><span class="keyword">def </span>kronsum(A, B, format=None):</div>
<div class="line"><span class="lineno">  369</span>    <span class="stringliteral">&quot;&quot;&quot;kronecker sum of sparse matrices A and B</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    Kronecker sum of two sparse matrices is a sum of two Kronecker</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    products kron(I_n,A) + kron(B,I_m) where A has shape (m,m)</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    and B has shape (n,n) and I_m and I_n are identity matrices</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    of shape (m,m) and (n,n), respectively.</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    A</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        square matrix</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    B</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        square matrix</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    format : str</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        format of the result (e.g. &quot;csr&quot;)</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    kronecker sum in a sparse matrix format</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  394</span>    A = coo_matrix(A)</div>
<div class="line"><span class="lineno">  395</span>    B = coo_matrix(B)</div>
<div class="line"><span class="lineno">  396</span> </div>
<div class="line"><span class="lineno">  397</span>    <span class="keywordflow">if</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  398</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;A is not square&#39;</span>)</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>    <span class="keywordflow">if</span> B.shape[0] != B.shape[1]:</div>
<div class="line"><span class="lineno">  401</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;B is not square&#39;</span>)</div>
<div class="line"><span class="lineno">  402</span> </div>
<div class="line"><span class="lineno">  403</span>    dtype = upcast(A.dtype, B.dtype)</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>    L = kron(eye(B.shape[0],dtype=dtype), A, format=format)</div>
<div class="line"><span class="lineno">  406</span>    R = kron(B, eye(A.shape[0],dtype=dtype), format=format)</div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span>    <span class="keywordflow">return</span> (L+R).asformat(format)  <span class="comment"># since L + R is not always same format</span></div>
<div class="line"><span class="lineno">  409</span> </div>
<div class="line"><span class="lineno">  410</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f5233d128bc20de71666ce8bf68d46e" name="a2f5233d128bc20de71666ce8bf68d46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5233d128bc20de71666ce8bf68d46e">&#9670;&#160;</a></span>rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.rand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;coo&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a sparse matrix of the given shape and density with uniformly
distributed values.

Parameters
----------
m, n : int
    shape of the matrix
density : real, optional
    density of the generated matrix: density equal to one means a full
    matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
    sparse matrix format.
dtype : dtype, optional
    type of the returned matrix values.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.

Returns
-------
res : sparse matrix

Notes
-----
Only float types are supported for now.

See Also
--------
scipy.sparse.random : Similar function that allows a user-specified random
    data source.

Examples
--------
&gt;&gt;&gt; from scipy.sparse import rand
&gt;&gt;&gt; matrix = rand(3, 4, density=0.25, format="csr", random_state=42)
&gt;&gt;&gt; matrix
&lt;3x4 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
   with 3 stored elements in Compressed Sparse Row format&gt;
&gt;&gt;&gt; matrix.toarray()
array([[0.05641158, 0.        , 0.        , 0.65088847],
       [0.        , 0.        , 0.        , 0.14286682],
       [0.        , 0.        , 0.        , 0.        ]])</pre> <div class="fragment"><div class="line"><span class="lineno">  893</span><span class="keyword">def </span>rand(m, n, density=0.01, format=&quot;coo&quot;, dtype=None, random_state=None):</div>
<div class="line"><span class="lineno">  894</span>    <span class="stringliteral">&quot;&quot;&quot;Generate a sparse matrix of the given shape and density with uniformly</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    distributed values.</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    m, n : int</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">        shape of the matrix</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    density : real, optional</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">        density of the generated matrix: density equal to one means a full</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">        matrix, density of 0 means a matrix with no non-zero items.</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">        sparse matrix format.</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        type of the returned matrix values.</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">                    `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        singleton is used.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">        that instance is used.</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    res : sparse matrix</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    Only float types are supported for now.</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    scipy.sparse.random : Similar function that allows a user-specified random</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">        data source.</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import rand</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    &gt;&gt;&gt; matrix = rand(3, 4, density=0.25, format=&quot;csr&quot;, random_state=42)</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    &gt;&gt;&gt; matrix</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    &lt;3x4 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">       with 3 stored elements in Compressed Sparse Row format&gt;</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    &gt;&gt;&gt; matrix.toarray()</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    array([[0.05641158, 0.        , 0.        , 0.65088847],</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">           [0.        , 0.        , 0.        , 0.14286682],</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">           [0.        , 0.        , 0.        , 0.        ]])</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  944</span>    <span class="keywordflow">return</span> <a class="code hl_namespace" href="namespacerandom.html">random</a>(m, n, density, format, dtype, random_state)</div>
<div class="ttc" id="anamespacerandom_html"><div class="ttname"><a href="namespacerandom.html">random</a></div><div class="ttdef"><b>Definition</b> random.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acb5138f0a780dddcca900cdbdfa987d1" name="acb5138f0a780dddcca900cdbdfa987d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5138f0a780dddcca900cdbdfa987d1">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.random </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>'coo'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_rvs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a sparse matrix of the given shape and density with randomly
distributed values.

Parameters
----------
m, n : int
    shape of the matrix
density : real, optional
    density of the generated matrix: density equal to one means a full
    matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
    sparse matrix format.
dtype : dtype, optional
    type of the returned matrix values.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.
    This random state will be used
    for sampling the sparsity structure, but not necessarily for sampling
    the values of the structurally nonzero entries of the matrix.
data_rvs : callable, optional
    Samples a requested number of random values.
    This function should take a single argument specifying the length
    of the ndarray that it will return. The structurally nonzero entries
    of the sparse random matrix will be taken from the array sampled
    by this function. By default, uniform [0, 1) random values will be
    sampled using the same random state as is used for sampling
    the sparsity structure.

Returns
-------
res : sparse matrix

Notes
-----
Only float types are supported for now.

Examples
--------
&gt;&gt;&gt; from scipy.sparse import random
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; rvs = stats.poisson(25, loc=10).rvs
&gt;&gt;&gt; S = random(3, 4, density=0.25, random_state=rng, data_rvs=rvs)
&gt;&gt;&gt; S.A
array([[ 36.,   0.,  33.,   0.],   # random
       [  0.,   0.,   0.,   0.],
       [  0.,   0.,  36.,   0.]])

&gt;&gt;&gt; from scipy.sparse import random
&gt;&gt;&gt; from scipy.stats import rv_continuous
&gt;&gt;&gt; class CustomDistribution(rv_continuous):
...     def _rvs(self,  size=None, random_state=None):
...         return random_state.standard_normal(size)
&gt;&gt;&gt; X = CustomDistribution(seed=rng)
&gt;&gt;&gt; Y = X()  # get a frozen version of the distribution
&gt;&gt;&gt; S = random(3, 4, density=0.25, random_state=rng, data_rvs=Y.rvs)
&gt;&gt;&gt; S.A
array([[ 0.        ,  0.        ,  0.        ,  0.        ],   # random
       [ 0.13569738,  1.9467163 , -0.81205367,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ]])</pre> <div class="fragment"><div class="line"><span class="lineno">  776</span>           random_state=<span class="keywordtype">None</span>, data_rvs=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  777</span>    <span class="stringliteral">&quot;&quot;&quot;Generate a sparse matrix of the given shape and density with randomly</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    distributed values.</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    m, n : int</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        shape of the matrix</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    density : real, optional</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        density of the generated matrix: density equal to one means a full</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        matrix, density of 0 means a matrix with no non-zero items.</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        sparse matrix format.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">        type of the returned matrix values.</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">                    `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        singleton is used.</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">        If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        that instance is used.</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">        This random state will be used</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">        for sampling the sparsity structure, but not necessarily for sampling</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">        the values of the structurally nonzero entries of the matrix.</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    data_rvs : callable, optional</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        Samples a requested number of random values.</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        This function should take a single argument specifying the length</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        of the ndarray that it will return. The structurally nonzero entries</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        of the sparse random matrix will be taken from the array sampled</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        by this function. By default, uniform [0, 1) random values will be</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        sampled using the same random state as is used for sampling</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">        the sparsity structure.</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    res : sparse matrix</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    Only float types are supported for now.</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import random</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    &gt;&gt;&gt; rvs = stats.poisson(25, loc=10).rvs</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    &gt;&gt;&gt; S = random(3, 4, density=0.25, random_state=rng, data_rvs=rvs)</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    &gt;&gt;&gt; S.A</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    array([[ 36.,   0.,  33.,   0.],   # random</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">           [  0.,   0.,   0.,   0.],</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">           [  0.,   0.,  36.,   0.]])</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import random</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import rv_continuous</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    &gt;&gt;&gt; class CustomDistribution(rv_continuous):</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    ...     def _rvs(self,  size=None, random_state=None):</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    ...         return random_state.standard_normal(size)</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    &gt;&gt;&gt; X = CustomDistribution(seed=rng)</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    &gt;&gt;&gt; Y = X()  # get a frozen version of the distribution</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    &gt;&gt;&gt; S = random(3, 4, density=0.25, random_state=rng, data_rvs=Y.rvs)</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    &gt;&gt;&gt; S.A</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    array([[ 0.        ,  0.        ,  0.        ,  0.        ],   # random</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">           [ 0.13569738,  1.9467163 , -0.81205367,  0.        ],</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">           [ 0.        ,  0.        ,  0.        ,  0.        ]])</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  847</span>    <span class="keywordflow">if</span> density &lt; 0 <span class="keywordflow">or</span> density &gt; 1:</div>
<div class="line"><span class="lineno">  848</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;density expected to be 0 &lt;= density &lt;= 1&quot;</span>)</div>
<div class="line"><span class="lineno">  849</span>    dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno">  850</span> </div>
<div class="line"><span class="lineno">  851</span>    mn = m * n</div>
<div class="line"><span class="lineno">  852</span> </div>
<div class="line"><span class="lineno">  853</span>    tp = np.intc</div>
<div class="line"><span class="lineno">  854</span>    <span class="keywordflow">if</span> mn &gt; np.iinfo(tp).max:</div>
<div class="line"><span class="lineno">  855</span>        tp = np.int64</div>
<div class="line"><span class="lineno">  856</span> </div>
<div class="line"><span class="lineno">  857</span>    <span class="keywordflow">if</span> mn &gt; np.iinfo(tp).max:</div>
<div class="line"><span class="lineno">  858</span>        msg = <span class="stringliteral">&quot;&quot;&quot;\</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">Trying to generate a random sparse matrix such as the product of dimensions is</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">greater than %d - this is not supported on this machine</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  862</span>        <span class="keywordflow">raise</span> ValueError(msg % np.iinfo(tp).max)</div>
<div class="line"><span class="lineno">  863</span> </div>
<div class="line"><span class="lineno">  864</span>    <span class="comment"># Number of non zero values</span></div>
<div class="line"><span class="lineno">  865</span>    k = int(round(density * m * n))</div>
<div class="line"><span class="lineno">  866</span> </div>
<div class="line"><span class="lineno">  867</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno">  868</span> </div>
<div class="line"><span class="lineno">  869</span>    <span class="keywordflow">if</span> data_rvs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  870</span>        <span class="keywordflow">if</span> np.issubdtype(dtype, np.integer):</div>
<div class="line"><span class="lineno">  871</span>            <span class="keyword">def </span>data_rvs(n):</div>
<div class="line"><span class="lineno">  872</span>                <span class="keywordflow">return</span> rng_integers(random_state,</div>
<div class="line"><span class="lineno">  873</span>                                    np.iinfo(dtype).min,</div>
<div class="line"><span class="lineno">  874</span>                                    np.iinfo(dtype).max,</div>
<div class="line"><span class="lineno">  875</span>                                    n,</div>
<div class="line"><span class="lineno">  876</span>                                    dtype=dtype)</div>
<div class="line"><span class="lineno">  877</span>        <span class="keywordflow">elif</span> np.issubdtype(dtype, np.complexfloating):</div>
<div class="line"><span class="lineno">  878</span>            <span class="keyword">def </span>data_rvs(n):</div>
<div class="line"><span class="lineno">  879</span>                <span class="keywordflow">return</span> (random_state.uniform(size=n) +</div>
<div class="line"><span class="lineno">  880</span>                        random_state.uniform(size=n) * 1j)</div>
<div class="line"><span class="lineno">  881</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  882</span>            data_rvs = partial(random_state.uniform, 0., 1.)</div>
<div class="line"><span class="lineno">  883</span> </div>
<div class="line"><span class="lineno">  884</span>    ind = random_state.choice(mn, size=k, replace=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  885</span> </div>
<div class="line"><span class="lineno">  886</span>    j = np.floor(ind * 1. / m).astype(tp, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  887</span>    i = (ind - j * m).astype(tp, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  888</span>    vals = data_rvs(k).astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  889</span>    <span class="keywordflow">return</span> coo_matrix((vals, (i, j)), shape=(m, n)).asformat(format,</div>
<div class="line"><span class="lineno">  890</span>                                                             copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  891</span> </div>
<div class="line"><span class="lineno">  892</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a791718fb9c41528476ee23151df753b9" name="a791718fb9c41528476ee23151df753b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791718fb9c41528476ee23151df753b9">&#9670;&#160;</a></span>spdiags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.spdiags </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sparse matrix from diagonals.

Parameters
----------
data : array_like
    Matrix diagonals stored row-wise
diags : sequence of int or an int
    Diagonals to set:

    * k = 0  the main diagonal
    * k &gt; 0  the kth upper diagonal
    * k &lt; 0  the kth lower diagonal
m, n : int, tuple, optional
    Shape of the result. If `n` is None and `m` is a given tuple,
    the shape is this tuple. If omitted, the matrix is square and
    its shape is len(data[0]).
format : str, optional
    Format of the result. By default (format=None) an appropriate sparse
    matrix format is returned. This choice is subject to change.

See Also
--------
diags : more convenient form of this function
dia_matrix : the sparse DIAgonal format.

Examples
--------
&gt;&gt;&gt; from scipy.sparse import spdiags
&gt;&gt;&gt; data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])
&gt;&gt;&gt; diags = np.array([0, -1, 2])
&gt;&gt;&gt; spdiags(data, diags, 4, 4).toarray()
array([[1, 0, 3, 0],
       [1, 2, 0, 4],
       [0, 2, 3, 0],
       [0, 0, 3, 4]])</pre> <div class="fragment"><div class="line"><span class="lineno">   26</span><span class="keyword">def </span>spdiags(data, diags, m=None, n=None, format=None):</div>
<div class="line"><span class="lineno">   27</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    Return a sparse matrix from diagonals.</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">        Matrix diagonals stored row-wise</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    diags : sequence of int or an int</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">        Diagonals to set:</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        * k = 0  the main diagonal</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">        * k &gt; 0  the kth upper diagonal</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        * k &lt; 0  the kth lower diagonal</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    m, n : int, tuple, optional</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">        Shape of the result. If `n` is None and `m` is a given tuple,</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        the shape is this tuple. If omitted, the matrix is square and</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        its shape is len(data[0]).</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        Format of the result. By default (format=None) an appropriate sparse</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        matrix format is returned. This choice is subject to change.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    diags : more convenient form of this function</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    dia_matrix : the sparse DIAgonal format.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import spdiags</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    &gt;&gt;&gt; data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    &gt;&gt;&gt; diags = np.array([0, -1, 2])</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    &gt;&gt;&gt; spdiags(data, diags, 4, 4).toarray()</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    array([[1, 0, 3, 0],</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">           [1, 2, 0, 4],</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">           [0, 2, 3, 0],</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">           [0, 0, 3, 4]])</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   65</span>    <span class="keywordflow">if</span> m <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   66</span>        m = n = len(data[0])</div>
<div class="line"><span class="lineno">   67</span>    <span class="keywordflow">elif</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   68</span>        m, n = m</div>
<div class="line"><span class="lineno">   69</span>    <span class="keywordflow">return</span> dia_matrix((data, diags), shape=(m, n)).asformat(format)</div>
<div class="line"><span class="lineno">   70</span> </div>
<div class="line"><span class="lineno">   71</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a98518cff890bf4844a76539c498e9428" name="a98518cff890bf4844a76539c498e9428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98518cff890bf4844a76539c498e9428">&#9670;&#160;</a></span>vstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse._construct.vstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stack sparse matrices vertically (row wise)

Parameters
----------
blocks
    sequence of sparse matrices with compatible shapes
format : str, optional
    sparse format of the result (e.g., "csr")
    by default an appropriate sparse matrix format is returned.
    This choice is subject to change.
dtype : dtype, optional
    The data-type of the output matrix. If not given, the dtype is
    determined from that of `blocks`.

See Also
--------
hstack : stack sparse matrices horizontally (column wise)

Examples
--------
&gt;&gt;&gt; from scipy.sparse import coo_matrix, vstack
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5, 6]])
&gt;&gt;&gt; vstack([A, B]).toarray()
array([[1, 2],
       [3, 4],
       [5, 6]])</pre> <div class="fragment"><div class="line"><span class="lineno">  535</span><span class="keyword">def </span>vstack(blocks, format=None, dtype=None):</div>
<div class="line"><span class="lineno">  536</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    Stack sparse matrices vertically (row wise)</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    blocks</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        sequence of sparse matrices with compatible shapes</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    format : str, optional</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        sparse format of the result (e.g., &quot;csr&quot;)</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        by default an appropriate sparse matrix format is returned.</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        This choice is subject to change.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">        The data-type of the output matrix. If not given, the dtype is</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        determined from that of `blocks`.</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    hstack : stack sparse matrices horizontally (column wise)</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import coo_matrix, vstack</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    &gt;&gt;&gt; B = coo_matrix([[5, 6]])</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    &gt;&gt;&gt; vstack([A, B]).toarray()</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    array([[1, 2],</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">           [3, 4],</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">           [5, 6]])</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  566</span>    <span class="keywordflow">return</span> bmat([[b] <span class="keywordflow">for</span> b <span class="keywordflow">in</span> blocks], format=format, dtype=dtype)</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
