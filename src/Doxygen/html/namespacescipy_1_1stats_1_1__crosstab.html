<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.stats._crosstab Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats.html">stats</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats_1_1__crosstab.html">_crosstab</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.stats._crosstab Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42040e01638168e3ceaaf5b34385791d" id="r_a42040e01638168e3ceaaf5b34385791d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__crosstab.html#a42040e01638168e3ceaaf5b34385791d">crosstab</a> (*args, levels=None, sparse=False)</td></tr>
<tr class="separator:a42040e01638168e3ceaaf5b34385791d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a42040e01638168e3ceaaf5b34385791d" name="a42040e01638168e3ceaaf5b34385791d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42040e01638168e3ceaaf5b34385791d">&#9670;&#160;</a></span>crosstab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._crosstab.crosstab </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>levels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return table of counts for each possible unique combination in ``*args``.

When ``len(args) &gt; 1``, the array computed by this function is
often referred to as a *contingency table* [1]_.

The arguments must be sequences with the same length.  The second return
value, `count`, is an integer array with ``len(args)`` dimensions.  If
`levels` is None, the shape of `count` is ``(n0, n1, ...)``, where ``nk``
is the number of unique elements in ``args[k]``.

Parameters
----------
*args : sequences
    A sequence of sequences whose unique aligned elements are to be
    counted.  The sequences in args must all be the same length.
levels : sequence, optional
    If `levels` is given, it must be a sequence that is the same length as
    `args`.  Each element in `levels` is either a sequence or None.  If it
    is a sequence, it gives the values in the corresponding sequence in
    `args` that are to be counted.  If any value in the sequences in `args`
    does not occur in the corresponding sequence in `levels`, that value
    is ignored and not counted in the returned array `count`.  The default
    value of `levels` for ``args[i]`` is ``np.unique(args[i])``
sparse : bool, optional
    If True, return a sparse matrix.  The matrix will be an instance of
    the `scipy.sparse.coo_matrix` class.  Because SciPy's sparse matrices
    must be 2-d, only two input sequences are allowed when `sparse` is
    True.  Default is False.

Returns
-------
elements : tuple of numpy.ndarrays.
    Tuple of length ``len(args)`` containing the arrays of elements that
    are counted in `count`.  These can be interpreted as the labels of
    the corresponding dimensions of `count`.
    If `levels` was given, then if ``levels[i]`` is not None,
    ``elements[i]`` will hold the values given in ``levels[i]``.
count : numpy.ndarray or scipy.sparse.coo_matrix
    Counts of the unique elements in ``zip(*args)``, stored in an array.
    Also known as a *contingency table* when ``len(args) &gt; 1``.

See Also
--------
numpy.unique

Notes
-----
.. versionadded:: 1.7.0

References
----------
.. [1] "Contingency table", http://en.wikipedia.org/wiki/Contingency_table

Examples
--------
&gt;&gt;&gt; from scipy.stats.contingency import crosstab

Given the lists `a` and `x`, create a contingency table that counts the
frequencies of the corresponding pairs.

&gt;&gt;&gt; a = ['A', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B']
&gt;&gt;&gt; x = ['X', 'X', 'X', 'Y', 'Z', 'Z', 'Y', 'Y', 'Z', 'Z']
&gt;&gt;&gt; (avals, xvals), count = crosstab(a, x)
&gt;&gt;&gt; avals
array(['A', 'B'], dtype='&lt;U1')
&gt;&gt;&gt; xvals
array(['X', 'Y', 'Z'], dtype='&lt;U1')
&gt;&gt;&gt; count
array([[2, 3, 0],
       [1, 0, 4]])

So `('A', 'X')` occurs twice, `('A', 'Y')` occurs three times, etc.

Higher dimensional contingency tables can be created.

&gt;&gt;&gt; p = [0, 0, 0, 0, 1, 1, 1, 0, 0, 1]
&gt;&gt;&gt; (avals, xvals, pvals), count = crosstab(a, x, p)
&gt;&gt;&gt; count
array([[[2, 0],
        [2, 1],
        [0, 0]],
       [[1, 0],
        [0, 0],
        [1, 3]]])
&gt;&gt;&gt; count.shape
(2, 3, 2)

The values to be counted can be set by using the `levels` argument.
It allows the elements of interest in each input sequence to be
given explicitly instead finding the unique elements of the sequence.

For example, suppose one of the arguments is an array containing the
answers to a survey question, with integer values 1 to 4.  Even if the
value 1 does not occur in the data, we want an entry for it in the table.

&gt;&gt;&gt; q1 = [2, 3, 3, 2, 4, 4, 2, 3, 4, 4, 4, 3, 3, 3, 4]  # 1 does not occur.
&gt;&gt;&gt; q2 = [4, 4, 2, 2, 2, 4, 1, 1, 2, 2, 4, 2, 2, 2, 4]  # 3 does not occur.
&gt;&gt;&gt; options = [1, 2, 3, 4]
&gt;&gt;&gt; vals, count = crosstab(q1, q2, levels=(options, options))
&gt;&gt;&gt; count
array([[0, 0, 0, 0],
       [1, 1, 0, 1],
       [1, 4, 0, 1],
       [0, 3, 0, 3]])

If `levels` is given, but an element of `levels` is None, the unique values
of the corresponding argument are used. For example,

&gt;&gt;&gt; vals, count = crosstab(q1, q2, levels=(None, options))
&gt;&gt;&gt; vals
[array([2, 3, 4]), [1, 2, 3, 4]]
&gt;&gt;&gt; count
array([[1, 1, 0, 1],
       [1, 4, 0, 1],
       [0, 3, 0, 3]])

If we want to ignore the pairs where 4 occurs in ``q2``, we can
give just the values [1, 2] to `levels`, and the 4 will be ignored:

&gt;&gt;&gt; vals, count = crosstab(q1, q2, levels=(None, [1, 2]))
&gt;&gt;&gt; vals
[array([2, 3, 4]), [1, 2]]
&gt;&gt;&gt; count
array([[1, 1],
       [1, 4],
       [0, 3]])

Finally, let's repeat the first example, but return a sparse matrix:

&gt;&gt;&gt; (avals, xvals), count = crosstab(a, x, sparse=True)
&gt;&gt;&gt; count
&lt;2x3 sparse matrix of type '&lt;class 'numpy.int64'&gt;'
        with 4 stored elements in COOrdinate format&gt;
&gt;&gt;&gt; count.A
array([[2, 3, 0],
       [1, 0, 4]])</pre> <div class="fragment"><div class="line"><span class="lineno">    5</span><span class="keyword">def </span>crosstab(*args, levels=None, sparse=False):</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">    7</span><span class="stringliteral">    Return table of counts for each possible unique combination in ``*args``.</span></div>
<div class="line"><span class="lineno">    8</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">    9</span><span class="stringliteral">    When ``len(args) &gt; 1``, the array computed by this function is</span></div>
<div class="line"><span class="lineno">   10</span><span class="stringliteral">    often referred to as a *contingency table* [1]_.</span></div>
<div class="line"><span class="lineno">   11</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   12</span><span class="stringliteral">    The arguments must be sequences with the same length.  The second return</span></div>
<div class="line"><span class="lineno">   13</span><span class="stringliteral">    value, `count`, is an integer array with ``len(args)`` dimensions.  If</span></div>
<div class="line"><span class="lineno">   14</span><span class="stringliteral">    `levels` is None, the shape of `count` is ``(n0, n1, ...)``, where ``nk``</span></div>
<div class="line"><span class="lineno">   15</span><span class="stringliteral">    is the number of unique elements in ``args[k]``.</span></div>
<div class="line"><span class="lineno">   16</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   17</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   18</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral">    *args : sequences</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral">        A sequence of sequences whose unique aligned elements are to be</span></div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral">        counted.  The sequences in args must all be the same length.</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">    levels : sequence, optional</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">        If `levels` is given, it must be a sequence that is the same length as</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">        `args`.  Each element in `levels` is either a sequence or None.  If it</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">        is a sequence, it gives the values in the corresponding sequence in</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">        `args` that are to be counted.  If any value in the sequences in `args`</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">        does not occur in the corresponding sequence in `levels`, that value</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">        is ignored and not counted in the returned array `count`.  The default</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">        value of `levels` for ``args[i]`` is ``np.unique(args[i])``</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    sparse : bool, optional</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">        If True, return a sparse matrix.  The matrix will be an instance of</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">        the `scipy.sparse.coo_matrix` class.  Because SciPy&#39;s sparse matrices</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">        must be 2-d, only two input sequences are allowed when `sparse` is</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">        True.  Default is False.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    elements : tuple of numpy.ndarrays.</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        Tuple of length ``len(args)`` containing the arrays of elements that</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        are counted in `count`.  These can be interpreted as the labels of</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">        the corresponding dimensions of `count`.</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        If `levels` was given, then if ``levels[i]`` is not None,</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        ``elements[i]`` will hold the values given in ``levels[i]``.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    count : numpy.ndarray or scipy.sparse.coo_matrix</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        Counts of the unique elements in ``zip(*args)``, stored in an array.</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        Also known as a *contingency table* when ``len(args) &gt; 1``.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    numpy.unique</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    .. [1] &quot;Contingency table&quot;, http://en.wikipedia.org/wiki/Contingency_table</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats.contingency import crosstab</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    Given the lists `a` and `x`, create a contingency table that counts the</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    frequencies of the corresponding pairs.</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    &gt;&gt;&gt; a = [&#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;]</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    &gt;&gt;&gt; x = [&#39;X&#39;, &#39;X&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;Z&#39;, &#39;Y&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;Z&#39;]</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    &gt;&gt;&gt; (avals, xvals), count = crosstab(a, x)</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    &gt;&gt;&gt; avals</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    array([&#39;A&#39;, &#39;B&#39;], dtype=&#39;&lt;U1&#39;)</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    &gt;&gt;&gt; xvals</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    array([&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;], dtype=&#39;&lt;U1&#39;)</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    &gt;&gt;&gt; count</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    array([[2, 3, 0],</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">           [1, 0, 4]])</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    So `(&#39;A&#39;, &#39;X&#39;)` occurs twice, `(&#39;A&#39;, &#39;Y&#39;)` occurs three times, etc.</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    Higher dimensional contingency tables can be created.</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    &gt;&gt;&gt; p = [0, 0, 0, 0, 1, 1, 1, 0, 0, 1]</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    &gt;&gt;&gt; (avals, xvals, pvals), count = crosstab(a, x, p)</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    &gt;&gt;&gt; count</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    array([[[2, 0],</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">            [2, 1],</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">            [0, 0]],</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">           [[1, 0],</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">            [0, 0],</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">            [1, 3]]])</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    &gt;&gt;&gt; count.shape</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    (2, 3, 2)</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    The values to be counted can be set by using the `levels` argument.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    It allows the elements of interest in each input sequence to be</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    given explicitly instead finding the unique elements of the sequence.</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    For example, suppose one of the arguments is an array containing the</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    answers to a survey question, with integer values 1 to 4.  Even if the</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    value 1 does not occur in the data, we want an entry for it in the table.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    &gt;&gt;&gt; q1 = [2, 3, 3, 2, 4, 4, 2, 3, 4, 4, 4, 3, 3, 3, 4]  # 1 does not occur.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    &gt;&gt;&gt; q2 = [4, 4, 2, 2, 2, 4, 1, 1, 2, 2, 4, 2, 2, 2, 4]  # 3 does not occur.</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    &gt;&gt;&gt; options = [1, 2, 3, 4]</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    &gt;&gt;&gt; vals, count = crosstab(q1, q2, levels=(options, options))</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    &gt;&gt;&gt; count</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    array([[0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">           [1, 1, 0, 1],</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">           [1, 4, 0, 1],</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">           [0, 3, 0, 3]])</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    If `levels` is given, but an element of `levels` is None, the unique values</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    of the corresponding argument are used. For example,</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &gt;&gt;&gt; vals, count = crosstab(q1, q2, levels=(None, options))</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    &gt;&gt;&gt; vals</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    [array([2, 3, 4]), [1, 2, 3, 4]]</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &gt;&gt;&gt; count</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    array([[1, 1, 0, 1],</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">           [1, 4, 0, 1],</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">           [0, 3, 0, 3]])</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    If we want to ignore the pairs where 4 occurs in ``q2``, we can</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    give just the values [1, 2] to `levels`, and the 4 will be ignored:</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    &gt;&gt;&gt; vals, count = crosstab(q1, q2, levels=(None, [1, 2]))</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &gt;&gt;&gt; vals</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    [array([2, 3, 4]), [1, 2]]</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    &gt;&gt;&gt; count</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    array([[1, 1],</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">           [1, 4],</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">           [0, 3]])</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    Finally, let&#39;s repeat the first example, but return a sparse matrix:</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    &gt;&gt;&gt; (avals, xvals), count = crosstab(a, x, sparse=True)</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    &gt;&gt;&gt; count</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    &lt;2x3 sparse matrix of type &#39;&lt;class &#39;numpy.int64&#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">            with 4 stored elements in COOrdinate format&gt;</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    &gt;&gt;&gt; count.A</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    array([[2, 3, 0],</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">           [1, 0, 4]])</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  145</span>    nargs = len(args)</div>
<div class="line"><span class="lineno">  146</span>    <span class="keywordflow">if</span> nargs == 0:</div>
<div class="line"><span class="lineno">  147</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;At least one input sequence is required.&quot;</span>)</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>    len0 = len(args[0])</div>
<div class="line"><span class="lineno">  150</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> all(len(a) == len0 <span class="keywordflow">for</span> a <span class="keywordflow">in</span> args[1:]):</div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All input sequences must have the same length.&quot;</span>)</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    <span class="keywordflow">if</span> sparse <span class="keywordflow">and</span> nargs != 2:</div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;When `sparse` is True, only two input sequences &quot;</span></div>
<div class="line"><span class="lineno">  155</span>                         <span class="stringliteral">&quot;are allowed.&quot;</span>)</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>    <span class="keywordflow">if</span> levels <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  158</span>        <span class="comment"># Call np.unique with return_inverse=True on each argument.</span></div>
<div class="line"><span class="lineno">  159</span>        actual_levels, indices = zip(*[np.unique(a, return_inverse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  160</span>                                       <span class="keywordflow">for</span> a <span class="keywordflow">in</span> args])</div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  162</span>        <span class="comment"># `levels` is not None...</span></div>
<div class="line"><span class="lineno">  163</span>        <span class="keywordflow">if</span> len(levels) != nargs:</div>
<div class="line"><span class="lineno">  164</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;len(levels) must equal the number of input &#39;</span></div>
<div class="line"><span class="lineno">  165</span>                             <span class="stringliteral">&#39;sequences&#39;</span>)</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>        args = [np.asarray(arg) <span class="keywordflow">for</span> arg <span class="keywordflow">in</span> args]</div>
<div class="line"><span class="lineno">  168</span>        mask = np.zeros((nargs, len0), dtype=np.bool_)</div>
<div class="line"><span class="lineno">  169</span>        inv = np.zeros((nargs, len0), dtype=np.intp)</div>
<div class="line"><span class="lineno">  170</span>        actual_levels = []</div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordflow">for</span> k, (levels_list, arg) <span class="keywordflow">in</span> enumerate(zip(levels, args)):</div>
<div class="line"><span class="lineno">  172</span>            <span class="keywordflow">if</span> levels_list <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  173</span>                levels_list, inv[k, :] = np.unique(arg, return_inverse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  174</span>                mask[k, :] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  175</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  176</span>                q = arg == np.asarray(levels_list).reshape(-1, 1)</div>
<div class="line"><span class="lineno">  177</span>                mask[k, :] = np.any(q, axis=0)</div>
<div class="line"><span class="lineno">  178</span>                qnz = q.T.nonzero()</div>
<div class="line"><span class="lineno">  179</span>                inv[k, qnz[0]] = qnz[1]</div>
<div class="line"><span class="lineno">  180</span>            actual_levels.append(levels_list)</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>        mask_all = mask.all(axis=0)</div>
<div class="line"><span class="lineno">  183</span>        indices = tuple(inv[:, mask_all])</div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span>    <span class="keywordflow">if</span> sparse:</div>
<div class="line"><span class="lineno">  186</span>        count = coo_matrix((np.ones(len(indices[0]), dtype=int),</div>
<div class="line"><span class="lineno">  187</span>                            (indices[0], indices[1])))</div>
<div class="line"><span class="lineno">  188</span>        count.sum_duplicates()</div>
<div class="line"><span class="lineno">  189</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  190</span>        shape = [len(u) <span class="keywordflow">for</span> u <span class="keywordflow">in</span> actual_levels]</div>
<div class="line"><span class="lineno">  191</span>        count = np.zeros(shape, dtype=int)</div>
<div class="line"><span class="lineno">  192</span>        np.add.at(count, indices, 1)</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">return</span> actual_levels, count</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
