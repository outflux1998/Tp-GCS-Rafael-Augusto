<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.core.multiarray Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html">multiarray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.core.multiarray Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada1001d8f93718a2060ebb0bfb320566" id="r_ada1001d8f93718a2060ebb0bfb320566"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#ada1001d8f93718a2060ebb0bfb320566">empty_like</a> (prototype, dtype=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None, subok=None, <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>=None)</td></tr>
<tr class="separator:ada1001d8f93718a2060ebb0bfb320566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509213ada7ec84c1bfa2a26700cffd56" id="r_a509213ada7ec84c1bfa2a26700cffd56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a509213ada7ec84c1bfa2a26700cffd56">concatenate</a> (arrays, axis=None, out=None, *dtype=None, casting=None)</td></tr>
<tr class="separator:a509213ada7ec84c1bfa2a26700cffd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b170dbdd3f2d833f9eb7c289cb9308b" id="r_a2b170dbdd3f2d833f9eb7c289cb9308b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a2b170dbdd3f2d833f9eb7c289cb9308b">inner</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b)</td></tr>
<tr class="separator:a2b170dbdd3f2d833f9eb7c289cb9308b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafec298d2664515002736e4905e6719b" id="r_aafec298d2664515002736e4905e6719b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#aafec298d2664515002736e4905e6719b">where</a> (condition, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>=None, y=None)</td></tr>
<tr class="separator:aafec298d2664515002736e4905e6719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8ad7def2a66f3fe06f715cb4023972" id="r_ace8ad7def2a66f3fe06f715cb4023972"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#ace8ad7def2a66f3fe06f715cb4023972">lexsort</a> (keys, axis=None)</td></tr>
<tr class="separator:ace8ad7def2a66f3fe06f715cb4023972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab9136a883992c277491a86e13efb61" id="r_aeab9136a883992c277491a86e13efb61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#aeab9136a883992c277491a86e13efb61">can_cast</a> (from_, to, casting=None)</td></tr>
<tr class="separator:aeab9136a883992c277491a86e13efb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33554df6963ba407087d085e3d3e92cc" id="r_a33554df6963ba407087d085e3d3e92cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a33554df6963ba407087d085e3d3e92cc">min_scalar_type</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a33554df6963ba407087d085e3d3e92cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631dd443594fa259a859838d2f68c7ec" id="r_a631dd443594fa259a859838d2f68c7ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a631dd443594fa259a859838d2f68c7ec">result_type</a> (*arrays_and_dtypes)</td></tr>
<tr class="separator:a631dd443594fa259a859838d2f68c7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9a5c7d84575fc3b30df46912ecba76" id="r_a6d9a5c7d84575fc3b30df46912ecba76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a6d9a5c7d84575fc3b30df46912ecba76">dot</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, out=None)</td></tr>
<tr class="separator:a6d9a5c7d84575fc3b30df46912ecba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb4f2892682f3716f61b5eaf5a35b4a" id="r_addb4f2892682f3716f61b5eaf5a35b4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#addb4f2892682f3716f61b5eaf5a35b4a">vdot</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b)</td></tr>
<tr class="separator:addb4f2892682f3716f61b5eaf5a35b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e60db196719f0acc24d2dfa28953805" id="r_a9e60db196719f0acc24d2dfa28953805"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a9e60db196719f0acc24d2dfa28953805">bincount</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, weights=None, minlength=None)</td></tr>
<tr class="separator:a9e60db196719f0acc24d2dfa28953805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8504d23fefcc338cbd7617d1b6a78ad8" id="r_a8504d23fefcc338cbd7617d1b6a78ad8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a8504d23fefcc338cbd7617d1b6a78ad8">ravel_multi_index</a> (multi_index, dims, mode=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a8504d23fefcc338cbd7617d1b6a78ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fb5a81e759751a4846cfdb2a7c0661" id="r_a05fb5a81e759751a4846cfdb2a7c0661"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a05fb5a81e759751a4846cfdb2a7c0661">unravel_index</a> (<a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a9b57e299af9537cd1030c654e4be8abb">indices</a>, <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a05fb5a81e759751a4846cfdb2a7c0661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a976075176cee5304cdbb9636e761a1" id="r_a5a976075176cee5304cdbb9636e761a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a5a976075176cee5304cdbb9636e761a1">copyto</a> (dst, src, casting=None, <a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#aafec298d2664515002736e4905e6719b">where</a>=None)</td></tr>
<tr class="separator:a5a976075176cee5304cdbb9636e761a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8a9c5fd8b434b5700a26280140116" id="r_ae9b8a9c5fd8b434b5700a26280140116"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#ae9b8a9c5fd8b434b5700a26280140116">putmask</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, mask, values)</td></tr>
<tr class="separator:ae9b8a9c5fd8b434b5700a26280140116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a2455f865e0ab4d6e086efac2163fa" id="r_a91a2455f865e0ab4d6e086efac2163fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a91a2455f865e0ab4d6e086efac2163fa">packbits</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, bitorder='big')</td></tr>
<tr class="separator:a91a2455f865e0ab4d6e086efac2163fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab260a98a2750798027f651b626b8403f" id="r_ab260a98a2750798027f651b626b8403f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#ab260a98a2750798027f651b626b8403f">unpackbits</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, count=None, bitorder='big')</td></tr>
<tr class="separator:ab260a98a2750798027f651b626b8403f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2f8c4e2c932442df0c92eedce29aac" id="r_a0c2f8c4e2c932442df0c92eedce29aac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a0c2f8c4e2c932442df0c92eedce29aac">shares_memory</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, max_work=None)</td></tr>
<tr class="separator:a0c2f8c4e2c932442df0c92eedce29aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ad592278d3cb45614f93e90a1acffc" id="r_a53ad592278d3cb45614f93e90a1acffc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a53ad592278d3cb45614f93e90a1acffc">may_share_memory</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, max_work=None)</td></tr>
<tr class="separator:a53ad592278d3cb45614f93e90a1acffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d744404a5ecb28d9cbb89b9762cc53" id="r_a15d744404a5ecb28d9cbb89b9762cc53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a15d744404a5ecb28d9cbb89b9762cc53">is_busday</a> (dates, weekmask=None, holidays=None, busdaycal=None, out=None)</td></tr>
<tr class="separator:a15d744404a5ecb28d9cbb89b9762cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ee5aadc9c5f54a2125e7fb03f0ef9d" id="r_a99ee5aadc9c5f54a2125e7fb03f0ef9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a99ee5aadc9c5f54a2125e7fb03f0ef9d">busday_offset</a> (dates, offsets, <a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ac1b2b647e32899d2e32fff33a0ed90ef">roll</a>=None, weekmask=None, holidays=None, busdaycal=None, out=None)</td></tr>
<tr class="separator:a99ee5aadc9c5f54a2125e7fb03f0ef9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46f6e97509f4906c4cb96d68d853567" id="r_af46f6e97509f4906c4cb96d68d853567"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#af46f6e97509f4906c4cb96d68d853567">busday_count</a> (begindates, enddates, weekmask=None, holidays=None, busdaycal=None, out=None)</td></tr>
<tr class="separator:af46f6e97509f4906c4cb96d68d853567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcfe796e24491e022f5c5ea93e9007c" id="r_affcfe796e24491e022f5c5ea93e9007c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#affcfe796e24491e022f5c5ea93e9007c">datetime_as_string</a> (arr, unit=None, timezone=None, casting=None)</td></tr>
<tr class="separator:affcfe796e24491e022f5c5ea93e9007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8f0985446cd1812ab7345b24aaf37a2b" id="r_a8f0985446cd1812ab7345b24aaf37a2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1multiarray.html#a8f0985446cd1812ab7345b24aaf37a2b">array_function_from_c_func_and_dispatcher</a></td></tr>
<tr class="separator:a8f0985446cd1812ab7345b24aaf37a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Create the numpy.core.multiarray namespace for backward compatibility. In v1.16
the multiarray and umath c-extension modules were merged into a single
_multiarray_umath extension module. So we replicate the old namespace
by importing from the extension module.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a9e60db196719f0acc24d2dfa28953805" name="a9e60db196719f0acc24d2dfa28953805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e60db196719f0acc24d2dfa28953805">&#9670;&#160;</a></span>bincount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.bincount </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minlength</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">bincount(x, /, weights=None, minlength=0)

Count number of occurrences of each value in array of non-negative ints.

The number of bins (of size 1) is one larger than the largest value in
`x`. If `minlength` is specified, there will be at least this number
of bins in the output array (though it will be longer if necessary,
depending on the contents of `x`).
Each bin gives the number of occurrences of its index value in `x`.
If `weights` is specified the input array is weighted by it, i.e. if a
value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead
of ``out[n] += 1``.

Parameters
----------
x : array_like, 1 dimension, nonnegative ints
    Input array.
weights : array_like, optional
    Weights, array of the same shape as `x`.
minlength : int, optional
    A minimum number of bins for the output array.

    .. versionadded:: 1.6.0

Returns
-------
out : ndarray of ints
    The result of binning the input array.
    The length of `out` is equal to ``np.amax(x)+1``.

Raises
------
ValueError
    If the input is not 1-dimensional, or contains elements with negative
    values, or if `minlength` is negative.
TypeError
    If the type of the input is float or complex.

See Also
--------
histogram, digitize, unique

Examples
--------
&gt;&gt;&gt; np.bincount(np.arange(5))
array([1, 1, 1, 1, 1])
&gt;&gt;&gt; np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
array([1, 3, 1, 1, 0, 0, 0, 1])

&gt;&gt;&gt; x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
&gt;&gt;&gt; np.bincount(x).size == np.amax(x)+1
True

The input array needs to be of integer dtype, otherwise a
TypeError is raised:

&gt;&gt;&gt; np.bincount(np.arange(5, dtype=float))
Traceback (most recent call last):
  ...
TypeError: Cannot cast array data from dtype('float64') to dtype('int64')
according to the rule 'safe'

A possible use of ``bincount`` is to perform sums over
variable-size chunks of an array, using the ``weights`` keyword.

&gt;&gt;&gt; w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
&gt;&gt;&gt; x = np.array([0, 1, 1, 2, 2, 2])
&gt;&gt;&gt; np.bincount(x,  weights=w)
array([ 0.3,  0.7,  1.1])</pre> <div class="fragment"><div class="line"><span class="lineno">  892</span><span class="keyword">def </span>bincount(x, weights=None, minlength=None):</div>
<div class="line"><span class="lineno">  893</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    bincount(x, /, weights=None, minlength=0)</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    Count number of occurrences of each value in array of non-negative ints.</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    The number of bins (of size 1) is one larger than the largest value in</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    `x`. If `minlength` is specified, there will be at least this number</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    of bins in the output array (though it will be longer if necessary,</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    depending on the contents of `x`).</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    Each bin gives the number of occurrences of its index value in `x`.</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    If `weights` is specified the input array is weighted by it, i.e. if a</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    of ``out[n] += 1``.</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    x : array_like, 1 dimension, nonnegative ints</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        Weights, array of the same shape as `x`.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    minlength : int, optional</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        A minimum number of bins for the output array.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    out : ndarray of ints</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">        The result of binning the input array.</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">        The length of `out` is equal to ``np.amax(x)+1``.</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">        If the input is not 1-dimensional, or contains elements with negative</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">        values, or if `minlength` is negative.</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">        If the type of the input is float or complex.</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    histogram, digitize, unique</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    &gt;&gt;&gt; np.bincount(np.arange(5))</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    array([1, 1, 1, 1, 1])</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    &gt;&gt;&gt; np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    array([1, 3, 1, 1, 0, 0, 0, 1])</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([0, 1, 1, 3, 2, 1, 7, 23])</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">    &gt;&gt;&gt; np.bincount(x).size == np.amax(x)+1</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    The input array needs to be of integer dtype, otherwise a</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    TypeError is raised:</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    &gt;&gt;&gt; np.bincount(np.arange(5, dtype=float))</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">      ...</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    TypeError: Cannot cast array data from dtype(&#39;float64&#39;) to dtype(&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">    according to the rule &#39;safe&#39;</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    A possible use of ``bincount`` is to perform sums over</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    variable-size chunks of an array, using the ``weights`` keyword.</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    &gt;&gt;&gt; w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([0, 1, 1, 2, 2, 2])</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    &gt;&gt;&gt; np.bincount(x,  weights=w)</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    array([ 0.3,  0.7,  1.1])</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  965</span>    <span class="keywordflow">return</span> (x, weights)</div>
<div class="line"><span class="lineno">  966</span> </div>
<div class="line"><span class="lineno">  967</span> </div>
<div class="line"><span class="lineno">  968</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.ravel_multi_index)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af46f6e97509f4906c4cb96d68d853567" name="af46f6e97509f4906c4cb96d68d853567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46f6e97509f4906c4cb96d68d853567">&#9670;&#160;</a></span>busday_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.busday_count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>begindates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enddates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weekmask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>holidays</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>busdaycal</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)

Counts the number of valid days between `begindates` and
`enddates`, not including the day of `enddates`.

If ``enddates`` specifies a date value that is earlier than the
corresponding ``begindates`` date value, the count will be negative.

.. versionadded:: 1.7.0

Parameters
----------
begindates : array_like of datetime64[D]
    The array of the first dates for counting.
enddates : array_like of datetime64[D]
    The array of the end dates for counting, which are excluded
    from the count themselves.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of int, optional
    If provided, this array is filled with the result.

Returns
-------
out : array of int
    An array with a shape from broadcasting ``begindates`` and ``enddates``
    together, containing the number of valid days between
    the begin and end dates.

See Also
--------
busdaycalendar : An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.

Examples
--------
&gt;&gt;&gt; # Number of weekdays in January 2011
... np.busday_count('2011-01', '2011-02')
21
&gt;&gt;&gt; # Number of weekdays in 2011
&gt;&gt;&gt; np.busday_count('2011', '2012')
260
&gt;&gt;&gt; # Number of Saturdays in 2011
... np.busday_count('2011', '2012', weekmask='Sat')
53
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1583</span>                 busdaycal=<span class="keywordtype">None</span>, out=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1584</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    busday_count(begindates, enddates, weekmask=&#39;1111100&#39;, holidays=[], busdaycal=None, out=None)</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    Counts the number of valid days between `begindates` and</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    `enddates`, not including the day of `enddates`.</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">    If ``enddates`` specifies a date value that is earlier than the</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    corresponding ``begindates`` date value, the count will be negative.</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    begindates : array_like of datetime64[D]</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">        The array of the first dates for counting.</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    enddates : array_like of datetime64[D]</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        The array of the end dates for counting, which are excluded</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">        from the count themselves.</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    weekmask : str or array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">        A seven-element array indicating which of Monday through Sunday are</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">        valid days. May be specified as a length-seven list or array, like</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        [1,1,1,1,1,0,0]; a length-seven string, like &#39;1111100&#39;; or a string</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">        like &quot;Mon Tue Wed Thu Fri&quot;, made up of 3-character abbreviations for</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">        weekdays, optionally separated by white space. Valid abbreviations</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">        are: Mon Tue Wed Thu Fri Sat Sun</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">    holidays : array_like of datetime64[D], optional</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">        An array of dates to consider as invalid dates.  They may be</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">        specified in any order, and NaT (not-a-time) dates are ignored.</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">        This list is saved in a normalized form that is suited for</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">        fast calculations of valid days.</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">    busdaycal : busdaycalendar, optional</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral">        A `busdaycalendar` object which specifies the valid days. If this</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        parameter is provided, neither weekmask nor holidays may be</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">        provided.</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">    out : array of int, optional</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">        If provided, this array is filled with the result.</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    out : array of int</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">        An array with a shape from broadcasting ``begindates`` and ``enddates``</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">        together, containing the number of valid days between</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">        the begin and end dates.</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">    busdaycalendar : An object that specifies a custom set of valid days.</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    is_busday : Returns a boolean array indicating valid days.</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">    busday_offset : Applies an offset counted in valid days.</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    &gt;&gt;&gt; # Number of weekdays in January 2011</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    ... np.busday_count(&#39;2011-01&#39;, &#39;2011-02&#39;)</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">    21</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">    &gt;&gt;&gt; # Number of weekdays in 2011</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">    &gt;&gt;&gt; np.busday_count(&#39;2011&#39;, &#39;2012&#39;)</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">    260</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">    &gt;&gt;&gt; # Number of Saturdays in 2011</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">    ... np.busday_count(&#39;2011&#39;, &#39;2012&#39;, weekmask=&#39;Sat&#39;)</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">    53</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1646</span>    <span class="keywordflow">return</span> (begindates, enddates, weekmask, holidays, out)</div>
<div class="line"><span class="lineno"> 1647</span> </div>
<div class="line"><span class="lineno"> 1648</span> </div>
<div class="line"><span class="lineno"> 1649</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher</span>(</div>
<div class="line"><span class="lineno"> 1650</span>    _multiarray_umath.datetime_as_string)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a99ee5aadc9c5f54a2125e7fb03f0ef9d" name="a99ee5aadc9c5f54a2125e7fb03f0ef9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ee5aadc9c5f54a2125e7fb03f0ef9d">&#9670;&#160;</a></span>busday_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.busday_offset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>roll</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weekmask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>holidays</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>busdaycal</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)

First adjusts the date to fall on a valid day according to
the ``roll`` rule, then applies offsets to the given dates
counted in valid days.

.. versionadded:: 1.7.0

Parameters
----------
dates : array_like of datetime64[D]
    The array of dates to process.
offsets : array_like of int
    The array of offsets, which is broadcast with ``dates``.
roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional
    How to treat dates that do not fall on a valid day. The default
    is 'raise'.

      * 'raise' means to raise an exception for an invalid day.
      * 'nat' means to return a NaT (not-a-time) for an invalid day.
      * 'forward' and 'following' mean to take the first valid day
        later in time.
      * 'backward' and 'preceding' mean to take the first valid day
        earlier in time.
      * 'modifiedfollowing' means to take the first valid day
        later in time unless it is across a Month boundary, in which
        case to take the first valid day earlier in time.
      * 'modifiedpreceding' means to take the first valid day
        earlier in time unless it is across a Month boundary, in which
        case to take the first valid day later in time.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of datetime64[D], optional
    If provided, this array is filled with the result.

Returns
-------
out : array of datetime64[D]
    An array with a shape from broadcasting ``dates`` and ``offsets``
    together, containing the dates with offsets applied.

See Also
--------
busdaycalendar : An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_count : Counts how many valid days are in a half-open date range.

Examples
--------
&gt;&gt;&gt; # First business day in October 2011 (not accounting for holidays)
... np.busday_offset('2011-10', 0, roll='forward')
numpy.datetime64('2011-10-03')
&gt;&gt;&gt; # Last business day in February 2012 (not accounting for holidays)
... np.busday_offset('2012-03', -1, roll='forward')
numpy.datetime64('2012-02-29')
&gt;&gt;&gt; # Third Wednesday in January 2011
... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
numpy.datetime64('2011-01-19')
&gt;&gt;&gt; # 2012 Mother's Day in Canada and the U.S.
... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
numpy.datetime64('2012-05-13')

&gt;&gt;&gt; # First business day on or after a date
... np.busday_offset('2011-03-20', 0, roll='forward')
numpy.datetime64('2011-03-21')
&gt;&gt;&gt; np.busday_offset('2011-03-22', 0, roll='forward')
numpy.datetime64('2011-03-22')
&gt;&gt;&gt; # First business day after a date
... np.busday_offset('2011-03-20', 1, roll='backward')
numpy.datetime64('2011-03-21')
&gt;&gt;&gt; np.busday_offset('2011-03-22', 1, roll='backward')
numpy.datetime64('2011-03-23')
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1489</span>                  busdaycal=<span class="keywordtype">None</span>, out=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1490</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">    busday_offset(dates, offsets, roll=&#39;raise&#39;, weekmask=&#39;1111100&#39;, holidays=None, busdaycal=None, out=None)</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">    First adjusts the date to fall on a valid day according to</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">    the ``roll`` rule, then applies offsets to the given dates</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">    counted in valid days.</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    dates : array_like of datetime64[D]</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">        The array of dates to process.</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    offsets : array_like of int</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">        The array of offsets, which is broadcast with ``dates``.</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    roll : {&#39;raise&#39;, &#39;nat&#39;, &#39;forward&#39;, &#39;following&#39;, &#39;backward&#39;, &#39;preceding&#39;, &#39;modifiedfollowing&#39;, &#39;modifiedpreceding&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">        How to treat dates that do not fall on a valid day. The default</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">        is &#39;raise&#39;.</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">          * &#39;raise&#39; means to raise an exception for an invalid day.</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">          * &#39;nat&#39; means to return a NaT (not-a-time) for an invalid day.</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">          * &#39;forward&#39; and &#39;following&#39; mean to take the first valid day</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">            later in time.</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">          * &#39;backward&#39; and &#39;preceding&#39; mean to take the first valid day</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">            earlier in time.</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">          * &#39;modifiedfollowing&#39; means to take the first valid day</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">            later in time unless it is across a Month boundary, in which</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">            case to take the first valid day earlier in time.</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">          * &#39;modifiedpreceding&#39; means to take the first valid day</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">            earlier in time unless it is across a Month boundary, in which</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">            case to take the first valid day later in time.</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    weekmask : str or array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">        A seven-element array indicating which of Monday through Sunday are</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        valid days. May be specified as a length-seven list or array, like</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">        [1,1,1,1,1,0,0]; a length-seven string, like &#39;1111100&#39;; or a string</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">        like &quot;Mon Tue Wed Thu Fri&quot;, made up of 3-character abbreviations for</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">        weekdays, optionally separated by white space. Valid abbreviations</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">        are: Mon Tue Wed Thu Fri Sat Sun</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    holidays : array_like of datetime64[D], optional</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">        An array of dates to consider as invalid dates.  They may be</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">        specified in any order, and NaT (not-a-time) dates are ignored.</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">        This list is saved in a normalized form that is suited for</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">        fast calculations of valid days.</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    busdaycal : busdaycalendar, optional</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">        A `busdaycalendar` object which specifies the valid days. If this</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">        parameter is provided, neither weekmask nor holidays may be</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">        provided.</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    out : array of datetime64[D], optional</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">        If provided, this array is filled with the result.</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    out : array of datetime64[D]</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">        An array with a shape from broadcasting ``dates`` and ``offsets``</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">        together, containing the dates with offsets applied.</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    busdaycalendar : An object that specifies a custom set of valid days.</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    is_busday : Returns a boolean array indicating valid days.</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    busday_count : Counts how many valid days are in a half-open date range.</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    &gt;&gt;&gt; # First business day in October 2011 (not accounting for holidays)</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    ... np.busday_offset(&#39;2011-10&#39;, 0, roll=&#39;forward&#39;)</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    numpy.datetime64(&#39;2011-10-03&#39;)</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    &gt;&gt;&gt; # Last business day in February 2012 (not accounting for holidays)</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    ... np.busday_offset(&#39;2012-03&#39;, -1, roll=&#39;forward&#39;)</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    numpy.datetime64(&#39;2012-02-29&#39;)</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">    &gt;&gt;&gt; # Third Wednesday in January 2011</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    ... np.busday_offset(&#39;2011-01&#39;, 2, roll=&#39;forward&#39;, weekmask=&#39;Wed&#39;)</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">    numpy.datetime64(&#39;2011-01-19&#39;)</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    &gt;&gt;&gt; # 2012 Mother&#39;s Day in Canada and the U.S.</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">    ... np.busday_offset(&#39;2012-05&#39;, 1, roll=&#39;forward&#39;, weekmask=&#39;Sun&#39;)</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">    numpy.datetime64(&#39;2012-05-13&#39;)</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">    &gt;&gt;&gt; # First business day on or after a date</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral">    ... np.busday_offset(&#39;2011-03-20&#39;, 0, roll=&#39;forward&#39;)</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">    numpy.datetime64(&#39;2011-03-21&#39;)</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">    &gt;&gt;&gt; np.busday_offset(&#39;2011-03-22&#39;, 0, roll=&#39;forward&#39;)</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">    numpy.datetime64(&#39;2011-03-22&#39;)</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    &gt;&gt;&gt; # First business day after a date</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral">    ... np.busday_offset(&#39;2011-03-20&#39;, 1, roll=&#39;backward&#39;)</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">    numpy.datetime64(&#39;2011-03-21&#39;)</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">    &gt;&gt;&gt; np.busday_offset(&#39;2011-03-22&#39;, 1, roll=&#39;backward&#39;)</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">    numpy.datetime64(&#39;2011-03-23&#39;)</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1578</span>    <span class="keywordflow">return</span> (dates, offsets, weekmask, holidays, out)</div>
<div class="line"><span class="lineno"> 1579</span> </div>
<div class="line"><span class="lineno"> 1580</span> </div>
<div class="line"><span class="lineno"> 1581</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_count)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeab9136a883992c277491a86e13efb61" name="aeab9136a883992c277491a86e13efb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab9136a883992c277491a86e13efb61">&#9670;&#160;</a></span>can_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.can_cast </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>from_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">can_cast(from_, to, casting='safe')

Returns True if cast between data types can occur according to the
casting rule.  If from is a scalar or array scalar, also returns
True if the scalar value can be cast without overflow or truncation
to an integer.

Parameters
----------
from_ : dtype, dtype specifier, scalar, or array
    Data type, scalar, or array to cast from.
to : dtype or dtype specifier
    Data type to cast to.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.

Returns
-------
out : bool
    True if cast can occur according to the casting rule.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for "unsafe" casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the maximum
   integer/float value converted.

See also
--------
dtype, result_type

Examples
--------
Basic examples

&gt;&gt;&gt; np.can_cast(np.int32, np.int64)
True
&gt;&gt;&gt; np.can_cast(np.float64, complex)
True
&gt;&gt;&gt; np.can_cast(complex, float)
False

&gt;&gt;&gt; np.can_cast('i8', 'f8')
True
&gt;&gt;&gt; np.can_cast('i8', 'f4')
False
&gt;&gt;&gt; np.can_cast('i4', 'S4')
False

Casting scalars

&gt;&gt;&gt; np.can_cast(100, 'i1')
True
&gt;&gt;&gt; np.can_cast(150, 'i1')
False
&gt;&gt;&gt; np.can_cast(150, 'u1')
True

&gt;&gt;&gt; np.can_cast(3.5e100, np.float32)
False
&gt;&gt;&gt; np.can_cast(1000.0, np.float32)
True

Array scalar checks the value, array does not

&gt;&gt;&gt; np.can_cast(np.array(1000.0), np.float32)
True
&gt;&gt;&gt; np.can_cast(np.array([1000.0]), np.float32)
False

Using the casting rules

&gt;&gt;&gt; np.can_cast('i8', 'i8', 'no')
True
&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i8', 'no')
False

&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i8', 'equiv')
True
&gt;&gt;&gt; np.can_cast('&lt;i4', '&gt;i8', 'equiv')
False

&gt;&gt;&gt; np.can_cast('&lt;i4', '&gt;i8', 'safe')
True
&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i4', 'safe')
False

&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i4', 'same_kind')
True
&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;u4', 'same_kind')
False

&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;u4', 'unsafe')
True</pre> <div class="fragment"><div class="line"><span class="lineno">  503</span><span class="keyword">def </span>can_cast(from_, to, casting=None):</div>
<div class="line"><span class="lineno">  504</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    can_cast(from_, to, casting=&#39;safe&#39;)</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    Returns True if cast between data types can occur according to the</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    casting rule.  If from is a scalar or array scalar, also returns</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    True if the scalar value can be cast without overflow or truncation</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    to an integer.</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    from_ : dtype, dtype specifier, scalar, or array</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        Data type, scalar, or array to cast from.</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    to : dtype or dtype specifier</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        Data type to cast to.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        Controls what kind of data casting may occur.</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">          * &#39;no&#39; means the data types should not be cast at all.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">          * &#39;equiv&#39; means only byte-order changes are allowed.</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">          * &#39;safe&#39; means only casts which can preserve values are allowed.</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">          * &#39;same_kind&#39; means only safe casts or casts within a kind,</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">            like float64 to float32, are allowed.</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">          * &#39;unsafe&#39; means any data conversions may be done.</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    out : bool</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        True if cast can occur according to the casting rule.</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    .. versionchanged:: 1.17.0</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">       Casting between a simple data type and a structured one is possible only</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">       for &quot;unsafe&quot; casting.  Casting to multiple fields is allowed, but</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">       casting from multiple fields is not.</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    .. versionchanged:: 1.9.0</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">       Casting from numeric to string types in &#39;safe&#39; casting mode requires</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">       that the string dtype length is long enough to store the maximum</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">       integer/float value converted.</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    dtype, result_type</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    Basic examples</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(np.int32, np.int64)</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(np.float64, complex)</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(complex, float)</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;i8&#39;, &#39;f8&#39;)</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;i8&#39;, &#39;f4&#39;)</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;i4&#39;, &#39;S4&#39;)</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    Casting scalars</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(100, &#39;i1&#39;)</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(150, &#39;i1&#39;)</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(150, &#39;u1&#39;)</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(3.5e100, np.float32)</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(1000.0, np.float32)</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    Array scalar checks the value, array does not</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(np.array(1000.0), np.float32)</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(np.array([1000.0]), np.float32)</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    Using the casting rules</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;i8&#39;, &#39;i8&#39;, &#39;no&#39;)</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i8&#39;, &#39;no&#39;)</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i8&#39;, &#39;equiv&#39;)</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i4&#39;, &#39;&gt;i8&#39;, &#39;equiv&#39;)</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i4&#39;, &#39;&gt;i8&#39;, &#39;safe&#39;)</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i4&#39;, &#39;safe&#39;)</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i4&#39;, &#39;same_kind&#39;)</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;u4&#39;, &#39;same_kind&#39;)</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;u4&#39;, &#39;unsafe&#39;)</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  614</span>    <span class="keywordflow">return</span> (from_,)</div>
<div class="line"><span class="lineno">  615</span> </div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.min_scalar_type)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a509213ada7ec84c1bfa2a26700cffd56" name="a509213ada7ec84c1bfa2a26700cffd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509213ada7ec84c1bfa2a26700cffd56">&#9670;&#160;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.concatenate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")

Join a sequence of arrays along an existing axis.

Parameters
----------
a1, a2, ... : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined.  If axis is None,
    arrays are flattened before use.  Default is 0.
out : ndarray, optional
    If provided, the destination to place the result. The shape must be
    correct, matching that of what concatenate would have returned if no
    out argument were specified.
dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

    .. versionadded:: 1.20.0

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

    .. versionadded:: 1.20.0

Returns
-------
res : ndarray
    The concatenated array.

See Also
--------
ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
block : Assemble arrays from blocks.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
column_stack : Stack 1-D arrays as columns into a 2-D array.

Notes
-----
When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are *not* preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; b = np.array([[5, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])

This function will not preserve masking of MaskedArray inputs.

&gt;&gt;&gt; a = np.ma.arange(3)
&gt;&gt;&gt; a[1] = np.ma.masked
&gt;&gt;&gt; b = np.arange(2, 5)
&gt;&gt;&gt; a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
&gt;&gt;&gt; b
array([2, 3, 4])
&gt;&gt;&gt; np.concatenate([a, b])
masked_array(data=[0, 1, 2, 2, 3, 4],
             mask=False,
       fill_value=999999)
&gt;&gt;&gt; np.ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)</pre> <div class="fragment"><div class="line"><span class="lineno">  153</span><span class="keyword">def </span>concatenate(arrays, axis=None, out=None, *, dtype=None, casting=None):</div>
<div class="line"><span class="lineno">  154</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting=&quot;same_kind&quot;)</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    Join a sequence of arrays along an existing axis.</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    a1, a2, ... : sequence of array_like</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        The arrays must have the same shape, except in the dimension</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">        corresponding to `axis` (the first, by default).</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        The axis along which the arrays will be joined.  If axis is None,</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">        arrays are flattened before use.  Default is 0.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        If provided, the destination to place the result. The shape must be</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        correct, matching that of what concatenate would have returned if no</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        out argument were specified.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    dtype : str or dtype</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        If provided, the destination array will have this dtype. Cannot be</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        provided together with `out`.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">        Controls what kind of data casting may occur. Defaults to &#39;same_kind&#39;.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    res : ndarray</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        The concatenated array.</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    ma.concatenate : Concatenate function that preserves input masks.</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    array_split : Split an array into multiple sub-arrays of equal or</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">                  near-equal size.</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    split : Split array into a list of multiple sub-arrays of equal size.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    hsplit : Split array into multiple sub-arrays horizontally (column wise).</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    vsplit : Split array into multiple sub-arrays vertically (row wise).</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    stack : Stack a sequence of arrays along a new axis.</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    block : Assemble arrays from blocks.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    hstack : Stack arrays in sequence horizontally (column wise).</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    vstack : Stack arrays in sequence vertically (row wise).</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    dstack : Stack arrays in sequence depth wise (along third dimension).</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    column_stack : Stack 1-D arrays as columns into a 2-D array.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    When one or more of the arrays to be concatenated is a MaskedArray,</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    this function will return a MaskedArray object instead of an ndarray,</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    but the input masks are *not* preserved. In cases where a MaskedArray</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    is expected as input, use the ma.concatenate function from the masked</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    array module instead.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[5, 6]])</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; np.concatenate((a, b), axis=0)</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    array([[1, 2],</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">           [3, 4],</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">           [5, 6]])</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    &gt;&gt;&gt; np.concatenate((a, b.T), axis=1)</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    array([[1, 2, 5],</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">           [3, 4, 6]])</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &gt;&gt;&gt; np.concatenate((a, b), axis=None)</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    array([1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    This function will not preserve masking of MaskedArray inputs.</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    &gt;&gt;&gt; a = np.ma.arange(3)</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    &gt;&gt;&gt; a[1] = np.ma.masked</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(2, 5)</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    masked_array(data=[0, --, 2],</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">                 mask=[False,  True, False],</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">           fill_value=999999)</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    array([2, 3, 4])</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    &gt;&gt;&gt; np.concatenate([a, b])</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    masked_array(data=[0, 1, 2, 2, 3, 4],</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">                 mask=False,</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">           fill_value=999999)</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    &gt;&gt;&gt; np.ma.concatenate([a, b])</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    masked_array(data=[0, --, 2, 2, 3, 4],</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">                 mask=[False,  True, False, False, False, False],</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">           fill_value=999999)</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  246</span>    <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  247</span>        <span class="comment"># optimize for the typical case where only arrays is provided</span></div>
<div class="line"><span class="lineno">  248</span>        arrays = list(arrays)</div>
<div class="line"><span class="lineno">  249</span>        arrays.append(out)</div>
<div class="line"><span class="lineno">  250</span>    <span class="keywordflow">return</span> arrays</div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.inner)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a976075176cee5304cdbb9636e761a1" name="a5a976075176cee5304cdbb9636e761a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a976075176cee5304cdbb9636e761a1">&#9670;&#160;</a></span>copyto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.copyto </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">copyto(dst, src, casting='same_kind', where=True)

Copies values from one array to another, broadcasting as necessary.

Raises a TypeError if the `casting` rule is violated, and if
`where` is provided, it selects which elements to copy.

.. versionadded:: 1.7.0

Parameters
----------
dst : ndarray
    The array into which values are copied.
src : array_like
    The array from which values are copied.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur when copying.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
where : array_like of bool, optional
    A boolean array which is broadcasted to match the dimensions
    of `dst`, and selects elements to copy from `src` to `dst`
    wherever it contains the value True.

Examples
--------
&gt;&gt;&gt; A = np.array([4, 5, 6])
&gt;&gt;&gt; B = [1, 2, 3]
&gt;&gt;&gt; np.copyto(A, B)
&gt;&gt;&gt; A
array([1, 2, 3])

&gt;&gt;&gt; A = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; B = [[4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; np.copyto(A, B)
&gt;&gt;&gt; A
array([[4, 5, 6],
       [7, 8, 9]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1080</span><span class="keyword">def </span>copyto(dst, src, casting=None, where=None):</div>
<div class="line"><span class="lineno"> 1081</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    copyto(dst, src, casting=&#39;same_kind&#39;, where=True)</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    Copies values from one array to another, broadcasting as necessary.</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    Raises a TypeError if the `casting` rule is violated, and if</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    `where` is provided, it selects which elements to copy.</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    dst : ndarray</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        The array into which values are copied.</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">    src : array_like</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">        The array from which values are copied.</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">        Controls what kind of data casting may occur when copying.</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">          * &#39;no&#39; means the data types should not be cast at all.</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">          * &#39;equiv&#39; means only byte-order changes are allowed.</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">          * &#39;safe&#39; means only casts which can preserve values are allowed.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">          * &#39;same_kind&#39; means only safe casts or casts within a kind,</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">            like float64 to float32, are allowed.</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">          * &#39;unsafe&#39; means any data conversions may be done.</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">        A boolean array which is broadcasted to match the dimensions</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">        of `dst`, and selects elements to copy from `src` to `dst`</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">        wherever it contains the value True.</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    &gt;&gt;&gt; B = [1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    &gt;&gt;&gt; np.copyto(A, B)</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    &gt;&gt;&gt; A</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    array([1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[1, 2, 3], [4, 5, 6]])</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    &gt;&gt;&gt; B = [[4, 5, 6], [7, 8, 9]]</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    &gt;&gt;&gt; np.copyto(A, B)</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    &gt;&gt;&gt; A</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    array([[4, 5, 6],</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">           [7, 8, 9]])</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">       </span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1127</span>    <span class="keywordflow">return</span> (dst, src, where)</div>
<div class="line"><span class="lineno"> 1128</span> </div>
<div class="line"><span class="lineno"> 1129</span> </div>
<div class="line"><span class="lineno"> 1130</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.putmask)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="affcfe796e24491e022f5c5ea93e9007c" name="affcfe796e24491e022f5c5ea93e9007c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcfe796e24491e022f5c5ea93e9007c">&#9670;&#160;</a></span>datetime_as_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.datetime_as_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timezone</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')

Convert an array of datetimes into an array of strings.

Parameters
----------
arr : array_like of datetime64
    The array of UTC timestamps to format.
unit : str
    One of None, 'auto', or a :ref:`datetime unit &lt;arrays.dtypes.dateunits&gt;`.
timezone : {'naive', 'UTC', 'local'} or tzinfo
    Timezone information to use when displaying the datetime. If 'UTC', end
    with a Z to indicate UTC time. If 'local', convert to the local timezone
    first, and suffix with a +-#### timezone offset. If a tzinfo object,
    then do as with 'local', but use the specified timezone.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}
    Casting to allow when changing between datetime units.

Returns
-------
str_arr : ndarray
    An array of strings the same shape as `arr`.

Examples
--------
&gt;&gt;&gt; import pytz
&gt;&gt;&gt; d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
&gt;&gt;&gt; d
array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
       '2002-10-27T07:30'], dtype='datetime64[m]')

Setting the timezone to UTC shows the same information, but with a Z suffix

&gt;&gt;&gt; np.datetime_as_string(d, timezone='UTC')
array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
       '2002-10-27T07:30Z'], dtype='&lt;U35')

Note that we picked datetimes that cross a DST boundary. Passing in a
``pytz`` timezone object will print the appropriate offset

&gt;&gt;&gt; np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='&lt;U39')

Passing in a unit will change the precision

&gt;&gt;&gt; np.datetime_as_string(d, unit='h')
array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
      dtype='&lt;U32')
&gt;&gt;&gt; np.datetime_as_string(d, unit='s')
array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
       '2002-10-27T07:30:00'], dtype='&lt;U38')

'casting' can be used to specify whether precision can be changed

&gt;&gt;&gt; np.datetime_as_string(d, unit='h', casting='safe')
Traceback (most recent call last):
    ...
TypeError: Cannot create a datetime string as units 'h' from a NumPy
datetime with units 'm' according to the rule 'safe'
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1651</span><span class="keyword">def </span>datetime_as_string(arr, unit=None, timezone=None, casting=None):</div>
<div class="line"><span class="lineno"> 1652</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">    datetime_as_string(arr, unit=None, timezone=&#39;naive&#39;, casting=&#39;same_kind&#39;)</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">    Convert an array of datetimes into an array of strings.</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">    arr : array_like of datetime64</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">        The array of UTC timestamps to format.</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">    unit : str</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">        One of None, &#39;auto&#39;, or a :ref:`datetime unit &lt;arrays.dtypes.dateunits&gt;`.</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">    timezone : {&#39;naive&#39;, &#39;UTC&#39;, &#39;local&#39;} or tzinfo</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">        Timezone information to use when displaying the datetime. If &#39;UTC&#39;, end</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">        with a Z to indicate UTC time. If &#39;local&#39;, convert to the local timezone</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">        first, and suffix with a +-#### timezone offset. If a tzinfo object,</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">        then do as with &#39;local&#39;, but use the specified timezone.</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">        Casting to allow when changing between datetime units.</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    str_arr : ndarray</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">        An array of strings the same shape as `arr`.</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    &gt;&gt;&gt; import pytz</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">    &gt;&gt;&gt; d = np.arange(&#39;2002-10-27T04:30&#39;, 4*60, 60, dtype=&#39;M8[m]&#39;)</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    &gt;&gt;&gt; d</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    array([&#39;2002-10-27T04:30&#39;, &#39;2002-10-27T05:30&#39;, &#39;2002-10-27T06:30&#39;,</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">           &#39;2002-10-27T07:30&#39;], dtype=&#39;datetime64[m]&#39;)</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    Setting the timezone to UTC shows the same information, but with a Z suffix</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">    &gt;&gt;&gt; np.datetime_as_string(d, timezone=&#39;UTC&#39;)</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">    array([&#39;2002-10-27T04:30Z&#39;, &#39;2002-10-27T05:30Z&#39;, &#39;2002-10-27T06:30Z&#39;,</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">           &#39;2002-10-27T07:30Z&#39;], dtype=&#39;&lt;U35&#39;)</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    Note that we picked datetimes that cross a DST boundary. Passing in a</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">    ``pytz`` timezone object will print the appropriate offset</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">    &gt;&gt;&gt; np.datetime_as_string(d, timezone=pytz.timezone(&#39;US/Eastern&#39;))</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">    array([&#39;2002-10-27T00:30-0400&#39;, &#39;2002-10-27T01:30-0400&#39;,</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">           &#39;2002-10-27T01:30-0500&#39;, &#39;2002-10-27T02:30-0500&#39;], dtype=&#39;&lt;U39&#39;)</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">    Passing in a unit will change the precision</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">    &gt;&gt;&gt; np.datetime_as_string(d, unit=&#39;h&#39;)</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    array([&#39;2002-10-27T04&#39;, &#39;2002-10-27T05&#39;, &#39;2002-10-27T06&#39;, &#39;2002-10-27T07&#39;],</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">          dtype=&#39;&lt;U32&#39;)</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    &gt;&gt;&gt; np.datetime_as_string(d, unit=&#39;s&#39;)</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    array([&#39;2002-10-27T04:30:00&#39;, &#39;2002-10-27T05:30:00&#39;, &#39;2002-10-27T06:30:00&#39;,</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral">           &#39;2002-10-27T07:30:00&#39;], dtype=&#39;&lt;U38&#39;)</span></div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral">    &#39;casting&#39; can be used to specify whether precision can be changed</span></div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">    &gt;&gt;&gt; np.datetime_as_string(d, unit=&#39;h&#39;, casting=&#39;safe&#39;)</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">    TypeError: Cannot create a datetime string as units &#39;h&#39; from a NumPy</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">    datetime with units &#39;m&#39; according to the rule &#39;safe&#39;</span></div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1714</span>    <span class="keywordflow">return</span> (arr,)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d9a5c7d84575fc3b30df46912ecba76" name="a6d9a5c7d84575fc3b30df46912ecba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9a5c7d84575fc3b30df46912ecba76">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.dot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">dot(a, b, out=None)

Dot product of two arrays. Specifically,

- If both `a` and `b` are 1-D arrays, it is inner product of vectors
  (without complex conjugation).

- If both `a` and `b` are 2-D arrays, it is matrix multiplication,
  but using :func:`matmul` or ``a @ b`` is preferred.

- If either `a` or `b` is 0-D (scalar), it is equivalent to
  :func:`multiply` and using ``numpy.multiply(a, b)`` or ``a * b`` is
  preferred.

- If `a` is an N-D array and `b` is a 1-D array, it is a sum product over
  the last axis of `a` and `b`.

- If `a` is an N-D array and `b` is an M-D array (where ``M&gt;=2``), it is a
  sum product over the last axis of `a` and the second-to-last axis of
  `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

It uses an optimized BLAS library when possible (see `numpy.linalg`).

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If `out` is given, then it is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.
linalg.multi_dot : Chained dot product.

Examples
--------
&gt;&gt;&gt; np.dot(3, 4)
12

Neither argument is complex-conjugated:

&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])
(-13+0j)

For 2-D arrays it is the matrix product:

&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [[4, 1], [2, 2]]
&gt;&gt;&gt; np.dot(a, b)
array([[4, 1],
       [2, 2]])

&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))
&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]
499128
&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])
499128</pre> <div class="fragment"><div class="line"><span class="lineno">  741</span><span class="keyword">def </span>dot(a, b, out=None):</div>
<div class="line"><span class="lineno">  742</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    dot(a, b, out=None)</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    Dot product of two arrays. Specifically,</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    - If both `a` and `b` are 1-D arrays, it is inner product of vectors</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">      (without complex conjugation).</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    - If both `a` and `b` are 2-D arrays, it is matrix multiplication,</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">      but using :func:`matmul` or ``a @ b`` is preferred.</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    - If either `a` or `b` is 0-D (scalar), it is equivalent to</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">      :func:`multiply` and using ``numpy.multiply(a, b)`` or ``a * b`` is</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">      preferred.</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    - If `a` is an N-D array and `b` is a 1-D array, it is a sum product over</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">      the last axis of `a` and `b`.</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    - If `a` is an N-D array and `b` is an M-D array (where ``M&gt;=2``), it is a</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">      sum product over the last axis of `a` and the second-to-last axis of</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">      `b`::</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    It uses an optimized BLAS library when possible (see `numpy.linalg`).</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        First argument.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">        Second argument.</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">        Output argument. This must have the exact kind that would be returned</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        if it was not used. In particular, it must have the right type, must be</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">        C-contiguous, and its dtype must be the dtype that would be returned</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">        for `dot(a,b)`. This is a performance feature. Therefore, if these</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        conditions are not met, an exception is raised, instead of attempting</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">        to be flexible.</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        Returns the dot product of `a` and `b`.  If `a` and `b` are both</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        scalars or both 1-D arrays then a scalar is returned; otherwise</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        an array is returned.</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        If `out` is given, then it is returned.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">        If the last dimension of `a` is not the same size as</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        the second-to-last dimension of `b`.</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    vdot : Complex-conjugating dot product.</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    tensordot : Sum products over arbitrary axes.</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    einsum : Einstein summation convention.</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    matmul : &#39;@&#39; operator as method with out parameter.</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    linalg.multi_dot : Chained dot product.</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(3, 4)</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    12</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    Neither argument is complex-conjugated:</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    &gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    (-13+0j)</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    For 2-D arrays it is the matrix product:</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    &gt;&gt;&gt; a = [[1, 0], [0, 1]]</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    &gt;&gt;&gt; b = [[4, 1], [2, 2]]</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(a, b)</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    array([[4, 1],</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">           [2, 2]])</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    499128</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    &gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    499128</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  830</span>    <span class="keywordflow">return</span> (a, b, out)</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span> </div>
<div class="line"><span class="lineno">  833</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.vdot)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ada1001d8f93718a2060ebb0bfb320566" name="ada1001d8f93718a2060ebb0bfb320566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1001d8f93718a2060ebb0bfb320566">&#9670;&#160;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.empty_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prototype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">empty_like(prototype, dtype=None, order='K', subok=True, shape=None)

Return a new array with the same shape and type as a given array.

Parameters
----------
prototype : array_like
    The shape and data-type of `prototype` define these same attributes
    of the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `prototype` is Fortran
    contiguous, 'C' otherwise. 'K' means match the layout of `prototype`
    as closely as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `prototype`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the same
    shape and type as `prototype`.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.  It may be marginally faster than
the functions that do set the array values.

Examples
--------
&gt;&gt;&gt; a = ([1,2,3], [4,5,6])                         # a is array-like
&gt;&gt;&gt; np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
&gt;&gt;&gt; a = np.array([[1., 2., 3.],[4.,5.,6.]])
&gt;&gt;&gt; np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</pre> <div class="fragment"><div class="line"><span class="lineno">   85</span><span class="keyword">def </span>empty_like(prototype, dtype=None, order=None, subok=None, shape=None):</div>
<div class="line"><span class="lineno">   86</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    empty_like(prototype, dtype=None, order=&#39;K&#39;, subok=True, shape=None)</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    Return a new array with the same shape and type as a given array.</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    prototype : array_like</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        The shape and data-type of `prototype` define these same attributes</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        of the returned array.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        Overrides the data type of the result.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, or &#39;K&#39;}, optional</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        Overrides the memory layout of the result. &#39;C&#39; means C-order,</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `prototype` is Fortran</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        contiguous, &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `prototype`</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        as closely as possible.</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    subok : bool, optional.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        If True, then the newly created array will use the sub-class</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        type of `prototype`, otherwise it will be a base-class array. Defaults</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        to True.</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    shape : int or sequence of ints, optional.</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        Overrides the shape of the result. If order=&#39;K&#39; and the number of</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        dimensions is unchanged, will try to keep order, otherwise,</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        order=&#39;C&#39; is implied.</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        Array of uninitialized (arbitrary) data with the same</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        shape and type as `prototype`.</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    ones_like : Return an array of ones with shape and type of input.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    zeros_like : Return an array of zeros with shape and type of input.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    full_like : Return a new array with shape of input filled with value.</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    empty : Return a new uninitialized array.</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    This function does *not* initialize the returned array; to do that use</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    `zeros_like` or `ones_like` instead.  It may be marginally faster than</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    the functions that do set the array values.</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    &gt;&gt;&gt; a = ([1,2,3], [4,5,6])                         # a is array-like</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    &gt;&gt;&gt; np.empty_like(a)</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    array([[-1073741821, -1073741821,           3],    # uninitialized</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">           [          0,           0, -1073741821]])</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1., 2., 3.],[4.,5.,6.]])</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    &gt;&gt;&gt; np.empty_like(a)</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">           [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">return</span> (prototype,)</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.concatenate)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b170dbdd3f2d833f9eb7c289cb9308b" name="a2b170dbdd3f2d833f9eb7c289cb9308b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b170dbdd3f2d833f9eb7c289cb9308b">&#9670;&#160;</a></span>inner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.inner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">inner(a, b, /)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions must match.

Returns
-------
out : ndarray
    If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    ``out.shape = (*a.shape[:-1], *b.shape[:-1])``

Raises
------
ValueError
    If both `a` and `b` are nonscalar and their last dimensions have
    different sizes.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if ``ndim(a) = r &gt; 0`` and ``ndim(b) = s &gt; 0``::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-2,j0,...,js-2]
         = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; b = np.array([0,1,0])
&gt;&gt;&gt; np.inner(a, b)
2

Some multidimensional examples:

&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; c = np.inner(a, b)
&gt;&gt;&gt; c.shape
(2, 3)
&gt;&gt;&gt; c
array([[ 14,  38,  62],
       [ 86, 110, 134]])

&gt;&gt;&gt; a = np.arange(2).reshape((1,1,2))
&gt;&gt;&gt; b = np.arange(6).reshape((3,2))
&gt;&gt;&gt; c = np.inner(a, b)
&gt;&gt;&gt; c.shape
(1, 1, 3)
&gt;&gt;&gt; c
array([[[1, 3, 5]]])

An example where `b` is a scalar:

&gt;&gt;&gt; np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])</pre> <div class="fragment"><div class="line"><span class="lineno">  254</span><span class="keyword">def </span>inner(a, b):</div>
<div class="line"><span class="lineno">  255</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    inner(a, b, /)</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    Inner product of two arrays.</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    Ordinary inner product of vectors for 1-D arrays (without complex</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    conjugation), in higher dimensions a sum product over the last axes.</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    a, b : array_like</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">        If `a` and `b` are nonscalar, their last dimensions must match.</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        If `a` and `b` are both</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        scalars or both 1-D arrays then a scalar is returned; otherwise</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">        an array is returned.</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        ``out.shape = (*a.shape[:-1], *b.shape[:-1])``</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        If both `a` and `b` are nonscalar and their last dimensions have</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        different sizes.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    tensordot : Sum products over arbitrary axes.</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    dot : Generalised matrix product, using second last dimension of `b`.</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    einsum : Einstein summation convention.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    For vectors (1-D arrays) it computes the ordinary inner-product::</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        np.inner(a, b) = sum(a[:]*b[:])</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    More generally, if ``ndim(a) = r &gt; 0`` and ``ndim(b) = s &gt; 0``::</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    or explicitly::</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        np.inner(a, b)[i0,...,ir-2,j0,...,js-2]</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">             = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    In addition `a` or `b` may be scalars, in which case::</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">       np.inner(a,b) = a*b</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    Ordinary inner product for vectors:</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1,2,3])</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([0,1,0])</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    &gt;&gt;&gt; np.inner(a, b)</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    2</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    Some multidimensional examples:</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(4)</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    &gt;&gt;&gt; c = np.inner(a, b)</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    &gt;&gt;&gt; c.shape</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    (2, 3)</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    &gt;&gt;&gt; c</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    array([[ 14,  38,  62],</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">           [ 86, 110, 134]])</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(2).reshape((1,1,2))</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(6).reshape((3,2))</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    &gt;&gt;&gt; c = np.inner(a, b)</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    &gt;&gt;&gt; c.shape</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    (1, 1, 3)</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    &gt;&gt;&gt; c</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    array([[[1, 3, 5]]])</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    An example where `b` is a scalar:</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    &gt;&gt;&gt; np.inner(np.eye(2), 7)</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    array([[7., 0.],</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">           [0., 7.]])</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  342</span>    <span class="keywordflow">return</span> (a, b)</div>
<div class="line"><span class="lineno">  343</span> </div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.where)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a15d744404a5ecb28d9cbb89b9762cc53" name="a15d744404a5ecb28d9cbb89b9762cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d744404a5ecb28d9cbb89b9762cc53">&#9670;&#160;</a></span>is_busday()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.is_busday </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weekmask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>holidays</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>busdaycal</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)

Calculates which of the given dates are valid days, and which are not.

.. versionadded:: 1.7.0

Parameters
----------
dates : array_like of datetime64[D]
    The array of dates to process.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of bool, optional
    If provided, this array is filled with the result.

Returns
-------
out : array of bool
    An array with the same shape as ``dates``, containing True for
    each valid day, and False for each invalid day.

See Also
--------
busdaycalendar : An object that specifies a custom set of valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.

Examples
--------
&gt;&gt;&gt; # The weekdays are Friday, Saturday, and Monday
... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
array([False, False,  True])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1434</span><span class="keyword">def </span>is_busday(dates, weekmask=None, holidays=None, busdaycal=None, out=None):</div>
<div class="line"><span class="lineno"> 1435</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">    is_busday(dates, weekmask=&#39;1111100&#39;, holidays=None, busdaycal=None, out=None)</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    Calculates which of the given dates are valid days, and which are not.</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    dates : array_like of datetime64[D]</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">        The array of dates to process.</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    weekmask : str or array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">        A seven-element array indicating which of Monday through Sunday are</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">        valid days. May be specified as a length-seven list or array, like</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">        [1,1,1,1,1,0,0]; a length-seven string, like &#39;1111100&#39;; or a string</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">        like &quot;Mon Tue Wed Thu Fri&quot;, made up of 3-character abbreviations for</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">        weekdays, optionally separated by white space. Valid abbreviations</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">        are: Mon Tue Wed Thu Fri Sat Sun</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    holidays : array_like of datetime64[D], optional</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">        An array of dates to consider as invalid dates.  They may be</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">        specified in any order, and NaT (not-a-time) dates are ignored.</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">        This list is saved in a normalized form that is suited for</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">        fast calculations of valid days.</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">    busdaycal : busdaycalendar, optional</span></div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">        A `busdaycalendar` object which specifies the valid days. If this</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">        parameter is provided, neither weekmask nor holidays may be</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">        provided.</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">    out : array of bool, optional</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">        If provided, this array is filled with the result.</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral">    out : array of bool</span></div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">        An array with the same shape as ``dates``, containing True for</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">        each valid day, and False for each invalid day.</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">    busdaycalendar : An object that specifies a custom set of valid days.</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">    busday_offset : Applies an offset counted in valid days.</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    busday_count : Counts how many valid days are in a half-open date range.</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">    &gt;&gt;&gt; # The weekdays are Friday, Saturday, and Monday</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">    ... np.is_busday([&#39;2011-07-01&#39;, &#39;2011-07-02&#39;, &#39;2011-07-18&#39;],</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">    ...                 holidays=[&#39;2011-07-01&#39;, &#39;2011-07-04&#39;, &#39;2011-07-17&#39;])</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">    array([False, False,  True])</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1484</span>    <span class="keywordflow">return</span> (dates, weekmask, holidays, out)</div>
<div class="line"><span class="lineno"> 1485</span> </div>
<div class="line"><span class="lineno"> 1486</span> </div>
<div class="line"><span class="lineno"> 1487</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_offset)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ace8ad7def2a66f3fe06f715cb4023972" name="ace8ad7def2a66f3fe06f715cb4023972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8ad7def2a66f3fe06f715cb4023972">&#9670;&#160;</a></span>lexsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.lexsort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">lexsort(keys, axis=-1)

Perform an indirect stable sort using a sequence of keys.

Given multiple sorting keys, which can be interpreted as columns in a
spreadsheet, lexsort returns an array of integer indices that describes
the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, the second-to-last key for the secondary sort
order, and so on. The keys argument must be a sequence of objects that
can be converted to arrays of the same shape. If a 2D array is provided
for the keys argument, its rows are interpreted as the sorting keys and
sorting is according to the last row, second last row etc.

Parameters
----------
keys : (k, N) array or tuple containing k (N,)-shaped sequences
    The `k` different "columns" to be sorted.  The last column (or row if
    `keys` is a 2D array) is the primary sort key.
axis : int, optional
    Axis to be indirectly sorted.  By default, sort over the last axis.

Returns
-------
indices : (N,) ndarray of ints
    Array of indices that sort the keys along the specified axis.

See Also
--------
argsort : Indirect sort.
ndarray.sort : In-place sort.
sort : Return a sorted copy of an array.

Examples
--------
Sort names: first by surname, then by name.

&gt;&gt;&gt; surnames =    ('Hertz',    'Galilei', 'Hertz')
&gt;&gt;&gt; first_names = ('Heinrich', 'Galileo', 'Gustav')
&gt;&gt;&gt; ind = np.lexsort((first_names, surnames))
&gt;&gt;&gt; ind
array([1, 2, 0])

&gt;&gt;&gt; [surnames[i] + ", " + first_names[i] for i in ind]
['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']

Sort two columns of numbers:

&gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column
&gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column
&gt;&gt;&gt; ind = np.lexsort((b,a)) # Sort by a, then by b
&gt;&gt;&gt; ind
array([2, 0, 4, 6, 5, 3, 1])

&gt;&gt;&gt; [(a[i],b[i]) for i in ind]
[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]

Note that sorting is first according to the elements of ``a``.
Secondary sorting is according to the elements of ``b``.

A normal ``argsort`` would have yielded:

&gt;&gt;&gt; [(a[i],b[i]) for i in np.argsort(a)]
[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]

Structured arrays are sorted lexically by ``argsort``:

&gt;&gt;&gt; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
...              dtype=np.dtype([('x', int), ('y', int)]))

&gt;&gt;&gt; np.argsort(x) # or np.argsort(x, order=('x', 'y'))
array([2, 0, 4, 6, 5, 3, 1])</pre> <div class="fragment"><div class="line"><span class="lineno">  421</span><span class="keyword">def </span>lexsort(keys, axis=None):</div>
<div class="line"><span class="lineno">  422</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    lexsort(keys, axis=-1)</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    Perform an indirect stable sort using a sequence of keys.</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    Given multiple sorting keys, which can be interpreted as columns in a</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    spreadsheet, lexsort returns an array of integer indices that describes</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    the sort order by multiple columns. The last key in the sequence is used</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    for the primary sort order, the second-to-last key for the secondary sort</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    order, and so on. The keys argument must be a sequence of objects that</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    can be converted to arrays of the same shape. If a 2D array is provided</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    for the keys argument, its rows are interpreted as the sorting keys and</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    sorting is according to the last row, second last row etc.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    keys : (k, N) array or tuple containing k (N,)-shaped sequences</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        The `k` different &quot;columns&quot; to be sorted.  The last column (or row if</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        `keys` is a 2D array) is the primary sort key.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        Axis to be indirectly sorted.  By default, sort over the last axis.</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    indices : (N,) ndarray of ints</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        Array of indices that sort the keys along the specified axis.</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    argsort : Indirect sort.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    ndarray.sort : In-place sort.</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    sort : Return a sorted copy of an array.</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    Sort names: first by surname, then by name.</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    &gt;&gt;&gt; surnames =    (&#39;Hertz&#39;,    &#39;Galilei&#39;, &#39;Hertz&#39;)</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    &gt;&gt;&gt; first_names = (&#39;Heinrich&#39;, &#39;Galileo&#39;, &#39;Gustav&#39;)</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    &gt;&gt;&gt; ind = np.lexsort((first_names, surnames))</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    &gt;&gt;&gt; ind</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    array([1, 2, 0])</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    &gt;&gt;&gt; [surnames[i] + &quot;, &quot; + first_names[i] for i in ind]</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    [&#39;Galilei, Galileo&#39;, &#39;Hertz, Gustav&#39;, &#39;Hertz, Heinrich&#39;]</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    Sort two columns of numbers:</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    &gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    &gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    &gt;&gt;&gt; ind = np.lexsort((b,a)) # Sort by a, then by b</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    &gt;&gt;&gt; ind</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    array([2, 0, 4, 6, 5, 3, 1])</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    &gt;&gt;&gt; [(a[i],b[i]) for i in ind]</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    Note that sorting is first according to the elements of ``a``.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    Secondary sorting is according to the elements of ``b``.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    A normal ``argsort`` would have yielded:</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    &gt;&gt;&gt; [(a[i],b[i]) for i in np.argsort(a)]</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    Structured arrays are sorted lexically by ``argsort``:</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    ...              dtype=np.dtype([(&#39;x&#39;, int), (&#39;y&#39;, int)]))</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    &gt;&gt;&gt; np.argsort(x) # or np.argsort(x, order=(&#39;x&#39;, &#39;y&#39;))</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    array([2, 0, 4, 6, 5, 3, 1])</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  496</span>    <span class="keywordflow">if</span> isinstance(keys, tuple):</div>
<div class="line"><span class="lineno">  497</span>        <span class="keywordflow">return</span> keys</div>
<div class="line"><span class="lineno">  498</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  499</span>        <span class="keywordflow">return</span> (keys,)</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span> </div>
<div class="line"><span class="lineno">  502</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.can_cast)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a53ad592278d3cb45614f93e90a1acffc" name="a53ad592278d3cb45614f93e90a1acffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ad592278d3cb45614f93e90a1acffc">&#9670;&#160;</a></span>may_share_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.may_share_memory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_work</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">may_share_memory(a, b, /, max_work=None)

Determine if two arrays might share memory

A return of True does not necessarily mean that the two arrays
share any element.  It just means that they *might*.

Only the memory bounds of a and b are checked by default.

Parameters
----------
a, b : ndarray
    Input arrays
max_work : int, optional
    Effort to spend on solving the overlap problem.  See
    `shares_memory` for details.  Default for ``may_share_memory``
    is to do a bounds check.

Returns
-------
out : bool

See Also
--------
shares_memory

Examples
--------
&gt;&gt;&gt; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
False
&gt;&gt;&gt; x = np.zeros([3, 4])
&gt;&gt;&gt; np.may_share_memory(x[:,0], x[:,1])
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1393</span><span class="keyword">def </span>may_share_memory(a, b, max_work=None):</div>
<div class="line"><span class="lineno"> 1394</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    may_share_memory(a, b, /, max_work=None)</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    Determine if two arrays might share memory</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">    A return of True does not necessarily mean that the two arrays</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    share any element.  It just means that they *might*.</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    Only the memory bounds of a and b are checked by default.</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    a, b : ndarray</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">        Input arrays</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    max_work : int, optional</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">        Effort to spend on solving the overlap problem.  See</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">        `shares_memory` for details.  Default for ``may_share_memory``</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">        is to do a bounds check.</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">    out : bool</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">    shares_memory</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    &gt;&gt;&gt; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    &gt;&gt;&gt; x = np.zeros([3, 4])</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    &gt;&gt;&gt; np.may_share_memory(x[:,0], x[:,1])</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1430</span>    <span class="keywordflow">return</span> (a, b)</div>
<div class="line"><span class="lineno"> 1431</span> </div>
<div class="line"><span class="lineno"> 1432</span> </div>
<div class="line"><span class="lineno"> 1433</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.is_busday)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a33554df6963ba407087d085e3d3e92cc" name="a33554df6963ba407087d085e3d3e92cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33554df6963ba407087d085e3d3e92cc">&#9670;&#160;</a></span>min_scalar_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.min_scalar_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">min_scalar_type(a, /)

For scalar ``a``, returns the data type with the smallest size
and smallest scalar kind which can hold its value.  For non-scalar
array ``a``, returns the vector's dtype unmodified.

Floating point values are not demoted to integers,
and complex values are not demoted to floats.

Parameters
----------
a : scalar or array_like
    The value whose minimal data type is to be found.

Returns
-------
out : dtype
    The minimal data type.

Notes
-----
.. versionadded:: 1.6.0

See Also
--------
result_type, promote_types, dtype, can_cast

Examples
--------
&gt;&gt;&gt; np.min_scalar_type(10)
dtype('uint8')

&gt;&gt;&gt; np.min_scalar_type(-260)
dtype('int16')

&gt;&gt;&gt; np.min_scalar_type(3.1)
dtype('float16')

&gt;&gt;&gt; np.min_scalar_type(1e50)
dtype('float64')

&gt;&gt;&gt; np.min_scalar_type(np.arange(4,dtype='f8'))
dtype('float64')</pre> <div class="fragment"><div class="line"><span class="lineno">  618</span><span class="keyword">def </span>min_scalar_type(a):</div>
<div class="line"><span class="lineno">  619</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    min_scalar_type(a, /)</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    For scalar ``a``, returns the data type with the smallest size</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    and smallest scalar kind which can hold its value.  For non-scalar</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    array ``a``, returns the vector&#39;s dtype unmodified.</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    Floating point values are not demoted to integers,</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    and complex values are not demoted to floats.</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    a : scalar or array_like</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">        The value whose minimal data type is to be found.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    out : dtype</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        The minimal data type.</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    result_type, promote_types, dtype, can_cast</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    &gt;&gt;&gt; np.min_scalar_type(10)</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    dtype(&#39;uint8&#39;)</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    &gt;&gt;&gt; np.min_scalar_type(-260)</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    dtype(&#39;int16&#39;)</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    &gt;&gt;&gt; np.min_scalar_type(3.1)</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    dtype(&#39;float16&#39;)</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    &gt;&gt;&gt; np.min_scalar_type(1e50)</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    dtype(&#39;float64&#39;)</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    &gt;&gt;&gt; np.min_scalar_type(np.arange(4,dtype=&#39;f8&#39;))</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    dtype(&#39;float64&#39;)</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.result_type)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a91a2455f865e0ab4d6e086efac2163fa" name="a91a2455f865e0ab4d6e086efac2163fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a2455f865e0ab4d6e086efac2163fa">&#9670;&#160;</a></span>packbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.packbits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bitorder</em> = <code>'big'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">packbits(a, /, axis=None, bitorder='big')

Packs the elements of a binary-valued array into bits in a uint8 array.

The result is padded to full bytes by inserting zero bits at the end.

Parameters
----------
a : array_like
    An array of integers or booleans whose elements should be packed to
    bits.
axis : int, optional
    The dimension over which bit-packing is done.
    ``None`` implies packing the flattened array.
bitorder : {'big', 'little'}, optional
    The order of the input bits. 'big' will mimic bin(val),
    ``[0, 0, 0, 0, 0, 0, 1, 1] =&gt; 3 = 0b00000011``, 'little' will
    reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&gt; 3``.
    Defaults to 'big'.

    .. versionadded:: 1.17.0

Returns
-------
packed : ndarray
    Array of type uint8 whose elements represent bits corresponding to the
    logical (0 or nonzero) value of the input elements. The shape of
    `packed` has the same number of dimensions as the input (unless `axis`
    is None, in which case the output is 1-D).

See Also
--------
unpackbits: Unpacks elements of a uint8 array into a binary-valued output
            array.

Examples
--------
&gt;&gt;&gt; a = np.array([[[1,0,1],
...                [0,1,0]],
...               [[1,1,0],
...                [0,0,1]]])
&gt;&gt;&gt; b = np.packbits(a, axis=-1)
&gt;&gt;&gt; b
array([[[160],
        [ 64]],
       [[192],
        [ 32]]], dtype=uint8)

Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
and 32 = 0010 0000.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1176</span><span class="keyword">def </span>packbits(a, axis=None, bitorder=&#39;big&#39;):</div>
<div class="line"><span class="lineno"> 1177</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">    packbits(a, /, axis=None, bitorder=&#39;big&#39;)</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    Packs the elements of a binary-valued array into bits in a uint8 array.</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    The result is padded to full bytes by inserting zero bits at the end.</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">        An array of integers or booleans whose elements should be packed to</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">        bits.</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">        The dimension over which bit-packing is done.</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">        ``None`` implies packing the flattened array.</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    bitorder : {&#39;big&#39;, &#39;little&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">        The order of the input bits. &#39;big&#39; will mimic bin(val),</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">        ``[0, 0, 0, 0, 0, 0, 1, 1] =&gt; 3 = 0b00000011``, &#39;little&#39; will</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">        reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&gt; 3``.</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">        Defaults to &#39;big&#39;.</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    packed : ndarray</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">        Array of type uint8 whose elements represent bits corresponding to the</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">        logical (0 or nonzero) value of the input elements. The shape of</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">        `packed` has the same number of dimensions as the input (unless `axis`</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">        is None, in which case the output is 1-D).</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    unpackbits: Unpacks elements of a uint8 array into a binary-valued output</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">                array.</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[[1,0,1],</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    ...                [0,1,0]],</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    ...               [[1,1,0],</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    ...                [0,0,1]]])</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    &gt;&gt;&gt; b = np.packbits(a, axis=-1)</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">    array([[[160],</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">            [ 64]],</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">           [[192],</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">            [ 32]]], dtype=uint8)</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    and 32 = 0010 0000.</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1230</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1231</span> </div>
<div class="line"><span class="lineno"> 1232</span> </div>
<div class="line"><span class="lineno"> 1233</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.unpackbits)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9b8a9c5fd8b434b5700a26280140116" name="ae9b8a9c5fd8b434b5700a26280140116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8a9c5fd8b434b5700a26280140116">&#9670;&#160;</a></span>putmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.putmask </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">putmask(a, mask, values)

Changes elements of an array based on conditional and input values.

Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.

If `values` is not the same size as `a` and `mask` then it will repeat.
This gives behavior different from ``a[mask] = values``.

Parameters
----------
a : ndarray
    Target array.
mask : array_like
    Boolean mask array. It has to be the same shape as `a`.
values : array_like
    Values to put into `a` where `mask` is True. If `values` is smaller
    than `a` it will be repeated.

See Also
--------
place, put, take, copyto

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)
&gt;&gt;&gt; np.putmask(x, x&gt;2, x**2)
&gt;&gt;&gt; x
array([[ 0,  1,  2],
       [ 9, 16, 25]])

If `values` is smaller than `a` it is repeated:

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.putmask(x, x&gt;1, [-33, -44])
&gt;&gt;&gt; x
array([  0,   1, -33, -44, -33])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1131</span><span class="keyword">def </span>putmask(a, mask, values):</div>
<div class="line"><span class="lineno"> 1132</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    putmask(a, mask, values)</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    Changes elements of an array based on conditional and input values.</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    If `values` is not the same size as `a` and `mask` then it will repeat.</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    This gives behavior different from ``a[mask] = values``.</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">        Target array.</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    mask : array_like</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">        Boolean mask array. It has to be the same shape as `a`.</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    values : array_like</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">        Values to put into `a` where `mask` is True. If `values` is smaller</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">        than `a` it will be repeated.</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    place, put, take, copyto</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(6).reshape(2, 3)</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    &gt;&gt;&gt; np.putmask(x, x&gt;2, x**2)</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    array([[ 0,  1,  2],</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">           [ 9, 16, 25]])</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    If `values` is smaller than `a` it is repeated:</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(5)</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    &gt;&gt;&gt; np.putmask(x, x&gt;1, [-33, -44])</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    array([  0,   1, -33, -44, -33])</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1172</span>    <span class="keywordflow">return</span> (a, mask, values)</div>
<div class="line"><span class="lineno"> 1173</span> </div>
<div class="line"><span class="lineno"> 1174</span> </div>
<div class="line"><span class="lineno"> 1175</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.packbits)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8504d23fefcc338cbd7617d1b6a78ad8" name="a8504d23fefcc338cbd7617d1b6a78ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8504d23fefcc338cbd7617d1b6a78ad8">&#9670;&#160;</a></span>ravel_multi_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.ravel_multi_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">ravel_multi_index(multi_index, dims, mode='raise', order='C')

Converts a tuple of index arrays into an array of flat
indices, applying boundary modes to the multi-index.

Parameters
----------
multi_index : tuple of array_like
    A tuple of integer arrays, one array for each dimension.
dims : tuple of ints
    The shape of array into which the indices from ``multi_index`` apply.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices are handled.  Can specify
    either one mode or a tuple of modes, one mode per index.

    * 'raise' -- raise an error (default)
    * 'wrap' -- wrap around
    * 'clip' -- clip to the range

    In 'clip' mode, a negative index which would normally
    wrap will clip to 0 instead.
order : {'C', 'F'}, optional
    Determines whether the multi-index should be viewed as
    indexing in row-major (C-style) or column-major
    (Fortran-style) order.

Returns
-------
raveled_indices : ndarray
    An array of indices into the flattened version of an array
    of dimensions ``dims``.

See Also
--------
unravel_index

Notes
-----
.. versionadded:: 1.6.0

Examples
--------
&gt;&gt;&gt; arr = np.array([[3,6,6],[4,5,1]])
&gt;&gt;&gt; np.ravel_multi_index(arr, (7,6))
array([22, 41, 37])
&gt;&gt;&gt; np.ravel_multi_index(arr, (7,6), order='F')
array([31, 41, 13])
&gt;&gt;&gt; np.ravel_multi_index(arr, (4,6), mode='clip')
array([22, 23, 19])
&gt;&gt;&gt; np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
array([12, 13, 13])

&gt;&gt;&gt; np.ravel_multi_index((3,1,4,1), (6,7,8,9))
1621
</pre> <div class="fragment"><div class="line"><span class="lineno">  969</span><span class="keyword">def </span>ravel_multi_index(multi_index, dims, mode=None, order=None):</div>
<div class="line"><span class="lineno">  970</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    ravel_multi_index(multi_index, dims, mode=&#39;raise&#39;, order=&#39;C&#39;)</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    Converts a tuple of index arrays into an array of flat</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">    indices, applying boundary modes to the multi-index.</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    multi_index : tuple of array_like</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">        A tuple of integer arrays, one array for each dimension.</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    dims : tuple of ints</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">        The shape of array into which the indices from ``multi_index`` apply.</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">        Specifies how out-of-bounds indices are handled.  Can specify</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">        either one mode or a tuple of modes, one mode per index.</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">        * &#39;raise&#39; -- raise an error (default)</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">        * &#39;wrap&#39; -- wrap around</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">        * &#39;clip&#39; -- clip to the range</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">        In &#39;clip&#39; mode, a negative index which would normally</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">        wrap will clip to 0 instead.</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">        Determines whether the multi-index should be viewed as</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">        indexing in row-major (C-style) or column-major</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">        (Fortran-style) order.</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    raveled_indices : ndarray</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        An array of indices into the flattened version of an array</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">        of dimensions ``dims``.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    unravel_index</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    &gt;&gt;&gt; arr = np.array([[3,6,6],[4,5,1]])</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel_multi_index(arr, (7,6))</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    array([22, 41, 37])</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel_multi_index(arr, (7,6), order=&#39;F&#39;)</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    array([31, 41, 13])</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel_multi_index(arr, (4,6), mode=&#39;clip&#39;)</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    array([22, 23, 19])</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel_multi_index(arr, (4,4), mode=(&#39;clip&#39;,&#39;wrap&#39;))</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    array([12, 13, 13])</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel_multi_index((3,1,4,1), (6,7,8,9))</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    1621</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1026</span>    <span class="keywordflow">return</span> multi_index</div>
<div class="line"><span class="lineno"> 1027</span> </div>
<div class="line"><span class="lineno"> 1028</span> </div>
<div class="line"><span class="lineno"> 1029</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.unravel_index)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a631dd443594fa259a859838d2f68c7ec" name="a631dd443594fa259a859838d2f68c7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631dd443594fa259a859838d2f68c7ec">&#9670;&#160;</a></span>result_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.result_type </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays_and_dtypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">result_type(*arrays_and_dtypes)

Returns the type that results from applying the NumPy
type promotion rules to the arguments.

Type promotion in NumPy works similarly to the rules in languages
like C++, with some slight differences.  When both scalars and
arrays are used, the array's type takes precedence and the actual value
of the scalar is taken into account.

For example, calculating 3*a, where a is an array of 32-bit floats,
intuitively should result in a 32-bit float output.  If the 3 is a
32-bit integer, the NumPy rules indicate it can't convert losslessly
into a 32-bit float, so a 64-bit float should be the result type.
By examining the value of the constant, '3', we see that it fits in
an 8-bit integer, which can be cast losslessly into the 32-bit float.

Parameters
----------
arrays_and_dtypes : list of arrays and dtypes
    The operands of some operation whose result type is needed.

Returns
-------
out : dtype
    The result type.

See also
--------
dtype, promote_types, min_scalar_type, can_cast

Notes
-----
.. versionadded:: 1.6.0

The specific algorithm used is as follows.

Categories are determined by first checking which of boolean,
integer (int/uint), or floating point (float/complex) the maximum
kind of all the arrays and the scalars are.

If there are only scalars or the maximum category of the scalars
is higher than the maximum category of the arrays,
the data types are combined with :func:`promote_types`
to produce the return value.

Otherwise, `min_scalar_type` is called on each array, and
the resulting data types are all combined with :func:`promote_types`
to produce the return value.

The set of int values is not a subset of the uint values for types
with the same number of bits, something not reflected in
:func:`min_scalar_type`, but handled as a special case in `result_type`.

Examples
--------
&gt;&gt;&gt; np.result_type(3, np.arange(7, dtype='i1'))
dtype('int8')

&gt;&gt;&gt; np.result_type('i4', 'c8')
dtype('complex128')

&gt;&gt;&gt; np.result_type(3.0, -2)
dtype('float64')</pre> <div class="fragment"><div class="line"><span class="lineno">  669</span><span class="keyword">def </span>result_type(*arrays_and_dtypes):</div>
<div class="line"><span class="lineno">  670</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    result_type(*arrays_and_dtypes)</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    Returns the type that results from applying the NumPy</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    type promotion rules to the arguments.</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    Type promotion in NumPy works similarly to the rules in languages</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    like C++, with some slight differences.  When both scalars and</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    arrays are used, the array&#39;s type takes precedence and the actual value</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    of the scalar is taken into account.</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    For example, calculating 3*a, where a is an array of 32-bit floats,</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    intuitively should result in a 32-bit float output.  If the 3 is a</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    32-bit integer, the NumPy rules indicate it can&#39;t convert losslessly</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    into a 32-bit float, so a 64-bit float should be the result type.</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    By examining the value of the constant, &#39;3&#39;, we see that it fits in</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    an 8-bit integer, which can be cast losslessly into the 32-bit float.</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    arrays_and_dtypes : list of arrays and dtypes</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        The operands of some operation whose result type is needed.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    out : dtype</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">        The result type.</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    dtype, promote_types, min_scalar_type, can_cast</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    The specific algorithm used is as follows.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    Categories are determined by first checking which of boolean,</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    integer (int/uint), or floating point (float/complex) the maximum</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    kind of all the arrays and the scalars are.</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    If there are only scalars or the maximum category of the scalars</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    is higher than the maximum category of the arrays,</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    the data types are combined with :func:`promote_types`</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    to produce the return value.</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    Otherwise, `min_scalar_type` is called on each array, and</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    the resulting data types are all combined with :func:`promote_types`</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    to produce the return value.</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    The set of int values is not a subset of the uint values for types</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    with the same number of bits, something not reflected in</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    :func:`min_scalar_type`, but handled as a special case in `result_type`.</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    &gt;&gt;&gt; np.result_type(3, np.arange(7, dtype=&#39;i1&#39;))</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    dtype(&#39;int8&#39;)</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    &gt;&gt;&gt; np.result_type(&#39;i4&#39;, &#39;c8&#39;)</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    dtype(&#39;complex128&#39;)</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    &gt;&gt;&gt; np.result_type(3.0, -2)</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    dtype(&#39;float64&#39;)</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  737</span>    <span class="keywordflow">return</span> arrays_and_dtypes</div>
<div class="line"><span class="lineno">  738</span> </div>
<div class="line"><span class="lineno">  739</span> </div>
<div class="line"><span class="lineno">  740</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.dot)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c2f8c4e2c932442df0c92eedce29aac" name="a0c2f8c4e2c932442df0c92eedce29aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2f8c4e2c932442df0c92eedce29aac">&#9670;&#160;</a></span>shares_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.shares_memory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_work</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">shares_memory(a, b, /, max_work=None)

Determine if two arrays share memory.

.. warning::

   This function can be exponentially slow for some inputs, unless
   `max_work` is set to a finite number or ``MAY_SHARE_BOUNDS``.
   If in doubt, use `numpy.may_share_memory` instead.

Parameters
----------
a, b : ndarray
    Input arrays
max_work : int, optional
    Effort to spend on solving the overlap problem (maximum number
    of candidate solutions to consider). The following special
    values are recognized:

    max_work=MAY_SHARE_EXACT  (default)
        The problem is solved exactly. In this case, the function returns
        True only if there is an element shared between the arrays. Finding
        the exact solution may take extremely long in some cases.
    max_work=MAY_SHARE_BOUNDS
        Only the memory bounds of a and b are checked.

Raises
------
numpy.TooHardError
    Exceeded max_work.

Returns
-------
out : bool

See Also
--------
may_share_memory

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 4])
&gt;&gt;&gt; np.shares_memory(x, np.array([5, 6, 7]))
False
&gt;&gt;&gt; np.shares_memory(x[::2], x)
True
&gt;&gt;&gt; np.shares_memory(x[::2], x[1::2])
False

Checking whether two arrays share memory is NP-complete, and
runtime may increase exponentially in the number of
dimensions. Hence, `max_work` should generally be set to a finite
number, as it is possible to construct examples that take
extremely long to run:

&gt;&gt;&gt; from numpy.lib.stride_tricks import as_strided
&gt;&gt;&gt; x = np.zeros([192163377], dtype=np.int8)
&gt;&gt;&gt; x1 = as_strided(x, strides=(36674, 61119, 85569), shape=(1049, 1049, 1049))
&gt;&gt;&gt; x2 = as_strided(x[64023025:], strides=(12223, 12224, 1), shape=(1049, 1049, 1))
&gt;&gt;&gt; np.shares_memory(x1, x2, max_work=1000)
Traceback (most recent call last):
...
numpy.TooHardError: Exceeded max_work

Running ``np.shares_memory(x1, x2)`` without `max_work` set takes
around 1 minute for this case. It is possible to find problems
that take still significantly longer.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1318</span><span class="keyword">def </span>shares_memory(a, b, max_work=None):</div>
<div class="line"><span class="lineno"> 1319</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    shares_memory(a, b, /, max_work=None)</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    Determine if two arrays share memory.</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    .. warning::</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">       This function can be exponentially slow for some inputs, unless</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">       `max_work` is set to a finite number or ``MAY_SHARE_BOUNDS``.</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">       If in doubt, use `numpy.may_share_memory` instead.</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    a, b : ndarray</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">        Input arrays</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    max_work : int, optional</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">        Effort to spend on solving the overlap problem (maximum number</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">        of candidate solutions to consider). The following special</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">        values are recognized:</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">        max_work=MAY_SHARE_EXACT  (default)</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">            The problem is solved exactly. In this case, the function returns</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">            True only if there is an element shared between the arrays. Finding</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">            the exact solution may take extremely long in some cases.</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">        max_work=MAY_SHARE_BOUNDS</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">            Only the memory bounds of a and b are checked.</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    numpy.TooHardError</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">        Exceeded max_work.</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    out : bool</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    may_share_memory</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    &gt;&gt;&gt; np.shares_memory(x, np.array([5, 6, 7]))</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    &gt;&gt;&gt; np.shares_memory(x[::2], x)</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">    &gt;&gt;&gt; np.shares_memory(x[::2], x[1::2])</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    Checking whether two arrays share memory is NP-complete, and</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    runtime may increase exponentially in the number of</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    dimensions. Hence, `max_work` should generally be set to a finite</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    number, as it is possible to construct examples that take</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    extremely long to run:</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib.stride_tricks import as_strided</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    &gt;&gt;&gt; x = np.zeros([192163377], dtype=np.int8)</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">    &gt;&gt;&gt; x1 = as_strided(x, strides=(36674, 61119, 85569), shape=(1049, 1049, 1049))</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">    &gt;&gt;&gt; x2 = as_strided(x[64023025:], strides=(12223, 12224, 1), shape=(1049, 1049, 1))</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    &gt;&gt;&gt; np.shares_memory(x1, x2, max_work=1000)</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    numpy.TooHardError: Exceeded max_work</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">    Running ``np.shares_memory(x1, x2)`` without `max_work` set takes</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    around 1 minute for this case. It is possible to find problems</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    that take still significantly longer.</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1389</span>    <span class="keywordflow">return</span> (a, b)</div>
<div class="line"><span class="lineno"> 1390</span> </div>
<div class="line"><span class="lineno"> 1391</span> </div>
<div class="line"><span class="lineno"> 1392</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.may_share_memory)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab260a98a2750798027f651b626b8403f" name="ab260a98a2750798027f651b626b8403f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab260a98a2750798027f651b626b8403f">&#9670;&#160;</a></span>unpackbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.unpackbits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bitorder</em> = <code>'big'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">unpackbits(a, /, axis=None, count=None, bitorder='big')

Unpacks elements of a uint8 array into a binary-valued output array.

Each element of `a` represents a bit-field that should be unpacked
into a binary-valued output array. The shape of the output array is
either 1-D (if `axis` is ``None``) or the same shape as the input
array with unpacking done along the axis specified.

Parameters
----------
a : ndarray, uint8 type
   Input array.
axis : int, optional
    The dimension over which bit-unpacking is done.
    ``None`` implies unpacking the flattened array.
count : int or None, optional
    The number of elements to unpack along `axis`, provided as a way
    of undoing the effect of packing a size that is not a multiple
    of eight. A non-negative number means to only unpack `count`
    bits. A negative number means to trim off that many bits from
    the end. ``None`` means to unpack the entire array (the
    default). Counts larger than the available number of bits will
    add zero padding to the output. Negative counts must not
    exceed the available number of bits.

    .. versionadded:: 1.17.0

bitorder : {'big', 'little'}, optional
    The order of the returned bits. 'big' will mimic bin(val),
    ``3 = 0b00000011 =&gt; [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse
    the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.
    Defaults to 'big'.

    .. versionadded:: 1.17.0

Returns
-------
unpacked : ndarray, uint8 type
   The elements are binary-valued (0 or 1).

See Also
--------
packbits : Packs the elements of a binary-valued array into bits in
           a uint8 array.

Examples
--------
&gt;&gt;&gt; a = np.array([[2], [7], [23]], dtype=np.uint8)
&gt;&gt;&gt; a
array([[ 2],
       [ 7],
       [23]], dtype=uint8)
&gt;&gt;&gt; b = np.unpackbits(a, axis=1)
&gt;&gt;&gt; b
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
&gt;&gt;&gt; c = np.unpackbits(a, axis=1, count=-3)
&gt;&gt;&gt; c
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0]], dtype=uint8)

&gt;&gt;&gt; p = np.packbits(b, axis=0)
&gt;&gt;&gt; np.unpackbits(p, axis=0)
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1234</span><span class="keyword">def </span>unpackbits(a, axis=None, count=None, bitorder=&#39;big&#39;):</div>
<div class="line"><span class="lineno"> 1235</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    unpackbits(a, /, axis=None, count=None, bitorder=&#39;big&#39;)</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    Unpacks elements of a uint8 array into a binary-valued output array.</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    Each element of `a` represents a bit-field that should be unpacked</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    into a binary-valued output array. The shape of the output array is</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">    either 1-D (if `axis` is ``None``) or the same shape as the input</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">    array with unpacking done along the axis specified.</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    a : ndarray, uint8 type</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">       Input array.</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">        The dimension over which bit-unpacking is done.</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">        ``None`` implies unpacking the flattened array.</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    count : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">        The number of elements to unpack along `axis`, provided as a way</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">        of undoing the effect of packing a size that is not a multiple</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">        of eight. A non-negative number means to only unpack `count`</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">        bits. A negative number means to trim off that many bits from</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">        the end. ``None`` means to unpack the entire array (the</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">        default). Counts larger than the available number of bits will</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">        add zero padding to the output. Negative counts must not</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">        exceed the available number of bits.</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    bitorder : {&#39;big&#39;, &#39;little&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">        The order of the returned bits. &#39;big&#39; will mimic bin(val),</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        ``3 = 0b00000011 =&gt; [0, 0, 0, 0, 0, 0, 1, 1]``, &#39;little&#39; will reverse</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        Defaults to &#39;big&#39;.</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    unpacked : ndarray, uint8 type</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">       The elements are binary-valued (0 or 1).</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    packbits : Packs the elements of a binary-valued array into bits in</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">               a uint8 array.</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[2], [7], [23]], dtype=np.uint8)</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">    array([[ 2],</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">           [ 7],</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">           [23]], dtype=uint8)</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    &gt;&gt;&gt; b = np.unpackbits(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    array([[0, 0, 0, 0, 0, 0, 1, 0],</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">           [0, 0, 0, 0, 0, 1, 1, 1],</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    &gt;&gt;&gt; c = np.unpackbits(a, axis=1, count=-3)</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    &gt;&gt;&gt; c</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    array([[0, 0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">           [0, 0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">           [0, 0, 0, 1, 0]], dtype=uint8)</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    &gt;&gt;&gt; p = np.packbits(b, axis=0)</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    &gt;&gt;&gt; np.unpackbits(p, axis=0)</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    array([[0, 0, 0, 0, 0, 0, 1, 0],</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">           [0, 0, 0, 0, 0, 1, 1, 1],</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">           [0, 0, 0, 1, 0, 1, 1, 1],</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">           [0, 0, 0, 0, 0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">           [0, 0, 0, 0, 0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">           [0, 0, 0, 0, 0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">           [0, 0, 0, 0, 0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">           [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    &gt;&gt;&gt; np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1314</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1315</span> </div>
<div class="line"><span class="lineno"> 1316</span> </div>
<div class="line"><span class="lineno"> 1317</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.shares_memory)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a05fb5a81e759751a4846cfdb2a7c0661" name="a05fb5a81e759751a4846cfdb2a7c0661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fb5a81e759751a4846cfdb2a7c0661">&#9670;&#160;</a></span>unravel_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.unravel_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">unravel_index(indices, shape, order='C')

Converts a flat index or array of flat indices into a tuple
of coordinate arrays.

Parameters
----------
indices : array_like
    An integer array whose elements are indices into the flattened
    version of an array of dimensions ``shape``. Before version 1.6.0,
    this function accepted just one index value.
shape : tuple of ints
    The shape of the array to use for unraveling ``indices``.

    .. versionchanged:: 1.16.0
        Renamed from ``dims`` to ``shape``.

order : {'C', 'F'}, optional
    Determines whether the indices should be viewed as indexing in
    row-major (C-style) or column-major (Fortran-style) order.

    .. versionadded:: 1.6.0

Returns
-------
unraveled_coords : tuple of ndarray
    Each array in the tuple has the same shape as the ``indices``
    array.

See Also
--------
ravel_multi_index

Examples
--------
&gt;&gt;&gt; np.unravel_index([22, 41, 37], (7,6))
(array([3, 6, 6]), array([4, 5, 1]))
&gt;&gt;&gt; np.unravel_index([31, 41, 13], (7,6), order='F')
(array([3, 6, 6]), array([4, 5, 1]))

&gt;&gt;&gt; np.unravel_index(1621, (6,7,8,9))
(3, 1, 4, 1)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1030</span><span class="keyword">def </span>unravel_index(indices, shape=None, order=None):</div>
<div class="line"><span class="lineno"> 1031</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    unravel_index(indices, shape, order=&#39;C&#39;)</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    Converts a flat index or array of flat indices into a tuple</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    of coordinate arrays.</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    indices : array_like</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">        An integer array whose elements are indices into the flattened</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">        version of an array of dimensions ``shape``. Before version 1.6.0,</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        this function accepted just one index value.</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    shape : tuple of ints</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">        The shape of the array to use for unraveling ``indices``.</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        .. versionchanged:: 1.16.0</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">            Renamed from ``dims`` to ``shape``.</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">        Determines whether the indices should be viewed as indexing in</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">        row-major (C-style) or column-major (Fortran-style) order.</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    unraveled_coords : tuple of ndarray</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">        Each array in the tuple has the same shape as the ``indices``</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">        array.</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">    ravel_multi_index</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">    &gt;&gt;&gt; np.unravel_index([22, 41, 37], (7,6))</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    (array([3, 6, 6]), array([4, 5, 1]))</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    &gt;&gt;&gt; np.unravel_index([31, 41, 13], (7,6), order=&#39;F&#39;)</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    (array([3, 6, 6]), array([4, 5, 1]))</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    &gt;&gt;&gt; np.unravel_index(1621, (6,7,8,9))</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    (3, 1, 4, 1)</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1076</span>    <span class="keywordflow">return</span> (indices,)</div>
<div class="line"><span class="lineno"> 1077</span> </div>
<div class="line"><span class="lineno"> 1078</span> </div>
<div class="line"><span class="lineno"> 1079</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.copyto)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="addb4f2892682f3716f61b5eaf5a35b4a" name="addb4f2892682f3716f61b5eaf5a35b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb4f2892682f3716f61b5eaf5a35b4a">&#9670;&#160;</a></span>vdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.vdot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">vdot(a, b, /)

Return the dot product of two vectors.

The vdot(`a`, `b`) function handles complex numbers differently than
dot(`a`, `b`).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.

Note that `vdot` handles multidimensional arrays differently than `dot`:
it does *not* perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.

Parameters
----------
a : array_like
    If `a` is complex the complex conjugate is taken before calculation
    of the dot product.
b : array_like
    Second argument to the dot product.

Returns
-------
output : ndarray
    Dot product of `a` and `b`.  Can be an int, float, or
    complex depending on the types of `a` and `b`.

See Also
--------
dot : Return the dot product without using the complex conjugate of the
      first argument.

Examples
--------
&gt;&gt;&gt; a = np.array([1+2j,3+4j])
&gt;&gt;&gt; b = np.array([5+6j,7+8j])
&gt;&gt;&gt; np.vdot(a, b)
(70-8j)
&gt;&gt;&gt; np.vdot(b, a)
(70+8j)

Note that higher-dimensional arrays are flattened!

&gt;&gt;&gt; a = np.array([[1, 4], [5, 6]])
&gt;&gt;&gt; b = np.array([[4, 1], [2, 2]])
&gt;&gt;&gt; np.vdot(a, b)
30
&gt;&gt;&gt; np.vdot(b, a)
30
&gt;&gt;&gt; 1*4 + 4*1 + 5*2 + 6*2
30</pre> <div class="fragment"><div class="line"><span class="lineno">  834</span><span class="keyword">def </span>vdot(a, b):</div>
<div class="line"><span class="lineno">  835</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    vdot(a, b, /)</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    Return the dot product of two vectors.</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    The vdot(`a`, `b`) function handles complex numbers differently than</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    dot(`a`, `b`).  If the first argument is complex the complex conjugate</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    of the first argument is used for the calculation of the dot product.</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Note that `vdot` handles multidimensional arrays differently than `dot`:</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    it does *not* perform a matrix product, but flattens input arguments</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    to 1-D vectors first. Consequently, it should only be used for vectors.</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">        If `a` is complex the complex conjugate is taken before calculation</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">        of the dot product.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">        Second argument to the dot product.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">        Dot product of `a` and `b`.  Can be an int, float, or</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">        complex depending on the types of `a` and `b`.</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    dot : Return the dot product without using the complex conjugate of the</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">          first argument.</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1+2j,3+4j])</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([5+6j,7+8j])</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    &gt;&gt;&gt; np.vdot(a, b)</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    (70-8j)</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    &gt;&gt;&gt; np.vdot(b, a)</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    (70+8j)</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    Note that higher-dimensional arrays are flattened!</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 4], [5, 6]])</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[4, 1], [2, 2]])</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    &gt;&gt;&gt; np.vdot(a, b)</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    30</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    &gt;&gt;&gt; np.vdot(b, a)</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    30</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    &gt;&gt;&gt; 1*4 + 4*1 + 5*2 + 6*2</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    30</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  888</span>    <span class="keywordflow">return</span> (a, b)</div>
<div class="line"><span class="lineno">  889</span> </div>
<div class="line"><span class="lineno">  890</span> </div>
<div class="line"><span class="lineno">  891</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.bincount)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aafec298d2664515002736e4905e6719b" name="aafec298d2664515002736e4905e6719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafec298d2664515002736e4905e6719b">&#9670;&#160;</a></span>where()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.where </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">where(condition, [x, y], /)

Return elements chosen from `x` or `y` depending on `condition`.

.. note::
    When only `condition` is provided, this function is a shorthand for
    ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be
    preferred, as it behaves correctly for subclasses. The rest of this
    documentation covers only the case where all three arguments are
    provided.

Parameters
----------
condition : array_like, bool
    Where True, yield `x`, otherwise yield `y`.
x, y : array_like
    Values from which to choose. `x`, `y` and `condition` need to be
    broadcastable to some shape.

Returns
-------
out : ndarray
    An array with elements from `x` where `condition` is True, and elements
    from `y` elsewhere.

See Also
--------
choose
nonzero : The function that is called when x and y are omitted

Notes
-----
If all the arrays are 1-D, `where` is equivalent to::

    [xv if c else yv
     for c, xv, yv in zip(condition, x, y)]

Examples
--------
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.where(a &lt; 5, a, 10*a)
array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])

This can be used on multidimensional arrays too:

&gt;&gt;&gt; np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
       [3, 4]])

The shapes of x, y, and the condition are broadcast together:

&gt;&gt;&gt; x, y = np.ogrid[:3, :4]
&gt;&gt;&gt; np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast
array([[10,  0,  0,  0],
       [10, 11,  1,  1],
       [10, 11, 12,  2]])

&gt;&gt;&gt; a = np.array([[0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6]])
&gt;&gt;&gt; np.where(a &lt; 4, a, -1)  # -1 is broadcast
array([[ 0,  1,  2],
       [ 0,  2, -1],
       [ 0,  3, -1]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  346</span><span class="keyword">def </span>where(condition, x=None, y=None):</div>
<div class="line"><span class="lineno">  347</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    where(condition, [x, y], /)</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    Return elements chosen from `x` or `y` depending on `condition`.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    .. note::</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">        When only `condition` is provided, this function is a shorthand for</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">        ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        preferred, as it behaves correctly for subclasses. The rest of this</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        documentation covers only the case where all three arguments are</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        provided.</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    condition : array_like, bool</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">        Where True, yield `x`, otherwise yield `y`.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    x, y : array_like</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">        Values from which to choose. `x`, `y` and `condition` need to be</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">        broadcastable to some shape.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">        An array with elements from `x` where `condition` is True, and elements</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">        from `y` elsewhere.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    choose</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    nonzero : The function that is called when x and y are omitted</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    If all the arrays are 1-D, `where` is equivalent to::</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">        [xv if c else yv</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">         for c, xv, yv in zip(condition, x, y)]</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(10)</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    &gt;&gt;&gt; np.where(a &lt; 5, a, 10*a)</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    This can be used on multidimensional arrays too:</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    &gt;&gt;&gt; np.where([[True, False], [True, True]],</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    ...          [[1, 2], [3, 4]],</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    ...          [[9, 8], [7, 6]])</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    array([[1, 8],</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">           [3, 4]])</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    The shapes of x, y, and the condition are broadcast together:</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    &gt;&gt;&gt; x, y = np.ogrid[:3, :4]</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    &gt;&gt;&gt; np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    array([[10,  0,  0,  0],</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">           [10, 11,  1,  1],</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">           [10, 11, 12,  2]])</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    ...               [0, 2, 4],</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    ...               [0, 3, 6]])</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    &gt;&gt;&gt; np.where(a &lt; 4, a, -1)  # -1 is broadcast</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    array([[ 0,  1,  2],</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">           [ 0,  2, -1],</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">           [ 0,  3, -1]])</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">return</span> (condition, x, y)</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span> </div>
<div class="line"><span class="lineno">  420</span><span class="preprocessor">@array_function_from_c_func_and_dispatcher(_multiarray_umath.lexsort)</span></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8f0985446cd1812ab7345b24aaf37a2b" name="a8f0985446cd1812ab7345b24aaf37a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0985446cd1812ab7345b24aaf37a2b">&#9670;&#160;</a></span>array_function_from_c_func_and_dispatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.array_function_from_c_func_and_dispatcher</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_from_dispatcher,</div>
<div class="line"><span class="lineno">    3</span>    module=<span class="stringliteral">&#39;numpy&#39;</span>, docs_from_dispatcher=<span class="keyword">True</span>, verify=<span class="keyword">False</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
