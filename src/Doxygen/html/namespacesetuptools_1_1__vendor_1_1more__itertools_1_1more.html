<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: setuptools._vendor.more_itertools.more Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesetuptools.html">setuptools</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor.html">_vendor</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools.html">more_itertools</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html">more</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">setuptools._vendor.more_itertools.more Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1_abort_thread.html">AbortThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1bucket.html">bucket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1callback__iter.html">callback_iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1countable.html">countable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1islice__extended.html">islice_extended</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1numeric__range.html">numeric_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1peekable.html">peekable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1run__length.html">run_length</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1seekable.html">seekable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1_sequence_view.html">SequenceView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1time__limited.html">time_limited</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1_unequal_iterables_error.html">UnequalIterablesError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abffb53abf1266b52e612759e97a93b4d" id="r_abffb53abf1266b52e612759e97a93b4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#abffb53abf1266b52e612759e97a93b4d">chunked</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, strict=False)</td></tr>
<tr class="separator:abffb53abf1266b52e612759e97a93b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d65f68012304f562994508d19d68b4b" id="r_a3d65f68012304f562994508d19d68b4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a3d65f68012304f562994508d19d68b4b">first</a> (iterable, default=<a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a67c5ce81dc3269a7393daed34ec304f1">_marker</a>)</td></tr>
<tr class="separator:a3d65f68012304f562994508d19d68b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8451a225701bd3bc60ca00f234062208" id="r_a8451a225701bd3bc60ca00f234062208"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a8451a225701bd3bc60ca00f234062208">last</a> (iterable, default=<a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a67c5ce81dc3269a7393daed34ec304f1">_marker</a>)</td></tr>
<tr class="separator:a8451a225701bd3bc60ca00f234062208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1c123134b401ca372bc206b6fae7ba" id="r_a7b1c123134b401ca372bc206b6fae7ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a7b1c123134b401ca372bc206b6fae7ba">nth_or_last</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, default=<a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a67c5ce81dc3269a7393daed34ec304f1">_marker</a>)</td></tr>
<tr class="separator:a7b1c123134b401ca372bc206b6fae7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691dc99d522ad3defe468a1ee9bd532d" id="r_a691dc99d522ad3defe468a1ee9bd532d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a691dc99d522ad3defe468a1ee9bd532d">collate</a> (*iterables, **kwargs)</td></tr>
<tr class="separator:a691dc99d522ad3defe468a1ee9bd532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e66c12cc86c45187adb224fee478b" id="r_a227e66c12cc86c45187adb224fee478b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a227e66c12cc86c45187adb224fee478b">consumer</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>)</td></tr>
<tr class="separator:a227e66c12cc86c45187adb224fee478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c69fff987516a452aa90c06d24885e" id="r_a64c69fff987516a452aa90c06d24885e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a64c69fff987516a452aa90c06d24885e">ilen</a> (iterable)</td></tr>
<tr class="separator:a64c69fff987516a452aa90c06d24885e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17348f255369895951eeb91ce27eab84" id="r_a17348f255369895951eeb91ce27eab84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a17348f255369895951eeb91ce27eab84">iterate</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, start)</td></tr>
<tr class="separator:a17348f255369895951eeb91ce27eab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619447baa790cfa94d6bfc301c96a573" id="r_a619447baa790cfa94d6bfc301c96a573"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a619447baa790cfa94d6bfc301c96a573">with_iter</a> (context_manager)</td></tr>
<tr class="separator:a619447baa790cfa94d6bfc301c96a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c28ebee9cc10435df318256129637c0" id="r_a8c28ebee9cc10435df318256129637c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a8c28ebee9cc10435df318256129637c0">one</a> (iterable, too_short=None, too_long=None)</td></tr>
<tr class="separator:a8c28ebee9cc10435df318256129637c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8491276c50929899fe32cda6fd2d01e" id="r_ab8491276c50929899fe32cda6fd2d01e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ab8491276c50929899fe32cda6fd2d01e">distinct_permutations</a> (iterable, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>=None)</td></tr>
<tr class="separator:ab8491276c50929899fe32cda6fd2d01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fc6f0275c765800910360d1f96dc0" id="r_a511fc6f0275c765800910360d1f96dc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a511fc6f0275c765800910360d1f96dc0">intersperse</a> (e, iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=1)</td></tr>
<tr class="separator:a511fc6f0275c765800910360d1f96dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bc505640cbe98f92a1703e472e1d00" id="r_ad5bc505640cbe98f92a1703e472e1d00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad5bc505640cbe98f92a1703e472e1d00">unique_to_each</a> (*iterables)</td></tr>
<tr class="separator:ad5bc505640cbe98f92a1703e472e1d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a25a63106c08986d199ddbd78d46277" id="r_a6a25a63106c08986d199ddbd78d46277"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a6a25a63106c08986d199ddbd78d46277">windowed</a> (seq, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, fillvalue=None, step=1)</td></tr>
<tr class="separator:a6a25a63106c08986d199ddbd78d46277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdc9a02ebf3b5ed801ceee08af6afb5" id="r_a0cdc9a02ebf3b5ed801ceee08af6afb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0cdc9a02ebf3b5ed801ceee08af6afb5">substrings</a> (iterable)</td></tr>
<tr class="separator:a0cdc9a02ebf3b5ed801ceee08af6afb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac255ef443ff15888f55c49aa1f070ff4" id="r_ac255ef443ff15888f55c49aa1f070ff4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ac255ef443ff15888f55c49aa1f070ff4">substrings_indexes</a> (seq, reverse=False)</td></tr>
<tr class="separator:ac255ef443ff15888f55c49aa1f070ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad404f78ea35afd075654a37ad98a9426" id="r_ad404f78ea35afd075654a37ad98a9426"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad404f78ea35afd075654a37ad98a9426">spy</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=1)</td></tr>
<tr class="separator:ad404f78ea35afd075654a37ad98a9426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a550537ce14e8b31de79d09cbf72ab2" id="r_a6a550537ce14e8b31de79d09cbf72ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a6a550537ce14e8b31de79d09cbf72ab2">interleave</a> (*iterables)</td></tr>
<tr class="separator:a6a550537ce14e8b31de79d09cbf72ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1803700181e28e4201ab209a3da924d" id="r_aa1803700181e28e4201ab209a3da924d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aa1803700181e28e4201ab209a3da924d">interleave_longest</a> (*iterables)</td></tr>
<tr class="separator:aa1803700181e28e4201ab209a3da924d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41738788dce77084e613575a9391382" id="r_ad41738788dce77084e613575a9391382"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad41738788dce77084e613575a9391382">collapse</a> (iterable, base_type=None, levels=None)</td></tr>
<tr class="separator:ad41738788dce77084e613575a9391382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fd87a60e18304da46bc5b9b42b14b1" id="r_aa9fd87a60e18304da46bc5b9b42b14b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aa9fd87a60e18304da46bc5b9b42b14b1">side_effect</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, iterable, chunk_size=None, before=None, after=None)</td></tr>
<tr class="separator:aa9fd87a60e18304da46bc5b9b42b14b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d69cf216f30f8434561bc98a0dd779" id="r_a56d69cf216f30f8434561bc98a0dd779"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a56d69cf216f30f8434561bc98a0dd779">sliced</a> (seq, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, strict=False)</td></tr>
<tr class="separator:a56d69cf216f30f8434561bc98a0dd779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c21ccdd1a1500b43fd08fe03f0f3c2c" id="r_a0c21ccdd1a1500b43fd08fe03f0f3c2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0c21ccdd1a1500b43fd08fe03f0f3c2c">split_at</a> (iterable, pred, maxsplit=-1, keep_separator=False)</td></tr>
<tr class="separator:a0c21ccdd1a1500b43fd08fe03f0f3c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aee350818833ba18a93b952983d841" id="r_ad7aee350818833ba18a93b952983d841"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad7aee350818833ba18a93b952983d841">split_before</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="separator:ad7aee350818833ba18a93b952983d841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec868cc95b2ee87797046cbf8083e47d" id="r_aec868cc95b2ee87797046cbf8083e47d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aec868cc95b2ee87797046cbf8083e47d">split_after</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="separator:aec868cc95b2ee87797046cbf8083e47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524b6352594c860dfa3b742832d114aa" id="r_a524b6352594c860dfa3b742832d114aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a524b6352594c860dfa3b742832d114aa">split_when</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="separator:a524b6352594c860dfa3b742832d114aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2414703c881898f60f20d405da23acc0" id="r_a2414703c881898f60f20d405da23acc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a2414703c881898f60f20d405da23acc0">split_into</a> (iterable, sizes)</td></tr>
<tr class="separator:a2414703c881898f60f20d405da23acc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50adbaec19127d43efcec83b3b67d2e1" id="r_a50adbaec19127d43efcec83b3b67d2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a50adbaec19127d43efcec83b3b67d2e1">padded</a> (iterable, fillvalue=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, next_multiple=False)</td></tr>
<tr class="separator:a50adbaec19127d43efcec83b3b67d2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5425f753dfd8559de42b9fc12c28fc2" id="r_aa5425f753dfd8559de42b9fc12c28fc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aa5425f753dfd8559de42b9fc12c28fc2">repeat_last</a> (iterable, default=None)</td></tr>
<tr class="separator:aa5425f753dfd8559de42b9fc12c28fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c0a201e6bbd3b1a336c4b775963c6b" id="r_a83c0a201e6bbd3b1a336c4b775963c6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a83c0a201e6bbd3b1a336c4b775963c6b">distribute</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, iterable)</td></tr>
<tr class="separator:a83c0a201e6bbd3b1a336c4b775963c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a5061bfeab377fdcb3819d122ea2ae" id="r_aa6a5061bfeab377fdcb3819d122ea2ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aa6a5061bfeab377fdcb3819d122ea2ae">stagger</a> (iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None)</td></tr>
<tr class="separator:aa6a5061bfeab377fdcb3819d122ea2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e20e24eacb1c2dfe200269764b32ff" id="r_a42e20e24eacb1c2dfe200269764b32ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a42e20e24eacb1c2dfe200269764b32ff">_zip_equal_generator</a> (iterables)</td></tr>
<tr class="separator:a42e20e24eacb1c2dfe200269764b32ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310cdb228065a896661fdb3af5198990" id="r_a310cdb228065a896661fdb3af5198990"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a310cdb228065a896661fdb3af5198990">zip_equal</a> (*iterables)</td></tr>
<tr class="separator:a310cdb228065a896661fdb3af5198990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2e4bfc8d9d82c7daaa81730f316ae4" id="r_a5b2e4bfc8d9d82c7daaa81730f316ae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a5b2e4bfc8d9d82c7daaa81730f316ae4">zip_offset</a> (*iterables, offsets, longest=False, fillvalue=None)</td></tr>
<tr class="separator:a5b2e4bfc8d9d82c7daaa81730f316ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9b12c4b7074c419c909ee5b3b0b8cf" id="r_aea9b12c4b7074c419c909ee5b3b0b8cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aea9b12c4b7074c419c909ee5b3b0b8cf">sort_together</a> (iterables, key_list=(0,), key=None, reverse=False)</td></tr>
<tr class="separator:aea9b12c4b7074c419c909ee5b3b0b8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eebc9faf562f56d169cb5aec787b6d" id="r_a32eebc9faf562f56d169cb5aec787b6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a32eebc9faf562f56d169cb5aec787b6d">unzip</a> (iterable)</td></tr>
<tr class="separator:a32eebc9faf562f56d169cb5aec787b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db1c5b2b6da960a1ab63de218124d0f" id="r_a4db1c5b2b6da960a1ab63de218124d0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a4db1c5b2b6da960a1ab63de218124d0f">divide</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, iterable)</td></tr>
<tr class="separator:a4db1c5b2b6da960a1ab63de218124d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747a961c026ef4e048dbad7872b7e9ba" id="r_a747a961c026ef4e048dbad7872b7e9ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a747a961c026ef4e048dbad7872b7e9ba">always_iterable</a> (obj, base_type=(str, bytes))</td></tr>
<tr class="separator:a747a961c026ef4e048dbad7872b7e9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835dca721e46dea810ffe00b70252e86" id="r_a835dca721e46dea810ffe00b70252e86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a835dca721e46dea810ffe00b70252e86">adjacent</a> (predicate, iterable, distance=1)</td></tr>
<tr class="separator:a835dca721e46dea810ffe00b70252e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26be38b59e90b14984ed58d3b3bbc82" id="r_ab26be38b59e90b14984ed58d3b3bbc82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ab26be38b59e90b14984ed58d3b3bbc82">groupby_transform</a> (iterable, keyfunc=None, valuefunc=None, reducefunc=None)</td></tr>
<tr class="separator:ab26be38b59e90b14984ed58d3b3bbc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad742cc24dfb3b49a4f07db2aa012b8" id="r_a3ad742cc24dfb3b49a4f07db2aa012b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a3ad742cc24dfb3b49a4f07db2aa012b8">count_cycle</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None)</td></tr>
<tr class="separator:a3ad742cc24dfb3b49a4f07db2aa012b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887baec1ac1113ad302338e44bef29e7" id="r_a887baec1ac1113ad302338e44bef29e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a887baec1ac1113ad302338e44bef29e7">mark_ends</a> (iterable)</td></tr>
<tr class="separator:a887baec1ac1113ad302338e44bef29e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e18ee5ccec970465321f705ee1e11b" id="r_a05e18ee5ccec970465321f705ee1e11b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a05e18ee5ccec970465321f705ee1e11b">locate</a> (iterable, pred=bool, window_size=None)</td></tr>
<tr class="separator:a05e18ee5ccec970465321f705ee1e11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0712cc8a0f49172287bf947e453677" id="r_a2b0712cc8a0f49172287bf947e453677"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a2b0712cc8a0f49172287bf947e453677">lstrip</a> (iterable, pred)</td></tr>
<tr class="separator:a2b0712cc8a0f49172287bf947e453677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafac6a26effb97d5579c5412d30bc77" id="r_abafac6a26effb97d5579c5412d30bc77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#abafac6a26effb97d5579c5412d30bc77">rstrip</a> (iterable, pred)</td></tr>
<tr class="separator:abafac6a26effb97d5579c5412d30bc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aacddd1fb6d2525e7ca741424fd0045" id="r_a4aacddd1fb6d2525e7ca741424fd0045"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a4aacddd1fb6d2525e7ca741424fd0045">strip</a> (iterable, pred)</td></tr>
<tr class="separator:a4aacddd1fb6d2525e7ca741424fd0045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95249a3c504f20ba7aa1a05dfcbf80b7" id="r_a95249a3c504f20ba7aa1a05dfcbf80b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a95249a3c504f20ba7aa1a05dfcbf80b7">_islice_helper</a> (it, s)</td></tr>
<tr class="separator:a95249a3c504f20ba7aa1a05dfcbf80b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed7891e30021a8924131411039ad76a" id="r_a4ed7891e30021a8924131411039ad76a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a4ed7891e30021a8924131411039ad76a">always_reversible</a> (iterable)</td></tr>
<tr class="separator:a4ed7891e30021a8924131411039ad76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42cfd133811f127a2c4321d8c63042b" id="r_ad42cfd133811f127a2c4321d8c63042b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad42cfd133811f127a2c4321d8c63042b">consecutive_groups</a> (iterable, ordering=<a class="el" href="__lapack__subroutines_8h.html#a76093d20ca2e1c5d5216168f26f73e19">lambda</a> x:x)</td></tr>
<tr class="separator:ad42cfd133811f127a2c4321d8c63042b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e95112d6bab64bd6e57ae7690be37f" id="r_aa1e95112d6bab64bd6e57ae7690be37f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aa1e95112d6bab64bd6e57ae7690be37f">difference</a> (iterable, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>=sub, *initial=None)</td></tr>
<tr class="separator:aa1e95112d6bab64bd6e57ae7690be37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9a2af8ed9c6a97fc0d47f59ab8dd52" id="r_a9d9a2af8ed9c6a97fc0d47f59ab8dd52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a9d9a2af8ed9c6a97fc0d47f59ab8dd52">exactly_n</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, predicate=bool)</td></tr>
<tr class="separator:a9d9a2af8ed9c6a97fc0d47f59ab8dd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed850f38028aaebb5989efe884862a" id="r_affed850f38028aaebb5989efe884862a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#affed850f38028aaebb5989efe884862a">circular_shifts</a> (iterable)</td></tr>
<tr class="separator:affed850f38028aaebb5989efe884862a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e8616c9a2d21c6b3b81e351225bf60" id="r_a21e8616c9a2d21c6b3b81e351225bf60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a21e8616c9a2d21c6b3b81e351225bf60">make_decorator</a> (wrapping_func, result_index=0)</td></tr>
<tr class="separator:a21e8616c9a2d21c6b3b81e351225bf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c533b865a3514e16c54991daba7af2" id="r_a45c533b865a3514e16c54991daba7af2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a45c533b865a3514e16c54991daba7af2">map_reduce</a> (iterable, keyfunc, valuefunc=None, reducefunc=None)</td></tr>
<tr class="separator:a45c533b865a3514e16c54991daba7af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f682ab11fa2bc3a54def3f13ae20d9" id="r_a31f682ab11fa2bc3a54def3f13ae20d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a31f682ab11fa2bc3a54def3f13ae20d9">rlocate</a> (iterable, pred=bool, window_size=None)</td></tr>
<tr class="separator:a31f682ab11fa2bc3a54def3f13ae20d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8daa550cec9c16c67c4500228d1e08d" id="r_ab8daa550cec9c16c67c4500228d1e08d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ab8daa550cec9c16c67c4500228d1e08d">replace</a> (iterable, pred, substitutes, count=None, window_size=1)</td></tr>
<tr class="separator:ab8daa550cec9c16c67c4500228d1e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac8728632c6d80de2b0e3f627b1b77" id="r_a50ac8728632c6d80de2b0e3f627b1b77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a50ac8728632c6d80de2b0e3f627b1b77">partitions</a> (iterable)</td></tr>
<tr class="separator:a50ac8728632c6d80de2b0e3f627b1b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aba9fcbb4adacab1fdac7c921e39b0" id="r_a09aba9fcbb4adacab1fdac7c921e39b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a09aba9fcbb4adacab1fdac7c921e39b0">set_partitions</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>=None)</td></tr>
<tr class="separator:a09aba9fcbb4adacab1fdac7c921e39b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f27ecbe9378a7e871e33d55a980ebc7" id="r_a6f27ecbe9378a7e871e33d55a980ebc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a6f27ecbe9378a7e871e33d55a980ebc7">only</a> (iterable, default=None, too_long=None)</td></tr>
<tr class="separator:a6f27ecbe9378a7e871e33d55a980ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c641087a4891d3ac5b40616a3394bd5" id="r_a9c641087a4891d3ac5b40616a3394bd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a9c641087a4891d3ac5b40616a3394bd5">ichunked</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a9c641087a4891d3ac5b40616a3394bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf4eef1c3957d30770055397f1b10ef" id="r_aecf4eef1c3957d30770055397f1b10ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aecf4eef1c3957d30770055397f1b10ef">distinct_combinations</a> (iterable, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>)</td></tr>
<tr class="separator:aecf4eef1c3957d30770055397f1b10ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf15114e78cfa3671c3635f0e07826" id="r_a75cf15114e78cfa3671c3635f0e07826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a75cf15114e78cfa3671c3635f0e07826">filter_except</a> (validator, iterable, *exceptions)</td></tr>
<tr class="separator:a75cf15114e78cfa3671c3635f0e07826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f31c6152daaffa29cd357b6080416f" id="r_af5f31c6152daaffa29cd357b6080416f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#af5f31c6152daaffa29cd357b6080416f">map_except</a> (function, iterable, *exceptions)</td></tr>
<tr class="separator:af5f31c6152daaffa29cd357b6080416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d30cb28efe1b2b0e586aee21b16368b" id="r_a0d30cb28efe1b2b0e586aee21b16368b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0d30cb28efe1b2b0e586aee21b16368b">_sample_unweighted</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:a0d30cb28efe1b2b0e586aee21b16368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec7ac4b35d3e11e81091ab5cd00017e" id="r_a4ec7ac4b35d3e11e81091ab5cd00017e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a4ec7ac4b35d3e11e81091ab5cd00017e">_sample_weighted</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, weights)</td></tr>
<tr class="separator:a4ec7ac4b35d3e11e81091ab5cd00017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405cfbac3f502521faf280895b1920a" id="r_a1405cfbac3f502521faf280895b1920a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a1405cfbac3f502521faf280895b1920a">sample</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, weights=None)</td></tr>
<tr class="separator:a1405cfbac3f502521faf280895b1920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cbbbf641f0a69938658857aacd4a4b" id="r_a81cbbbf641f0a69938658857aacd4a4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a81cbbbf641f0a69938658857aacd4a4b">is_sorted</a> (iterable, key=None, reverse=False)</td></tr>
<tr class="separator:a81cbbbf641f0a69938658857aacd4a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c0440945239e801c6cb8025ab068c9" id="r_a02c0440945239e801c6cb8025ab068c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a02c0440945239e801c6cb8025ab068c9">windowed_complete</a> (iterable, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a02c0440945239e801c6cb8025ab068c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b736b170fbf6c04c61095495941cc9" id="r_a85b736b170fbf6c04c61095495941cc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a85b736b170fbf6c04c61095495941cc9">all_unique</a> (iterable, key=None)</td></tr>
<tr class="separator:a85b736b170fbf6c04c61095495941cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3159489420e4a47a301c6d2d9c0529" id="r_a0b3159489420e4a47a301c6d2d9c0529"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0b3159489420e4a47a301c6d2d9c0529">nth_product</a> (index, *args)</td></tr>
<tr class="separator:a0b3159489420e4a47a301c6d2d9c0529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8fb234f6fe28459220bb2acf7e7024" id="r_a1e8fb234f6fe28459220bb2acf7e7024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a1e8fb234f6fe28459220bb2acf7e7024">nth_permutation</a> (iterable, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, index)</td></tr>
<tr class="separator:a1e8fb234f6fe28459220bb2acf7e7024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b402e9e076f6d6c1d7d13dccb5d992c" id="r_a0b402e9e076f6d6c1d7d13dccb5d992c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0b402e9e076f6d6c1d7d13dccb5d992c">value_chain</a> (*args)</td></tr>
<tr class="separator:a0b402e9e076f6d6c1d7d13dccb5d992c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04f1738abb04e3d9334e3daf689c4a5" id="r_ad04f1738abb04e3d9334e3daf689c4a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad04f1738abb04e3d9334e3daf689c4a5">product_index</a> (element, *args)</td></tr>
<tr class="separator:ad04f1738abb04e3d9334e3daf689c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d03eaa373fc38712ee738617d1f0e4" id="r_a60d03eaa373fc38712ee738617d1f0e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a60d03eaa373fc38712ee738617d1f0e4">combination_index</a> (element, iterable)</td></tr>
<tr class="separator:a60d03eaa373fc38712ee738617d1f0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a435858b2e240b461187e43423a959" id="r_aa8a435858b2e240b461187e43423a959"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aa8a435858b2e240b461187e43423a959">permutation_index</a> (element, iterable)</td></tr>
<tr class="separator:aa8a435858b2e240b461187e43423a959"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a67c5ce81dc3269a7393daed34ec304f1" id="r_a67c5ce81dc3269a7393daed34ec304f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a67c5ce81dc3269a7393daed34ec304f1">_marker</a> = object()</td></tr>
<tr class="separator:a67c5ce81dc3269a7393daed34ec304f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a95249a3c504f20ba7aa1a05dfcbf80b7" name="a95249a3c504f20ba7aa1a05dfcbf80b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95249a3c504f20ba7aa1a05dfcbf80b7">&#9670;&#160;</a></span>_islice_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._islice_helper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2314</span><span class="keyword">def </span>_islice_helper(it, s):</div>
<div class="line"><span class="lineno"> 2315</span>    start = s.start</div>
<div class="line"><span class="lineno"> 2316</span>    stop = s.stop</div>
<div class="line"><span class="lineno"> 2317</span>    <span class="keywordflow">if</span> s.step == 0:</div>
<div class="line"><span class="lineno"> 2318</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;step argument must be a non-zero integer or None.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2319</span>    step = s.step <span class="keywordflow">or</span> 1</div>
<div class="line"><span class="lineno"> 2320</span> </div>
<div class="line"><span class="lineno"> 2321</span>    <span class="keywordflow">if</span> step &gt; 0:</div>
<div class="line"><span class="lineno"> 2322</span>        start = 0 <span class="keywordflow">if</span> (start <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> start</div>
<div class="line"><span class="lineno"> 2323</span> </div>
<div class="line"><span class="lineno"> 2324</span>        <span class="keywordflow">if</span> start &lt; 0:</div>
<div class="line"><span class="lineno"> 2325</span>            <span class="comment"># Consume all but the last -start items</span></div>
<div class="line"><span class="lineno"> 2326</span>            cache = deque(enumerate(it, 1), maxlen=-start)</div>
<div class="line"><span class="lineno"> 2327</span>            len_iter = cache[-1][0] <span class="keywordflow">if</span> cache <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno"> 2328</span> </div>
<div class="line"><span class="lineno"> 2329</span>            <span class="comment"># Adjust start to be positive</span></div>
<div class="line"><span class="lineno"> 2330</span>            i = max(len_iter + start, 0)</div>
<div class="line"><span class="lineno"> 2331</span> </div>
<div class="line"><span class="lineno"> 2332</span>            <span class="comment"># Adjust stop to be positive</span></div>
<div class="line"><span class="lineno"> 2333</span>            <span class="keywordflow">if</span> stop <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2334</span>                j = len_iter</div>
<div class="line"><span class="lineno"> 2335</span>            <span class="keywordflow">elif</span> stop &gt;= 0:</div>
<div class="line"><span class="lineno"> 2336</span>                j = min(stop, len_iter)</div>
<div class="line"><span class="lineno"> 2337</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2338</span>                j = max(len_iter + stop, 0)</div>
<div class="line"><span class="lineno"> 2339</span> </div>
<div class="line"><span class="lineno"> 2340</span>            <span class="comment"># Slice the cache</span></div>
<div class="line"><span class="lineno"> 2341</span>            n = j - i</div>
<div class="line"><span class="lineno"> 2342</span>            <span class="keywordflow">if</span> n &lt;= 0:</div>
<div class="line"><span class="lineno"> 2343</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 2344</span> </div>
<div class="line"><span class="lineno"> 2345</span>            <span class="keywordflow">for</span> index, item <span class="keywordflow">in</span> islice(cache, 0, n, step):</div>
<div class="line"><span class="lineno"> 2346</span>                <span class="keywordflow">yield</span> item</div>
<div class="line"><span class="lineno"> 2347</span>        <span class="keywordflow">elif</span> (stop <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (stop &lt; 0):</div>
<div class="line"><span class="lineno"> 2348</span>            <span class="comment"># Advance to the start position</span></div>
<div class="line"><span class="lineno"> 2349</span>            next(islice(it, start, start), <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 2350</span> </div>
<div class="line"><span class="lineno"> 2351</span>            <span class="comment"># When stop is negative, we have to carry -stop items while</span></div>
<div class="line"><span class="lineno"> 2352</span>            <span class="comment"># iterating</span></div>
<div class="line"><span class="lineno"> 2353</span>            cache = deque(islice(it, -stop), maxlen=-stop)</div>
<div class="line"><span class="lineno"> 2354</span> </div>
<div class="line"><span class="lineno"> 2355</span>            <span class="keywordflow">for</span> index, item <span class="keywordflow">in</span> enumerate(it):</div>
<div class="line"><span class="lineno"> 2356</span>                cached_item = cache.popleft()</div>
<div class="line"><span class="lineno"> 2357</span>                <span class="keywordflow">if</span> index % step == 0:</div>
<div class="line"><span class="lineno"> 2358</span>                    <span class="keywordflow">yield</span> cached_item</div>
<div class="line"><span class="lineno"> 2359</span>                cache.append(item)</div>
<div class="line"><span class="lineno"> 2360</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2361</span>            <span class="comment"># When both start and stop are positive we have the normal case</span></div>
<div class="line"><span class="lineno"> 2362</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> islice(it, start, stop, step)</div>
<div class="line"><span class="lineno"> 2363</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2364</span>        start = -1 <span class="keywordflow">if</span> (start <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> start</div>
<div class="line"><span class="lineno"> 2365</span> </div>
<div class="line"><span class="lineno"> 2366</span>        <span class="keywordflow">if</span> (stop <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (stop &lt; 0):</div>
<div class="line"><span class="lineno"> 2367</span>            <span class="comment"># Consume all but the last items</span></div>
<div class="line"><span class="lineno"> 2368</span>            n = -stop - 1</div>
<div class="line"><span class="lineno"> 2369</span>            cache = deque(enumerate(it, 1), maxlen=n)</div>
<div class="line"><span class="lineno"> 2370</span>            len_iter = cache[-1][0] <span class="keywordflow">if</span> cache <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno"> 2371</span> </div>
<div class="line"><span class="lineno"> 2372</span>            <span class="comment"># If start and stop are both negative they are comparable and</span></div>
<div class="line"><span class="lineno"> 2373</span>            <span class="comment"># we can just slice. Otherwise we can adjust start to be negative</span></div>
<div class="line"><span class="lineno"> 2374</span>            <span class="comment"># and then slice.</span></div>
<div class="line"><span class="lineno"> 2375</span>            <span class="keywordflow">if</span> start &lt; 0:</div>
<div class="line"><span class="lineno"> 2376</span>                i, j = start, stop</div>
<div class="line"><span class="lineno"> 2377</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2378</span>                i, j = min(start - len_iter, -1), <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2379</span> </div>
<div class="line"><span class="lineno"> 2380</span>            <span class="keywordflow">for</span> index, item <span class="keywordflow">in</span> list(cache)[i:j:step]:</div>
<div class="line"><span class="lineno"> 2381</span>                <span class="keywordflow">yield</span> item</div>
<div class="line"><span class="lineno"> 2382</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2383</span>            <span class="comment"># Advance to the stop position</span></div>
<div class="line"><span class="lineno"> 2384</span>            <span class="keywordflow">if</span> stop <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2385</span>                m = stop + 1</div>
<div class="line"><span class="lineno"> 2386</span>                next(islice(it, m, m), <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 2387</span> </div>
<div class="line"><span class="lineno"> 2388</span>            <span class="comment"># stop is positive, so if start is negative they are not comparable</span></div>
<div class="line"><span class="lineno"> 2389</span>            <span class="comment"># and we need the rest of the items.</span></div>
<div class="line"><span class="lineno"> 2390</span>            <span class="keywordflow">if</span> start &lt; 0:</div>
<div class="line"><span class="lineno"> 2391</span>                i = start</div>
<div class="line"><span class="lineno"> 2392</span>                n = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2393</span>            <span class="comment"># stop is None and start is positive, so we just need items up to</span></div>
<div class="line"><span class="lineno"> 2394</span>            <span class="comment"># the start index.</span></div>
<div class="line"><span class="lineno"> 2395</span>            <span class="keywordflow">elif</span> stop <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2396</span>                i = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2397</span>                n = start + 1</div>
<div class="line"><span class="lineno"> 2398</span>            <span class="comment"># Both stop and start are positive, so they are comparable.</span></div>
<div class="line"><span class="lineno"> 2399</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2400</span>                i = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2401</span>                n = start - stop</div>
<div class="line"><span class="lineno"> 2402</span>                <span class="keywordflow">if</span> n &lt;= 0:</div>
<div class="line"><span class="lineno"> 2403</span>                    <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 2404</span> </div>
<div class="line"><span class="lineno"> 2405</span>            cache = list(islice(it, n))</div>
<div class="line"><span class="lineno"> 2406</span> </div>
<div class="line"><span class="lineno"> 2407</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> cache[i::step]</div>
<div class="line"><span class="lineno"> 2408</span> </div>
<div class="line"><span class="lineno"> 2409</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d30cb28efe1b2b0e586aee21b16368b" name="a0d30cb28efe1b2b0e586aee21b16368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d30cb28efe1b2b0e586aee21b16368b">&#9670;&#160;</a></span>_sample_unweighted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._sample_unweighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3280</span><span class="keyword">def </span>_sample_unweighted(iterable, k):</div>
<div class="line"><span class="lineno"> 3281</span>    <span class="comment"># Implementation of &quot;Algorithm L&quot; from the 1994 paper by Kim-Hung Li:</span></div>
<div class="line"><span class="lineno"> 3282</span>    <span class="comment"># &quot;Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))&quot;.</span></div>
<div class="line"><span class="lineno"> 3283</span> </div>
<div class="line"><span class="lineno"> 3284</span>    <span class="comment"># Fill up the reservoir (collection of samples) with the first `k` samples</span></div>
<div class="line"><span class="lineno"> 3285</span>    reservoir = take(k, iterable)</div>
<div class="line"><span class="lineno"> 3286</span> </div>
<div class="line"><span class="lineno"> 3287</span>    <span class="comment"># Generate random number that&#39;s the largest in a sample of k U(0,1) numbers</span></div>
<div class="line"><span class="lineno"> 3288</span>    <span class="comment"># Largest order statistic: https://en.wikipedia.org/wiki/Order_statistic</span></div>
<div class="line"><span class="lineno"> 3289</span>    W = exp(log(<a class="code hl_namespace" href="namespacerandom.html">random</a>()) / k)</div>
<div class="line"><span class="lineno"> 3290</span> </div>
<div class="line"><span class="lineno"> 3291</span>    <span class="comment"># The number of elements to skip before changing the reservoir is a random</span></div>
<div class="line"><span class="lineno"> 3292</span>    <span class="comment"># number with a geometric distribution. Sample it using random() and logs.</span></div>
<div class="line"><span class="lineno"> 3293</span>    next_index = k + floor(log(<a class="code hl_namespace" href="namespacerandom.html">random</a>()) / log(1 - W))</div>
<div class="line"><span class="lineno"> 3294</span> </div>
<div class="line"><span class="lineno"> 3295</span>    <span class="keywordflow">for</span> index, element <span class="keywordflow">in</span> enumerate(iterable, k):</div>
<div class="line"><span class="lineno"> 3296</span> </div>
<div class="line"><span class="lineno"> 3297</span>        <span class="keywordflow">if</span> index == next_index:</div>
<div class="line"><span class="lineno"> 3298</span>            reservoir[randrange(k)] = element</div>
<div class="line"><span class="lineno"> 3299</span>            <span class="comment"># The new W is the largest in a sample of k U(0, `old_W`) numbers</span></div>
<div class="line"><span class="lineno"> 3300</span>            W *= exp(log(<a class="code hl_namespace" href="namespacerandom.html">random</a>()) / k)</div>
<div class="line"><span class="lineno"> 3301</span>            next_index += floor(log(<a class="code hl_namespace" href="namespacerandom.html">random</a>()) / log(1 - W)) + 1</div>
<div class="line"><span class="lineno"> 3302</span> </div>
<div class="line"><span class="lineno"> 3303</span>    <span class="keywordflow">return</span> reservoir</div>
<div class="line"><span class="lineno"> 3304</span> </div>
<div class="line"><span class="lineno"> 3305</span> </div>
<div class="ttc" id="anamespacerandom_html"><div class="ttname"><a href="namespacerandom.html">random</a></div><div class="ttdef"><b>Definition</b> random.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ec7ac4b35d3e11e81091ab5cd00017e" name="a4ec7ac4b35d3e11e81091ab5cd00017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec7ac4b35d3e11e81091ab5cd00017e">&#9670;&#160;</a></span>_sample_weighted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._sample_weighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3306</span><span class="keyword">def </span>_sample_weighted(iterable, k, weights):</div>
<div class="line"><span class="lineno"> 3307</span>    <span class="comment"># Implementation of &quot;A-ExpJ&quot; from the 2006 paper by Efraimidis et al. :</span></div>
<div class="line"><span class="lineno"> 3308</span>    <span class="comment"># &quot;Weighted random sampling with a reservoir&quot;.</span></div>
<div class="line"><span class="lineno"> 3309</span> </div>
<div class="line"><span class="lineno"> 3310</span>    <span class="comment"># Log-transform for numerical stability for weights that are small/large</span></div>
<div class="line"><span class="lineno"> 3311</span>    weight_keys = (log(<a class="code hl_namespace" href="namespacerandom.html">random</a>()) / weight <span class="keywordflow">for</span> weight <span class="keywordflow">in</span> weights)</div>
<div class="line"><span class="lineno"> 3312</span> </div>
<div class="line"><span class="lineno"> 3313</span>    <span class="comment"># Fill up the reservoir (collection of samples) with the first `k`</span></div>
<div class="line"><span class="lineno"> 3314</span>    <span class="comment"># weight-keys and elements, then heapify the list.</span></div>
<div class="line"><span class="lineno"> 3315</span>    reservoir = take(k, zip(weight_keys, iterable))</div>
<div class="line"><span class="lineno"> 3316</span>    heapify(reservoir)</div>
<div class="line"><span class="lineno"> 3317</span> </div>
<div class="line"><span class="lineno"> 3318</span>    <span class="comment"># The number of jumps before changing the reservoir is a random variable</span></div>
<div class="line"><span class="lineno"> 3319</span>    <span class="comment"># with an exponential distribution. Sample it using random() and logs.</span></div>
<div class="line"><span class="lineno"> 3320</span>    smallest_weight_key, _ = reservoir[0]</div>
<div class="line"><span class="lineno"> 3321</span>    weights_to_skip = log(<a class="code hl_namespace" href="namespacerandom.html">random</a>()) / smallest_weight_key</div>
<div class="line"><span class="lineno"> 3322</span> </div>
<div class="line"><span class="lineno"> 3323</span>    <span class="keywordflow">for</span> weight, element <span class="keywordflow">in</span> zip(weights, iterable):</div>
<div class="line"><span class="lineno"> 3324</span>        <span class="keywordflow">if</span> weight &gt;= weights_to_skip:</div>
<div class="line"><span class="lineno"> 3325</span>            <span class="comment"># The notation here is consistent with the paper, but we store</span></div>
<div class="line"><span class="lineno"> 3326</span>            <span class="comment"># the weight-keys in log-space for better numerical stability.</span></div>
<div class="line"><span class="lineno"> 3327</span>            smallest_weight_key, _ = reservoir[0]</div>
<div class="line"><span class="lineno"> 3328</span>            t_w = exp(weight * smallest_weight_key)</div>
<div class="line"><span class="lineno"> 3329</span>            r_2 = uniform(t_w, 1)  <span class="comment"># generate U(t_w, 1)</span></div>
<div class="line"><span class="lineno"> 3330</span>            weight_key = log(r_2) / weight</div>
<div class="line"><span class="lineno"> 3331</span>            heapreplace(reservoir, (weight_key, element))</div>
<div class="line"><span class="lineno"> 3332</span>            smallest_weight_key, _ = reservoir[0]</div>
<div class="line"><span class="lineno"> 3333</span>            weights_to_skip = log(<a class="code hl_namespace" href="namespacerandom.html">random</a>()) / smallest_weight_key</div>
<div class="line"><span class="lineno"> 3334</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3335</span>            weights_to_skip -= weight</div>
<div class="line"><span class="lineno"> 3336</span> </div>
<div class="line"><span class="lineno"> 3337</span>    <span class="comment"># Equivalent to [element for weight_key, element in sorted(reservoir)]</span></div>
<div class="line"><span class="lineno"> 3338</span>    <span class="keywordflow">return</span> [heappop(reservoir)[1] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(k)]</div>
<div class="line"><span class="lineno"> 3339</span> </div>
<div class="line"><span class="lineno"> 3340</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a42e20e24eacb1c2dfe200269764b32ff" name="a42e20e24eacb1c2dfe200269764b32ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e20e24eacb1c2dfe200269764b32ff">&#9670;&#160;</a></span>_zip_equal_generator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._zip_equal_generator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1493</span><span class="keyword">def </span>_zip_equal_generator(iterables):</div>
<div class="line"><span class="lineno"> 1494</span>    <span class="keywordflow">for</span> combo <span class="keywordflow">in</span> zip_longest(*iterables, fillvalue=_marker):</div>
<div class="line"><span class="lineno"> 1495</span>        <span class="keywordflow">for</span> val <span class="keywordflow">in</span> combo:</div>
<div class="line"><span class="lineno"> 1496</span>            <span class="keywordflow">if</span> val <span class="keywordflow">is</span> _marker:</div>
<div class="line"><span class="lineno"> 1497</span>                <span class="keywordflow">raise</span> UnequalIterablesError()</div>
<div class="line"><span class="lineno"> 1498</span>        <span class="keywordflow">yield</span> combo</div>
<div class="line"><span class="lineno"> 1499</span> </div>
<div class="line"><span class="lineno"> 1500</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a835dca721e46dea810ffe00b70252e86" name="a835dca721e46dea810ffe00b70252e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835dca721e46dea810ffe00b70252e86">&#9670;&#160;</a></span>adjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.adjacent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an iterable over `(bool, item)` tuples where the `item` is
drawn from *iterable* and the `bool` indicates whether
that item satisfies the *predicate* or is adjacent to an item that does.

For example, to find whether items are adjacent to a ``3``::

    &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6)))
    [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]

Set *distance* to change what counts as adjacent. For example, to find
whether items are two places away from a ``3``:

    &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6), distance=2))
    [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]

This is useful for contextualizing the results of a search function.
For example, a code comparison tool might want to identify lines that
have changed, but also surrounding lines to give the viewer of the diff
context.

The predicate function will only be called once for each item in the
iterable.

See also :func:`groupby_transform`, which can be used with this function
to group ranges of items with the same `bool` value.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1805</span><span class="keyword">def </span>adjacent(predicate, iterable, distance=1):</div>
<div class="line"><span class="lineno"> 1806</span>    <span class="stringliteral">&quot;&quot;&quot;Return an iterable over `(bool, item)` tuples where the `item` is</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">    drawn from *iterable* and the `bool` indicates whether</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">    that item satisfies the *predicate* or is adjacent to an item that does.</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">    For example, to find whether items are adjacent to a ``3``::</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">        &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6)))</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">    Set *distance* to change what counts as adjacent. For example, to find</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">    whether items are two places away from a ``3``:</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">        &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6), distance=2))</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    This is useful for contextualizing the results of a search function.</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">    For example, a code comparison tool might want to identify lines that</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    have changed, but also surrounding lines to give the viewer of the diff</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    context.</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    The predicate function will only be called once for each item in the</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    iterable.</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    See also :func:`groupby_transform`, which can be used with this function</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    to group ranges of items with the same `bool` value.</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1833</span>    <span class="comment"># Allow distance=0 mainly for testing that it reproduces results with map()</span></div>
<div class="line"><span class="lineno"> 1834</span>    <span class="keywordflow">if</span> distance &lt; 0:</div>
<div class="line"><span class="lineno"> 1835</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;distance must be at least 0&#39;</span>)</div>
<div class="line"><span class="lineno"> 1836</span> </div>
<div class="line"><span class="lineno"> 1837</span>    i1, i2 = tee(iterable)</div>
<div class="line"><span class="lineno"> 1838</span>    padding = [<span class="keyword">False</span>] * distance</div>
<div class="line"><span class="lineno"> 1839</span>    selected = chain(padding, map(predicate, i1), padding)</div>
<div class="line"><span class="lineno"> 1840</span>    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))</div>
<div class="line"><span class="lineno"> 1841</span>    <span class="keywordflow">return</span> zip(adjacent_to_selected, i2)</div>
<div class="line"><span class="lineno"> 1842</span> </div>
<div class="line"><span class="lineno"> 1843</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a85b736b170fbf6c04c61095495941cc9" name="a85b736b170fbf6c04c61095495941cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b736b170fbf6c04c61095495941cc9">&#9670;&#160;</a></span>all_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.all_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns ``True`` if all the elements of *iterable* are unique (no two
elements are equal).

    &gt;&gt;&gt; all_unique('ABCB')
    False

If a *key* function is specified, it will be used to make comparisons.

    &gt;&gt;&gt; all_unique('ABCb')
    True
    &gt;&gt;&gt; all_unique('ABCb', str.lower)
    False

The function returns as soon as the first non-unique element is
encountered. Iterables with a mix of hashable and unhashable items can
be used, but the function will be slower for unhashable items.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3564</span><span class="keyword">def </span>all_unique(iterable, key=None):</div>
<div class="line"><span class="lineno"> 3565</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral">    Returns ``True`` if all the elements of *iterable* are unique (no two</span></div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">    elements are equal).</span></div>
<div class="line"><span class="lineno"> 3568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3569</span><span class="stringliteral">        &gt;&gt;&gt; all_unique(&#39;ABCB&#39;)</span></div>
<div class="line"><span class="lineno"> 3570</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 3571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3572</span><span class="stringliteral">    If a *key* function is specified, it will be used to make comparisons.</span></div>
<div class="line"><span class="lineno"> 3573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral">        &gt;&gt;&gt; all_unique(&#39;ABCb&#39;)</span></div>
<div class="line"><span class="lineno"> 3575</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 3576</span><span class="stringliteral">        &gt;&gt;&gt; all_unique(&#39;ABCb&#39;, str.lower)</span></div>
<div class="line"><span class="lineno"> 3577</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 3578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3579</span><span class="stringliteral">    The function returns as soon as the first non-unique element is</span></div>
<div class="line"><span class="lineno"> 3580</span><span class="stringliteral">    encountered. Iterables with a mix of hashable and unhashable items can</span></div>
<div class="line"><span class="lineno"> 3581</span><span class="stringliteral">    be used, but the function will be slower for unhashable items.</span></div>
<div class="line"><span class="lineno"> 3582</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3583</span>    seenset = set()</div>
<div class="line"><span class="lineno"> 3584</span>    seenset_add = seenset.add</div>
<div class="line"><span class="lineno"> 3585</span>    seenlist = []</div>
<div class="line"><span class="lineno"> 3586</span>    seenlist_add = seenlist.append</div>
<div class="line"><span class="lineno"> 3587</span>    <span class="keywordflow">for</span> element <span class="keywordflow">in</span> map(key, iterable) <span class="keywordflow">if</span> key <span class="keywordflow">else</span> iterable:</div>
<div class="line"><span class="lineno"> 3588</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3589</span>            <span class="keywordflow">if</span> element <span class="keywordflow">in</span> seenset:</div>
<div class="line"><span class="lineno"> 3590</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3591</span>            seenset_add(element)</div>
<div class="line"><span class="lineno"> 3592</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 3593</span>            <span class="keywordflow">if</span> element <span class="keywordflow">in</span> seenlist:</div>
<div class="line"><span class="lineno"> 3594</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3595</span>            seenlist_add(element)</div>
<div class="line"><span class="lineno"> 3596</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3597</span> </div>
<div class="line"><span class="lineno"> 3598</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a747a961c026ef4e048dbad7872b7e9ba" name="a747a961c026ef4e048dbad7872b7e9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747a961c026ef4e048dbad7872b7e9ba">&#9670;&#160;</a></span>always_iterable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.always_iterable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_type</em> = <code>(str,&#160;bytes)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If *obj* is iterable, return an iterator over its items::

    &gt;&gt;&gt; obj = (1, 2, 3)
    &gt;&gt;&gt; list(always_iterable(obj))
    [1, 2, 3]

If *obj* is not iterable, return a one-item iterable containing *obj*::

    &gt;&gt;&gt; obj = 1
    &gt;&gt;&gt; list(always_iterable(obj))
    [1]

If *obj* is ``None``, return an empty iterable:

    &gt;&gt;&gt; obj = None
    &gt;&gt;&gt; list(always_iterable(None))
    []

By default, binary and text strings are not considered iterable::

    &gt;&gt;&gt; obj = 'foo'
    &gt;&gt;&gt; list(always_iterable(obj))
    ['foo']

If *base_type* is set, objects for which ``isinstance(obj, base_type)``
returns ``True`` won't be considered iterable.

    &gt;&gt;&gt; obj = {'a': 1}
    &gt;&gt;&gt; list(always_iterable(obj))  # Iterate over the dict's keys
    ['a']
    &gt;&gt;&gt; list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit
    [{'a': 1}]

Set *base_type* to ``None`` to avoid any special handling and treat objects
Python considers iterable as iterable:

    &gt;&gt;&gt; obj = 'foo'
    &gt;&gt;&gt; list(always_iterable(obj, base_type=None))
    ['f', 'o', 'o']
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1752</span><span class="keyword">def </span>always_iterable(obj, base_type=(str, bytes)):</div>
<div class="line"><span class="lineno"> 1753</span>    <span class="stringliteral">&quot;&quot;&quot;If *obj* is iterable, return an iterator over its items::</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">        &gt;&gt;&gt; obj = (1, 2, 3)</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral">        &gt;&gt;&gt; list(always_iterable(obj))</span></div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">        [1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">    If *obj* is not iterable, return a one-item iterable containing *obj*::</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">        &gt;&gt;&gt; obj = 1</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">        &gt;&gt;&gt; list(always_iterable(obj))</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">        [1]</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    If *obj* is ``None``, return an empty iterable:</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">        &gt;&gt;&gt; obj = None</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">        &gt;&gt;&gt; list(always_iterable(None))</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">        []</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    By default, binary and text strings are not considered iterable::</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">        &gt;&gt;&gt; obj = &#39;foo&#39;</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">        &gt;&gt;&gt; list(always_iterable(obj))</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">        [&#39;foo&#39;]</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">    If *base_type* is set, objects for which ``isinstance(obj, base_type)``</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">    returns ``True`` won&#39;t be considered iterable.</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">        &gt;&gt;&gt; obj = {&#39;a&#39;: 1}</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">        &gt;&gt;&gt; list(always_iterable(obj))  # Iterate over the dict&#39;s keys</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">        [&#39;a&#39;]</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">        &gt;&gt;&gt; list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">        [{&#39;a&#39;: 1}]</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">    Set *base_type* to ``None`` to avoid any special handling and treat objects</span></div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">    Python considers iterable as iterable:</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">        &gt;&gt;&gt; obj = &#39;foo&#39;</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">        &gt;&gt;&gt; list(always_iterable(obj, base_type=None))</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">        [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1793</span>    <span class="keywordflow">if</span> obj <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1794</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(())</div>
<div class="line"><span class="lineno"> 1795</span> </div>
<div class="line"><span class="lineno"> 1796</span>    <span class="keywordflow">if</span> (base_type <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> isinstance(obj, base_type):</div>
<div class="line"><span class="lineno"> 1797</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>((obj,))</div>
<div class="line"><span class="lineno"> 1798</span> </div>
<div class="line"><span class="lineno"> 1799</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1800</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(obj)</div>
<div class="line"><span class="lineno"> 1801</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1802</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>((obj,))</div>
<div class="line"><span class="lineno"> 1803</span> </div>
<div class="line"><span class="lineno"> 1804</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ed7891e30021a8924131411039ad76a" name="a4ed7891e30021a8924131411039ad76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed7891e30021a8924131411039ad76a">&#9670;&#160;</a></span>always_reversible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.always_reversible </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An extension of :func:`reversed` that supports all iterables, not
just those which implement the ``Reversible`` or ``Sequence`` protocols.

    &gt;&gt;&gt; print(*always_reversible(x for x in range(3)))
    2 1 0

If the iterable is already reversible, this function returns the
result of :func:`reversed()`. If the iterable is not reversible,
this function will cache the remaining items in the iterable and
yield them in reverse order, which may require significant storage.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2410</span><span class="keyword">def </span>always_reversible(iterable):</div>
<div class="line"><span class="lineno"> 2411</span>    <span class="stringliteral">&quot;&quot;&quot;An extension of :func:`reversed` that supports all iterables, not</span></div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral">    just those which implement the ``Reversible`` or ``Sequence`` protocols.</span></div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral">        &gt;&gt;&gt; print(*always_reversible(x for x in range(3)))</span></div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral">        2 1 0</span></div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral">    If the iterable is already reversible, this function returns the</span></div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral">    result of :func:`reversed()`. If the iterable is not reversible,</span></div>
<div class="line"><span class="lineno"> 2419</span><span class="stringliteral">    this function will cache the remaining items in the iterable and</span></div>
<div class="line"><span class="lineno"> 2420</span><span class="stringliteral">    yield them in reverse order, which may require significant storage.</span></div>
<div class="line"><span class="lineno"> 2421</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2422</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2423</span>        <span class="keywordflow">return</span> reversed(iterable)</div>
<div class="line"><span class="lineno"> 2424</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 2425</span>        <span class="keywordflow">return</span> reversed(list(iterable))</div>
<div class="line"><span class="lineno"> 2426</span> </div>
<div class="line"><span class="lineno"> 2427</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abffb53abf1266b52e612759e97a93b4d" name="abffb53abf1266b52e612759e97a93b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffb53abf1266b52e612759e97a93b4d">&#9670;&#160;</a></span>chunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.chunked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Break *iterable* into lists of length *n*:

    &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6], 3))
    [[1, 2, 3], [4, 5, 6]]

By the default, the last yielded list will have fewer than *n* elements
if the length of *iterable* is not divisible by *n*:

    &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))
    [[1, 2, 3], [4, 5, 6], [7, 8]]

To use a fill-in value instead, see the :func:`grouper` recipe.

If the length of *iterable* is not divisible by *n* and *strict* is
``True``, then ``ValueError`` will be raised before the last
list is yielded.</pre> <div class="fragment"><div class="line"><span class="lineno">  127</span><span class="keyword">def </span>chunked(iterable, n, strict=False):</div>
<div class="line"><span class="lineno">  128</span>    <span class="stringliteral">&quot;&quot;&quot;Break *iterable* into lists of length *n*:</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">        &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6], 3))</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        [[1, 2, 3], [4, 5, 6]]</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    By the default, the last yielded list will have fewer than *n* elements</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    if the length of *iterable* is not divisible by *n*:</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        [[1, 2, 3], [4, 5, 6], [7, 8]]</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    To use a fill-in value instead, see the :func:`grouper` recipe.</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    If the length of *iterable* is not divisible by *n* and *strict* is</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    ``True``, then ``ValueError`` will be raised before the last</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    list is yielded.</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  146</span>    iterator = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(partial(take, n, <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)), [])</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">if</span> strict:</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>        <span class="keyword">def </span>ret():</div>
<div class="line"><span class="lineno">  150</span>            <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> iterator:</div>
<div class="line"><span class="lineno">  151</span>                <span class="keywordflow">if</span> len(chunk) != n:</div>
<div class="line"><span class="lineno">  152</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;iterable is not divisible by n.&#39;</span>)</div>
<div class="line"><span class="lineno">  153</span>                <span class="keywordflow">yield</span> chunk</div>
<div class="line"><span class="lineno">  154</span> </div>
<div class="line"><span class="lineno">  155</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(ret())</div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  157</span>        <span class="keywordflow">return</span> iterator</div>
<div class="line"><span class="lineno">  158</span> </div>
<div class="line"><span class="lineno">  159</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="affed850f38028aaebb5989efe884862a" name="affed850f38028aaebb5989efe884862a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affed850f38028aaebb5989efe884862a">&#9670;&#160;</a></span>circular_shifts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.circular_shifts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of circular shifts of *iterable*.

&gt;&gt;&gt; circular_shifts(range(4))
[(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2750</span><span class="keyword">def </span>circular_shifts(iterable):</div>
<div class="line"><span class="lineno"> 2751</span>    <span class="stringliteral">&quot;&quot;&quot;Return a list of circular shifts of *iterable*.</span></div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral">    &gt;&gt;&gt; circular_shifts(range(4))</span></div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral">    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]</span></div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2756</span>    lst = list(iterable)</div>
<div class="line"><span class="lineno"> 2757</span>    <span class="keywordflow">return</span> take(len(lst), windowed(cycle(lst), len(lst)))</div>
<div class="line"><span class="lineno"> 2758</span> </div>
<div class="line"><span class="lineno"> 2759</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad41738788dce77084e613575a9391382" name="ad41738788dce77084e613575a9391382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41738788dce77084e613575a9391382">&#9670;&#160;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.collapse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>levels</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flatten an iterable with multiple levels of nesting (e.g., a list of
lists of tuples) into non-iterable types.

    &gt;&gt;&gt; iterable = [(1, 2), ([3, 4], [[5], [6]])]
    &gt;&gt;&gt; list(collapse(iterable))
    [1, 2, 3, 4, 5, 6]

Binary and text strings are not considered iterable and
will not be collapsed.

To avoid collapsing other types, specify *base_type*:

    &gt;&gt;&gt; iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]
    &gt;&gt;&gt; list(collapse(iterable, base_type=tuple))
    ['ab', ('cd', 'ef'), 'gh', 'ij']

Specify *levels* to stop flattening after a certain level:

&gt;&gt;&gt; iterable = [('a', ['b']), ('c', ['d'])]
&gt;&gt;&gt; list(collapse(iterable))  # Fully flattened
['a', 'b', 'c', 'd']
&gt;&gt;&gt; list(collapse(iterable, levels=1))  # Only one level flattened
['a', ['b'], 'c', ['d']]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1020</span><span class="keyword">def </span>collapse(iterable, base_type=None, levels=None):</div>
<div class="line"><span class="lineno"> 1021</span>    <span class="stringliteral">&quot;&quot;&quot;Flatten an iterable with multiple levels of nesting (e.g., a list of</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    lists of tuples) into non-iterable types.</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [(1, 2), ([3, 4], [[5], [6]])]</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">        &gt;&gt;&gt; list(collapse(iterable))</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">        [1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    Binary and text strings are not considered iterable and</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    will not be collapsed.</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    To avoid collapsing other types, specify *base_type*:</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [&#39;ab&#39;, (&#39;cd&#39;, &#39;ef&#39;), [&#39;gh&#39;, &#39;ij&#39;]]</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">        &gt;&gt;&gt; list(collapse(iterable, base_type=tuple))</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">        [&#39;ab&#39;, (&#39;cd&#39;, &#39;ef&#39;), &#39;gh&#39;, &#39;ij&#39;]</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    Specify *levels* to stop flattening after a certain level:</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    &gt;&gt;&gt; iterable = [(&#39;a&#39;, [&#39;b&#39;]), (&#39;c&#39;, [&#39;d&#39;])]</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    &gt;&gt;&gt; list(collapse(iterable))  # Fully flattened</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">    &gt;&gt;&gt; list(collapse(iterable, levels=1))  # Only one level flattened</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    [&#39;a&#39;, [&#39;b&#39;], &#39;c&#39;, [&#39;d&#39;]]</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1046</span> </div>
<div class="line"><span class="lineno"> 1047</span>    <span class="keyword">def </span>walk(node, level):</div>
<div class="line"><span class="lineno"> 1048</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1049</span>            ((levels <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (level &gt; levels))</div>
<div class="line"><span class="lineno"> 1050</span>            <span class="keywordflow">or</span> isinstance(node, (str, bytes))</div>
<div class="line"><span class="lineno"> 1051</span>            <span class="keywordflow">or</span> ((base_type <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> isinstance(node, base_type))</div>
<div class="line"><span class="lineno"> 1052</span>        ):</div>
<div class="line"><span class="lineno"> 1053</span>            <span class="keywordflow">yield</span> node</div>
<div class="line"><span class="lineno"> 1054</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1055</span> </div>
<div class="line"><span class="lineno"> 1056</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1057</span>            tree = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(node)</div>
<div class="line"><span class="lineno"> 1058</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1059</span>            <span class="keywordflow">yield</span> node</div>
<div class="line"><span class="lineno"> 1060</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1061</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1062</span>            <span class="keywordflow">for</span> child <span class="keywordflow">in</span> tree:</div>
<div class="line"><span class="lineno"> 1063</span>                <span class="keywordflow">yield</span> <span class="keyword">from</span> walk(child, level + 1)</div>
<div class="line"><span class="lineno"> 1064</span> </div>
<div class="line"><span class="lineno"> 1065</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> walk(iterable, 0)</div>
<div class="line"><span class="lineno"> 1066</span> </div>
<div class="line"><span class="lineno"> 1067</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a691dc99d522ad3defe468a1ee9bd532d" name="a691dc99d522ad3defe468a1ee9bd532d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691dc99d522ad3defe468a1ee9bd532d">&#9670;&#160;</a></span>collate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.collate </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sorted merge of the items from each of several already-sorted
*iterables*.

    &gt;&gt;&gt; list(collate('ACDZ', 'AZ', 'JKL'))
    ['A', 'A', 'C', 'D', 'J', 'K', 'L', 'Z', 'Z']

Works lazily, keeping only the next value from each iterable in memory. Use
:func:`collate` to, for example, perform a n-way mergesort of items that
don't fit in memory.

If a *key* function is specified, the iterables will be sorted according
to its result:

    &gt;&gt;&gt; key = lambda s: int(s)  # Sort by numeric value, not by string
    &gt;&gt;&gt; list(collate(['1', '10'], ['2', '11'], key=key))
    ['1', '2', '10', '11']


If the *iterables* are sorted in descending order, set *reverse* to
``True``:

    &gt;&gt;&gt; list(collate([5, 3, 1], [4, 2, 0], reverse=True))
    [5, 4, 3, 2, 1, 0]

If the elements of the passed-in iterables are out of order, you might get
unexpected results.

On Python 3.5+, this function is an alias for :func:`heapq.merge`.</pre> <div class="fragment"><div class="line"><span class="lineno">  399</span><span class="keyword">def </span>collate(*iterables, **kwargs):</div>
<div class="line"><span class="lineno">  400</span>    <span class="stringliteral">&quot;&quot;&quot;Return a sorted merge of the items from each of several already-sorted</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    *iterables*.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">        &gt;&gt;&gt; list(collate(&#39;ACDZ&#39;, &#39;AZ&#39;, &#39;JKL&#39;))</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">        [&#39;A&#39;, &#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;Z&#39;, &#39;Z&#39;]</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    Works lazily, keeping only the next value from each iterable in memory. Use</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    :func:`collate` to, for example, perform a n-way mergesort of items that</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    don&#39;t fit in memory.</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    If a *key* function is specified, the iterables will be sorted according</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    to its result:</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        &gt;&gt;&gt; key = lambda s: int(s)  # Sort by numeric value, not by string</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">        &gt;&gt;&gt; list(collate([&#39;1&#39;, &#39;10&#39;], [&#39;2&#39;, &#39;11&#39;], key=key))</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">        [&#39;1&#39;, &#39;2&#39;, &#39;10&#39;, &#39;11&#39;]</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    If the *iterables* are sorted in descending order, set *reverse* to</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    ``True``:</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">        &gt;&gt;&gt; list(collate([5, 3, 1], [4, 2, 0], reverse=True))</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        [5, 4, 3, 2, 1, 0]</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    If the elements of the passed-in iterables are out of order, you might get</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    unexpected results.</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    On Python 3.5+, this function is an alias for :func:`heapq.merge`.</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  430</span>    warnings.warn(</div>
<div class="line"><span class="lineno">  431</span>        <span class="stringliteral">&quot;collate is no longer part of more_itertools, use heapq.merge&quot;</span>,</div>
<div class="line"><span class="lineno">  432</span>        DeprecationWarning,</div>
<div class="line"><span class="lineno">  433</span>    )</div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">return</span> merge(*iterables, **kwargs)</div>
<div class="line"><span class="lineno">  435</span> </div>
<div class="line"><span class="lineno">  436</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a60d03eaa373fc38712ee738617d1f0e4" name="a60d03eaa373fc38712ee738617d1f0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d03eaa373fc38712ee738617d1f0e4">&#9670;&#160;</a></span>combination_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.combination_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(combinations(iterable, r)).index(element)``

The subsequences of *iterable* that are of length *r* can be ordered
lexicographically. :func:`combination_index` computes the index of the
first *element*, without computing the previous combinations.

    &gt;&gt;&gt; combination_index('adf', 'abcdefg')
    10

``ValueError`` will be raised if the given *element* isn't one of the
combinations of *iterable*.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3729</span><span class="keyword">def </span>combination_index(element, iterable):</div>
<div class="line"><span class="lineno"> 3730</span>    <span class="stringliteral">&quot;&quot;&quot;Equivalent to ``list(combinations(iterable, r)).index(element)``</span></div>
<div class="line"><span class="lineno"> 3731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3732</span><span class="stringliteral">    The subsequences of *iterable* that are of length *r* can be ordered</span></div>
<div class="line"><span class="lineno"> 3733</span><span class="stringliteral">    lexicographically. :func:`combination_index` computes the index of the</span></div>
<div class="line"><span class="lineno"> 3734</span><span class="stringliteral">    first *element*, without computing the previous combinations.</span></div>
<div class="line"><span class="lineno"> 3735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3736</span><span class="stringliteral">        &gt;&gt;&gt; combination_index(&#39;adf&#39;, &#39;abcdefg&#39;)</span></div>
<div class="line"><span class="lineno"> 3737</span><span class="stringliteral">        10</span></div>
<div class="line"><span class="lineno"> 3738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3739</span><span class="stringliteral">    ``ValueError`` will be raised if the given *element* isn&#39;t one of the</span></div>
<div class="line"><span class="lineno"> 3740</span><span class="stringliteral">    combinations of *iterable*.</span></div>
<div class="line"><span class="lineno"> 3741</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3742</span>    element = enumerate(element)</div>
<div class="line"><span class="lineno"> 3743</span>    k, y = next(element, (<span class="keywordtype">None</span>, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno"> 3744</span>    <span class="keywordflow">if</span> k <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3745</span>        <span class="keywordflow">return</span> 0</div>
<div class="line"><span class="lineno"> 3746</span> </div>
<div class="line"><span class="lineno"> 3747</span>    indexes = []</div>
<div class="line"><span class="lineno"> 3748</span>    pool = enumerate(iterable)</div>
<div class="line"><span class="lineno"> 3749</span>    <span class="keywordflow">for</span> n, x <span class="keywordflow">in</span> pool:</div>
<div class="line"><span class="lineno"> 3750</span>        <span class="keywordflow">if</span> x == y:</div>
<div class="line"><span class="lineno"> 3751</span>            indexes.append(n)</div>
<div class="line"><span class="lineno"> 3752</span>            tmp, y = next(element, (<span class="keywordtype">None</span>, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno"> 3753</span>            <span class="keywordflow">if</span> tmp <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3754</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 3755</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3756</span>                k = tmp</div>
<div class="line"><span class="lineno"> 3757</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3758</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;element is not a combination of iterable&#39;</span>)</div>
<div class="line"><span class="lineno"> 3759</span> </div>
<div class="line"><span class="lineno"> 3760</span>    n, _ = last(pool, default=(n, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno"> 3761</span> </div>
<div class="line"><span class="lineno"> 3762</span>    <span class="comment"># Python versiosn below 3.8 don&#39;t have math.comb</span></div>
<div class="line"><span class="lineno"> 3763</span>    index = 1</div>
<div class="line"><span class="lineno"> 3764</span>    <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> enumerate(reversed(indexes), start=1):</div>
<div class="line"><span class="lineno"> 3765</span>        j = n - j</div>
<div class="line"><span class="lineno"> 3766</span>        <span class="keywordflow">if</span> i &lt;= j:</div>
<div class="line"><span class="lineno"> 3767</span>            index += factorial(j) // (factorial(i) * factorial(j - i))</div>
<div class="line"><span class="lineno"> 3768</span> </div>
<div class="line"><span class="lineno"> 3769</span>    <span class="keywordflow">return</span> factorial(n + 1) // (factorial(k + 1) * factorial(n - k)) - index</div>
<div class="line"><span class="lineno"> 3770</span> </div>
<div class="line"><span class="lineno"> 3771</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad42cfd133811f127a2c4321d8c63042b" name="ad42cfd133811f127a2c4321d8c63042b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42cfd133811f127a2c4321d8c63042b">&#9670;&#160;</a></span>consecutive_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.consecutive_groups </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em> = <code><a class="el" href="__lapack__subroutines_8h.html#a76093d20ca2e1c5d5216168f26f73e19">lambda</a>&#160;x:&#160;x</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield groups of consecutive items using :func:`itertools.groupby`.
The *ordering* function determines whether two items are adjacent by
returning their position.

By default, the ordering function is the identity function. This is
suitable for finding runs of numbers:

    &gt;&gt;&gt; iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]
    &gt;&gt;&gt; for group in consecutive_groups(iterable):
    ...     print(list(group))
    [1]
    [10, 11, 12]
    [20]
    [30, 31, 32, 33]
    [40]

For finding runs of adjacent letters, try using the :meth:`index` method
of a string of letters:

    &gt;&gt;&gt; from string import ascii_lowercase
    &gt;&gt;&gt; iterable = 'abcdfgilmnop'
    &gt;&gt;&gt; ordering = ascii_lowercase.index
    &gt;&gt;&gt; for group in consecutive_groups(iterable, ordering):
    ...     print(list(group))
    ['a', 'b', 'c', 'd']
    ['f', 'g']
    ['i']
    ['l', 'm', 'n', 'o', 'p']

Each group of consecutive items is an iterator that shares it source with
*iterable*. When an an output group is advanced, the previous group is
no longer available unless its elements are copied (e.g., into a ``list``).

    &gt;&gt;&gt; iterable = [1, 2, 11, 12, 21, 22]
    &gt;&gt;&gt; saved_groups = []
    &gt;&gt;&gt; for group in consecutive_groups(iterable):
    ...     saved_groups.append(list(group))  # Copy group elements
    &gt;&gt;&gt; saved_groups
    [[1, 2], [11, 12], [21, 22]]</pre> <div class="fragment"><div class="line"><span class="lineno"> 2428</span><span class="keyword">def </span>consecutive_groups(iterable, ordering=lambda x: x):</div>
<div class="line"><span class="lineno"> 2429</span>    <span class="stringliteral">&quot;&quot;&quot;Yield groups of consecutive items using :func:`itertools.groupby`.</span></div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral">    The *ordering* function determines whether two items are adjacent by</span></div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral">    returning their position.</span></div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral">    By default, the ordering function is the identity function. This is</span></div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">    suitable for finding runs of numbers:</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">        &gt;&gt;&gt; for group in consecutive_groups(iterable):</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">        ...     print(list(group))</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">        [1]</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral">        [10, 11, 12]</span></div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">        [20]</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">        [30, 31, 32, 33]</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">        [40]</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">    For finding runs of adjacent letters, try using the :meth:`index` method</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral">    of a string of letters:</span></div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral">        &gt;&gt;&gt; from string import ascii_lowercase</span></div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">        &gt;&gt;&gt; iterable = &#39;abcdfgilmnop&#39;</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">        &gt;&gt;&gt; ordering = ascii_lowercase.index</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral">        &gt;&gt;&gt; for group in consecutive_groups(iterable, ordering):</span></div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">        ...     print(list(group))</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">        [&#39;f&#39;, &#39;g&#39;]</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">        [&#39;i&#39;]</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">        [&#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;]</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">    Each group of consecutive items is an iterator that shares it source with</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">    *iterable*. When an an output group is advanced, the previous group is</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral">    no longer available unless its elements are copied (e.g., into a ``list``).</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [1, 2, 11, 12, 21, 22]</span></div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral">        &gt;&gt;&gt; saved_groups = []</span></div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">        &gt;&gt;&gt; for group in consecutive_groups(iterable):</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">        ...     saved_groups.append(list(group))  # Copy group elements</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral">        &gt;&gt;&gt; saved_groups</span></div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral">        [[1, 2], [11, 12], [21, 22]]</span></div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2470</span>    <span class="keywordflow">for</span> k, g <span class="keywordflow">in</span> groupby(</div>
<div class="line"><span class="lineno"> 2471</span>        enumerate(iterable), key=<span class="keyword">lambda</span> x: x[0] - ordering(x[1])</div>
<div class="line"><span class="lineno"> 2472</span>    ):</div>
<div class="line"><span class="lineno"> 2473</span>        <span class="keywordflow">yield</span> map(itemgetter(1), g)</div>
<div class="line"><span class="lineno"> 2474</span> </div>
<div class="line"><span class="lineno"> 2475</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a227e66c12cc86c45187adb224fee478b" name="a227e66c12cc86c45187adb224fee478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e66c12cc86c45187adb224fee478b">&#9670;&#160;</a></span>consumer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.consumer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decorator that automatically advances a PEP-342-style "reverse iterator"
to its first yield point so you don't have to call ``next()`` on it
manually.

    &gt;&gt;&gt; @consumer
    ... def tally():
    ...     i = 0
    ...     while True:
    ...         print('Thing number %s is %s.' % (i, (yield)))
    ...         i += 1
    ...
    &gt;&gt;&gt; t = tally()
    &gt;&gt;&gt; t.send('red')
    Thing number 0 is red.
    &gt;&gt;&gt; t.send('fish')
    Thing number 1 is fish.

Without the decorator, you would have to call ``next(t)`` before
``t.send()`` could be used.</pre> <div class="fragment"><div class="line"><span class="lineno">  437</span><span class="keyword">def </span>consumer(func):</div>
<div class="line"><span class="lineno">  438</span>    <span class="stringliteral">&quot;&quot;&quot;Decorator that automatically advances a PEP-342-style &quot;reverse iterator&quot;</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    to its first yield point so you don&#39;t have to call ``next()`` on it</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    manually.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        &gt;&gt;&gt; @consumer</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        ... def tally():</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        ...     i = 0</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        ...     while True:</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        ...         print(&#39;Thing number %s is %s.&#39; % (i, (yield)))</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        ...         i += 1</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        &gt;&gt;&gt; t = tally()</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        &gt;&gt;&gt; t.send(&#39;red&#39;)</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        Thing number 0 is red.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        &gt;&gt;&gt; t.send(&#39;fish&#39;)</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        Thing number 1 is fish.</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    Without the decorator, you would have to call ``next(t)`` before</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    ``t.send()`` could be used.</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    <span class="preprocessor">@wraps(func)</span></div>
<div class="line"><span class="lineno">  461</span>    <span class="keyword">def </span>wrapper(*args, **kwargs):</div>
<div class="line"><span class="lineno">  462</span>        gen = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(*args, **kwargs)</div>
<div class="line"><span class="lineno">  463</span>        next(gen)</div>
<div class="line"><span class="lineno">  464</span>        <span class="keywordflow">return</span> gen</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">return</span> wrapper</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ad742cc24dfb3b49a4f07db2aa012b8" name="a3ad742cc24dfb3b49a4f07db2aa012b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad742cc24dfb3b49a4f07db2aa012b8">&#9670;&#160;</a></span>count_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.count_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cycle through the items from *iterable* up to *n* times, yielding
the number of completed cycles along with each item. If *n* is omitted the
process repeats indefinitely.

&gt;&gt;&gt; list(count_cycle('AB', 3))
[(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]</pre> <div class="fragment"><div class="line"><span class="lineno"> 2106</span><span class="keyword">def </span>count_cycle(iterable, n=None):</div>
<div class="line"><span class="lineno"> 2107</span>    <span class="stringliteral">&quot;&quot;&quot;Cycle through the items from *iterable* up to *n* times, yielding</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral">    the number of completed cycles along with each item. If *n* is omitted the</span></div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">    process repeats indefinitely.</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">    &gt;&gt;&gt; list(count_cycle(&#39;AB&#39;, 3))</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">    [(0, &#39;A&#39;), (0, &#39;B&#39;), (1, &#39;A&#39;), (1, &#39;B&#39;), (2, &#39;A&#39;), (2, &#39;B&#39;)]</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2115</span>    iterable = tuple(iterable)</div>
<div class="line"><span class="lineno"> 2116</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> iterable:</div>
<div class="line"><span class="lineno"> 2117</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(())</div>
<div class="line"><span class="lineno"> 2118</span>    counter = count() <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> range(n)</div>
<div class="line"><span class="lineno"> 2119</span>    <span class="keywordflow">return</span> ((i, item) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> counter <span class="keywordflow">for</span> item <span class="keywordflow">in</span> iterable)</div>
<div class="line"><span class="lineno"> 2120</span> </div>
<div class="line"><span class="lineno"> 2121</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1e95112d6bab64bd6e57ae7690be37f" name="aa1e95112d6bab64bd6e57ae7690be37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e95112d6bab64bd6e57ae7690be37f">&#9670;&#160;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>sub</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function is the inverse of :func:`itertools.accumulate`. By default
it will compute the first difference of *iterable* using
:func:`operator.sub`:

    &gt;&gt;&gt; from itertools import accumulate
    &gt;&gt;&gt; iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10
    &gt;&gt;&gt; list(difference(iterable))
    [0, 1, 2, 3, 4]

*func* defaults to :func:`operator.sub`, but other functions can be
specified. They will be applied as follows::

    A, B, C, D, ... --&gt; A, func(B, A), func(C, B), func(D, C), ...

For example, to do progressive division:

    &gt;&gt;&gt; iterable = [1, 2, 6, 24, 120]
    &gt;&gt;&gt; func = lambda x, y: x // y
    &gt;&gt;&gt; list(difference(iterable, func))
    [1, 2, 3, 4, 5]

If the *initial* keyword is set, the first element will be skipped when
computing successive differences.

    &gt;&gt;&gt; it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)
    &gt;&gt;&gt; list(difference(it, initial=10))
    [1, 2, 3]</pre> <div class="fragment"><div class="line"><span class="lineno"> 2476</span><span class="keyword">def </span>difference(iterable, func=sub, *, initial=None):</div>
<div class="line"><span class="lineno"> 2477</span>    <span class="stringliteral">&quot;&quot;&quot;This function is the inverse of :func:`itertools.accumulate`. By default</span></div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">    it will compute the first difference of *iterable* using</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">    :func:`operator.sub`:</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">        &gt;&gt;&gt; from itertools import accumulate</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">        &gt;&gt;&gt; iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">        &gt;&gt;&gt; list(difference(iterable))</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">        [0, 1, 2, 3, 4]</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">    *func* defaults to :func:`operator.sub`, but other functions can be</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    specified. They will be applied as follows::</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">        A, B, C, D, ... --&gt; A, func(B, A), func(C, B), func(D, C), ...</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">    For example, to do progressive division:</span></div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [1, 2, 6, 24, 120]</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral">        &gt;&gt;&gt; func = lambda x, y: x // y</span></div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral">        &gt;&gt;&gt; list(difference(iterable, func))</span></div>
<div class="line"><span class="lineno"> 2496</span><span class="stringliteral">        [1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral">    If the *initial* keyword is set, the first element will be skipped when</span></div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral">    computing successive differences.</span></div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral">        &gt;&gt;&gt; it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)</span></div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">        &gt;&gt;&gt; list(difference(it, initial=10))</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">        [1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2506</span>    a, b = tee(iterable)</div>
<div class="line"><span class="lineno"> 2507</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2508</span>        first = [next(b)]</div>
<div class="line"><span class="lineno"> 2509</span>    <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno"> 2510</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>([])</div>
<div class="line"><span class="lineno"> 2511</span> </div>
<div class="line"><span class="lineno"> 2512</span>    <span class="keywordflow">if</span> initial <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2513</span>        first = []</div>
<div class="line"><span class="lineno"> 2514</span> </div>
<div class="line"><span class="lineno"> 2515</span>    <span class="keywordflow">return</span> chain(first, starmap(func, zip(b, a)))</div>
<div class="line"><span class="lineno"> 2516</span> </div>
<div class="line"><span class="lineno"> 2517</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aecf4eef1c3957d30770055397f1b10ef" name="aecf4eef1c3957d30770055397f1b10ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf4eef1c3957d30770055397f1b10ef">&#9670;&#160;</a></span>distinct_combinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.distinct_combinations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the distinct combinations of *r* items taken from *iterable*.

    &gt;&gt;&gt; list(distinct_combinations([0, 0, 1], 2))
    [(0, 0), (0, 1)]

Equivalent to ``set(combinations(iterable))``, except duplicates are not
generated and thrown away. For larger input sequences this is much more
efficient.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3195</span><span class="keyword">def </span>distinct_combinations(iterable, r):</div>
<div class="line"><span class="lineno"> 3196</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the distinct combinations of *r* items taken from *iterable*.</span></div>
<div class="line"><span class="lineno"> 3197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3198</span><span class="stringliteral">        &gt;&gt;&gt; list(distinct_combinations([0, 0, 1], 2))</span></div>
<div class="line"><span class="lineno"> 3199</span><span class="stringliteral">        [(0, 0), (0, 1)]</span></div>
<div class="line"><span class="lineno"> 3200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral">    Equivalent to ``set(combinations(iterable))``, except duplicates are not</span></div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral">    generated and thrown away. For larger input sequences this is much more</span></div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">    efficient.</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3205</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3206</span>    <span class="keywordflow">if</span> r &lt; 0:</div>
<div class="line"><span class="lineno"> 3207</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;r must be non-negative&#39;</span>)</div>
<div class="line"><span class="lineno"> 3208</span>    <span class="keywordflow">elif</span> r == 0:</div>
<div class="line"><span class="lineno"> 3209</span>        <span class="keywordflow">yield</span> ()</div>
<div class="line"><span class="lineno"> 3210</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 3211</span>    pool = tuple(iterable)</div>
<div class="line"><span class="lineno"> 3212</span>    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]</div>
<div class="line"><span class="lineno"> 3213</span>    current_combo = [<span class="keywordtype">None</span>] * r</div>
<div class="line"><span class="lineno"> 3214</span>    level = 0</div>
<div class="line"><span class="lineno"> 3215</span>    <span class="keywordflow">while</span> generators:</div>
<div class="line"><span class="lineno"> 3216</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3217</span>            cur_idx, p = next(generators[-1])</div>
<div class="line"><span class="lineno"> 3218</span>        <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno"> 3219</span>            generators.pop()</div>
<div class="line"><span class="lineno"> 3220</span>            level -= 1</div>
<div class="line"><span class="lineno"> 3221</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 3222</span>        current_combo[level] = p</div>
<div class="line"><span class="lineno"> 3223</span>        <span class="keywordflow">if</span> level + 1 == r:</div>
<div class="line"><span class="lineno"> 3224</span>            <span class="keywordflow">yield</span> tuple(current_combo)</div>
<div class="line"><span class="lineno"> 3225</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3226</span>            generators.append(</div>
<div class="line"><span class="lineno"> 3227</span>                unique_everseen(</div>
<div class="line"><span class="lineno"> 3228</span>                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),</div>
<div class="line"><span class="lineno"> 3229</span>                    key=itemgetter(1),</div>
<div class="line"><span class="lineno"> 3230</span>                )</div>
<div class="line"><span class="lineno"> 3231</span>            )</div>
<div class="line"><span class="lineno"> 3232</span>            level += 1</div>
<div class="line"><span class="lineno"> 3233</span> </div>
<div class="line"><span class="lineno"> 3234</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8491276c50929899fe32cda6fd2d01e" name="ab8491276c50929899fe32cda6fd2d01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8491276c50929899fe32cda6fd2d01e">&#9670;&#160;</a></span>distinct_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.distinct_permutations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield successive distinct permutations of the elements in *iterable*.

    &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1]))
    [(0, 1, 1), (1, 0, 1), (1, 1, 0)]

Equivalent to ``set(permutations(iterable))``, except duplicates are not
generated and thrown away. For larger input sequences this is much more
efficient.

Duplicate permutations arise when there are duplicated elements in the
input iterable. The number of items returned is
`n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of
items input, and each `x_i` is the count of a distinct item in the input
sequence.

If *r* is given, only the *r*-length permutations are yielded.

    &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1], r=2))
    [(0, 1), (1, 0), (1, 1)]
    &gt;&gt;&gt; sorted(distinct_permutations(range(3), r=2))
    [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</pre> <div class="fragment"><div class="line"><span class="lineno">  581</span><span class="keyword">def </span>distinct_permutations(iterable, r=None):</div>
<div class="line"><span class="lineno">  582</span>    <span class="stringliteral">&quot;&quot;&quot;Yield successive distinct permutations of the elements in *iterable*.</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1]))</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    Equivalent to ``set(permutations(iterable))``, except duplicates are not</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    generated and thrown away. For larger input sequences this is much more</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    efficient.</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    Duplicate permutations arise when there are duplicated elements in the</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    input iterable. The number of items returned is</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    items input, and each `x_i` is the count of a distinct item in the input</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    sequence.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    If *r* is given, only the *r*-length permutations are yielded.</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1], r=2))</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">        [(0, 1), (1, 0), (1, 1)]</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        &gt;&gt;&gt; sorted(distinct_permutations(range(3), r=2))</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  605</span>    <span class="comment"># Algorithm: https://w.wiki/Qai</span></div>
<div class="line"><span class="lineno">  606</span>    <span class="keyword">def </span>_full(A):</div>
<div class="line"><span class="lineno">  607</span>        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  608</span>            <span class="comment"># Yield the permutation we have</span></div>
<div class="line"><span class="lineno">  609</span>            <span class="keywordflow">yield</span> tuple(A)</div>
<div class="line"><span class="lineno">  610</span> </div>
<div class="line"><span class="lineno">  611</span>            <span class="comment"># Find the largest index i such that A[i] &lt; A[i + 1]</span></div>
<div class="line"><span class="lineno">  612</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(size - 2, -1, -1):</div>
<div class="line"><span class="lineno">  613</span>                <span class="keywordflow">if</span> A[i] &lt; A[i + 1]:</div>
<div class="line"><span class="lineno">  614</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  615</span>            <span class="comment">#  If no such index exists, this permutation is the last one</span></div>
<div class="line"><span class="lineno">  616</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  617</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  618</span> </div>
<div class="line"><span class="lineno">  619</span>            <span class="comment"># Find the largest index j greater than j such that A[i] &lt; A[j]</span></div>
<div class="line"><span class="lineno">  620</span>            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(size - 1, i, -1):</div>
<div class="line"><span class="lineno">  621</span>                <span class="keywordflow">if</span> A[i] &lt; A[j]:</div>
<div class="line"><span class="lineno">  622</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  623</span> </div>
<div class="line"><span class="lineno">  624</span>            <span class="comment"># Swap the value of A[i] with that of A[j], then reverse the</span></div>
<div class="line"><span class="lineno">  625</span>            <span class="comment"># sequence from A[i + 1] to form the new permutation</span></div>
<div class="line"><span class="lineno">  626</span>            A[i], A[j] = A[j], A[i]</div>
<div class="line"><span class="lineno">  627</span>            A[i + 1 :] = A[: i - size : -1]  <span class="comment"># A[i + 1:][::-1]</span></div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="line"><span class="lineno">  629</span>    <span class="comment"># Algorithm: modified from the above</span></div>
<div class="line"><span class="lineno">  630</span>    <span class="keyword">def </span>_partial(A, r):</div>
<div class="line"><span class="lineno">  631</span>        <span class="comment"># Split A into the first r items and the last r items</span></div>
<div class="line"><span class="lineno">  632</span>        head, tail = A[:r], A[r:]</div>
<div class="line"><span class="lineno">  633</span>        right_head_indexes = range(r - 1, -1, -1)</div>
<div class="line"><span class="lineno">  634</span>        left_tail_indexes = range(len(tail))</div>
<div class="line"><span class="lineno">  635</span> </div>
<div class="line"><span class="lineno">  636</span>        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  637</span>            <span class="comment"># Yield the permutation we have</span></div>
<div class="line"><span class="lineno">  638</span>            <span class="keywordflow">yield</span> tuple(head)</div>
<div class="line"><span class="lineno">  639</span> </div>
<div class="line"><span class="lineno">  640</span>            <span class="comment"># Starting from the right, find the first index of the head with</span></div>
<div class="line"><span class="lineno">  641</span>            <span class="comment"># value smaller than the maximum value of the tail - call it i.</span></div>
<div class="line"><span class="lineno">  642</span>            pivot = tail[-1]</div>
<div class="line"><span class="lineno">  643</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> right_head_indexes:</div>
<div class="line"><span class="lineno">  644</span>                <span class="keywordflow">if</span> head[i] &lt; pivot:</div>
<div class="line"><span class="lineno">  645</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  646</span>                pivot = head[i]</div>
<div class="line"><span class="lineno">  647</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  648</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  649</span> </div>
<div class="line"><span class="lineno">  650</span>            <span class="comment"># Starting from the left, find the first value of the tail</span></div>
<div class="line"><span class="lineno">  651</span>            <span class="comment"># with a value greater than head[i] and swap.</span></div>
<div class="line"><span class="lineno">  652</span>            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> left_tail_indexes:</div>
<div class="line"><span class="lineno">  653</span>                <span class="keywordflow">if</span> tail[j] &gt; head[i]:</div>
<div class="line"><span class="lineno">  654</span>                    head[i], tail[j] = tail[j], head[i]</div>
<div class="line"><span class="lineno">  655</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  656</span>            <span class="comment"># If we didn&#39;t find one, start from the right and find the first</span></div>
<div class="line"><span class="lineno">  657</span>            <span class="comment"># index of the head with a value greater than head[i] and swap.</span></div>
<div class="line"><span class="lineno">  658</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  659</span>                <span class="keywordflow">for</span> j <span class="keywordflow">in</span> right_head_indexes:</div>
<div class="line"><span class="lineno">  660</span>                    <span class="keywordflow">if</span> head[j] &gt; head[i]:</div>
<div class="line"><span class="lineno">  661</span>                        head[i], head[j] = head[j], head[i]</div>
<div class="line"><span class="lineno">  662</span>                        <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  663</span> </div>
<div class="line"><span class="lineno">  664</span>            <span class="comment"># Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]</span></div>
<div class="line"><span class="lineno">  665</span>            tail += head[: i - r : -1]  <span class="comment"># head[i + 1:][::-1]</span></div>
<div class="line"><span class="lineno">  666</span>            i += 1</div>
<div class="line"><span class="lineno">  667</span>            head[i:], tail[:] = tail[: r - i], tail[r - i :]</div>
<div class="line"><span class="lineno">  668</span> </div>
<div class="line"><span class="lineno">  669</span>    items = sorted(iterable)</div>
<div class="line"><span class="lineno">  670</span> </div>
<div class="line"><span class="lineno">  671</span>    size = len(items)</div>
<div class="line"><span class="lineno">  672</span>    <span class="keywordflow">if</span> r <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  673</span>        r = size</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span>    <span class="keywordflow">if</span> 0 &lt; r &lt;= size:</div>
<div class="line"><span class="lineno">  676</span>        <span class="keywordflow">return</span> _full(items) <span class="keywordflow">if</span> (r == size) <span class="keywordflow">else</span> _partial(items, r)</div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(() <span class="keywordflow">if</span> r <span class="keywordflow">else</span> ((),))</div>
<div class="line"><span class="lineno">  679</span> </div>
<div class="line"><span class="lineno">  680</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a83c0a201e6bbd3b1a336c4b775963c6b" name="a83c0a201e6bbd3b1a336c4b775963c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c0a201e6bbd3b1a336c4b775963c6b">&#9670;&#160;</a></span>distribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.distribute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Distribute the items from *iterable* among *n* smaller iterables.

    &gt;&gt;&gt; group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])
    &gt;&gt;&gt; list(group_1)
    [1, 3, 5]
    &gt;&gt;&gt; list(group_2)
    [2, 4, 6]

If the length of *iterable* is not evenly divisible by *n*, then the
length of the returned iterables will not be identical:

    &gt;&gt;&gt; children = distribute(3, [1, 2, 3, 4, 5, 6, 7])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1, 4, 7], [2, 5], [3, 6]]

If the length of *iterable* is smaller than *n*, then the last returned
iterables will be empty:

    &gt;&gt;&gt; children = distribute(5, [1, 2, 3])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1], [2], [3], [], []]

This function uses :func:`itertools.tee` and may require significant
storage. If you need the order items in the smaller iterables to match the
original iterable, see :func:`divide`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1419</span><span class="keyword">def </span>distribute(n, iterable):</div>
<div class="line"><span class="lineno"> 1420</span>    <span class="stringliteral">&quot;&quot;&quot;Distribute the items from *iterable* among *n* smaller iterables.</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">        &gt;&gt;&gt; group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">        &gt;&gt;&gt; list(group_1)</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">        [1, 3, 5]</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">        &gt;&gt;&gt; list(group_2)</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">        [2, 4, 6]</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    If the length of *iterable* is not evenly divisible by *n*, then the</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    length of the returned iterables will not be identical:</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">        &gt;&gt;&gt; children = distribute(3, [1, 2, 3, 4, 5, 6, 7])</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">        &gt;&gt;&gt; [list(c) for c in children]</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">        [[1, 4, 7], [2, 5], [3, 6]]</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    If the length of *iterable* is smaller than *n*, then the last returned</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">    iterables will be empty:</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">        &gt;&gt;&gt; children = distribute(5, [1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">        &gt;&gt;&gt; [list(c) for c in children]</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">        [[1], [2], [3], [], []]</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    This function uses :func:`itertools.tee` and may require significant</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    storage. If you need the order items in the smaller iterables to match the</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    original iterable, see :func:`divide`.</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1447</span>    <span class="keywordflow">if</span> n &lt; 1:</div>
<div class="line"><span class="lineno"> 1448</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n must be at least 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 1449</span> </div>
<div class="line"><span class="lineno"> 1450</span>    children = tee(iterable, n)</div>
<div class="line"><span class="lineno"> 1451</span>    <span class="keywordflow">return</span> [islice(it, index, <span class="keywordtype">None</span>, n) <span class="keywordflow">for</span> index, it <span class="keywordflow">in</span> enumerate(children)]</div>
<div class="line"><span class="lineno"> 1452</span> </div>
<div class="line"><span class="lineno"> 1453</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4db1c5b2b6da960a1ab63de218124d0f" name="a4db1c5b2b6da960a1ab63de218124d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db1c5b2b6da960a1ab63de218124d0f">&#9670;&#160;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.divide </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Divide the elements from *iterable* into *n* parts, maintaining
order.

    &gt;&gt;&gt; group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])
    &gt;&gt;&gt; list(group_1)
    [1, 2, 3]
    &gt;&gt;&gt; list(group_2)
    [4, 5, 6]

If the length of *iterable* is not evenly divisible by *n*, then the
length of the returned iterables will not be identical:

    &gt;&gt;&gt; children = divide(3, [1, 2, 3, 4, 5, 6, 7])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1, 2, 3], [4, 5], [6, 7]]

If the length of the iterable is smaller than n, then the last returned
iterables will be empty:

    &gt;&gt;&gt; children = divide(5, [1, 2, 3])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1], [2], [3], [], []]

This function will exhaust the iterable before returning and may require
significant storage. If order is not important, see :func:`distribute`,
which does not first pull the iterable into memory.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1701</span><span class="keyword">def </span>divide(n, iterable):</div>
<div class="line"><span class="lineno"> 1702</span>    <span class="stringliteral">&quot;&quot;&quot;Divide the elements from *iterable* into *n* parts, maintaining</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    order.</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">        &gt;&gt;&gt; group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral">        &gt;&gt;&gt; list(group_1)</span></div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">        [1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">        &gt;&gt;&gt; list(group_2)</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">        [4, 5, 6]</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">    If the length of *iterable* is not evenly divisible by *n*, then the</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">    length of the returned iterables will not be identical:</span></div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral">        &gt;&gt;&gt; children = divide(3, [1, 2, 3, 4, 5, 6, 7])</span></div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral">        &gt;&gt;&gt; [list(c) for c in children]</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">        [[1, 2, 3], [4, 5], [6, 7]]</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    If the length of the iterable is smaller than n, then the last returned</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">    iterables will be empty:</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">        &gt;&gt;&gt; children = divide(5, [1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">        &gt;&gt;&gt; [list(c) for c in children]</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">        [[1], [2], [3], [], []]</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral">    This function will exhaust the iterable before returning and may require</span></div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">    significant storage. If order is not important, see :func:`distribute`,</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">    which does not first pull the iterable into memory.</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1730</span>    <span class="keywordflow">if</span> n &lt; 1:</div>
<div class="line"><span class="lineno"> 1731</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n must be at least 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 1732</span> </div>
<div class="line"><span class="lineno"> 1733</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1734</span>        iterable[:0]</div>
<div class="line"><span class="lineno"> 1735</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1736</span>        seq = tuple(iterable)</div>
<div class="line"><span class="lineno"> 1737</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1738</span>        seq = iterable</div>
<div class="line"><span class="lineno"> 1739</span> </div>
<div class="line"><span class="lineno"> 1740</span>    q, r = divmod(len(seq), n)</div>
<div class="line"><span class="lineno"> 1741</span> </div>
<div class="line"><span class="lineno"> 1742</span>    ret = []</div>
<div class="line"><span class="lineno"> 1743</span>    stop = 0</div>
<div class="line"><span class="lineno"> 1744</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, n + 1):</div>
<div class="line"><span class="lineno"> 1745</span>        start = stop</div>
<div class="line"><span class="lineno"> 1746</span>        stop += q + 1 <span class="keywordflow">if</span> i &lt;= r <span class="keywordflow">else</span> q</div>
<div class="line"><span class="lineno"> 1747</span>        ret.append(<a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(seq[start:stop]))</div>
<div class="line"><span class="lineno"> 1748</span> </div>
<div class="line"><span class="lineno"> 1749</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 1750</span> </div>
<div class="line"><span class="lineno"> 1751</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d9a2af8ed9c6a97fc0d47f59ab8dd52" name="a9d9a2af8ed9c6a97fc0d47f59ab8dd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9a2af8ed9c6a97fc0d47f59ab8dd52">&#9670;&#160;</a></span>exactly_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.exactly_n </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predicate</em> = <code>bool</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if exactly ``n`` items in the iterable are ``True``
according to the *predicate* function.

    &gt;&gt;&gt; exactly_n([True, True, False], 2)
    True
    &gt;&gt;&gt; exactly_n([True, True, False], 1)
    False
    &gt;&gt;&gt; exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x &lt; 3)
    True

The iterable will be advanced until ``n + 1`` truthy items are encountered,
so avoid calling it on infinite iterables.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2732</span><span class="keyword">def </span>exactly_n(iterable, n, predicate=bool):</div>
<div class="line"><span class="lineno"> 2733</span>    <span class="stringliteral">&quot;&quot;&quot;Return ``True`` if exactly ``n`` items in the iterable are ``True``</span></div>
<div class="line"><span class="lineno"> 2734</span><span class="stringliteral">    according to the *predicate* function.</span></div>
<div class="line"><span class="lineno"> 2735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2736</span><span class="stringliteral">        &gt;&gt;&gt; exactly_n([True, True, False], 2)</span></div>
<div class="line"><span class="lineno"> 2737</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2738</span><span class="stringliteral">        &gt;&gt;&gt; exactly_n([True, True, False], 1)</span></div>
<div class="line"><span class="lineno"> 2739</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2740</span><span class="stringliteral">        &gt;&gt;&gt; exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x &lt; 3)</span></div>
<div class="line"><span class="lineno"> 2741</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral">    The iterable will be advanced until ``n + 1`` truthy items are encountered,</span></div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral">    so avoid calling it on infinite iterables.</span></div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2747</span>    <span class="keywordflow">return</span> len(take(n + 1, filter(predicate, iterable))) == n</div>
<div class="line"><span class="lineno"> 2748</span> </div>
<div class="line"><span class="lineno"> 2749</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a75cf15114e78cfa3671c3635f0e07826" name="a75cf15114e78cfa3671c3635f0e07826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf15114e78cfa3671c3635f0e07826">&#9670;&#160;</a></span>filter_except()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.filter_except </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>validator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>exceptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable* for which the *validator* function does
not raise one of the specified *exceptions*.

*validator* is called for each item in *iterable*.
It should be a function that accepts one argument and raises an exception
if that item is not valid.

&gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None]
&gt;&gt;&gt; list(filter_except(int, iterable, ValueError, TypeError))
['1', '2', '4']

If an exception other than one given by *exceptions* is raised by
*validator*, it is raised like normal.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3235</span><span class="keyword">def </span>filter_except(validator, iterable, *exceptions):</div>
<div class="line"><span class="lineno"> 3236</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the items from *iterable* for which the *validator* function does</span></div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral">    not raise one of the specified *exceptions*.</span></div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral">    *validator* is called for each item in *iterable*.</span></div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">    It should be a function that accepts one argument and raises an exception</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral">    if that item is not valid.</span></div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral">    &gt;&gt;&gt; iterable = [&#39;1&#39;, &#39;2&#39;, &#39;three&#39;, &#39;4&#39;, None]</span></div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral">    &gt;&gt;&gt; list(filter_except(int, iterable, ValueError, TypeError))</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">    [&#39;1&#39;, &#39;2&#39;, &#39;4&#39;]</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">    If an exception other than one given by *exceptions* is raised by</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">    *validator*, it is raised like normal.</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3250</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno"> 3251</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3252</span>            validator(item)</div>
<div class="line"><span class="lineno"> 3253</span>        <span class="keywordflow">except</span> exceptions:</div>
<div class="line"><span class="lineno"> 3254</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 3255</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3256</span>            <span class="keywordflow">yield</span> item</div>
<div class="line"><span class="lineno"> 3257</span> </div>
<div class="line"><span class="lineno"> 3258</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d65f68012304f562994508d19d68b4b" name="a3d65f68012304f562994508d19d68b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d65f68012304f562994508d19d68b4b">&#9670;&#160;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.first </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a67c5ce81dc3269a7393daed34ec304f1">_marker</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the first item of *iterable*, or *default* if *iterable* is
empty.

    &gt;&gt;&gt; first([0, 1, 2, 3])
    0
    &gt;&gt;&gt; first([], 'some default')
    'some default'

If *default* is not provided and there are no items in the iterable,
raise ``ValueError``.

:func:`first` is useful when you have a generator of expensive-to-retrieve
values and want any arbitrary one. It is marginally shorter than
``next(iter(iterable), default)``.</pre> <div class="fragment"><div class="line"><span class="lineno">  160</span><span class="keyword">def </span>first(iterable, default=_marker):</div>
<div class="line"><span class="lineno">  161</span>    <span class="stringliteral">&quot;&quot;&quot;Return the first item of *iterable*, or *default* if *iterable* is</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    empty.</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">        &gt;&gt;&gt; first([0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        0</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">        &gt;&gt;&gt; first([], &#39;some default&#39;)</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">        &#39;some default&#39;</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    If *default* is not provided and there are no items in the iterable,</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    raise ``ValueError``.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    :func:`first` is useful when you have a generator of expensive-to-retrieve</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    values and want any arbitrary one. It is marginally shorter than</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    ``next(iter(iterable), default)``.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  177</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  178</span>        <span class="keywordflow">return</span> next(<a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable))</div>
<div class="line"><span class="lineno">  179</span>    <span class="keywordflow">except</span> StopIteration <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  180</span>        <span class="keywordflow">if</span> default <span class="keywordflow">is</span> _marker:</div>
<div class="line"><span class="lineno">  181</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  182</span>                <span class="stringliteral">&#39;first() was called on an empty iterable, and no &#39;</span></div>
<div class="line"><span class="lineno">  183</span>                <span class="stringliteral">&#39;default value was provided.&#39;</span></div>
<div class="line"><span class="lineno">  184</span>            ) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  185</span>        <span class="keywordflow">return</span> default</div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab26be38b59e90b14984ed58d3b3bbc82" name="ab26be38b59e90b14984ed58d3b3bbc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26be38b59e90b14984ed58d3b3bbc82">&#9670;&#160;</a></span>groupby_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.groupby_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keyfunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valuefunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reducefunc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An extension of :func:`itertools.groupby` that can apply transformations
to the grouped data.

* *keyfunc* is a function computing a key value for each item in *iterable*
* *valuefunc* is a function that transforms the individual items from
  *iterable* after grouping
* *reducefunc* is a function that transforms each group of items

&gt;&gt;&gt; iterable = 'aAAbBBcCC'
&gt;&gt;&gt; keyfunc = lambda k: k.upper()
&gt;&gt;&gt; valuefunc = lambda v: v.lower()
&gt;&gt;&gt; reducefunc = lambda g: ''.join(g)
&gt;&gt;&gt; list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))
[('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]

Each optional argument defaults to an identity function if not specified.

:func:`groupby_transform` is useful when grouping elements of an iterable
using a separate iterable as the key. To do this, :func:`zip` the iterables
and pass a *keyfunc* that extracts the first element and a *valuefunc*
that extracts the second element::

    &gt;&gt;&gt; from operator import itemgetter
    &gt;&gt;&gt; keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]
    &gt;&gt;&gt; values = 'abcdefghi'
    &gt;&gt;&gt; iterable = zip(keys, values)
    &gt;&gt;&gt; grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))
    &gt;&gt;&gt; [(k, ''.join(g)) for k, g in grouper]
    [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]

Note that the order of items in the iterable is significant.
Only adjacent items are grouped together, so if you don't want any
duplicate groups, you should sort the iterable by the key function.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1844</span><span class="keyword">def </span>groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):</div>
<div class="line"><span class="lineno"> 1845</span>    <span class="stringliteral">&quot;&quot;&quot;An extension of :func:`itertools.groupby` that can apply transformations</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">    to the grouped data.</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    * *keyfunc* is a function computing a key value for each item in *iterable*</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    * *valuefunc* is a function that transforms the individual items from</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">      *iterable* after grouping</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    * *reducefunc* is a function that transforms each group of items</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    &gt;&gt;&gt; iterable = &#39;aAAbBBcCC&#39;</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    &gt;&gt;&gt; keyfunc = lambda k: k.upper()</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    &gt;&gt;&gt; valuefunc = lambda v: v.lower()</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    &gt;&gt;&gt; reducefunc = lambda g: &#39;&#39;.join(g)</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    &gt;&gt;&gt; list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral">    [(&#39;A&#39;, &#39;aaa&#39;), (&#39;B&#39;, &#39;bbb&#39;), (&#39;C&#39;, &#39;ccc&#39;)]</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral">    Each optional argument defaults to an identity function if not specified.</span></div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">    :func:`groupby_transform` is useful when grouping elements of an iterable</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    using a separate iterable as the key. To do this, :func:`zip` the iterables</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">    and pass a *keyfunc* that extracts the first element and a *valuefunc*</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">    that extracts the second element::</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">        &gt;&gt;&gt; from operator import itemgetter</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">        &gt;&gt;&gt; keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">        &gt;&gt;&gt; values = &#39;abcdefghi&#39;</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">        &gt;&gt;&gt; iterable = zip(keys, values)</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">        &gt;&gt;&gt; grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))</span></div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">        &gt;&gt;&gt; [(k, &#39;&#39;.join(g)) for k, g in grouper]</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">        [(0, &#39;ab&#39;), (1, &#39;cde&#39;), (2, &#39;fgh&#39;), (3, &#39;i&#39;)]</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    Note that the order of items in the iterable is significant.</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">    Only adjacent items are grouped together, so if you don&#39;t want any</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    duplicate groups, you should sort the iterable by the key function.</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1880</span>    ret = groupby(iterable, keyfunc)</div>
<div class="line"><span class="lineno"> 1881</span>    <span class="keywordflow">if</span> valuefunc:</div>
<div class="line"><span class="lineno"> 1882</span>        ret = ((k, map(valuefunc, g)) <span class="keywordflow">for</span> k, g <span class="keywordflow">in</span> ret)</div>
<div class="line"><span class="lineno"> 1883</span>    <span class="keywordflow">if</span> reducefunc:</div>
<div class="line"><span class="lineno"> 1884</span>        ret = ((k, reducefunc(g)) <span class="keywordflow">for</span> k, g <span class="keywordflow">in</span> ret)</div>
<div class="line"><span class="lineno"> 1885</span> </div>
<div class="line"><span class="lineno"> 1886</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 1887</span> </div>
<div class="line"><span class="lineno"> 1888</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c641087a4891d3ac5b40616a3394bd5" name="a9c641087a4891d3ac5b40616a3394bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c641087a4891d3ac5b40616a3394bd5">&#9670;&#160;</a></span>ichunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.ichunked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Break *iterable* into sub-iterables with *n* elements each.
:func:`ichunked` is like :func:`chunked`, but it yields iterables
instead of lists.

If the sub-iterables are read in order, the elements of *iterable*
won't be stored in memory.
If they are read out of order, :func:`itertools.tee` is used to cache
elements as necessary.

&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; all_chunks = ichunked(count(), 4)
&gt;&gt;&gt; c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)
&gt;&gt;&gt; list(c_2)  # c_1's elements have been cached; c_3's haven't been
[4, 5, 6, 7]
&gt;&gt;&gt; list(c_1)
[0, 1, 2, 3]
&gt;&gt;&gt; list(c_3)
[8, 9, 10, 11]</pre> <div class="fragment"><div class="line"><span class="lineno"> 3158</span><span class="keyword">def </span>ichunked(iterable, n):</div>
<div class="line"><span class="lineno"> 3159</span>    <span class="stringliteral">&quot;&quot;&quot;Break *iterable* into sub-iterables with *n* elements each.</span></div>
<div class="line"><span class="lineno"> 3160</span><span class="stringliteral">    :func:`ichunked` is like :func:`chunked`, but it yields iterables</span></div>
<div class="line"><span class="lineno"> 3161</span><span class="stringliteral">    instead of lists.</span></div>
<div class="line"><span class="lineno"> 3162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3163</span><span class="stringliteral">    If the sub-iterables are read in order, the elements of *iterable*</span></div>
<div class="line"><span class="lineno"> 3164</span><span class="stringliteral">    won&#39;t be stored in memory.</span></div>
<div class="line"><span class="lineno"> 3165</span><span class="stringliteral">    If they are read out of order, :func:`itertools.tee` is used to cache</span></div>
<div class="line"><span class="lineno"> 3166</span><span class="stringliteral">    elements as necessary.</span></div>
<div class="line"><span class="lineno"> 3167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3168</span><span class="stringliteral">    &gt;&gt;&gt; from itertools import count</span></div>
<div class="line"><span class="lineno"> 3169</span><span class="stringliteral">    &gt;&gt;&gt; all_chunks = ichunked(count(), 4)</span></div>
<div class="line"><span class="lineno"> 3170</span><span class="stringliteral">    &gt;&gt;&gt; c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)</span></div>
<div class="line"><span class="lineno"> 3171</span><span class="stringliteral">    &gt;&gt;&gt; list(c_2)  # c_1&#39;s elements have been cached; c_3&#39;s haven&#39;t been</span></div>
<div class="line"><span class="lineno"> 3172</span><span class="stringliteral">    [4, 5, 6, 7]</span></div>
<div class="line"><span class="lineno"> 3173</span><span class="stringliteral">    &gt;&gt;&gt; list(c_1)</span></div>
<div class="line"><span class="lineno"> 3174</span><span class="stringliteral">    [0, 1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 3175</span><span class="stringliteral">    &gt;&gt;&gt; list(c_3)</span></div>
<div class="line"><span class="lineno"> 3176</span><span class="stringliteral">    [8, 9, 10, 11]</span></div>
<div class="line"><span class="lineno"> 3177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3178</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3179</span>    source = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 3180</span> </div>
<div class="line"><span class="lineno"> 3181</span>    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno"> 3182</span>        <span class="comment"># Check to see whether we&#39;re at the end of the source iterable</span></div>
<div class="line"><span class="lineno"> 3183</span>        item = next(source, _marker)</div>
<div class="line"><span class="lineno"> 3184</span>        <span class="keywordflow">if</span> item <span class="keywordflow">is</span> _marker:</div>
<div class="line"><span class="lineno"> 3185</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 3186</span> </div>
<div class="line"><span class="lineno"> 3187</span>        <span class="comment"># Clone the source and yield an n-length slice</span></div>
<div class="line"><span class="lineno"> 3188</span>        source, it = tee(chain([item], source))</div>
<div class="line"><span class="lineno"> 3189</span>        <span class="keywordflow">yield</span> islice(it, n)</div>
<div class="line"><span class="lineno"> 3190</span> </div>
<div class="line"><span class="lineno"> 3191</span>        <span class="comment"># Advance the source iterable</span></div>
<div class="line"><span class="lineno"> 3192</span>        consume(source, n)</div>
<div class="line"><span class="lineno"> 3193</span> </div>
<div class="line"><span class="lineno"> 3194</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a64c69fff987516a452aa90c06d24885e" name="a64c69fff987516a452aa90c06d24885e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c69fff987516a452aa90c06d24885e">&#9670;&#160;</a></span>ilen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.ilen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of items in *iterable*.

    &gt;&gt;&gt; ilen(x for x in range(1000000) if x % 3 == 0)
    333334

This consumes the iterable, so handle with care.</pre> <div class="fragment"><div class="line"><span class="lineno">  469</span><span class="keyword">def </span>ilen(iterable):</div>
<div class="line"><span class="lineno">  470</span>    <span class="stringliteral">&quot;&quot;&quot;Return the number of items in *iterable*.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        &gt;&gt;&gt; ilen(x for x in range(1000000) if x % 3 == 0)</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        333334</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    This consumes the iterable, so handle with care.</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  478</span>    <span class="comment"># This approach was selected because benchmarks showed it&#39;s likely the</span></div>
<div class="line"><span class="lineno">  479</span>    <span class="comment"># fastest of the known implementations at the time of writing.</span></div>
<div class="line"><span class="lineno">  480</span>    <span class="comment"># See GitHub tracker: #236, #230.</span></div>
<div class="line"><span class="lineno">  481</span>    counter = count()</div>
<div class="line"><span class="lineno">  482</span>    deque(zip(iterable, counter), maxlen=0)</div>
<div class="line"><span class="lineno">  483</span>    <span class="keywordflow">return</span> next(counter)</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a550537ce14e8b31de79d09cbf72ab2" name="a6a550537ce14e8b31de79d09cbf72ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a550537ce14e8b31de79d09cbf72ab2">&#9670;&#160;</a></span>interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.interleave </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new iterable yielding from each iterable in turn,
until the shortest is exhausted.

    &gt;&gt;&gt; list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))
    [1, 4, 6, 2, 5, 7]

For a version that doesn't terminate after the shortest iterable is
exhausted, see :func:`interleave_longest`.</pre> <div class="fragment"><div class="line"><span class="lineno">  990</span><span class="keyword">def </span>interleave(*iterables):</div>
<div class="line"><span class="lineno">  991</span>    <span class="stringliteral">&quot;&quot;&quot;Return a new iterable yielding from each iterable in turn,</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    until the shortest is exhausted.</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">        &gt;&gt;&gt; list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">        [1, 4, 6, 2, 5, 7]</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    For a version that doesn&#39;t terminate after the shortest iterable is</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    exhausted, see :func:`interleave_longest`.</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1001</span>    <span class="keywordflow">return</span> chain.from_iterable(zip(*iterables))</div>
<div class="line"><span class="lineno"> 1002</span> </div>
<div class="line"><span class="lineno"> 1003</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1803700181e28e4201ab209a3da924d" name="aa1803700181e28e4201ab209a3da924d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1803700181e28e4201ab209a3da924d">&#9670;&#160;</a></span>interleave_longest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.interleave_longest </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new iterable yielding from each iterable in turn,
skipping any that are exhausted.

    &gt;&gt;&gt; list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))
    [1, 4, 6, 2, 5, 7, 3, 8]

This function produces the same output as :func:`roundrobin`, but may
perform better for some inputs (in particular when the number of iterables
is large).</pre> <div class="fragment"><div class="line"><span class="lineno"> 1004</span><span class="keyword">def </span>interleave_longest(*iterables):</div>
<div class="line"><span class="lineno"> 1005</span>    <span class="stringliteral">&quot;&quot;&quot;Return a new iterable yielding from each iterable in turn,</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    skipping any that are exhausted.</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">        &gt;&gt;&gt; list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">        [1, 4, 6, 2, 5, 7, 3, 8]</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    This function produces the same output as :func:`roundrobin`, but may</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    perform better for some inputs (in particular when the number of iterables</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    is large).</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1016</span>    i = chain.from_iterable(zip_longest(*iterables, fillvalue=_marker))</div>
<div class="line"><span class="lineno"> 1017</span>    <span class="keywordflow">return</span> (x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> i <span class="keywordflow">if</span> x <span class="keywordflow">is</span> <span class="keywordflow">not</span> _marker)</div>
<div class="line"><span class="lineno"> 1018</span> </div>
<div class="line"><span class="lineno"> 1019</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a511fc6f0275c765800910360d1f96dc0" name="a511fc6f0275c765800910360d1f96dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511fc6f0275c765800910360d1f96dc0">&#9670;&#160;</a></span>intersperse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.intersperse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intersperse filler element *e* among the items in *iterable*, leaving
*n* items between each filler element.

    &gt;&gt;&gt; list(intersperse('!', [1, 2, 3, 4, 5]))
    [1, '!', 2, '!', 3, '!', 4, '!', 5]

    &gt;&gt;&gt; list(intersperse(None, [1, 2, 3, 4, 5], n=2))
    [1, 2, None, 3, 4, None, 5]</pre> <div class="fragment"><div class="line"><span class="lineno">  681</span><span class="keyword">def </span>intersperse(e, iterable, n=1):</div>
<div class="line"><span class="lineno">  682</span>    <span class="stringliteral">&quot;&quot;&quot;Intersperse filler element *e* among the items in *iterable*, leaving</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    *n* items between each filler element.</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        &gt;&gt;&gt; list(intersperse(&#39;!&#39;, [1, 2, 3, 4, 5]))</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">        [1, &#39;!&#39;, 2, &#39;!&#39;, 3, &#39;!&#39;, 4, &#39;!&#39;, 5]</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        &gt;&gt;&gt; list(intersperse(None, [1, 2, 3, 4, 5], n=2))</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        [1, 2, None, 3, 4, None, 5]</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  692</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno">  693</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n must be &gt; 0&#39;</span>)</div>
<div class="line"><span class="lineno">  694</span>    <span class="keywordflow">elif</span> n == 1:</div>
<div class="line"><span class="lineno">  695</span>        <span class="comment"># interleave(repeat(e), iterable) -&gt; e, x_0, e, e, x_1, e, x_2...</span></div>
<div class="line"><span class="lineno">  696</span>        <span class="comment"># islice(..., 1, None) -&gt; x_0, e, e, x_1, e, x_2...</span></div>
<div class="line"><span class="lineno">  697</span>        <span class="keywordflow">return</span> islice(interleave(repeat(e), iterable), 1, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  698</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  699</span>        <span class="comment"># interleave(filler, chunks) -&gt; [e], [x_0, x_1], [e], [x_2, x_3]...</span></div>
<div class="line"><span class="lineno">  700</span>        <span class="comment"># islice(..., 1, None) -&gt; [x_0, x_1], [e], [x_2, x_3]...</span></div>
<div class="line"><span class="lineno">  701</span>        <span class="comment"># flatten(...) -&gt; x_0, x_1, e, x_2, x_3...</span></div>
<div class="line"><span class="lineno">  702</span>        filler = repeat([e])</div>
<div class="line"><span class="lineno">  703</span>        chunks = chunked(iterable, n)</div>
<div class="line"><span class="lineno">  704</span>        <span class="keywordflow">return</span> flatten(islice(interleave(filler, chunks), 1, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  705</span> </div>
<div class="line"><span class="lineno">  706</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a81cbbbf641f0a69938658857aacd4a4b" name="a81cbbbf641f0a69938658857aacd4a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cbbbf641f0a69938658857aacd4a4b">&#9670;&#160;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.is_sorted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns ``True`` if the items of iterable are in sorted order, and
``False`` otherwise. *key* and *reverse* have the same meaning that they do
in the built-in :func:`sorted` function.

&gt;&gt;&gt; is_sorted(['1', '2', '3', '4', '5'], key=int)
True
&gt;&gt;&gt; is_sorted([5, 4, 3, 1, 2], reverse=True)
False

The function returns ``False`` after encountering the first out-of-order
item. If there are no out-of-order items, the iterable is exhausted.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3377</span><span class="keyword">def </span>is_sorted(iterable, key=None, reverse=False):</div>
<div class="line"><span class="lineno"> 3378</span>    <span class="stringliteral">&quot;&quot;&quot;Returns ``True`` if the items of iterable are in sorted order, and</span></div>
<div class="line"><span class="lineno"> 3379</span><span class="stringliteral">    ``False`` otherwise. *key* and *reverse* have the same meaning that they do</span></div>
<div class="line"><span class="lineno"> 3380</span><span class="stringliteral">    in the built-in :func:`sorted` function.</span></div>
<div class="line"><span class="lineno"> 3381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3382</span><span class="stringliteral">    &gt;&gt;&gt; is_sorted([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;], key=int)</span></div>
<div class="line"><span class="lineno"> 3383</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 3384</span><span class="stringliteral">    &gt;&gt;&gt; is_sorted([5, 4, 3, 1, 2], reverse=True)</span></div>
<div class="line"><span class="lineno"> 3385</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 3386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3387</span><span class="stringliteral">    The function returns ``False`` after encountering the first out-of-order</span></div>
<div class="line"><span class="lineno"> 3388</span><span class="stringliteral">    item. If there are no out-of-order items, the iterable is exhausted.</span></div>
<div class="line"><span class="lineno"> 3389</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3390</span> </div>
<div class="line"><span class="lineno"> 3391</span>    compare = lt <span class="keywordflow">if</span> reverse <span class="keywordflow">else</span> gt</div>
<div class="line"><span class="lineno"> 3392</span>    it = iterable <span class="keywordflow">if</span> (key <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> map(key, iterable)</div>
<div class="line"><span class="lineno"> 3393</span>    <span class="keywordflow">return</span> <span class="keywordflow">not</span> any(starmap(compare, pairwise(it)))</div>
<div class="line"><span class="lineno"> 3394</span> </div>
<div class="line"><span class="lineno"> 3395</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a17348f255369895951eeb91ce27eab84" name="a17348f255369895951eeb91ce27eab84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17348f255369895951eeb91ce27eab84">&#9670;&#160;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.iterate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``start``, ``func(start)``, ``func(func(start))``, ...

&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; list(islice(iterate(lambda x: 2*x, 1), 10))
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]</pre> <div class="fragment"><div class="line"><span class="lineno">  486</span><span class="keyword">def </span>iterate(func, start):</div>
<div class="line"><span class="lineno">  487</span>    <span class="stringliteral">&quot;&quot;&quot;Return ``start``, ``func(start)``, ``func(func(start))``, ...</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    &gt;&gt;&gt; from itertools import islice</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    &gt;&gt;&gt; list(islice(iterate(lambda x: 2*x, 1), 10))</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  495</span>        <span class="keywordflow">yield</span> start</div>
<div class="line"><span class="lineno">  496</span>        start = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(start)</div>
<div class="line"><span class="lineno">  497</span> </div>
<div class="line"><span class="lineno">  498</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8451a225701bd3bc60ca00f234062208" name="a8451a225701bd3bc60ca00f234062208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8451a225701bd3bc60ca00f234062208">&#9670;&#160;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a67c5ce81dc3269a7393daed34ec304f1">_marker</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the last item of *iterable*, or *default* if *iterable* is
empty.

    &gt;&gt;&gt; last([0, 1, 2, 3])
    3
    &gt;&gt;&gt; last([], 'some default')
    'some default'

If *default* is not provided and there are no items in the iterable,
raise ``ValueError``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  188</span><span class="keyword">def </span>last(iterable, default=_marker):</div>
<div class="line"><span class="lineno">  189</span>    <span class="stringliteral">&quot;&quot;&quot;Return the last item of *iterable*, or *default* if *iterable* is</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    empty.</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        &gt;&gt;&gt; last([0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        3</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">        &gt;&gt;&gt; last([], &#39;some default&#39;)</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        &#39;some default&#39;</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    If *default* is not provided and there are no items in the iterable,</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    raise ``ValueError``.</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  201</span>        <span class="keywordflow">if</span> isinstance(iterable, Sequence):</div>
<div class="line"><span class="lineno">  202</span>            <span class="keywordflow">return</span> iterable[-1]</div>
<div class="line"><span class="lineno">  203</span>        <span class="comment"># Work around https://bugs.python.org/issue38525</span></div>
<div class="line"><span class="lineno">  204</span>        <span class="keywordflow">elif</span> hasattr(iterable, <span class="stringliteral">&#39;__reversed__&#39;</span>) <span class="keywordflow">and</span> (hexversion != 0x030800F0):</div>
<div class="line"><span class="lineno">  205</span>            <span class="keywordflow">return</span> next(reversed(iterable))</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  207</span>            <span class="keywordflow">return</span> deque(iterable, maxlen=1)[-1]</div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordflow">except</span> (IndexError, TypeError, StopIteration):</div>
<div class="line"><span class="lineno">  209</span>        <span class="keywordflow">if</span> default <span class="keywordflow">is</span> _marker:</div>
<div class="line"><span class="lineno">  210</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  211</span>                <span class="stringliteral">&#39;last() was called on an empty iterable, and no default was &#39;</span></div>
<div class="line"><span class="lineno">  212</span>                <span class="stringliteral">&#39;provided.&#39;</span></div>
<div class="line"><span class="lineno">  213</span>            )</div>
<div class="line"><span class="lineno">  214</span>        <span class="keywordflow">return</span> default</div>
<div class="line"><span class="lineno">  215</span> </div>
<div class="line"><span class="lineno">  216</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a05e18ee5ccec970465321f705ee1e11b" name="a05e18ee5ccec970465321f705ee1e11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e18ee5ccec970465321f705ee1e11b">&#9670;&#160;</a></span>locate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.locate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em> = <code>bool</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the index of each item in *iterable* for which *pred* returns
``True``.

*pred* defaults to :func:`bool`, which will select truthy items:

    &gt;&gt;&gt; list(locate([0, 1, 1, 0, 1, 0, 0]))
    [1, 2, 4]

Set *pred* to a custom function to, e.g., find the indexes for a particular
item.

    &gt;&gt;&gt; list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))
    [1, 3]

If *window_size* is given, then the *pred* function will be called with
that many items. This enables searching for sub-sequences:

    &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
    &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)
    &gt;&gt;&gt; list(locate(iterable, pred=pred, window_size=3))
    [1, 5, 9]

Use with :func:`seekable` to find indexes and then retrieve the associated
items:

    &gt;&gt;&gt; from itertools import count
    &gt;&gt;&gt; from more_itertools import seekable
    &gt;&gt;&gt; source = (3 * n + 1 if (n % 2) else n // 2 for n in count())
    &gt;&gt;&gt; it = seekable(source)
    &gt;&gt;&gt; pred = lambda x: x &gt; 100
    &gt;&gt;&gt; indexes = locate(it, pred=pred)
    &gt;&gt;&gt; i = next(indexes)
    &gt;&gt;&gt; it.seek(i)
    &gt;&gt;&gt; next(it)
    106</pre> <div class="fragment"><div class="line"><span class="lineno"> 2159</span><span class="keyword">def </span>locate(iterable, pred=bool, window_size=None):</div>
<div class="line"><span class="lineno"> 2160</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the index of each item in *iterable* for which *pred* returns</span></div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">    ``True``.</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral">    *pred* defaults to :func:`bool`, which will select truthy items:</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral">        &gt;&gt;&gt; list(locate([0, 1, 1, 0, 1, 0, 0]))</span></div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">        [1, 2, 4]</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">    Set *pred* to a custom function to, e.g., find the indexes for a particular</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">    item.</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">        &gt;&gt;&gt; list(locate([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;], lambda x: x == &#39;b&#39;))</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral">        [1, 3]</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">    If *window_size* is given, then the *pred* function will be called with</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">    that many items. This enables searching for sub-sequences:</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)</span></div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">        &gt;&gt;&gt; list(locate(iterable, pred=pred, window_size=3))</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">        [1, 5, 9]</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2182</span><span class="stringliteral">    Use with :func:`seekable` to find indexes and then retrieve the associated</span></div>
<div class="line"><span class="lineno"> 2183</span><span class="stringliteral">    items:</span></div>
<div class="line"><span class="lineno"> 2184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2185</span><span class="stringliteral">        &gt;&gt;&gt; from itertools import count</span></div>
<div class="line"><span class="lineno"> 2186</span><span class="stringliteral">        &gt;&gt;&gt; from more_itertools import seekable</span></div>
<div class="line"><span class="lineno"> 2187</span><span class="stringliteral">        &gt;&gt;&gt; source = (3 * n + 1 if (n % 2) else n // 2 for n in count())</span></div>
<div class="line"><span class="lineno"> 2188</span><span class="stringliteral">        &gt;&gt;&gt; it = seekable(source)</span></div>
<div class="line"><span class="lineno"> 2189</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda x: x &gt; 100</span></div>
<div class="line"><span class="lineno"> 2190</span><span class="stringliteral">        &gt;&gt;&gt; indexes = locate(it, pred=pred)</span></div>
<div class="line"><span class="lineno"> 2191</span><span class="stringliteral">        &gt;&gt;&gt; i = next(indexes)</span></div>
<div class="line"><span class="lineno"> 2192</span><span class="stringliteral">        &gt;&gt;&gt; it.seek(i)</span></div>
<div class="line"><span class="lineno"> 2193</span><span class="stringliteral">        &gt;&gt;&gt; next(it)</span></div>
<div class="line"><span class="lineno"> 2194</span><span class="stringliteral">        106</span></div>
<div class="line"><span class="lineno"> 2195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2196</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2197</span>    <span class="keywordflow">if</span> window_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2198</span>        <span class="keywordflow">return</span> compress(count(), map(pred, iterable))</div>
<div class="line"><span class="lineno"> 2199</span> </div>
<div class="line"><span class="lineno"> 2200</span>    <span class="keywordflow">if</span> window_size &lt; 1:</div>
<div class="line"><span class="lineno"> 2201</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window size must be at least 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 2202</span> </div>
<div class="line"><span class="lineno"> 2203</span>    it = windowed(iterable, window_size, fillvalue=_marker)</div>
<div class="line"><span class="lineno"> 2204</span>    <span class="keywordflow">return</span> compress(count(), starmap(pred, it))</div>
<div class="line"><span class="lineno"> 2205</span> </div>
<div class="line"><span class="lineno"> 2206</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b0712cc8a0f49172287bf947e453677" name="a2b0712cc8a0f49172287bf947e453677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0712cc8a0f49172287bf947e453677">&#9670;&#160;</a></span>lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.lstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, but strip any from the beginning
for which *pred* returns ``True``.

For example, to remove a set of items from the start of an iterable:

    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)
    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}
    &gt;&gt;&gt; list(lstrip(iterable, pred))
    [1, 2, None, 3, False, None]

This function is analogous to to :func:`str.lstrip`, and is essentially
an wrapper for :func:`itertools.dropwhile`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2207</span><span class="keyword">def </span>lstrip(iterable, pred):</div>
<div class="line"><span class="lineno"> 2208</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the items from *iterable*, but strip any from the beginning</span></div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral">    for which *pred* returns ``True``.</span></div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">    For example, to remove a set of items from the start of an iterable:</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral">        &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)</span></div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda x: x in {None, False, &#39;&#39;}</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral">        &gt;&gt;&gt; list(lstrip(iterable, pred))</span></div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">        [1, 2, None, 3, False, None]</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">    This function is analogous to to :func:`str.lstrip`, and is essentially</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">    an wrapper for :func:`itertools.dropwhile`.</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2222</span>    <span class="keywordflow">return</span> dropwhile(pred, iterable)</div>
<div class="line"><span class="lineno"> 2223</span> </div>
<div class="line"><span class="lineno"> 2224</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a21e8616c9a2d21c6b3b81e351225bf60" name="a21e8616c9a2d21c6b3b81e351225bf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e8616c9a2d21c6b3b81e351225bf60">&#9670;&#160;</a></span>make_decorator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.make_decorator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrapping_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a decorator version of *wrapping_func*, which is a function that
modifies an iterable. *result_index* is the position in that function's
signature where the iterable goes.

This lets you use itertools on the "production end," i.e. at function
definition. This can augment what the function returns without changing the
function's code.

For example, to produce a decorator version of :func:`chunked`:

    &gt;&gt;&gt; from more_itertools import chunked
    &gt;&gt;&gt; chunker = make_decorator(chunked, result_index=0)
    &gt;&gt;&gt; @chunker(3)
    ... def iter_range(n):
    ...     return iter(range(n))
    ...
    &gt;&gt;&gt; list(iter_range(9))
    [[0, 1, 2], [3, 4, 5], [6, 7, 8]]

To only allow truthy items to be returned:

    &gt;&gt;&gt; truth_serum = make_decorator(filter, result_index=1)
    &gt;&gt;&gt; @truth_serum(bool)
    ... def boolean_test():
    ...     return [0, 1, '', ' ', False, True]
    ...
    &gt;&gt;&gt; list(boolean_test())
    [1, ' ', True]

The :func:`peekable` and :func:`seekable` wrappers make for practical
decorators:

    &gt;&gt;&gt; from more_itertools import peekable
    &gt;&gt;&gt; peekable_function = make_decorator(peekable)
    &gt;&gt;&gt; @peekable_function()
    ... def str_range(*args):
    ...     return (str(x) for x in range(*args))
    ...
    &gt;&gt;&gt; it = str_range(1, 20, 2)
    &gt;&gt;&gt; next(it), next(it), next(it)
    ('1', '3', '5')
    &gt;&gt;&gt; it.peek()
    '7'
    &gt;&gt;&gt; next(it)
    '7'</pre> <div class="fragment"><div class="line"><span class="lineno"> 2760</span><span class="keyword">def </span>make_decorator(wrapping_func, result_index=0):</div>
<div class="line"><span class="lineno"> 2761</span>    <span class="stringliteral">&quot;&quot;&quot;Return a decorator version of *wrapping_func*, which is a function that</span></div>
<div class="line"><span class="lineno"> 2762</span><span class="stringliteral">    modifies an iterable. *result_index* is the position in that function&#39;s</span></div>
<div class="line"><span class="lineno"> 2763</span><span class="stringliteral">    signature where the iterable goes.</span></div>
<div class="line"><span class="lineno"> 2764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2765</span><span class="stringliteral">    This lets you use itertools on the &quot;production end,&quot; i.e. at function</span></div>
<div class="line"><span class="lineno"> 2766</span><span class="stringliteral">    definition. This can augment what the function returns without changing the</span></div>
<div class="line"><span class="lineno"> 2767</span><span class="stringliteral">    function&#39;s code.</span></div>
<div class="line"><span class="lineno"> 2768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2769</span><span class="stringliteral">    For example, to produce a decorator version of :func:`chunked`:</span></div>
<div class="line"><span class="lineno"> 2770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2771</span><span class="stringliteral">        &gt;&gt;&gt; from more_itertools import chunked</span></div>
<div class="line"><span class="lineno"> 2772</span><span class="stringliteral">        &gt;&gt;&gt; chunker = make_decorator(chunked, result_index=0)</span></div>
<div class="line"><span class="lineno"> 2773</span><span class="stringliteral">        &gt;&gt;&gt; @chunker(3)</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="stringliteral">        ... def iter_range(n):</span></div>
<div class="line"><span class="lineno"> 2775</span><span class="stringliteral">        ...     return iter(range(n))</span></div>
<div class="line"><span class="lineno"> 2776</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 2777</span><span class="stringliteral">        &gt;&gt;&gt; list(iter_range(9))</span></div>
<div class="line"><span class="lineno"> 2778</span><span class="stringliteral">        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]</span></div>
<div class="line"><span class="lineno"> 2779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2780</span><span class="stringliteral">    To only allow truthy items to be returned:</span></div>
<div class="line"><span class="lineno"> 2781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2782</span><span class="stringliteral">        &gt;&gt;&gt; truth_serum = make_decorator(filter, result_index=1)</span></div>
<div class="line"><span class="lineno"> 2783</span><span class="stringliteral">        &gt;&gt;&gt; @truth_serum(bool)</span></div>
<div class="line"><span class="lineno"> 2784</span><span class="stringliteral">        ... def boolean_test():</span></div>
<div class="line"><span class="lineno"> 2785</span><span class="stringliteral">        ...     return [0, 1, &#39;&#39;, &#39; &#39;, False, True]</span></div>
<div class="line"><span class="lineno"> 2786</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 2787</span><span class="stringliteral">        &gt;&gt;&gt; list(boolean_test())</span></div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">        [1, &#39; &#39;, True]</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">    The :func:`peekable` and :func:`seekable` wrappers make for practical</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">    decorators:</span></div>
<div class="line"><span class="lineno"> 2792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2793</span><span class="stringliteral">        &gt;&gt;&gt; from more_itertools import peekable</span></div>
<div class="line"><span class="lineno"> 2794</span><span class="stringliteral">        &gt;&gt;&gt; peekable_function = make_decorator(peekable)</span></div>
<div class="line"><span class="lineno"> 2795</span><span class="stringliteral">        &gt;&gt;&gt; @peekable_function()</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral">        ... def str_range(*args):</span></div>
<div class="line"><span class="lineno"> 2797</span><span class="stringliteral">        ...     return (str(x) for x in range(*args))</span></div>
<div class="line"><span class="lineno"> 2798</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 2799</span><span class="stringliteral">        &gt;&gt;&gt; it = str_range(1, 20, 2)</span></div>
<div class="line"><span class="lineno"> 2800</span><span class="stringliteral">        &gt;&gt;&gt; next(it), next(it), next(it)</span></div>
<div class="line"><span class="lineno"> 2801</span><span class="stringliteral">        (&#39;1&#39;, &#39;3&#39;, &#39;5&#39;)</span></div>
<div class="line"><span class="lineno"> 2802</span><span class="stringliteral">        &gt;&gt;&gt; it.peek()</span></div>
<div class="line"><span class="lineno"> 2803</span><span class="stringliteral">        &#39;7&#39;</span></div>
<div class="line"><span class="lineno"> 2804</span><span class="stringliteral">        &gt;&gt;&gt; next(it)</span></div>
<div class="line"><span class="lineno"> 2805</span><span class="stringliteral">        &#39;7&#39;</span></div>
<div class="line"><span class="lineno"> 2806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2807</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2808</span>    <span class="comment"># See https://sites.google.com/site/bbayles/index/decorator_factory for</span></div>
<div class="line"><span class="lineno"> 2809</span>    <span class="comment"># notes on how this works.</span></div>
<div class="line"><span class="lineno"> 2810</span>    <span class="keyword">def </span>decorator(*wrapping_args, **wrapping_kwargs):</div>
<div class="line"><span class="lineno"> 2811</span>        <span class="keyword">def </span>outer_wrapper(f):</div>
<div class="line"><span class="lineno"> 2812</span>            <span class="keyword">def </span>inner_wrapper(*args, **kwargs):</div>
<div class="line"><span class="lineno"> 2813</span>                result = <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 2814</span>                wrapping_args_ = list(wrapping_args)</div>
<div class="line"><span class="lineno"> 2815</span>                wrapping_args_.insert(result_index, result)</div>
<div class="line"><span class="lineno"> 2816</span>                <span class="keywordflow">return</span> wrapping_func(*wrapping_args_, **wrapping_kwargs)</div>
<div class="line"><span class="lineno"> 2817</span> </div>
<div class="line"><span class="lineno"> 2818</span>            <span class="keywordflow">return</span> inner_wrapper</div>
<div class="line"><span class="lineno"> 2819</span> </div>
<div class="line"><span class="lineno"> 2820</span>        <span class="keywordflow">return</span> outer_wrapper</div>
<div class="line"><span class="lineno"> 2821</span> </div>
<div class="line"><span class="lineno"> 2822</span>    <span class="keywordflow">return</span> decorator</div>
<div class="line"><span class="lineno"> 2823</span> </div>
<div class="line"><span class="lineno"> 2824</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_af01a903df7bdb7a494f5827e45bf3a2a"><div class="ttname"><a href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a></div><div class="ttdeci">void int int int int npy_complex64 int int npy_complex64 float float npy_complex64 npy_complex64 * f</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:262</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af5f31c6152daaffa29cd357b6080416f" name="af5f31c6152daaffa29cd357b6080416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f31c6152daaffa29cd357b6080416f">&#9670;&#160;</a></span>map_except()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.map_except </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>exceptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform each item from *iterable* with *function* and yield the
result, unless *function* raises one of the specified *exceptions*.

*function* is called to transform each item in *iterable*.
It should be a accept one argument.

&gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None]
&gt;&gt;&gt; list(map_except(int, iterable, ValueError, TypeError))
[1, 2, 4]

If an exception other than one given by *exceptions* is raised by
*function*, it is raised like normal.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3259</span><span class="keyword">def </span>map_except(function, iterable, *exceptions):</div>
<div class="line"><span class="lineno"> 3260</span>    <span class="stringliteral">&quot;&quot;&quot;Transform each item from *iterable* with *function* and yield the</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">    result, unless *function* raises one of the specified *exceptions*.</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral">    *function* is called to transform each item in *iterable*.</span></div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral">    It should be a accept one argument.</span></div>
<div class="line"><span class="lineno"> 3265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3266</span><span class="stringliteral">    &gt;&gt;&gt; iterable = [&#39;1&#39;, &#39;2&#39;, &#39;three&#39;, &#39;4&#39;, None]</span></div>
<div class="line"><span class="lineno"> 3267</span><span class="stringliteral">    &gt;&gt;&gt; list(map_except(int, iterable, ValueError, TypeError))</span></div>
<div class="line"><span class="lineno"> 3268</span><span class="stringliteral">    [1, 2, 4]</span></div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral">    If an exception other than one given by *exceptions* is raised by</span></div>
<div class="line"><span class="lineno"> 3271</span><span class="stringliteral">    *function*, it is raised like normal.</span></div>
<div class="line"><span class="lineno"> 3272</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3273</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno"> 3274</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3275</span>            <span class="keywordflow">yield</span> function(item)</div>
<div class="line"><span class="lineno"> 3276</span>        <span class="keywordflow">except</span> exceptions:</div>
<div class="line"><span class="lineno"> 3277</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 3278</span> </div>
<div class="line"><span class="lineno"> 3279</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a45c533b865a3514e16c54991daba7af2" name="a45c533b865a3514e16c54991daba7af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c533b865a3514e16c54991daba7af2">&#9670;&#160;</a></span>map_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.map_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keyfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valuefunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reducefunc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dictionary that maps the items in *iterable* to categories
defined by *keyfunc*, transforms them with *valuefunc*, and
then summarizes them by category with *reducefunc*.

*valuefunc* defaults to the identity function if it is unspecified.
If *reducefunc* is unspecified, no summarization takes place:

    &gt;&gt;&gt; keyfunc = lambda x: x.upper()
    &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc)
    &gt;&gt;&gt; sorted(result.items())
    [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]

Specifying *valuefunc* transforms the categorized items:

    &gt;&gt;&gt; keyfunc = lambda x: x.upper()
    &gt;&gt;&gt; valuefunc = lambda x: 1
    &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc, valuefunc)
    &gt;&gt;&gt; sorted(result.items())
    [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]

Specifying *reducefunc* summarizes the categorized items:

    &gt;&gt;&gt; keyfunc = lambda x: x.upper()
    &gt;&gt;&gt; valuefunc = lambda x: 1
    &gt;&gt;&gt; reducefunc = sum
    &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)
    &gt;&gt;&gt; sorted(result.items())
    [('A', 1), ('B', 2), ('C', 3)]

You may want to filter the input iterable before applying the map/reduce
procedure:

    &gt;&gt;&gt; all_items = range(30)
    &gt;&gt;&gt; items = [x for x in all_items if 10 &lt;= x &lt;= 20]  # Filter
    &gt;&gt;&gt; keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1
    &gt;&gt;&gt; categories = map_reduce(items, keyfunc=keyfunc)
    &gt;&gt;&gt; sorted(categories.items())
    [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]
    &gt;&gt;&gt; summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)
    &gt;&gt;&gt; sorted(summaries.items())
    [(0, 90), (1, 75)]

Note that all items in the iterable are gathered into a list before the
summarization step, which may require significant storage.

The returned object is a :obj:`collections.defaultdict` with the
``default_factory`` set to ``None``, such that it behaves like a normal
dictionary.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2825</span><span class="keyword">def </span>map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):</div>
<div class="line"><span class="lineno"> 2826</span>    <span class="stringliteral">&quot;&quot;&quot;Return a dictionary that maps the items in *iterable* to categories</span></div>
<div class="line"><span class="lineno"> 2827</span><span class="stringliteral">    defined by *keyfunc*, transforms them with *valuefunc*, and</span></div>
<div class="line"><span class="lineno"> 2828</span><span class="stringliteral">    then summarizes them by category with *reducefunc*.</span></div>
<div class="line"><span class="lineno"> 2829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2830</span><span class="stringliteral">    *valuefunc* defaults to the identity function if it is unspecified.</span></div>
<div class="line"><span class="lineno"> 2831</span><span class="stringliteral">    If *reducefunc* is unspecified, no summarization takes place:</span></div>
<div class="line"><span class="lineno"> 2832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2833</span><span class="stringliteral">        &gt;&gt;&gt; keyfunc = lambda x: x.upper()</span></div>
<div class="line"><span class="lineno"> 2834</span><span class="stringliteral">        &gt;&gt;&gt; result = map_reduce(&#39;abbccc&#39;, keyfunc)</span></div>
<div class="line"><span class="lineno"> 2835</span><span class="stringliteral">        &gt;&gt;&gt; sorted(result.items())</span></div>
<div class="line"><span class="lineno"> 2836</span><span class="stringliteral">        [(&#39;A&#39;, [&#39;a&#39;]), (&#39;B&#39;, [&#39;b&#39;, &#39;b&#39;]), (&#39;C&#39;, [&#39;c&#39;, &#39;c&#39;, &#39;c&#39;])]</span></div>
<div class="line"><span class="lineno"> 2837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2838</span><span class="stringliteral">    Specifying *valuefunc* transforms the categorized items:</span></div>
<div class="line"><span class="lineno"> 2839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2840</span><span class="stringliteral">        &gt;&gt;&gt; keyfunc = lambda x: x.upper()</span></div>
<div class="line"><span class="lineno"> 2841</span><span class="stringliteral">        &gt;&gt;&gt; valuefunc = lambda x: 1</span></div>
<div class="line"><span class="lineno"> 2842</span><span class="stringliteral">        &gt;&gt;&gt; result = map_reduce(&#39;abbccc&#39;, keyfunc, valuefunc)</span></div>
<div class="line"><span class="lineno"> 2843</span><span class="stringliteral">        &gt;&gt;&gt; sorted(result.items())</span></div>
<div class="line"><span class="lineno"> 2844</span><span class="stringliteral">        [(&#39;A&#39;, [1]), (&#39;B&#39;, [1, 1]), (&#39;C&#39;, [1, 1, 1])]</span></div>
<div class="line"><span class="lineno"> 2845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2846</span><span class="stringliteral">    Specifying *reducefunc* summarizes the categorized items:</span></div>
<div class="line"><span class="lineno"> 2847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2848</span><span class="stringliteral">        &gt;&gt;&gt; keyfunc = lambda x: x.upper()</span></div>
<div class="line"><span class="lineno"> 2849</span><span class="stringliteral">        &gt;&gt;&gt; valuefunc = lambda x: 1</span></div>
<div class="line"><span class="lineno"> 2850</span><span class="stringliteral">        &gt;&gt;&gt; reducefunc = sum</span></div>
<div class="line"><span class="lineno"> 2851</span><span class="stringliteral">        &gt;&gt;&gt; result = map_reduce(&#39;abbccc&#39;, keyfunc, valuefunc, reducefunc)</span></div>
<div class="line"><span class="lineno"> 2852</span><span class="stringliteral">        &gt;&gt;&gt; sorted(result.items())</span></div>
<div class="line"><span class="lineno"> 2853</span><span class="stringliteral">        [(&#39;A&#39;, 1), (&#39;B&#39;, 2), (&#39;C&#39;, 3)]</span></div>
<div class="line"><span class="lineno"> 2854</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2855</span><span class="stringliteral">    You may want to filter the input iterable before applying the map/reduce</span></div>
<div class="line"><span class="lineno"> 2856</span><span class="stringliteral">    procedure:</span></div>
<div class="line"><span class="lineno"> 2857</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2858</span><span class="stringliteral">        &gt;&gt;&gt; all_items = range(30)</span></div>
<div class="line"><span class="lineno"> 2859</span><span class="stringliteral">        &gt;&gt;&gt; items = [x for x in all_items if 10 &lt;= x &lt;= 20]  # Filter</span></div>
<div class="line"><span class="lineno"> 2860</span><span class="stringliteral">        &gt;&gt;&gt; keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1</span></div>
<div class="line"><span class="lineno"> 2861</span><span class="stringliteral">        &gt;&gt;&gt; categories = map_reduce(items, keyfunc=keyfunc)</span></div>
<div class="line"><span class="lineno"> 2862</span><span class="stringliteral">        &gt;&gt;&gt; sorted(categories.items())</span></div>
<div class="line"><span class="lineno"> 2863</span><span class="stringliteral">        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]</span></div>
<div class="line"><span class="lineno"> 2864</span><span class="stringliteral">        &gt;&gt;&gt; summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)</span></div>
<div class="line"><span class="lineno"> 2865</span><span class="stringliteral">        &gt;&gt;&gt; sorted(summaries.items())</span></div>
<div class="line"><span class="lineno"> 2866</span><span class="stringliteral">        [(0, 90), (1, 75)]</span></div>
<div class="line"><span class="lineno"> 2867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2868</span><span class="stringliteral">    Note that all items in the iterable are gathered into a list before the</span></div>
<div class="line"><span class="lineno"> 2869</span><span class="stringliteral">    summarization step, which may require significant storage.</span></div>
<div class="line"><span class="lineno"> 2870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2871</span><span class="stringliteral">    The returned object is a :obj:`collections.defaultdict` with the</span></div>
<div class="line"><span class="lineno"> 2872</span><span class="stringliteral">    ``default_factory`` set to ``None``, such that it behaves like a normal</span></div>
<div class="line"><span class="lineno"> 2873</span><span class="stringliteral">    dictionary.</span></div>
<div class="line"><span class="lineno"> 2874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2875</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2876</span>    valuefunc = (<span class="keyword">lambda</span> x: x) <span class="keywordflow">if</span> (valuefunc <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> valuefunc</div>
<div class="line"><span class="lineno"> 2877</span> </div>
<div class="line"><span class="lineno"> 2878</span>    ret = defaultdict(list)</div>
<div class="line"><span class="lineno"> 2879</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno"> 2880</span>        key = keyfunc(item)</div>
<div class="line"><span class="lineno"> 2881</span>        value = valuefunc(item)</div>
<div class="line"><span class="lineno"> 2882</span>        ret[key].append(value)</div>
<div class="line"><span class="lineno"> 2883</span> </div>
<div class="line"><span class="lineno"> 2884</span>    <span class="keywordflow">if</span> reducefunc <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2885</span>        <span class="keywordflow">for</span> key, value_list <span class="keywordflow">in</span> ret.items():</div>
<div class="line"><span class="lineno"> 2886</span>            ret[key] = reducefunc(value_list)</div>
<div class="line"><span class="lineno"> 2887</span> </div>
<div class="line"><span class="lineno"> 2888</span>    ret.default_factory = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2889</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 2890</span> </div>
<div class="line"><span class="lineno"> 2891</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a887baec1ac1113ad302338e44bef29e7" name="a887baec1ac1113ad302338e44bef29e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887baec1ac1113ad302338e44bef29e7">&#9670;&#160;</a></span>mark_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.mark_ends </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield 3-tuples of the form ``(is_first, is_last, item)``.

&gt;&gt;&gt; list(mark_ends('ABC'))
[(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]

Use this when looping over an iterable to take special action on its first
and/or last items:

&gt;&gt;&gt; iterable = ['Header', 100, 200, 'Footer']
&gt;&gt;&gt; total = 0
&gt;&gt;&gt; for is_first, is_last, item in mark_ends(iterable):
...     if is_first:
...         continue  # Skip the header
...     if is_last:
...         continue  # Skip the footer
...     total += item
&gt;&gt;&gt; print(total)
300
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2122</span><span class="keyword">def </span>mark_ends(iterable):</div>
<div class="line"><span class="lineno"> 2123</span>    <span class="stringliteral">&quot;&quot;&quot;Yield 3-tuples of the form ``(is_first, is_last, item)``.</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral">    &gt;&gt;&gt; list(mark_ends(&#39;ABC&#39;))</span></div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">    [(True, False, &#39;A&#39;), (False, False, &#39;B&#39;), (False, True, &#39;C&#39;)]</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral">    Use this when looping over an iterable to take special action on its first</span></div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">    and/or last items:</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral">    &gt;&gt;&gt; iterable = [&#39;Header&#39;, 100, 200, &#39;Footer&#39;]</span></div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral">    &gt;&gt;&gt; total = 0</span></div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">    &gt;&gt;&gt; for is_first, is_last, item in mark_ends(iterable):</span></div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral">    ...     if is_first:</span></div>
<div class="line"><span class="lineno"> 2135</span><span class="stringliteral">    ...         continue  # Skip the header</span></div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral">    ...     if is_last:</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral">    ...         continue  # Skip the footer</span></div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral">    ...     total += item</span></div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">    &gt;&gt;&gt; print(total)</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral">    300</span></div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2142</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 2143</span> </div>
<div class="line"><span class="lineno"> 2144</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2145</span>        b = next(it)</div>
<div class="line"><span class="lineno"> 2146</span>    <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno"> 2147</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 2148</span> </div>
<div class="line"><span class="lineno"> 2149</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2150</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> count():</div>
<div class="line"><span class="lineno"> 2151</span>            a = b</div>
<div class="line"><span class="lineno"> 2152</span>            b = next(it)</div>
<div class="line"><span class="lineno"> 2153</span>            <span class="keywordflow">yield</span> i == 0, <span class="keyword">False</span>, a</div>
<div class="line"><span class="lineno"> 2154</span> </div>
<div class="line"><span class="lineno"> 2155</span>    <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno"> 2156</span>        <span class="keywordflow">yield</span> i == 0, <span class="keyword">True</span>, a</div>
<div class="line"><span class="lineno"> 2157</span> </div>
<div class="line"><span class="lineno"> 2158</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b1c123134b401ca372bc206b6fae7ba" name="a7b1c123134b401ca372bc206b6fae7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1c123134b401ca372bc206b6fae7ba">&#9670;&#160;</a></span>nth_or_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.nth_or_last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a67c5ce81dc3269a7393daed34ec304f1">_marker</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the nth or the last item of *iterable*,
or *default* if *iterable* is empty.

    &gt;&gt;&gt; nth_or_last([0, 1, 2, 3], 2)
    2
    &gt;&gt;&gt; nth_or_last([0, 1], 2)
    1
    &gt;&gt;&gt; nth_or_last([], 0, 'some default')
    'some default'

If *default* is not provided and there are no items in the iterable,
raise ``ValueError``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  217</span><span class="keyword">def </span>nth_or_last(iterable, n, default=_marker):</div>
<div class="line"><span class="lineno">  218</span>    <span class="stringliteral">&quot;&quot;&quot;Return the nth or the last item of *iterable*,</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    or *default* if *iterable* is empty.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">        &gt;&gt;&gt; nth_or_last([0, 1, 2, 3], 2)</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        2</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">        &gt;&gt;&gt; nth_or_last([0, 1], 2)</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">        1</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">        &gt;&gt;&gt; nth_or_last([], 0, &#39;some default&#39;)</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        &#39;some default&#39;</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    If *default* is not provided and there are no items in the iterable,</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    raise ``ValueError``.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  231</span>    <span class="keywordflow">return</span> last(islice(iterable, n + 1), default=default)</div>
<div class="line"><span class="lineno">  232</span> </div>
<div class="line"><span class="lineno">  233</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e8fb234f6fe28459220bb2acf7e7024" name="a1e8fb234f6fe28459220bb2acf7e7024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8fb234f6fe28459220bb2acf7e7024">&#9670;&#160;</a></span>nth_permutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.nth_permutation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(permutations(iterable, r))[index]```

The subsequences of *iterable* that are of length *r* where order is
important can be ordered lexicographically. :func:`nth_permutation`
computes the subsequence at sort position *index* directly, without
computing the previous subsequences.

    &gt;&gt;&gt; nth_permutation('ghijk', 2, 5)
    ('h', 'i')

``ValueError`` will be raised If *r* is negative or greater than the length
of *iterable*.
``IndexError`` will be raised if the given *index* is invalid.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3630</span><span class="keyword">def </span>nth_permutation(iterable, r, index):</div>
<div class="line"><span class="lineno"> 3631</span>    <span class="stringliteral">&quot;&quot;&quot;Equivalent to ``list(permutations(iterable, r))[index]```</span></div>
<div class="line"><span class="lineno"> 3632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3633</span><span class="stringliteral">    The subsequences of *iterable* that are of length *r* where order is</span></div>
<div class="line"><span class="lineno"> 3634</span><span class="stringliteral">    important can be ordered lexicographically. :func:`nth_permutation`</span></div>
<div class="line"><span class="lineno"> 3635</span><span class="stringliteral">    computes the subsequence at sort position *index* directly, without</span></div>
<div class="line"><span class="lineno"> 3636</span><span class="stringliteral">    computing the previous subsequences.</span></div>
<div class="line"><span class="lineno"> 3637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3638</span><span class="stringliteral">        &gt;&gt;&gt; nth_permutation(&#39;ghijk&#39;, 2, 5)</span></div>
<div class="line"><span class="lineno"> 3639</span><span class="stringliteral">        (&#39;h&#39;, &#39;i&#39;)</span></div>
<div class="line"><span class="lineno"> 3640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3641</span><span class="stringliteral">    ``ValueError`` will be raised If *r* is negative or greater than the length</span></div>
<div class="line"><span class="lineno"> 3642</span><span class="stringliteral">    of *iterable*.</span></div>
<div class="line"><span class="lineno"> 3643</span><span class="stringliteral">    ``IndexError`` will be raised if the given *index* is invalid.</span></div>
<div class="line"><span class="lineno"> 3644</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3645</span>    pool = list(iterable)</div>
<div class="line"><span class="lineno"> 3646</span>    n = len(pool)</div>
<div class="line"><span class="lineno"> 3647</span> </div>
<div class="line"><span class="lineno"> 3648</span>    <span class="keywordflow">if</span> r <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> r == n:</div>
<div class="line"><span class="lineno"> 3649</span>        r, c = n, factorial(n)</div>
<div class="line"><span class="lineno"> 3650</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> 0 &lt;= r &lt; n:</div>
<div class="line"><span class="lineno"> 3651</span>        <span class="keywordflow">raise</span> ValueError</div>
<div class="line"><span class="lineno"> 3652</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3653</span>        c = factorial(n) // factorial(n - r)</div>
<div class="line"><span class="lineno"> 3654</span> </div>
<div class="line"><span class="lineno"> 3655</span>    <span class="keywordflow">if</span> index &lt; 0:</div>
<div class="line"><span class="lineno"> 3656</span>        index += c</div>
<div class="line"><span class="lineno"> 3657</span> </div>
<div class="line"><span class="lineno"> 3658</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> 0 &lt;= index &lt; c:</div>
<div class="line"><span class="lineno"> 3659</span>        <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno"> 3660</span> </div>
<div class="line"><span class="lineno"> 3661</span>    <span class="keywordflow">if</span> c == 0:</div>
<div class="line"><span class="lineno"> 3662</span>        <span class="keywordflow">return</span> tuple()</div>
<div class="line"><span class="lineno"> 3663</span> </div>
<div class="line"><span class="lineno"> 3664</span>    result = [0] * r</div>
<div class="line"><span class="lineno"> 3665</span>    q = index * factorial(n) // c <span class="keywordflow">if</span> r &lt; n <span class="keywordflow">else</span> index</div>
<div class="line"><span class="lineno"> 3666</span>    <span class="keywordflow">for</span> d <span class="keywordflow">in</span> range(1, n + 1):</div>
<div class="line"><span class="lineno"> 3667</span>        q, i = divmod(q, d)</div>
<div class="line"><span class="lineno"> 3668</span>        <span class="keywordflow">if</span> 0 &lt;= n - d &lt; r:</div>
<div class="line"><span class="lineno"> 3669</span>            result[n - d] = i</div>
<div class="line"><span class="lineno"> 3670</span>        <span class="keywordflow">if</span> q == 0:</div>
<div class="line"><span class="lineno"> 3671</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 3672</span> </div>
<div class="line"><span class="lineno"> 3673</span>    <span class="keywordflow">return</span> tuple(map(pool.pop, result))</div>
<div class="line"><span class="lineno"> 3674</span> </div>
<div class="line"><span class="lineno"> 3675</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b3159489420e4a47a301c6d2d9c0529" name="a0b3159489420e4a47a301c6d2d9c0529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3159489420e4a47a301c6d2d9c0529">&#9670;&#160;</a></span>nth_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.nth_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(product(*args))[index]``.

The products of *args* can be ordered lexicographically.
:func:`nth_product` computes the product at sort position *index* without
computing the previous products.

    &gt;&gt;&gt; nth_product(8, range(2), range(2), range(2), range(2))
    (1, 0, 0, 0)

``IndexError`` will be raised if the given *index* is invalid.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3599</span><span class="keyword">def </span>nth_product(index, *args):</div>
<div class="line"><span class="lineno"> 3600</span>    <span class="stringliteral">&quot;&quot;&quot;Equivalent to ``list(product(*args))[index]``.</span></div>
<div class="line"><span class="lineno"> 3601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3602</span><span class="stringliteral">    The products of *args* can be ordered lexicographically.</span></div>
<div class="line"><span class="lineno"> 3603</span><span class="stringliteral">    :func:`nth_product` computes the product at sort position *index* without</span></div>
<div class="line"><span class="lineno"> 3604</span><span class="stringliteral">    computing the previous products.</span></div>
<div class="line"><span class="lineno"> 3605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3606</span><span class="stringliteral">        &gt;&gt;&gt; nth_product(8, range(2), range(2), range(2), range(2))</span></div>
<div class="line"><span class="lineno"> 3607</span><span class="stringliteral">        (1, 0, 0, 0)</span></div>
<div class="line"><span class="lineno"> 3608</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3609</span><span class="stringliteral">    ``IndexError`` will be raised if the given *index* is invalid.</span></div>
<div class="line"><span class="lineno"> 3610</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3611</span>    pools = list(map(tuple, reversed(args)))</div>
<div class="line"><span class="lineno"> 3612</span>    ns = list(map(len, pools))</div>
<div class="line"><span class="lineno"> 3613</span> </div>
<div class="line"><span class="lineno"> 3614</span>    c = reduce(mul, ns)</div>
<div class="line"><span class="lineno"> 3615</span> </div>
<div class="line"><span class="lineno"> 3616</span>    <span class="keywordflow">if</span> index &lt; 0:</div>
<div class="line"><span class="lineno"> 3617</span>        index += c</div>
<div class="line"><span class="lineno"> 3618</span> </div>
<div class="line"><span class="lineno"> 3619</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> 0 &lt;= index &lt; c:</div>
<div class="line"><span class="lineno"> 3620</span>        <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno"> 3621</span> </div>
<div class="line"><span class="lineno"> 3622</span>    result = []</div>
<div class="line"><span class="lineno"> 3623</span>    <span class="keywordflow">for</span> pool, n <span class="keywordflow">in</span> zip(pools, ns):</div>
<div class="line"><span class="lineno"> 3624</span>        result.append(pool[index % n])</div>
<div class="line"><span class="lineno"> 3625</span>        index //= n</div>
<div class="line"><span class="lineno"> 3626</span> </div>
<div class="line"><span class="lineno"> 3627</span>    <span class="keywordflow">return</span> tuple(reversed(result))</div>
<div class="line"><span class="lineno"> 3628</span> </div>
<div class="line"><span class="lineno"> 3629</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c28ebee9cc10435df318256129637c0" name="a8c28ebee9cc10435df318256129637c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c28ebee9cc10435df318256129637c0">&#9670;&#160;</a></span>one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.one </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>too_short</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>too_long</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the first item from *iterable*, which is expected to contain only
that item. Raise an exception if *iterable* is empty or has more than one
item.

:func:`one` is useful for ensuring that an iterable contains only one item.
For example, it can be used to retrieve the result of a database query
that is expected to return a single row.

If *iterable* is empty, ``ValueError`` will be raised. You may specify a
different exception with the *too_short* keyword:

    &gt;&gt;&gt; it = []
    &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    ValueError: too many items in iterable (expected 1)'
    &gt;&gt;&gt; too_short = IndexError('too few items')
    &gt;&gt;&gt; one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    IndexError: too few items

Similarly, if *iterable* contains more than one item, ``ValueError`` will
be raised. You may specify a different exception with the *too_long*
keyword:

    &gt;&gt;&gt; it = ['too', 'many']
    &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    ValueError: Expected exactly one item in iterable, but got 'too',
    'many', and perhaps more.
    &gt;&gt;&gt; too_long = RuntimeError
    &gt;&gt;&gt; one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    RuntimeError

Note that :func:`one` attempts to advance *iterable* twice to ensure there
is only one item. See :func:`spy` or :func:`peekable` to check iterable
contents less destructively.</pre> <div class="fragment"><div class="line"><span class="lineno">  514</span><span class="keyword">def </span><a class="code hl_variable" href="__lapack__subroutines_8h.html#a80d94bd327a5fa681359de9f54bf945f">one</a>(iterable, too_short=None, too_long=None):</div>
<div class="line"><span class="lineno">  515</span>    <span class="stringliteral">&quot;&quot;&quot;Return the first item from *iterable*, which is expected to contain only</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    that item. Raise an exception if *iterable* is empty or has more than one</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    item.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    :func:`one` is useful for ensuring that an iterable contains only one item.</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    For example, it can be used to retrieve the result of a database query</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    that is expected to return a single row.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    If *iterable* is empty, ``ValueError`` will be raised. You may specify a</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    different exception with the *too_short* keyword:</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">        &gt;&gt;&gt; it = []</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">        Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        ValueError: too many items in iterable (expected 1)&#39;</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        &gt;&gt;&gt; too_short = IndexError(&#39;too few items&#39;)</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        &gt;&gt;&gt; one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        IndexError: too few items</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    Similarly, if *iterable* contains more than one item, ``ValueError`` will</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    be raised. You may specify a different exception with the *too_long*</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    keyword:</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        &gt;&gt;&gt; it = [&#39;too&#39;, &#39;many&#39;]</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        ValueError: Expected exactly one item in iterable, but got &#39;too&#39;,</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        &#39;many&#39;, and perhaps more.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">        &gt;&gt;&gt; too_long = RuntimeError</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">        &gt;&gt;&gt; one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        RuntimeError</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    Note that :func:`one` attempts to advance *iterable* twice to ensure there</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    is only one item. See :func:`spy` or :func:`peekable` to check iterable</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    contents less destructively.</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  558</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno">  559</span> </div>
<div class="line"><span class="lineno">  560</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  561</span>        first_value = next(it)</div>
<div class="line"><span class="lineno">  562</span>    <span class="keywordflow">except</span> StopIteration <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  563</span>        <span class="keywordflow">raise</span> (</div>
<div class="line"><span class="lineno">  564</span>            too_short <span class="keywordflow">or</span> ValueError(<span class="stringliteral">&#39;too few items in iterable (expected 1)&#39;</span>)</div>
<div class="line"><span class="lineno">  565</span>        ) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  566</span> </div>
<div class="line"><span class="lineno">  567</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  568</span>        second_value = next(it)</div>
<div class="line"><span class="lineno">  569</span>    <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno">  570</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  571</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  572</span>        msg = (</div>
<div class="line"><span class="lineno">  573</span>            <span class="stringliteral">&#39;Expected exactly one item in iterable, but got {!r}, {!r}, &#39;</span></div>
<div class="line"><span class="lineno">  574</span>            <span class="stringliteral">&#39;and perhaps more.&#39;</span>.format(first_value, second_value)</div>
<div class="line"><span class="lineno">  575</span>        )</div>
<div class="line"><span class="lineno">  576</span>        <span class="keywordflow">raise</span> too_long <span class="keywordflow">or</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  577</span> </div>
<div class="line"><span class="lineno">  578</span>    <span class="keywordflow">return</span> first_value</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a80d94bd327a5fa681359de9f54bf945f"><div class="ttname"><a href="__lapack__subroutines_8h.html#a80d94bd327a5fa681359de9f54bf945f">one</a></div><div class="ttdeci">void int float float * one</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:58</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f27ecbe9378a7e871e33d55a980ebc7" name="a6f27ecbe9378a7e871e33d55a980ebc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f27ecbe9378a7e871e33d55a980ebc7">&#9670;&#160;</a></span>only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.only </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>too_long</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If *iterable* has only one item, return it.
If it has zero items, return *default*.
If it has more than one item, raise the exception given by *too_long*,
which is ``ValueError`` by default.

&gt;&gt;&gt; only([], default='missing')
'missing'
&gt;&gt;&gt; only([1])
1
&gt;&gt;&gt; only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
...
ValueError: Expected exactly one item in iterable, but got 1, 2,
 and perhaps more.'
&gt;&gt;&gt; only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
...
TypeError

Note that :func:`only` attempts to advance *iterable* twice to ensure there
is only one item.  See :func:`spy` or :func:`peekable` to check
iterable contents less destructively.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3117</span><span class="keyword">def </span>only(iterable, default=None, too_long=None):</div>
<div class="line"><span class="lineno"> 3118</span>    <span class="stringliteral">&quot;&quot;&quot;If *iterable* has only one item, return it.</span></div>
<div class="line"><span class="lineno"> 3119</span><span class="stringliteral">    If it has zero items, return *default*.</span></div>
<div class="line"><span class="lineno"> 3120</span><span class="stringliteral">    If it has more than one item, raise the exception given by *too_long*,</span></div>
<div class="line"><span class="lineno"> 3121</span><span class="stringliteral">    which is ``ValueError`` by default.</span></div>
<div class="line"><span class="lineno"> 3122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3123</span><span class="stringliteral">    &gt;&gt;&gt; only([], default=&#39;missing&#39;)</span></div>
<div class="line"><span class="lineno"> 3124</span><span class="stringliteral">    &#39;missing&#39;</span></div>
<div class="line"><span class="lineno"> 3125</span><span class="stringliteral">    &gt;&gt;&gt; only([1])</span></div>
<div class="line"><span class="lineno"> 3126</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno"> 3127</span><span class="stringliteral">    &gt;&gt;&gt; only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line"><span class="lineno"> 3128</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 3129</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 3130</span><span class="stringliteral">    ValueError: Expected exactly one item in iterable, but got 1, 2,</span></div>
<div class="line"><span class="lineno"> 3131</span><span class="stringliteral">     and perhaps more.&#39;</span></div>
<div class="line"><span class="lineno"> 3132</span><span class="stringliteral">    &gt;&gt;&gt; only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line"><span class="lineno"> 3133</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 3134</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 3135</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 3136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3137</span><span class="stringliteral">    Note that :func:`only` attempts to advance *iterable* twice to ensure there</span></div>
<div class="line"><span class="lineno"> 3138</span><span class="stringliteral">    is only one item.  See :func:`spy` or :func:`peekable` to check</span></div>
<div class="line"><span class="lineno"> 3139</span><span class="stringliteral">    iterable contents less destructively.</span></div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3141</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 3142</span>    first_value = next(it, default)</div>
<div class="line"><span class="lineno"> 3143</span> </div>
<div class="line"><span class="lineno"> 3144</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3145</span>        second_value = next(it)</div>
<div class="line"><span class="lineno"> 3146</span>    <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno"> 3147</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 3148</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3149</span>        msg = (</div>
<div class="line"><span class="lineno"> 3150</span>            <span class="stringliteral">&#39;Expected exactly one item in iterable, but got {!r}, {!r}, &#39;</span></div>
<div class="line"><span class="lineno"> 3151</span>            <span class="stringliteral">&#39;and perhaps more.&#39;</span>.format(first_value, second_value)</div>
<div class="line"><span class="lineno"> 3152</span>        )</div>
<div class="line"><span class="lineno"> 3153</span>        <span class="keywordflow">raise</span> too_long <span class="keywordflow">or</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 3154</span> </div>
<div class="line"><span class="lineno"> 3155</span>    <span class="keywordflow">return</span> first_value</div>
<div class="line"><span class="lineno"> 3156</span> </div>
<div class="line"><span class="lineno"> 3157</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a50adbaec19127d43efcec83b3b67d2e1" name="a50adbaec19127d43efcec83b3b67d2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50adbaec19127d43efcec83b3b67d2e1">&#9670;&#160;</a></span>padded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.padded </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>next_multiple</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the elements from *iterable*, followed by *fillvalue*, such that
at least *n* items are emitted.

    &gt;&gt;&gt; list(padded([1, 2, 3], '?', 5))
    [1, 2, 3, '?', '?']

If *next_multiple* is ``True``, *fillvalue* will be emitted until the
number of items emitted is a multiple of *n*::

    &gt;&gt;&gt; list(padded([1, 2, 3, 4], n=3, next_multiple=True))
    [1, 2, 3, 4, None, None]

If *n* is ``None``, *fillvalue* will be emitted indefinitely.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1368</span><span class="keyword">def </span>padded(iterable, fillvalue=None, n=None, next_multiple=False):</div>
<div class="line"><span class="lineno"> 1369</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the elements from *iterable*, followed by *fillvalue*, such that</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    at least *n* items are emitted.</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">        &gt;&gt;&gt; list(padded([1, 2, 3], &#39;?&#39;, 5))</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">        [1, 2, 3, &#39;?&#39;, &#39;?&#39;]</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    If *next_multiple* is ``True``, *fillvalue* will be emitted until the</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    number of items emitted is a multiple of *n*::</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">        &gt;&gt;&gt; list(padded([1, 2, 3, 4], n=3, next_multiple=True))</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">        [1, 2, 3, 4, None, None]</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    If *n* is ``None``, *fillvalue* will be emitted indefinitely.</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1384</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 1385</span>    <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1386</span>        <span class="keywordflow">yield</span> <span class="keyword">from</span> chain(it, repeat(fillvalue))</div>
<div class="line"><span class="lineno"> 1387</span>    <span class="keywordflow">elif</span> n &lt; 1:</div>
<div class="line"><span class="lineno"> 1388</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n must be at least 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 1389</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1390</span>        item_count = 0</div>
<div class="line"><span class="lineno"> 1391</span>        <span class="keywordflow">for</span> item <span class="keywordflow">in</span> it:</div>
<div class="line"><span class="lineno"> 1392</span>            <span class="keywordflow">yield</span> item</div>
<div class="line"><span class="lineno"> 1393</span>            item_count += 1</div>
<div class="line"><span class="lineno"> 1394</span> </div>
<div class="line"><span class="lineno"> 1395</span>        remaining = (n - item_count) % n <span class="keywordflow">if</span> next_multiple <span class="keywordflow">else</span> n - item_count</div>
<div class="line"><span class="lineno"> 1396</span>        <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(remaining):</div>
<div class="line"><span class="lineno"> 1397</span>            <span class="keywordflow">yield</span> fillvalue</div>
<div class="line"><span class="lineno"> 1398</span> </div>
<div class="line"><span class="lineno"> 1399</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a50ac8728632c6d80de2b0e3f627b1b77" name="a50ac8728632c6d80de2b0e3f627b1b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ac8728632c6d80de2b0e3f627b1b77">&#9670;&#160;</a></span>partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all possible order-preserving partitions of *iterable*.

&gt;&gt;&gt; iterable = 'abc'
&gt;&gt;&gt; for part in partitions(iterable):
...     print([''.join(p) for p in part])
['abc']
['a', 'bc']
['ab', 'c']
['a', 'b', 'c']

This is unrelated to :func:`partition`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2996</span><span class="keyword">def </span>partitions(iterable):</div>
<div class="line"><span class="lineno"> 2997</span>    <span class="stringliteral">&quot;&quot;&quot;Yield all possible order-preserving partitions of *iterable*.</span></div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral">    &gt;&gt;&gt; iterable = &#39;abc&#39;</span></div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral">    &gt;&gt;&gt; for part in partitions(iterable):</span></div>
<div class="line"><span class="lineno"> 3001</span><span class="stringliteral">    ...     print([&#39;&#39;.join(p) for p in part])</span></div>
<div class="line"><span class="lineno"> 3002</span><span class="stringliteral">    [&#39;abc&#39;]</span></div>
<div class="line"><span class="lineno"> 3003</span><span class="stringliteral">    [&#39;a&#39;, &#39;bc&#39;]</span></div>
<div class="line"><span class="lineno"> 3004</span><span class="stringliteral">    [&#39;ab&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno"> 3005</span><span class="stringliteral">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno"> 3006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3007</span><span class="stringliteral">    This is unrelated to :func:`partition`.</span></div>
<div class="line"><span class="lineno"> 3008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3009</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3010</span>    sequence = list(iterable)</div>
<div class="line"><span class="lineno"> 3011</span>    n = len(sequence)</div>
<div class="line"><span class="lineno"> 3012</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> powerset(range(1, n)):</div>
<div class="line"><span class="lineno"> 3013</span>        <span class="keywordflow">yield</span> [sequence[i:j] <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> zip((0,) + i, i + (n,))]</div>
<div class="line"><span class="lineno"> 3014</span> </div>
<div class="line"><span class="lineno"> 3015</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8a435858b2e240b461187e43423a959" name="aa8a435858b2e240b461187e43423a959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a435858b2e240b461187e43423a959">&#9670;&#160;</a></span>permutation_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.permutation_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(permutations(iterable, r)).index(element)```

The subsequences of *iterable* that are of length *r* where order is
important can be ordered lexicographically. :func:`permutation_index`
computes the index of the first *element* directly, without computing
the previous permutations.

    &gt;&gt;&gt; permutation_index([1, 3, 2], range(5))
    19

``ValueError`` will be raised if the given *element* isn't one of the
permutations of *iterable*.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3772</span><span class="keyword">def </span>permutation_index(element, iterable):</div>
<div class="line"><span class="lineno"> 3773</span>    <span class="stringliteral">&quot;&quot;&quot;Equivalent to ``list(permutations(iterable, r)).index(element)```</span></div>
<div class="line"><span class="lineno"> 3774</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3775</span><span class="stringliteral">    The subsequences of *iterable* that are of length *r* where order is</span></div>
<div class="line"><span class="lineno"> 3776</span><span class="stringliteral">    important can be ordered lexicographically. :func:`permutation_index`</span></div>
<div class="line"><span class="lineno"> 3777</span><span class="stringliteral">    computes the index of the first *element* directly, without computing</span></div>
<div class="line"><span class="lineno"> 3778</span><span class="stringliteral">    the previous permutations.</span></div>
<div class="line"><span class="lineno"> 3779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3780</span><span class="stringliteral">        &gt;&gt;&gt; permutation_index([1, 3, 2], range(5))</span></div>
<div class="line"><span class="lineno"> 3781</span><span class="stringliteral">        19</span></div>
<div class="line"><span class="lineno"> 3782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3783</span><span class="stringliteral">    ``ValueError`` will be raised if the given *element* isn&#39;t one of the</span></div>
<div class="line"><span class="lineno"> 3784</span><span class="stringliteral">    permutations of *iterable*.</span></div>
<div class="line"><span class="lineno"> 3785</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3786</span>    index = 0</div>
<div class="line"><span class="lineno"> 3787</span>    pool = list(iterable)</div>
<div class="line"><span class="lineno"> 3788</span>    <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> zip(range(len(pool), -1, -1), element):</div>
<div class="line"><span class="lineno"> 3789</span>        r = pool.index(x)</div>
<div class="line"><span class="lineno"> 3790</span>        index = index * i + r</div>
<div class="line"><span class="lineno"> 3791</span>        del pool[r]</div>
<div class="line"><span class="lineno"> 3792</span> </div>
<div class="line"><span class="lineno"> 3793</span>    <span class="keywordflow">return</span> index</div>
<div class="line"><span class="lineno"> 3794</span> </div>
<div class="line"><span class="lineno"> 3795</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad04f1738abb04e3d9334e3daf689c4a5" name="ad04f1738abb04e3d9334e3daf689c4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04f1738abb04e3d9334e3daf689c4a5">&#9670;&#160;</a></span>product_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.product_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(product(*args)).index(element)``

The products of *args* can be ordered lexicographically.
:func:`product_index` computes the first index of *element* without
computing the previous products.

    &gt;&gt;&gt; product_index([8, 2], range(10), range(5))
    42

``ValueError`` will be raised if the given *element* isn't in the product
of *args*.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3704</span><span class="keyword">def </span>product_index(element, *args):</div>
<div class="line"><span class="lineno"> 3705</span>    <span class="stringliteral">&quot;&quot;&quot;Equivalent to ``list(product(*args)).index(element)``</span></div>
<div class="line"><span class="lineno"> 3706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3707</span><span class="stringliteral">    The products of *args* can be ordered lexicographically.</span></div>
<div class="line"><span class="lineno"> 3708</span><span class="stringliteral">    :func:`product_index` computes the first index of *element* without</span></div>
<div class="line"><span class="lineno"> 3709</span><span class="stringliteral">    computing the previous products.</span></div>
<div class="line"><span class="lineno"> 3710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3711</span><span class="stringliteral">        &gt;&gt;&gt; product_index([8, 2], range(10), range(5))</span></div>
<div class="line"><span class="lineno"> 3712</span><span class="stringliteral">        42</span></div>
<div class="line"><span class="lineno"> 3713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3714</span><span class="stringliteral">    ``ValueError`` will be raised if the given *element* isn&#39;t in the product</span></div>
<div class="line"><span class="lineno"> 3715</span><span class="stringliteral">    of *args*.</span></div>
<div class="line"><span class="lineno"> 3716</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3717</span>    index = 0</div>
<div class="line"><span class="lineno"> 3718</span> </div>
<div class="line"><span class="lineno"> 3719</span>    <span class="keywordflow">for</span> x, pool <span class="keywordflow">in</span> zip_longest(element, args, fillvalue=_marker):</div>
<div class="line"><span class="lineno"> 3720</span>        <span class="keywordflow">if</span> x <span class="keywordflow">is</span> _marker <span class="keywordflow">or</span> pool <span class="keywordflow">is</span> _marker:</div>
<div class="line"><span class="lineno"> 3721</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;element is not a product of args&#39;</span>)</div>
<div class="line"><span class="lineno"> 3722</span> </div>
<div class="line"><span class="lineno"> 3723</span>        pool = tuple(pool)</div>
<div class="line"><span class="lineno"> 3724</span>        index = index * len(pool) + pool.index(x)</div>
<div class="line"><span class="lineno"> 3725</span> </div>
<div class="line"><span class="lineno"> 3726</span>    <span class="keywordflow">return</span> index</div>
<div class="line"><span class="lineno"> 3727</span> </div>
<div class="line"><span class="lineno"> 3728</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5425f753dfd8559de42b9fc12c28fc2" name="aa5425f753dfd8559de42b9fc12c28fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5425f753dfd8559de42b9fc12c28fc2">&#9670;&#160;</a></span>repeat_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.repeat_last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">After the *iterable* is exhausted, keep yielding its last element.

    &gt;&gt;&gt; list(islice(repeat_last(range(3)), 5))
    [0, 1, 2, 2, 2]

If the iterable is empty, yield *default* forever::

    &gt;&gt;&gt; list(islice(repeat_last(range(0), 42), 5))
    [42, 42, 42, 42, 42]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1400</span><span class="keyword">def </span>repeat_last(iterable, default=None):</div>
<div class="line"><span class="lineno"> 1401</span>    <span class="stringliteral">&quot;&quot;&quot;After the *iterable* is exhausted, keep yielding its last element.</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">        &gt;&gt;&gt; list(islice(repeat_last(range(3)), 5))</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">        [0, 1, 2, 2, 2]</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    If the iterable is empty, yield *default* forever::</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">        &gt;&gt;&gt; list(islice(repeat_last(range(0), 42), 5))</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">        [42, 42, 42, 42, 42]</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1412</span>    item = _marker</div>
<div class="line"><span class="lineno"> 1413</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno"> 1414</span>        <span class="keywordflow">yield</span> item</div>
<div class="line"><span class="lineno"> 1415</span>    final = default <span class="keywordflow">if</span> item <span class="keywordflow">is</span> _marker <span class="keywordflow">else</span> item</div>
<div class="line"><span class="lineno"> 1416</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> repeat(final)</div>
<div class="line"><span class="lineno"> 1417</span> </div>
<div class="line"><span class="lineno"> 1418</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8daa550cec9c16c67c4500228d1e08d" name="ab8daa550cec9c16c67c4500228d1e08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8daa550cec9c16c67c4500228d1e08d">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.replace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>substitutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, replacing the items for which *pred*
returns ``True`` with the items from the iterable *substitutes*.

    &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1]
    &gt;&gt;&gt; pred = lambda x: x == 0
    &gt;&gt;&gt; substitutes = (2, 3)
    &gt;&gt;&gt; list(replace(iterable, pred, substitutes))
    [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]

If *count* is given, the number of replacements will be limited:

    &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]
    &gt;&gt;&gt; pred = lambda x: x == 0
    &gt;&gt;&gt; substitutes = [None]
    &gt;&gt;&gt; list(replace(iterable, pred, substitutes, count=2))
    [1, 1, None, 1, 1, None, 1, 1, 0]

Use *window_size* to control the number of items passed as arguments to
*pred*. This allows for locating and replacing subsequences.

    &gt;&gt;&gt; iterable = [0, 1, 2, 5, 0, 1, 2, 5]
    &gt;&gt;&gt; window_size = 3
    &gt;&gt;&gt; pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred
    &gt;&gt;&gt; substitutes = [3, 4] # Splice in these items
    &gt;&gt;&gt; list(replace(iterable, pred, substitutes, window_size=window_size))
    [3, 4, 5, 3, 4, 5]</pre> <div class="fragment"><div class="line"><span class="lineno"> 2935</span><span class="keyword">def </span>replace(iterable, pred, substitutes, count=None, window_size=1):</div>
<div class="line"><span class="lineno"> 2936</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the items from *iterable*, replacing the items for which *pred*</span></div>
<div class="line"><span class="lineno"> 2937</span><span class="stringliteral">    returns ``True`` with the items from the iterable *substitutes*.</span></div>
<div class="line"><span class="lineno"> 2938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2939</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1]</span></div>
<div class="line"><span class="lineno"> 2940</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda x: x == 0</span></div>
<div class="line"><span class="lineno"> 2941</span><span class="stringliteral">        &gt;&gt;&gt; substitutes = (2, 3)</span></div>
<div class="line"><span class="lineno"> 2942</span><span class="stringliteral">        &gt;&gt;&gt; list(replace(iterable, pred, substitutes))</span></div>
<div class="line"><span class="lineno"> 2943</span><span class="stringliteral">        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]</span></div>
<div class="line"><span class="lineno"> 2944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2945</span><span class="stringliteral">    If *count* is given, the number of replacements will be limited:</span></div>
<div class="line"><span class="lineno"> 2946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2947</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]</span></div>
<div class="line"><span class="lineno"> 2948</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda x: x == 0</span></div>
<div class="line"><span class="lineno"> 2949</span><span class="stringliteral">        &gt;&gt;&gt; substitutes = [None]</span></div>
<div class="line"><span class="lineno"> 2950</span><span class="stringliteral">        &gt;&gt;&gt; list(replace(iterable, pred, substitutes, count=2))</span></div>
<div class="line"><span class="lineno"> 2951</span><span class="stringliteral">        [1, 1, None, 1, 1, None, 1, 1, 0]</span></div>
<div class="line"><span class="lineno"> 2952</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2953</span><span class="stringliteral">    Use *window_size* to control the number of items passed as arguments to</span></div>
<div class="line"><span class="lineno"> 2954</span><span class="stringliteral">    *pred*. This allows for locating and replacing subsequences.</span></div>
<div class="line"><span class="lineno"> 2955</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2956</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [0, 1, 2, 5, 0, 1, 2, 5]</span></div>
<div class="line"><span class="lineno"> 2957</span><span class="stringliteral">        &gt;&gt;&gt; window_size = 3</span></div>
<div class="line"><span class="lineno"> 2958</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred</span></div>
<div class="line"><span class="lineno"> 2959</span><span class="stringliteral">        &gt;&gt;&gt; substitutes = [3, 4] # Splice in these items</span></div>
<div class="line"><span class="lineno"> 2960</span><span class="stringliteral">        &gt;&gt;&gt; list(replace(iterable, pred, substitutes, window_size=window_size))</span></div>
<div class="line"><span class="lineno"> 2961</span><span class="stringliteral">        [3, 4, 5, 3, 4, 5]</span></div>
<div class="line"><span class="lineno"> 2962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2963</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2964</span>    <span class="keywordflow">if</span> window_size &lt; 1:</div>
<div class="line"><span class="lineno"> 2965</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window_size must be at least 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 2966</span> </div>
<div class="line"><span class="lineno"> 2967</span>    <span class="comment"># Save the substitutes iterable, since it&#39;s used more than once</span></div>
<div class="line"><span class="lineno"> 2968</span>    substitutes = tuple(substitutes)</div>
<div class="line"><span class="lineno"> 2969</span> </div>
<div class="line"><span class="lineno"> 2970</span>    <span class="comment"># Add padding such that the number of windows matches the length of the</span></div>
<div class="line"><span class="lineno"> 2971</span>    <span class="comment"># iterable</span></div>
<div class="line"><span class="lineno"> 2972</span>    it = chain(iterable, [_marker] * (window_size - 1))</div>
<div class="line"><span class="lineno"> 2973</span>    windows = windowed(it, window_size)</div>
<div class="line"><span class="lineno"> 2974</span> </div>
<div class="line"><span class="lineno"> 2975</span>    n = 0</div>
<div class="line"><span class="lineno"> 2976</span>    <span class="keywordflow">for</span> w <span class="keywordflow">in</span> windows:</div>
<div class="line"><span class="lineno"> 2977</span>        <span class="comment"># If the current window matches our predicate (and we haven&#39;t hit</span></div>
<div class="line"><span class="lineno"> 2978</span>        <span class="comment"># our maximum number of replacements), splice in the substitutes</span></div>
<div class="line"><span class="lineno"> 2979</span>        <span class="comment"># and then consume the following windows that overlap with this one.</span></div>
<div class="line"><span class="lineno"> 2980</span>        <span class="comment"># For example, if the iterable is (0, 1, 2, 3, 4...)</span></div>
<div class="line"><span class="lineno"> 2981</span>        <span class="comment"># and the window size is 2, we have (0, 1), (1, 2), (2, 3)...</span></div>
<div class="line"><span class="lineno"> 2982</span>        <span class="comment"># If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)</span></div>
<div class="line"><span class="lineno"> 2983</span>        <span class="keywordflow">if</span> pred(*w):</div>
<div class="line"><span class="lineno"> 2984</span>            <span class="keywordflow">if</span> (count <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">or</span> (n &lt; count):</div>
<div class="line"><span class="lineno"> 2985</span>                n += 1</div>
<div class="line"><span class="lineno"> 2986</span>                <span class="keywordflow">yield</span> <span class="keyword">from</span> substitutes</div>
<div class="line"><span class="lineno"> 2987</span>                consume(windows, window_size - 1)</div>
<div class="line"><span class="lineno"> 2988</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2989</span> </div>
<div class="line"><span class="lineno"> 2990</span>        <span class="comment"># If there was no match (or we&#39;ve reached the replacement limit),</span></div>
<div class="line"><span class="lineno"> 2991</span>        <span class="comment"># yield the first item from the window.</span></div>
<div class="line"><span class="lineno"> 2992</span>        <span class="keywordflow">if</span> w <span class="keywordflow">and</span> (w[0] <span class="keywordflow">is</span> <span class="keywordflow">not</span> _marker):</div>
<div class="line"><span class="lineno"> 2993</span>            <span class="keywordflow">yield</span> w[0]</div>
<div class="line"><span class="lineno"> 2994</span> </div>
<div class="line"><span class="lineno"> 2995</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a31f682ab11fa2bc3a54def3f13ae20d9" name="a31f682ab11fa2bc3a54def3f13ae20d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f682ab11fa2bc3a54def3f13ae20d9">&#9670;&#160;</a></span>rlocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.rlocate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em> = <code>bool</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the index of each item in *iterable* for which *pred* returns
``True``, starting from the right and moving left.

*pred* defaults to :func:`bool`, which will select truthy items:

    &gt;&gt;&gt; list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4
    [4, 2, 1]

Set *pred* to a custom function to, e.g., find the indexes for a particular
item:

    &gt;&gt;&gt; iterable = iter('abcb')
    &gt;&gt;&gt; pred = lambda x: x == 'b'
    &gt;&gt;&gt; list(rlocate(iterable, pred))
    [3, 1]

If *window_size* is given, then the *pred* function will be called with
that many items. This enables searching for sub-sequences:

    &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
    &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)
    &gt;&gt;&gt; list(rlocate(iterable, pred=pred, window_size=3))
    [9, 5, 1]

Beware, this function won't return anything for infinite iterables.
If *iterable* is reversible, ``rlocate`` will reverse it and search from
the right. Otherwise, it will search from the left and return the results
in reverse order.

See :func:`locate` to for other example applications.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2892</span><span class="keyword">def </span>rlocate(iterable, pred=bool, window_size=None):</div>
<div class="line"><span class="lineno"> 2893</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the index of each item in *iterable* for which *pred* returns</span></div>
<div class="line"><span class="lineno"> 2894</span><span class="stringliteral">    ``True``, starting from the right and moving left.</span></div>
<div class="line"><span class="lineno"> 2895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2896</span><span class="stringliteral">    *pred* defaults to :func:`bool`, which will select truthy items:</span></div>
<div class="line"><span class="lineno"> 2897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2898</span><span class="stringliteral">        &gt;&gt;&gt; list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4</span></div>
<div class="line"><span class="lineno"> 2899</span><span class="stringliteral">        [4, 2, 1]</span></div>
<div class="line"><span class="lineno"> 2900</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2901</span><span class="stringliteral">    Set *pred* to a custom function to, e.g., find the indexes for a particular</span></div>
<div class="line"><span class="lineno"> 2902</span><span class="stringliteral">    item:</span></div>
<div class="line"><span class="lineno"> 2903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2904</span><span class="stringliteral">        &gt;&gt;&gt; iterable = iter(&#39;abcb&#39;)</span></div>
<div class="line"><span class="lineno"> 2905</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda x: x == &#39;b&#39;</span></div>
<div class="line"><span class="lineno"> 2906</span><span class="stringliteral">        &gt;&gt;&gt; list(rlocate(iterable, pred))</span></div>
<div class="line"><span class="lineno"> 2907</span><span class="stringliteral">        [3, 1]</span></div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral">    If *window_size* is given, then the *pred* function will be called with</span></div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral">    that many items. This enables searching for sub-sequences:</span></div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2912</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)</span></div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral">        &gt;&gt;&gt; list(rlocate(iterable, pred=pred, window_size=3))</span></div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">        [9, 5, 1]</span></div>
<div class="line"><span class="lineno"> 2916</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2917</span><span class="stringliteral">    Beware, this function won&#39;t return anything for infinite iterables.</span></div>
<div class="line"><span class="lineno"> 2918</span><span class="stringliteral">    If *iterable* is reversible, ``rlocate`` will reverse it and search from</span></div>
<div class="line"><span class="lineno"> 2919</span><span class="stringliteral">    the right. Otherwise, it will search from the left and return the results</span></div>
<div class="line"><span class="lineno"> 2920</span><span class="stringliteral">    in reverse order.</span></div>
<div class="line"><span class="lineno"> 2921</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2922</span><span class="stringliteral">    See :func:`locate` to for other example applications.</span></div>
<div class="line"><span class="lineno"> 2923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2924</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2925</span>    <span class="keywordflow">if</span> window_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2926</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2927</span>            len_iter = len(iterable)</div>
<div class="line"><span class="lineno"> 2928</span>            <span class="keywordflow">return</span> (len_iter - i - 1 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> locate(reversed(iterable), pred))</div>
<div class="line"><span class="lineno"> 2929</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 2930</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 2931</span> </div>
<div class="line"><span class="lineno"> 2932</span>    <span class="keywordflow">return</span> reversed(list(locate(iterable, pred, window_size)))</div>
<div class="line"><span class="lineno"> 2933</span> </div>
<div class="line"><span class="lineno"> 2934</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abafac6a26effb97d5579c5412d30bc77" name="abafac6a26effb97d5579c5412d30bc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafac6a26effb97d5579c5412d30bc77">&#9670;&#160;</a></span>rstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.rstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, but strip any from the end
for which *pred* returns ``True``.

For example, to remove a set of items from the end of an iterable:

    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)
    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}
    &gt;&gt;&gt; list(rstrip(iterable, pred))
    [None, False, None, 1, 2, None, 3]

This function is analogous to :func:`str.rstrip`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2225</span><span class="keyword">def </span>rstrip(iterable, pred):</div>
<div class="line"><span class="lineno"> 2226</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the items from *iterable*, but strip any from the end</span></div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">    for which *pred* returns ``True``.</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">    For example, to remove a set of items from the end of an iterable:</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral">        &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda x: x in {None, False, &#39;&#39;}</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">        &gt;&gt;&gt; list(rstrip(iterable, pred))</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">        [None, False, None, 1, 2, None, 3]</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    This function is analogous to :func:`str.rstrip`.</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2239</span>    cache = []</div>
<div class="line"><span class="lineno"> 2240</span>    cache_append = cache.append</div>
<div class="line"><span class="lineno"> 2241</span>    cache_clear = cache.clear</div>
<div class="line"><span class="lineno"> 2242</span>    <span class="keywordflow">for</span> x <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno"> 2243</span>        <span class="keywordflow">if</span> pred(x):</div>
<div class="line"><span class="lineno"> 2244</span>            cache_append(x)</div>
<div class="line"><span class="lineno"> 2245</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2246</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> cache</div>
<div class="line"><span class="lineno"> 2247</span>            cache_clear()</div>
<div class="line"><span class="lineno"> 2248</span>            <span class="keywordflow">yield</span> x</div>
<div class="line"><span class="lineno"> 2249</span> </div>
<div class="line"><span class="lineno"> 2250</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1405cfbac3f502521faf280895b1920a" name="a1405cfbac3f502521faf280895b1920a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1405cfbac3f502521faf280895b1920a">&#9670;&#160;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.sample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a *k*-length list of elements chosen (without replacement)
from the *iterable*. Like :func:`random.sample`, but works on iterables
of unknown length.

&gt;&gt;&gt; iterable = range(100)
&gt;&gt;&gt; sample(iterable, 5)  # doctest: +SKIP
[81, 60, 96, 16, 4]

An iterable with *weights* may also be given:

&gt;&gt;&gt; iterable = range(100)
&gt;&gt;&gt; weights = (i * i + 1 for i in range(100))
&gt;&gt;&gt; sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP
[79, 67, 74, 66, 78]

The algorithm can also be used to generate weighted random permutations.
The relative weight of each item determines the probability that it
appears late in the permutation.

&gt;&gt;&gt; data = "abcdefgh"
&gt;&gt;&gt; weights = range(1, len(data) + 1)
&gt;&gt;&gt; sample(data, k=len(data), weights=weights)  # doctest: +SKIP
['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3341</span><span class="keyword">def </span>sample(iterable, k, weights=None):</div>
<div class="line"><span class="lineno"> 3342</span>    <span class="stringliteral">&quot;&quot;&quot;Return a *k*-length list of elements chosen (without replacement)</span></div>
<div class="line"><span class="lineno"> 3343</span><span class="stringliteral">    from the *iterable*. Like :func:`random.sample`, but works on iterables</span></div>
<div class="line"><span class="lineno"> 3344</span><span class="stringliteral">    of unknown length.</span></div>
<div class="line"><span class="lineno"> 3345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3346</span><span class="stringliteral">    &gt;&gt;&gt; iterable = range(100)</span></div>
<div class="line"><span class="lineno"> 3347</span><span class="stringliteral">    &gt;&gt;&gt; sample(iterable, 5)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 3348</span><span class="stringliteral">    [81, 60, 96, 16, 4]</span></div>
<div class="line"><span class="lineno"> 3349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3350</span><span class="stringliteral">    An iterable with *weights* may also be given:</span></div>
<div class="line"><span class="lineno"> 3351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3352</span><span class="stringliteral">    &gt;&gt;&gt; iterable = range(100)</span></div>
<div class="line"><span class="lineno"> 3353</span><span class="stringliteral">    &gt;&gt;&gt; weights = (i * i + 1 for i in range(100))</span></div>
<div class="line"><span class="lineno"> 3354</span><span class="stringliteral">    &gt;&gt;&gt; sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 3355</span><span class="stringliteral">    [79, 67, 74, 66, 78]</span></div>
<div class="line"><span class="lineno"> 3356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3357</span><span class="stringliteral">    The algorithm can also be used to generate weighted random permutations.</span></div>
<div class="line"><span class="lineno"> 3358</span><span class="stringliteral">    The relative weight of each item determines the probability that it</span></div>
<div class="line"><span class="lineno"> 3359</span><span class="stringliteral">    appears late in the permutation.</span></div>
<div class="line"><span class="lineno"> 3360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3361</span><span class="stringliteral">    &gt;&gt;&gt; data = &quot;abcdefgh&quot;</span></div>
<div class="line"><span class="lineno"> 3362</span><span class="stringliteral">    &gt;&gt;&gt; weights = range(1, len(data) + 1)</span></div>
<div class="line"><span class="lineno"> 3363</span><span class="stringliteral">    &gt;&gt;&gt; sample(data, k=len(data), weights=weights)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 3364</span><span class="stringliteral">    [&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;e&#39;, &#39;g&#39;, &#39;d&#39;, &#39;h&#39;, &#39;f&#39;]</span></div>
<div class="line"><span class="lineno"> 3365</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3366</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno"> 3367</span>        <span class="keywordflow">return</span> []</div>
<div class="line"><span class="lineno"> 3368</span> </div>
<div class="line"><span class="lineno"> 3369</span>    iterable = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 3370</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3371</span>        <span class="keywordflow">return</span> _sample_unweighted(iterable, k)</div>
<div class="line"><span class="lineno"> 3372</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3373</span>        weights = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(weights)</div>
<div class="line"><span class="lineno"> 3374</span>        <span class="keywordflow">return</span> _sample_weighted(iterable, k, weights)</div>
<div class="line"><span class="lineno"> 3375</span> </div>
<div class="line"><span class="lineno"> 3376</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a09aba9fcbb4adacab1fdac7c921e39b0" name="a09aba9fcbb4adacab1fdac7c921e39b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aba9fcbb4adacab1fdac7c921e39b0">&#9670;&#160;</a></span>set_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.set_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the set partitions of *iterable* into *k* parts. Set partitions are
not order-preserving.

&gt;&gt;&gt; iterable = 'abc'
&gt;&gt;&gt; for part in set_partitions(iterable, 2):
...     print([''.join(p) for p in part])
['a', 'bc']
['ab', 'c']
['b', 'ac']


If *k* is not given, every set partition is generated.

&gt;&gt;&gt; iterable = 'abc'
&gt;&gt;&gt; for part in set_partitions(iterable):
...     print([''.join(p) for p in part])
['abc']
['a', 'bc']
['ab', 'c']
['b', 'ac']
['a', 'b', 'c']</pre> <div class="fragment"><div class="line"><span class="lineno"> 3016</span><span class="keyword">def </span>set_partitions(iterable, k=None):</div>
<div class="line"><span class="lineno"> 3017</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3018</span><span class="stringliteral">    Yield the set partitions of *iterable* into *k* parts. Set partitions are</span></div>
<div class="line"><span class="lineno"> 3019</span><span class="stringliteral">    not order-preserving.</span></div>
<div class="line"><span class="lineno"> 3020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3021</span><span class="stringliteral">    &gt;&gt;&gt; iterable = &#39;abc&#39;</span></div>
<div class="line"><span class="lineno"> 3022</span><span class="stringliteral">    &gt;&gt;&gt; for part in set_partitions(iterable, 2):</span></div>
<div class="line"><span class="lineno"> 3023</span><span class="stringliteral">    ...     print([&#39;&#39;.join(p) for p in part])</span></div>
<div class="line"><span class="lineno"> 3024</span><span class="stringliteral">    [&#39;a&#39;, &#39;bc&#39;]</span></div>
<div class="line"><span class="lineno"> 3025</span><span class="stringliteral">    [&#39;ab&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno"> 3026</span><span class="stringliteral">    [&#39;b&#39;, &#39;ac&#39;]</span></div>
<div class="line"><span class="lineno"> 3027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral">    If *k* is not given, every set partition is generated.</span></div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3031</span><span class="stringliteral">    &gt;&gt;&gt; iterable = &#39;abc&#39;</span></div>
<div class="line"><span class="lineno"> 3032</span><span class="stringliteral">    &gt;&gt;&gt; for part in set_partitions(iterable):</span></div>
<div class="line"><span class="lineno"> 3033</span><span class="stringliteral">    ...     print([&#39;&#39;.join(p) for p in part])</span></div>
<div class="line"><span class="lineno"> 3034</span><span class="stringliteral">    [&#39;abc&#39;]</span></div>
<div class="line"><span class="lineno"> 3035</span><span class="stringliteral">    [&#39;a&#39;, &#39;bc&#39;]</span></div>
<div class="line"><span class="lineno"> 3036</span><span class="stringliteral">    [&#39;ab&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno"> 3037</span><span class="stringliteral">    [&#39;b&#39;, &#39;ac&#39;]</span></div>
<div class="line"><span class="lineno"> 3038</span><span class="stringliteral">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno"> 3039</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3040</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3041</span>    L = list(iterable)</div>
<div class="line"><span class="lineno"> 3042</span>    n = len(L)</div>
<div class="line"><span class="lineno"> 3043</span>    <span class="keywordflow">if</span> k <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3044</span>        <span class="keywordflow">if</span> k &lt; 1:</div>
<div class="line"><span class="lineno"> 3045</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3046</span>                <span class="stringliteral">&quot;Can&#39;t partition in a negative or zero number of groups&quot;</span></div>
<div class="line"><span class="lineno"> 3047</span>            )</div>
<div class="line"><span class="lineno"> 3048</span>        <span class="keywordflow">elif</span> k &gt; n:</div>
<div class="line"><span class="lineno"> 3049</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 3050</span> </div>
<div class="line"><span class="lineno"> 3051</span>    <span class="keyword">def </span>set_partitions_helper(L, k):</div>
<div class="line"><span class="lineno"> 3052</span>        n = len(L)</div>
<div class="line"><span class="lineno"> 3053</span>        <span class="keywordflow">if</span> k == 1:</div>
<div class="line"><span class="lineno"> 3054</span>            <span class="keywordflow">yield</span> [L]</div>
<div class="line"><span class="lineno"> 3055</span>        <span class="keywordflow">elif</span> n == k:</div>
<div class="line"><span class="lineno"> 3056</span>            <span class="keywordflow">yield</span> [[s] <span class="keywordflow">for</span> s <span class="keywordflow">in</span> L]</div>
<div class="line"><span class="lineno"> 3057</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3058</span>            e, *M = L</div>
<div class="line"><span class="lineno"> 3059</span>            <span class="keywordflow">for</span> p <span class="keywordflow">in</span> set_partitions_helper(M, k - 1):</div>
<div class="line"><span class="lineno"> 3060</span>                <span class="keywordflow">yield</span> [[e], *p]</div>
<div class="line"><span class="lineno"> 3061</span>            <span class="keywordflow">for</span> p <span class="keywordflow">in</span> set_partitions_helper(M, k):</div>
<div class="line"><span class="lineno"> 3062</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(p)):</div>
<div class="line"><span class="lineno"> 3063</span>                    <span class="keywordflow">yield</span> p[:i] + [[e] + p[i]] + p[i + 1 :]</div>
<div class="line"><span class="lineno"> 3064</span> </div>
<div class="line"><span class="lineno"> 3065</span>    <span class="keywordflow">if</span> k <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3066</span>        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(1, n + 1):</div>
<div class="line"><span class="lineno"> 3067</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> set_partitions_helper(L, k)</div>
<div class="line"><span class="lineno"> 3068</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3069</span>        <span class="keywordflow">yield</span> <span class="keyword">from</span> set_partitions_helper(L, k)</div>
<div class="line"><span class="lineno"> 3070</span> </div>
<div class="line"><span class="lineno"> 3071</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9fd87a60e18304da46bc5b9b42b14b1" name="aa9fd87a60e18304da46bc5b9b42b14b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fd87a60e18304da46bc5b9b42b14b1">&#9670;&#160;</a></span>side_effect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.side_effect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>before</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>after</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Invoke *func* on each item in *iterable* (or on each *chunk_size* group
of items) before yielding the item.

`func` must be a function that takes a single argument. Its return value
will be discarded.

*before* and *after* are optional functions that take no arguments. They
will be executed before iteration starts and after it ends, respectively.

`side_effect` can be used for logging, updating progress bars, or anything
that is not functionally "pure."

Emitting a status message:

    &gt;&gt;&gt; from more_itertools import consume
    &gt;&gt;&gt; func = lambda item: print('Received {}'.format(item))
    &gt;&gt;&gt; consume(side_effect(func, range(2)))
    Received 0
    Received 1

Operating on chunks of items:

    &gt;&gt;&gt; pair_sums = []
    &gt;&gt;&gt; func = lambda chunk: pair_sums.append(sum(chunk))
    &gt;&gt;&gt; list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))
    [0, 1, 2, 3, 4, 5]
    &gt;&gt;&gt; list(pair_sums)
    [1, 5, 9]

Writing to a file-like object:

    &gt;&gt;&gt; from io import StringIO
    &gt;&gt;&gt; from more_itertools import consume
    &gt;&gt;&gt; f = StringIO()
    &gt;&gt;&gt; func = lambda x: print(x, file=f)
    &gt;&gt;&gt; before = lambda: print(u'HEADER', file=f)
    &gt;&gt;&gt; after = f.close
    &gt;&gt;&gt; it = [u'a', u'b', u'c']
    &gt;&gt;&gt; consume(side_effect(func, it, before=before, after=after))
    &gt;&gt;&gt; f.closed
    True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1068</span><span class="keyword">def </span>side_effect(func, iterable, chunk_size=None, before=None, after=None):</div>
<div class="line"><span class="lineno"> 1069</span>    <span class="stringliteral">&quot;&quot;&quot;Invoke *func* on each item in *iterable* (or on each *chunk_size* group</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    of items) before yielding the item.</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    `func` must be a function that takes a single argument. Its return value</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    will be discarded.</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    *before* and *after* are optional functions that take no arguments. They</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">    will be executed before iteration starts and after it ends, respectively.</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    `side_effect` can be used for logging, updating progress bars, or anything</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    that is not functionally &quot;pure.&quot;</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    Emitting a status message:</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">        &gt;&gt;&gt; from more_itertools import consume</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">        &gt;&gt;&gt; func = lambda item: print(&#39;Received {}&#39;.format(item))</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">        &gt;&gt;&gt; consume(side_effect(func, range(2)))</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">        Received 0</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">        Received 1</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    Operating on chunks of items:</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">        &gt;&gt;&gt; pair_sums = []</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">        &gt;&gt;&gt; func = lambda chunk: pair_sums.append(sum(chunk))</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">        &gt;&gt;&gt; list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        [0, 1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">        &gt;&gt;&gt; list(pair_sums)</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">        [1, 5, 9]</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    Writing to a file-like object:</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">        &gt;&gt;&gt; from io import StringIO</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">        &gt;&gt;&gt; from more_itertools import consume</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">        &gt;&gt;&gt; f = StringIO()</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">        &gt;&gt;&gt; func = lambda x: print(x, file=f)</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">        &gt;&gt;&gt; before = lambda: print(u&#39;HEADER&#39;, file=f)</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">        &gt;&gt;&gt; after = f.close</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">        &gt;&gt;&gt; it = [u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;]</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">        &gt;&gt;&gt; consume(side_effect(func, it, before=before, after=after))</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">        &gt;&gt;&gt; f.closed</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1112</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1113</span>        <span class="keywordflow">if</span> before <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1114</span>            before()</div>
<div class="line"><span class="lineno"> 1115</span> </div>
<div class="line"><span class="lineno"> 1116</span>        <span class="keywordflow">if</span> chunk_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1117</span>            <span class="keywordflow">for</span> item <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno"> 1118</span>                <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(item)</div>
<div class="line"><span class="lineno"> 1119</span>                <span class="keywordflow">yield</span> item</div>
<div class="line"><span class="lineno"> 1120</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1121</span>            <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> chunked(iterable, chunk_size):</div>
<div class="line"><span class="lineno"> 1122</span>                <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(chunk)</div>
<div class="line"><span class="lineno"> 1123</span>                <span class="keywordflow">yield</span> <span class="keyword">from</span> chunk</div>
<div class="line"><span class="lineno"> 1124</span>    <span class="keywordflow">finally</span>:</div>
<div class="line"><span class="lineno"> 1125</span>        <span class="keywordflow">if</span> after <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1126</span>            after()</div>
<div class="line"><span class="lineno"> 1127</span> </div>
<div class="line"><span class="lineno"> 1128</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a56d69cf216f30f8434561bc98a0dd779" name="a56d69cf216f30f8434561bc98a0dd779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d69cf216f30f8434561bc98a0dd779">&#9670;&#160;</a></span>sliced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.sliced </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield slices of length *n* from the sequence *seq*.

&gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6), 3))
[(1, 2, 3), (4, 5, 6)]

By the default, the last yielded slice will have fewer than *n* elements
if the length of *seq* is not divisible by *n*:

&gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))
[(1, 2, 3), (4, 5, 6), (7, 8)]

If the length of *seq* is not divisible by *n* and *strict* is
``True``, then ``ValueError`` will be raised before the last
slice is yielded.

This function will only work for iterables that support slicing.
For non-sliceable iterables, see :func:`chunked`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1129</span><span class="keyword">def </span>sliced(seq, n, strict=False):</div>
<div class="line"><span class="lineno"> 1130</span>    <span class="stringliteral">&quot;&quot;&quot;Yield slices of length *n* from the sequence *seq*.</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    &gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6), 3))</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    [(1, 2, 3), (4, 5, 6)]</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    By the default, the last yielded slice will have fewer than *n* elements</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    if the length of *seq* is not divisible by *n*:</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">    &gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    [(1, 2, 3), (4, 5, 6), (7, 8)]</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">    If the length of *seq* is not divisible by *n* and *strict* is</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    ``True``, then ``ValueError`` will be raised before the last</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    slice is yielded.</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">    This function will only work for iterables that support slicing.</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    For non-sliceable iterables, see :func:`chunked`.</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1149</span>    iterator = takewhile(len, (seq[i : i + n] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> count(0, n)))</div>
<div class="line"><span class="lineno"> 1150</span>    <span class="keywordflow">if</span> strict:</div>
<div class="line"><span class="lineno"> 1151</span> </div>
<div class="line"><span class="lineno"> 1152</span>        <span class="keyword">def </span>ret():</div>
<div class="line"><span class="lineno"> 1153</span>            <span class="keywordflow">for</span> _slice <span class="keywordflow">in</span> iterator:</div>
<div class="line"><span class="lineno"> 1154</span>                <span class="keywordflow">if</span> len(_slice) != n:</div>
<div class="line"><span class="lineno"> 1155</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;seq is not divisible by n.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1156</span>                <span class="keywordflow">yield</span> _slice</div>
<div class="line"><span class="lineno"> 1157</span> </div>
<div class="line"><span class="lineno"> 1158</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(ret())</div>
<div class="line"><span class="lineno"> 1159</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1160</span>        <span class="keywordflow">return</span> iterator</div>
<div class="line"><span class="lineno"> 1161</span> </div>
<div class="line"><span class="lineno"> 1162</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aea9b12c4b7074c419c909ee5b3b0b8cf" name="aea9b12c4b7074c419c909ee5b3b0b8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9b12c4b7074c419c909ee5b3b0b8cf">&#9670;&#160;</a></span>sort_together()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.sort_together </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_list</em> = <code>(0,)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the input iterables sorted together, with *key_list* as the
priority for sorting. All iterables are trimmed to the length of the
shortest one.

This can be used like the sorting function in a spreadsheet. If each
iterable represents a column of data, the key list determines which
columns are used for sorting.

By default, all iterables are sorted using the ``0``-th iterable::

    &gt;&gt;&gt; iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]
    &gt;&gt;&gt; sort_together(iterables)
    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]

Set a different key list to sort according to another iterable.
Specifying multiple keys dictates how ties are broken::

    &gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]
    &gt;&gt;&gt; sort_together(iterables, key_list=(1, 2))
    [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]

To sort by a function of the elements of the iterable, pass a *key*
function. Its arguments are the elements of the iterables corresponding to
the key list::

    &gt;&gt;&gt; names = ('a', 'b', 'c')
    &gt;&gt;&gt; lengths = (1, 2, 3)
    &gt;&gt;&gt; widths = (5, 2, 1)
    &gt;&gt;&gt; def area(length, width):
    ...     return length * width
    &gt;&gt;&gt; sort_together([names, lengths, widths], key_list=(1, 2), key=area)
    [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]

Set *reverse* to ``True`` to sort in descending order.

    &gt;&gt;&gt; sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)
    [(3, 2, 1), ('a', 'b', 'c')]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1586</span><span class="keyword">def </span>sort_together(iterables, key_list=(0,), key=<span class="keywordtype">None</span>, reverse=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 1587</span>    <span class="stringliteral">&quot;&quot;&quot;Return the input iterables sorted together, with *key_list* as the</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    priority for sorting. All iterables are trimmed to the length of the</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    shortest one.</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    This can be used like the sorting function in a spreadsheet. If each</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    iterable represents a column of data, the key list determines which</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    columns are used for sorting.</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    By default, all iterables are sorted using the ``0``-th iterable::</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">        &gt;&gt;&gt; iterables = [(4, 3, 2, 1), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)]</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">        &gt;&gt;&gt; sort_together(iterables)</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">        [(1, 2, 3, 4), (&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;)]</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    Set a different key list to sort according to another iterable.</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    Specifying multiple keys dictates how ties are broken::</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">        &gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), (&#39;c&#39;, &#39;b&#39;, &#39;a&#39;)]</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        &gt;&gt;&gt; sort_together(iterables, key_list=(1, 2))</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">        [(2, 3, 1), (0, 0, 1), (&#39;a&#39;, &#39;c&#39;, &#39;b&#39;)]</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    To sort by a function of the elements of the iterable, pass a *key*</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">    function. Its arguments are the elements of the iterables corresponding to</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">    the key list::</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">        &gt;&gt;&gt; names = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">        &gt;&gt;&gt; lengths = (1, 2, 3)</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">        &gt;&gt;&gt; widths = (5, 2, 1)</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral">        &gt;&gt;&gt; def area(length, width):</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        ...     return length * width</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">        &gt;&gt;&gt; sort_together([names, lengths, widths], key_list=(1, 2), key=area)</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">        [(&#39;c&#39;, &#39;b&#39;, &#39;a&#39;), (3, 2, 1), (1, 2, 5)]</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">    Set *reverse* to ``True`` to sort in descending order.</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">        &gt;&gt;&gt; sort_together([(1, 2, 3), (&#39;c&#39;, &#39;b&#39;, &#39;a&#39;)], reverse=True)</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">        [(3, 2, 1), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)]</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1626</span>    <span class="keywordflow">if</span> key <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1627</span>        <span class="comment"># if there is no key function, the key argument to sorted is an</span></div>
<div class="line"><span class="lineno"> 1628</span>        <span class="comment"># itemgetter</span></div>
<div class="line"><span class="lineno"> 1629</span>        key_argument = itemgetter(*key_list)</div>
<div class="line"><span class="lineno"> 1630</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1631</span>        <span class="comment"># if there is a key function, call it with the items at the offsets</span></div>
<div class="line"><span class="lineno"> 1632</span>        <span class="comment"># specified by the key function as arguments</span></div>
<div class="line"><span class="lineno"> 1633</span>        key_list = list(key_list)</div>
<div class="line"><span class="lineno"> 1634</span>        <span class="keywordflow">if</span> len(key_list) == 1:</div>
<div class="line"><span class="lineno"> 1635</span>            <span class="comment"># if key_list contains a single item, pass the item at that offset</span></div>
<div class="line"><span class="lineno"> 1636</span>            <span class="comment"># as the only argument to the key function</span></div>
<div class="line"><span class="lineno"> 1637</span>            key_offset = key_list[0]</div>
<div class="line"><span class="lineno"> 1638</span>            key_argument = <span class="keyword">lambda</span> zipped_items: key(zipped_items[key_offset])</div>
<div class="line"><span class="lineno"> 1639</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1640</span>            <span class="comment"># if key_list contains multiple items, use itemgetter to return a</span></div>
<div class="line"><span class="lineno"> 1641</span>            <span class="comment"># tuple of items, which we pass as *args to the key function</span></div>
<div class="line"><span class="lineno"> 1642</span>            get_key_items = itemgetter(*key_list)</div>
<div class="line"><span class="lineno"> 1643</span>            key_argument = <span class="keyword">lambda</span> zipped_items: key(</div>
<div class="line"><span class="lineno"> 1644</span>                *get_key_items(zipped_items)</div>
<div class="line"><span class="lineno"> 1645</span>            )</div>
<div class="line"><span class="lineno"> 1646</span> </div>
<div class="line"><span class="lineno"> 1647</span>    <span class="keywordflow">return</span> list(</div>
<div class="line"><span class="lineno"> 1648</span>        zip(*sorted(zip(*iterables), key=key_argument, reverse=reverse))</div>
<div class="line"><span class="lineno"> 1649</span>    )</div>
<div class="line"><span class="lineno"> 1650</span> </div>
<div class="line"><span class="lineno"> 1651</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aec868cc95b2ee87797046cbf8083e47d" name="aec868cc95b2ee87797046cbf8083e47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec868cc95b2ee87797046cbf8083e47d">&#9670;&#160;</a></span>split_after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_after </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield lists of items from *iterable*, where each list ends with an
item where callable *pred* returns ``True``:

    &gt;&gt;&gt; list(split_after('one1two2', lambda s: s.isdigit()))
    [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]

    &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0))
    [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))
    [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1242</span><span class="keyword">def </span>split_after(iterable, pred, maxsplit=-1):</div>
<div class="line"><span class="lineno"> 1243</span>    <span class="stringliteral">&quot;&quot;&quot;Yield lists of items from *iterable*, where each list ends with an</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    item where callable *pred* returns ``True``:</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">        &gt;&gt;&gt; list(split_after(&#39;one1two2&#39;, lambda s: s.isdigit()))</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">        [[&#39;o&#39;, &#39;n&#39;, &#39;e&#39;, &#39;1&#39;], [&#39;t&#39;, &#39;w&#39;, &#39;o&#39;, &#39;2&#39;]]</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">        &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0))</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">    then there is no limit on the number of splits:</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">        &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1259</span>    <span class="keywordflow">if</span> maxsplit == 0:</div>
<div class="line"><span class="lineno"> 1260</span>        <span class="keywordflow">yield</span> list(iterable)</div>
<div class="line"><span class="lineno"> 1261</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1262</span> </div>
<div class="line"><span class="lineno"> 1263</span>    buf = []</div>
<div class="line"><span class="lineno"> 1264</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 1265</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> it:</div>
<div class="line"><span class="lineno"> 1266</span>        buf.append(item)</div>
<div class="line"><span class="lineno"> 1267</span>        <span class="keywordflow">if</span> pred(item) <span class="keywordflow">and</span> buf:</div>
<div class="line"><span class="lineno"> 1268</span>            <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1269</span>            <span class="keywordflow">if</span> maxsplit == 1:</div>
<div class="line"><span class="lineno"> 1270</span>                <span class="keywordflow">yield</span> list(it)</div>
<div class="line"><span class="lineno"> 1271</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1272</span>            buf = []</div>
<div class="line"><span class="lineno"> 1273</span>            maxsplit -= 1</div>
<div class="line"><span class="lineno"> 1274</span>    <span class="keywordflow">if</span> buf:</div>
<div class="line"><span class="lineno"> 1275</span>        <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1276</span> </div>
<div class="line"><span class="lineno"> 1277</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c21ccdd1a1500b43fd08fe03f0f3c2c" name="a0c21ccdd1a1500b43fd08fe03f0f3c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c21ccdd1a1500b43fd08fe03f0f3c2c">&#9670;&#160;</a></span>split_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_at </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_separator</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield lists of items from *iterable*, where each list is delimited by
an item where callable *pred* returns ``True``.

    &gt;&gt;&gt; list(split_at('abcdcba', lambda x: x == 'b'))
    [['a'], ['c', 'd', 'c'], ['a']]

    &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1))
    [[0], [2], [4], [6], [8], []]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))
    [[0], [2], [4, 5, 6, 7, 8, 9]]

By default, the delimiting items are not included in the output.
The include them, set *keep_separator* to ``True``.

    &gt;&gt;&gt; list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))
    [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1163</span><span class="keyword">def </span>split_at(iterable, pred, maxsplit=-1, keep_separator=False):</div>
<div class="line"><span class="lineno"> 1164</span>    <span class="stringliteral">&quot;&quot;&quot;Yield lists of items from *iterable*, where each list is delimited by</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    an item where callable *pred* returns ``True``.</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">        &gt;&gt;&gt; list(split_at(&#39;abcdcba&#39;, lambda x: x == &#39;b&#39;))</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">        [[&#39;a&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;c&#39;], [&#39;a&#39;]]</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">        &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1))</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">        [[0], [2], [4], [6], [8], []]</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    then there is no limit on the number of splits:</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">        &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">        [[0], [2], [4, 5, 6, 7, 8, 9]]</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    By default, the delimiting items are not included in the output.</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    The include them, set *keep_separator* to ``True``.</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">        &gt;&gt;&gt; list(split_at(&#39;abcdcba&#39;, lambda x: x == &#39;b&#39;, keep_separator=True))</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">        [[&#39;a&#39;], [&#39;b&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;c&#39;], [&#39;b&#39;], [&#39;a&#39;]]</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1186</span>    <span class="keywordflow">if</span> maxsplit == 0:</div>
<div class="line"><span class="lineno"> 1187</span>        <span class="keywordflow">yield</span> list(iterable)</div>
<div class="line"><span class="lineno"> 1188</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1189</span> </div>
<div class="line"><span class="lineno"> 1190</span>    buf = []</div>
<div class="line"><span class="lineno"> 1191</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 1192</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> it:</div>
<div class="line"><span class="lineno"> 1193</span>        <span class="keywordflow">if</span> pred(item):</div>
<div class="line"><span class="lineno"> 1194</span>            <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1195</span>            <span class="keywordflow">if</span> keep_separator:</div>
<div class="line"><span class="lineno"> 1196</span>                <span class="keywordflow">yield</span> [item]</div>
<div class="line"><span class="lineno"> 1197</span>            <span class="keywordflow">if</span> maxsplit == 1:</div>
<div class="line"><span class="lineno"> 1198</span>                <span class="keywordflow">yield</span> list(it)</div>
<div class="line"><span class="lineno"> 1199</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1200</span>            buf = []</div>
<div class="line"><span class="lineno"> 1201</span>            maxsplit -= 1</div>
<div class="line"><span class="lineno"> 1202</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1203</span>            buf.append(item)</div>
<div class="line"><span class="lineno"> 1204</span>    <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1205</span> </div>
<div class="line"><span class="lineno"> 1206</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7aee350818833ba18a93b952983d841" name="ad7aee350818833ba18a93b952983d841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aee350818833ba18a93b952983d841">&#9670;&#160;</a></span>split_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_before </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield lists of items from *iterable*, where each list ends just before
an item for which callable *pred* returns ``True``:

    &gt;&gt;&gt; list(split_before('OneTwo', lambda s: s.isupper()))
    [['O', 'n', 'e'], ['T', 'w', 'o']]

    &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0))
    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))
    [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1207</span><span class="keyword">def </span>split_before(iterable, pred, maxsplit=-1):</div>
<div class="line"><span class="lineno"> 1208</span>    <span class="stringliteral">&quot;&quot;&quot;Yield lists of items from *iterable*, where each list ends just before</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    an item for which callable *pred* returns ``True``:</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">        &gt;&gt;&gt; list(split_before(&#39;OneTwo&#39;, lambda s: s.isupper()))</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">        [[&#39;O&#39;, &#39;n&#39;, &#39;e&#39;], [&#39;T&#39;, &#39;w&#39;, &#39;o&#39;]]</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">        &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0))</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    then there is no limit on the number of splits:</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">        &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1223</span>    <span class="keywordflow">if</span> maxsplit == 0:</div>
<div class="line"><span class="lineno"> 1224</span>        <span class="keywordflow">yield</span> list(iterable)</div>
<div class="line"><span class="lineno"> 1225</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1226</span> </div>
<div class="line"><span class="lineno"> 1227</span>    buf = []</div>
<div class="line"><span class="lineno"> 1228</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 1229</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> it:</div>
<div class="line"><span class="lineno"> 1230</span>        <span class="keywordflow">if</span> pred(item) <span class="keywordflow">and</span> buf:</div>
<div class="line"><span class="lineno"> 1231</span>            <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1232</span>            <span class="keywordflow">if</span> maxsplit == 1:</div>
<div class="line"><span class="lineno"> 1233</span>                <span class="keywordflow">yield</span> [item] + list(it)</div>
<div class="line"><span class="lineno"> 1234</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1235</span>            buf = []</div>
<div class="line"><span class="lineno"> 1236</span>            maxsplit -= 1</div>
<div class="line"><span class="lineno"> 1237</span>        buf.append(item)</div>
<div class="line"><span class="lineno"> 1238</span>    <span class="keywordflow">if</span> buf:</div>
<div class="line"><span class="lineno"> 1239</span>        <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1240</span> </div>
<div class="line"><span class="lineno"> 1241</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2414703c881898f60f20d405da23acc0" name="a2414703c881898f60f20d405da23acc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2414703c881898f60f20d405da23acc0">&#9670;&#160;</a></span>split_into()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_into </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield a list of sequential items from *iterable* of length 'n' for each
integer 'n' in *sizes*.

    &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [1,2,3]))
    [[1], [2, 3], [4, 5, 6]]

If the sum of *sizes* is smaller than the length of *iterable*, then the
remaining items of *iterable* will not be returned.

    &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [2,3]))
    [[1, 2], [3, 4, 5]]

If the sum of *sizes* is larger than the length of *iterable*, fewer items
will be returned in the iteration that overruns *iterable* and further
lists will be empty:

    &gt;&gt;&gt; list(split_into([1,2,3,4], [1,2,3,4]))
    [[1], [2, 3], [4], []]

When a ``None`` object is encountered in *sizes*, the returned list will
contain items up to the end of *iterable* the same way that itertools.slice
does:

    &gt;&gt;&gt; list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))
    [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]

:func:`split_into` can be useful for grouping a series of items where the
sizes of the groups are not uniform. An example would be where in a row
from a table, multiple columns represent elements of the same feature
(e.g. a point represented by x,y,z) but, the format is not the same for
all columns.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1323</span><span class="keyword">def </span>split_into(iterable, sizes):</div>
<div class="line"><span class="lineno"> 1324</span>    <span class="stringliteral">&quot;&quot;&quot;Yield a list of sequential items from *iterable* of length &#39;n&#39; for each</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    integer &#39;n&#39; in *sizes*.</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">        &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [1,2,3]))</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">        [[1], [2, 3], [4, 5, 6]]</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    If the sum of *sizes* is smaller than the length of *iterable*, then the</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    remaining items of *iterable* will not be returned.</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">        &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [2,3]))</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">        [[1, 2], [3, 4, 5]]</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    If the sum of *sizes* is larger than the length of *iterable*, fewer items</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    will be returned in the iteration that overruns *iterable* and further</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    lists will be empty:</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">        &gt;&gt;&gt; list(split_into([1,2,3,4], [1,2,3,4]))</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        [[1], [2, 3], [4], []]</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    When a ``None`` object is encountered in *sizes*, the returned list will</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    contain items up to the end of *iterable* the same way that itertools.slice</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    does:</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">        &gt;&gt;&gt; list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    :func:`split_into` can be useful for grouping a series of items where the</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    sizes of the groups are not uniform. An example would be where in a row</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    from a table, multiple columns represent elements of the same feature</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    (e.g. a point represented by x,y,z) but, the format is not the same for</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    all columns.</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1356</span>    <span class="comment"># convert the iterable argument into an iterator so its contents can</span></div>
<div class="line"><span class="lineno"> 1357</span>    <span class="comment"># be consumed by islice in case it is a generator</span></div>
<div class="line"><span class="lineno"> 1358</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 1359</span> </div>
<div class="line"><span class="lineno"> 1360</span>    <span class="keywordflow">for</span> size <span class="keywordflow">in</span> sizes:</div>
<div class="line"><span class="lineno"> 1361</span>        <span class="keywordflow">if</span> size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1362</span>            <span class="keywordflow">yield</span> list(it)</div>
<div class="line"><span class="lineno"> 1363</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1364</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1365</span>            <span class="keywordflow">yield</span> list(islice(it, size))</div>
<div class="line"><span class="lineno"> 1366</span> </div>
<div class="line"><span class="lineno"> 1367</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a524b6352594c860dfa3b742832d114aa" name="a524b6352594c860dfa3b742832d114aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524b6352594c860dfa3b742832d114aa">&#9670;&#160;</a></span>split_when()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.split_when </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Split *iterable* into pieces based on the output of *pred*.
*pred* should be a function that takes successive pairs of items and
returns ``True`` if the iterable should be split in between them.

For example, to find runs of increasing numbers, split the iterable when
element ``i`` is larger than element ``i + 1``:

    &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x &gt; y))
    [[1, 2, 3, 3], [2, 5], [2, 4], [2]]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],
    ...                 lambda x, y: x &gt; y, maxsplit=2))
    [[1, 2, 3, 3], [2, 5], [2, 4, 2]]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1278</span><span class="keyword">def </span>split_when(iterable, pred, maxsplit=-1):</div>
<div class="line"><span class="lineno"> 1279</span>    <span class="stringliteral">&quot;&quot;&quot;Split *iterable* into pieces based on the output of *pred*.</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    *pred* should be a function that takes successive pairs of items and</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    returns ``True`` if the iterable should be split in between them.</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">    For example, to find runs of increasing numbers, split the iterable when</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    element ``i`` is larger than element ``i + 1``:</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">        &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x &gt; y))</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    then there is no limit on the number of splits:</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">        &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">        ...                 lambda x, y: x &gt; y, maxsplit=2))</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1297</span>    <span class="keywordflow">if</span> maxsplit == 0:</div>
<div class="line"><span class="lineno"> 1298</span>        <span class="keywordflow">yield</span> list(iterable)</div>
<div class="line"><span class="lineno"> 1299</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1300</span> </div>
<div class="line"><span class="lineno"> 1301</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno"> 1302</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1303</span>        cur_item = next(it)</div>
<div class="line"><span class="lineno"> 1304</span>    <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno"> 1305</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1306</span> </div>
<div class="line"><span class="lineno"> 1307</span>    buf = [cur_item]</div>
<div class="line"><span class="lineno"> 1308</span>    <span class="keywordflow">for</span> next_item <span class="keywordflow">in</span> it:</div>
<div class="line"><span class="lineno"> 1309</span>        <span class="keywordflow">if</span> pred(cur_item, next_item):</div>
<div class="line"><span class="lineno"> 1310</span>            <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1311</span>            <span class="keywordflow">if</span> maxsplit == 1:</div>
<div class="line"><span class="lineno"> 1312</span>                <span class="keywordflow">yield</span> [next_item] + list(it)</div>
<div class="line"><span class="lineno"> 1313</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1314</span>            buf = []</div>
<div class="line"><span class="lineno"> 1315</span>            maxsplit -= 1</div>
<div class="line"><span class="lineno"> 1316</span> </div>
<div class="line"><span class="lineno"> 1317</span>        buf.append(next_item)</div>
<div class="line"><span class="lineno"> 1318</span>        cur_item = next_item</div>
<div class="line"><span class="lineno"> 1319</span> </div>
<div class="line"><span class="lineno"> 1320</span>    <span class="keywordflow">yield</span> buf</div>
<div class="line"><span class="lineno"> 1321</span> </div>
<div class="line"><span class="lineno"> 1322</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad404f78ea35afd075654a37ad98a9426" name="ad404f78ea35afd075654a37ad98a9426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad404f78ea35afd075654a37ad98a9426">&#9670;&#160;</a></span>spy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.spy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a 2-tuple with a list containing the first *n* elements of
*iterable*, and an iterator with the same items as *iterable*.
This allows you to "look ahead" at the items in the iterable without
advancing it.

There is one item in the list by default:

    &gt;&gt;&gt; iterable = 'abcdefg'
    &gt;&gt;&gt; head, iterable = spy(iterable)
    &gt;&gt;&gt; head
    ['a']
    &gt;&gt;&gt; list(iterable)
    ['a', 'b', 'c', 'd', 'e', 'f', 'g']

You may use unpacking to retrieve items instead of lists:

    &gt;&gt;&gt; (head,), iterable = spy('abcdefg')
    &gt;&gt;&gt; head
    'a'
    &gt;&gt;&gt; (first, second), iterable = spy('abcdefg', 2)
    &gt;&gt;&gt; first
    'a'
    &gt;&gt;&gt; second
    'b'

The number of items requested can be larger than the number of items in
the iterable:

    &gt;&gt;&gt; iterable = [1, 2, 3, 4, 5]
    &gt;&gt;&gt; head, iterable = spy(iterable, 10)
    &gt;&gt;&gt; head
    [1, 2, 3, 4, 5]
    &gt;&gt;&gt; list(iterable)
    [1, 2, 3, 4, 5]</pre> <div class="fragment"><div class="line"><span class="lineno">  947</span><span class="keyword">def </span>spy(iterable, n=1):</div>
<div class="line"><span class="lineno">  948</span>    <span class="stringliteral">&quot;&quot;&quot;Return a 2-tuple with a list containing the first *n* elements of</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">    *iterable*, and an iterator with the same items as *iterable*.</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    This allows you to &quot;look ahead&quot; at the items in the iterable without</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    advancing it.</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    There is one item in the list by default:</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">        &gt;&gt;&gt; iterable = &#39;abcdefg&#39;</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">        &gt;&gt;&gt; head, iterable = spy(iterable)</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">        &gt;&gt;&gt; head</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">        [&#39;a&#39;]</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">        &gt;&gt;&gt; list(iterable)</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    You may use unpacking to retrieve items instead of lists:</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">        &gt;&gt;&gt; (head,), iterable = spy(&#39;abcdefg&#39;)</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">        &gt;&gt;&gt; head</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">        &#39;a&#39;</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">        &gt;&gt;&gt; (first, second), iterable = spy(&#39;abcdefg&#39;, 2)</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">        &gt;&gt;&gt; first</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">        &#39;a&#39;</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">        &gt;&gt;&gt; second</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">        &#39;b&#39;</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    The number of items requested can be larger than the number of items in</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">    the iterable:</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">        &gt;&gt;&gt; head, iterable = spy(iterable, 10)</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">        &gt;&gt;&gt; head</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">        [1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">        &gt;&gt;&gt; list(iterable)</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">        [1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  984</span>    it = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno">  985</span>    head = take(n, it)</div>
<div class="line"><span class="lineno">  986</span> </div>
<div class="line"><span class="lineno">  987</span>    <span class="keywordflow">return</span> head.copy(), chain(head, it)</div>
<div class="line"><span class="lineno">  988</span> </div>
<div class="line"><span class="lineno">  989</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6a5061bfeab377fdcb3819d122ea2ae" name="aa6a5061bfeab377fdcb3819d122ea2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a5061bfeab377fdcb3819d122ea2ae">&#9670;&#160;</a></span>stagger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.stagger </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em> = <code>(-1,&#160;0,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>longest</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield tuples whose elements are offset from *iterable*.
The amount by which the `i`-th item in each tuple is offset is given by
the `i`-th item in *offsets*.

    &gt;&gt;&gt; list(stagger([0, 1, 2, 3]))
    [(None, 0, 1), (0, 1, 2), (1, 2, 3)]
    &gt;&gt;&gt; list(stagger(range(8), offsets=(0, 2, 4)))
    [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]

By default, the sequence will end when the final element of a tuple is the
last item in the iterable. To continue until the first element of a tuple
is the last item in the iterable, set *longest* to ``True``::

    &gt;&gt;&gt; list(stagger([0, 1, 2, 3], longest=True))
    [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]

By default, ``None`` will be used to replace offsets beyond the end of the
sequence. Specify *fillvalue* to use some other value.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1454</span><span class="keyword">def </span>stagger(iterable, offsets=(-1, 0, 1), longest=<span class="keyword">False</span>, fillvalue=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1455</span>    <span class="stringliteral">&quot;&quot;&quot;Yield tuples whose elements are offset from *iterable*.</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">    The amount by which the `i`-th item in each tuple is offset is given by</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">    the `i`-th item in *offsets*.</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">        &gt;&gt;&gt; list(stagger([0, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">        &gt;&gt;&gt; list(stagger(range(8), offsets=(0, 2, 4)))</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">    By default, the sequence will end when the final element of a tuple is the</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">    last item in the iterable. To continue until the first element of a tuple</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    is the last item in the iterable, set *longest* to ``True``::</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">        &gt;&gt;&gt; list(stagger([0, 1, 2, 3], longest=True))</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">    By default, ``None`` will be used to replace offsets beyond the end of the</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    sequence. Specify *fillvalue* to use some other value.</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1475</span>    children = tee(iterable, len(offsets))</div>
<div class="line"><span class="lineno"> 1476</span> </div>
<div class="line"><span class="lineno"> 1477</span>    <span class="keywordflow">return</span> zip_offset(</div>
<div class="line"><span class="lineno"> 1478</span>        *children, offsets=offsets, longest=longest, fillvalue=fillvalue</div>
<div class="line"><span class="lineno"> 1479</span>    )</div>
<div class="line"><span class="lineno"> 1480</span> </div>
<div class="line"><span class="lineno"> 1481</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4aacddd1fb6d2525e7ca741424fd0045" name="a4aacddd1fb6d2525e7ca741424fd0045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aacddd1fb6d2525e7ca741424fd0045">&#9670;&#160;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.strip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, but strip any from the
beginning and end for which *pred* returns ``True``.

For example, to remove a set of items from both ends of an iterable:

    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)
    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}
    &gt;&gt;&gt; list(strip(iterable, pred))
    [1, 2, None, 3]

This function is analogous to :func:`str.strip`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2251</span><span class="keyword">def </span>strip(iterable, pred):</div>
<div class="line"><span class="lineno"> 2252</span>    <span class="stringliteral">&quot;&quot;&quot;Yield the items from *iterable*, but strip any from the</span></div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">    beginning and end for which *pred* returns ``True``.</span></div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">    For example, to remove a set of items from both ends of an iterable:</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral">        &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)</span></div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">        &gt;&gt;&gt; pred = lambda x: x in {None, False, &#39;&#39;}</span></div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral">        &gt;&gt;&gt; list(strip(iterable, pred))</span></div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">        [1, 2, None, 3]</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral">    This function is analogous to :func:`str.strip`.</span></div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2265</span>    <span class="keywordflow">return</span> rstrip(lstrip(iterable, pred), pred)</div>
<div class="line"><span class="lineno"> 2266</span> </div>
<div class="line"><span class="lineno"> 2267</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0cdc9a02ebf3b5ed801ceee08af6afb5" name="a0cdc9a02ebf3b5ed801ceee08af6afb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdc9a02ebf3b5ed801ceee08af6afb5">&#9670;&#160;</a></span>substrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.substrings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all of the substrings of *iterable*.

    &gt;&gt;&gt; [''.join(s) for s in substrings('more')]
    ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']

Note that non-string iterables can also be subdivided.

    &gt;&gt;&gt; list(substrings([0, 1, 2]))
    [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]</pre> <div class="fragment"><div class="line"><span class="lineno">  791</span><span class="keyword">def </span>substrings(iterable):</div>
<div class="line"><span class="lineno">  792</span>    <span class="stringliteral">&quot;&quot;&quot;Yield all of the substrings of *iterable*.</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        &gt;&gt;&gt; [&#39;&#39;.join(s) for s in substrings(&#39;more&#39;)]</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        [&#39;m&#39;, &#39;o&#39;, &#39;r&#39;, &#39;e&#39;, &#39;mo&#39;, &#39;or&#39;, &#39;re&#39;, &#39;mor&#39;, &#39;ore&#39;, &#39;more&#39;]</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    Note that non-string iterables can also be subdivided.</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        &gt;&gt;&gt; list(substrings([0, 1, 2]))</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  803</span>    <span class="comment"># The length-1 substrings</span></div>
<div class="line"><span class="lineno">  804</span>    seq = []</div>
<div class="line"><span class="lineno">  805</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable):</div>
<div class="line"><span class="lineno">  806</span>        seq.append(item)</div>
<div class="line"><span class="lineno">  807</span>        <span class="keywordflow">yield</span> (item,)</div>
<div class="line"><span class="lineno">  808</span>    seq = tuple(seq)</div>
<div class="line"><span class="lineno">  809</span>    item_count = len(seq)</div>
<div class="line"><span class="lineno">  810</span> </div>
<div class="line"><span class="lineno">  811</span>    <span class="comment"># And the rest</span></div>
<div class="line"><span class="lineno">  812</span>    <span class="keywordflow">for</span> n <span class="keywordflow">in</span> range(2, item_count + 1):</div>
<div class="line"><span class="lineno">  813</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(item_count - n + 1):</div>
<div class="line"><span class="lineno">  814</span>            <span class="keywordflow">yield</span> seq[i : i + n]</div>
<div class="line"><span class="lineno">  815</span> </div>
<div class="line"><span class="lineno">  816</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac255ef443ff15888f55c49aa1f070ff4" name="ac255ef443ff15888f55c49aa1f070ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac255ef443ff15888f55c49aa1f070ff4">&#9670;&#160;</a></span>substrings_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.substrings_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all substrings and their positions in *seq*

The items yielded will be a tuple of the form ``(substr, i, j)``, where
``substr == seq[i:j]``.

This function only works for iterables that support slicing, such as
``str`` objects.

&gt;&gt;&gt; for item in substrings_indexes('more'):
...    print(item)
('m', 0, 1)
('o', 1, 2)
('r', 2, 3)
('e', 3, 4)
('mo', 0, 2)
('or', 1, 3)
('re', 2, 4)
('mor', 0, 3)
('ore', 1, 4)
('more', 0, 4)

Set *reverse* to ``True`` to yield the same items in the opposite order.</pre> <div class="fragment"><div class="line"><span class="lineno">  817</span><span class="keyword">def </span>substrings_indexes(seq, reverse=False):</div>
<div class="line"><span class="lineno">  818</span>    <span class="stringliteral">&quot;&quot;&quot;Yield all substrings and their positions in *seq*</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    The items yielded will be a tuple of the form ``(substr, i, j)``, where</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    ``substr == seq[i:j]``.</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    This function only works for iterables that support slicing, such as</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    ``str`` objects.</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    &gt;&gt;&gt; for item in substrings_indexes(&#39;more&#39;):</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    ...    print(item)</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    (&#39;m&#39;, 0, 1)</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    (&#39;o&#39;, 1, 2)</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    (&#39;r&#39;, 2, 3)</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    (&#39;e&#39;, 3, 4)</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    (&#39;mo&#39;, 0, 2)</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    (&#39;or&#39;, 1, 3)</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    (&#39;re&#39;, 2, 4)</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    (&#39;mor&#39;, 0, 3)</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    (&#39;ore&#39;, 1, 4)</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    (&#39;more&#39;, 0, 4)</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    Set *reverse* to ``True`` to yield the same items in the opposite order.</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  843</span>    r = range(1, len(seq) + 1)</div>
<div class="line"><span class="lineno">  844</span>    <span class="keywordflow">if</span> reverse:</div>
<div class="line"><span class="lineno">  845</span>        r = reversed(r)</div>
<div class="line"><span class="lineno">  846</span>    <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">  847</span>        (seq[i : i + L], i, i + L) <span class="keywordflow">for</span> L <span class="keywordflow">in</span> r <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(seq) - L + 1)</div>
<div class="line"><span class="lineno">  848</span>    )</div>
<div class="line"><span class="lineno">  849</span> </div>
<div class="line"><span class="lineno">  850</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5bc505640cbe98f92a1703e472e1d00" name="ad5bc505640cbe98f92a1703e472e1d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bc505640cbe98f92a1703e472e1d00">&#9670;&#160;</a></span>unique_to_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.unique_to_each </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the elements from each of the input iterables that aren't in the
other input iterables.

For example, suppose you have a set of packages, each with a set of
dependencies::

    {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}

If you remove one package, which dependencies can also be removed?

If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not
associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for
``pkg_2``, and ``D`` is only needed for ``pkg_3``::

    &gt;&gt;&gt; unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})
    [['A'], ['C'], ['D']]

If there are duplicates in one input iterable that aren't in the others
they will be duplicated in the output. Input order is preserved::

    &gt;&gt;&gt; unique_to_each("mississippi", "missouri")
    [['p', 'p'], ['o', 'u', 'r']]

It is assumed that the elements of each iterable are hashable.</pre> <div class="fragment"><div class="line"><span class="lineno">  707</span><span class="keyword">def </span>unique_to_each(*iterables):</div>
<div class="line"><span class="lineno">  708</span>    <span class="stringliteral">&quot;&quot;&quot;Return the elements from each of the input iterables that aren&#39;t in the</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    other input iterables.</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    For example, suppose you have a set of packages, each with a set of</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    dependencies::</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        {&#39;pkg_1&#39;: {&#39;A&#39;, &#39;B&#39;}, &#39;pkg_2&#39;: {&#39;B&#39;, &#39;C&#39;}, &#39;pkg_3&#39;: {&#39;B&#39;, &#39;D&#39;}}</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    If you remove one package, which dependencies can also be removed?</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">        &gt;&gt;&gt; unique_to_each({&#39;A&#39;, &#39;B&#39;}, {&#39;B&#39;, &#39;C&#39;}, {&#39;B&#39;, &#39;D&#39;})</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">        [[&#39;A&#39;], [&#39;C&#39;], [&#39;D&#39;]]</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    If there are duplicates in one input iterable that aren&#39;t in the others</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    they will be duplicated in the output. Input order is preserved::</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        &gt;&gt;&gt; unique_to_each(&quot;mississippi&quot;, &quot;missouri&quot;)</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">        [[&#39;p&#39;, &#39;p&#39;], [&#39;o&#39;, &#39;u&#39;, &#39;r&#39;]]</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    It is assumed that the elements of each iterable are hashable.</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  734</span>    pool = [list(it) <span class="keywordflow">for</span> it <span class="keywordflow">in</span> iterables]</div>
<div class="line"><span class="lineno">  735</span>    counts = Counter(chain.from_iterable(map(set, pool)))</div>
<div class="line"><span class="lineno">  736</span>    uniques = {element <span class="keywordflow">for</span> element <span class="keywordflow">in</span> counts <span class="keywordflow">if</span> counts[element] == 1}</div>
<div class="line"><span class="lineno">  737</span>    <span class="keywordflow">return</span> [list(filter(uniques.__contains__, it)) <span class="keywordflow">for</span> it <span class="keywordflow">in</span> pool]</div>
<div class="line"><span class="lineno">  738</span> </div>
<div class="line"><span class="lineno">  739</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a32eebc9faf562f56d169cb5aec787b6d" name="a32eebc9faf562f56d169cb5aec787b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eebc9faf562f56d169cb5aec787b6d">&#9670;&#160;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.unzip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The inverse of :func:`zip`, this function disaggregates the elements
of the zipped *iterable*.

The ``i``-th iterable contains the ``i``-th element from each element
of the zipped iterable. The first element is used to to determine the
length of the remaining elements.

    &gt;&gt;&gt; iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
    &gt;&gt;&gt; letters, numbers = unzip(iterable)
    &gt;&gt;&gt; list(letters)
    ['a', 'b', 'c', 'd']
    &gt;&gt;&gt; list(numbers)
    [1, 2, 3, 4]

This is similar to using ``zip(*iterable)``, but it avoids reading
*iterable* into memory. Note, however, that this function uses
:func:`itertools.tee` and thus may require significant storage.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1652</span><span class="keyword">def </span>unzip(iterable):</div>
<div class="line"><span class="lineno"> 1653</span>    <span class="stringliteral">&quot;&quot;&quot;The inverse of :func:`zip`, this function disaggregates the elements</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral">    of the zipped *iterable*.</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">    The ``i``-th iterable contains the ``i``-th element from each element</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">    of the zipped iterable. The first element is used to to determine the</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">    length of the remaining elements.</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4)]</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">        &gt;&gt;&gt; letters, numbers = unzip(iterable)</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">        &gt;&gt;&gt; list(letters)</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">        &gt;&gt;&gt; list(numbers)</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">        [1, 2, 3, 4]</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">    This is similar to using ``zip(*iterable)``, but it avoids reading</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    *iterable* into memory. Note, however, that this function uses</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    :func:`itertools.tee` and thus may require significant storage.</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1672</span>    head, iterable = spy(<a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable))</div>
<div class="line"><span class="lineno"> 1673</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> head:</div>
<div class="line"><span class="lineno"> 1674</span>        <span class="comment"># empty iterable, e.g. zip([], [], [])</span></div>
<div class="line"><span class="lineno"> 1675</span>        <span class="keywordflow">return</span> ()</div>
<div class="line"><span class="lineno"> 1676</span>    <span class="comment"># spy returns a one-length iterable as head</span></div>
<div class="line"><span class="lineno"> 1677</span>    head = head[0]</div>
<div class="line"><span class="lineno"> 1678</span>    iterables = tee(iterable, len(head))</div>
<div class="line"><span class="lineno"> 1679</span> </div>
<div class="line"><span class="lineno"> 1680</span>    <span class="keyword">def </span>itemgetter(i):</div>
<div class="line"><span class="lineno"> 1681</span>        <span class="keyword">def </span>getter(obj):</div>
<div class="line"><span class="lineno"> 1682</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1683</span>                <span class="keywordflow">return</span> obj[i]</div>
<div class="line"><span class="lineno"> 1684</span>            <span class="keywordflow">except</span> IndexError:</div>
<div class="line"><span class="lineno"> 1685</span>                <span class="comment"># basically if we have an iterable like</span></div>
<div class="line"><span class="lineno"> 1686</span>                <span class="comment"># iter([(1, 2, 3), (4, 5), (6,)])</span></div>
<div class="line"><span class="lineno"> 1687</span>                <span class="comment"># the second unzipped iterable would fail at the third tuple</span></div>
<div class="line"><span class="lineno"> 1688</span>                <span class="comment"># since it would try to access tup[1]</span></div>
<div class="line"><span class="lineno"> 1689</span>                <span class="comment"># same with the third unzipped iterable and the second tuple</span></div>
<div class="line"><span class="lineno"> 1690</span>                <span class="comment"># to support these &quot;improperly zipped&quot; iterables,</span></div>
<div class="line"><span class="lineno"> 1691</span>                <span class="comment"># we create a custom itemgetter</span></div>
<div class="line"><span class="lineno"> 1692</span>                <span class="comment"># which just stops the unzipped iterables</span></div>
<div class="line"><span class="lineno"> 1693</span>                <span class="comment"># at first length mismatch</span></div>
<div class="line"><span class="lineno"> 1694</span>                <span class="keywordflow">raise</span> StopIteration</div>
<div class="line"><span class="lineno"> 1695</span> </div>
<div class="line"><span class="lineno"> 1696</span>        <span class="keywordflow">return</span> getter</div>
<div class="line"><span class="lineno"> 1697</span> </div>
<div class="line"><span class="lineno"> 1698</span>    <span class="keywordflow">return</span> tuple(map(itemgetter(i), it) <span class="keywordflow">for</span> i, it <span class="keywordflow">in</span> enumerate(iterables))</div>
<div class="line"><span class="lineno"> 1699</span> </div>
<div class="line"><span class="lineno"> 1700</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b402e9e076f6d6c1d7d13dccb5d992c" name="a0b402e9e076f6d6c1d7d13dccb5d992c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b402e9e076f6d6c1d7d13dccb5d992c">&#9670;&#160;</a></span>value_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.value_chain </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all arguments passed to the function in the same order in which
they were passed. If an argument itself is iterable then iterate over its
values.

    &gt;&gt;&gt; list(value_chain(1, 2, 3, [4, 5, 6]))
    [1, 2, 3, 4, 5, 6]

Binary and text strings are not considered iterable and are emitted
as-is:

    &gt;&gt;&gt; list(value_chain('12', '34', ['56', '78']))
    ['12', '34', '56', '78']


Multiple levels of nesting are not flattened.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3676</span><span class="keyword">def </span>value_chain(*args):</div>
<div class="line"><span class="lineno"> 3677</span>    <span class="stringliteral">&quot;&quot;&quot;Yield all arguments passed to the function in the same order in which</span></div>
<div class="line"><span class="lineno"> 3678</span><span class="stringliteral">    they were passed. If an argument itself is iterable then iterate over its</span></div>
<div class="line"><span class="lineno"> 3679</span><span class="stringliteral">    values.</span></div>
<div class="line"><span class="lineno"> 3680</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3681</span><span class="stringliteral">        &gt;&gt;&gt; list(value_chain(1, 2, 3, [4, 5, 6]))</span></div>
<div class="line"><span class="lineno"> 3682</span><span class="stringliteral">        [1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="lineno"> 3683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3684</span><span class="stringliteral">    Binary and text strings are not considered iterable and are emitted</span></div>
<div class="line"><span class="lineno"> 3685</span><span class="stringliteral">    as-is:</span></div>
<div class="line"><span class="lineno"> 3686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3687</span><span class="stringliteral">        &gt;&gt;&gt; list(value_chain(&#39;12&#39;, &#39;34&#39;, [&#39;56&#39;, &#39;78&#39;]))</span></div>
<div class="line"><span class="lineno"> 3688</span><span class="stringliteral">        [&#39;12&#39;, &#39;34&#39;, &#39;56&#39;, &#39;78&#39;]</span></div>
<div class="line"><span class="lineno"> 3689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3690</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3691</span><span class="stringliteral">    Multiple levels of nesting are not flattened.</span></div>
<div class="line"><span class="lineno"> 3692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3693</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3694</span>    <span class="keywordflow">for</span> value <span class="keywordflow">in</span> args:</div>
<div class="line"><span class="lineno"> 3695</span>        <span class="keywordflow">if</span> isinstance(value, (str, bytes)):</div>
<div class="line"><span class="lineno"> 3696</span>            <span class="keywordflow">yield</span> value</div>
<div class="line"><span class="lineno"> 3697</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 3698</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3699</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> value</div>
<div class="line"><span class="lineno"> 3700</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 3701</span>            <span class="keywordflow">yield</span> value</div>
<div class="line"><span class="lineno"> 3702</span> </div>
<div class="line"><span class="lineno"> 3703</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a25a63106c08986d199ddbd78d46277" name="a6a25a63106c08986d199ddbd78d46277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a25a63106c08986d199ddbd78d46277">&#9670;&#160;</a></span>windowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.windowed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sliding window of width *n* over the given iterable.

    &gt;&gt;&gt; all_windows = windowed([1, 2, 3, 4, 5], 3)
    &gt;&gt;&gt; list(all_windows)
    [(1, 2, 3), (2, 3, 4), (3, 4, 5)]

When the window is larger than the iterable, *fillvalue* is used in place
of missing values:

    &gt;&gt;&gt; list(windowed([1, 2, 3], 4))
    [(1, 2, 3, None)]

Each window will advance in increments of *step*:

    &gt;&gt;&gt; list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))
    [(1, 2, 3), (3, 4, 5), (5, 6, '!')]

To slide into the iterable's items, use :func:`chain` to add filler items
to the left:

    &gt;&gt;&gt; iterable = [1, 2, 3, 4]
    &gt;&gt;&gt; n = 3
    &gt;&gt;&gt; padding = [None] * (n - 1)
    &gt;&gt;&gt; list(windowed(chain(padding, iterable), 3))
    [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]
</pre> <div class="fragment"><div class="line"><span class="lineno">  740</span><span class="keyword">def </span>windowed(seq, n, fillvalue=None, step=1):</div>
<div class="line"><span class="lineno">  741</span>    <span class="stringliteral">&quot;&quot;&quot;Return a sliding window of width *n* over the given iterable.</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        &gt;&gt;&gt; all_windows = windowed([1, 2, 3, 4, 5], 3)</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        &gt;&gt;&gt; list(all_windows)</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    When the window is larger than the iterable, *fillvalue* is used in place</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    of missing values:</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        &gt;&gt;&gt; list(windowed([1, 2, 3], 4))</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        [(1, 2, 3, None)]</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    Each window will advance in increments of *step*:</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        &gt;&gt;&gt; list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue=&#39;!&#39;, step=2))</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        [(1, 2, 3), (3, 4, 5), (5, 6, &#39;!&#39;)]</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    To slide into the iterable&#39;s items, use :func:`chain` to add filler items</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    to the left:</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        &gt;&gt;&gt; iterable = [1, 2, 3, 4]</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        &gt;&gt;&gt; n = 3</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        &gt;&gt;&gt; padding = [None] * (n - 1)</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        &gt;&gt;&gt; list(windowed(chain(padding, iterable), 3))</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  767</span>    <span class="keywordflow">if</span> n &lt; 0:</div>
<div class="line"><span class="lineno">  768</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n must be &gt;= 0&#39;</span>)</div>
<div class="line"><span class="lineno">  769</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno">  770</span>        <span class="keywordflow">yield</span> tuple()</div>
<div class="line"><span class="lineno">  771</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  772</span>    <span class="keywordflow">if</span> step &lt; 1:</div>
<div class="line"><span class="lineno">  773</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;step must be &gt;= 1&#39;</span>)</div>
<div class="line"><span class="lineno">  774</span> </div>
<div class="line"><span class="lineno">  775</span>    window = deque(maxlen=n)</div>
<div class="line"><span class="lineno">  776</span>    i = n</div>
<div class="line"><span class="lineno">  777</span>    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> map(window.append, seq):</div>
<div class="line"><span class="lineno">  778</span>        i -= 1</div>
<div class="line"><span class="lineno">  779</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> i:</div>
<div class="line"><span class="lineno">  780</span>            i = step</div>
<div class="line"><span class="lineno">  781</span>            <span class="keywordflow">yield</span> tuple(window)</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>    size = len(window)</div>
<div class="line"><span class="lineno">  784</span>    <span class="keywordflow">if</span> size &lt; n:</div>
<div class="line"><span class="lineno">  785</span>        <span class="keywordflow">yield</span> tuple(chain(window, repeat(fillvalue, n - size)))</div>
<div class="line"><span class="lineno">  786</span>    <span class="keywordflow">elif</span> 0 &lt; i &lt; min(step, n):</div>
<div class="line"><span class="lineno">  787</span>        window += (fillvalue,) * i</div>
<div class="line"><span class="lineno">  788</span>        <span class="keywordflow">yield</span> tuple(window)</div>
<div class="line"><span class="lineno">  789</span> </div>
<div class="line"><span class="lineno">  790</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02c0440945239e801c6cb8025ab068c9" name="a02c0440945239e801c6cb8025ab068c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c0440945239e801c6cb8025ab068c9">&#9670;&#160;</a></span>windowed_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.windowed_complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield ``(beginning, middle, end)`` tuples, where:

* Each ``middle`` has *n* items from *iterable*
* Each ``beginning`` has the items before the ones in ``middle``
* Each ``end`` has the items after the ones in ``middle``

&gt;&gt;&gt; iterable = range(7)
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; for beginning, middle, end in windowed_complete(iterable, n):
...     print(beginning, middle, end)
() (0, 1, 2) (3, 4, 5, 6)
(0,) (1, 2, 3) (4, 5, 6)
(0, 1) (2, 3, 4) (5, 6)
(0, 1, 2) (3, 4, 5) (6,)
(0, 1, 2, 3) (4, 5, 6) ()

Note that *n* must be at least 0 and most equal to the length of
*iterable*.

This function will exhaust the iterable and may require significant
storage.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3524</span><span class="keyword">def </span>windowed_complete(iterable, n):</div>
<div class="line"><span class="lineno"> 3525</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3526</span><span class="stringliteral">    Yield ``(beginning, middle, end)`` tuples, where:</span></div>
<div class="line"><span class="lineno"> 3527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3528</span><span class="stringliteral">    * Each ``middle`` has *n* items from *iterable*</span></div>
<div class="line"><span class="lineno"> 3529</span><span class="stringliteral">    * Each ``beginning`` has the items before the ones in ``middle``</span></div>
<div class="line"><span class="lineno"> 3530</span><span class="stringliteral">    * Each ``end`` has the items after the ones in ``middle``</span></div>
<div class="line"><span class="lineno"> 3531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3532</span><span class="stringliteral">    &gt;&gt;&gt; iterable = range(7)</span></div>
<div class="line"><span class="lineno"> 3533</span><span class="stringliteral">    &gt;&gt;&gt; n = 3</span></div>
<div class="line"><span class="lineno"> 3534</span><span class="stringliteral">    &gt;&gt;&gt; for beginning, middle, end in windowed_complete(iterable, n):</span></div>
<div class="line"><span class="lineno"> 3535</span><span class="stringliteral">    ...     print(beginning, middle, end)</span></div>
<div class="line"><span class="lineno"> 3536</span><span class="stringliteral">    () (0, 1, 2) (3, 4, 5, 6)</span></div>
<div class="line"><span class="lineno"> 3537</span><span class="stringliteral">    (0,) (1, 2, 3) (4, 5, 6)</span></div>
<div class="line"><span class="lineno"> 3538</span><span class="stringliteral">    (0, 1) (2, 3, 4) (5, 6)</span></div>
<div class="line"><span class="lineno"> 3539</span><span class="stringliteral">    (0, 1, 2) (3, 4, 5) (6,)</span></div>
<div class="line"><span class="lineno"> 3540</span><span class="stringliteral">    (0, 1, 2, 3) (4, 5, 6) ()</span></div>
<div class="line"><span class="lineno"> 3541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3542</span><span class="stringliteral">    Note that *n* must be at least 0 and most equal to the length of</span></div>
<div class="line"><span class="lineno"> 3543</span><span class="stringliteral">    *iterable*.</span></div>
<div class="line"><span class="lineno"> 3544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3545</span><span class="stringliteral">    This function will exhaust the iterable and may require significant</span></div>
<div class="line"><span class="lineno"> 3546</span><span class="stringliteral">    storage.</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3548</span>    <span class="keywordflow">if</span> n &lt; 0:</div>
<div class="line"><span class="lineno"> 3549</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n must be &gt;= 0&#39;</span>)</div>
<div class="line"><span class="lineno"> 3550</span> </div>
<div class="line"><span class="lineno"> 3551</span>    seq = tuple(iterable)</div>
<div class="line"><span class="lineno"> 3552</span>    size = len(seq)</div>
<div class="line"><span class="lineno"> 3553</span> </div>
<div class="line"><span class="lineno"> 3554</span>    <span class="keywordflow">if</span> n &gt; size:</div>
<div class="line"><span class="lineno"> 3555</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n must be &lt;= len(seq)&#39;</span>)</div>
<div class="line"><span class="lineno"> 3556</span> </div>
<div class="line"><span class="lineno"> 3557</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(size - n + 1):</div>
<div class="line"><span class="lineno"> 3558</span>        beginning = seq[:i]</div>
<div class="line"><span class="lineno"> 3559</span>        middle = seq[i : i + n]</div>
<div class="line"><span class="lineno"> 3560</span>        end = seq[i + n :]</div>
<div class="line"><span class="lineno"> 3561</span>        <span class="keywordflow">yield</span> beginning, middle, end</div>
<div class="line"><span class="lineno"> 3562</span> </div>
<div class="line"><span class="lineno"> 3563</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a619447baa790cfa94d6bfc301c96a573" name="a619447baa790cfa94d6bfc301c96a573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619447baa790cfa94d6bfc301c96a573">&#9670;&#160;</a></span>with_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.with_iter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context_manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrap an iterable in a ``with`` statement, so it closes once exhausted.

For example, this will close the file when the iterator is exhausted::

    upper_lines = (line.upper() for line in with_iter(open('foo')))

Any context manager which returns an iterable is a candidate for
``with_iter``.</pre> <div class="fragment"><div class="line"><span class="lineno">  499</span><span class="keyword">def </span>with_iter(context_manager):</div>
<div class="line"><span class="lineno">  500</span>    <span class="stringliteral">&quot;&quot;&quot;Wrap an iterable in a ``with`` statement, so it closes once exhausted.</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    For example, this will close the file when the iterator is exhausted::</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        upper_lines = (line.upper() for line in with_iter(open(&#39;foo&#39;)))</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    Any context manager which returns an iterable is a candidate for</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    ``with_iter``.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  510</span>    <span class="keyword">with</span> context_manager <span class="keyword">as</span> iterable:</div>
<div class="line"><span class="lineno">  511</span>        <span class="keywordflow">yield</span> <span class="keyword">from</span> iterable</div>
<div class="line"><span class="lineno">  512</span> </div>
<div class="line"><span class="lineno">  513</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a310cdb228065a896661fdb3af5198990" name="a310cdb228065a896661fdb3af5198990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310cdb228065a896661fdb3af5198990">&#9670;&#160;</a></span>zip_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.zip_equal </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">``zip`` the input *iterables* together, but raise
``UnequalIterablesError`` if they aren't all the same length.

    &gt;&gt;&gt; it_1 = range(3)
    &gt;&gt;&gt; it_2 = iter('abc')
    &gt;&gt;&gt; list(zip_equal(it_1, it_2))
    [(0, 'a'), (1, 'b'), (2, 'c')]

    &gt;&gt;&gt; it_1 = range(3)
    &gt;&gt;&gt; it_2 = iter('abcd')
    &gt;&gt;&gt; list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    more_itertools.more.UnequalIterablesError: Iterables have different
    lengths</pre> <div class="fragment"><div class="line"><span class="lineno"> 1501</span><span class="keyword">def </span>zip_equal(*iterables):</div>
<div class="line"><span class="lineno"> 1502</span>    <span class="stringliteral">&quot;&quot;&quot;``zip`` the input *iterables* together, but raise</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    ``UnequalIterablesError`` if they aren&#39;t all the same length.</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">        &gt;&gt;&gt; it_1 = range(3)</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">        &gt;&gt;&gt; it_2 = iter(&#39;abc&#39;)</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">        &gt;&gt;&gt; list(zip_equal(it_1, it_2))</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">        [(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;)]</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        &gt;&gt;&gt; it_1 = range(3)</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">        &gt;&gt;&gt; it_2 = iter(&#39;abcd&#39;)</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        &gt;&gt;&gt; list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">        Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">        more_itertools.more.UnequalIterablesError: Iterables have different</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        lengths</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1519</span>    <span class="keywordflow">if</span> hexversion &gt;= 0x30A00A6:</div>
<div class="line"><span class="lineno"> 1520</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1521</span>            (</div>
<div class="line"><span class="lineno"> 1522</span>                <span class="stringliteral">&#39;zip_equal will be removed in a future version of &#39;</span></div>
<div class="line"><span class="lineno"> 1523</span>                <span class="stringliteral">&#39;more-itertools. Use the builtin zip function with &#39;</span></div>
<div class="line"><span class="lineno"> 1524</span>                <span class="stringliteral">&#39;strict=True instead.&#39;</span></div>
<div class="line"><span class="lineno"> 1525</span>            ),</div>
<div class="line"><span class="lineno"> 1526</span>            DeprecationWarning,</div>
<div class="line"><span class="lineno"> 1527</span>        )</div>
<div class="line"><span class="lineno"> 1528</span>    <span class="comment"># Check whether the iterables are all the same size.</span></div>
<div class="line"><span class="lineno"> 1529</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1530</span>        first_size = len(iterables[0])</div>
<div class="line"><span class="lineno"> 1531</span>        <span class="keywordflow">for</span> i, it <span class="keywordflow">in</span> enumerate(iterables[1:], 1):</div>
<div class="line"><span class="lineno"> 1532</span>            size = len(it)</div>
<div class="line"><span class="lineno"> 1533</span>            <span class="keywordflow">if</span> size != first_size:</div>
<div class="line"><span class="lineno"> 1534</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1535</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1536</span>            <span class="comment"># If we didn&#39;t break out, we can use the built-in zip.</span></div>
<div class="line"><span class="lineno"> 1537</span>            <span class="keywordflow">return</span> zip(*iterables)</div>
<div class="line"><span class="lineno"> 1538</span> </div>
<div class="line"><span class="lineno"> 1539</span>        <span class="comment"># If we did break out, there was a mismatch.</span></div>
<div class="line"><span class="lineno"> 1540</span>        <span class="keywordflow">raise</span> UnequalIterablesError(details=(first_size, i, size))</div>
<div class="line"><span class="lineno"> 1541</span>    <span class="comment"># If any one of the iterables didn&#39;t have a length, start reading</span></div>
<div class="line"><span class="lineno"> 1542</span>    <span class="comment"># them until one runs out.</span></div>
<div class="line"><span class="lineno"> 1543</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1544</span>        <span class="keywordflow">return</span> _zip_equal_generator(iterables)</div>
<div class="line"><span class="lineno"> 1545</span> </div>
<div class="line"><span class="lineno"> 1546</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b2e4bfc8d9d82c7daaa81730f316ae4" name="a5b2e4bfc8d9d82c7daaa81730f316ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2e4bfc8d9d82c7daaa81730f316ae4">&#9670;&#160;</a></span>zip_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more.zip_offset </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>longest</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">``zip`` the input *iterables* together, but offset the `i`-th iterable
by the `i`-th item in *offsets*.

    &gt;&gt;&gt; list(zip_offset('0123', 'abcdef', offsets=(0, 1)))
    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]

This can be used as a lightweight alternative to SciPy or pandas to analyze
data sets in which some series have a lead or lag relationship.

By default, the sequence will end when the shortest iterable is exhausted.
To continue until the longest iterable is exhausted, set *longest* to
``True``.

    &gt;&gt;&gt; list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))
    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]

By default, ``None`` will be used to replace offsets beyond the end of the
sequence. Specify *fillvalue* to use some other value.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1547</span><span class="keyword">def </span>zip_offset(*iterables, offsets, longest=False, fillvalue=None):</div>
<div class="line"><span class="lineno"> 1548</span>    <span class="stringliteral">&quot;&quot;&quot;``zip`` the input *iterables* together, but offset the `i`-th iterable</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    by the `i`-th item in *offsets*.</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">        &gt;&gt;&gt; list(zip_offset(&#39;0123&#39;, &#39;abcdef&#39;, offsets=(0, 1)))</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">        [(&#39;0&#39;, &#39;b&#39;), (&#39;1&#39;, &#39;c&#39;), (&#39;2&#39;, &#39;d&#39;), (&#39;3&#39;, &#39;e&#39;)]</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    This can be used as a lightweight alternative to SciPy or pandas to analyze</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    data sets in which some series have a lead or lag relationship.</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    By default, the sequence will end when the shortest iterable is exhausted.</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    To continue until the longest iterable is exhausted, set *longest* to</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    ``True``.</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">        &gt;&gt;&gt; list(zip_offset(&#39;0123&#39;, &#39;abcdef&#39;, offsets=(0, 1), longest=True))</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">        [(&#39;0&#39;, &#39;b&#39;), (&#39;1&#39;, &#39;c&#39;), (&#39;2&#39;, &#39;d&#39;), (&#39;3&#39;, &#39;e&#39;), (None, &#39;f&#39;)]</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">    By default, ``None`` will be used to replace offsets beyond the end of the</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">    sequence. Specify *fillvalue* to use some other value.</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1568</span>    <span class="keywordflow">if</span> len(iterables) != len(offsets):</div>
<div class="line"><span class="lineno"> 1569</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Number of iterables and offsets didn&#39;t match&quot;</span>)</div>
<div class="line"><span class="lineno"> 1570</span> </div>
<div class="line"><span class="lineno"> 1571</span>    staggered = []</div>
<div class="line"><span class="lineno"> 1572</span>    <span class="keywordflow">for</span> it, n <span class="keywordflow">in</span> zip(iterables, offsets):</div>
<div class="line"><span class="lineno"> 1573</span>        <span class="keywordflow">if</span> n &lt; 0:</div>
<div class="line"><span class="lineno"> 1574</span>            staggered.append(chain(repeat(fillvalue, -n), it))</div>
<div class="line"><span class="lineno"> 1575</span>        <span class="keywordflow">elif</span> n &gt; 0:</div>
<div class="line"><span class="lineno"> 1576</span>            staggered.append(islice(it, n, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno"> 1577</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1578</span>            staggered.append(it)</div>
<div class="line"><span class="lineno"> 1579</span> </div>
<div class="line"><span class="lineno"> 1580</span>    <span class="keywordflow">if</span> longest:</div>
<div class="line"><span class="lineno"> 1581</span>        <span class="keywordflow">return</span> zip_longest(*staggered, fillvalue=fillvalue)</div>
<div class="line"><span class="lineno"> 1582</span> </div>
<div class="line"><span class="lineno"> 1583</span>    <span class="keywordflow">return</span> zip(*staggered)</div>
<div class="line"><span class="lineno"> 1584</span> </div>
<div class="line"><span class="lineno"> 1585</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a67c5ce81dc3269a7393daed34ec304f1" name="a67c5ce81dc3269a7393daed34ec304f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c5ce81dc3269a7393daed34ec304f1">&#9670;&#160;</a></span>_marker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">setuptools._vendor.more_itertools.more._marker = object()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
