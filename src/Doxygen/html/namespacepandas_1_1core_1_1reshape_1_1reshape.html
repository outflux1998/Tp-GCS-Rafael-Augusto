<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.reshape.reshape Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1reshape.html">reshape</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html">reshape</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.reshape.reshape Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1reshape_1_1reshape_1_1___unstacker.html">_Unstacker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2a35096c44e8706bad5f5cdcef26b4c7" id="r_a2a35096c44e8706bad5f5cdcef26b4c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#a2a35096c44e8706bad5f5cdcef26b4c7">_unstack_multiple</a> (data, clocs, fill_value=None)</td></tr>
<tr class="separator:a2a35096c44e8706bad5f5cdcef26b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b9af2adc2404f174fc1f0483114da7" id="r_ac0b9af2adc2404f174fc1f0483114da7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#ac0b9af2adc2404f174fc1f0483114da7">unstack</a> (<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>|<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> obj, level, fill_value=None)</td></tr>
<tr class="separator:ac0b9af2adc2404f174fc1f0483114da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176b0ecc68a925b43dae8a3b70ad6027" id="r_a176b0ecc68a925b43dae8a3b70ad6027"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#a176b0ecc68a925b43dae8a3b70ad6027">_unstack_frame</a> (<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> obj, level, fill_value=None)</td></tr>
<tr class="separator:a176b0ecc68a925b43dae8a3b70ad6027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564799070cd74e4c7a4a8c3500b6b6ff" id="r_a564799070cd74e4c7a4a8c3500b6b6ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#a564799070cd74e4c7a4a8c3500b6b6ff">_unstack_extension_series</a> (<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> series, level, fill_value)</td></tr>
<tr class="separator:a564799070cd74e4c7a4a8c3500b6b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e2778d6fcbb8e7ef9df48ae6429e12" id="r_ad7e2778d6fcbb8e7ef9df48ae6429e12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#ad7e2778d6fcbb8e7ef9df48ae6429e12">stack</a> (<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> frame, level=-1, bool dropna=True)</td></tr>
<tr class="separator:ad7e2778d6fcbb8e7ef9df48ae6429e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf72a80d6474c8a804a2701ca4debdf" id="r_a8cf72a80d6474c8a804a2701ca4debdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#a8cf72a80d6474c8a804a2701ca4debdf">stack_multiple</a> (frame, level, dropna=True)</td></tr>
<tr class="separator:a8cf72a80d6474c8a804a2701ca4debdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739ff3037e914b5aabcaf82f0c1c5057" id="r_a739ff3037e914b5aabcaf82f0c1c5057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html">MultiIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#a739ff3037e914b5aabcaf82f0c1c5057">_stack_multi_column_index</a> (<a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html">MultiIndex</a> columns)</td></tr>
<tr class="separator:a739ff3037e914b5aabcaf82f0c1c5057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436d70680f4a1e357b4ab4b432caf40a" id="r_a436d70680f4a1e357b4ab4b432caf40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#a436d70680f4a1e357b4ab4b432caf40a">_stack_multi_columns</a> (<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> frame, int level_num=-1, bool dropna=True)</td></tr>
<tr class="separator:a436d70680f4a1e357b4ab4b432caf40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47efa768da0a75cbbfcc42c21ba1db28" id="r_a47efa768da0a75cbbfcc42c21ba1db28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1reshape.html#a47efa768da0a75cbbfcc42c21ba1db28">_reorder_for_extension_array_stack</a> (<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> arr, int n_rows, int n_columns)</td></tr>
<tr class="separator:a47efa768da0a75cbbfcc42c21ba1db28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a47efa768da0a75cbbfcc42c21ba1db28" name="a47efa768da0a75cbbfcc42c21ba1db28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47efa768da0a75cbbfcc42c21ba1db28">&#9670;&#160;</a></span>_reorder_for_extension_array_stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> pandas.core.reshape.reshape._reorder_for_extension_array_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
&#160;</td>
          <td class="paramname"><em>n_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Re-orders the values when stacking multiple extension-arrays.

The indirect stacking method used for EAs requires a followup
take to get the order correct.

Parameters
----------
arr : ExtensionArray
n_rows, n_columns : int
    The number of rows and columns in the original DataFrame.

Returns
-------
taken : ExtensionArray
    The original `arr` with elements re-ordered appropriately

Examples
--------
&gt;&gt;&gt; arr = np.array(['a', 'b', 'c', 'd', 'e', 'f'])
&gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 2, 3)
array(['a', 'c', 'e', 'b', 'd', 'f'], dtype='&lt;U1')

&gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 3, 2)
array(['a', 'd', 'b', 'e', 'c', 'f'], dtype='&lt;U1')
</pre> <div class="fragment"><div class="line"><span class="lineno">  818</span>) -&gt; ExtensionArray:</div>
<div class="line"><span class="lineno">  819</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    Re-orders the values when stacking multiple extension-arrays.</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    The indirect stacking method used for EAs requires a followup</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    take to get the order correct.</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    arr : ExtensionArray</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    n_rows, n_columns : int</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">        The number of rows and columns in the original DataFrame.</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    taken : ExtensionArray</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        The original `arr` with elements re-ordered appropriately</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    &gt;&gt;&gt; arr = np.array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;])</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    &gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 2, 3)</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    array([&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;b&#39;, &#39;d&#39;, &#39;f&#39;], dtype=&#39;&lt;U1&#39;)</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    &gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 3, 2)</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">    array([&#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;e&#39;, &#39;c&#39;, &#39;f&#39;], dtype=&#39;&lt;U1&#39;)</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  845</span>    <span class="comment"># final take to get the order correct.</span></div>
<div class="line"><span class="lineno">  846</span>    <span class="comment"># idx is an indexer like</span></div>
<div class="line"><span class="lineno">  847</span>    <span class="comment"># [c0r0, c1r0, c2r0, ...,</span></div>
<div class="line"><span class="lineno">  848</span>    <span class="comment">#  c0r1, c1r1, c2r1, ...]</span></div>
<div class="line"><span class="lineno">  849</span>    idx = np.arange(n_rows * n_columns).reshape(n_columns, n_rows).T.ravel()</div>
<div class="line"><span class="lineno">  850</span>    <span class="keywordflow">return</span> arr.take(idx)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a739ff3037e914b5aabcaf82f0c1c5057" name="a739ff3037e914b5aabcaf82f0c1c5057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739ff3037e914b5aabcaf82f0c1c5057">&#9670;&#160;</a></span>_stack_multi_column_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html">MultiIndex</a> pandas.core.reshape.reshape._stack_multi_column_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html">MultiIndex</a>&#160;</td>
          <td class="paramname"><em>columns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Creates a MultiIndex from the first N-1 levels of this MultiIndex.</pre> <div class="fragment"><div class="line"><span class="lineno">  658</span><span class="keyword">def </span>_stack_multi_column_index(columns: MultiIndex) -&gt; MultiIndex:</div>
<div class="line"><span class="lineno">  659</span>    <span class="stringliteral">&quot;&quot;&quot;Creates a MultiIndex from the first N-1 levels of this MultiIndex.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  660</span>    <span class="keywordflow">if</span> len(columns.levels) &lt;= 2:</div>
<div class="line"><span class="lineno">  661</span>        <span class="keywordflow">return</span> columns.levels[0]._rename(name=columns.names[0])</div>
<div class="line"><span class="lineno">  662</span> </div>
<div class="line"><span class="lineno">  663</span>    levs = [</div>
<div class="line"><span class="lineno">  664</span>        [lev[c] <span class="keywordflow">if</span> c &gt;= 0 <span class="keywordflow">else</span> <span class="keywordtype">None</span> <span class="keywordflow">for</span> c <span class="keywordflow">in</span> codes]</div>
<div class="line"><span class="lineno">  665</span>        <span class="keywordflow">for</span> lev, codes <span class="keywordflow">in</span> zip(columns.levels[:-1], columns.codes[:-1])</div>
<div class="line"><span class="lineno">  666</span>    ]</div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span>    <span class="comment"># Remove duplicate tuples in the MultiIndex.</span></div>
<div class="line"><span class="lineno">  669</span>    tuples = zip(*levs)</div>
<div class="line"><span class="lineno">  670</span>    unique_tuples = (key <span class="keywordflow">for</span> key, _ <span class="keywordflow">in</span> itertools.groupby(tuples))</div>
<div class="line"><span class="lineno">  671</span>    new_levs = zip(*unique_tuples)</div>
<div class="line"><span class="lineno">  672</span> </div>
<div class="line"><span class="lineno">  673</span>    <span class="comment"># The dtype of each level must be explicitly set to avoid inferring the wrong type.</span></div>
<div class="line"><span class="lineno">  674</span>    <span class="comment"># See GH-36991.</span></div>
<div class="line"><span class="lineno">  675</span>    <span class="keywordflow">return</span> MultiIndex.from_arrays(</div>
<div class="line"><span class="lineno">  676</span>        [</div>
<div class="line"><span class="lineno">  677</span>            <span class="comment"># Not all indices can accept None values.</span></div>
<div class="line"><span class="lineno">  678</span>            Index(new_lev, dtype=lev.dtype) <span class="keywordflow">if</span> <span class="keywordtype">None</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> new_lev <span class="keywordflow">else</span> new_lev</div>
<div class="line"><span class="lineno">  679</span>            <span class="keywordflow">for</span> new_lev, lev <span class="keywordflow">in</span> zip(new_levs, columns.levels)</div>
<div class="line"><span class="lineno">  680</span>        ],</div>
<div class="line"><span class="lineno">  681</span>        names=columns.names[:-1],</div>
<div class="line"><span class="lineno">  682</span>    )</div>
<div class="line"><span class="lineno">  683</span> </div>
<div class="line"><span class="lineno">  684</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a436d70680f4a1e357b4ab4b432caf40a" name="a436d70680f4a1e357b4ab4b432caf40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436d70680f4a1e357b4ab4b432caf40a">&#9670;&#160;</a></span>_stack_multi_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.core.reshape.reshape._stack_multi_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>level_num</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dropna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  687</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  688</span>    <span class="keyword">def </span>_convert_level_number(level_num: int, columns: Index):</div>
<div class="line"><span class="lineno">  689</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        Logic for converting the level number to something we can safely pass</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        to swaplevel.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        If `level_num` matches a column name return the name from</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        position `level_num`, otherwise return `level_num`.</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  696</span>        <span class="keywordflow">if</span> level_num <span class="keywordflow">in</span> columns.names:</div>
<div class="line"><span class="lineno">  697</span>            <span class="keywordflow">return</span> columns.names[level_num]</div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>        <span class="keywordflow">return</span> level_num</div>
<div class="line"><span class="lineno">  700</span> </div>
<div class="line"><span class="lineno">  701</span>    this = frame.copy(deep=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  702</span>    mi_cols = this.columns  <span class="comment"># cast(MultiIndex, this.columns)</span></div>
<div class="line"><span class="lineno">  703</span>    <span class="keyword">assert</span> isinstance(mi_cols, MultiIndex)  <span class="comment"># caller is responsible</span></div>
<div class="line"><span class="lineno">  704</span> </div>
<div class="line"><span class="lineno">  705</span>    <span class="comment"># this makes life much simpler</span></div>
<div class="line"><span class="lineno">  706</span>    <span class="keywordflow">if</span> level_num != mi_cols.nlevels - 1:</div>
<div class="line"><span class="lineno">  707</span>        <span class="comment"># roll levels to put selected level at end</span></div>
<div class="line"><span class="lineno">  708</span>        roll_columns = mi_cols</div>
<div class="line"><span class="lineno">  709</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(level_num, mi_cols.nlevels - 1):</div>
<div class="line"><span class="lineno">  710</span>            <span class="comment"># Need to check if the ints conflict with level names</span></div>
<div class="line"><span class="lineno">  711</span>            lev1 = _convert_level_number(i, roll_columns)</div>
<div class="line"><span class="lineno">  712</span>            lev2 = _convert_level_number(i + 1, roll_columns)</div>
<div class="line"><span class="lineno">  713</span>            roll_columns = roll_columns.swaplevel(lev1, lev2)</div>
<div class="line"><span class="lineno">  714</span>        this.columns = mi_cols = roll_columns</div>
<div class="line"><span class="lineno">  715</span> </div>
<div class="line"><span class="lineno">  716</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> mi_cols._is_lexsorted():</div>
<div class="line"><span class="lineno">  717</span>        <span class="comment"># Workaround the edge case where 0 is one of the column names,</span></div>
<div class="line"><span class="lineno">  718</span>        <span class="comment"># which interferes with trying to sort based on the first</span></div>
<div class="line"><span class="lineno">  719</span>        <span class="comment"># level</span></div>
<div class="line"><span class="lineno">  720</span>        level_to_sort = _convert_level_number(0, mi_cols)</div>
<div class="line"><span class="lineno">  721</span>        this = this.sort_index(level=level_to_sort, axis=1)</div>
<div class="line"><span class="lineno">  722</span>        mi_cols = this.columns</div>
<div class="line"><span class="lineno">  723</span> </div>
<div class="line"><span class="lineno">  724</span>    mi_cols = cast(MultiIndex, mi_cols)</div>
<div class="line"><span class="lineno">  725</span>    new_columns = _stack_multi_column_index(mi_cols)</div>
<div class="line"><span class="lineno">  726</span> </div>
<div class="line"><span class="lineno">  727</span>    <span class="comment"># time to ravel the values</span></div>
<div class="line"><span class="lineno">  728</span>    new_data = {}</div>
<div class="line"><span class="lineno">  729</span>    level_vals = mi_cols.levels[-1]</div>
<div class="line"><span class="lineno">  730</span>    level_codes = sorted(set(mi_cols.codes[-1]))</div>
<div class="line"><span class="lineno">  731</span>    level_vals_nan = level_vals.insert(len(level_vals), <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="line"><span class="lineno">  733</span>    level_vals_used = np.take(level_vals_nan, level_codes)</div>
<div class="line"><span class="lineno">  734</span>    levsize = len(level_codes)</div>
<div class="line"><span class="lineno">  735</span>    drop_cols = []</div>
<div class="line"><span class="lineno">  736</span>    <span class="keywordflow">for</span> key <span class="keywordflow">in</span> new_columns:</div>
<div class="line"><span class="lineno">  737</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  738</span>            loc = this.columns.get_loc(key)</div>
<div class="line"><span class="lineno">  739</span>        <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno">  740</span>            drop_cols.append(key)</div>
<div class="line"><span class="lineno">  741</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  742</span> </div>
<div class="line"><span class="lineno">  743</span>        <span class="comment"># can make more efficient?</span></div>
<div class="line"><span class="lineno">  744</span>        <span class="comment"># we almost always return a slice</span></div>
<div class="line"><span class="lineno">  745</span>        <span class="comment"># but if unsorted can get a boolean</span></div>
<div class="line"><span class="lineno">  746</span>        <span class="comment"># indexer</span></div>
<div class="line"><span class="lineno">  747</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(loc, slice):</div>
<div class="line"><span class="lineno">  748</span>            slice_len = len(loc)</div>
<div class="line"><span class="lineno">  749</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  750</span>            slice_len = loc.stop - loc.start</div>
<div class="line"><span class="lineno">  751</span> </div>
<div class="line"><span class="lineno">  752</span>        <span class="keywordflow">if</span> slice_len != levsize:</div>
<div class="line"><span class="lineno">  753</span>            chunk = this.loc[:, this.columns[loc]]</div>
<div class="line"><span class="lineno">  754</span>            chunk.columns = level_vals_nan.take(chunk.columns.codes[-1])</div>
<div class="line"><span class="lineno">  755</span>            value_slice = chunk.reindex(columns=level_vals_used).values</div>
<div class="line"><span class="lineno">  756</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  757</span>            <span class="keywordflow">if</span> frame._is_homogeneous_type <span class="keywordflow">and</span> is_extension_array_dtype(</div>
<div class="line"><span class="lineno">  758</span>                frame.dtypes.iloc[0]</div>
<div class="line"><span class="lineno">  759</span>            ):</div>
<div class="line"><span class="lineno">  760</span>                <span class="comment"># TODO(EA2D): won&#39;t need special case, can go through .values</span></div>
<div class="line"><span class="lineno">  761</span>                <span class="comment">#  paths below (might change to ._values)</span></div>
<div class="line"><span class="lineno">  762</span>                dtype = this[this.columns[loc]].dtypes.iloc[0]</div>
<div class="line"><span class="lineno">  763</span>                subset = this[this.columns[loc]]</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span>                value_slice = dtype.construct_array_type()._concat_same_type(</div>
<div class="line"><span class="lineno">  766</span>                    [x._values <span class="keywordflow">for</span> _, x <span class="keywordflow">in</span> subset.items()]</div>
<div class="line"><span class="lineno">  767</span>                )</div>
<div class="line"><span class="lineno">  768</span>                N, K = subset.shape</div>
<div class="line"><span class="lineno">  769</span>                idx = np.arange(N * K).reshape(K, N).T.ravel()</div>
<div class="line"><span class="lineno">  770</span>                value_slice = value_slice.take(idx)</div>
<div class="line"><span class="lineno">  771</span> </div>
<div class="line"><span class="lineno">  772</span>            <span class="keywordflow">elif</span> frame._is_mixed_type:</div>
<div class="line"><span class="lineno">  773</span>                value_slice = this[this.columns[loc]].values</div>
<div class="line"><span class="lineno">  774</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  775</span>                value_slice = this.values[:, loc]</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span>        <span class="keywordflow">if</span> value_slice.ndim &gt; 1:</div>
<div class="line"><span class="lineno">  778</span>            <span class="comment"># i.e. not extension</span></div>
<div class="line"><span class="lineno">  779</span>            value_slice = value_slice.ravel()</div>
<div class="line"><span class="lineno">  780</span> </div>
<div class="line"><span class="lineno">  781</span>        new_data[key] = value_slice</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>    <span class="keywordflow">if</span> len(drop_cols) &gt; 0:</div>
<div class="line"><span class="lineno">  784</span>        new_columns = new_columns.difference(drop_cols)</div>
<div class="line"><span class="lineno">  785</span> </div>
<div class="line"><span class="lineno">  786</span>    N = len(this)</div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    <span class="keywordflow">if</span> isinstance(this.index, MultiIndex):</div>
<div class="line"><span class="lineno">  789</span>        new_levels = list(this.index.levels)</div>
<div class="line"><span class="lineno">  790</span>        new_names = list(this.index.names)</div>
<div class="line"><span class="lineno">  791</span>        new_codes = [lab.repeat(levsize) <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> this.index.codes]</div>
<div class="line"><span class="lineno">  792</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  793</span>        old_codes, old_levels = factorize_from_iterable(this.index)</div>
<div class="line"><span class="lineno">  794</span>        new_levels = [old_levels]</div>
<div class="line"><span class="lineno">  795</span>        new_codes = [old_codes.repeat(levsize)]</div>
<div class="line"><span class="lineno">  796</span>        new_names = [this.index.name]  <span class="comment"># something better?</span></div>
<div class="line"><span class="lineno">  797</span> </div>
<div class="line"><span class="lineno">  798</span>    new_levels.append(level_vals)</div>
<div class="line"><span class="lineno">  799</span>    new_codes.append(np.tile(level_codes, N))</div>
<div class="line"><span class="lineno">  800</span>    new_names.append(frame.columns.names[level_num])</div>
<div class="line"><span class="lineno">  801</span> </div>
<div class="line"><span class="lineno">  802</span>    new_index = MultiIndex(</div>
<div class="line"><span class="lineno">  803</span>        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=<span class="keyword">False</span></div>
<div class="line"><span class="lineno">  804</span>    )</div>
<div class="line"><span class="lineno">  805</span> </div>
<div class="line"><span class="lineno">  806</span>    result = frame._constructor(new_data, index=new_index, columns=new_columns)</div>
<div class="line"><span class="lineno">  807</span> </div>
<div class="line"><span class="lineno">  808</span>    <span class="comment"># more efficient way to go about this? can do the whole masking biz but</span></div>
<div class="line"><span class="lineno">  809</span>    <span class="comment"># will only save a small amount of time...</span></div>
<div class="line"><span class="lineno">  810</span>    <span class="keywordflow">if</span> dropna:</div>
<div class="line"><span class="lineno">  811</span>        result = result.dropna(axis=0, how=<span class="stringliteral">&quot;all&quot;</span>)</div>
<div class="line"><span class="lineno">  812</span> </div>
<div class="line"><span class="lineno">  813</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  814</span> </div>
<div class="line"><span class="lineno">  815</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a564799070cd74e4c7a4a8c3500b6b6ff" name="a564799070cd74e4c7a4a8c3500b6b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564799070cd74e4c7a4a8c3500b6b6ff">&#9670;&#160;</a></span>_unstack_extension_series()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.core.reshape.reshape._unstack_extension_series </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>&#160;</td>
          <td class="paramname"><em>series</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Unstack an ExtensionArray-backed Series.

The ExtensionDtype is preserved.

Parameters
----------
series : Series
    A Series with an ExtensionArray for values
level : Any
    The level name or number.
fill_value : Any
    The user-level (not physical storage) fill value to use for
    missing values introduced by the reshape. Passed to
    ``series.values.take``.

Returns
-------
DataFrame
    Each column of the DataFrame will have the same dtype as
    the input Series.
</pre> <div class="fragment"><div class="line"><span class="lineno">  510</span><span class="keyword">def </span>_unstack_extension_series(series: Series, level, fill_value) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  511</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    Unstack an ExtensionArray-backed Series.</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    The ExtensionDtype is preserved.</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    series : Series</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        A Series with an ExtensionArray for values</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    level : Any</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        The level name or number.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    fill_value : Any</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        The user-level (not physical storage) fill value to use for</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        missing values introduced by the reshape. Passed to</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">        ``series.values.take``.</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    DataFrame</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        Each column of the DataFrame will have the same dtype as</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        the input Series.</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  533</span>    <span class="comment"># Defer to the logic in ExtensionBlock._unstack</span></div>
<div class="line"><span class="lineno">  534</span>    df = series.to_frame()</div>
<div class="line"><span class="lineno">  535</span>    result = df.unstack(level=level, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>    <span class="comment"># equiv: result.droplevel(level=0, axis=1)</span></div>
<div class="line"><span class="lineno">  538</span>    <span class="comment">#  but this avoids an extra copy</span></div>
<div class="line"><span class="lineno">  539</span>    result.columns = result.columns.droplevel(0)</div>
<div class="line"><span class="lineno">  540</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  541</span> </div>
<div class="line"><span class="lineno">  542</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a176b0ecc68a925b43dae8a3b70ad6027" name="a176b0ecc68a925b43dae8a3b70ad6027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176b0ecc68a925b43dae8a3b70ad6027">&#9670;&#160;</a></span>_unstack_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.reshape._unstack_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  497</span><span class="keyword">def </span>_unstack_frame(obj: DataFrame, level, fill_value=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  498</span>    <span class="keyword">assert</span> isinstance(obj.index, MultiIndex)  <span class="comment"># checked by caller</span></div>
<div class="line"><span class="lineno">  499</span>    unstacker = _Unstacker(obj.index, level=level, constructor=obj._constructor)</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> obj._can_fast_transpose:</div>
<div class="line"><span class="lineno">  502</span>        mgr = obj._mgr.unstack(unstacker, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  503</span>        <span class="keywordflow">return</span> obj._constructor(mgr)</div>
<div class="line"><span class="lineno">  504</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  505</span>        <span class="keywordflow">return</span> unstacker.get_result(</div>
<div class="line"><span class="lineno">  506</span>            obj._values, value_columns=obj.columns, fill_value=fill_value</div>
<div class="line"><span class="lineno">  507</span>        )</div>
<div class="line"><span class="lineno">  508</span> </div>
<div class="line"><span class="lineno">  509</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a35096c44e8706bad5f5cdcef26b4c7" name="a2a35096c44e8706bad5f5cdcef26b4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a35096c44e8706bad5f5cdcef26b4c7">&#9670;&#160;</a></span>_unstack_multiple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.reshape._unstack_multiple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  373</span><span class="keyword">def </span>_unstack_multiple(data, clocs, fill_value=None):</div>
<div class="line"><span class="lineno">  374</span>    <span class="keywordflow">if</span> len(clocs) == 0:</div>
<div class="line"><span class="lineno">  375</span>        <span class="keywordflow">return</span> data</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span>    <span class="comment"># NOTE: This doesn&#39;t deal with hierarchical columns yet</span></div>
<div class="line"><span class="lineno">  378</span> </div>
<div class="line"><span class="lineno">  379</span>    index = data.index</div>
<div class="line"><span class="lineno">  380</span> </div>
<div class="line"><span class="lineno">  381</span>    <span class="comment"># GH 19966 Make sure if MultiIndexed index has tuple name, they will be</span></div>
<div class="line"><span class="lineno">  382</span>    <span class="comment"># recognised as a whole</span></div>
<div class="line"><span class="lineno">  383</span>    <span class="keywordflow">if</span> clocs <span class="keywordflow">in</span> index.names:</div>
<div class="line"><span class="lineno">  384</span>        clocs = [clocs]</div>
<div class="line"><span class="lineno">  385</span>    clocs = [index._get_level_number(i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> clocs]</div>
<div class="line"><span class="lineno">  386</span> </div>
<div class="line"><span class="lineno">  387</span>    rlocs = [i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(index.nlevels) <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> clocs]</div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>    clevels = [index.levels[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> clocs]</div>
<div class="line"><span class="lineno">  390</span>    ccodes = [index.codes[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> clocs]</div>
<div class="line"><span class="lineno">  391</span>    cnames = [index.names[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> clocs]</div>
<div class="line"><span class="lineno">  392</span>    rlevels = [index.levels[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> rlocs]</div>
<div class="line"><span class="lineno">  393</span>    rcodes = [index.codes[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> rlocs]</div>
<div class="line"><span class="lineno">  394</span>    rnames = [index.names[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> rlocs]</div>
<div class="line"><span class="lineno">  395</span> </div>
<div class="line"><span class="lineno">  396</span>    shape = tuple(len(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> clevels)</div>
<div class="line"><span class="lineno">  397</span>    group_index = get_group_index(ccodes, shape, sort=<span class="keyword">False</span>, xnull=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  398</span> </div>
<div class="line"><span class="lineno">  399</span>    comp_ids, obs_ids = compress_group_index(group_index, sort=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  400</span>    recons_codes = decons_obs_group_ids(comp_ids, obs_ids, shape, ccodes, xnull=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  401</span> </div>
<div class="line"><span class="lineno">  402</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> rlocs:</div>
<div class="line"><span class="lineno">  403</span>        <span class="comment"># Everything is in clocs, so the dummy df has a regular index</span></div>
<div class="line"><span class="lineno">  404</span>        dummy_index = Index(obs_ids, name=<span class="stringliteral">&quot;__placeholder__&quot;</span>)</div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  406</span>        dummy_index = MultiIndex(</div>
<div class="line"><span class="lineno">  407</span>            levels=rlevels + [obs_ids],</div>
<div class="line"><span class="lineno">  408</span>            codes=rcodes + [comp_ids],</div>
<div class="line"><span class="lineno">  409</span>            names=rnames + [<span class="stringliteral">&quot;__placeholder__&quot;</span>],</div>
<div class="line"><span class="lineno">  410</span>            verify_integrity=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  411</span>        )</div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">if</span> isinstance(data, Series):</div>
<div class="line"><span class="lineno">  414</span>        dummy = data.copy()</div>
<div class="line"><span class="lineno">  415</span>        dummy.index = dummy_index</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>        unstacked = dummy.unstack(<span class="stringliteral">&quot;__placeholder__&quot;</span>, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  418</span>        new_levels = clevels</div>
<div class="line"><span class="lineno">  419</span>        new_names = cnames</div>
<div class="line"><span class="lineno">  420</span>        new_codes = recons_codes</div>
<div class="line"><span class="lineno">  421</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  422</span>        <span class="keywordflow">if</span> isinstance(data.columns, MultiIndex):</div>
<div class="line"><span class="lineno">  423</span>            result = data</div>
<div class="line"><span class="lineno">  424</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(clocs)):</div>
<div class="line"><span class="lineno">  425</span>                val = clocs[i]</div>
<div class="line"><span class="lineno">  426</span>                result = result.unstack(val, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  427</span>                clocs = [v <span class="keywordflow">if</span> v &lt; val <span class="keywordflow">else</span> v - 1 <span class="keywordflow">for</span> v <span class="keywordflow">in</span> clocs]</div>
<div class="line"><span class="lineno">  428</span> </div>
<div class="line"><span class="lineno">  429</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  430</span> </div>
<div class="line"><span class="lineno">  431</span>        <span class="comment"># GH#42579 deep=False to avoid consolidating</span></div>
<div class="line"><span class="lineno">  432</span>        dummy = data.copy(deep=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  433</span>        dummy.index = dummy_index</div>
<div class="line"><span class="lineno">  434</span> </div>
<div class="line"><span class="lineno">  435</span>        unstacked = dummy.unstack(<span class="stringliteral">&quot;__placeholder__&quot;</span>, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  436</span>        <span class="keywordflow">if</span> isinstance(unstacked, Series):</div>
<div class="line"><span class="lineno">  437</span>            unstcols = unstacked.index</div>
<div class="line"><span class="lineno">  438</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  439</span>            unstcols = unstacked.columns</div>
<div class="line"><span class="lineno">  440</span>        <span class="keyword">assert</span> isinstance(unstcols, MultiIndex)  <span class="comment"># for mypy</span></div>
<div class="line"><span class="lineno">  441</span>        new_levels = [unstcols.levels[0]] + clevels</div>
<div class="line"><span class="lineno">  442</span>        new_names = [data.columns.name] + cnames</div>
<div class="line"><span class="lineno">  443</span> </div>
<div class="line"><span class="lineno">  444</span>        new_codes = [unstcols.codes[0]]</div>
<div class="line"><span class="lineno">  445</span>        <span class="keywordflow">for</span> rec <span class="keywordflow">in</span> recons_codes:</div>
<div class="line"><span class="lineno">  446</span>            new_codes.append(rec.take(unstcols.codes[-1]))</div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span>    new_columns = MultiIndex(</div>
<div class="line"><span class="lineno">  449</span>        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=<span class="keyword">False</span></div>
<div class="line"><span class="lineno">  450</span>    )</div>
<div class="line"><span class="lineno">  451</span> </div>
<div class="line"><span class="lineno">  452</span>    <span class="keywordflow">if</span> isinstance(unstacked, Series):</div>
<div class="line"><span class="lineno">  453</span>        unstacked.index = new_columns</div>
<div class="line"><span class="lineno">  454</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  455</span>        unstacked.columns = new_columns</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    <span class="keywordflow">return</span> unstacked</div>
<div class="line"><span class="lineno">  458</span> </div>
<div class="line"><span class="lineno">  459</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7e2778d6fcbb8e7ef9df48ae6429e12" name="ad7e2778d6fcbb8e7ef9df48ae6429e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e2778d6fcbb8e7ef9df48ae6429e12">&#9670;&#160;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.reshape.stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dropna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert DataFrame to Series with multi-level Index. Columns become the
second level of the resulting hierarchical index

Returns
-------
stacked : Series or DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno">  543</span><span class="keyword">def </span>stack(frame: DataFrame, level=-1, dropna: bool = <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  544</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    Convert DataFrame to Series with multi-level Index. Columns become the</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    second level of the resulting hierarchical index</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    stacked : Series or DataFrame</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  552</span> </div>
<div class="line"><span class="lineno">  553</span>    <span class="keyword">def </span>factorize(index):</div>
<div class="line"><span class="lineno">  554</span>        <span class="keywordflow">if</span> index.is_unique:</div>
<div class="line"><span class="lineno">  555</span>            <span class="keywordflow">return</span> index, np.arange(len(index))</div>
<div class="line"><span class="lineno">  556</span>        codes, categories = factorize_from_iterable(index)</div>
<div class="line"><span class="lineno">  557</span>        <span class="keywordflow">return</span> categories, codes</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>    N, K = frame.shape</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>    <span class="comment"># Will also convert negative level numbers and check if out of bounds.</span></div>
<div class="line"><span class="lineno">  562</span>    level_num = frame.columns._get_level_number(level)</div>
<div class="line"><span class="lineno">  563</span> </div>
<div class="line"><span class="lineno">  564</span>    <span class="keywordflow">if</span> isinstance(frame.columns, MultiIndex):</div>
<div class="line"><span class="lineno">  565</span>        <span class="keywordflow">return</span> _stack_multi_columns(frame, level_num=level_num, dropna=dropna)</div>
<div class="line"><span class="lineno">  566</span>    <span class="keywordflow">elif</span> isinstance(frame.index, MultiIndex):</div>
<div class="line"><span class="lineno">  567</span>        new_levels = list(frame.index.levels)</div>
<div class="line"><span class="lineno">  568</span>        new_codes = [lab.repeat(K) <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> frame.index.codes]</div>
<div class="line"><span class="lineno">  569</span> </div>
<div class="line"><span class="lineno">  570</span>        clev, clab = factorize(frame.columns)</div>
<div class="line"><span class="lineno">  571</span>        new_levels.append(clev)</div>
<div class="line"><span class="lineno">  572</span>        new_codes.append(np.tile(clab, N).ravel())</div>
<div class="line"><span class="lineno">  573</span> </div>
<div class="line"><span class="lineno">  574</span>        new_names = list(frame.index.names)</div>
<div class="line"><span class="lineno">  575</span>        new_names.append(frame.columns.name)</div>
<div class="line"><span class="lineno">  576</span>        new_index = MultiIndex(</div>
<div class="line"><span class="lineno">  577</span>            levels=new_levels, codes=new_codes, names=new_names, verify_integrity=<span class="keyword">False</span></div>
<div class="line"><span class="lineno">  578</span>        )</div>
<div class="line"><span class="lineno">  579</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  580</span>        levels, (ilab, clab) = zip(*map(factorize, (frame.index, frame.columns)))</div>
<div class="line"><span class="lineno">  581</span>        codes = ilab.repeat(K), np.tile(clab, N).ravel()</div>
<div class="line"><span class="lineno">  582</span>        new_index = MultiIndex(</div>
<div class="line"><span class="lineno">  583</span>            levels=levels,</div>
<div class="line"><span class="lineno">  584</span>            codes=codes,</div>
<div class="line"><span class="lineno">  585</span>            names=[frame.index.name, frame.columns.name],</div>
<div class="line"><span class="lineno">  586</span>            verify_integrity=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  587</span>        )</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> frame.empty <span class="keywordflow">and</span> frame._is_homogeneous_type:</div>
<div class="line"><span class="lineno">  590</span>        <span class="comment"># For homogeneous EAs, frame._values will coerce to object. So</span></div>
<div class="line"><span class="lineno">  591</span>        <span class="comment"># we concatenate instead.</span></div>
<div class="line"><span class="lineno">  592</span>        dtypes = list(frame.dtypes._values)</div>
<div class="line"><span class="lineno">  593</span>        dtype = dtypes[0]</div>
<div class="line"><span class="lineno">  594</span> </div>
<div class="line"><span class="lineno">  595</span>        <span class="keywordflow">if</span> is_extension_array_dtype(dtype):</div>
<div class="line"><span class="lineno">  596</span>            arr = dtype.construct_array_type()</div>
<div class="line"><span class="lineno">  597</span>            new_values = arr._concat_same_type(</div>
<div class="line"><span class="lineno">  598</span>                [col._values <span class="keywordflow">for</span> _, col <span class="keywordflow">in</span> frame.items()]</div>
<div class="line"><span class="lineno">  599</span>            )</div>
<div class="line"><span class="lineno">  600</span>            new_values = _reorder_for_extension_array_stack(new_values, N, K)</div>
<div class="line"><span class="lineno">  601</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  602</span>            <span class="comment"># homogeneous, non-EA</span></div>
<div class="line"><span class="lineno">  603</span>            new_values = frame._values.ravel()</div>
<div class="line"><span class="lineno">  604</span> </div>
<div class="line"><span class="lineno">  605</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  606</span>        <span class="comment"># non-homogeneous</span></div>
<div class="line"><span class="lineno">  607</span>        new_values = frame._values.ravel()</div>
<div class="line"><span class="lineno">  608</span> </div>
<div class="line"><span class="lineno">  609</span>    <span class="keywordflow">if</span> dropna:</div>
<div class="line"><span class="lineno">  610</span>        mask = notna(new_values)</div>
<div class="line"><span class="lineno">  611</span>        new_values = new_values[mask]</div>
<div class="line"><span class="lineno">  612</span>        new_index = new_index[mask]</div>
<div class="line"><span class="lineno">  613</span> </div>
<div class="line"><span class="lineno">  614</span>    <span class="keywordflow">return</span> frame._constructor_sliced(new_values, index=new_index)</div>
<div class="line"><span class="lineno">  615</span> </div>
<div class="line"><span class="lineno">  616</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cf72a80d6474c8a804a2701ca4debdf" name="a8cf72a80d6474c8a804a2701ca4debdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf72a80d6474c8a804a2701ca4debdf">&#9670;&#160;</a></span>stack_multiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.reshape.stack_multiple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dropna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  617</span><span class="keyword">def </span>stack_multiple(frame, level, dropna=True):</div>
<div class="line"><span class="lineno">  618</span>    <span class="comment"># If all passed levels match up to column names, no</span></div>
<div class="line"><span class="lineno">  619</span>    <span class="comment"># ambiguity about what to do</span></div>
<div class="line"><span class="lineno">  620</span>    <span class="keywordflow">if</span> all(lev <span class="keywordflow">in</span> frame.columns.names <span class="keywordflow">for</span> lev <span class="keywordflow">in</span> level):</div>
<div class="line"><span class="lineno">  621</span>        result = frame</div>
<div class="line"><span class="lineno">  622</span>        <span class="keywordflow">for</span> lev <span class="keywordflow">in</span> level:</div>
<div class="line"><span class="lineno">  623</span>            result = stack(result, lev, dropna=dropna)</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span>    <span class="comment"># Otherwise, level numbers may change as each successive level is stacked</span></div>
<div class="line"><span class="lineno">  626</span>    <span class="keywordflow">elif</span> all(isinstance(lev, int) <span class="keywordflow">for</span> lev <span class="keywordflow">in</span> level):</div>
<div class="line"><span class="lineno">  627</span>        <span class="comment"># As each stack is done, the level numbers decrease, so we need</span></div>
<div class="line"><span class="lineno">  628</span>        <span class="comment">#  to account for that when level is a sequence of ints</span></div>
<div class="line"><span class="lineno">  629</span>        result = frame</div>
<div class="line"><span class="lineno">  630</span>        <span class="comment"># _get_level_number() checks level numbers are in range and converts</span></div>
<div class="line"><span class="lineno">  631</span>        <span class="comment"># negative numbers to positive</span></div>
<div class="line"><span class="lineno">  632</span>        level = [frame.columns._get_level_number(lev) <span class="keywordflow">for</span> lev <span class="keywordflow">in</span> level]</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span>        <span class="comment"># Can&#39;t iterate directly through level as we might need to change</span></div>
<div class="line"><span class="lineno">  635</span>        <span class="comment"># values as we go</span></div>
<div class="line"><span class="lineno">  636</span>        <span class="keywordflow">for</span> index <span class="keywordflow">in</span> range(len(level)):</div>
<div class="line"><span class="lineno">  637</span>            lev = level[index]</div>
<div class="line"><span class="lineno">  638</span>            result = stack(result, lev, dropna=dropna)</div>
<div class="line"><span class="lineno">  639</span>            <span class="comment"># Decrement all level numbers greater than current, as these</span></div>
<div class="line"><span class="lineno">  640</span>            <span class="comment"># have now shifted down by one</span></div>
<div class="line"><span class="lineno">  641</span>            updated_level = []</div>
<div class="line"><span class="lineno">  642</span>            <span class="keywordflow">for</span> other <span class="keywordflow">in</span> level:</div>
<div class="line"><span class="lineno">  643</span>                <span class="keywordflow">if</span> other &gt; lev:</div>
<div class="line"><span class="lineno">  644</span>                    updated_level.append(other - 1)</div>
<div class="line"><span class="lineno">  645</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  646</span>                    updated_level.append(other)</div>
<div class="line"><span class="lineno">  647</span>            level = updated_level</div>
<div class="line"><span class="lineno">  648</span> </div>
<div class="line"><span class="lineno">  649</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  650</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  651</span>            <span class="stringliteral">&quot;level should contain all level names or all level &quot;</span></div>
<div class="line"><span class="lineno">  652</span>            <span class="stringliteral">&quot;numbers, not a mixture of the two.&quot;</span></div>
<div class="line"><span class="lineno">  653</span>        )</div>
<div class="line"><span class="lineno">  654</span> </div>
<div class="line"><span class="lineno">  655</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  656</span> </div>
<div class="line"><span class="lineno">  657</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0b9af2adc2404f174fc1f0483114da7" name="ac0b9af2adc2404f174fc1f0483114da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b9af2adc2404f174fc1f0483114da7">&#9670;&#160;</a></span>unstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.reshape.unstack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> | <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  460</span><span class="keyword">def </span>unstack(obj: Series | DataFrame, level, fill_value=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span>    <span class="keywordflow">if</span> isinstance(level, (tuple, list)):</div>
<div class="line"><span class="lineno">  463</span>        <span class="keywordflow">if</span> len(level) != 1:</div>
<div class="line"><span class="lineno">  464</span>            <span class="comment"># _unstack_multiple only handles MultiIndexes,</span></div>
<div class="line"><span class="lineno">  465</span>            <span class="comment"># and isn&#39;t needed for a single level</span></div>
<div class="line"><span class="lineno">  466</span>            <span class="keywordflow">return</span> _unstack_multiple(obj, level, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  467</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  468</span>            level = level[0]</div>
<div class="line"><span class="lineno">  469</span> </div>
<div class="line"><span class="lineno">  470</span>    <span class="comment"># Prioritize integer interpretation (GH #21677):</span></div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_integer(level) <span class="keywordflow">and</span> <span class="keywordflow">not</span> level == <span class="stringliteral">&quot;__placeholder__&quot;</span>:</div>
<div class="line"><span class="lineno">  472</span>        level = obj.index._get_level_number(level)</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span>    <span class="keywordflow">if</span> isinstance(obj, DataFrame):</div>
<div class="line"><span class="lineno">  475</span>        <span class="keywordflow">if</span> isinstance(obj.index, MultiIndex):</div>
<div class="line"><span class="lineno">  476</span>            <span class="keywordflow">return</span> _unstack_frame(obj, level, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  477</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  478</span>            <span class="keywordflow">return</span> obj.T.stack(dropna=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  479</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(obj.index, MultiIndex):</div>
<div class="line"><span class="lineno">  480</span>        <span class="comment"># GH 36113</span></div>
<div class="line"><span class="lineno">  481</span>        <span class="comment"># Give nicer error messages when unstack a Series whose</span></div>
<div class="line"><span class="lineno">  482</span>        <span class="comment"># Index is not a MultiIndex.</span></div>
<div class="line"><span class="lineno">  483</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  484</span>            f<span class="stringliteral">&quot;index must be a MultiIndex to unstack, {type(obj.index)} was passed&quot;</span></div>
<div class="line"><span class="lineno">  485</span>        )</div>
<div class="line"><span class="lineno">  486</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  487</span>        <span class="keywordflow">if</span> is_1d_only_ea_dtype(obj.dtype):</div>
<div class="line"><span class="lineno">  488</span>            <span class="keywordflow">return</span> _unstack_extension_series(obj, level, fill_value)</div>
<div class="line"><span class="lineno">  489</span>        unstacker = _Unstacker(</div>
<div class="line"><span class="lineno">  490</span>            obj.index, level=level, constructor=obj._constructor_expanddim</div>
<div class="line"><span class="lineno">  491</span>        )</div>
<div class="line"><span class="lineno">  492</span>        <span class="keywordflow">return</span> unstacker.get_result(</div>
<div class="line"><span class="lineno">  493</span>            obj._values, value_columns=<span class="keywordtype">None</span>, fill_value=fill_value</div>
<div class="line"><span class="lineno">  494</span>        )</div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
