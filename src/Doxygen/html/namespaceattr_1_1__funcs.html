<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: attr._funcs Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceattr.html">attr</a></li><li class="navelem"><a class="el" href="namespaceattr_1_1__funcs.html">_funcs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">attr._funcs Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ea4558a56652f9f52210b5b304cdb69" id="r_a9ea4558a56652f9f52210b5b304cdb69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__funcs.html#a9ea4558a56652f9f52210b5b304cdb69">asdict</a> (inst, recurse=True, filter=None, dict_factory=dict, retain_collection_types=False, value_serializer=None)</td></tr>
<tr class="separator:a9ea4558a56652f9f52210b5b304cdb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae751cfcf1cd40edc983e226c2442b142" id="r_ae751cfcf1cd40edc983e226c2442b142"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__funcs.html#ae751cfcf1cd40edc983e226c2442b142">_asdict_anything</a> (val, is_key, filter, dict_factory, retain_collection_types, value_serializer)</td></tr>
<tr class="separator:ae751cfcf1cd40edc983e226c2442b142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56e821cedf493375f974ff06750158f" id="r_aa56e821cedf493375f974ff06750158f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__funcs.html#aa56e821cedf493375f974ff06750158f">astuple</a> (inst, recurse=True, filter=None, tuple_factory=tuple, retain_collection_types=False)</td></tr>
<tr class="separator:aa56e821cedf493375f974ff06750158f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb41daebc62d8bfd9197c816a81b1cce" id="r_acb41daebc62d8bfd9197c816a81b1cce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__funcs.html#acb41daebc62d8bfd9197c816a81b1cce">has</a> (cls)</td></tr>
<tr class="separator:acb41daebc62d8bfd9197c816a81b1cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af582f4beeebbbc97570a5768fa894483" id="r_af582f4beeebbbc97570a5768fa894483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__funcs.html#af582f4beeebbbc97570a5768fa894483">assoc</a> (inst, **changes)</td></tr>
<tr class="separator:af582f4beeebbbc97570a5768fa894483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae535ad200b0d8355062f462de63b352" id="r_aae535ad200b0d8355062f462de63b352"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__funcs.html#aae535ad200b0d8355062f462de63b352">evolve</a> (inst, **changes)</td></tr>
<tr class="separator:aae535ad200b0d8355062f462de63b352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55810b0d49f6a451deac0855db7af474" id="r_a55810b0d49f6a451deac0855db7af474"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceattr_1_1__funcs.html#a55810b0d49f6a451deac0855db7af474">resolve_types</a> (cls, globalns=None, localns=None, attribs=None)</td></tr>
<tr class="separator:a55810b0d49f6a451deac0855db7af474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae751cfcf1cd40edc983e226c2442b142" name="ae751cfcf1cd40edc983e226c2442b142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae751cfcf1cd40edc983e226c2442b142">&#9670;&#160;</a></span>_asdict_anything()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs._asdict_anything </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>is_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>retain_collection_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_serializer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">``asdict`` only works on attrs instances, this works on anything.
</pre> <div class="fragment"><div class="line"><span class="lineno">  124</span>):</div>
<div class="line"><span class="lineno">  125</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    ``asdict`` only works on attrs instances, this works on anything.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  128</span>    <span class="keywordflow">if</span> getattr(val.__class__, <span class="stringliteral">&quot;__attrs_attrs__&quot;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  129</span>        <span class="comment"># Attrs class.</span></div>
<div class="line"><span class="lineno">  130</span>        rv = asdict(</div>
<div class="line"><span class="lineno">  131</span>            val,</div>
<div class="line"><span class="lineno">  132</span>            recurse=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  133</span>            filter=filter,</div>
<div class="line"><span class="lineno">  134</span>            dict_factory=dict_factory,</div>
<div class="line"><span class="lineno">  135</span>            retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">  136</span>            value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">  137</span>        )</div>
<div class="line"><span class="lineno">  138</span>    <span class="keywordflow">elif</span> isinstance(val, (tuple, list, set, frozenset)):</div>
<div class="line"><span class="lineno">  139</span>        <span class="keywordflow">if</span> retain_collection_types <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  140</span>            cf = val.__class__</div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordflow">elif</span> is_key:</div>
<div class="line"><span class="lineno">  142</span>            cf = tuple</div>
<div class="line"><span class="lineno">  143</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  144</span>            cf = list</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>        rv = cf(</div>
<div class="line"><span class="lineno">  147</span>            [</div>
<div class="line"><span class="lineno">  148</span>                _asdict_anything(</div>
<div class="line"><span class="lineno">  149</span>                    i,</div>
<div class="line"><span class="lineno">  150</span>                    is_key=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  151</span>                    filter=filter,</div>
<div class="line"><span class="lineno">  152</span>                    dict_factory=dict_factory,</div>
<div class="line"><span class="lineno">  153</span>                    retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">  154</span>                    value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">  155</span>                )</div>
<div class="line"><span class="lineno">  156</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> val</div>
<div class="line"><span class="lineno">  157</span>            ]</div>
<div class="line"><span class="lineno">  158</span>        )</div>
<div class="line"><span class="lineno">  159</span>    <span class="keywordflow">elif</span> isinstance(val, dict):</div>
<div class="line"><span class="lineno">  160</span>        df = dict_factory</div>
<div class="line"><span class="lineno">  161</span>        rv = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>(</div>
<div class="line"><span class="lineno">  162</span>            (</div>
<div class="line"><span class="lineno">  163</span>                _asdict_anything(</div>
<div class="line"><span class="lineno">  164</span>                    kk,</div>
<div class="line"><span class="lineno">  165</span>                    is_key=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  166</span>                    filter=filter,</div>
<div class="line"><span class="lineno">  167</span>                    dict_factory=df,</div>
<div class="line"><span class="lineno">  168</span>                    retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">  169</span>                    value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">  170</span>                ),</div>
<div class="line"><span class="lineno">  171</span>                _asdict_anything(</div>
<div class="line"><span class="lineno">  172</span>                    vv,</div>
<div class="line"><span class="lineno">  173</span>                    is_key=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  174</span>                    filter=filter,</div>
<div class="line"><span class="lineno">  175</span>                    dict_factory=df,</div>
<div class="line"><span class="lineno">  176</span>                    retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">  177</span>                    value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">  178</span>                ),</div>
<div class="line"><span class="lineno">  179</span>            )</div>
<div class="line"><span class="lineno">  180</span>            <span class="keywordflow">for</span> kk, vv <span class="keywordflow">in</span> val.items()</div>
<div class="line"><span class="lineno">  181</span>        )</div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  183</span>        rv = val</div>
<div class="line"><span class="lineno">  184</span>        <span class="keywordflow">if</span> value_serializer <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  185</span>            rv = value_serializer(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, rv)</div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">return</span> rv</div>
<div class="line"><span class="lineno">  188</span> </div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a2a33a012da63c0be8f0f3845c10bf577"><div class="ttname"><a href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a></div><div class="ttdeci">void int int npy_complex64 npy_complex64 npy_complex64 npy_complex64 npy_complex64 * df</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:172</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ea4558a56652f9f52210b5b304cdb69" name="a9ea4558a56652f9f52210b5b304cdb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea4558a56652f9f52210b5b304cdb69">&#9670;&#160;</a></span>asdict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.asdict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict_factory</em> = <code>dict</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>retain_collection_types</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_serializer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the ``attrs`` attribute values of *inst* as a dict.

Optionally recurse into other ``attrs``-decorated classes.

:param inst: Instance of an ``attrs``-decorated class.
:param bool recurse: Recurse into classes that are also
    ``attrs``-decorated.
:param callable filter: A callable whose return code determines whether an
    attribute or element is included (``True``) or dropped (``False``).  Is
    called with the `attrs.Attribute` as the first argument and the
    value as the second argument.
:param callable dict_factory: A callable to produce dictionaries from.  For
    example, to produce ordered dictionaries instead of normal Python
    dictionaries, pass in ``collections.OrderedDict``.
:param bool retain_collection_types: Do not convert to ``list`` when
    encountering an attribute whose type is ``tuple`` or ``set``.  Only
    meaningful if ``recurse`` is ``True``.
:param Optional[callable] value_serializer: A hook that is called for every
    attribute or dict key/value.  It receives the current instance, field
    and value and must return the (updated) value.  The hook is run *after*
    the optional *filter* has been applied.

:rtype: return type of *dict_factory*

:raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``
    class.

..  versionadded:: 16.0.0 *dict_factory*
..  versionadded:: 16.1.0 *retain_collection_types*
..  versionadded:: 20.3.0 *value_serializer*
..  versionadded:: 21.3.0 If a dict has a collection for a key, it is
    serialized as a tuple.
</pre> <div class="fragment"><div class="line"><span class="lineno">   17</span>):</div>
<div class="line"><span class="lineno">   18</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral">    Return the ``attrs`` attribute values of *inst* as a dict.</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral">    Optionally recurse into other ``attrs``-decorated classes.</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    :param inst: Instance of an ``attrs``-decorated class.</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">    :param bool recurse: Recurse into classes that are also</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">        ``attrs``-decorated.</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    :param callable filter: A callable whose return code determines whether an</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">        attribute or element is included (``True``) or dropped (``False``).  Is</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">        called with the `attrs.Attribute` as the first argument and the</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">        value as the second argument.</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    :param callable dict_factory: A callable to produce dictionaries from.  For</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">        example, to produce ordered dictionaries instead of normal Python</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">        dictionaries, pass in ``collections.OrderedDict``.</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    :param bool retain_collection_types: Do not convert to ``list`` when</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">        encountering an attribute whose type is ``tuple`` or ``set``.  Only</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">        meaningful if ``recurse`` is ``True``.</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    :param Optional[callable] value_serializer: A hook that is called for every</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        attribute or dict key/value.  It receives the current instance, field</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">        and value and must return the (updated) value.  The hook is run *after*</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        the optional *filter* has been applied.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    :rtype: return type of *dict_factory*</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">        class.</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    ..  versionadded:: 16.0.0 *dict_factory*</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    ..  versionadded:: 16.1.0 *retain_collection_types*</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    ..  versionadded:: 20.3.0 *value_serializer*</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    ..  versionadded:: 21.3.0 If a dict has a collection for a key, it is</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        serialized as a tuple.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   52</span>    attrs = fields(inst.__class__)</div>
<div class="line"><span class="lineno">   53</span>    rv = dict_factory()</div>
<div class="line"><span class="lineno">   54</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> attrs:</div>
<div class="line"><span class="lineno">   55</span>        v = getattr(inst, a.name)</div>
<div class="line"><span class="lineno">   56</span>        <span class="keywordflow">if</span> filter <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> filter(a, v):</div>
<div class="line"><span class="lineno">   57</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>        <span class="keywordflow">if</span> value_serializer <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   60</span>            v = value_serializer(inst, a, v)</div>
<div class="line"><span class="lineno">   61</span> </div>
<div class="line"><span class="lineno">   62</span>        <span class="keywordflow">if</span> recurse <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">   63</span>            <span class="keywordflow">if</span> has(v.__class__):</div>
<div class="line"><span class="lineno">   64</span>                rv[a.name] = asdict(</div>
<div class="line"><span class="lineno">   65</span>                    v,</div>
<div class="line"><span class="lineno">   66</span>                    recurse=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">   67</span>                    filter=filter,</div>
<div class="line"><span class="lineno">   68</span>                    dict_factory=dict_factory,</div>
<div class="line"><span class="lineno">   69</span>                    retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">   70</span>                    value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">   71</span>                )</div>
<div class="line"><span class="lineno">   72</span>            <span class="keywordflow">elif</span> isinstance(v, (tuple, list, set, frozenset)):</div>
<div class="line"><span class="lineno">   73</span>                cf = v.__class__ <span class="keywordflow">if</span> retain_collection_types <span class="keywordflow">is</span> <span class="keyword">True</span> <span class="keywordflow">else</span> list</div>
<div class="line"><span class="lineno">   74</span>                rv[a.name] = cf(</div>
<div class="line"><span class="lineno">   75</span>                    [</div>
<div class="line"><span class="lineno">   76</span>                        _asdict_anything(</div>
<div class="line"><span class="lineno">   77</span>                            i,</div>
<div class="line"><span class="lineno">   78</span>                            is_key=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">   79</span>                            filter=filter,</div>
<div class="line"><span class="lineno">   80</span>                            dict_factory=dict_factory,</div>
<div class="line"><span class="lineno">   81</span>                            retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">   82</span>                            value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">   83</span>                        )</div>
<div class="line"><span class="lineno">   84</span>                        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> v</div>
<div class="line"><span class="lineno">   85</span>                    ]</div>
<div class="line"><span class="lineno">   86</span>                )</div>
<div class="line"><span class="lineno">   87</span>            <span class="keywordflow">elif</span> isinstance(v, dict):</div>
<div class="line"><span class="lineno">   88</span>                df = dict_factory</div>
<div class="line"><span class="lineno">   89</span>                rv[a.name] = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>(</div>
<div class="line"><span class="lineno">   90</span>                    (</div>
<div class="line"><span class="lineno">   91</span>                        _asdict_anything(</div>
<div class="line"><span class="lineno">   92</span>                            kk,</div>
<div class="line"><span class="lineno">   93</span>                            is_key=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">   94</span>                            filter=filter,</div>
<div class="line"><span class="lineno">   95</span>                            dict_factory=df,</div>
<div class="line"><span class="lineno">   96</span>                            retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">   97</span>                            value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">   98</span>                        ),</div>
<div class="line"><span class="lineno">   99</span>                        _asdict_anything(</div>
<div class="line"><span class="lineno">  100</span>                            vv,</div>
<div class="line"><span class="lineno">  101</span>                            is_key=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  102</span>                            filter=filter,</div>
<div class="line"><span class="lineno">  103</span>                            dict_factory=df,</div>
<div class="line"><span class="lineno">  104</span>                            retain_collection_types=retain_collection_types,</div>
<div class="line"><span class="lineno">  105</span>                            value_serializer=value_serializer,</div>
<div class="line"><span class="lineno">  106</span>                        ),</div>
<div class="line"><span class="lineno">  107</span>                    )</div>
<div class="line"><span class="lineno">  108</span>                    <span class="keywordflow">for</span> kk, vv <span class="keywordflow">in</span> v.items()</div>
<div class="line"><span class="lineno">  109</span>                )</div>
<div class="line"><span class="lineno">  110</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  111</span>                rv[a.name] = v</div>
<div class="line"><span class="lineno">  112</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  113</span>            rv[a.name] = v</div>
<div class="line"><span class="lineno">  114</span>    <span class="keywordflow">return</span> rv</div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af582f4beeebbbc97570a5768fa894483" name="af582f4beeebbbc97570a5768fa894483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af582f4beeebbbc97570a5768fa894483">&#9670;&#160;</a></span>assoc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.assoc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Copy *inst* and apply *changes*.

:param inst: Instance of a class with ``attrs`` attributes.
:param changes: Keyword changes in the new copy.

:return: A copy of inst with *changes* incorporated.

:raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn't
    be found on *cls*.
:raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``
    class.

..  deprecated:: 17.1.0
    Use `attrs.evolve` instead if you can.
    This function will not be removed du to the slightly different approach
    compared to `attrs.evolve`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  302</span><span class="keyword">def </span>assoc(inst, **changes):</div>
<div class="line"><span class="lineno">  303</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    Copy *inst* and apply *changes*.</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    :param inst: Instance of a class with ``attrs`` attributes.</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    :param changes: Keyword changes in the new copy.</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    :return: A copy of inst with *changes* incorporated.</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    :raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn&#39;t</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        be found on *cls*.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">        class.</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    ..  deprecated:: 17.1.0</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        Use `attrs.evolve` instead if you can.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        This function will not be removed du to the slightly different approach</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        compared to `attrs.evolve`.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  321</span>    <span class="keyword">import</span> warnings</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>    warnings.warn(</div>
<div class="line"><span class="lineno">  324</span>        <span class="stringliteral">&quot;assoc is deprecated and will be removed after 2018/01.&quot;</span>,</div>
<div class="line"><span class="lineno">  325</span>        DeprecationWarning,</div>
<div class="line"><span class="lineno">  326</span>        stacklevel=2,</div>
<div class="line"><span class="lineno">  327</span>    )</div>
<div class="line"><span class="lineno">  328</span>    new = copy.copy(inst)</div>
<div class="line"><span class="lineno">  329</span>    attrs = fields(inst.__class__)</div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> changes.items():</div>
<div class="line"><span class="lineno">  331</span>        a = getattr(attrs, k, NOTHING)</div>
<div class="line"><span class="lineno">  332</span>        <span class="keywordflow">if</span> a <span class="keywordflow">is</span> NOTHING:</div>
<div class="line"><span class="lineno">  333</span>            <span class="keywordflow">raise</span> AttrsAttributeNotFoundError(</div>
<div class="line"><span class="lineno">  334</span>                f<span class="stringliteral">&quot;{k} is not an attrs attribute on {new.__class__}.&quot;</span></div>
<div class="line"><span class="lineno">  335</span>            )</div>
<div class="line"><span class="lineno">  336</span>        _obj_setattr(new, k, v)</div>
<div class="line"><span class="lineno">  337</span>    <span class="keywordflow">return</span> new</div>
<div class="line"><span class="lineno">  338</span> </div>
<div class="line"><span class="lineno">  339</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa56e821cedf493375f974ff06750158f" name="aa56e821cedf493375f974ff06750158f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56e821cedf493375f974ff06750158f">&#9670;&#160;</a></span>astuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.astuple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tuple_factory</em> = <code>tuple</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>retain_collection_types</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the ``attrs`` attribute values of *inst* as a tuple.

Optionally recurse into other ``attrs``-decorated classes.

:param inst: Instance of an ``attrs``-decorated class.
:param bool recurse: Recurse into classes that are also
    ``attrs``-decorated.
:param callable filter: A callable whose return code determines whether an
    attribute or element is included (``True``) or dropped (``False``).  Is
    called with the `attrs.Attribute` as the first argument and the
    value as the second argument.
:param callable tuple_factory: A callable to produce tuples from.  For
    example, to produce lists instead of tuples.
:param bool retain_collection_types: Do not convert to ``list``
    or ``dict`` when encountering an attribute which type is
    ``tuple``, ``dict`` or ``set``.  Only meaningful if ``recurse`` is
    ``True``.

:rtype: return type of *tuple_factory*

:raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``
    class.

..  versionadded:: 16.2.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  196</span>):</div>
<div class="line"><span class="lineno">  197</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    Return the ``attrs`` attribute values of *inst* as a tuple.</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    Optionally recurse into other ``attrs``-decorated classes.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    :param inst: Instance of an ``attrs``-decorated class.</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    :param bool recurse: Recurse into classes that are also</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        ``attrs``-decorated.</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    :param callable filter: A callable whose return code determines whether an</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        attribute or element is included (``True``) or dropped (``False``).  Is</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        called with the `attrs.Attribute` as the first argument and the</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        value as the second argument.</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    :param callable tuple_factory: A callable to produce tuples from.  For</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        example, to produce lists instead of tuples.</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    :param bool retain_collection_types: Do not convert to ``list``</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        or ``dict`` when encountering an attribute which type is</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        ``tuple``, ``dict`` or ``set``.  Only meaningful if ``recurse`` is</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        ``True``.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    :rtype: return type of *tuple_factory*</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        class.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    ..  versionadded:: 16.2.0</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  223</span>    attrs = fields(inst.__class__)</div>
<div class="line"><span class="lineno">  224</span>    rv = []</div>
<div class="line"><span class="lineno">  225</span>    retain = retain_collection_types  <span class="comment"># Very long. :/</span></div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> attrs:</div>
<div class="line"><span class="lineno">  227</span>        v = getattr(inst, a.name)</div>
<div class="line"><span class="lineno">  228</span>        <span class="keywordflow">if</span> filter <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> filter(a, v):</div>
<div class="line"><span class="lineno">  229</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  230</span>        <span class="keywordflow">if</span> recurse <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  231</span>            <span class="keywordflow">if</span> has(v.__class__):</div>
<div class="line"><span class="lineno">  232</span>                rv.append(</div>
<div class="line"><span class="lineno">  233</span>                    astuple(</div>
<div class="line"><span class="lineno">  234</span>                        v,</div>
<div class="line"><span class="lineno">  235</span>                        recurse=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  236</span>                        filter=filter,</div>
<div class="line"><span class="lineno">  237</span>                        tuple_factory=tuple_factory,</div>
<div class="line"><span class="lineno">  238</span>                        retain_collection_types=retain,</div>
<div class="line"><span class="lineno">  239</span>                    )</div>
<div class="line"><span class="lineno">  240</span>                )</div>
<div class="line"><span class="lineno">  241</span>            <span class="keywordflow">elif</span> isinstance(v, (tuple, list, set, frozenset)):</div>
<div class="line"><span class="lineno">  242</span>                cf = v.__class__ <span class="keywordflow">if</span> retain <span class="keywordflow">is</span> <span class="keyword">True</span> <span class="keywordflow">else</span> list</div>
<div class="line"><span class="lineno">  243</span>                rv.append(</div>
<div class="line"><span class="lineno">  244</span>                    cf(</div>
<div class="line"><span class="lineno">  245</span>                        [</div>
<div class="line"><span class="lineno">  246</span>                            astuple(</div>
<div class="line"><span class="lineno">  247</span>                                j,</div>
<div class="line"><span class="lineno">  248</span>                                recurse=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  249</span>                                filter=filter,</div>
<div class="line"><span class="lineno">  250</span>                                tuple_factory=tuple_factory,</div>
<div class="line"><span class="lineno">  251</span>                                retain_collection_types=retain,</div>
<div class="line"><span class="lineno">  252</span>                            )</div>
<div class="line"><span class="lineno">  253</span>                            <span class="keywordflow">if</span> has(j.__class__)</div>
<div class="line"><span class="lineno">  254</span>                            <span class="keywordflow">else</span> j</div>
<div class="line"><span class="lineno">  255</span>                            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> v</div>
<div class="line"><span class="lineno">  256</span>                        ]</div>
<div class="line"><span class="lineno">  257</span>                    )</div>
<div class="line"><span class="lineno">  258</span>                )</div>
<div class="line"><span class="lineno">  259</span>            <span class="keywordflow">elif</span> isinstance(v, dict):</div>
<div class="line"><span class="lineno">  260</span>                df = v.__class__ <span class="keywordflow">if</span> retain <span class="keywordflow">is</span> <span class="keyword">True</span> <span class="keywordflow">else</span> dict</div>
<div class="line"><span class="lineno">  261</span>                rv.append(</div>
<div class="line"><span class="lineno">  262</span>                    <a class="code hl_variable" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>(</div>
<div class="line"><span class="lineno">  263</span>                        (</div>
<div class="line"><span class="lineno">  264</span>                            astuple(</div>
<div class="line"><span class="lineno">  265</span>                                kk,</div>
<div class="line"><span class="lineno">  266</span>                                tuple_factory=tuple_factory,</div>
<div class="line"><span class="lineno">  267</span>                                retain_collection_types=retain,</div>
<div class="line"><span class="lineno">  268</span>                            )</div>
<div class="line"><span class="lineno">  269</span>                            <span class="keywordflow">if</span> has(kk.__class__)</div>
<div class="line"><span class="lineno">  270</span>                            <span class="keywordflow">else</span> kk,</div>
<div class="line"><span class="lineno">  271</span>                            astuple(</div>
<div class="line"><span class="lineno">  272</span>                                vv,</div>
<div class="line"><span class="lineno">  273</span>                                tuple_factory=tuple_factory,</div>
<div class="line"><span class="lineno">  274</span>                                retain_collection_types=retain,</div>
<div class="line"><span class="lineno">  275</span>                            )</div>
<div class="line"><span class="lineno">  276</span>                            <span class="keywordflow">if</span> has(vv.__class__)</div>
<div class="line"><span class="lineno">  277</span>                            <span class="keywordflow">else</span> vv,</div>
<div class="line"><span class="lineno">  278</span>                        )</div>
<div class="line"><span class="lineno">  279</span>                        <span class="keywordflow">for</span> kk, vv <span class="keywordflow">in</span> v.items()</div>
<div class="line"><span class="lineno">  280</span>                    )</div>
<div class="line"><span class="lineno">  281</span>                )</div>
<div class="line"><span class="lineno">  282</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  283</span>                rv.append(v)</div>
<div class="line"><span class="lineno">  284</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  285</span>            rv.append(v)</div>
<div class="line"><span class="lineno">  286</span> </div>
<div class="line"><span class="lineno">  287</span>    <span class="keywordflow">return</span> rv <span class="keywordflow">if</span> tuple_factory <span class="keywordflow">is</span> list <span class="keywordflow">else</span> tuple_factory(rv)</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae535ad200b0d8355062f462de63b352" name="aae535ad200b0d8355062f462de63b352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae535ad200b0d8355062f462de63b352">&#9670;&#160;</a></span>evolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.evolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new instance, based on *inst* with *changes* applied.

:param inst: Instance of a class with ``attrs`` attributes.
:param changes: Keyword changes in the new copy.

:return: A copy of inst with *changes* incorporated.

:raise TypeError: If *attr_name* couldn't be found in the class
    ``__init__``.
:raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``
    class.

..  versionadded:: 17.1.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  340</span><span class="keyword">def </span>evolve(inst, **changes):</div>
<div class="line"><span class="lineno">  341</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    Create a new instance, based on *inst* with *changes* applied.</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    :param inst: Instance of a class with ``attrs`` attributes.</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    :param changes: Keyword changes in the new copy.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    :return: A copy of inst with *changes* incorporated.</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    :raise TypeError: If *attr_name* couldn&#39;t be found in the class</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        ``__init__``.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        class.</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    ..  versionadded:: 17.1.0</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  356</span>    cls = inst.__class__</div>
<div class="line"><span class="lineno">  357</span>    attrs = fields(cls)</div>
<div class="line"><span class="lineno">  358</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> attrs:</div>
<div class="line"><span class="lineno">  359</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> a.init:</div>
<div class="line"><span class="lineno">  360</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  361</span>        attr_name = a.name  <span class="comment"># To deal with private attributes.</span></div>
<div class="line"><span class="lineno">  362</span>        init_name = a.alias</div>
<div class="line"><span class="lineno">  363</span>        <span class="keywordflow">if</span> init_name <span class="keywordflow">not</span> <span class="keywordflow">in</span> changes:</div>
<div class="line"><span class="lineno">  364</span>            changes[init_name] = getattr(inst, attr_name)</div>
<div class="line"><span class="lineno">  365</span> </div>
<div class="line"><span class="lineno">  366</span>    <span class="keywordflow">return</span> cls(**changes)</div>
<div class="line"><span class="lineno">  367</span> </div>
<div class="line"><span class="lineno">  368</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acb41daebc62d8bfd9197c816a81b1cce" name="acb41daebc62d8bfd9197c816a81b1cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb41daebc62d8bfd9197c816a81b1cce">&#9670;&#160;</a></span>has()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.has </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether *cls* is a class with ``attrs`` attributes.

:param type cls: Class to introspect.
:raise TypeError: If *cls* is not a class.

:rtype: bool
</pre> <div class="fragment"><div class="line"><span class="lineno">  290</span><span class="keyword">def </span>has(cls):</div>
<div class="line"><span class="lineno">  291</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    Check whether *cls* is a class with ``attrs`` attributes.</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    :param type cls: Class to introspect.</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    :raise TypeError: If *cls* is not a class.</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    :rtype: bool</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">return</span> getattr(cls, <span class="stringliteral">&quot;__attrs_attrs__&quot;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a55810b0d49f6a451deac0855db7af474" name="a55810b0d49f6a451deac0855db7af474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55810b0d49f6a451deac0855db7af474">&#9670;&#160;</a></span>resolve_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.resolve_types </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>globalns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>localns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attribs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Resolve any strings and forward annotations in type annotations.

This is only required if you need concrete types in `Attribute`'s *type*
field. In other words, you don't need to resolve your types if you only
use them for static type checking.

With no arguments, names will be looked up in the module in which the class
was created. If this is not what you want, e.g. if the name only exists
inside a method, you may pass *globalns* or *localns* to specify other
dictionaries in which to look up these names. See the docs of
`typing.get_type_hints` for more details.

:param type cls: Class to resolve.
:param Optional[dict] globalns: Dictionary containing global variables.
:param Optional[dict] localns: Dictionary containing local variables.
:param Optional[list] attribs: List of attribs for the given class.
    This is necessary when calling from inside a ``field_transformer``
    since *cls* is not an ``attrs`` class yet.

:raise TypeError: If *cls* is not a class.
:raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``
    class and you didn't pass any attribs.
:raise NameError: If types cannot be resolved because of missing variables.

:returns: *cls* so you can use this function also as a class decorator.
    Please note that you have to apply it **after** `attrs.define`. That
    means the decorator has to come in the line **before** `attrs.define`.

..  versionadded:: 20.1.0
..  versionadded:: 21.1.0 *attribs*</pre> <div class="fragment"><div class="line"><span class="lineno">  369</span><span class="keyword">def </span>resolve_types(cls, globalns=None, localns=None, attribs=None):</div>
<div class="line"><span class="lineno">  370</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    Resolve any strings and forward annotations in type annotations.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    This is only required if you need concrete types in `Attribute`&#39;s *type*</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    field. In other words, you don&#39;t need to resolve your types if you only</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    use them for static type checking.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    With no arguments, names will be looked up in the module in which the class</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    was created. If this is not what you want, e.g. if the name only exists</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    inside a method, you may pass *globalns* or *localns* to specify other</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    dictionaries in which to look up these names. See the docs of</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    `typing.get_type_hints` for more details.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    :param type cls: Class to resolve.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    :param Optional[dict] globalns: Dictionary containing global variables.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    :param Optional[dict] localns: Dictionary containing local variables.</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    :param Optional[list] attribs: List of attribs for the given class.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        This is necessary when calling from inside a ``field_transformer``</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        since *cls* is not an ``attrs`` class yet.</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    :raise TypeError: If *cls* is not a class.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">        class and you didn&#39;t pass any attribs.</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    :raise NameError: If types cannot be resolved because of missing variables.</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    :returns: *cls* so you can use this function also as a class decorator.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">        Please note that you have to apply it **after** `attrs.define`. That</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">        means the decorator has to come in the line **before** `attrs.define`.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    ..  versionadded:: 20.1.0</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    ..  versionadded:: 21.1.0 *attribs*</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  403</span>    <span class="comment"># Since calling get_type_hints is expensive we cache whether we&#39;ve</span></div>
<div class="line"><span class="lineno">  404</span>    <span class="comment"># done it already.</span></div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordflow">if</span> getattr(cls, <span class="stringliteral">&quot;__attrs_types_resolved__&quot;</span>, <span class="keywordtype">None</span>) != cls:</div>
<div class="line"><span class="lineno">  406</span>        <span class="keyword">import</span> typing</div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span>        hints = typing.get_type_hints(cls, globalns=globalns, localns=localns)</div>
<div class="line"><span class="lineno">  409</span>        <span class="keywordflow">for</span> field <span class="keywordflow">in</span> fields(cls) <span class="keywordflow">if</span> attribs <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> attribs:</div>
<div class="line"><span class="lineno">  410</span>            <span class="keywordflow">if</span> field.name <span class="keywordflow">in</span> hints:</div>
<div class="line"><span class="lineno">  411</span>                <span class="comment"># Since fields have been frozen we must work around it.</span></div>
<div class="line"><span class="lineno">  412</span>                _obj_setattr(field, <span class="stringliteral">&quot;type&quot;</span>, hints[field.name])</div>
<div class="line"><span class="lineno">  413</span>        <span class="comment"># We store the class we resolved so that subclasses know they haven&#39;t</span></div>
<div class="line"><span class="lineno">  414</span>        <span class="comment"># been resolved.</span></div>
<div class="line"><span class="lineno">  415</span>        cls.__attrs_types_resolved__ = cls</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>    <span class="comment"># Return the class so you can use it as a decorator too.</span></div>
<div class="line"><span class="lineno">  418</span>    <span class="keywordflow">return</span> cls</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
