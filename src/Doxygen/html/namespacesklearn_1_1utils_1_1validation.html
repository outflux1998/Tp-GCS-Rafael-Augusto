<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.utils.validation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html">validation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sklearn.utils.validation Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b491e58cfa1ea6b9eddbd05581afdd5" id="r_a0b491e58cfa1ea6b9eddbd05581afdd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a0b491e58cfa1ea6b9eddbd05581afdd5">_deprecate_positional_args</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>=None, *version=&quot;1.3&quot;)</td></tr>
<tr class="separator:a0b491e58cfa1ea6b9eddbd05581afdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a62f217416ae84f85f6a057a0e3f23" id="r_ad4a62f217416ae84f85f6a057a0e3f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#ad4a62f217416ae84f85f6a057a0e3f23">_assert_all_finite</a> (X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=&quot;&quot;)</td></tr>
<tr class="separator:ad4a62f217416ae84f85f6a057a0e3f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845ed63e43216bb6cdca8fc7ed34888a" id="r_a845ed63e43216bb6cdca8fc7ed34888a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a845ed63e43216bb6cdca8fc7ed34888a">assert_all_finite</a> (X, *allow_nan=False, estimator_name=None, input_name=&quot;&quot;)</td></tr>
<tr class="separator:a845ed63e43216bb6cdca8fc7ed34888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebe645081521254c0460747f06c848f" id="r_acebe645081521254c0460747f06c848f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#acebe645081521254c0460747f06c848f">as_float_array</a> (X, *copy=True, force_all_finite=True)</td></tr>
<tr class="separator:acebe645081521254c0460747f06c848f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74c4bdbb9185e056d4db94a4321d4b" id="r_a7a74c4bdbb9185e056d4db94a4321d4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a7a74c4bdbb9185e056d4db94a4321d4b">_is_arraylike</a> (x)</td></tr>
<tr class="separator:a7a74c4bdbb9185e056d4db94a4321d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af048955280074c9ef7215354038a2d" id="r_a4af048955280074c9ef7215354038a2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a4af048955280074c9ef7215354038a2d">_is_arraylike_not_scalar</a> (array)</td></tr>
<tr class="separator:a4af048955280074c9ef7215354038a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac633479b1dc831cf7ed4e7b59ad364" id="r_aeac633479b1dc831cf7ed4e7b59ad364"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#aeac633479b1dc831cf7ed4e7b59ad364">_num_features</a> (X)</td></tr>
<tr class="separator:aeac633479b1dc831cf7ed4e7b59ad364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f819616f9cf7c4a803a684bb783bdfe" id="r_a2f819616f9cf7c4a803a684bb783bdfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a2f819616f9cf7c4a803a684bb783bdfe">_num_samples</a> (x)</td></tr>
<tr class="separator:a2f819616f9cf7c4a803a684bb783bdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab472519c2e841a2531e0a8dc3b9fbd64" id="r_ab472519c2e841a2531e0a8dc3b9fbd64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#ab472519c2e841a2531e0a8dc3b9fbd64">check_memory</a> (memory)</td></tr>
<tr class="separator:ab472519c2e841a2531e0a8dc3b9fbd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d76ca8a780f1b9df7f975d307e28dc8" id="r_a3d76ca8a780f1b9df7f975d307e28dc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a3d76ca8a780f1b9df7f975d307e28dc8">check_consistent_length</a> (*arrays)</td></tr>
<tr class="separator:a3d76ca8a780f1b9df7f975d307e28dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7550ba455fda84a6ace62242d3b0dc70" id="r_a7550ba455fda84a6ace62242d3b0dc70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a7550ba455fda84a6ace62242d3b0dc70">_make_indexable</a> (iterable)</td></tr>
<tr class="separator:a7550ba455fda84a6ace62242d3b0dc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b868d5db67011bff3ac38f2dbaf4e" id="r_a504b868d5db67011bff3ac38f2dbaf4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a504b868d5db67011bff3ac38f2dbaf4e">indexable</a> (*iterables)</td></tr>
<tr class="separator:a504b868d5db67011bff3ac38f2dbaf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d375a2f8881aa24b3db8cbf7647aa90" id="r_a5d375a2f8881aa24b3db8cbf7647aa90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a5d375a2f8881aa24b3db8cbf7647aa90">_ensure_sparse_format</a> (spmatrix, accept_sparse, dtype, copy, force_all_finite, accept_large_sparse, estimator_name=None, input_name=&quot;&quot;)</td></tr>
<tr class="separator:a5d375a2f8881aa24b3db8cbf7647aa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa634741aed9f3b17aad8a66b5577ec85" id="r_aa634741aed9f3b17aad8a66b5577ec85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#aa634741aed9f3b17aad8a66b5577ec85">_ensure_no_complex_data</a> (array)</td></tr>
<tr class="separator:aa634741aed9f3b17aad8a66b5577ec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622220dd6fe3de2a1d211be4e82d25b4" id="r_a622220dd6fe3de2a1d211be4e82d25b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a622220dd6fe3de2a1d211be4e82d25b4">_check_estimator_name</a> (estimator)</td></tr>
<tr class="separator:a622220dd6fe3de2a1d211be4e82d25b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebca20e325263d762622596fa7b1bac" id="r_a0ebca20e325263d762622596fa7b1bac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a0ebca20e325263d762622596fa7b1bac">_pandas_dtype_needs_early_conversion</a> (pd_dtype)</td></tr>
<tr class="separator:a0ebca20e325263d762622596fa7b1bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616829948911596bf72e5e20a26f2fab" id="r_a616829948911596bf72e5e20a26f2fab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a616829948911596bf72e5e20a26f2fab">check_array</a> (array, accept_sparse=False, *accept_large_sparse=True, dtype=&quot;numeric&quot;, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None, copy=False, force_all_finite=True, ensure_2d=True, allow_nd=False, ensure_min_samples=1, ensure_min_features=1, estimator=None, input_name=&quot;&quot;)</td></tr>
<tr class="separator:a616829948911596bf72e5e20a26f2fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66127648643ff52252663b27ccb84278" id="r_a66127648643ff52252663b27ccb84278"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a66127648643ff52252663b27ccb84278">_check_large_sparse</a> (X, accept_large_sparse=False)</td></tr>
<tr class="separator:a66127648643ff52252663b27ccb84278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac632ce030bd7b0dc0d68a269acefc27" id="r_aac632ce030bd7b0dc0d68a269acefc27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#aac632ce030bd7b0dc0d68a269acefc27">check_X_y</a> (X, y, accept_sparse=False, *accept_large_sparse=True, dtype=&quot;numeric&quot;, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None, copy=False, force_all_finite=True, ensure_2d=True, allow_nd=False, multi_output=False, ensure_min_samples=1, ensure_min_features=1, y_numeric=False, estimator=None)</td></tr>
<tr class="separator:aac632ce030bd7b0dc0d68a269acefc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d745f985dadefe1bf3a15fb67d5243" id="r_a72d745f985dadefe1bf3a15fb67d5243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a72d745f985dadefe1bf3a15fb67d5243">_check_y</a> (y, multi_output=False, y_numeric=False, estimator=None)</td></tr>
<tr class="separator:a72d745f985dadefe1bf3a15fb67d5243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f60f7bf55522e1b6342d541ae018ac" id="r_ab9f60f7bf55522e1b6342d541ae018ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#ab9f60f7bf55522e1b6342d541ae018ac">column_or_1d</a> (y, *dtype=None, warn=False)</td></tr>
<tr class="separator:ab9f60f7bf55522e1b6342d541ae018ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e9f59100d50fa74df40218a4de1471" id="r_a02e9f59100d50fa74df40218a4de1471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a02e9f59100d50fa74df40218a4de1471">check_random_state</a> (seed)</td></tr>
<tr class="separator:a02e9f59100d50fa74df40218a4de1471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e26a6139a4438d6cb20d7df8e22627" id="r_ac4e26a6139a4438d6cb20d7df8e22627"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#ac4e26a6139a4438d6cb20d7df8e22627">has_fit_parameter</a> (estimator, parameter)</td></tr>
<tr class="separator:ac4e26a6139a4438d6cb20d7df8e22627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f901fc41b1ee3c98df4c59b365495d2" id="r_a6f901fc41b1ee3c98df4c59b365495d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a6f901fc41b1ee3c98df4c59b365495d2">check_symmetric</a> (array, *<a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-10, raise_warning=True, raise_exception=False)</td></tr>
<tr class="separator:a6f901fc41b1ee3c98df4c59b365495d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62ae60044363a1a546da93c2bd89ac2" id="r_ae62ae60044363a1a546da93c2bd89ac2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#ae62ae60044363a1a546da93c2bd89ac2">check_is_fitted</a> (estimator, attributes=None, *msg=None, all_or_any=all)</td></tr>
<tr class="separator:ae62ae60044363a1a546da93c2bd89ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219a80672df078db2c451d95db8833ee" id="r_a219a80672df078db2c451d95db8833ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a219a80672df078db2c451d95db8833ee">check_non_negative</a> (X, whom)</td></tr>
<tr class="separator:a219a80672df078db2c451d95db8833ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc729f787899d05dd3469fd181ce02a" id="r_a2dc729f787899d05dd3469fd181ce02a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a2dc729f787899d05dd3469fd181ce02a">check_scalar</a> (x, name, target_type, *min_val=None, max_val=None, include_boundaries=&quot;both&quot;)</td></tr>
<tr class="separator:a2dc729f787899d05dd3469fd181ce02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb9557cb2e17288962287ce3c50e4d1" id="r_addb9557cb2e17288962287ce3c50e4d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#addb9557cb2e17288962287ce3c50e4d1">_check_psd_eigenvalues</a> (lambdas, enable_warnings=False)</td></tr>
<tr class="separator:addb9557cb2e17288962287ce3c50e4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5956ce2fcf59f3b8bb1700de1bf15fdf" id="r_a5956ce2fcf59f3b8bb1700de1bf15fdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a5956ce2fcf59f3b8bb1700de1bf15fdf">_check_sample_weight</a> (sample_weight, X, dtype=None, copy=False, only_non_negative=False)</td></tr>
<tr class="separator:a5956ce2fcf59f3b8bb1700de1bf15fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a79b268e62f5ed44d02169fc1adb39" id="r_a53a79b268e62f5ed44d02169fc1adb39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a53a79b268e62f5ed44d02169fc1adb39">_allclose_dense_sparse</a> (x, y, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=1e-7, atol=1e-9)</td></tr>
<tr class="separator:a53a79b268e62f5ed44d02169fc1adb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0273ea0c6c5644a4d05d80c36c6384f" id="r_af0273ea0c6c5644a4d05d80c36c6384f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#af0273ea0c6c5644a4d05d80c36c6384f">_check_fit_params</a> (X, fit_params, indices=None)</td></tr>
<tr class="separator:af0273ea0c6c5644a4d05d80c36c6384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa403f42854f5a6a64e52a464b347c9f7" id="r_aa403f42854f5a6a64e52a464b347c9f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#aa403f42854f5a6a64e52a464b347c9f7">_get_feature_names</a> (X)</td></tr>
<tr class="separator:aa403f42854f5a6a64e52a464b347c9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02007205a12bf0bb15f0b28f7acdf888" id="r_a02007205a12bf0bb15f0b28f7acdf888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a02007205a12bf0bb15f0b28f7acdf888">_check_feature_names_in</a> (estimator, input_features=None, *generate_names=True)</td></tr>
<tr class="separator:a02007205a12bf0bb15f0b28f7acdf888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c81bffff5d7bcec77445438cdfaa82" id="r_a64c81bffff5d7bcec77445438cdfaa82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a64c81bffff5d7bcec77445438cdfaa82">_generate_get_feature_names_out</a> (estimator, n_features_out, input_features=None)</td></tr>
<tr class="separator:a64c81bffff5d7bcec77445438cdfaa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dbace05a46d67eb4eb76c35feaed3e" id="r_a47dbace05a46d67eb4eb76c35feaed3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a47dbace05a46d67eb4eb76c35feaed3e">_check_monotonic_cst</a> (estimator, monotonic_cst=None)</td></tr>
<tr class="separator:a47dbace05a46d67eb4eb76c35feaed3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6f695de28a35eaa5749b3ba2d290d83e" id="r_a6f695de28a35eaa5749b3ba2d290d83e"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1utils_1_1validation.html#a6f695de28a35eaa5749b3ba2d290d83e">FLOAT_DTYPES</a> = (np.float64, np.float32, np.float16)</td></tr>
<tr class="separator:a6f695de28a35eaa5749b3ba2d290d83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Utilities for input validation</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a53a79b268e62f5ed44d02169fc1adb39" name="a53a79b268e62f5ed44d02169fc1adb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a79b268e62f5ed44d02169fc1adb39">&#9670;&#160;</a></span>_allclose_dense_sparse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._allclose_dense_sparse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1e-7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check allclose for sparse and dense data.

Both x and y need to be either sparse or dense, they
can't be mixed.

Parameters
----------
x : {array-like, sparse matrix}
    First array to compare.

y : {array-like, sparse matrix}
    Second array to compare.

rtol : float, default=1e-7
    Relative tolerance; see numpy.allclose.

atol : float, default=1e-9
    absolute tolerance; see numpy.allclose. Note that the default here is
    more tolerant than the default for numpy.testing.assert_allclose, where
    atol=0.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1781</span><span class="keyword">def </span>_allclose_dense_sparse(x, y, rtol=1e-7, atol=1e-9):</div>
<div class="line"><span class="lineno"> 1782</span>    <span class="stringliteral">&quot;&quot;&quot;Check allclose for sparse and dense data.</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">    Both x and y need to be either sparse or dense, they</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">    can&#39;t be mixed.</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">    x : {array-like, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">        First array to compare.</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    y : {array-like, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">        Second array to compare.</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">    rtol : float, default=1e-7</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">        Relative tolerance; see numpy.allclose.</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">    atol : float, default=1e-9</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">        absolute tolerance; see numpy.allclose. Note that the default here is</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        more tolerant than the default for numpy.testing.assert_allclose, where</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">        atol=0.</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1803</span>    <span class="keywordflow">if</span> sp.issparse(x) <span class="keywordflow">and</span> sp.issparse(y):</div>
<div class="line"><span class="lineno"> 1804</span>        x = x.tocsr()</div>
<div class="line"><span class="lineno"> 1805</span>        y = y.tocsr()</div>
<div class="line"><span class="lineno"> 1806</span>        x.sum_duplicates()</div>
<div class="line"><span class="lineno"> 1807</span>        y.sum_duplicates()</div>
<div class="line"><span class="lineno"> 1808</span>        <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno"> 1809</span>            np.array_equal(x.indices, y.indices)</div>
<div class="line"><span class="lineno"> 1810</span>            <span class="keywordflow">and</span> np.array_equal(x.indptr, y.indptr)</div>
<div class="line"><span class="lineno"> 1811</span>            <span class="keywordflow">and</span> np.allclose(x.data, y.data, rtol=rtol, atol=atol)</div>
<div class="line"><span class="lineno"> 1812</span>        )</div>
<div class="line"><span class="lineno"> 1813</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> sp.issparse(x) <span class="keywordflow">and</span> <span class="keywordflow">not</span> sp.issparse(y):</div>
<div class="line"><span class="lineno"> 1814</span>        <span class="keywordflow">return</span> np.allclose(x, y, rtol=rtol, atol=atol)</div>
<div class="line"><span class="lineno"> 1815</span>    <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1816</span>        <span class="stringliteral">&quot;Can only compare two sparse matrices, not a sparse matrix and an array&quot;</span></div>
<div class="line"><span class="lineno"> 1817</span>    )</div>
<div class="line"><span class="lineno"> 1818</span> </div>
<div class="line"><span class="lineno"> 1819</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4a62f217416ae84f85f6a057a0e3f23" name="ad4a62f217416ae84f85f6a057a0e3f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a62f217416ae84f85f6a057a0e3f23">&#9670;&#160;</a></span>_assert_all_finite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._assert_all_finite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_nan</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg_dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Like assert_all_finite, but only for ndarray.</pre> <div class="fragment"><div class="line"><span class="lineno">   98</span>):</div>
<div class="line"><span class="lineno">   99</span>    <span class="stringliteral">&quot;&quot;&quot;Like assert_all_finite, but only for ndarray.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>    xp, _ = get_namespace(X)</div>
<div class="line"><span class="lineno">  102</span> </div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">if</span> _get_config()[<span class="stringliteral">&quot;assume_finite&quot;</span>]:</div>
<div class="line"><span class="lineno">  104</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  105</span> </div>
<div class="line"><span class="lineno">  106</span>    X = xp.asarray(X)</div>
<div class="line"><span class="lineno">  107</span> </div>
<div class="line"><span class="lineno">  108</span>    <span class="comment"># for object dtype data, we only check for NaNs (GH-13254)</span></div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordflow">if</span> X.dtype == np.dtype(<span class="stringliteral">&quot;object&quot;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> allow_nan:</div>
<div class="line"><span class="lineno">  110</span>        <span class="keywordflow">if</span> _object_dtype_isnan(X).any():</div>
<div class="line"><span class="lineno">  111</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Input contains NaN&quot;</span>)</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>    <span class="comment"># We need only consider float arrays, hence can early return for all else.</span></div>
<div class="line"><span class="lineno">  114</span>    <span class="keywordflow">if</span> X.dtype.kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> <span class="stringliteral">&quot;fc&quot;</span>:</div>
<div class="line"><span class="lineno">  115</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>    <span class="comment"># First try an O(n) time, O(1) space solution for the common case that</span></div>
<div class="line"><span class="lineno">  118</span>    <span class="comment"># everything is finite; fall back to O(n) space `np.isinf/isnan` or custom</span></div>
<div class="line"><span class="lineno">  119</span>    <span class="comment"># Cython implementation to prevent false positives and provide a detailed</span></div>
<div class="line"><span class="lineno">  120</span>    <span class="comment"># error message.</span></div>
<div class="line"><span class="lineno">  121</span>    <span class="keyword">with</span> np.errstate(over=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno">  122</span>        first_pass_isfinite = xp.isfinite(xp.sum(X))</div>
<div class="line"><span class="lineno">  123</span>    <span class="keywordflow">if</span> first_pass_isfinite:</div>
<div class="line"><span class="lineno">  124</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  125</span>    <span class="comment"># Cython implementation doesn&#39;t support FP16 or complex numbers</span></div>
<div class="line"><span class="lineno">  126</span>    use_cython = (</div>
<div class="line"><span class="lineno">  127</span>        xp <span class="keywordflow">is</span> np <span class="keywordflow">and</span> X.data.contiguous <span class="keywordflow">and</span> X.dtype.type <span class="keywordflow">in</span> {np.float32, np.float64}</div>
<div class="line"><span class="lineno">  128</span>    )</div>
<div class="line"><span class="lineno">  129</span>    <span class="keywordflow">if</span> use_cython:</div>
<div class="line"><span class="lineno">  130</span>        out = cy_isfinite(X.reshape(-1), allow_nan=allow_nan)</div>
<div class="line"><span class="lineno">  131</span>        has_nan_error = <span class="keyword">False</span> <span class="keywordflow">if</span> allow_nan <span class="keywordflow">else</span> out == FiniteStatus.has_nan</div>
<div class="line"><span class="lineno">  132</span>        has_inf = out == FiniteStatus.has_infinite</div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  134</span>        has_inf = np.isinf(X).any()</div>
<div class="line"><span class="lineno">  135</span>        has_nan_error = <span class="keyword">False</span> <span class="keywordflow">if</span> allow_nan <span class="keywordflow">else</span> xp.isnan(X).any()</div>
<div class="line"><span class="lineno">  136</span>    <span class="keywordflow">if</span> has_inf <span class="keywordflow">or</span> has_nan_error:</div>
<div class="line"><span class="lineno">  137</span>        <span class="keywordflow">if</span> has_nan_error:</div>
<div class="line"><span class="lineno">  138</span>            type_err = <span class="stringliteral">&quot;NaN&quot;</span></div>
<div class="line"><span class="lineno">  139</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  140</span>            msg_dtype = msg_dtype <span class="keywordflow">if</span> msg_dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> X.dtype</div>
<div class="line"><span class="lineno">  141</span>            type_err = f<span class="stringliteral">&quot;infinity or a value too large for {msg_dtype!r}&quot;</span></div>
<div class="line"><span class="lineno">  142</span>        padded_input_name = input_name + <span class="stringliteral">&quot; &quot;</span> <span class="keywordflow">if</span> input_name <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  143</span>        msg_err = f<span class="stringliteral">&quot;Input {padded_input_name}contains {type_err}.&quot;</span></div>
<div class="line"><span class="lineno">  144</span>        <span class="keywordflow">if</span> estimator_name <span class="keywordflow">and</span> input_name == <span class="stringliteral">&quot;X&quot;</span> <span class="keywordflow">and</span> has_nan_error:</div>
<div class="line"><span class="lineno">  145</span>            <span class="comment"># Improve the error message on how to handle missing values in</span></div>
<div class="line"><span class="lineno">  146</span>            <span class="comment"># scikit-learn.</span></div>
<div class="line"><span class="lineno">  147</span>            msg_err += (</div>
<div class="line"><span class="lineno">  148</span>                f<span class="stringliteral">&quot;\n{estimator_name} does not accept missing values&quot;</span></div>
<div class="line"><span class="lineno">  149</span>                <span class="stringliteral">&quot; encoded as NaN natively. For supervised learning, you might want&quot;</span></div>
<div class="line"><span class="lineno">  150</span>                <span class="stringliteral">&quot; to consider sklearn.ensemble.HistGradientBoostingClassifier and&quot;</span></div>
<div class="line"><span class="lineno">  151</span>                <span class="stringliteral">&quot; Regressor which accept missing values encoded as NaNs natively.&quot;</span></div>
<div class="line"><span class="lineno">  152</span>                <span class="stringliteral">&quot; Alternatively, it is possible to preprocess the data, for&quot;</span></div>
<div class="line"><span class="lineno">  153</span>                <span class="stringliteral">&quot; instance by using an imputer transformer in a pipeline or drop&quot;</span></div>
<div class="line"><span class="lineno">  154</span>                <span class="stringliteral">&quot; samples with missing values. See&quot;</span></div>
<div class="line"><span class="lineno">  155</span>                <span class="stringliteral">&quot; https://scikit-learn.org/stable/modules/impute.html&quot;</span></div>
<div class="line"><span class="lineno">  156</span>                <span class="stringliteral">&quot; You can find a list of all estimators that handle NaN values&quot;</span></div>
<div class="line"><span class="lineno">  157</span>                <span class="stringliteral">&quot; at the following page:&quot;</span></div>
<div class="line"><span class="lineno">  158</span>                <span class="stringliteral">&quot; https://scikit-learn.org/stable/modules/impute.html&quot;</span></div>
<div class="line"><span class="lineno">  159</span>                <span class="stringliteral">&quot;#estimators-that-handle-nan-values&quot;</span></div>
<div class="line"><span class="lineno">  160</span>            )</div>
<div class="line"><span class="lineno">  161</span>        <span class="keywordflow">raise</span> ValueError(msg_err)</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a622220dd6fe3de2a1d211be4e82d25b4" name="a622220dd6fe3de2a1d211be4e82d25b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622220dd6fe3de2a1d211be4e82d25b4">&#9670;&#160;</a></span>_check_estimator_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_estimator_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  581</span><span class="keyword">def </span>_check_estimator_name(estimator):</div>
<div class="line"><span class="lineno">  582</span>    <span class="keywordflow">if</span> estimator <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  583</span>        <span class="keywordflow">if</span> isinstance(estimator, str):</div>
<div class="line"><span class="lineno">  584</span>            <span class="keywordflow">return</span> estimator</div>
<div class="line"><span class="lineno">  585</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  586</span>            <span class="keywordflow">return</span> estimator.__class__.__name__</div>
<div class="line"><span class="lineno">  587</span>    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02007205a12bf0bb15f0b28f7acdf888" name="a02007205a12bf0bb15f0b28f7acdf888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02007205a12bf0bb15f0b28f7acdf888">&#9670;&#160;</a></span>_check_feature_names_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_feature_names_in </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_features</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>generate_names</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check `input_features` and generate names if needed.

Commonly used in :term:`get_feature_names_out`.

Parameters
----------
input_features : array-like of str or None, default=None
    Input features.

    - If `input_features` is `None`, then `feature_names_in_` is
      used as feature names in. If `feature_names_in_` is not defined,
      then the following input feature names are generated:
      `["x0", "x1", ..., "x(n_features_in_ - 1)"]`.
    - If `input_features` is an array-like, then `input_features` must
      match `feature_names_in_` if `feature_names_in_` is defined.

generate_names : bool, default=True
    Whether to generate names when `input_features` is `None` and
    `estimator.feature_names_in_` is not defined. This is useful for transformers
    that validates `input_features` but do not require them in
    :term:`get_feature_names_out` e.g. `PCA`.

Returns
-------
feature_names_in : ndarray of str or `None`
    Feature names in.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1907</span><span class="keyword">def </span>_check_feature_names_in(estimator, input_features=None, *, generate_names=True):</div>
<div class="line"><span class="lineno"> 1908</span>    <span class="stringliteral">&quot;&quot;&quot;Check `input_features` and generate names if needed.</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">    Commonly used in :term:`get_feature_names_out`.</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">    input_features : array-like of str or None, default=None</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">        Input features.</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">        - If `input_features` is `None`, then `feature_names_in_` is</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral">          used as feature names in. If `feature_names_in_` is not defined,</span></div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">          then the following input feature names are generated:</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">          `[&quot;x0&quot;, &quot;x1&quot;, ..., &quot;x(n_features_in_ - 1)&quot;]`.</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">        - If `input_features` is an array-like, then `input_features` must</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral">          match `feature_names_in_` if `feature_names_in_` is defined.</span></div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral">    generate_names : bool, default=True</span></div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">        Whether to generate names when `input_features` is `None` and</span></div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">        `estimator.feature_names_in_` is not defined. This is useful for transformers</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral">        that validates `input_features` but do not require them in</span></div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">        :term:`get_feature_names_out` e.g. `PCA`.</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral">    feature_names_in : ndarray of str or `None`</span></div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">        Feature names in.</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1935</span> </div>
<div class="line"><span class="lineno"> 1936</span>    feature_names_in_ = getattr(estimator, <span class="stringliteral">&quot;feature_names_in_&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1937</span>    n_features_in_ = getattr(estimator, <span class="stringliteral">&quot;n_features_in_&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1938</span> </div>
<div class="line"><span class="lineno"> 1939</span>    <span class="keywordflow">if</span> input_features <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1940</span>        input_features = np.asarray(input_features, dtype=object)</div>
<div class="line"><span class="lineno"> 1941</span>        <span class="keywordflow">if</span> feature_names_in_ <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.array_equal(</div>
<div class="line"><span class="lineno"> 1942</span>            feature_names_in_, input_features</div>
<div class="line"><span class="lineno"> 1943</span>        ):</div>
<div class="line"><span class="lineno"> 1944</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;input_features is not equal to feature_names_in_&quot;</span>)</div>
<div class="line"><span class="lineno"> 1945</span> </div>
<div class="line"><span class="lineno"> 1946</span>        <span class="keywordflow">if</span> n_features_in_ <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> len(input_features) != n_features_in_:</div>
<div class="line"><span class="lineno"> 1947</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1948</span>                <span class="stringliteral">&quot;input_features should have length equal to number of &quot;</span></div>
<div class="line"><span class="lineno"> 1949</span>                f<span class="stringliteral">&quot;features ({n_features_in_}), got {len(input_features)}&quot;</span></div>
<div class="line"><span class="lineno"> 1950</span>            )</div>
<div class="line"><span class="lineno"> 1951</span>        <span class="keywordflow">return</span> input_features</div>
<div class="line"><span class="lineno"> 1952</span> </div>
<div class="line"><span class="lineno"> 1953</span>    <span class="keywordflow">if</span> feature_names_in_ <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1954</span>        <span class="keywordflow">return</span> feature_names_in_</div>
<div class="line"><span class="lineno"> 1955</span> </div>
<div class="line"><span class="lineno"> 1956</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> generate_names:</div>
<div class="line"><span class="lineno"> 1957</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1958</span> </div>
<div class="line"><span class="lineno"> 1959</span>    <span class="comment"># Generates feature names if `n_features_in_` is defined</span></div>
<div class="line"><span class="lineno"> 1960</span>    <span class="keywordflow">if</span> n_features_in_ <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1961</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unable to generate feature names without n_features_in_&quot;</span>)</div>
<div class="line"><span class="lineno"> 1962</span> </div>
<div class="line"><span class="lineno"> 1963</span>    <span class="keywordflow">return</span> np.asarray([f<span class="stringliteral">&quot;x{i}&quot;</span> <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n_features_in_)], dtype=object)</div>
<div class="line"><span class="lineno"> 1964</span> </div>
<div class="line"><span class="lineno"> 1965</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af0273ea0c6c5644a4d05d80c36c6384f" name="af0273ea0c6c5644a4d05d80c36c6384f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0273ea0c6c5644a4d05d80c36c6384f">&#9670;&#160;</a></span>_check_fit_params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_fit_params </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check and validate the parameters passed during `fit`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Data array.

fit_params : dict
    Dictionary containing the parameters passed at fit.

indices : array-like of shape (n_samples,), default=None
    Indices to be selected if the parameter has the same size as `X`.

Returns
-------
fit_params_validated : dict
    Validated parameters. We ensure that the values support indexing.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1820</span><span class="keyword">def </span>_check_fit_params(X, fit_params, indices=None):</div>
<div class="line"><span class="lineno"> 1821</span>    <span class="stringliteral">&quot;&quot;&quot;Check and validate the parameters passed during `fit`.</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">        Data array.</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    fit_params : dict</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        Dictionary containing the parameters passed at fit.</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    indices : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">        Indices to be selected if the parameter has the same size as `X`.</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">    fit_params_validated : dict</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">        Validated parameters. We ensure that the values support indexing.</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1839</span>    <span class="keyword">from</span> . <span class="keyword">import</span> _safe_indexing</div>
<div class="line"><span class="lineno"> 1840</span> </div>
<div class="line"><span class="lineno"> 1841</span>    fit_params_validated = {}</div>
<div class="line"><span class="lineno"> 1842</span>    <span class="keywordflow">for</span> param_key, param_value <span class="keywordflow">in</span> fit_params.items():</div>
<div class="line"><span class="lineno"> 1843</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> _is_arraylike(param_value) <span class="keywordflow">or</span> _num_samples(param_value) != _num_samples(</div>
<div class="line"><span class="lineno"> 1844</span>            X</div>
<div class="line"><span class="lineno"> 1845</span>        ):</div>
<div class="line"><span class="lineno"> 1846</span>            <span class="comment"># Non-indexable pass-through (for now for backward-compatibility).</span></div>
<div class="line"><span class="lineno"> 1847</span>            <span class="comment"># https://github.com/scikit-learn/scikit-learn/issues/15805</span></div>
<div class="line"><span class="lineno"> 1848</span>            fit_params_validated[param_key] = param_value</div>
<div class="line"><span class="lineno"> 1849</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1850</span>            <span class="comment"># Any other fit_params should support indexing</span></div>
<div class="line"><span class="lineno"> 1851</span>            <span class="comment"># (e.g. for cross-validation).</span></div>
<div class="line"><span class="lineno"> 1852</span>            fit_params_validated[param_key] = _make_indexable(param_value)</div>
<div class="line"><span class="lineno"> 1853</span>            fit_params_validated[param_key] = _safe_indexing(</div>
<div class="line"><span class="lineno"> 1854</span>                fit_params_validated[param_key], indices</div>
<div class="line"><span class="lineno"> 1855</span>            )</div>
<div class="line"><span class="lineno"> 1856</span> </div>
<div class="line"><span class="lineno"> 1857</span>    <span class="keywordflow">return</span> fit_params_validated</div>
<div class="line"><span class="lineno"> 1858</span> </div>
<div class="line"><span class="lineno"> 1859</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a66127648643ff52252663b27ccb84278" name="a66127648643ff52252663b27ccb84278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66127648643ff52252663b27ccb84278">&#9670;&#160;</a></span>_check_large_sparse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_large_sparse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accept_large_sparse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Raise a ValueError if X has 64bit indices and accept_large_sparse=False</pre> <div class="fragment"><div class="line"><span class="lineno">  960</span><span class="keyword">def </span>_check_large_sparse(X, accept_large_sparse=False):</div>
<div class="line"><span class="lineno">  961</span>    <span class="stringliteral">&quot;&quot;&quot;Raise a ValueError if X has 64bit indices and accept_large_sparse=False&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  962</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> accept_large_sparse:</div>
<div class="line"><span class="lineno">  963</span>        supported_indices = [<span class="stringliteral">&quot;int32&quot;</span>]</div>
<div class="line"><span class="lineno">  964</span>        <span class="keywordflow">if</span> X.getformat() == <span class="stringliteral">&quot;coo&quot;</span>:</div>
<div class="line"><span class="lineno">  965</span>            index_keys = [<span class="stringliteral">&quot;col&quot;</span>, <span class="stringliteral">&quot;row&quot;</span>]</div>
<div class="line"><span class="lineno">  966</span>        <span class="keywordflow">elif</span> X.getformat() <span class="keywordflow">in</span> [<span class="stringliteral">&quot;csr&quot;</span>, <span class="stringliteral">&quot;csc&quot;</span>, <span class="stringliteral">&quot;bsr&quot;</span>]:</div>
<div class="line"><span class="lineno">  967</span>            index_keys = [<span class="stringliteral">&quot;indices&quot;</span>, <span class="stringliteral">&quot;indptr&quot;</span>]</div>
<div class="line"><span class="lineno">  968</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  969</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  970</span>        <span class="keywordflow">for</span> key <span class="keywordflow">in</span> index_keys:</div>
<div class="line"><span class="lineno">  971</span>            indices_datatype = getattr(X, key).dtype</div>
<div class="line"><span class="lineno">  972</span>            <span class="keywordflow">if</span> indices_datatype <span class="keywordflow">not</span> <span class="keywordflow">in</span> supported_indices:</div>
<div class="line"><span class="lineno">  973</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  974</span>                    <span class="stringliteral">&quot;Only sparse matrices with 32-bit integer&quot;</span></div>
<div class="line"><span class="lineno">  975</span>                    <span class="stringliteral">&quot; indices are accepted. Got %s indices.&quot;</span> % indices_datatype</div>
<div class="line"><span class="lineno">  976</span>                )</div>
<div class="line"><span class="lineno">  977</span> </div>
<div class="line"><span class="lineno">  978</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a47dbace05a46d67eb4eb76c35feaed3e" name="a47dbace05a46d67eb4eb76c35feaed3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dbace05a46d67eb4eb76c35feaed3e">&#9670;&#160;</a></span>_check_monotonic_cst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_monotonic_cst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>monotonic_cst</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check the monotonic constraints and return the corresponding array.

This helper function should be used in the `fit` method of an estimator
that supports monotonic constraints and called after the estimator has
introspected input data to set the `n_features_in_` and optionally the
`feature_names_in_` attributes.

.. versionadded:: 1.2

Parameters
----------
estimator : estimator instance

monotonic_cst : array-like of int, dict of str or None, default=None
    Monotonic constraints for the features.

    - If array-like, then it should contain only -1, 0 or 1. Each value
        will be checked to be in [-1, 0, 1]. If a value is -1, then the
        corresponding feature is required to be monotonically decreasing.
    - If dict, then it the keys should be the feature names occurring in
        `estimator.feature_names_in_` and the values should be -1, 0 or 1.
    - If None, then an array of 0s will be allocated.

Returns
-------
monotonic_cst : ndarray of int
    Monotonic constraints for each feature.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1995</span><span class="keyword">def </span>_check_monotonic_cst(estimator, monotonic_cst=None):</div>
<div class="line"><span class="lineno"> 1996</span>    <span class="stringliteral">&quot;&quot;&quot;Check the monotonic constraints and return the corresponding array.</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">    This helper function should be used in the `fit` method of an estimator</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">    that supports monotonic constraints and called after the estimator has</span></div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral">    introspected input data to set the `n_features_in_` and optionally the</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">    `feature_names_in_` attributes.</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral">    .. versionadded:: 1.2</span></div>
<div class="line"><span class="lineno"> 2004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2005</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2006</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2007</span><span class="stringliteral">    estimator : estimator instance</span></div>
<div class="line"><span class="lineno"> 2008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">    monotonic_cst : array-like of int, dict of str or None, default=None</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral">        Monotonic constraints for the features.</span></div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral">        - If array-like, then it should contain only -1, 0 or 1. Each value</span></div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">            will be checked to be in [-1, 0, 1]. If a value is -1, then the</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral">            corresponding feature is required to be monotonically decreasing.</span></div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">        - If dict, then it the keys should be the feature names occurring in</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral">            `estimator.feature_names_in_` and the values should be -1, 0 or 1.</span></div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral">        - If None, then an array of 0s will be allocated.</span></div>
<div class="line"><span class="lineno"> 2018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2019</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2020</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral">    monotonic_cst : ndarray of int</span></div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">        Monotonic constraints for each feature.</span></div>
<div class="line"><span class="lineno"> 2023</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2024</span>    original_monotonic_cst = monotonic_cst</div>
<div class="line"><span class="lineno"> 2025</span>    <span class="keywordflow">if</span> monotonic_cst <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> isinstance(monotonic_cst, dict):</div>
<div class="line"><span class="lineno"> 2026</span>        monotonic_cst = np.full(</div>
<div class="line"><span class="lineno"> 2027</span>            shape=estimator.n_features_in_,</div>
<div class="line"><span class="lineno"> 2028</span>            fill_value=0,</div>
<div class="line"><span class="lineno"> 2029</span>            dtype=np.int8,</div>
<div class="line"><span class="lineno"> 2030</span>        )</div>
<div class="line"><span class="lineno"> 2031</span>        <span class="keywordflow">if</span> isinstance(original_monotonic_cst, dict):</div>
<div class="line"><span class="lineno"> 2032</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(estimator, <span class="stringliteral">&quot;feature_names_in_&quot;</span>):</div>
<div class="line"><span class="lineno"> 2033</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2034</span>                    f<span class="stringliteral">&quot;{estimator.__class__.__name__} was not fitted on data &quot;</span></div>
<div class="line"><span class="lineno"> 2035</span>                    <span class="stringliteral">&quot;with feature names. Pass monotonic_cst as an integer &quot;</span></div>
<div class="line"><span class="lineno"> 2036</span>                    <span class="stringliteral">&quot;array instead.&quot;</span></div>
<div class="line"><span class="lineno"> 2037</span>                )</div>
<div class="line"><span class="lineno"> 2038</span>            unexpected_feature_names = list(</div>
<div class="line"><span class="lineno"> 2039</span>                set(original_monotonic_cst) - set(estimator.feature_names_in_)</div>
<div class="line"><span class="lineno"> 2040</span>            )</div>
<div class="line"><span class="lineno"> 2041</span>            unexpected_feature_names.sort()  <span class="comment"># deterministic error message</span></div>
<div class="line"><span class="lineno"> 2042</span>            n_unexpeced = len(unexpected_feature_names)</div>
<div class="line"><span class="lineno"> 2043</span>            <span class="keywordflow">if</span> unexpected_feature_names:</div>
<div class="line"><span class="lineno"> 2044</span>                <span class="keywordflow">if</span> len(unexpected_feature_names) &gt; 5:</div>
<div class="line"><span class="lineno"> 2045</span>                    unexpected_feature_names = unexpected_feature_names[:5]</div>
<div class="line"><span class="lineno"> 2046</span>                    unexpected_feature_names.append(<span class="stringliteral">&quot;...&quot;</span>)</div>
<div class="line"><span class="lineno"> 2047</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2048</span>                    f<span class="stringliteral">&quot;monotonic_cst contains {n_unexpeced} unexpected feature &quot;</span></div>
<div class="line"><span class="lineno"> 2049</span>                    f<span class="stringliteral">&quot;names: {unexpected_feature_names}.&quot;</span></div>
<div class="line"><span class="lineno"> 2050</span>                )</div>
<div class="line"><span class="lineno"> 2051</span>            <span class="keywordflow">for</span> feature_idx, feature_name <span class="keywordflow">in</span> enumerate(estimator.feature_names_in_):</div>
<div class="line"><span class="lineno"> 2052</span>                <span class="keywordflow">if</span> feature_name <span class="keywordflow">in</span> original_monotonic_cst:</div>
<div class="line"><span class="lineno"> 2053</span>                    cst = original_monotonic_cst[feature_name]</div>
<div class="line"><span class="lineno"> 2054</span>                    <span class="keywordflow">if</span> cst <span class="keywordflow">not</span> <span class="keywordflow">in</span> [-1, 0, 1]:</div>
<div class="line"><span class="lineno"> 2055</span>                        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2056</span>                            f<span class="stringliteral">&quot;monotonic_cst[&#39;{feature_name}&#39;] must be either &quot;</span></div>
<div class="line"><span class="lineno"> 2057</span>                            f<span class="stringliteral">&quot;-1, 0 or 1. Got {cst!r}.&quot;</span></div>
<div class="line"><span class="lineno"> 2058</span>                        )</div>
<div class="line"><span class="lineno"> 2059</span>                    monotonic_cst[feature_idx] = cst</div>
<div class="line"><span class="lineno"> 2060</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2061</span>        unexpected_cst = np.setdiff1d(monotonic_cst, [-1, 0, 1])</div>
<div class="line"><span class="lineno"> 2062</span>        <span class="keywordflow">if</span> unexpected_cst.shape[0]:</div>
<div class="line"><span class="lineno"> 2063</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2064</span>                <span class="stringliteral">&quot;monotonic_cst must be an array-like of -1, 0 or 1. Observed &quot;</span></div>
<div class="line"><span class="lineno"> 2065</span>                f<span class="stringliteral">&quot;values: {unexpected_cst.tolist()}.&quot;</span></div>
<div class="line"><span class="lineno"> 2066</span>            )</div>
<div class="line"><span class="lineno"> 2067</span> </div>
<div class="line"><span class="lineno"> 2068</span>        monotonic_cst = np.asarray(monotonic_cst, dtype=np.int8)</div>
<div class="line"><span class="lineno"> 2069</span>        <span class="keywordflow">if</span> monotonic_cst.shape[0] != estimator.n_features_in_:</div>
<div class="line"><span class="lineno"> 2070</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2071</span>                f<span class="stringliteral">&quot;monotonic_cst has shape {monotonic_cst.shape} but the input data &quot;</span></div>
<div class="line"><span class="lineno"> 2072</span>                f<span class="stringliteral">&quot;X has {estimator.n_features_in_} features.&quot;</span></div>
<div class="line"><span class="lineno"> 2073</span>            )</div>
<div class="line"><span class="lineno"> 2074</span>    <span class="keywordflow">return</span> monotonic_cst</div>
</div><!-- fragment -->
</div>
</div>
<a id="addb9557cb2e17288962287ce3c50e4d1" name="addb9557cb2e17288962287ce3c50e4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb9557cb2e17288962287ce3c50e4d1">&#9670;&#160;</a></span>_check_psd_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_psd_eigenvalues </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lambdas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enable_warnings</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check the eigenvalues of a positive semidefinite (PSD) matrix.

Checks the provided array of PSD matrix eigenvalues for numerical or
conditioning issues and returns a fixed validated version. This method
should typically be used if the PSD matrix is user-provided (e.g. a
Gram matrix) or computed using a user-provided dissimilarity metric
(e.g. kernel function), or if the decomposition process uses approximation
methods (randomized SVD, etc.).

It checks for three things:

- that there are no significant imaginary parts in eigenvalues (more than
  1e-5 times the maximum real part). If this check fails, it raises a
  ``ValueError``. Otherwise all non-significant imaginary parts that may
  remain are set to zero. This operation is traced with a
  ``PositiveSpectrumWarning`` when ``enable_warnings=True``.

- that eigenvalues are not all negative. If this check fails, it raises a
  ``ValueError``

- that there are no significant negative eigenvalues with absolute value
  more than 1e-10 (1e-6) and more than 1e-5 (5e-3) times the largest
  positive eigenvalue in double (simple) precision. If this check fails,
  it raises a ``ValueError``. Otherwise all negative eigenvalues that may
  remain are set to zero. This operation is traced with a
  ``PositiveSpectrumWarning`` when ``enable_warnings=True``.

Finally, all the positive eigenvalues that are too small (with a value
smaller than the maximum eigenvalue multiplied by 1e-12 (2e-7)) are set to
zero. This operation is traced with a ``PositiveSpectrumWarning`` when
``enable_warnings=True``.

Parameters
----------
lambdas : array-like of shape (n_eigenvalues,)
    Array of eigenvalues to check / fix.

enable_warnings : bool, default=False
    When this is set to ``True``, a ``PositiveSpectrumWarning`` will be
    raised when there are imaginary parts, negative eigenvalues, or
    extremely small non-zero eigenvalues. Otherwise no warning will be
    raised. In both cases, imaginary parts, negative eigenvalues, and
    extremely small non-zero eigenvalues will be set to zero.

Returns
-------
lambdas_fixed : ndarray of shape (n_eigenvalues,)
    A fixed validated copy of the array of eigenvalues.

Examples
--------
&gt;&gt;&gt; from sklearn.utils.validation import _check_psd_eigenvalues
&gt;&gt;&gt; _check_psd_eigenvalues([1, 2])      # nominal case
array([1, 2])
&gt;&gt;&gt; _check_psd_eigenvalues([5, 5j])     # significant imag part
Traceback (most recent call last):
    ...
ValueError: There are significant imaginary parts in eigenvalues (1
    of the maximum real part). Either the matrix is not PSD, or there was
    an issue while computing the eigendecomposition of the matrix.
&gt;&gt;&gt; _check_psd_eigenvalues([5, 5e-5j])  # insignificant imag part
array([5., 0.])
&gt;&gt;&gt; _check_psd_eigenvalues([-5, -1])    # all negative
Traceback (most recent call last):
    ...
ValueError: All eigenvalues are negative (maximum is -1). Either the
    matrix is not PSD, or there was an issue while computing the
    eigendecomposition of the matrix.
&gt;&gt;&gt; _check_psd_eigenvalues([5, -1])     # significant negative
Traceback (most recent call last):
    ...
ValueError: There are significant negative eigenvalues (0.2 of the
    maximum positive). Either the matrix is not PSD, or there was an issue
    while computing the eigendecomposition of the matrix.
&gt;&gt;&gt; _check_psd_eigenvalues([5, -5e-5])  # insignificant negative
array([5., 0.])
&gt;&gt;&gt; _check_psd_eigenvalues([5, 4e-12])  # bad conditioning (too small)
array([5., 0.])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1533</span><span class="keyword">def </span>_check_psd_eigenvalues(lambdas, enable_warnings=False):</div>
<div class="line"><span class="lineno"> 1534</span>    <span class="stringliteral">&quot;&quot;&quot;Check the eigenvalues of a positive semidefinite (PSD) matrix.</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">    Checks the provided array of PSD matrix eigenvalues for numerical or</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    conditioning issues and returns a fixed validated version. This method</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    should typically be used if the PSD matrix is user-provided (e.g. a</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">    Gram matrix) or computed using a user-provided dissimilarity metric</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    (e.g. kernel function), or if the decomposition process uses approximation</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    methods (randomized SVD, etc.).</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    It checks for three things:</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    - that there are no significant imaginary parts in eigenvalues (more than</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">      1e-5 times the maximum real part). If this check fails, it raises a</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">      ``ValueError``. Otherwise all non-significant imaginary parts that may</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">      remain are set to zero. This operation is traced with a</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">      ``PositiveSpectrumWarning`` when ``enable_warnings=True``.</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    - that eigenvalues are not all negative. If this check fails, it raises a</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">      ``ValueError``</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    - that there are no significant negative eigenvalues with absolute value</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">      more than 1e-10 (1e-6) and more than 1e-5 (5e-3) times the largest</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">      positive eigenvalue in double (simple) precision. If this check fails,</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">      it raises a ``ValueError``. Otherwise all negative eigenvalues that may</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">      remain are set to zero. This operation is traced with a</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">      ``PositiveSpectrumWarning`` when ``enable_warnings=True``.</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    Finally, all the positive eigenvalues that are too small (with a value</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">    smaller than the maximum eigenvalue multiplied by 1e-12 (2e-7)) are set to</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    zero. This operation is traced with a ``PositiveSpectrumWarning`` when</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">    ``enable_warnings=True``.</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral">    lambdas : array-like of shape (n_eigenvalues,)</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">        Array of eigenvalues to check / fix.</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">    enable_warnings : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">        When this is set to ``True``, a ``PositiveSpectrumWarning`` will be</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral">        raised when there are imaginary parts, negative eigenvalues, or</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">        extremely small non-zero eigenvalues. Otherwise no warning will be</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">        raised. In both cases, imaginary parts, negative eigenvalues, and</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">        extremely small non-zero eigenvalues will be set to zero.</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">    lambdas_fixed : ndarray of shape (n_eigenvalues,)</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">        A fixed validated copy of the array of eigenvalues.</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.utils.validation import _check_psd_eigenvalues</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">    &gt;&gt;&gt; _check_psd_eigenvalues([1, 2])      # nominal case</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    array([1, 2])</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    &gt;&gt;&gt; _check_psd_eigenvalues([5, 5j])     # significant imag part</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    ValueError: There are significant imaginary parts in eigenvalues (1</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">        of the maximum real part). Either the matrix is not PSD, or there was</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">        an issue while computing the eigendecomposition of the matrix.</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    &gt;&gt;&gt; _check_psd_eigenvalues([5, 5e-5j])  # insignificant imag part</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    array([5., 0.])</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    &gt;&gt;&gt; _check_psd_eigenvalues([-5, -1])    # all negative</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    ValueError: All eigenvalues are negative (maximum is -1). Either the</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        matrix is not PSD, or there was an issue while computing the</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">        eigendecomposition of the matrix.</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    &gt;&gt;&gt; _check_psd_eigenvalues([5, -1])     # significant negative</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">    ValueError: There are significant negative eigenvalues (0.2 of the</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">        maximum positive). Either the matrix is not PSD, or there was an issue</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">        while computing the eigendecomposition of the matrix.</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    &gt;&gt;&gt; _check_psd_eigenvalues([5, -5e-5])  # insignificant negative</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">    array([5., 0.])</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">    &gt;&gt;&gt; _check_psd_eigenvalues([5, 4e-12])  # bad conditioning (too small)</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">    array([5., 0.])</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1614</span> </div>
<div class="line"><span class="lineno"> 1615</span>    lambdas = np.array(lambdas)</div>
<div class="line"><span class="lineno"> 1616</span>    is_double_precision = lambdas.dtype == np.float64</div>
<div class="line"><span class="lineno"> 1617</span> </div>
<div class="line"><span class="lineno"> 1618</span>    <span class="comment"># note: the minimum value available is</span></div>
<div class="line"><span class="lineno"> 1619</span>    <span class="comment">#  - single-precision: np.finfo(&#39;float32&#39;).eps = 1.2e-07</span></div>
<div class="line"><span class="lineno"> 1620</span>    <span class="comment">#  - double-precision: np.finfo(&#39;float64&#39;).eps = 2.2e-16</span></div>
<div class="line"><span class="lineno"> 1621</span> </div>
<div class="line"><span class="lineno"> 1622</span>    <span class="comment"># the various thresholds used for validation</span></div>
<div class="line"><span class="lineno"> 1623</span>    <span class="comment"># we may wish to change the value according to precision.</span></div>
<div class="line"><span class="lineno"> 1624</span>    significant_imag_ratio = 1e-5</div>
<div class="line"><span class="lineno"> 1625</span>    significant_neg_ratio = 1e-5 <span class="keywordflow">if</span> is_double_precision <span class="keywordflow">else</span> 5e-3</div>
<div class="line"><span class="lineno"> 1626</span>    significant_neg_value = 1e-10 <span class="keywordflow">if</span> is_double_precision <span class="keywordflow">else</span> 1e-6</div>
<div class="line"><span class="lineno"> 1627</span>    small_pos_ratio = 1e-12 <span class="keywordflow">if</span> is_double_precision <span class="keywordflow">else</span> 2e-7</div>
<div class="line"><span class="lineno"> 1628</span> </div>
<div class="line"><span class="lineno"> 1629</span>    <span class="comment"># Check that there are no significant imaginary parts</span></div>
<div class="line"><span class="lineno"> 1630</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isreal(lambdas).all():</div>
<div class="line"><span class="lineno"> 1631</span>        max_imag_abs = np.abs(np.imag(lambdas)).max()</div>
<div class="line"><span class="lineno"> 1632</span>        max_real_abs = np.abs(np.real(lambdas)).max()</div>
<div class="line"><span class="lineno"> 1633</span>        <span class="keywordflow">if</span> max_imag_abs &gt; significant_imag_ratio * max_real_abs:</div>
<div class="line"><span class="lineno"> 1634</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1635</span>                <span class="stringliteral">&quot;There are significant imaginary parts in eigenvalues (%g &quot;</span></div>
<div class="line"><span class="lineno"> 1636</span>                <span class="stringliteral">&quot;of the maximum real part). Either the matrix is not PSD, or &quot;</span></div>
<div class="line"><span class="lineno"> 1637</span>                <span class="stringliteral">&quot;there was an issue while computing the eigendecomposition &quot;</span></div>
<div class="line"><span class="lineno"> 1638</span>                <span class="stringliteral">&quot;of the matrix.&quot;</span> % (max_imag_abs / max_real_abs)</div>
<div class="line"><span class="lineno"> 1639</span>            )</div>
<div class="line"><span class="lineno"> 1640</span> </div>
<div class="line"><span class="lineno"> 1641</span>        <span class="comment"># warn about imaginary parts being removed</span></div>
<div class="line"><span class="lineno"> 1642</span>        <span class="keywordflow">if</span> enable_warnings:</div>
<div class="line"><span class="lineno"> 1643</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1644</span>                <span class="stringliteral">&quot;There are imaginary parts in eigenvalues (%g &quot;</span></div>
<div class="line"><span class="lineno"> 1645</span>                <span class="stringliteral">&quot;of the maximum real part). Either the matrix is not&quot;</span></div>
<div class="line"><span class="lineno"> 1646</span>                <span class="stringliteral">&quot; PSD, or there was an issue while computing the &quot;</span></div>
<div class="line"><span class="lineno"> 1647</span>                <span class="stringliteral">&quot;eigendecomposition of the matrix. Only the real &quot;</span></div>
<div class="line"><span class="lineno"> 1648</span>                <span class="stringliteral">&quot;parts will be kept.&quot;</span> % (max_imag_abs / max_real_abs),</div>
<div class="line"><span class="lineno"> 1649</span>                PositiveSpectrumWarning,</div>
<div class="line"><span class="lineno"> 1650</span>            )</div>
<div class="line"><span class="lineno"> 1651</span> </div>
<div class="line"><span class="lineno"> 1652</span>    <span class="comment"># Remove all imaginary parts (even if zero)</span></div>
<div class="line"><span class="lineno"> 1653</span>    lambdas = np.real(lambdas)</div>
<div class="line"><span class="lineno"> 1654</span> </div>
<div class="line"><span class="lineno"> 1655</span>    <span class="comment"># Check that there are no significant negative eigenvalues</span></div>
<div class="line"><span class="lineno"> 1656</span>    max_eig = lambdas.max()</div>
<div class="line"><span class="lineno"> 1657</span>    <span class="keywordflow">if</span> max_eig &lt; 0:</div>
<div class="line"><span class="lineno"> 1658</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1659</span>            <span class="stringliteral">&quot;All eigenvalues are negative (maximum is %g). &quot;</span></div>
<div class="line"><span class="lineno"> 1660</span>            <span class="stringliteral">&quot;Either the matrix is not PSD, or there was an &quot;</span></div>
<div class="line"><span class="lineno"> 1661</span>            <span class="stringliteral">&quot;issue while computing the eigendecomposition of &quot;</span></div>
<div class="line"><span class="lineno"> 1662</span>            <span class="stringliteral">&quot;the matrix.&quot;</span> % max_eig</div>
<div class="line"><span class="lineno"> 1663</span>        )</div>
<div class="line"><span class="lineno"> 1664</span> </div>
<div class="line"><span class="lineno"> 1665</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1666</span>        min_eig = lambdas.min()</div>
<div class="line"><span class="lineno"> 1667</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1668</span>            min_eig &lt; -significant_neg_ratio * max_eig</div>
<div class="line"><span class="lineno"> 1669</span>            <span class="keywordflow">and</span> min_eig &lt; -significant_neg_value</div>
<div class="line"><span class="lineno"> 1670</span>        ):</div>
<div class="line"><span class="lineno"> 1671</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1672</span>                <span class="stringliteral">&quot;There are significant negative eigenvalues (%g&quot;</span></div>
<div class="line"><span class="lineno"> 1673</span>                <span class="stringliteral">&quot; of the maximum positive). Either the matrix is &quot;</span></div>
<div class="line"><span class="lineno"> 1674</span>                <span class="stringliteral">&quot;not PSD, or there was an issue while computing &quot;</span></div>
<div class="line"><span class="lineno"> 1675</span>                <span class="stringliteral">&quot;the eigendecomposition of the matrix.&quot;</span> % (-min_eig / max_eig)</div>
<div class="line"><span class="lineno"> 1676</span>            )</div>
<div class="line"><span class="lineno"> 1677</span>        <span class="keywordflow">elif</span> min_eig &lt; 0:</div>
<div class="line"><span class="lineno"> 1678</span>            <span class="comment"># Remove all negative values and warn about it</span></div>
<div class="line"><span class="lineno"> 1679</span>            <span class="keywordflow">if</span> enable_warnings:</div>
<div class="line"><span class="lineno"> 1680</span>                warnings.warn(</div>
<div class="line"><span class="lineno"> 1681</span>                    <span class="stringliteral">&quot;There are negative eigenvalues (%g of the &quot;</span></div>
<div class="line"><span class="lineno"> 1682</span>                    <span class="stringliteral">&quot;maximum positive). Either the matrix is not &quot;</span></div>
<div class="line"><span class="lineno"> 1683</span>                    <span class="stringliteral">&quot;PSD, or there was an issue while computing the&quot;</span></div>
<div class="line"><span class="lineno"> 1684</span>                    <span class="stringliteral">&quot; eigendecomposition of the matrix. Negative &quot;</span></div>
<div class="line"><span class="lineno"> 1685</span>                    <span class="stringliteral">&quot;eigenvalues will be replaced with 0.&quot;</span> % (-min_eig / max_eig),</div>
<div class="line"><span class="lineno"> 1686</span>                    PositiveSpectrumWarning,</div>
<div class="line"><span class="lineno"> 1687</span>                )</div>
<div class="line"><span class="lineno"> 1688</span>            lambdas[lambdas &lt; 0] = 0</div>
<div class="line"><span class="lineno"> 1689</span> </div>
<div class="line"><span class="lineno"> 1690</span>    <span class="comment"># Check for conditioning (small positive non-zeros)</span></div>
<div class="line"><span class="lineno"> 1691</span>    too_small_lambdas = (0 &lt; lambdas) &amp; (lambdas &lt; small_pos_ratio * max_eig)</div>
<div class="line"><span class="lineno"> 1692</span>    <span class="keywordflow">if</span> too_small_lambdas.any():</div>
<div class="line"><span class="lineno"> 1693</span>        <span class="keywordflow">if</span> enable_warnings:</div>
<div class="line"><span class="lineno"> 1694</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1695</span>                <span class="stringliteral">&quot;Badly conditioned PSD matrix spectrum: the largest &quot;</span></div>
<div class="line"><span class="lineno"> 1696</span>                <span class="stringliteral">&quot;eigenvalue is more than %g times the smallest. &quot;</span></div>
<div class="line"><span class="lineno"> 1697</span>                <span class="stringliteral">&quot;Small eigenvalues will be replaced with 0.&quot;</span></div>
<div class="line"><span class="lineno"> 1698</span>                <span class="stringliteral">&quot;&quot;</span> % (1 / small_pos_ratio),</div>
<div class="line"><span class="lineno"> 1699</span>                PositiveSpectrumWarning,</div>
<div class="line"><span class="lineno"> 1700</span>            )</div>
<div class="line"><span class="lineno"> 1701</span>        lambdas[too_small_lambdas] = 0</div>
<div class="line"><span class="lineno"> 1702</span> </div>
<div class="line"><span class="lineno"> 1703</span>    <span class="keywordflow">return</span> lambdas</div>
<div class="line"><span class="lineno"> 1704</span> </div>
<div class="line"><span class="lineno"> 1705</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5956ce2fcf59f3b8bb1700de1bf15fdf" name="a5956ce2fcf59f3b8bb1700de1bf15fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5956ce2fcf59f3b8bb1700de1bf15fdf">&#9670;&#160;</a></span>_check_sample_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_sample_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>only_non_negative</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validate sample weights.

Note that passing sample_weight=None will output an array of ones.
Therefore, in some cases, you may want to protect the call with:
if sample_weight is not None:
    sample_weight = _check_sample_weight(...)

Parameters
----------
sample_weight : {ndarray, Number or None}, shape (n_samples,)
    Input sample weights.

X : {ndarray, list, sparse matrix}
    Input data.

only_non_negative : bool, default=False,
    Whether or not the weights are expected to be non-negative.

    .. versionadded:: 1.0

dtype : dtype, default=None
    dtype of the validated `sample_weight`.
    If None, and the input `sample_weight` is an array, the dtype of the
    input is preserved; otherwise an array with the default numpy dtype
    is be allocated.  If `dtype` is not one of `float32`, `float64`,
    `None`, the output will be of dtype `float64`.

copy : bool, default=False
    If True, a copy of sample_weight will be created.

Returns
-------
sample_weight : ndarray of shape (n_samples,)
    Validated sample weight. It is guaranteed to be "C" contiguous.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1708</span>):</div>
<div class="line"><span class="lineno"> 1709</span>    <span class="stringliteral">&quot;&quot;&quot;Validate sample weights.</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">    Note that passing sample_weight=None will output an array of ones.</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">    Therefore, in some cases, you may want to protect the call with:</span></div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">    if sample_weight is not None:</span></div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral">        sample_weight = _check_sample_weight(...)</span></div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    sample_weight : {ndarray, Number or None}, shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">        Input sample weights.</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">    X : {ndarray, list, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">    only_non_negative : bool, default=False,</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral">        Whether or not the weights are expected to be non-negative.</span></div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">        .. versionadded:: 1.0</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">    dtype : dtype, default=None</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">        dtype of the validated `sample_weight`.</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">        If None, and the input `sample_weight` is an array, the dtype of the</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral">        input is preserved; otherwise an array with the default numpy dtype</span></div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">        is be allocated.  If `dtype` is not one of `float32`, `float64`,</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">        `None`, the output will be of dtype `float64`.</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral">    copy : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral">        If True, a copy of sample_weight will be created.</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">    sample_weight : ndarray of shape (n_samples,)</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">        Validated sample weight. It is guaranteed to be &quot;C&quot; contiguous.</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1744</span>    n_samples = _num_samples(X)</div>
<div class="line"><span class="lineno"> 1745</span> </div>
<div class="line"><span class="lineno"> 1746</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> dtype <span class="keywordflow">not</span> <span class="keywordflow">in</span> [np.float32, np.float64]:</div>
<div class="line"><span class="lineno"> 1747</span>        dtype = np.float64</div>
<div class="line"><span class="lineno"> 1748</span> </div>
<div class="line"><span class="lineno"> 1749</span>    <span class="keywordflow">if</span> sample_weight <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1750</span>        sample_weight = np.ones(n_samples, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1751</span>    <span class="keywordflow">elif</span> isinstance(sample_weight, numbers.Number):</div>
<div class="line"><span class="lineno"> 1752</span>        sample_weight = np.full(n_samples, sample_weight, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1753</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1754</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1755</span>            dtype = [np.float64, np.float32]</div>
<div class="line"><span class="lineno"> 1756</span>        sample_weight = check_array(</div>
<div class="line"><span class="lineno"> 1757</span>            sample_weight,</div>
<div class="line"><span class="lineno"> 1758</span>            accept_sparse=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1759</span>            ensure_2d=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1760</span>            dtype=dtype,</div>
<div class="line"><span class="lineno"> 1761</span>            order=<span class="stringliteral">&quot;C&quot;</span>,</div>
<div class="line"><span class="lineno"> 1762</span>            copy=copy,</div>
<div class="line"><span class="lineno"> 1763</span>            input_name=<span class="stringliteral">&quot;sample_weight&quot;</span>,</div>
<div class="line"><span class="lineno"> 1764</span>        )</div>
<div class="line"><span class="lineno"> 1765</span>        <span class="keywordflow">if</span> sample_weight.ndim != 1:</div>
<div class="line"><span class="lineno"> 1766</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Sample weights must be 1D array or scalar&quot;</span>)</div>
<div class="line"><span class="lineno"> 1767</span> </div>
<div class="line"><span class="lineno"> 1768</span>        <span class="keywordflow">if</span> sample_weight.shape != (n_samples,):</div>
<div class="line"><span class="lineno"> 1769</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1770</span>                <span class="stringliteral">&quot;sample_weight.shape == {}, expected {}!&quot;</span>.format(</div>
<div class="line"><span class="lineno"> 1771</span>                    sample_weight.shape, (n_samples,)</div>
<div class="line"><span class="lineno"> 1772</span>                )</div>
<div class="line"><span class="lineno"> 1773</span>            )</div>
<div class="line"><span class="lineno"> 1774</span> </div>
<div class="line"><span class="lineno"> 1775</span>    <span class="keywordflow">if</span> only_non_negative:</div>
<div class="line"><span class="lineno"> 1776</span>        check_non_negative(sample_weight, <span class="stringliteral">&quot;`sample_weight`&quot;</span>)</div>
<div class="line"><span class="lineno"> 1777</span> </div>
<div class="line"><span class="lineno"> 1778</span>    <span class="keywordflow">return</span> sample_weight</div>
<div class="line"><span class="lineno"> 1779</span> </div>
<div class="line"><span class="lineno"> 1780</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a72d745f985dadefe1bf3a15fb67d5243" name="a72d745f985dadefe1bf3a15fb67d5243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d745f985dadefe1bf3a15fb67d5243">&#9670;&#160;</a></span>_check_y()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._check_y </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multi_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y_numeric</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Isolated part of check_X_y dedicated to y validation</pre> <div class="fragment"><div class="line"><span class="lineno"> 1127</span><span class="keyword">def </span>_check_y(y, multi_output=False, y_numeric=False, estimator=None):</div>
<div class="line"><span class="lineno"> 1128</span>    <span class="stringliteral">&quot;&quot;&quot;Isolated part of check_X_y dedicated to y validation&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1129</span>    <span class="keywordflow">if</span> multi_output:</div>
<div class="line"><span class="lineno"> 1130</span>        y = check_array(</div>
<div class="line"><span class="lineno"> 1131</span>            y,</div>
<div class="line"><span class="lineno"> 1132</span>            accept_sparse=<span class="stringliteral">&quot;csr&quot;</span>,</div>
<div class="line"><span class="lineno"> 1133</span>            force_all_finite=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 1134</span>            ensure_2d=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1135</span>            dtype=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno"> 1136</span>            input_name=<span class="stringliteral">&quot;y&quot;</span>,</div>
<div class="line"><span class="lineno"> 1137</span>            estimator=estimator,</div>
<div class="line"><span class="lineno"> 1138</span>        )</div>
<div class="line"><span class="lineno"> 1139</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1140</span>        estimator_name = _check_estimator_name(estimator)</div>
<div class="line"><span class="lineno"> 1141</span>        y = column_or_1d(y, warn=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1142</span>        _assert_all_finite(y, input_name=<span class="stringliteral">&quot;y&quot;</span>, estimator_name=estimator_name)</div>
<div class="line"><span class="lineno"> 1143</span>        _ensure_no_complex_data(y)</div>
<div class="line"><span class="lineno"> 1144</span>    <span class="keywordflow">if</span> y_numeric <span class="keywordflow">and</span> y.dtype.kind == <span class="stringliteral">&quot;O&quot;</span>:</div>
<div class="line"><span class="lineno"> 1145</span>        y = y.astype(np.float64)</div>
<div class="line"><span class="lineno"> 1146</span> </div>
<div class="line"><span class="lineno"> 1147</span>    <span class="keywordflow">return</span> y</div>
<div class="line"><span class="lineno"> 1148</span> </div>
<div class="line"><span class="lineno"> 1149</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b491e58cfa1ea6b9eddbd05581afdd5" name="a0b491e58cfa1ea6b9eddbd05581afdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b491e58cfa1ea6b9eddbd05581afdd5">&#9670;&#160;</a></span>_deprecate_positional_args()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._deprecate_positional_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>version</em> = <code>&quot;1.3&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Decorator for methods that issues warnings for positional arguments.

Using the keyword-only argument syntax in pep 3102, arguments after the
* will issue a warning when passed as a positional argument.

Parameters
----------
func : callable, default=None
    Function to check arguments on.
version : callable, default="1.3"
    The version when positional arguments will result in error.
</pre> <div class="fragment"><div class="line"><span class="lineno">   42</span><span class="keyword">def </span>_deprecate_positional_args(func=None, *, version=&quot;1.3&quot;):</div>
<div class="line"><span class="lineno">   43</span>    <span class="stringliteral">&quot;&quot;&quot;Decorator for methods that issues warnings for positional arguments.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    Using the keyword-only argument syntax in pep 3102, arguments after the</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    * will issue a warning when passed as a positional argument.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    func : callable, default=None</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        Function to check arguments on.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    version : callable, default=&quot;1.3&quot;</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        The version when positional arguments will result in error.</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   55</span> </div>
<div class="line"><span class="lineno">   56</span>    <span class="keyword">def </span>_inner_deprecate_positional_args(f):</div>
<div class="line"><span class="lineno">   57</span>        sig = signature(f)</div>
<div class="line"><span class="lineno">   58</span>        kwonly_args = []</div>
<div class="line"><span class="lineno">   59</span>        all_args = []</div>
<div class="line"><span class="lineno">   60</span> </div>
<div class="line"><span class="lineno">   61</span>        <span class="keywordflow">for</span> name, param <span class="keywordflow">in</span> sig.parameters.items():</div>
<div class="line"><span class="lineno">   62</span>            <span class="keywordflow">if</span> param.kind == Parameter.POSITIONAL_OR_KEYWORD:</div>
<div class="line"><span class="lineno">   63</span>                all_args.append(name)</div>
<div class="line"><span class="lineno">   64</span>            <span class="keywordflow">elif</span> param.kind == Parameter.KEYWORD_ONLY:</div>
<div class="line"><span class="lineno">   65</span>                kwonly_args.append(name)</div>
<div class="line"><span class="lineno">   66</span> </div>
<div class="line"><span class="lineno">   67</span>        <span class="preprocessor">@wraps(f)</span></div>
<div class="line"><span class="lineno">   68</span>        <span class="keyword">def </span>inner_f(*args, **kwargs):</div>
<div class="line"><span class="lineno">   69</span>            extra_args = len(args) - len(all_args)</div>
<div class="line"><span class="lineno">   70</span>            <span class="keywordflow">if</span> extra_args &lt;= 0:</div>
<div class="line"><span class="lineno">   71</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(*args, **kwargs)</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>            <span class="comment"># extra_args &gt; 0</span></div>
<div class="line"><span class="lineno">   74</span>            args_msg = [</div>
<div class="line"><span class="lineno">   75</span>                <span class="stringliteral">&quot;{}={}&quot;</span>.format(name, arg)</div>
<div class="line"><span class="lineno">   76</span>                <span class="keywordflow">for</span> name, arg <span class="keywordflow">in</span> zip(kwonly_args[:extra_args], args[-extra_args:])</div>
<div class="line"><span class="lineno">   77</span>            ]</div>
<div class="line"><span class="lineno">   78</span>            args_msg = <span class="stringliteral">&quot;, &quot;</span>.join(args_msg)</div>
<div class="line"><span class="lineno">   79</span>            warnings.warn(</div>
<div class="line"><span class="lineno">   80</span>                f<span class="stringliteral">&quot;Pass {args_msg} as keyword args. From version &quot;</span></div>
<div class="line"><span class="lineno">   81</span>                f<span class="stringliteral">&quot;{version} passing these as positional arguments &quot;</span></div>
<div class="line"><span class="lineno">   82</span>                <span class="stringliteral">&quot;will result in an error&quot;</span>,</div>
<div class="line"><span class="lineno">   83</span>                FutureWarning,</div>
<div class="line"><span class="lineno">   84</span>            )</div>
<div class="line"><span class="lineno">   85</span>            kwargs.update(zip(sig.parameters, args))</div>
<div class="line"><span class="lineno">   86</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(**kwargs)</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>        <span class="keywordflow">return</span> inner_f</div>
<div class="line"><span class="lineno">   89</span> </div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">if</span> func <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   91</span>        <span class="keywordflow">return</span> _inner_deprecate_positional_args(func)</div>
<div class="line"><span class="lineno">   92</span> </div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">return</span> _inner_deprecate_positional_args</div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_af01a903df7bdb7a494f5827e45bf3a2a"><div class="ttname"><a href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a></div><div class="ttdeci">void int int int int npy_complex64 int int npy_complex64 float float npy_complex64 npy_complex64 * f</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:262</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa634741aed9f3b17aad8a66b5577ec85" name="aa634741aed9f3b17aad8a66b5577ec85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa634741aed9f3b17aad8a66b5577ec85">&#9670;&#160;</a></span>_ensure_no_complex_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._ensure_no_complex_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  571</span><span class="keyword">def </span>_ensure_no_complex_data(array):</div>
<div class="line"><span class="lineno">  572</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  573</span>        hasattr(array, <span class="stringliteral">&quot;dtype&quot;</span>)</div>
<div class="line"><span class="lineno">  574</span>        <span class="keywordflow">and</span> array.dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  575</span>        <span class="keywordflow">and</span> hasattr(array.dtype, <span class="stringliteral">&quot;kind&quot;</span>)</div>
<div class="line"><span class="lineno">  576</span>        <span class="keywordflow">and</span> array.dtype.kind == <span class="stringliteral">&quot;c&quot;</span></div>
<div class="line"><span class="lineno">  577</span>    ):</div>
<div class="line"><span class="lineno">  578</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Complex data not supported\n{}\n&quot;</span>.format(array))</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d375a2f8881aa24b3db8cbf7647aa90" name="a5d375a2f8881aa24b3db8cbf7647aa90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d375a2f8881aa24b3db8cbf7647aa90">&#9670;&#160;</a></span>_ensure_sparse_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._ensure_sparse_format </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>spmatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accept_sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_all_finite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accept_large_sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a sparse matrix to a given format.

Checks the sparse format of spmatrix and converts if necessary.

Parameters
----------
spmatrix : sparse matrix
    Input to validate and convert.

accept_sparse : str, bool or list/tuple of str
    String[s] representing allowed sparse matrix formats ('csc',
    'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'). If the input is sparse but
    not in the allowed format, it will be converted to the first listed
    format. True allows the input to be any format. False means
    that a sparse matrix input will raise an error.

dtype : str, type or None
    Data type of result. If None, the dtype of the input is preserved.

copy : bool
    Whether a forced copy will be triggered. If copy=False, a copy might
    be triggered by a conversion.

force_all_finite : bool or 'allow-nan'
    Whether to raise an error on np.inf, np.nan, pd.NA in X. The
    possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 0.20
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`


estimator_name : str, default=None
    The estimator name, used to construct the error message.

input_name : str, default=""
    The data name used to construct the error message. In particular
    if `input_name` is "X" and the data has NaN values and
    allow_nan is False, the error message will link to the imputer
    documentation.

Returns
-------
spmatrix_converted : sparse matrix.
    Matrix that is ensured to have an allowed type.
</pre> <div class="fragment"><div class="line"><span class="lineno">  456</span>):</div>
<div class="line"><span class="lineno">  457</span>    <span class="stringliteral">&quot;&quot;&quot;Convert a sparse matrix to a given format.</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    Checks the sparse format of spmatrix and converts if necessary.</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    spmatrix : sparse matrix</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        Input to validate and convert.</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    accept_sparse : str, bool or list/tuple of str</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        String[s] representing allowed sparse matrix formats (&#39;csc&#39;,</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        &#39;csr&#39;, &#39;coo&#39;, &#39;dok&#39;, &#39;bsr&#39;, &#39;lil&#39;, &#39;dia&#39;). If the input is sparse but</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        not in the allowed format, it will be converted to the first listed</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        format. True allows the input to be any format. False means</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">        that a sparse matrix input will raise an error.</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    dtype : str, type or None</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        Data type of result. If None, the dtype of the input is preserved.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    copy : bool</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        Whether a forced copy will be triggered. If copy=False, a copy might</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        be triggered by a conversion.</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    force_all_finite : bool or &#39;allow-nan&#39;</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        Whether to raise an error on np.inf, np.nan, pd.NA in X. The</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        possibilities are:</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        - True: Force all values of X to be finite.</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        - False: accepts np.inf, np.nan, pd.NA in X.</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        - &#39;allow-nan&#39;: accepts only np.nan and pd.NA values in X. Values cannot</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">          be infinite.</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">           ``force_all_finite`` accepts the string ``&#39;allow-nan&#39;``.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">        .. versionchanged:: 0.23</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">           Accepts `pd.NA` and converts it into `np.nan`</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    estimator_name : str, default=None</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">        The estimator name, used to construct the error message.</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    input_name : str, default=&quot;&quot;</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        The data name used to construct the error message. In particular</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        if `input_name` is &quot;X&quot; and the data has NaN values and</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        allow_nan is False, the error message will link to the imputer</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        documentation.</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    spmatrix_converted : sparse matrix.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        Matrix that is ensured to have an allowed type.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  510</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  511</span>        dtype = spmatrix.dtype</div>
<div class="line"><span class="lineno">  512</span> </div>
<div class="line"><span class="lineno">  513</span>    changed_format = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  514</span> </div>
<div class="line"><span class="lineno">  515</span>    <span class="keywordflow">if</span> isinstance(accept_sparse, str):</div>
<div class="line"><span class="lineno">  516</span>        accept_sparse = [accept_sparse]</div>
<div class="line"><span class="lineno">  517</span> </div>
<div class="line"><span class="lineno">  518</span>    <span class="comment"># Indices dtype validation</span></div>
<div class="line"><span class="lineno">  519</span>    _check_large_sparse(spmatrix, accept_large_sparse)</div>
<div class="line"><span class="lineno">  520</span> </div>
<div class="line"><span class="lineno">  521</span>    <span class="keywordflow">if</span> accept_sparse <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno">  522</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  523</span>            <span class="stringliteral">&quot;A sparse matrix was passed, but dense &quot;</span></div>
<div class="line"><span class="lineno">  524</span>            <span class="stringliteral">&quot;data is required. Use X.toarray() to &quot;</span></div>
<div class="line"><span class="lineno">  525</span>            <span class="stringliteral">&quot;convert to a dense numpy array.&quot;</span></div>
<div class="line"><span class="lineno">  526</span>        )</div>
<div class="line"><span class="lineno">  527</span>    <span class="keywordflow">elif</span> isinstance(accept_sparse, (list, tuple)):</div>
<div class="line"><span class="lineno">  528</span>        <span class="keywordflow">if</span> len(accept_sparse) == 0:</div>
<div class="line"><span class="lineno">  529</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  530</span>                <span class="stringliteral">&quot;When providing &#39;accept_sparse&#39; &quot;</span></div>
<div class="line"><span class="lineno">  531</span>                <span class="stringliteral">&quot;as a tuple or list, it must contain at &quot;</span></div>
<div class="line"><span class="lineno">  532</span>                <span class="stringliteral">&quot;least one string value.&quot;</span></div>
<div class="line"><span class="lineno">  533</span>            )</div>
<div class="line"><span class="lineno">  534</span>        <span class="comment"># ensure correct sparse format</span></div>
<div class="line"><span class="lineno">  535</span>        <span class="keywordflow">if</span> spmatrix.format <span class="keywordflow">not</span> <span class="keywordflow">in</span> accept_sparse:</div>
<div class="line"><span class="lineno">  536</span>            <span class="comment"># create new with correct sparse</span></div>
<div class="line"><span class="lineno">  537</span>            spmatrix = spmatrix.asformat(accept_sparse[0])</div>
<div class="line"><span class="lineno">  538</span>            changed_format = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  539</span>    <span class="keywordflow">elif</span> accept_sparse <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  540</span>        <span class="comment"># any other type</span></div>
<div class="line"><span class="lineno">  541</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  542</span>            <span class="stringliteral">&quot;Parameter &#39;accept_sparse&#39; should be a string, &quot;</span></div>
<div class="line"><span class="lineno">  543</span>            <span class="stringliteral">&quot;boolean or list of strings. You provided &quot;</span></div>
<div class="line"><span class="lineno">  544</span>            <span class="stringliteral">&quot;&#39;accept_sparse={}&#39;.&quot;</span>.format(accept_sparse)</div>
<div class="line"><span class="lineno">  545</span>        )</div>
<div class="line"><span class="lineno">  546</span> </div>
<div class="line"><span class="lineno">  547</span>    <span class="keywordflow">if</span> dtype != spmatrix.dtype:</div>
<div class="line"><span class="lineno">  548</span>        <span class="comment"># convert dtype</span></div>
<div class="line"><span class="lineno">  549</span>        spmatrix = spmatrix.astype(dtype)</div>
<div class="line"><span class="lineno">  550</span>    <span class="keywordflow">elif</span> copy <span class="keywordflow">and</span> <span class="keywordflow">not</span> changed_format:</div>
<div class="line"><span class="lineno">  551</span>        <span class="comment"># force copy</span></div>
<div class="line"><span class="lineno">  552</span>        spmatrix = spmatrix.copy()</div>
<div class="line"><span class="lineno">  553</span> </div>
<div class="line"><span class="lineno">  554</span>    <span class="keywordflow">if</span> force_all_finite:</div>
<div class="line"><span class="lineno">  555</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(spmatrix, <span class="stringliteral">&quot;data&quot;</span>):</div>
<div class="line"><span class="lineno">  556</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  557</span>                <span class="stringliteral">&quot;Can&#39;t check %s sparse matrix for nan or inf.&quot;</span> % spmatrix.format,</div>
<div class="line"><span class="lineno">  558</span>                stacklevel=2,</div>
<div class="line"><span class="lineno">  559</span>            )</div>
<div class="line"><span class="lineno">  560</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  561</span>            _assert_all_finite(</div>
<div class="line"><span class="lineno">  562</span>                spmatrix.data,</div>
<div class="line"><span class="lineno">  563</span>                allow_nan=force_all_finite == <span class="stringliteral">&quot;allow-nan&quot;</span>,</div>
<div class="line"><span class="lineno">  564</span>                estimator_name=estimator_name,</div>
<div class="line"><span class="lineno">  565</span>                input_name=input_name,</div>
<div class="line"><span class="lineno">  566</span>            )</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>    <span class="keywordflow">return</span> spmatrix</div>
<div class="line"><span class="lineno">  569</span> </div>
<div class="line"><span class="lineno">  570</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a64c81bffff5d7bcec77445438cdfaa82" name="a64c81bffff5d7bcec77445438cdfaa82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c81bffff5d7bcec77445438cdfaa82">&#9670;&#160;</a></span>_generate_get_feature_names_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._generate_get_feature_names_out </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_features_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_features</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generate feature names out for estimator using the estimator name as the prefix.

The input_feature names are validated but not used. This function is useful
for estimators that generate their own names based on `n_features_out`, i.e. PCA.

Parameters
----------
estimator : estimator instance
    Estimator producing output feature names.

n_feature_out : int
    Number of feature names out.

input_features : array-like of str or None, default=None
    Only used to validate feature names with `estimator.feature_names_in_`.

Returns
-------
feature_names_in : ndarray of str or `None`
    Feature names in.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1966</span><span class="keyword">def </span>_generate_get_feature_names_out(estimator, n_features_out, input_features=None):</div>
<div class="line"><span class="lineno"> 1967</span>    <span class="stringliteral">&quot;&quot;&quot;Generate feature names out for estimator using the estimator name as the prefix.</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">    The input_feature names are validated but not used. This function is useful</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    for estimators that generate their own names based on `n_features_out`, i.e. PCA.</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    estimator : estimator instance</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">        Estimator producing output feature names.</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">    n_feature_out : int</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">        Number of feature names out.</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">    input_features : array-like of str or None, default=None</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">        Only used to validate feature names with `estimator.feature_names_in_`.</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">    feature_names_in : ndarray of str or `None`</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">        Feature names in.</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1988</span>    _check_feature_names_in(estimator, input_features, generate_names=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1989</span>    estimator_name = estimator.__class__.__name__.lower()</div>
<div class="line"><span class="lineno"> 1990</span>    <span class="keywordflow">return</span> np.asarray(</div>
<div class="line"><span class="lineno"> 1991</span>        [f<span class="stringliteral">&quot;{estimator_name}{i}&quot;</span> <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n_features_out)], dtype=object</div>
<div class="line"><span class="lineno"> 1992</span>    )</div>
<div class="line"><span class="lineno"> 1993</span> </div>
<div class="line"><span class="lineno"> 1994</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa403f42854f5a6a64e52a464b347c9f7" name="aa403f42854f5a6a64e52a464b347c9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa403f42854f5a6a64e52a464b347c9f7">&#9670;&#160;</a></span>_get_feature_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._get_feature_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get feature names from X.

Support for other array containers should place its implementation here.

Parameters
----------
X : {ndarray, dataframe} of shape (n_samples, n_features)
    Array container to extract feature names.

    - pandas dataframe : The columns will be considered to be feature
      names. If the dataframe contains non-string feature names, `None` is
      returned.
    - All other array containers will return `None`.

Returns
-------
names: ndarray or None
    Feature names of `X`. Unrecognized array containers will return `None`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1860</span><span class="keyword">def </span>_get_feature_names(X):</div>
<div class="line"><span class="lineno"> 1861</span>    <span class="stringliteral">&quot;&quot;&quot;Get feature names from X.</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    Support for other array containers should place its implementation here.</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">    X : {ndarray, dataframe} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">        Array container to extract feature names.</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">        - pandas dataframe : The columns will be considered to be feature</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">          names. If the dataframe contains non-string feature names, `None` is</span></div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">          returned.</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">        - All other array containers will return `None`.</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    names: ndarray or None</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">        Feature names of `X`. Unrecognized array containers will return `None`.</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1880</span>    feature_names = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1881</span> </div>
<div class="line"><span class="lineno"> 1882</span>    <span class="comment"># extract feature names for support array containers</span></div>
<div class="line"><span class="lineno"> 1883</span>    <span class="keywordflow">if</span> hasattr(X, <span class="stringliteral">&quot;columns&quot;</span>):</div>
<div class="line"><span class="lineno"> 1884</span>        feature_names = np.asarray(X.columns, dtype=object)</div>
<div class="line"><span class="lineno"> 1885</span> </div>
<div class="line"><span class="lineno"> 1886</span>    <span class="keywordflow">if</span> feature_names <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> len(feature_names) == 0:</div>
<div class="line"><span class="lineno"> 1887</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1888</span> </div>
<div class="line"><span class="lineno"> 1889</span>    types = sorted(t.__qualname__ <span class="keywordflow">for</span> t <span class="keywordflow">in</span> set(type(v) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> feature_names))</div>
<div class="line"><span class="lineno"> 1890</span> </div>
<div class="line"><span class="lineno"> 1891</span>    <span class="comment"># mixed type of string and non-string is not supported</span></div>
<div class="line"><span class="lineno"> 1892</span>    <span class="keywordflow">if</span> len(types) &gt; 1 <span class="keywordflow">and</span> <span class="stringliteral">&quot;str&quot;</span> <span class="keywordflow">in</span> types:</div>
<div class="line"><span class="lineno"> 1893</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1894</span>            <span class="stringliteral">&quot;Feature names are only supported if all input features have string names, &quot;</span></div>
<div class="line"><span class="lineno"> 1895</span>            f<span class="stringliteral">&quot;but your input has {types} as feature name / column name types. &quot;</span></div>
<div class="line"><span class="lineno"> 1896</span>            <span class="stringliteral">&quot;If you want feature names to be stored and validated, you must convert &quot;</span></div>
<div class="line"><span class="lineno"> 1897</span>            <span class="stringliteral">&quot;them all to strings, by using X.columns = X.columns.astype(str) for &quot;</span></div>
<div class="line"><span class="lineno"> 1898</span>            <span class="stringliteral">&quot;example. Otherwise you can remove feature / column names from your input &quot;</span></div>
<div class="line"><span class="lineno"> 1899</span>            <span class="stringliteral">&quot;data, or convert them all to a non-string data type.&quot;</span></div>
<div class="line"><span class="lineno"> 1900</span>        )</div>
<div class="line"><span class="lineno"> 1901</span> </div>
<div class="line"><span class="lineno"> 1902</span>    <span class="comment"># Only feature names of all strings are supported</span></div>
<div class="line"><span class="lineno"> 1903</span>    <span class="keywordflow">if</span> len(types) == 1 <span class="keywordflow">and</span> types[0] == <span class="stringliteral">&quot;str&quot;</span>:</div>
<div class="line"><span class="lineno"> 1904</span>        <span class="keywordflow">return</span> feature_names</div>
<div class="line"><span class="lineno"> 1905</span> </div>
<div class="line"><span class="lineno"> 1906</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a74c4bdbb9185e056d4db94a4321d4b" name="a7a74c4bdbb9185e056d4db94a4321d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a74c4bdbb9185e056d4db94a4321d4b">&#9670;&#160;</a></span>_is_arraylike()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._is_arraylike </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns whether the input is array-like.</pre> <div class="fragment"><div class="line"><span class="lineno">  257</span><span class="keyword">def </span>_is_arraylike(x):</div>
<div class="line"><span class="lineno">  258</span>    <span class="stringliteral">&quot;&quot;&quot;Returns whether the input is array-like.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  259</span>    <span class="keywordflow">return</span> hasattr(x, <span class="stringliteral">&quot;__len__&quot;</span>) <span class="keywordflow">or</span> hasattr(x, <span class="stringliteral">&quot;shape&quot;</span>) <span class="keywordflow">or</span> hasattr(x, <span class="stringliteral">&quot;__array__&quot;</span>)</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4af048955280074c9ef7215354038a2d" name="a4af048955280074c9ef7215354038a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af048955280074c9ef7215354038a2d">&#9670;&#160;</a></span>_is_arraylike_not_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._is_arraylike_not_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return True if array is array-like and not a scalar</pre> <div class="fragment"><div class="line"><span class="lineno">  262</span><span class="keyword">def </span>_is_arraylike_not_scalar(array):</div>
<div class="line"><span class="lineno">  263</span>    <span class="stringliteral">&quot;&quot;&quot;Return True if array is array-like and not a scalar&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    return _is_arraylike(array) and not np.isscalar(array)</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7550ba455fda84a6ace62242d3b0dc70" name="a7550ba455fda84a6ace62242d3b0dc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7550ba455fda84a6ace62242d3b0dc70">&#9670;&#160;</a></span>_make_indexable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._make_indexable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure iterable supports indexing or convert to an indexable variant.

Convert sparse matrices to csr and other non-indexable iterable to arrays.
Let `None` and indexable objects (e.g. pandas dataframes) pass unchanged.

Parameters
----------
iterable : {list, dataframe, ndarray, sparse matrix} or None
    Object to be converted to an indexable iterable.
</pre> <div class="fragment"><div class="line"><span class="lineno">  403</span><span class="keyword">def </span>_make_indexable(iterable):</div>
<div class="line"><span class="lineno">  404</span>    <span class="stringliteral">&quot;&quot;&quot;Ensure iterable supports indexing or convert to an indexable variant.</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    Convert sparse matrices to csr and other non-indexable iterable to arrays.</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    Let `None` and indexable objects (e.g. pandas dataframes) pass unchanged.</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    iterable : {list, dataframe, ndarray, sparse matrix} or None</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">        Object to be converted to an indexable iterable.</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  414</span>    <span class="keywordflow">if</span> sp.issparse(iterable):</div>
<div class="line"><span class="lineno">  415</span>        <span class="keywordflow">return</span> iterable.tocsr()</div>
<div class="line"><span class="lineno">  416</span>    <span class="keywordflow">elif</span> hasattr(iterable, <span class="stringliteral">&quot;__getitem__&quot;</span>) <span class="keywordflow">or</span> hasattr(iterable, <span class="stringliteral">&quot;iloc&quot;</span>):</div>
<div class="line"><span class="lineno">  417</span>        <span class="keywordflow">return</span> iterable</div>
<div class="line"><span class="lineno">  418</span>    <span class="keywordflow">elif</span> iterable <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">return</span> iterable</div>
<div class="line"><span class="lineno">  420</span>    <span class="keywordflow">return</span> np.array(iterable)</div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeac633479b1dc831cf7ed4e7b59ad364" name="aeac633479b1dc831cf7ed4e7b59ad364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac633479b1dc831cf7ed4e7b59ad364">&#9670;&#160;</a></span>_num_features()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._num_features </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the number of features in an array-like X.

This helper function tries hard to avoid to materialize an array version
of X unless necessary. For instance, if X is a list of lists,
this function will return the length of the first element, assuming
that subsequent elements are all lists of the same length without
checking.
Parameters
----------
X : array-like
    array-like to get the number of features.

Returns
-------
features : int
    Number of features
</pre> <div class="fragment"><div class="line"><span class="lineno">  267</span><span class="keyword">def </span>_num_features(X):</div>
<div class="line"><span class="lineno">  268</span>    <span class="stringliteral">&quot;&quot;&quot;Return the number of features in an array-like X.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    This helper function tries hard to avoid to materialize an array version</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    of X unless necessary. For instance, if X is a list of lists,</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    this function will return the length of the first element, assuming</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    that subsequent elements are all lists of the same length without</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    checking.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    X : array-like</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        array-like to get the number of features.</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    features : int</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        Number of features</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  285</span>    type_ = type(X)</div>
<div class="line"><span class="lineno">  286</span>    <span class="keywordflow">if</span> type_.__module__ == <span class="stringliteral">&quot;builtins&quot;</span>:</div>
<div class="line"><span class="lineno">  287</span>        type_name = type_.__qualname__</div>
<div class="line"><span class="lineno">  288</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  289</span>        type_name = f<span class="stringliteral">&quot;{type_.__module__}.{type_.__qualname__}&quot;</span></div>
<div class="line"><span class="lineno">  290</span>    message = f<span class="stringliteral">&quot;Unable to find the number of features from X of type {type_name}&quot;</span></div>
<div class="line"><span class="lineno">  291</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(X, <span class="stringliteral">&quot;__len__&quot;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> hasattr(X, <span class="stringliteral">&quot;shape&quot;</span>):</div>
<div class="line"><span class="lineno">  292</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(X, <span class="stringliteral">&quot;__array__&quot;</span>):</div>
<div class="line"><span class="lineno">  293</span>            <span class="keywordflow">raise</span> TypeError(message)</div>
<div class="line"><span class="lineno">  294</span>        <span class="comment"># Only convert X to a numpy array if there is no cheaper, heuristic</span></div>
<div class="line"><span class="lineno">  295</span>        <span class="comment"># option.</span></div>
<div class="line"><span class="lineno">  296</span>        X = np.asarray(X)</div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span>    <span class="keywordflow">if</span> hasattr(X, <span class="stringliteral">&quot;shape&quot;</span>):</div>
<div class="line"><span class="lineno">  299</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(X.shape, <span class="stringliteral">&quot;__len__&quot;</span>) <span class="keywordflow">or</span> len(X.shape) &lt;= 1:</div>
<div class="line"><span class="lineno">  300</span>            message += f<span class="stringliteral">&quot; with shape {X.shape}&quot;</span></div>
<div class="line"><span class="lineno">  301</span>            <span class="keywordflow">raise</span> TypeError(message)</div>
<div class="line"><span class="lineno">  302</span>        <span class="keywordflow">return</span> X.shape[1]</div>
<div class="line"><span class="lineno">  303</span> </div>
<div class="line"><span class="lineno">  304</span>    first_sample = X[0]</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span>    <span class="comment"># Do not consider an array-like of strings or dicts to be a 2D array</span></div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">if</span> isinstance(first_sample, (str, bytes, dict)):</div>
<div class="line"><span class="lineno">  308</span>        message += f<span class="stringliteral">&quot; where the samples are of type {type(first_sample).__qualname__}&quot;</span></div>
<div class="line"><span class="lineno">  309</span>        <span class="keywordflow">raise</span> TypeError(message)</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  312</span>        <span class="comment"># If X is a list of lists, for instance, we assume that all nested</span></div>
<div class="line"><span class="lineno">  313</span>        <span class="comment"># lists have the same length without checking or converting to</span></div>
<div class="line"><span class="lineno">  314</span>        <span class="comment"># a numpy array to keep this function call as cheap as possible.</span></div>
<div class="line"><span class="lineno">  315</span>        <span class="keywordflow">return</span> len(first_sample)</div>
<div class="line"><span class="lineno">  316</span>    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  317</span>        <span class="keywordflow">raise</span> TypeError(message) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  318</span> </div>
<div class="line"><span class="lineno">  319</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f819616f9cf7c4a803a684bb783bdfe" name="a2f819616f9cf7c4a803a684bb783bdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f819616f9cf7c4a803a684bb783bdfe">&#9670;&#160;</a></span>_num_samples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._num_samples </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return number of samples in array-like x.</pre> <div class="fragment"><div class="line"><span class="lineno">  320</span><span class="keyword">def </span>_num_samples(x):</div>
<div class="line"><span class="lineno">  321</span>    <span class="stringliteral">&quot;&quot;&quot;Return number of samples in array-like x.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  322</span>    message = <span class="stringliteral">&quot;Expected sequence or array-like, got %s&quot;</span> % type(x)</div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">if</span> hasattr(x, <span class="stringliteral">&quot;fit&quot;</span>) <span class="keywordflow">and</span> callable(x.fit):</div>
<div class="line"><span class="lineno">  324</span>        <span class="comment"># Don&#39;t get num_samples from an ensembles length!</span></div>
<div class="line"><span class="lineno">  325</span>        <span class="keywordflow">raise</span> TypeError(message)</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(x, <span class="stringliteral">&quot;__len__&quot;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> hasattr(x, <span class="stringliteral">&quot;shape&quot;</span>):</div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordflow">if</span> hasattr(x, <span class="stringliteral">&quot;__array__&quot;</span>):</div>
<div class="line"><span class="lineno">  329</span>            x = np.asarray(x)</div>
<div class="line"><span class="lineno">  330</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  331</span>            <span class="keywordflow">raise</span> TypeError(message)</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>    <span class="keywordflow">if</span> hasattr(x, <span class="stringliteral">&quot;shape&quot;</span>) <span class="keywordflow">and</span> x.shape <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  334</span>        <span class="keywordflow">if</span> len(x.shape) == 0:</div>
<div class="line"><span class="lineno">  335</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  336</span>                <span class="stringliteral">&quot;Singleton array %r cannot be considered a valid collection.&quot;</span> % x</div>
<div class="line"><span class="lineno">  337</span>            )</div>
<div class="line"><span class="lineno">  338</span>        <span class="comment"># Check that shape is returning an integer or default to len</span></div>
<div class="line"><span class="lineno">  339</span>        <span class="comment"># Dask dataframes may not return numeric shape[0] value</span></div>
<div class="line"><span class="lineno">  340</span>        <span class="keywordflow">if</span> isinstance(x.shape[0], numbers.Integral):</div>
<div class="line"><span class="lineno">  341</span>            <span class="keywordflow">return</span> x.shape[0]</div>
<div class="line"><span class="lineno">  342</span> </div>
<div class="line"><span class="lineno">  343</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  344</span>        <span class="keywordflow">return</span> len(x)</div>
<div class="line"><span class="lineno">  345</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> type_error:</div>
<div class="line"><span class="lineno">  346</span>        <span class="keywordflow">raise</span> TypeError(message) <span class="keyword">from</span> type_error</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ebca20e325263d762622596fa7b1bac" name="a0ebca20e325263d762622596fa7b1bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebca20e325263d762622596fa7b1bac">&#9670;&#160;</a></span>_pandas_dtype_needs_early_conversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation._pandas_dtype_needs_early_conversion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pd_dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return True if pandas extension pd_dtype need to be converted early.</pre> <div class="fragment"><div class="line"><span class="lineno">  590</span><span class="keyword">def </span>_pandas_dtype_needs_early_conversion(pd_dtype):</div>
<div class="line"><span class="lineno">  591</span>    <span class="stringliteral">&quot;&quot;&quot;Return True if pandas extension pd_dtype need to be converted early.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  592</span>    <span class="comment"># Check these early for pandas versions without extension dtypes</span></div>
<div class="line"><span class="lineno">  593</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1api_1_1types.html">pandas.api.types</a> <span class="keyword">import</span> (</div>
<div class="line"><span class="lineno">  594</span>        is_bool_dtype,</div>
<div class="line"><span class="lineno">  595</span>        is_sparse,</div>
<div class="line"><span class="lineno">  596</span>        is_float_dtype,</div>
<div class="line"><span class="lineno">  597</span>        is_integer_dtype,</div>
<div class="line"><span class="lineno">  598</span>    )</div>
<div class="line"><span class="lineno">  599</span> </div>
<div class="line"><span class="lineno">  600</span>    <span class="keywordflow">if</span> is_bool_dtype(pd_dtype):</div>
<div class="line"><span class="lineno">  601</span>        <span class="comment"># bool and extension booleans need early converstion because __array__</span></div>
<div class="line"><span class="lineno">  602</span>        <span class="comment"># converts mixed dtype dataframes into object dtypes</span></div>
<div class="line"><span class="lineno">  603</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  604</span> </div>
<div class="line"><span class="lineno">  605</span>    <span class="keywordflow">if</span> is_sparse(pd_dtype):</div>
<div class="line"><span class="lineno">  606</span>        <span class="comment"># Sparse arrays will be converted later in `check_array`</span></div>
<div class="line"><span class="lineno">  607</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  608</span> </div>
<div class="line"><span class="lineno">  609</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  610</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1api_1_1types.html">pandas.api.types</a> <span class="keyword">import</span> is_extension_array_dtype</div>
<div class="line"><span class="lineno">  611</span>    <span class="keywordflow">except</span> ImportError:</div>
<div class="line"><span class="lineno">  612</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  613</span> </div>
<div class="line"><span class="lineno">  614</span>    <span class="keywordflow">if</span> is_sparse(pd_dtype) <span class="keywordflow">or</span> <span class="keywordflow">not</span> is_extension_array_dtype(pd_dtype):</div>
<div class="line"><span class="lineno">  615</span>        <span class="comment"># Sparse arrays will be converted later in `check_array`</span></div>
<div class="line"><span class="lineno">  616</span>        <span class="comment"># Only handle extension arrays for integer and floats</span></div>
<div class="line"><span class="lineno">  617</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  618</span>    <span class="keywordflow">elif</span> is_float_dtype(pd_dtype):</div>
<div class="line"><span class="lineno">  619</span>        <span class="comment"># Float ndarrays can normally support nans. They need to be converted</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="comment"># first to map pd.NA to np.nan</span></div>
<div class="line"><span class="lineno">  621</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordflow">elif</span> is_integer_dtype(pd_dtype):</div>
<div class="line"><span class="lineno">  623</span>        <span class="comment"># XXX: Warn when converting from a high integer to a float</span></div>
<div class="line"><span class="lineno">  624</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  625</span> </div>
<div class="line"><span class="lineno">  626</span>    <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="ttc" id="anamespacepandas_1_1api_1_1types_html"><div class="ttname"><a href="namespacepandas_1_1api_1_1types.html">pandas.api.types</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acebe645081521254c0460747f06c848f" name="acebe645081521254c0460747f06c848f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebe645081521254c0460747f06c848f">&#9670;&#160;</a></span>as_float_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.as_float_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_all_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert an array-like to an array of floats.

The new dtype will be np.float32 or np.float64, depending on the original
type. The function can create a copy or modify the argument depending
on the argument copy.

Parameters
----------
X : {array-like, sparse matrix}
    The input data.

copy : bool, default=True
    If True, a copy of X will be created. If False, a copy may still be
    returned if X's dtype is not a floating point type.

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in X. The
    possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 0.20
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`

Returns
-------
XT : {ndarray, sparse matrix}
    An array of type float.
</pre> <div class="fragment"><div class="line"><span class="lineno">  198</span><span class="keyword">def </span>as_float_array(X, *, copy=True, force_all_finite=True):</div>
<div class="line"><span class="lineno">  199</span>    <span class="stringliteral">&quot;&quot;&quot;Convert an array-like to an array of floats.</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    The new dtype will be np.float32 or np.float64, depending on the original</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    type. The function can create a copy or modify the argument depending</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    on the argument copy.</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    X : {array-like, sparse matrix}</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        The input data.</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    copy : bool, default=True</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        If True, a copy of X will be created. If False, a copy may still be</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        returned if X&#39;s dtype is not a floating point type.</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    force_all_finite : bool or &#39;allow-nan&#39;, default=True</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        Whether to raise an error on np.inf, np.nan, pd.NA in X. The</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        possibilities are:</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        - True: Force all values of X to be finite.</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        - False: accepts np.inf, np.nan, pd.NA in X.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        - &#39;allow-nan&#39;: accepts only np.nan and pd.NA values in X. Values cannot</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">          be infinite.</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">           ``force_all_finite`` accepts the string ``&#39;allow-nan&#39;``.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        .. versionchanged:: 0.23</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">           Accepts `pd.NA` and converts it into `np.nan`</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    XT : {ndarray, sparse matrix}</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        An array of type float.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">if</span> isinstance(X, np.matrix) <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno">  235</span>        <span class="keywordflow">not</span> isinstance(X, np.ndarray) <span class="keywordflow">and</span> <span class="keywordflow">not</span> sp.issparse(X)</div>
<div class="line"><span class="lineno">  236</span>    ):</div>
<div class="line"><span class="lineno">  237</span>        <span class="keywordflow">return</span> check_array(</div>
<div class="line"><span class="lineno">  238</span>            X,</div>
<div class="line"><span class="lineno">  239</span>            accept_sparse=[<span class="stringliteral">&quot;csr&quot;</span>, <span class="stringliteral">&quot;csc&quot;</span>, <span class="stringliteral">&quot;coo&quot;</span>],</div>
<div class="line"><span class="lineno">  240</span>            dtype=np.float64,</div>
<div class="line"><span class="lineno">  241</span>            copy=copy,</div>
<div class="line"><span class="lineno">  242</span>            force_all_finite=force_all_finite,</div>
<div class="line"><span class="lineno">  243</span>            ensure_2d=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  244</span>        )</div>
<div class="line"><span class="lineno">  245</span>    <span class="keywordflow">elif</span> sp.issparse(X) <span class="keywordflow">and</span> X.dtype <span class="keywordflow">in</span> [np.float32, np.float64]:</div>
<div class="line"><span class="lineno">  246</span>        <span class="keywordflow">return</span> X.copy() <span class="keywordflow">if</span> copy <span class="keywordflow">else</span> X</div>
<div class="line"><span class="lineno">  247</span>    <span class="keywordflow">elif</span> X.dtype <span class="keywordflow">in</span> [np.float32, np.float64]:  <span class="comment"># is numpy array</span></div>
<div class="line"><span class="lineno">  248</span>        <span class="keywordflow">return</span> X.copy(<span class="stringliteral">&quot;F&quot;</span> <span class="keywordflow">if</span> X.flags[<span class="stringliteral">&quot;F_CONTIGUOUS&quot;</span>] <span class="keywordflow">else</span> <span class="stringliteral">&quot;C&quot;</span>) <span class="keywordflow">if</span> copy <span class="keywordflow">else</span> X</div>
<div class="line"><span class="lineno">  249</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  250</span>        <span class="keywordflow">if</span> X.dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&quot;uib&quot;</span> <span class="keywordflow">and</span> X.dtype.itemsize &lt;= 4:</div>
<div class="line"><span class="lineno">  251</span>            return_dtype = np.float32</div>
<div class="line"><span class="lineno">  252</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  253</span>            return_dtype = np.float64</div>
<div class="line"><span class="lineno">  254</span>        <span class="keywordflow">return</span> X.astype(return_dtype)</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a845ed63e43216bb6cdca8fc7ed34888a" name="a845ed63e43216bb6cdca8fc7ed34888a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845ed63e43216bb6cdca8fc7ed34888a">&#9670;&#160;</a></span>assert_all_finite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.assert_all_finite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>allow_nan</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Throw a ValueError if X contains NaN or infinity.

Parameters
----------
X : {ndarray, sparse matrix}
    The input data.

allow_nan : bool, default=False
    If True, do not throw error when `X` contains NaN.

estimator_name : str, default=None
    The estimator name, used to construct the error message.

input_name : str, default=""
    The data name used to construct the error message. In particular
    if `input_name` is "X" and the data has NaN values and
    allow_nan is False, the error message will link to the imputer
    documentation.
</pre> <div class="fragment"><div class="line"><span class="lineno">  170</span>):</div>
<div class="line"><span class="lineno">  171</span>    <span class="stringliteral">&quot;&quot;&quot;Throw a ValueError if X contains NaN or infinity.</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    X : {ndarray, sparse matrix}</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        The input data.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    allow_nan : bool, default=False</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">        If True, do not throw error when `X` contains NaN.</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    estimator_name : str, default=None</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        The estimator name, used to construct the error message.</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    input_name : str, default=&quot;&quot;</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        The data name used to construct the error message. In particular</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        if `input_name` is &quot;X&quot; and the data has NaN values and</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">        allow_nan is False, the error message will link to the imputer</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        documentation.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  190</span>    _assert_all_finite(</div>
<div class="line"><span class="lineno">  191</span>        X.data <span class="keywordflow">if</span> sp.issparse(X) <span class="keywordflow">else</span> X,</div>
<div class="line"><span class="lineno">  192</span>        allow_nan=allow_nan,</div>
<div class="line"><span class="lineno">  193</span>        estimator_name=estimator_name,</div>
<div class="line"><span class="lineno">  194</span>        input_name=input_name,</div>
<div class="line"><span class="lineno">  195</span>    )</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a616829948911596bf72e5e20a26f2fab" name="a616829948911596bf72e5e20a26f2fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616829948911596bf72e5e20a26f2fab">&#9670;&#160;</a></span>check_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accept_sparse</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>accept_large_sparse</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>&quot;numeric&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_all_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensure_2d</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_nd</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensure_min_samples</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensure_min_features</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Input validation on an array, list, sparse matrix or similar.

By default, the input is checked to be a non-empty 2D array containing
only finite values. If the dtype of the array is object, attempt
converting to float, raising on failure.

Parameters
----------
array : object
    Input object to check / convert.

accept_sparse : str, bool or list/tuple of str, default=False
    String[s] representing allowed sparse matrix formats, such as 'csc',
    'csr', etc. If the input is sparse but not in the allowed format,
    it will be converted to the first listed format. True allows the input
    to be any format. False means that a sparse matrix input will
    raise an error.

accept_large_sparse : bool, default=True
    If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
    accept_sparse, accept_large_sparse=False will cause it to be accepted
    only if its indices are stored with a 32-bit dtype.

    .. versionadded:: 0.20

dtype : 'numeric', type, list of type or None, default='numeric'
    Data type of result. If None, the dtype of the input is preserved.
    If "numeric", dtype is preserved unless array.dtype is object.
    If dtype is a list of types, conversion on the first type is only
    performed if the dtype of the input is not in the list.

order : {'F', 'C'} or None, default=None
    Whether an array will be forced to be fortran or c-style.
    When order is None (default), then if copy=False, nothing is ensured
    about the memory layout of the output array; otherwise (copy=True)
    the memory layout of the returned array is kept as close as possible
    to the original array.

copy : bool, default=False
    Whether a forced copy will be triggered. If copy=False, a copy might
    be triggered by a conversion.

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in array. The
    possibilities are:

    - True: Force all values of array to be finite.
    - False: accepts np.inf, np.nan, pd.NA in array.
    - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
      cannot be infinite.

    .. versionadded:: 0.20
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`

ensure_2d : bool, default=True
    Whether to raise a value error if array is not 2D.

allow_nd : bool, default=False
    Whether to allow array.ndim &gt; 2.

ensure_min_samples : int, default=1
    Make sure that the array has a minimum number of samples in its first
    axis (rows for a 2D array). Setting to 0 disables this check.

ensure_min_features : int, default=1
    Make sure that the 2D array has some minimum number of features
    (columns). The default value of 1 rejects empty datasets.
    This check is only enforced when the input data has effectively 2
    dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0
    disables this check.

estimator : str or estimator instance, default=None
    If passed, include the name of the estimator in warning messages.

input_name : str, default=""
    The data name used to construct the error message. In particular
    if `input_name` is "X" and the data has NaN values and
    allow_nan is False, the error message will link to the imputer
    documentation.

    .. versionadded:: 1.1.0

Returns
-------
array_converted : object
    The converted and validated array.
</pre> <div class="fragment"><div class="line"><span class="lineno">  644</span>):</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>    <span class="stringliteral">&quot;&quot;&quot;Input validation on an array, list, sparse matrix or similar.</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    By default, the input is checked to be a non-empty 2D array containing</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    only finite values. If the dtype of the array is object, attempt</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    converting to float, raising on failure.</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    array : object</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        Input object to check / convert.</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    accept_sparse : str, bool or list/tuple of str, default=False</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        String[s] representing allowed sparse matrix formats, such as &#39;csc&#39;,</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        &#39;csr&#39;, etc. If the input is sparse but not in the allowed format,</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        it will be converted to the first listed format. True allows the input</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">        to be any format. False means that a sparse matrix input will</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        raise an error.</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    accept_large_sparse : bool, default=True</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">        accept_sparse, accept_large_sparse=False will cause it to be accepted</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">        only if its indices are stored with a 32-bit dtype.</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    dtype : &#39;numeric&#39;, type, list of type or None, default=&#39;numeric&#39;</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        Data type of result. If None, the dtype of the input is preserved.</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">        If &quot;numeric&quot;, dtype is preserved unless array.dtype is object.</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">        If dtype is a list of types, conversion on the first type is only</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">        performed if the dtype of the input is not in the list.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    order : {&#39;F&#39;, &#39;C&#39;} or None, default=None</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">        Whether an array will be forced to be fortran or c-style.</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">        When order is None (default), then if copy=False, nothing is ensured</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">        about the memory layout of the output array; otherwise (copy=True)</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">        the memory layout of the returned array is kept as close as possible</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">        to the original array.</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    copy : bool, default=False</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        Whether a forced copy will be triggered. If copy=False, a copy might</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">        be triggered by a conversion.</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    force_all_finite : bool or &#39;allow-nan&#39;, default=True</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        Whether to raise an error on np.inf, np.nan, pd.NA in array. The</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        possibilities are:</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">        - True: Force all values of array to be finite.</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        - False: accepts np.inf, np.nan, pd.NA in array.</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        - &#39;allow-nan&#39;: accepts only np.nan and pd.NA values in array. Values</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">          cannot be infinite.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">           ``force_all_finite`` accepts the string ``&#39;allow-nan&#39;``.</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        .. versionchanged:: 0.23</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">           Accepts `pd.NA` and converts it into `np.nan`</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    ensure_2d : bool, default=True</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        Whether to raise a value error if array is not 2D.</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    allow_nd : bool, default=False</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">        Whether to allow array.ndim &gt; 2.</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    ensure_min_samples : int, default=1</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">        Make sure that the array has a minimum number of samples in its first</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        axis (rows for a 2D array). Setting to 0 disables this check.</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    ensure_min_features : int, default=1</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        Make sure that the 2D array has some minimum number of features</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">        (columns). The default value of 1 rejects empty datasets.</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">        This check is only enforced when the input data has effectively 2</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">        disables this check.</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    estimator : str or estimator instance, default=None</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">        If passed, include the name of the estimator in warning messages.</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    input_name : str, default=&quot;&quot;</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">        The data name used to construct the error message. In particular</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">        if `input_name` is &quot;X&quot; and the data has NaN values and</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">        allow_nan is False, the error message will link to the imputer</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">        documentation.</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">        .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    array_converted : object</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">        The converted and validated array.</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  736</span>    <span class="keywordflow">if</span> isinstance(array, np.matrix):</div>
<div class="line"><span class="lineno">  737</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  738</span>            <span class="stringliteral">&quot;np.matrix is not supported. Please convert to a numpy array with &quot;</span></div>
<div class="line"><span class="lineno">  739</span>            <span class="stringliteral">&quot;np.asarray. For more information see: &quot;</span></div>
<div class="line"><span class="lineno">  740</span>            <span class="stringliteral">&quot;https://numpy.org/doc/stable/reference/generated/numpy.matrix.html&quot;</span></div>
<div class="line"><span class="lineno">  741</span>        )</div>
<div class="line"><span class="lineno">  742</span> </div>
<div class="line"><span class="lineno">  743</span>    xp, is_array_api = get_namespace(array)</div>
<div class="line"><span class="lineno">  744</span> </div>
<div class="line"><span class="lineno">  745</span>    <span class="comment"># store reference to original array to check if copy is needed when</span></div>
<div class="line"><span class="lineno">  746</span>    <span class="comment"># function returns</span></div>
<div class="line"><span class="lineno">  747</span>    array_orig = array</div>
<div class="line"><span class="lineno">  748</span> </div>
<div class="line"><span class="lineno">  749</span>    <span class="comment"># store whether originally we wanted numeric dtype</span></div>
<div class="line"><span class="lineno">  750</span>    dtype_numeric = isinstance(dtype, str) <span class="keywordflow">and</span> dtype == <span class="stringliteral">&quot;numeric&quot;</span></div>
<div class="line"><span class="lineno">  751</span> </div>
<div class="line"><span class="lineno">  752</span>    dtype_orig = getattr(array, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  753</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(dtype_orig, <span class="stringliteral">&quot;kind&quot;</span>):</div>
<div class="line"><span class="lineno">  754</span>        <span class="comment"># not a data type (e.g. a column named dtype in a pandas DataFrame)</span></div>
<div class="line"><span class="lineno">  755</span>        dtype_orig = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  756</span> </div>
<div class="line"><span class="lineno">  757</span>    <span class="comment"># check if the object contains several dtypes (typically a pandas</span></div>
<div class="line"><span class="lineno">  758</span>    <span class="comment"># DataFrame), and store them. If not, store None.</span></div>
<div class="line"><span class="lineno">  759</span>    dtypes_orig = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  760</span>    pandas_requires_conversion = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  761</span>    <span class="keywordflow">if</span> hasattr(array, <span class="stringliteral">&quot;dtypes&quot;</span>) <span class="keywordflow">and</span> hasattr(array.dtypes, <span class="stringliteral">&quot;__array__&quot;</span>):</div>
<div class="line"><span class="lineno">  762</span>        <span class="comment"># throw warning if columns are sparse. If all columns are sparse, then</span></div>
<div class="line"><span class="lineno">  763</span>        <span class="comment"># array.sparse exists and sparsity will be preserved (later).</span></div>
<div class="line"><span class="lineno">  764</span>        <span class="keyword">with</span> suppress(ImportError):</div>
<div class="line"><span class="lineno">  765</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1api_1_1types.html">pandas.api.types</a> <span class="keyword">import</span> is_sparse</div>
<div class="line"><span class="lineno">  766</span> </div>
<div class="line"><span class="lineno">  767</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(array, <span class="stringliteral">&quot;sparse&quot;</span>) <span class="keywordflow">and</span> array.dtypes.apply(is_sparse).any():</div>
<div class="line"><span class="lineno">  768</span>                warnings.warn(</div>
<div class="line"><span class="lineno">  769</span>                    <span class="stringliteral">&quot;pandas.DataFrame with sparse columns found.&quot;</span></div>
<div class="line"><span class="lineno">  770</span>                    <span class="stringliteral">&quot;It will be converted to a dense numpy array.&quot;</span></div>
<div class="line"><span class="lineno">  771</span>                )</div>
<div class="line"><span class="lineno">  772</span> </div>
<div class="line"><span class="lineno">  773</span>        dtypes_orig = list(array.dtypes)</div>
<div class="line"><span class="lineno">  774</span>        pandas_requires_conversion = any(</div>
<div class="line"><span class="lineno">  775</span>            _pandas_dtype_needs_early_conversion(i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> dtypes_orig</div>
<div class="line"><span class="lineno">  776</span>        )</div>
<div class="line"><span class="lineno">  777</span>        <span class="keywordflow">if</span> all(isinstance(dtype_iter, np.dtype) <span class="keywordflow">for</span> dtype_iter <span class="keywordflow">in</span> dtypes_orig):</div>
<div class="line"><span class="lineno">  778</span>            dtype_orig = np.result_type(*dtypes_orig)</div>
<div class="line"><span class="lineno">  779</span> </div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">elif</span> hasattr(array, <span class="stringliteral">&quot;iloc&quot;</span>) <span class="keywordflow">and</span> hasattr(array, <span class="stringliteral">&quot;dtype&quot;</span>):</div>
<div class="line"><span class="lineno">  781</span>        <span class="comment"># array is a pandas series</span></div>
<div class="line"><span class="lineno">  782</span>        pandas_requires_conversion = _pandas_dtype_needs_early_conversion(array.dtype)</div>
<div class="line"><span class="lineno">  783</span>        <span class="keywordflow">if</span> pandas_requires_conversion:</div>
<div class="line"><span class="lineno">  784</span>            <span class="comment"># Set to None, to convert to a np.dtype that works with array.dtype</span></div>
<div class="line"><span class="lineno">  785</span>            dtype_orig = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  786</span> </div>
<div class="line"><span class="lineno">  787</span>    <span class="keywordflow">if</span> dtype_numeric:</div>
<div class="line"><span class="lineno">  788</span>        <span class="keywordflow">if</span> dtype_orig <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> dtype_orig.kind == <span class="stringliteral">&quot;O&quot;</span>:</div>
<div class="line"><span class="lineno">  789</span>            <span class="comment"># if input is object, convert to float.</span></div>
<div class="line"><span class="lineno">  790</span>            dtype = xp.float64</div>
<div class="line"><span class="lineno">  791</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  792</span>            dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  793</span> </div>
<div class="line"><span class="lineno">  794</span>    <span class="keywordflow">if</span> isinstance(dtype, (list, tuple)):</div>
<div class="line"><span class="lineno">  795</span>        <span class="keywordflow">if</span> dtype_orig <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> dtype_orig <span class="keywordflow">in</span> dtype:</div>
<div class="line"><span class="lineno">  796</span>            <span class="comment"># no dtype conversion required</span></div>
<div class="line"><span class="lineno">  797</span>            dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  798</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  799</span>            <span class="comment"># dtype conversion required. Let&#39;s select the first element of the</span></div>
<div class="line"><span class="lineno">  800</span>            <span class="comment"># list of accepted types.</span></div>
<div class="line"><span class="lineno">  801</span>            dtype = dtype[0]</div>
<div class="line"><span class="lineno">  802</span> </div>
<div class="line"><span class="lineno">  803</span>    <span class="keywordflow">if</span> pandas_requires_conversion:</div>
<div class="line"><span class="lineno">  804</span>        <span class="comment"># pandas dataframe requires conversion earlier to handle extension dtypes with</span></div>
<div class="line"><span class="lineno">  805</span>        <span class="comment"># nans</span></div>
<div class="line"><span class="lineno">  806</span>        <span class="comment"># Use the original dtype for conversion if dtype is None</span></div>
<div class="line"><span class="lineno">  807</span>        new_dtype = dtype_orig <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> dtype</div>
<div class="line"><span class="lineno">  808</span>        array = array.astype(new_dtype)</div>
<div class="line"><span class="lineno">  809</span>        <span class="comment"># Since we converted here, we do not need to convert again later</span></div>
<div class="line"><span class="lineno">  810</span>        dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  811</span> </div>
<div class="line"><span class="lineno">  812</span>    <span class="keywordflow">if</span> force_all_finite <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="stringliteral">&quot;allow-nan&quot;</span>):</div>
<div class="line"><span class="lineno">  813</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  814</span>            <span class="stringliteral">&#39;force_all_finite should be a bool or &quot;allow-nan&quot;. Got {!r} instead&#39;</span>.format(</div>
<div class="line"><span class="lineno">  815</span>                force_all_finite</div>
<div class="line"><span class="lineno">  816</span>            )</div>
<div class="line"><span class="lineno">  817</span>        )</div>
<div class="line"><span class="lineno">  818</span> </div>
<div class="line"><span class="lineno">  819</span>    estimator_name = _check_estimator_name(estimator)</div>
<div class="line"><span class="lineno">  820</span>    context = <span class="stringliteral">&quot; by %s&quot;</span> % estimator_name <span class="keywordflow">if</span> estimator <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  821</span> </div>
<div class="line"><span class="lineno">  822</span>    <span class="comment"># When all dataframe columns are sparse, convert to a sparse array</span></div>
<div class="line"><span class="lineno">  823</span>    <span class="keywordflow">if</span> hasattr(array, <span class="stringliteral">&quot;sparse&quot;</span>) <span class="keywordflow">and</span> array.ndim &gt; 1:</div>
<div class="line"><span class="lineno">  824</span>        <span class="keyword">with</span> suppress(ImportError):</div>
<div class="line"><span class="lineno">  825</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1api_1_1types.html">pandas.api.types</a> <span class="keyword">import</span> is_sparse</div>
<div class="line"><span class="lineno">  826</span> </div>
<div class="line"><span class="lineno">  827</span>            <span class="keywordflow">if</span> array.dtypes.apply(is_sparse).all():</div>
<div class="line"><span class="lineno">  828</span>                <span class="comment"># DataFrame.sparse only supports `to_coo`</span></div>
<div class="line"><span class="lineno">  829</span>                array = array.sparse.to_coo()</div>
<div class="line"><span class="lineno">  830</span>                <span class="keywordflow">if</span> array.dtype == np.dtype(<span class="stringliteral">&quot;object&quot;</span>):</div>
<div class="line"><span class="lineno">  831</span>                    unique_dtypes = set([dt.subtype.name <span class="keywordflow">for</span> dt <span class="keywordflow">in</span> array_orig.dtypes])</div>
<div class="line"><span class="lineno">  832</span>                    <span class="keywordflow">if</span> len(unique_dtypes) &gt; 1:</div>
<div class="line"><span class="lineno">  833</span>                        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  834</span>                            <span class="stringliteral">&quot;Pandas DataFrame with mixed sparse extension arrays &quot;</span></div>
<div class="line"><span class="lineno">  835</span>                            <span class="stringliteral">&quot;generated a sparse matrix with object dtype which &quot;</span></div>
<div class="line"><span class="lineno">  836</span>                            <span class="stringliteral">&quot;can not be converted to a scipy sparse matrix.&quot;</span></div>
<div class="line"><span class="lineno">  837</span>                            <span class="stringliteral">&quot;Sparse extension arrays should all have the same &quot;</span></div>
<div class="line"><span class="lineno">  838</span>                            <span class="stringliteral">&quot;numeric type.&quot;</span></div>
<div class="line"><span class="lineno">  839</span>                        )</div>
<div class="line"><span class="lineno">  840</span> </div>
<div class="line"><span class="lineno">  841</span>    <span class="keywordflow">if</span> sp.issparse(array):</div>
<div class="line"><span class="lineno">  842</span>        _ensure_no_complex_data(array)</div>
<div class="line"><span class="lineno">  843</span>        array = _ensure_sparse_format(</div>
<div class="line"><span class="lineno">  844</span>            array,</div>
<div class="line"><span class="lineno">  845</span>            accept_sparse=accept_sparse,</div>
<div class="line"><span class="lineno">  846</span>            dtype=dtype,</div>
<div class="line"><span class="lineno">  847</span>            copy=copy,</div>
<div class="line"><span class="lineno">  848</span>            force_all_finite=force_all_finite,</div>
<div class="line"><span class="lineno">  849</span>            accept_large_sparse=accept_large_sparse,</div>
<div class="line"><span class="lineno">  850</span>            estimator_name=estimator_name,</div>
<div class="line"><span class="lineno">  851</span>            input_name=input_name,</div>
<div class="line"><span class="lineno">  852</span>        )</div>
<div class="line"><span class="lineno">  853</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  854</span>        <span class="comment"># If np.array(..) gives ComplexWarning, then we convert the warning</span></div>
<div class="line"><span class="lineno">  855</span>        <span class="comment"># to an error. This is needed because specifying a non complex</span></div>
<div class="line"><span class="lineno">  856</span>        <span class="comment"># dtype to the function converts complex to real dtype,</span></div>
<div class="line"><span class="lineno">  857</span>        <span class="comment"># thereby passing the test made in the lines following the scope</span></div>
<div class="line"><span class="lineno">  858</span>        <span class="comment"># of warnings context manager.</span></div>
<div class="line"><span class="lineno">  859</span>        <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno">  860</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  861</span>                warnings.simplefilter(<span class="stringliteral">&quot;error&quot;</span>, ComplexWarning)</div>
<div class="line"><span class="lineno">  862</span>                <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> np.dtype(dtype).kind <span class="keywordflow">in</span> <span class="stringliteral">&quot;iu&quot;</span>:</div>
<div class="line"><span class="lineno">  863</span>                    <span class="comment"># Conversion float -&gt; int should not contain NaN or</span></div>
<div class="line"><span class="lineno">  864</span>                    <span class="comment"># inf (numpy#14412). We cannot use casting=&#39;safe&#39; because</span></div>
<div class="line"><span class="lineno">  865</span>                    <span class="comment"># then conversion float -&gt; int would be disallowed.</span></div>
<div class="line"><span class="lineno">  866</span>                    array = _asarray_with_order(array, order=order, xp=xp)</div>
<div class="line"><span class="lineno">  867</span>                    <span class="keywordflow">if</span> array.dtype.kind == <span class="stringliteral">&quot;f&quot;</span>:</div>
<div class="line"><span class="lineno">  868</span>                        _assert_all_finite(</div>
<div class="line"><span class="lineno">  869</span>                            array,</div>
<div class="line"><span class="lineno">  870</span>                            allow_nan=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  871</span>                            msg_dtype=dtype,</div>
<div class="line"><span class="lineno">  872</span>                            estimator_name=estimator_name,</div>
<div class="line"><span class="lineno">  873</span>                            input_name=input_name,</div>
<div class="line"><span class="lineno">  874</span>                        )</div>
<div class="line"><span class="lineno">  875</span>                    array = xp.astype(array, dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  876</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  877</span>                    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)</div>
<div class="line"><span class="lineno">  878</span>            <span class="keywordflow">except</span> ComplexWarning <span class="keyword">as</span> complex_warning:</div>
<div class="line"><span class="lineno">  879</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  880</span>                    <span class="stringliteral">&quot;Complex data not supported\n{}\n&quot;</span>.format(array)</div>
<div class="line"><span class="lineno">  881</span>                ) <span class="keyword">from</span> complex_warning</div>
<div class="line"><span class="lineno">  882</span> </div>
<div class="line"><span class="lineno">  883</span>        <span class="comment"># It is possible that the np.array(..) gave no warning. This happens</span></div>
<div class="line"><span class="lineno">  884</span>        <span class="comment"># when no dtype conversion happened, for example dtype = None. The</span></div>
<div class="line"><span class="lineno">  885</span>        <span class="comment"># result is that np.array(..) produces an array of complex dtype</span></div>
<div class="line"><span class="lineno">  886</span>        <span class="comment"># and we need to catch and raise exception for such cases.</span></div>
<div class="line"><span class="lineno">  887</span>        _ensure_no_complex_data(array)</div>
<div class="line"><span class="lineno">  888</span> </div>
<div class="line"><span class="lineno">  889</span>        <span class="keywordflow">if</span> ensure_2d:</div>
<div class="line"><span class="lineno">  890</span>            <span class="comment"># If input is scalar raise error</span></div>
<div class="line"><span class="lineno">  891</span>            <span class="keywordflow">if</span> array.ndim == 0:</div>
<div class="line"><span class="lineno">  892</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  893</span>                    <span class="stringliteral">&quot;Expected 2D array, got scalar array instead:\narray={}.\n&quot;</span></div>
<div class="line"><span class="lineno">  894</span>                    <span class="stringliteral">&quot;Reshape your data either using array.reshape(-1, 1) if &quot;</span></div>
<div class="line"><span class="lineno">  895</span>                    <span class="stringliteral">&quot;your data has a single feature or array.reshape(1, -1) &quot;</span></div>
<div class="line"><span class="lineno">  896</span>                    <span class="stringliteral">&quot;if it contains a single sample.&quot;</span>.format(array)</div>
<div class="line"><span class="lineno">  897</span>                )</div>
<div class="line"><span class="lineno">  898</span>            <span class="comment"># If input is 1D raise error</span></div>
<div class="line"><span class="lineno">  899</span>            <span class="keywordflow">if</span> array.ndim == 1:</div>
<div class="line"><span class="lineno">  900</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  901</span>                    <span class="stringliteral">&quot;Expected 2D array, got 1D array instead:\narray={}.\n&quot;</span></div>
<div class="line"><span class="lineno">  902</span>                    <span class="stringliteral">&quot;Reshape your data either using array.reshape(-1, 1) if &quot;</span></div>
<div class="line"><span class="lineno">  903</span>                    <span class="stringliteral">&quot;your data has a single feature or array.reshape(1, -1) &quot;</span></div>
<div class="line"><span class="lineno">  904</span>                    <span class="stringliteral">&quot;if it contains a single sample.&quot;</span>.format(array)</div>
<div class="line"><span class="lineno">  905</span>                )</div>
<div class="line"><span class="lineno">  906</span> </div>
<div class="line"><span class="lineno">  907</span>        <span class="keywordflow">if</span> dtype_numeric <span class="keywordflow">and</span> array.dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&quot;USV&quot;</span>:</div>
<div class="line"><span class="lineno">  908</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  909</span>                <span class="stringliteral">&quot;dtype=&#39;numeric&#39; is not compatible with arrays of bytes/strings.&quot;</span></div>
<div class="line"><span class="lineno">  910</span>                <span class="stringliteral">&quot;Convert your data to numeric values explicitly instead.&quot;</span></div>
<div class="line"><span class="lineno">  911</span>            )</div>
<div class="line"><span class="lineno">  912</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> allow_nd <span class="keywordflow">and</span> array.ndim &gt;= 3:</div>
<div class="line"><span class="lineno">  913</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  914</span>                <span class="stringliteral">&quot;Found array with dim %d. %s expected &lt;= 2.&quot;</span></div>
<div class="line"><span class="lineno">  915</span>                % (array.ndim, estimator_name)</div>
<div class="line"><span class="lineno">  916</span>            )</div>
<div class="line"><span class="lineno">  917</span> </div>
<div class="line"><span class="lineno">  918</span>        <span class="keywordflow">if</span> force_all_finite:</div>
<div class="line"><span class="lineno">  919</span>            _assert_all_finite(</div>
<div class="line"><span class="lineno">  920</span>                array,</div>
<div class="line"><span class="lineno">  921</span>                input_name=input_name,</div>
<div class="line"><span class="lineno">  922</span>                estimator_name=estimator_name,</div>
<div class="line"><span class="lineno">  923</span>                allow_nan=force_all_finite == <span class="stringliteral">&quot;allow-nan&quot;</span>,</div>
<div class="line"><span class="lineno">  924</span>            )</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span>    <span class="keywordflow">if</span> ensure_min_samples &gt; 0:</div>
<div class="line"><span class="lineno">  927</span>        n_samples = _num_samples(array)</div>
<div class="line"><span class="lineno">  928</span>        <span class="keywordflow">if</span> n_samples &lt; ensure_min_samples:</div>
<div class="line"><span class="lineno">  929</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  930</span>                <span class="stringliteral">&quot;Found array with %d sample(s) (shape=%s) while a&quot;</span></div>
<div class="line"><span class="lineno">  931</span>                <span class="stringliteral">&quot; minimum of %d is required%s.&quot;</span></div>
<div class="line"><span class="lineno">  932</span>                % (n_samples, array.shape, ensure_min_samples, context)</div>
<div class="line"><span class="lineno">  933</span>            )</div>
<div class="line"><span class="lineno">  934</span> </div>
<div class="line"><span class="lineno">  935</span>    <span class="keywordflow">if</span> ensure_min_features &gt; 0 <span class="keywordflow">and</span> array.ndim == 2:</div>
<div class="line"><span class="lineno">  936</span>        n_features = array.shape[1]</div>
<div class="line"><span class="lineno">  937</span>        <span class="keywordflow">if</span> n_features &lt; ensure_min_features:</div>
<div class="line"><span class="lineno">  938</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  939</span>                <span class="stringliteral">&quot;Found array with %d feature(s) (shape=%s) while&quot;</span></div>
<div class="line"><span class="lineno">  940</span>                <span class="stringliteral">&quot; a minimum of %d is required%s.&quot;</span></div>
<div class="line"><span class="lineno">  941</span>                % (n_features, array.shape, ensure_min_features, context)</div>
<div class="line"><span class="lineno">  942</span>            )</div>
<div class="line"><span class="lineno">  943</span> </div>
<div class="line"><span class="lineno">  944</span>    <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno">  945</span>        <span class="keywordflow">if</span> xp.__name__ <span class="keywordflow">in</span> {<span class="stringliteral">&quot;numpy&quot;</span>, <span class="stringliteral">&quot;numpy.array_api&quot;</span>}:</div>
<div class="line"><span class="lineno">  946</span>            <span class="comment"># only make a copy if `array` and `array_orig` may share memory`</span></div>
<div class="line"><span class="lineno">  947</span>            <span class="keywordflow">if</span> np.may_share_memory(array, array_orig):</div>
<div class="line"><span class="lineno">  948</span>                array = _asarray_with_order(</div>
<div class="line"><span class="lineno">  949</span>                    array, dtype=dtype, order=order, copy=<span class="keyword">True</span>, xp=xp</div>
<div class="line"><span class="lineno">  950</span>                )</div>
<div class="line"><span class="lineno">  951</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  952</span>            <span class="comment"># always make a copy for non-numpy arrays</span></div>
<div class="line"><span class="lineno">  953</span>            array = _asarray_with_order(</div>
<div class="line"><span class="lineno">  954</span>                array, dtype=dtype, order=order, copy=<span class="keyword">True</span>, xp=xp</div>
<div class="line"><span class="lineno">  955</span>            )</div>
<div class="line"><span class="lineno">  956</span> </div>
<div class="line"><span class="lineno">  957</span>    <span class="keywordflow">return</span> array</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d76ca8a780f1b9df7f975d307e28dc8" name="a3d76ca8a780f1b9df7f975d307e28dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d76ca8a780f1b9df7f975d307e28dc8">&#9670;&#160;</a></span>check_consistent_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_consistent_length </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that all arrays have consistent first dimensions.

Checks whether all objects in arrays have the same shape or length.

Parameters
----------
*arrays : list or tuple of input objects.
    Objects that will be checked for consistent length.
</pre> <div class="fragment"><div class="line"><span class="lineno">  383</span><span class="keyword">def </span>check_consistent_length(*arrays):</div>
<div class="line"><span class="lineno">  384</span>    <span class="stringliteral">&quot;&quot;&quot;Check that all arrays have consistent first dimensions.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    Checks whether all objects in arrays have the same shape or length.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    *arrays : list or tuple of input objects.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        Objects that will be checked for consistent length.</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  393</span> </div>
<div class="line"><span class="lineno">  394</span>    lengths = [_num_samples(X) <span class="keywordflow">for</span> X <span class="keywordflow">in</span> arrays <span class="keywordflow">if</span> X <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno">  395</span>    uniques = np.unique(lengths)</div>
<div class="line"><span class="lineno">  396</span>    <span class="keywordflow">if</span> len(uniques) &gt; 1:</div>
<div class="line"><span class="lineno">  397</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  398</span>            <span class="stringliteral">&quot;Found input variables with inconsistent numbers of samples: %r&quot;</span></div>
<div class="line"><span class="lineno">  399</span>            % [int(l) <span class="keywordflow">for</span> l <span class="keywordflow">in</span> lengths]</div>
<div class="line"><span class="lineno">  400</span>        )</div>
<div class="line"><span class="lineno">  401</span> </div>
<div class="line"><span class="lineno">  402</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae62ae60044363a1a546da93c2bd89ac2" name="ae62ae60044363a1a546da93c2bd89ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62ae60044363a1a546da93c2bd89ac2">&#9670;&#160;</a></span>check_is_fitted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_is_fitted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>msg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_or_any</em> = <code>all</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform is_fitted validation for estimator.

Checks if the estimator is fitted by verifying the presence of
fitted attributes (ending with a trailing underscore) and otherwise
raises a NotFittedError with the given message.

If an estimator does not set any attributes with a trailing underscore, it
can define a ``__sklearn_is_fitted__`` method returning a boolean to specify if the
estimator is fitted or not.

Parameters
----------
estimator : estimator instance
    Estimator instance for which the check is performed.

attributes : str, list or tuple of str, default=None
    Attribute name(s) given as string or a list/tuple of strings
    Eg.: ``["coef_", "estimator_", ...], "coef_"``

    If `None`, `estimator` is considered fitted if there exist an
    attribute that ends with a underscore and does not start with double
    underscore.

msg : str, default=None
    The default error message is, "This %(name)s instance is not fitted
    yet. Call 'fit' with appropriate arguments before using this
    estimator."

    For custom messages if "%(name)s" is present in the message string,
    it is substituted for the estimator name.

    Eg. : "Estimator, %(name)s, must be fitted before sparsifying".

all_or_any : callable, {all, any}, default=all
    Specify whether all or any of the given attributes must exist.

Raises
------
TypeError
    If the estimator is a class or not an estimator instance

NotFittedError
    If the attributes are not found.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1312</span><span class="keyword">def </span>check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):</div>
<div class="line"><span class="lineno"> 1313</span>    <span class="stringliteral">&quot;&quot;&quot;Perform is_fitted validation for estimator.</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    Checks if the estimator is fitted by verifying the presence of</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    fitted attributes (ending with a trailing underscore) and otherwise</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    raises a NotFittedError with the given message.</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    If an estimator does not set any attributes with a trailing underscore, it</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    can define a ``__sklearn_is_fitted__`` method returning a boolean to specify if the</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    estimator is fitted or not.</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    estimator : estimator instance</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">        Estimator instance for which the check is performed.</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    attributes : str, list or tuple of str, default=None</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">        Attribute name(s) given as string or a list/tuple of strings</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">        Eg.: ``[&quot;coef_&quot;, &quot;estimator_&quot;, ...], &quot;coef_&quot;``</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">        If `None`, `estimator` is considered fitted if there exist an</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">        attribute that ends with a underscore and does not start with double</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">        underscore.</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    msg : str, default=None</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">        The default error message is, &quot;This %(name)s instance is not fitted</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">        yet. Call &#39;fit&#39; with appropriate arguments before using this</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">        estimator.&quot;</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        For custom messages if &quot;%(name)s&quot; is present in the message string,</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">        it is substituted for the estimator name.</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">        Eg. : &quot;Estimator, %(name)s, must be fitted before sparsifying&quot;.</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    all_or_any : callable, {all, any}, default=all</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">        Specify whether all or any of the given attributes must exist.</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">        If the estimator is a class or not an estimator instance</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    NotFittedError</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">        If the attributes are not found.</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1357</span>    <span class="keywordflow">if</span> isclass(estimator):</div>
<div class="line"><span class="lineno"> 1358</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;{} is a class, not an instance.&quot;</span>.format(estimator))</div>
<div class="line"><span class="lineno"> 1359</span>    <span class="keywordflow">if</span> msg <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1360</span>        msg = (</div>
<div class="line"><span class="lineno"> 1361</span>            <span class="stringliteral">&quot;This %(name)s instance is not fitted yet. Call &#39;fit&#39; with &quot;</span></div>
<div class="line"><span class="lineno"> 1362</span>            <span class="stringliteral">&quot;appropriate arguments before using this estimator.&quot;</span></div>
<div class="line"><span class="lineno"> 1363</span>        )</div>
<div class="line"><span class="lineno"> 1364</span> </div>
<div class="line"><span class="lineno"> 1365</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(estimator, <span class="stringliteral">&quot;fit&quot;</span>):</div>
<div class="line"><span class="lineno"> 1366</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;%s is not an estimator instance.&quot;</span> % (estimator))</div>
<div class="line"><span class="lineno"> 1367</span> </div>
<div class="line"><span class="lineno"> 1368</span>    <span class="keywordflow">if</span> attributes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1369</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(attributes, (list, tuple)):</div>
<div class="line"><span class="lineno"> 1370</span>            attributes = [attributes]</div>
<div class="line"><span class="lineno"> 1371</span>        fitted = all_or_any([hasattr(estimator, attr) <span class="keywordflow">for</span> attr <span class="keywordflow">in</span> attributes])</div>
<div class="line"><span class="lineno"> 1372</span>    <span class="keywordflow">elif</span> hasattr(estimator, <span class="stringliteral">&quot;__sklearn_is_fitted__&quot;</span>):</div>
<div class="line"><span class="lineno"> 1373</span>        fitted = estimator.__sklearn_is_fitted__()</div>
<div class="line"><span class="lineno"> 1374</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1375</span>        fitted = [</div>
<div class="line"><span class="lineno"> 1376</span>            v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> vars(estimator) <span class="keywordflow">if</span> v.endswith(<span class="stringliteral">&quot;_&quot;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> v.startswith(<span class="stringliteral">&quot;__&quot;</span>)</div>
<div class="line"><span class="lineno"> 1377</span>        ]</div>
<div class="line"><span class="lineno"> 1378</span> </div>
<div class="line"><span class="lineno"> 1379</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> fitted:</div>
<div class="line"><span class="lineno"> 1380</span>        <span class="keywordflow">raise</span> NotFittedError(msg % {<span class="stringliteral">&quot;name&quot;</span>: type(estimator).__name__})</div>
<div class="line"><span class="lineno"> 1381</span> </div>
<div class="line"><span class="lineno"> 1382</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab472519c2e841a2531e0a8dc3b9fbd64" name="ab472519c2e841a2531e0a8dc3b9fbd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab472519c2e841a2531e0a8dc3b9fbd64">&#9670;&#160;</a></span>check_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_memory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that ``memory`` is joblib.Memory-like.

joblib.Memory-like means that ``memory`` can be converted into a
joblib.Memory instance (typically a str denoting the ``location``)
or has the same interface (has a ``cache`` method).

Parameters
----------
memory : None, str or object with the joblib.Memory interface
    - If string, the location where to create the `joblib.Memory` interface.
    - If None, no caching is done and the Memory object is completely transparent.

Returns
-------
memory : object with the joblib.Memory interface
    A correct joblib.Memory object.

Raises
------
ValueError
    If ``memory`` is not joblib.Memory-like.
</pre> <div class="fragment"><div class="line"><span class="lineno">  349</span><span class="keyword">def </span>check_memory(memory):</div>
<div class="line"><span class="lineno">  350</span>    <span class="stringliteral">&quot;&quot;&quot;Check that ``memory`` is joblib.Memory-like.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    joblib.Memory-like means that ``memory`` can be converted into a</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    joblib.Memory instance (typically a str denoting the ``location``)</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    or has the same interface (has a ``cache`` method).</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    memory : None, str or object with the joblib.Memory interface</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">        - If string, the location where to create the `joblib.Memory` interface.</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        - If None, no caching is done and the Memory object is completely transparent.</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    memory : object with the joblib.Memory interface</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">        A correct joblib.Memory object.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">        If ``memory`` is not joblib.Memory-like.</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  372</span>    <span class="keywordflow">if</span> memory <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> isinstance(memory, str):</div>
<div class="line"><span class="lineno">  373</span>        memory = <a class="code hl_class" href="classjoblib_1_1memory_1_1_memory.html">joblib.Memory</a>(location=memory, verbose=0)</div>
<div class="line"><span class="lineno">  374</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> hasattr(memory, <span class="stringliteral">&quot;cache&quot;</span>):</div>
<div class="line"><span class="lineno">  375</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  376</span>            <span class="stringliteral">&quot;&#39;memory&#39; should be None, a string or have the same&quot;</span></div>
<div class="line"><span class="lineno">  377</span>            <span class="stringliteral">&quot; interface as joblib.Memory.&quot;</span></div>
<div class="line"><span class="lineno">  378</span>            <span class="stringliteral">&quot; Got memory=&#39;{}&#39; instead.&quot;</span>.format(memory)</div>
<div class="line"><span class="lineno">  379</span>        )</div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">return</span> memory</div>
<div class="line"><span class="lineno">  381</span> </div>
<div class="line"><span class="lineno">  382</span> </div>
<div class="ttc" id="aclassjoblib_1_1memory_1_1_memory_html"><div class="ttname"><a href="classjoblib_1_1memory_1_1_memory.html">joblib.memory.Memory</a></div><div class="ttdef"><b>Definition</b> memory.py:856</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a219a80672df078db2c451d95db8833ee" name="a219a80672df078db2c451d95db8833ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219a80672df078db2c451d95db8833ee">&#9670;&#160;</a></span>check_non_negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_non_negative </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>whom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if there is any negative value in an array.

Parameters
----------
X : {array-like, sparse matrix}
    Input data.

whom : str
    Who passed X to this function.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1383</span><span class="keyword">def </span>check_non_negative(X, whom):</div>
<div class="line"><span class="lineno"> 1384</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    Check if there is any negative value in an array.</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    X : {array-like, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">    whom : str</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">        Who passed X to this function.</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1395</span>    xp, _ = get_namespace(X)</div>
<div class="line"><span class="lineno"> 1396</span>    <span class="comment"># avoid X.min() on sparse matrix since it also sorts the indices</span></div>
<div class="line"><span class="lineno"> 1397</span>    <span class="keywordflow">if</span> sp.issparse(X):</div>
<div class="line"><span class="lineno"> 1398</span>        <span class="keywordflow">if</span> X.format <span class="keywordflow">in</span> [<span class="stringliteral">&quot;lil&quot;</span>, <span class="stringliteral">&quot;dok&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1399</span>            X = X.tocsr()</div>
<div class="line"><span class="lineno"> 1400</span>        <span class="keywordflow">if</span> X.data.size == 0:</div>
<div class="line"><span class="lineno"> 1401</span>            X_min = 0</div>
<div class="line"><span class="lineno"> 1402</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1403</span>            X_min = X.data.min()</div>
<div class="line"><span class="lineno"> 1404</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1405</span>        X_min = xp.min(X)</div>
<div class="line"><span class="lineno"> 1406</span> </div>
<div class="line"><span class="lineno"> 1407</span>    <span class="keywordflow">if</span> X_min &lt; 0:</div>
<div class="line"><span class="lineno"> 1408</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Negative values in data passed to %s&quot;</span> % whom)</div>
<div class="line"><span class="lineno"> 1409</span> </div>
<div class="line"><span class="lineno"> 1410</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02e9f59100d50fa74df40218a4de1471" name="a02e9f59100d50fa74df40218a4de1471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e9f59100d50fa74df40218a4de1471">&#9670;&#160;</a></span>check_random_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_random_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Turn seed into a np.random.RandomState instance.

Parameters
----------
seed : None, int or instance of RandomState
    If seed is None, return the RandomState singleton used by np.random.
    If seed is an int, return a new RandomState instance seeded with seed.
    If seed is already a RandomState instance, return it.
    Otherwise raise ValueError.

Returns
-------
:class:`numpy:numpy.random.RandomState`
    The random state object based on `seed` parameter.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1197</span><span class="keyword">def </span>check_random_state(seed):</div>
<div class="line"><span class="lineno"> 1198</span>    <span class="stringliteral">&quot;&quot;&quot;Turn seed into a np.random.RandomState instance.</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    seed : None, int or instance of RandomState</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">        If seed is None, return the RandomState singleton used by np.random.</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">        If seed is an int, return a new RandomState instance seeded with seed.</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">        If seed is already a RandomState instance, return it.</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">        Otherwise raise ValueError.</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    :class:`numpy:numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">        The random state object based on `seed` parameter.</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1213</span>    <span class="keywordflow">if</span> seed <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> seed <span class="keywordflow">is</span> np.random:</div>
<div class="line"><span class="lineno"> 1214</span>        <span class="keywordflow">return</span> np.random.mtrand._rand</div>
<div class="line"><span class="lineno"> 1215</span>    <span class="keywordflow">if</span> isinstance(seed, numbers.Integral):</div>
<div class="line"><span class="lineno"> 1216</span>        <span class="keywordflow">return</span> np.random.RandomState(seed)</div>
<div class="line"><span class="lineno"> 1217</span>    <span class="keywordflow">if</span> isinstance(seed, np.random.RandomState):</div>
<div class="line"><span class="lineno"> 1218</span>        <span class="keywordflow">return</span> seed</div>
<div class="line"><span class="lineno"> 1219</span>    <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1220</span>        <span class="stringliteral">&quot;%r cannot be used to seed a numpy.random.RandomState instance&quot;</span> % seed</div>
<div class="line"><span class="lineno"> 1221</span>    )</div>
<div class="line"><span class="lineno"> 1222</span> </div>
<div class="line"><span class="lineno"> 1223</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2dc729f787899d05dd3469fd181ce02a" name="a2dc729f787899d05dd3469fd181ce02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc729f787899d05dd3469fd181ce02a">&#9670;&#160;</a></span>check_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>min_val</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_val</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>include_boundaries</em> = <code>&quot;both&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validate scalar parameters type and value.

Parameters
----------
x : object
    The scalar parameter to validate.

name : str
    The name of the parameter to be printed in error messages.

target_type : type or tuple
    Acceptable data types for the parameter.

min_val : float or int, default=None
    The minimum valid value the parameter can take. If None (default) it
    is implied that the parameter does not have a lower bound.

max_val : float or int, default=None
    The maximum valid value the parameter can take. If None (default) it
    is implied that the parameter does not have an upper bound.

include_boundaries : {"left", "right", "both", "neither"}, default="both"
    Whether the interval defined by `min_val` and `max_val` should include
    the boundaries. Possible choices are:

    - `"left"`: only `min_val` is included in the valid interval.
      It is equivalent to the interval `[ min_val, max_val )`.
    - `"right"`: only `max_val` is included in the valid interval.
      It is equivalent to the interval `( min_val, max_val ]`.
    - `"both"`: `min_val` and `max_val` are included in the valid interval.
      It is equivalent to the interval `[ min_val, max_val ]`.
    - `"neither"`: neither `min_val` nor `max_val` are included in the
      valid interval. It is equivalent to the interval `( min_val, max_val )`.

Returns
-------
x : numbers.Number
    The validated number.

Raises
------
TypeError
    If the parameter's type does not match the desired type.

ValueError
    If the parameter's value violates the given bounds.
    If `min_val`, `max_val` and `include_boundaries` are inconsistent.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1419</span>):</div>
<div class="line"><span class="lineno"> 1420</span>    <span class="stringliteral">&quot;&quot;&quot;Validate scalar parameters type and value.</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    x : object</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">        The scalar parameter to validate.</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    name : str</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">        The name of the parameter to be printed in error messages.</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    target_type : type or tuple</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">        Acceptable data types for the parameter.</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">    min_val : float or int, default=None</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">        The minimum valid value the parameter can take. If None (default) it</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">        is implied that the parameter does not have a lower bound.</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">    max_val : float or int, default=None</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">        The maximum valid value the parameter can take. If None (default) it</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">        is implied that the parameter does not have an upper bound.</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    include_boundaries : {&quot;left&quot;, &quot;right&quot;, &quot;both&quot;, &quot;neither&quot;}, default=&quot;both&quot;</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">        Whether the interval defined by `min_val` and `max_val` should include</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">        the boundaries. Possible choices are:</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">        - `&quot;left&quot;`: only `min_val` is included in the valid interval.</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">          It is equivalent to the interval `[ min_val, max_val )`.</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">        - `&quot;right&quot;`: only `max_val` is included in the valid interval.</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">          It is equivalent to the interval `( min_val, max_val ]`.</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">        - `&quot;both&quot;`: `min_val` and `max_val` are included in the valid interval.</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">          It is equivalent to the interval `[ min_val, max_val ]`.</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">        - `&quot;neither&quot;`: neither `min_val` nor `max_val` are included in the</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">          valid interval. It is equivalent to the interval `( min_val, max_val )`.</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">    x : numbers.Number</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">        The validated number.</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">        If the parameter&#39;s type does not match the desired type.</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">        If the parameter&#39;s value violates the given bounds.</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">        If `min_val`, `max_val` and `include_boundaries` are inconsistent.</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1468</span> </div>
<div class="line"><span class="lineno"> 1469</span>    <span class="keyword">def </span>type_name(t):</div>
<div class="line"><span class="lineno"> 1470</span>        <span class="stringliteral">&quot;&quot;&quot;Convert type into humman readable string.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1471</span>        module = t.__module__</div>
<div class="line"><span class="lineno"> 1472</span>        qualname = t.__qualname__</div>
<div class="line"><span class="lineno"> 1473</span>        <span class="keywordflow">if</span> module == <span class="stringliteral">&quot;builtins&quot;</span>:</div>
<div class="line"><span class="lineno"> 1474</span>            <span class="keywordflow">return</span> qualname</div>
<div class="line"><span class="lineno"> 1475</span>        <span class="keywordflow">elif</span> t == numbers.Real:</div>
<div class="line"><span class="lineno"> 1476</span>            <span class="keywordflow">return</span> <span class="stringliteral">&quot;float&quot;</span></div>
<div class="line"><span class="lineno"> 1477</span>        <span class="keywordflow">elif</span> t == numbers.Integral:</div>
<div class="line"><span class="lineno"> 1478</span>            <span class="keywordflow">return</span> <span class="stringliteral">&quot;int&quot;</span></div>
<div class="line"><span class="lineno"> 1479</span>        <span class="keywordflow">return</span> f<span class="stringliteral">&quot;{module}.{qualname}&quot;</span></div>
<div class="line"><span class="lineno"> 1480</span> </div>
<div class="line"><span class="lineno"> 1481</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(x, target_type):</div>
<div class="line"><span class="lineno"> 1482</span>        <span class="keywordflow">if</span> isinstance(target_type, tuple):</div>
<div class="line"><span class="lineno"> 1483</span>            types_str = <span class="stringliteral">&quot;, &quot;</span>.join(type_name(t) <span class="keywordflow">for</span> t <span class="keywordflow">in</span> target_type)</div>
<div class="line"><span class="lineno"> 1484</span>            target_type_str = f<span class="stringliteral">&quot;{{{types_str}}}&quot;</span></div>
<div class="line"><span class="lineno"> 1485</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1486</span>            target_type_str = type_name(target_type)</div>
<div class="line"><span class="lineno"> 1487</span> </div>
<div class="line"><span class="lineno"> 1488</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1489</span>            f<span class="stringliteral">&quot;{name} must be an instance of {target_type_str}, not&quot;</span></div>
<div class="line"><span class="lineno"> 1490</span>            f<span class="stringliteral">&quot; {type(x).__qualname__}.&quot;</span></div>
<div class="line"><span class="lineno"> 1491</span>        )</div>
<div class="line"><span class="lineno"> 1492</span> </div>
<div class="line"><span class="lineno"> 1493</span>    expected_include_boundaries = (<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;right&quot;</span>, <span class="stringliteral">&quot;both&quot;</span>, <span class="stringliteral">&quot;neither&quot;</span>)</div>
<div class="line"><span class="lineno"> 1494</span>    <span class="keywordflow">if</span> include_boundaries <span class="keywordflow">not</span> <span class="keywordflow">in</span> expected_include_boundaries:</div>
<div class="line"><span class="lineno"> 1495</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1496</span>            f<span class="stringliteral">&quot;Unknown value for `include_boundaries`: {repr(include_boundaries)}. &quot;</span></div>
<div class="line"><span class="lineno"> 1497</span>            f<span class="stringliteral">&quot;Possible values are: {expected_include_boundaries}.&quot;</span></div>
<div class="line"><span class="lineno"> 1498</span>        )</div>
<div class="line"><span class="lineno"> 1499</span> </div>
<div class="line"><span class="lineno"> 1500</span>    <span class="keywordflow">if</span> max_val <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> include_boundaries == <span class="stringliteral">&quot;right&quot;</span>:</div>
<div class="line"><span class="lineno"> 1501</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1502</span>            <span class="stringliteral">&quot;`include_boundaries`=&#39;right&#39; without specifying explicitly `max_val` &quot;</span></div>
<div class="line"><span class="lineno"> 1503</span>            <span class="stringliteral">&quot;is inconsistent.&quot;</span></div>
<div class="line"><span class="lineno"> 1504</span>        )</div>
<div class="line"><span class="lineno"> 1505</span> </div>
<div class="line"><span class="lineno"> 1506</span>    <span class="keywordflow">if</span> min_val <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> include_boundaries == <span class="stringliteral">&quot;left&quot;</span>:</div>
<div class="line"><span class="lineno"> 1507</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1508</span>            <span class="stringliteral">&quot;`include_boundaries`=&#39;left&#39; without specifying explicitly `min_val` &quot;</span></div>
<div class="line"><span class="lineno"> 1509</span>            <span class="stringliteral">&quot;is inconsistent.&quot;</span></div>
<div class="line"><span class="lineno"> 1510</span>        )</div>
<div class="line"><span class="lineno"> 1511</span> </div>
<div class="line"><span class="lineno"> 1512</span>    comparison_operator = (</div>
<div class="line"><span class="lineno"> 1513</span>        operator.lt <span class="keywordflow">if</span> include_boundaries <span class="keywordflow">in</span> (<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;both&quot;</span>) <span class="keywordflow">else</span> operator.le</div>
<div class="line"><span class="lineno"> 1514</span>    )</div>
<div class="line"><span class="lineno"> 1515</span>    <span class="keywordflow">if</span> min_val <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> comparison_operator(x, min_val):</div>
<div class="line"><span class="lineno"> 1516</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1517</span>            f<span class="stringliteral">&quot;{name} == {x}, must be&quot;</span></div>
<div class="line"><span class="lineno"> 1518</span>            f<span class="stringliteral">&quot; {&#39;&gt;=&#39; if include_boundaries in (&#39;left&#39;, &#39;both&#39;) else &#39;&gt;&#39;} {min_val}.&quot;</span></div>
<div class="line"><span class="lineno"> 1519</span>        )</div>
<div class="line"><span class="lineno"> 1520</span> </div>
<div class="line"><span class="lineno"> 1521</span>    comparison_operator = (</div>
<div class="line"><span class="lineno"> 1522</span>        operator.gt <span class="keywordflow">if</span> include_boundaries <span class="keywordflow">in</span> (<span class="stringliteral">&quot;right&quot;</span>, <span class="stringliteral">&quot;both&quot;</span>) <span class="keywordflow">else</span> operator.ge</div>
<div class="line"><span class="lineno"> 1523</span>    )</div>
<div class="line"><span class="lineno"> 1524</span>    <span class="keywordflow">if</span> max_val <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> comparison_operator(x, max_val):</div>
<div class="line"><span class="lineno"> 1525</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1526</span>            f<span class="stringliteral">&quot;{name} == {x}, must be&quot;</span></div>
<div class="line"><span class="lineno"> 1527</span>            f<span class="stringliteral">&quot; {&#39;&lt;=&#39; if include_boundaries in (&#39;right&#39;, &#39;both&#39;) else &#39;&lt;&#39;} {max_val}.&quot;</span></div>
<div class="line"><span class="lineno"> 1528</span>        )</div>
<div class="line"><span class="lineno"> 1529</span> </div>
<div class="line"><span class="lineno"> 1530</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 1531</span> </div>
<div class="line"><span class="lineno"> 1532</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f901fc41b1ee3c98df4c59b365495d2" name="a6f901fc41b1ee3c98df4c59b365495d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f901fc41b1ee3c98df4c59b365495d2">&#9670;&#160;</a></span>check_symmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_symmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>raise_warning</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>raise_exception</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make sure that array is 2D, square and symmetric.

If the array is not symmetric, then a symmetrized version is returned.
Optionally, a warning or exception is raised if the matrix is not
symmetric.

Parameters
----------
array : {ndarray, sparse matrix}
    Input object to check / convert. Must be two-dimensional and square,
    otherwise a ValueError will be raised.

tol : float, default=1e-10
    Absolute tolerance for equivalence of arrays. Default = 1E-10.

raise_warning : bool, default=True
    If True then raise a warning if conversion is required.

raise_exception : bool, default=False
    If True then raise an exception if array is not symmetric.

Returns
-------
array_sym : {ndarray, sparse matrix}
    Symmetrized version of the input array, i.e. the average of array
    and array.transpose(). If sparse, then duplicate entries are first
    summed and zeros are eliminated.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1251</span><span class="keyword">def </span>check_symmetric(array, *, tol=1e-10, raise_warning=True, raise_exception=False):</div>
<div class="line"><span class="lineno"> 1252</span>    <span class="stringliteral">&quot;&quot;&quot;Make sure that array is 2D, square and symmetric.</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    If the array is not symmetric, then a symmetrized version is returned.</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    Optionally, a warning or exception is raised if the matrix is not</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    symmetric.</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    array : {ndarray, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">        Input object to check / convert. Must be two-dimensional and square,</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">        otherwise a ValueError will be raised.</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    tol : float, default=1e-10</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">        Absolute tolerance for equivalence of arrays. Default = 1E-10.</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">    raise_warning : bool, default=True</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        If True then raise a warning if conversion is required.</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    raise_exception : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">        If True then raise an exception if array is not symmetric.</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">    array_sym : {ndarray, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">        Symmetrized version of the input array, i.e. the average of array</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">        and array.transpose(). If sparse, then duplicate entries are first</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">        summed and zeros are eliminated.</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1280</span>    <span class="keywordflow">if</span> (array.ndim != 2) <span class="keywordflow">or</span> (array.shape[0] != array.shape[1]):</div>
<div class="line"><span class="lineno"> 1281</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1282</span>            <span class="stringliteral">&quot;array must be 2-dimensional and square. shape = {0}&quot;</span>.format(array.shape)</div>
<div class="line"><span class="lineno"> 1283</span>        )</div>
<div class="line"><span class="lineno"> 1284</span> </div>
<div class="line"><span class="lineno"> 1285</span>    <span class="keywordflow">if</span> sp.issparse(array):</div>
<div class="line"><span class="lineno"> 1286</span>        diff = array - array.T</div>
<div class="line"><span class="lineno"> 1287</span>        <span class="comment"># only csr, csc, and coo have `data` attribute</span></div>
<div class="line"><span class="lineno"> 1288</span>        <span class="keywordflow">if</span> diff.format <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;csr&quot;</span>, <span class="stringliteral">&quot;csc&quot;</span>, <span class="stringliteral">&quot;coo&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1289</span>            diff = diff.tocsr()</div>
<div class="line"><span class="lineno"> 1290</span>        symmetric = np.all(abs(diff.data) &lt; tol)</div>
<div class="line"><span class="lineno"> 1291</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1292</span>        symmetric = np.allclose(array, array.T, atol=tol)</div>
<div class="line"><span class="lineno"> 1293</span> </div>
<div class="line"><span class="lineno"> 1294</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> symmetric:</div>
<div class="line"><span class="lineno"> 1295</span>        <span class="keywordflow">if</span> raise_exception:</div>
<div class="line"><span class="lineno"> 1296</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Array must be symmetric&quot;</span>)</div>
<div class="line"><span class="lineno"> 1297</span>        <span class="keywordflow">if</span> raise_warning:</div>
<div class="line"><span class="lineno"> 1298</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1299</span>                <span class="stringliteral">&quot;Array is not symmetric, and will be converted &quot;</span></div>
<div class="line"><span class="lineno"> 1300</span>                <span class="stringliteral">&quot;to symmetric by average with its transpose.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1301</span>                stacklevel=2,</div>
<div class="line"><span class="lineno"> 1302</span>            )</div>
<div class="line"><span class="lineno"> 1303</span>        <span class="keywordflow">if</span> sp.issparse(array):</div>
<div class="line"><span class="lineno"> 1304</span>            conversion = <span class="stringliteral">&quot;to&quot;</span> + array.format</div>
<div class="line"><span class="lineno"> 1305</span>            array = getattr(0.5 * (array + array.T), conversion)()</div>
<div class="line"><span class="lineno"> 1306</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1307</span>            array = 0.5 * (array + array.T)</div>
<div class="line"><span class="lineno"> 1308</span> </div>
<div class="line"><span class="lineno"> 1309</span>    <span class="keywordflow">return</span> array</div>
<div class="line"><span class="lineno"> 1310</span> </div>
<div class="line"><span class="lineno"> 1311</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aac632ce030bd7b0dc0d68a269acefc27" name="aac632ce030bd7b0dc0d68a269acefc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac632ce030bd7b0dc0d68a269acefc27">&#9670;&#160;</a></span>check_X_y()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.check_X_y </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accept_sparse</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>accept_large_sparse</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>&quot;numeric&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_all_finite</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensure_2d</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_nd</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multi_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensure_min_samples</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensure_min_features</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y_numeric</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Input validation for standard estimators.

Checks X and y for consistent length, enforces X to be 2D and y 1D. By
default, X is checked to be non-empty and containing only finite values.
Standard input checks are also applied to y, such as checking that y
does not have np.nan or np.inf targets. For multi-label y, set
multi_output=True to allow 2D and sparse y. If the dtype of X is
object, attempt converting to float, raising on failure.

Parameters
----------
X : {ndarray, list, sparse matrix}
    Input data.

y : {ndarray, list, sparse matrix}
    Labels.

accept_sparse : str, bool or list of str, default=False
    String[s] representing allowed sparse matrix formats, such as 'csc',
    'csr', etc. If the input is sparse but not in the allowed format,
    it will be converted to the first listed format. True allows the input
    to be any format. False means that a sparse matrix input will
    raise an error.

accept_large_sparse : bool, default=True
    If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
    accept_sparse, accept_large_sparse will cause it to be accepted only
    if its indices are stored with a 32-bit dtype.

    .. versionadded:: 0.20

dtype : 'numeric', type, list of type or None, default='numeric'
    Data type of result. If None, the dtype of the input is preserved.
    If "numeric", dtype is preserved unless array.dtype is object.
    If dtype is a list of types, conversion on the first type is only
    performed if the dtype of the input is not in the list.

order : {'F', 'C'}, default=None
    Whether an array will be forced to be fortran or c-style.

copy : bool, default=False
    Whether a forced copy will be triggered. If copy=False, a copy might
    be triggered by a conversion.

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in X. This parameter
    does not influence whether y can have np.inf, np.nan, pd.NA values.
    The possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan or pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 0.20
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`

ensure_2d : bool, default=True
    Whether to raise a value error if X is not 2D.

allow_nd : bool, default=False
    Whether to allow X.ndim &gt; 2.

multi_output : bool, default=False
    Whether to allow 2D y (array or sparse matrix). If false, y will be
    validated as a vector. y cannot have np.nan or np.inf values if
    multi_output=True.

ensure_min_samples : int, default=1
    Make sure that X has a minimum number of samples in its first
    axis (rows for a 2D array).

ensure_min_features : int, default=1
    Make sure that the 2D array has some minimum number of features
    (columns). The default value of 1 rejects empty datasets.
    This check is only enforced when X has effectively 2 dimensions or
    is originally 1D and ``ensure_2d`` is True. Setting to 0 disables
    this check.

y_numeric : bool, default=False
    Whether to ensure that y has a numeric type. If dtype of y is object,
    it is converted to float64. Should only be used for regression
    algorithms.

estimator : str or estimator instance, default=None
    If passed, include the name of the estimator in warning messages.

Returns
-------
X_converted : object
    The converted and validated X.

y_converted : object
    The converted and validated y.
</pre> <div class="fragment"><div class="line"><span class="lineno">  996</span>):</div>
<div class="line"><span class="lineno">  997</span>    <span class="stringliteral">&quot;&quot;&quot;Input validation for standard estimators.</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    Checks X and y for consistent length, enforces X to be 2D and y 1D. By</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    default, X is checked to be non-empty and containing only finite values.</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    Standard input checks are also applied to y, such as checking that y</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    does not have np.nan or np.inf targets. For multi-label y, set</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    multi_output=True to allow 2D and sparse y. If the dtype of X is</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    object, attempt converting to float, raising on failure.</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    X : {ndarray, list, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    y : {ndarray, list, sparse matrix}</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">        Labels.</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    accept_sparse : str, bool or list of str, default=False</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">        String[s] representing allowed sparse matrix formats, such as &#39;csc&#39;,</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">        &#39;csr&#39;, etc. If the input is sparse but not in the allowed format,</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        it will be converted to the first listed format. True allows the input</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">        to be any format. False means that a sparse matrix input will</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">        raise an error.</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    accept_large_sparse : bool, default=True</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">        accept_sparse, accept_large_sparse will cause it to be accepted only</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">        if its indices are stored with a 32-bit dtype.</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    dtype : &#39;numeric&#39;, type, list of type or None, default=&#39;numeric&#39;</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">        Data type of result. If None, the dtype of the input is preserved.</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">        If &quot;numeric&quot;, dtype is preserved unless array.dtype is object.</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">        If dtype is a list of types, conversion on the first type is only</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">        performed if the dtype of the input is not in the list.</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    order : {&#39;F&#39;, &#39;C&#39;}, default=None</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">        Whether an array will be forced to be fortran or c-style.</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    copy : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">        Whether a forced copy will be triggered. If copy=False, a copy might</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">        be triggered by a conversion.</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    force_all_finite : bool or &#39;allow-nan&#39;, default=True</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        Whether to raise an error on np.inf, np.nan, pd.NA in X. This parameter</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">        does not influence whether y can have np.inf, np.nan, pd.NA values.</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">        The possibilities are:</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        - True: Force all values of X to be finite.</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">        - False: accepts np.inf, np.nan, pd.NA in X.</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">        - &#39;allow-nan&#39;: accepts only np.nan or pd.NA values in X. Values cannot</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">          be infinite.</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">           ``force_all_finite`` accepts the string ``&#39;allow-nan&#39;``.</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">        .. versionchanged:: 0.23</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">           Accepts `pd.NA` and converts it into `np.nan`</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    ensure_2d : bool, default=True</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">        Whether to raise a value error if X is not 2D.</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    allow_nd : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">        Whether to allow X.ndim &gt; 2.</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">    multi_output : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        Whether to allow 2D y (array or sparse matrix). If false, y will be</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">        validated as a vector. y cannot have np.nan or np.inf values if</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">        multi_output=True.</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    ensure_min_samples : int, default=1</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">        Make sure that X has a minimum number of samples in its first</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">        axis (rows for a 2D array).</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    ensure_min_features : int, default=1</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">        Make sure that the 2D array has some minimum number of features</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">        (columns). The default value of 1 rejects empty datasets.</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        This check is only enforced when X has effectively 2 dimensions or</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        is originally 1D and ``ensure_2d`` is True. Setting to 0 disables</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">        this check.</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    y_numeric : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">        Whether to ensure that y has a numeric type. If dtype of y is object,</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">        it is converted to float64. Should only be used for regression</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">        algorithms.</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    estimator : str or estimator instance, default=None</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">        If passed, include the name of the estimator in warning messages.</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    X_converted : object</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">        The converted and validated X.</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    y_converted : object</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">        The converted and validated y.</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1095</span>    <span class="keywordflow">if</span> y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1096</span>        <span class="keywordflow">if</span> estimator <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1097</span>            estimator_name = <span class="stringliteral">&quot;estimator&quot;</span></div>
<div class="line"><span class="lineno"> 1098</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1099</span>            estimator_name = _check_estimator_name(estimator)</div>
<div class="line"><span class="lineno"> 1100</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1101</span>            f<span class="stringliteral">&quot;{estimator_name} requires y to be passed, but the target y is None&quot;</span></div>
<div class="line"><span class="lineno"> 1102</span>        )</div>
<div class="line"><span class="lineno"> 1103</span> </div>
<div class="line"><span class="lineno"> 1104</span>    X = check_array(</div>
<div class="line"><span class="lineno"> 1105</span>        X,</div>
<div class="line"><span class="lineno"> 1106</span>        accept_sparse=accept_sparse,</div>
<div class="line"><span class="lineno"> 1107</span>        accept_large_sparse=accept_large_sparse,</div>
<div class="line"><span class="lineno"> 1108</span>        dtype=dtype,</div>
<div class="line"><span class="lineno"> 1109</span>        order=order,</div>
<div class="line"><span class="lineno"> 1110</span>        copy=copy,</div>
<div class="line"><span class="lineno"> 1111</span>        force_all_finite=force_all_finite,</div>
<div class="line"><span class="lineno"> 1112</span>        ensure_2d=ensure_2d,</div>
<div class="line"><span class="lineno"> 1113</span>        allow_nd=allow_nd,</div>
<div class="line"><span class="lineno"> 1114</span>        ensure_min_samples=ensure_min_samples,</div>
<div class="line"><span class="lineno"> 1115</span>        ensure_min_features=ensure_min_features,</div>
<div class="line"><span class="lineno"> 1116</span>        estimator=estimator,</div>
<div class="line"><span class="lineno"> 1117</span>        input_name=<span class="stringliteral">&quot;X&quot;</span>,</div>
<div class="line"><span class="lineno"> 1118</span>    )</div>
<div class="line"><span class="lineno"> 1119</span> </div>
<div class="line"><span class="lineno"> 1120</span>    y = _check_y(y, multi_output=multi_output, y_numeric=y_numeric, estimator=estimator)</div>
<div class="line"><span class="lineno"> 1121</span> </div>
<div class="line"><span class="lineno"> 1122</span>    check_consistent_length(X, y)</div>
<div class="line"><span class="lineno"> 1123</span> </div>
<div class="line"><span class="lineno"> 1124</span>    <span class="keywordflow">return</span> X, y</div>
<div class="line"><span class="lineno"> 1125</span> </div>
<div class="line"><span class="lineno"> 1126</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9f60f7bf55522e1b6342d541ae018ac" name="ab9f60f7bf55522e1b6342d541ae018ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f60f7bf55522e1b6342d541ae018ac">&#9670;&#160;</a></span>column_or_1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.column_or_1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>warn</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ravel column or 1d numpy array, else raises an error.

Parameters
----------
y : array-like
   Input data.

dtype : data-type, default=None
    Data type for `y`.

    .. versionadded:: 1.2

warn : bool, default=False
   To control display of warnings.

Returns
-------
y : ndarray
   Output data.

Raises
------
ValueError
    If `y` is not a 1D array or a 2D array with a single row or column.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1150</span><span class="keyword">def </span>column_or_1d(y, *, dtype=None, warn=False):</div>
<div class="line"><span class="lineno"> 1151</span>    <span class="stringliteral">&quot;&quot;&quot;Ravel column or 1d numpy array, else raises an error.</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    y : array-like</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">       Input data.</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    dtype : data-type, default=None</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">        Data type for `y`.</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">        .. versionadded:: 1.2</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    warn : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">       To control display of warnings.</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">       Output data.</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">        If `y` is not a 1D array or a 2D array with a single row or column.</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1176</span>    xp, _ = get_namespace(y)</div>
<div class="line"><span class="lineno"> 1177</span>    y = xp.asarray(y, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1178</span>    shape = y.shape</div>
<div class="line"><span class="lineno"> 1179</span>    <span class="keywordflow">if</span> len(shape) == 1:</div>
<div class="line"><span class="lineno"> 1180</span>        <span class="keywordflow">return</span> _asarray_with_order(xp.reshape(y, -1), order=<span class="stringliteral">&quot;C&quot;</span>, xp=xp)</div>
<div class="line"><span class="lineno"> 1181</span>    <span class="keywordflow">if</span> len(shape) == 2 <span class="keywordflow">and</span> shape[1] == 1:</div>
<div class="line"><span class="lineno"> 1182</span>        <span class="keywordflow">if</span> warn:</div>
<div class="line"><span class="lineno"> 1183</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1184</span>                <span class="stringliteral">&quot;A column-vector y was passed when a 1d array was&quot;</span></div>
<div class="line"><span class="lineno"> 1185</span>                <span class="stringliteral">&quot; expected. Please change the shape of y to &quot;</span></div>
<div class="line"><span class="lineno"> 1186</span>                <span class="stringliteral">&quot;(n_samples, ), for example using ravel().&quot;</span>,</div>
<div class="line"><span class="lineno"> 1187</span>                DataConversionWarning,</div>
<div class="line"><span class="lineno"> 1188</span>                stacklevel=2,</div>
<div class="line"><span class="lineno"> 1189</span>            )</div>
<div class="line"><span class="lineno"> 1190</span>        <span class="keywordflow">return</span> _asarray_with_order(xp.reshape(y, -1), order=<span class="stringliteral">&quot;C&quot;</span>, xp=xp)</div>
<div class="line"><span class="lineno"> 1191</span> </div>
<div class="line"><span class="lineno"> 1192</span>    <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1193</span>        <span class="stringliteral">&quot;y should be a 1d array, got an array of shape {} instead.&quot;</span>.format(shape)</div>
<div class="line"><span class="lineno"> 1194</span>    )</div>
<div class="line"><span class="lineno"> 1195</span> </div>
<div class="line"><span class="lineno"> 1196</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4e26a6139a4438d6cb20d7df8e22627" name="ac4e26a6139a4438d6cb20d7df8e22627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e26a6139a4438d6cb20d7df8e22627">&#9670;&#160;</a></span>has_fit_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.has_fit_parameter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether the estimator's fit method supports the given parameter.

Parameters
----------
estimator : object
    An estimator to inspect.

parameter : str
    The searched parameter.

Returns
-------
is_parameter : bool
    Whether the parameter was found to be a named parameter of the
    estimator's fit method.

Examples
--------
&gt;&gt;&gt; from sklearn.svm import SVC
&gt;&gt;&gt; from sklearn.utils.validation import has_fit_parameter
&gt;&gt;&gt; has_fit_parameter(SVC(), "sample_weight")
True
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1224</span><span class="keyword">def </span>has_fit_parameter(estimator, parameter):</div>
<div class="line"><span class="lineno"> 1225</span>    <span class="stringliteral">&quot;&quot;&quot;Check whether the estimator&#39;s fit method supports the given parameter.</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    estimator : object</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">        An estimator to inspect.</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    parameter : str</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">        The searched parameter.</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">    is_parameter : bool</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">        Whether the parameter was found to be a named parameter of the</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">        estimator&#39;s fit method.</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.svm import SVC</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.utils.validation import has_fit_parameter</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    &gt;&gt;&gt; has_fit_parameter(SVC(), &quot;sample_weight&quot;)</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1248</span>    <span class="keywordflow">return</span> parameter <span class="keywordflow">in</span> signature(estimator.fit).parameters</div>
<div class="line"><span class="lineno"> 1249</span> </div>
<div class="line"><span class="lineno"> 1250</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a504b868d5db67011bff3ac38f2dbaf4e" name="a504b868d5db67011bff3ac38f2dbaf4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504b868d5db67011bff3ac38f2dbaf4e">&#9670;&#160;</a></span>indexable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.utils.validation.indexable </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make arrays indexable for cross-validation.

Checks consistent length, passes through None, and ensures that everything
can be indexed by converting sparse matrices to csr and converting
non-interable objects to arrays.

Parameters
----------
*iterables : {lists, dataframes, ndarrays, sparse matrices}
    List of objects to ensure sliceability.

Returns
-------
result : list of {ndarray, sparse matrix, dataframe} or None
    Returns a list containing indexable arrays (i.e. NumPy array,
    sparse matrix, or dataframe) or `None`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  423</span><span class="keyword">def </span>indexable(*iterables):</div>
<div class="line"><span class="lineno">  424</span>    <span class="stringliteral">&quot;&quot;&quot;Make arrays indexable for cross-validation.</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    Checks consistent length, passes through None, and ensures that everything</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    can be indexed by converting sparse matrices to csr and converting</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    non-interable objects to arrays.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    *iterables : {lists, dataframes, ndarrays, sparse matrices}</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        List of objects to ensure sliceability.</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    result : list of {ndarray, sparse matrix, dataframe} or None</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        Returns a list containing indexable arrays (i.e. NumPy array,</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        sparse matrix, or dataframe) or `None`.</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  441</span> </div>
<div class="line"><span class="lineno">  442</span>    result = [_make_indexable(X) <span class="keywordflow">for</span> X <span class="keywordflow">in</span> iterables]</div>
<div class="line"><span class="lineno">  443</span>    check_consistent_length(*result)</div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  445</span> </div>
<div class="line"><span class="lineno">  446</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6f695de28a35eaa5749b3ba2d290d83e" name="a6f695de28a35eaa5749b3ba2d290d83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f695de28a35eaa5749b3ba2d290d83e">&#9670;&#160;</a></span>FLOAT_DTYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple sklearn.utils.validation.FLOAT_DTYPES = (np.float64, np.float32, np.float16)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
