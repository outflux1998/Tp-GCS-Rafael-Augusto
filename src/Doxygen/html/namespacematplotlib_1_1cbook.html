<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.cbook Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1cbook.html">cbook</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.cbook Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1___ordered_set.html">_OrderedSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1___strong_ref.html">_StrongRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1_callback_registry.html">CallbackRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1_grouper.html">Grouper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1_grouper_view.html">GrouperView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1maxdict.html">maxdict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1silent__list.html">silent_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1cbook_1_1_stack.html">Stack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a82d17f813574add65a17202ef36063" id="r_a0a82d17f813574add65a17202ef36063"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a0a82d17f813574add65a17202ef36063">_get_running_interactive_framework</a> ()</td></tr>
<tr class="separator:a0a82d17f813574add65a17202ef36063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cd7ed2d0d8c7d6397ad493194605a9" id="r_a91cd7ed2d0d8c7d6397ad493194605a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a91cd7ed2d0d8c7d6397ad493194605a9">_exception_printer</a> (exc)</td></tr>
<tr class="separator:a91cd7ed2d0d8c7d6397ad493194605a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e39620ff7f937326c451e7a49a51177" id="r_a3e39620ff7f937326c451e7a49a51177"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a3e39620ff7f937326c451e7a49a51177">_weak_or_strong_ref</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, callback)</td></tr>
<tr class="separator:a3e39620ff7f937326c451e7a49a51177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f41a8134471986341d71d0012458cc7" id="r_a1f41a8134471986341d71d0012458cc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a1f41a8134471986341d71d0012458cc7">_local_over_kwdict</a> (local_var, kwargs, *keys, warning_cls=<a class="el" href="classmatplotlib_1_1__api_1_1deprecation_1_1_matplotlib_deprecation_warning.html">_api.MatplotlibDeprecationWarning</a>)</td></tr>
<tr class="separator:a1f41a8134471986341d71d0012458cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ea7c7c3361971b38b78d6e568e0025" id="r_aa1ea7c7c3361971b38b78d6e568e0025"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#aa1ea7c7c3361971b38b78d6e568e0025">strip_math</a> (s)</td></tr>
<tr class="separator:aa1ea7c7c3361971b38b78d6e568e0025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae261a6b14eaeac6086209c9ffcacd275" id="r_ae261a6b14eaeac6086209c9ffcacd275"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ae261a6b14eaeac6086209c9ffcacd275">_strip_comment</a> (s)</td></tr>
<tr class="separator:ae261a6b14eaeac6086209c9ffcacd275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818dda18d21f657aa92908e429b51c1f" id="r_a818dda18d21f657aa92908e429b51c1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a818dda18d21f657aa92908e429b51c1f">is_writable_file_like</a> (obj)</td></tr>
<tr class="separator:a818dda18d21f657aa92908e429b51c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca7e7ca86e08046948b3456e1a0b46b" id="r_a7ca7e7ca86e08046948b3456e1a0b46b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a7ca7e7ca86e08046948b3456e1a0b46b">file_requires_unicode</a> (x)</td></tr>
<tr class="separator:a7ca7e7ca86e08046948b3456e1a0b46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae466f3a4c5faca4911ec7caa9ab003dc" id="r_ae466f3a4c5faca4911ec7caa9ab003dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ae466f3a4c5faca4911ec7caa9ab003dc">to_filehandle</a> (fname, flag='<a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>', return_opened=False, encoding=None)</td></tr>
<tr class="separator:ae466f3a4c5faca4911ec7caa9ab003dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d5df85847a367d002b2711ed1663f0" id="r_aa7d5df85847a367d002b2711ed1663f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#aa7d5df85847a367d002b2711ed1663f0">open_file_cm</a> (path_or_file, mode=&quot;r&quot;, encoding=None)</td></tr>
<tr class="separator:aa7d5df85847a367d002b2711ed1663f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77164721afd81a2b73e8cc7502f72032" id="r_a77164721afd81a2b73e8cc7502f72032"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a77164721afd81a2b73e8cc7502f72032">is_scalar_or_string</a> (val)</td></tr>
<tr class="separator:a77164721afd81a2b73e8cc7502f72032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32a9279c159539e253e9e58f195c054" id="r_af32a9279c159539e253e9e58f195c054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#af32a9279c159539e253e9e58f195c054">get_sample_data</a> (fname, asfileobj=True, *np_load=False)</td></tr>
<tr class="separator:af32a9279c159539e253e9e58f195c054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a470632d0225fcb3bf9fa4c4a03337" id="r_a95a470632d0225fcb3bf9fa4c4a03337"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a95a470632d0225fcb3bf9fa4c4a03337">_get_data_path</a> (*args)</td></tr>
<tr class="separator:a95a470632d0225fcb3bf9fa4c4a03337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90545f359bbd7e521186d834ee7f0ddb" id="r_a90545f359bbd7e521186d834ee7f0ddb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a90545f359bbd7e521186d834ee7f0ddb">flatten</a> (seq, scalarp=<a class="el" href="namespacematplotlib_1_1cbook.html#a77164721afd81a2b73e8cc7502f72032">is_scalar_or_string</a>)</td></tr>
<tr class="separator:a90545f359bbd7e521186d834ee7f0ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299da0bfc3414c276418ed1808a93b4c" id="r_a299da0bfc3414c276418ed1808a93b4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a299da0bfc3414c276418ed1808a93b4c">report_memory</a> (<a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>=0)</td></tr>
<tr class="separator:a299da0bfc3414c276418ed1808a93b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf188d34bbfeb6fd34da4b60388cc88" id="r_aeaf188d34bbfeb6fd34da4b60388cc88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#aeaf188d34bbfeb6fd34da4b60388cc88">safe_masked_invalid</a> (x, copy=False)</td></tr>
<tr class="separator:aeaf188d34bbfeb6fd34da4b60388cc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701b0bb4c152d0bcc615bd421406293b" id="r_a701b0bb4c152d0bcc615bd421406293b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a701b0bb4c152d0bcc615bd421406293b">print_cycles</a> (objects, outstream=sys.stdout, show_progress=False)</td></tr>
<tr class="separator:a701b0bb4c152d0bcc615bd421406293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7009c1e775ac01e9aba6eb62178e8b30" id="r_a7009c1e775ac01e9aba6eb62178e8b30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a7009c1e775ac01e9aba6eb62178e8b30">simple_linear_interpolation</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, steps)</td></tr>
<tr class="separator:a7009c1e775ac01e9aba6eb62178e8b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0574192dc644b3f7276891b1a963b533" id="r_a0574192dc644b3f7276891b1a963b533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a0574192dc644b3f7276891b1a963b533">delete_masked_points</a> (*args)</td></tr>
<tr class="separator:a0574192dc644b3f7276891b1a963b533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5270a8424dda2fd671b3da53f10943" id="r_a8e5270a8424dda2fd671b3da53f10943"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a8e5270a8424dda2fd671b3da53f10943">_combine_masks</a> (*args)</td></tr>
<tr class="separator:a8e5270a8424dda2fd671b3da53f10943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b74e34e2ec3a6424c4b5d4e1fc2325" id="r_a52b74e34e2ec3a6424c4b5d4e1fc2325"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a52b74e34e2ec3a6424c4b5d4e1fc2325">boxplot_stats</a> (X, whis=1.5, bootstrap=None, labels=None, autorange=False)</td></tr>
<tr class="separator:a52b74e34e2ec3a6424c4b5d4e1fc2325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d76f664e49c525a81f696623093978" id="r_aa5d76f664e49c525a81f696623093978"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#aa5d76f664e49c525a81f696623093978">contiguous_regions</a> (mask)</td></tr>
<tr class="separator:aa5d76f664e49c525a81f696623093978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d892c39527908e25bc5bf1bb9414a1" id="r_ac9d892c39527908e25bc5bf1bb9414a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ac9d892c39527908e25bc5bf1bb9414a1">is_math_text</a> (s)</td></tr>
<tr class="separator:ac9d892c39527908e25bc5bf1bb9414a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad249e91f741a55f32f6bf9822b197af8" id="r_ad249e91f741a55f32f6bf9822b197af8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ad249e91f741a55f32f6bf9822b197af8">_to_unmasked_float_array</a> (x)</td></tr>
<tr class="separator:ad249e91f741a55f32f6bf9822b197af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0661f9b28354e95ce2551ac34d0a467b" id="r_a0661f9b28354e95ce2551ac34d0a467b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a0661f9b28354e95ce2551ac34d0a467b">_check_1d</a> (x)</td></tr>
<tr class="separator:a0661f9b28354e95ce2551ac34d0a467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6662f7f6096aececf309bac8a9245aa3" id="r_a6662f7f6096aececf309bac8a9245aa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a6662f7f6096aececf309bac8a9245aa3">_reshape_2D</a> (X, name)</td></tr>
<tr class="separator:a6662f7f6096aececf309bac8a9245aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e7862da93ffb8e0f23314d55a8654c" id="r_a90e7862da93ffb8e0f23314d55a8654c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a90e7862da93ffb8e0f23314d55a8654c">violin_stats</a> (X, method, points=100, quantiles=None)</td></tr>
<tr class="separator:a90e7862da93ffb8e0f23314d55a8654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d9aa87eb2e3afeaf02fc980d4c175" id="r_a003d9aa87eb2e3afeaf02fc980d4c175"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a003d9aa87eb2e3afeaf02fc980d4c175">pts_to_prestep</a> (x, *args)</td></tr>
<tr class="separator:a003d9aa87eb2e3afeaf02fc980d4c175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab2f98cb68bdff50b1ea50705e01c99" id="r_a8ab2f98cb68bdff50b1ea50705e01c99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a8ab2f98cb68bdff50b1ea50705e01c99">pts_to_poststep</a> (x, *args)</td></tr>
<tr class="separator:a8ab2f98cb68bdff50b1ea50705e01c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61bb795ec107bf3f683b4c32ecc970a" id="r_ac61bb795ec107bf3f683b4c32ecc970a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ac61bb795ec107bf3f683b4c32ecc970a">pts_to_midstep</a> (x, *args)</td></tr>
<tr class="separator:ac61bb795ec107bf3f683b4c32ecc970a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5d1ad31c90a6479c5938d793401a99" id="r_a3b5d1ad31c90a6479c5938d793401a99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a3b5d1ad31c90a6479c5938d793401a99">index_of</a> (y)</td></tr>
<tr class="separator:a3b5d1ad31c90a6479c5938d793401a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada775c72111d2e19c04b0a34b570cd8f" id="r_ada775c72111d2e19c04b0a34b570cd8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ada775c72111d2e19c04b0a34b570cd8f">safe_first_element</a> (obj)</td></tr>
<tr class="separator:ada775c72111d2e19c04b0a34b570cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40f89ba5238e44c7ba777cce2218344" id="r_ae40f89ba5238e44c7ba777cce2218344"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ae40f89ba5238e44c7ba777cce2218344">_safe_first_finite</a> (obj, *skip_nonfinite=True)</td></tr>
<tr class="separator:ae40f89ba5238e44c7ba777cce2218344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c74e70d962066a34fd7ffc9707fb65" id="r_af3c74e70d962066a34fd7ffc9707fb65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#af3c74e70d962066a34fd7ffc9707fb65">sanitize_sequence</a> (data)</td></tr>
<tr class="separator:af3c74e70d962066a34fd7ffc9707fb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7263ff5dd36e3ce8c9a99108749f099" id="r_ae7263ff5dd36e3ce8c9a99108749f099"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ae7263ff5dd36e3ce8c9a99108749f099">normalize_kwargs</a> (kw, alias_mapping=None)</td></tr>
<tr class="separator:ae7263ff5dd36e3ce8c9a99108749f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba13ce0ddeaaa4cab0f5853654619d" id="r_a7cba13ce0ddeaaa4cab0f5853654619d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a7cba13ce0ddeaaa4cab0f5853654619d">_lock_path</a> (path)</td></tr>
<tr class="separator:a7cba13ce0ddeaaa4cab0f5853654619d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b338551ede51e78c27afe25c36abdd6" id="r_a7b338551ede51e78c27afe25c36abdd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a7b338551ede51e78c27afe25c36abdd6">_topmost_artist</a> (artists, _cached_max=functools.partial(max, key=operator.attrgetter(&quot;zorder&quot;)))</td></tr>
<tr class="separator:a7b338551ede51e78c27afe25c36abdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7397fb4d93e6422ba2765dcfc8df22" id="r_a6b7397fb4d93e6422ba2765dcfc8df22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a6b7397fb4d93e6422ba2765dcfc8df22">_str_equal</a> (obj, s)</td></tr>
<tr class="separator:a6b7397fb4d93e6422ba2765dcfc8df22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337321261dbc8043fca6e63f618001d3" id="r_a337321261dbc8043fca6e63f618001d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a337321261dbc8043fca6e63f618001d3">_str_lower_equal</a> (obj, s)</td></tr>
<tr class="separator:a337321261dbc8043fca6e63f618001d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488b76517efbbcda3cad1a5953c71c07" id="r_a488b76517efbbcda3cad1a5953c71c07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a488b76517efbbcda3cad1a5953c71c07">_array_perimeter</a> (arr)</td></tr>
<tr class="separator:a488b76517efbbcda3cad1a5953c71c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1b7d0d215afd906f3842ed8fca8076" id="r_a3e1b7d0d215afd906f3842ed8fca8076"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a3e1b7d0d215afd906f3842ed8fca8076">_unfold</a> (arr, axis, size, step)</td></tr>
<tr class="separator:a3e1b7d0d215afd906f3842ed8fca8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e7e4fa4a806eabbbf57a52f64db40e" id="r_a74e7e4fa4a806eabbbf57a52f64db40e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a74e7e4fa4a806eabbbf57a52f64db40e">_array_patch_perimeters</a> (x, rstride, cstride)</td></tr>
<tr class="separator:a74e7e4fa4a806eabbbf57a52f64db40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a04194d4852a148476be525caefe70" id="r_a57a04194d4852a148476be525caefe70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a57a04194d4852a148476be525caefe70">_setattr_cm</a> (obj, **kwargs)</td></tr>
<tr class="separator:a57a04194d4852a148476be525caefe70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfeb18389b728208d6847c1276d9727" id="r_a8cfeb18389b728208d6847c1276d9727"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a8cfeb18389b728208d6847c1276d9727">_premultiplied_argb32_to_unmultiplied_rgba8888</a> (buf)</td></tr>
<tr class="separator:a8cfeb18389b728208d6847c1276d9727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1650c0b8742e83d1de5ef078ed1c0e53" id="r_a1650c0b8742e83d1de5ef078ed1c0e53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a1650c0b8742e83d1de5ef078ed1c0e53">_unmultiplied_rgba8888_to_premultiplied_argb32</a> (rgba8888)</td></tr>
<tr class="separator:a1650c0b8742e83d1de5ef078ed1c0e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997b7c02808d1d141bb979581133aa15" id="r_a997b7c02808d1d141bb979581133aa15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a997b7c02808d1d141bb979581133aa15">_get_nonzero_slices</a> (buf)</td></tr>
<tr class="separator:a997b7c02808d1d141bb979581133aa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882ca280dc7d788e959489498cedd00a" id="r_a882ca280dc7d788e959489498cedd00a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a882ca280dc7d788e959489498cedd00a">_pformat_subprocess</a> (command)</td></tr>
<tr class="separator:a882ca280dc7d788e959489498cedd00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19da6a42078db13965487f1c96fd98b9" id="r_a19da6a42078db13965487f1c96fd98b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a19da6a42078db13965487f1c96fd98b9">_check_and_log_subprocess</a> (command, logger, **kwargs)</td></tr>
<tr class="separator:a19da6a42078db13965487f1c96fd98b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989e4a16d969d19af399c0651fcab2e9" id="r_a989e4a16d969d19af399c0651fcab2e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a989e4a16d969d19af399c0651fcab2e9">_backend_module_name</a> (name)</td></tr>
<tr class="separator:a989e4a16d969d19af399c0651fcab2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c2cb0a13c60720d2362f88f4922ca0" id="r_a28c2cb0a13c60720d2362f88f4922ca0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a28c2cb0a13c60720d2362f88f4922ca0">_setup_new_guiapp</a> ()</td></tr>
<tr class="separator:a28c2cb0a13c60720d2362f88f4922ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad4aee4f643a22c9fc5048dac3b3f60" id="r_a2ad4aee4f643a22c9fc5048dac3b3f60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a2ad4aee4f643a22c9fc5048dac3b3f60">_format_approx</a> (number, precision)</td></tr>
<tr class="separator:a2ad4aee4f643a22c9fc5048dac3b3f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793dfe91107a4df41029c34233e0f202" id="r_a793dfe91107a4df41029c34233e0f202"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a793dfe91107a4df41029c34233e0f202">_g_sig_digits</a> (value, <a class="el" href="__lapack__subroutines_8h.html#a98105e47e00b222e3c47bfe371fa4925">delta</a>)</td></tr>
<tr class="separator:a793dfe91107a4df41029c34233e0f202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133998aa5b4c40759be93a618a798a0e" id="r_a133998aa5b4c40759be93a618a798a0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a133998aa5b4c40759be93a618a798a0e">_unikey_or_keysym_to_mplkey</a> (unikey, keysym)</td></tr>
<tr class="separator:a133998aa5b4c40759be93a618a798a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00cdcb6df024bad2f373397194b7f51" id="r_aa00cdcb6df024bad2f373397194b7f51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#aa00cdcb6df024bad2f373397194b7f51">_make_class_factory</a> (mixin_class, fmt, attr_name=None)</td></tr>
<tr class="separator:aa00cdcb6df024bad2f373397194b7f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84188524761b67762a1c838e98fbcaf0" id="r_a84188524761b67762a1c838e98fbcaf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a84188524761b67762a1c838e98fbcaf0">_picklable_class_constructor</a> (mixin_class, fmt, attr_name, base_class)</td></tr>
<tr class="separator:a84188524761b67762a1c838e98fbcaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababb5661eae59d4838cc47c978484452" id="r_ababb5661eae59d4838cc47c978484452"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#ababb5661eae59d4838cc47c978484452">_unpack_to_numpy</a> (x)</td></tr>
<tr class="separator:ababb5661eae59d4838cc47c978484452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9f8bddda84669c9ebb7be9a3c701f29d" id="r_a9f8bddda84669c9ebb7be9a3c701f29d"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a9f8bddda84669c9ebb7be9a3c701f29d">ls_mapper</a> = {'-': 'solid', '--': 'dashed', '-.': 'dashdot', ':': 'dotted'}</td></tr>
<tr class="separator:a9f8bddda84669c9ebb7be9a3c701f29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e70193717f5fa3143a98525a891d01" id="r_a86e70193717f5fa3143a98525a891d01"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#a86e70193717f5fa3143a98525a891d01">ls_mapper_r</a> = {v: <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a> for <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, v <a class="el" href="__lapack__subroutines_8h.html#aa83d4778c28341ab79b01b2371f666fe">in</a> ls_mapper.items()}</td></tr>
<tr class="separator:a86e70193717f5fa3143a98525a891d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24f8a763f388b46b3bac623389c4856" id="r_af24f8a763f388b46b3bac623389c4856"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1cbook.html#af24f8a763f388b46b3bac623389c4856">STEP_LOOKUP_MAP</a></td></tr>
<tr class="separator:af24f8a763f388b46b3bac623389c4856"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">A collection of utility functions and classes.  Originally, many
(but not all) were from the Python Cookbook -- hence the name cbook.

This module is safe to import from anywhere within Matplotlib;
it imports Matplotlib only at runtime.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a74e7e4fa4a806eabbbf57a52f64db40e" name="a74e7e4fa4a806eabbbf57a52f64db40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e7e4fa4a806eabbbf57a52f64db40e">&#9670;&#160;</a></span>_array_patch_perimeters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._array_patch_perimeters </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rstride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cstride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Extract perimeters of patches from *arr*.

Extracted patches are of size (*rstride* + 1) x (*cstride* + 1) and
share perimeters with their neighbors. The ordering of the vertices matches
that returned by ``_array_perimeter``.

Parameters
----------
x : ndarray, shape (N, M)
    Input array
rstride : int
    Vertical (row) stride between corresponding elements of each patch
cstride : int
    Horizontal (column) stride between corresponding elements of each patch

Returns
-------
ndarray, shape (N/rstride * M/cstride, 2 * (rstride + cstride))
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1979</span><span class="keyword">def </span>_array_patch_perimeters(x, rstride, cstride):</div>
<div class="line"><span class="lineno"> 1980</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">    Extract perimeters of patches from *arr*.</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    Extracted patches are of size (*rstride* + 1) x (*cstride* + 1) and</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    share perimeters with their neighbors. The ordering of the vertices matches</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">    that returned by ``_array_perimeter``.</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral">    x : ndarray, shape (N, M)</span></div>
<div class="line"><span class="lineno"> 1990</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral">    rstride : int</span></div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral">        Vertical (row) stride between corresponding elements of each patch</span></div>
<div class="line"><span class="lineno"> 1993</span><span class="stringliteral">    cstride : int</span></div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral">        Horizontal (column) stride between corresponding elements of each patch</span></div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">    ndarray, shape (N/rstride * M/cstride, 2 * (rstride + cstride))</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2000</span>    <span class="keyword">assert</span> rstride &gt; 0 <span class="keywordflow">and</span> cstride &gt; 0</div>
<div class="line"><span class="lineno"> 2001</span>    <span class="keyword">assert</span> (x.shape[0] - 1) % rstride == 0</div>
<div class="line"><span class="lineno"> 2002</span>    <span class="keyword">assert</span> (x.shape[1] - 1) % cstride == 0</div>
<div class="line"><span class="lineno"> 2003</span>    <span class="comment"># We build up each perimeter from four half-open intervals. Here is an</span></div>
<div class="line"><span class="lineno"> 2004</span>    <span class="comment"># illustrated explanation for rstride == cstride == 3</span></div>
<div class="line"><span class="lineno"> 2005</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2006</span>    <span class="comment">#       T T T R</span></div>
<div class="line"><span class="lineno"> 2007</span>    <span class="comment">#       L     R</span></div>
<div class="line"><span class="lineno"> 2008</span>    <span class="comment">#       L     R</span></div>
<div class="line"><span class="lineno"> 2009</span>    <span class="comment">#       L B B B</span></div>
<div class="line"><span class="lineno"> 2010</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2011</span>    <span class="comment"># where T means that this element will be in the top array, R for right,</span></div>
<div class="line"><span class="lineno"> 2012</span>    <span class="comment"># B for bottom and L for left. Each of the arrays below has a shape of:</span></div>
<div class="line"><span class="lineno"> 2013</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2014</span>    <span class="comment">#    (number of perimeters that can be extracted vertically,</span></div>
<div class="line"><span class="lineno"> 2015</span>    <span class="comment">#     number of perimeters that can be extracted horizontally,</span></div>
<div class="line"><span class="lineno"> 2016</span>    <span class="comment">#     cstride for top and bottom and rstride for left and right)</span></div>
<div class="line"><span class="lineno"> 2017</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2018</span>    <span class="comment"># Note that _unfold doesn&#39;t incur any memory copies, so the only costly</span></div>
<div class="line"><span class="lineno"> 2019</span>    <span class="comment"># operation here is the np.concatenate.</span></div>
<div class="line"><span class="lineno"> 2020</span>    top = _unfold(x[:-1:rstride, :-1], 1, cstride, cstride)</div>
<div class="line"><span class="lineno"> 2021</span>    bottom = _unfold(x[rstride::rstride, 1:], 1, cstride, cstride)[..., ::-1]</div>
<div class="line"><span class="lineno"> 2022</span>    right = _unfold(x[:-1, cstride::cstride], 0, rstride, rstride)</div>
<div class="line"><span class="lineno"> 2023</span>    left = _unfold(x[1:, :-1:cstride], 0, rstride, rstride)[..., ::-1]</div>
<div class="line"><span class="lineno"> 2024</span>    <span class="keywordflow">return</span> (np.concatenate((top, right, bottom, left), axis=2)</div>
<div class="line"><span class="lineno"> 2025</span>              .reshape(-1, 2 * (rstride + cstride)))</div>
<div class="line"><span class="lineno"> 2026</span> </div>
<div class="line"><span class="lineno"> 2027</span> </div>
<div class="line"><span class="lineno"> 2028</span><span class="preprocessor">@contextlib.contextmanager</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a488b76517efbbcda3cad1a5953c71c07" name="a488b76517efbbcda3cad1a5953c71c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488b76517efbbcda3cad1a5953c71c07">&#9670;&#160;</a></span>_array_perimeter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._array_perimeter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get the elements on the perimeter of *arr*.

Parameters
----------
arr : ndarray, shape (M, N)
    The input array.

Returns
-------
ndarray, shape (2*(M - 1) + 2*(N - 1),)
    The elements on the perimeter of the array::

       [arr[0, 0], ..., arr[0, -1], ..., arr[-1, -1], ..., arr[-1, 0], ...]

Examples
--------
&gt;&gt;&gt; i, j = np.ogrid[:3, :4]
&gt;&gt;&gt; a = i*10 + j
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23]])
&gt;&gt;&gt; _array_perimeter(a)
array([ 0,  1,  2,  3, 13, 23, 22, 21, 20, 10])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1890</span><span class="keyword">def </span>_array_perimeter(arr):</div>
<div class="line"><span class="lineno"> 1891</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral">    Get the elements on the perimeter of *arr*.</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">    arr : ndarray, shape (M, N)</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">        The input array.</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">    ndarray, shape (2*(M - 1) + 2*(N - 1),)</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">        The elements on the perimeter of the array::</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">           [arr[0, 0], ..., arr[0, -1], ..., arr[-1, -1], ..., arr[-1, 0], ...]</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">    &gt;&gt;&gt; i, j = np.ogrid[:3, :4]</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">    &gt;&gt;&gt; a = i*10 + j</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">    array([[ 0,  1,  2,  3],</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">           [10, 11, 12, 13],</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">           [20, 21, 22, 23]])</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">    &gt;&gt;&gt; _array_perimeter(a)</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">    array([ 0,  1,  2,  3, 13, 23, 22, 21, 20, 10])</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1917</span>    <span class="comment"># note we use Python&#39;s half-open ranges to avoid repeating</span></div>
<div class="line"><span class="lineno"> 1918</span>    <span class="comment"># the corners</span></div>
<div class="line"><span class="lineno"> 1919</span>    forward = np.s_[0:-1]      <span class="comment"># [0 ... -1)</span></div>
<div class="line"><span class="lineno"> 1920</span>    backward = np.s_[-1:0:-1]  <span class="comment"># [-1 ... 0)</span></div>
<div class="line"><span class="lineno"> 1921</span>    <span class="keywordflow">return</span> np.concatenate((</div>
<div class="line"><span class="lineno"> 1922</span>        arr[0, forward],</div>
<div class="line"><span class="lineno"> 1923</span>        arr[forward, -1],</div>
<div class="line"><span class="lineno"> 1924</span>        arr[-1, backward],</div>
<div class="line"><span class="lineno"> 1925</span>        arr[backward, 0],</div>
<div class="line"><span class="lineno"> 1926</span>    ))</div>
<div class="line"><span class="lineno"> 1927</span> </div>
<div class="line"><span class="lineno"> 1928</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a989e4a16d969d19af399c0651fcab2e9" name="a989e4a16d969d19af399c0651fcab2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989e4a16d969d19af399c0651fcab2e9">&#9670;&#160;</a></span>_backend_module_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._backend_module_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a backend name (either a standard backend -- "Agg", "TkAgg", ... --
or a custom backend -- "module://...") to the corresponding module name).
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2193</span><span class="keyword">def </span>_backend_module_name(name):</div>
<div class="line"><span class="lineno"> 2194</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2195</span><span class="stringliteral">    Convert a backend name (either a standard backend -- &quot;Agg&quot;, &quot;TkAgg&quot;, ... --</span></div>
<div class="line"><span class="lineno"> 2196</span><span class="stringliteral">    or a custom backend -- &quot;module://...&quot;) to the corresponding module name).</span></div>
<div class="line"><span class="lineno"> 2197</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2198</span>    <span class="keywordflow">return</span> (name[9:] <span class="keywordflow">if</span> name.startswith(<span class="stringliteral">&quot;module://&quot;</span>)</div>
<div class="line"><span class="lineno"> 2199</span>            <span class="keywordflow">else</span> <span class="stringliteral">&quot;matplotlib.backends.backend_{}&quot;</span>.format(name.lower()))</div>
<div class="line"><span class="lineno"> 2200</span> </div>
<div class="line"><span class="lineno"> 2201</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0661f9b28354e95ce2551ac34d0a467b" name="a0661f9b28354e95ce2551ac34d0a467b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0661f9b28354e95ce2551ac34d0a467b">&#9670;&#160;</a></span>_check_1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._check_1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert scalars to 1D arrays; pass-through arrays as is.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1372</span><span class="keyword">def </span>_check_1d(x):</div>
<div class="line"><span class="lineno"> 1373</span>    <span class="stringliteral">&quot;&quot;&quot;Convert scalars to 1D arrays; pass-through arrays as is.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1374</span>    <span class="comment"># Unpack in case of e.g. Pandas or xarray object</span></div>
<div class="line"><span class="lineno"> 1375</span>    x = _unpack_to_numpy(x)</div>
<div class="line"><span class="lineno"> 1376</span>    <span class="comment"># plot requires `shape` and `ndim`.  If passed an</span></div>
<div class="line"><span class="lineno"> 1377</span>    <span class="comment"># object that doesn&#39;t provide them, then force to numpy array.</span></div>
<div class="line"><span class="lineno"> 1378</span>    <span class="comment"># Note this will strip unit information.</span></div>
<div class="line"><span class="lineno"> 1379</span>    <span class="keywordflow">if</span> (<span class="keywordflow">not</span> hasattr(x, <span class="stringliteral">&#39;shape&#39;</span>) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 1380</span>            <span class="keywordflow">not</span> hasattr(x, <span class="stringliteral">&#39;ndim&#39;</span>) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 1381</span>            len(x.shape) &lt; 1):</div>
<div class="line"><span class="lineno"> 1382</span>        <span class="keywordflow">return</span> np.atleast_1d(x)</div>
<div class="line"><span class="lineno"> 1383</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1384</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 1385</span> </div>
<div class="line"><span class="lineno"> 1386</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a19da6a42078db13965487f1c96fd98b9" name="a19da6a42078db13965487f1c96fd98b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19da6a42078db13965487f1c96fd98b9">&#9670;&#160;</a></span>_check_and_log_subprocess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._check_and_log_subprocess </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Run *command*, returning its stdout output if it succeeds.

If it fails (exits with nonzero return code), raise an exception whose text
includes the failed command and captured stdout and stderr output.

Regardless of the return code, the command is logged at DEBUG level on
*logger*.  In case of success, the output is likewise logged.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2159</span><span class="keyword">def </span>_check_and_log_subprocess(command, logger, **kwargs):</div>
<div class="line"><span class="lineno"> 2160</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">    Run *command*, returning its stdout output if it succeeds.</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral">    If it fails (exits with nonzero return code), raise an exception whose text</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">    includes the failed command and captured stdout and stderr output.</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">    Regardless of the return code, the command is logged at DEBUG level on</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">    *logger*.  In case of success, the output is likewise logged.</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2169</span>    logger.debug(<span class="stringliteral">&#39;%s&#39;</span>, _pformat_subprocess(command))</div>
<div class="line"><span class="lineno"> 2170</span>    proc = subprocess.run(</div>
<div class="line"><span class="lineno"> 2171</span>        command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)</div>
<div class="line"><span class="lineno"> 2172</span>    <span class="keywordflow">if</span> proc.returncode:</div>
<div class="line"><span class="lineno"> 2173</span>        stdout = proc.stdout</div>
<div class="line"><span class="lineno"> 2174</span>        <span class="keywordflow">if</span> isinstance(stdout, bytes):</div>
<div class="line"><span class="lineno"> 2175</span>            stdout = stdout.decode()</div>
<div class="line"><span class="lineno"> 2176</span>        stderr = proc.stderr</div>
<div class="line"><span class="lineno"> 2177</span>        <span class="keywordflow">if</span> isinstance(stderr, bytes):</div>
<div class="line"><span class="lineno"> 2178</span>            stderr = stderr.decode()</div>
<div class="line"><span class="lineno"> 2179</span>        <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno"> 2180</span>            f<span class="stringliteral">&quot;The command\n&quot;</span></div>
<div class="line"><span class="lineno"> 2181</span>            f<span class="stringliteral">&quot;    {_pformat_subprocess(command)}\n&quot;</span></div>
<div class="line"><span class="lineno"> 2182</span>            f<span class="stringliteral">&quot;failed and generated the following output:\n&quot;</span></div>
<div class="line"><span class="lineno"> 2183</span>            f<span class="stringliteral">&quot;{stdout}\n&quot;</span></div>
<div class="line"><span class="lineno"> 2184</span>            f<span class="stringliteral">&quot;and the following error:\n&quot;</span></div>
<div class="line"><span class="lineno"> 2185</span>            f<span class="stringliteral">&quot;{stderr}&quot;</span>)</div>
<div class="line"><span class="lineno"> 2186</span>    <span class="keywordflow">if</span> proc.stdout:</div>
<div class="line"><span class="lineno"> 2187</span>        logger.debug(<span class="stringliteral">&quot;stdout:\n%s&quot;</span>, proc.stdout)</div>
<div class="line"><span class="lineno"> 2188</span>    <span class="keywordflow">if</span> proc.stderr:</div>
<div class="line"><span class="lineno"> 2189</span>        logger.debug(<span class="stringliteral">&quot;stderr:\n%s&quot;</span>, proc.stderr)</div>
<div class="line"><span class="lineno"> 2190</span>    <span class="keywordflow">return</span> proc.stdout</div>
<div class="line"><span class="lineno"> 2191</span> </div>
<div class="line"><span class="lineno"> 2192</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e5270a8424dda2fd671b3da53f10943" name="a8e5270a8424dda2fd671b3da53f10943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5270a8424dda2fd671b3da53f10943">&#9670;&#160;</a></span>_combine_masks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._combine_masks </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Find all masked and/or non-finite points in a set of arguments,
and return the arguments as masked arrays with a common mask.

Arguments can be in any of 5 categories:

1) 1-D masked arrays
2) 1-D ndarrays
3) ndarrays with more than one dimension
4) other non-string iterables
5) anything else

The first argument must be in one of the first four categories;
any argument with a length differing from that of the first
argument (and hence anything in category 5) then will be
passed through unchanged.

Masks are obtained from all arguments of the correct length
in categories 1, 2, and 4; a point is bad if masked in a masked
array or if it is a nan or inf.  No attempt is made to
extract a mask from categories 2 and 4 if `numpy.isfinite`
does not yield a Boolean array.  Category 3 is included to
support RGB or RGBA ndarrays, which are assumed to have only
valid values and which are passed through unchanged.

All input arguments that are not passed unchanged are returned
as masked arrays if any masked points are found, otherwise as
ndarrays.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1050</span><span class="keyword">def </span>_combine_masks(*args):</div>
<div class="line"><span class="lineno"> 1051</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">    Find all masked and/or non-finite points in a set of arguments,</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">    and return the arguments as masked arrays with a common mask.</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">    Arguments can be in any of 5 categories:</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    1) 1-D masked arrays</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">    2) 1-D ndarrays</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">    3) ndarrays with more than one dimension</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    4) other non-string iterables</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    5) anything else</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">    The first argument must be in one of the first four categories;</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">    any argument with a length differing from that of the first</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">    argument (and hence anything in category 5) then will be</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    passed through unchanged.</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    Masks are obtained from all arguments of the correct length</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    in categories 1, 2, and 4; a point is bad if masked in a masked</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    array or if it is a nan or inf.  No attempt is made to</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    extract a mask from categories 2 and 4 if `numpy.isfinite`</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    does not yield a Boolean array.  Category 3 is included to</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    support RGB or RGBA ndarrays, which are assumed to have only</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    valid values and which are passed through unchanged.</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">    All input arguments that are not passed unchanged are returned</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    as masked arrays if any masked points are found, otherwise as</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    ndarrays.</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1081</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(args):</div>
<div class="line"><span class="lineno"> 1082</span>        <span class="keywordflow">return</span> ()</div>
<div class="line"><span class="lineno"> 1083</span>    <span class="keywordflow">if</span> is_scalar_or_string(args[0]):</div>
<div class="line"><span class="lineno"> 1084</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;First argument must be a sequence&quot;</span>)</div>
<div class="line"><span class="lineno"> 1085</span>    nrecs = len(args[0])</div>
<div class="line"><span class="lineno"> 1086</span>    margs = []  <span class="comment"># Output args; some may be modified.</span></div>
<div class="line"><span class="lineno"> 1087</span>    seqlist = [<span class="keyword">False</span>] * len(args)  <span class="comment"># Flags: True if output will be masked.</span></div>
<div class="line"><span class="lineno"> 1088</span>    masks = []    <span class="comment"># List of masks.</span></div>
<div class="line"><span class="lineno"> 1089</span>    <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(args):</div>
<div class="line"><span class="lineno"> 1090</span>        <span class="keywordflow">if</span> is_scalar_or_string(x) <span class="keywordflow">or</span> len(x) != nrecs:</div>
<div class="line"><span class="lineno"> 1091</span>            margs.append(x)  <span class="comment"># Leave it unmodified.</span></div>
<div class="line"><span class="lineno"> 1092</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1093</span>            <span class="keywordflow">if</span> isinstance(x, np.ma.MaskedArray) <span class="keywordflow">and</span> x.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 1094</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Masked arrays must be 1-D&quot;</span>)</div>
<div class="line"><span class="lineno"> 1095</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1096</span>                x = np.asanyarray(x)</div>
<div class="line"><span class="lineno"> 1097</span>            <span class="keywordflow">except</span> (np.VisibleDeprecationWarning, ValueError):</div>
<div class="line"><span class="lineno"> 1098</span>                <span class="comment"># NumPy 1.19 raises a warning about ragged arrays, but we want</span></div>
<div class="line"><span class="lineno"> 1099</span>                <span class="comment"># to accept basically anything here.</span></div>
<div class="line"><span class="lineno"> 1100</span>                x = np.asanyarray(x, dtype=object)</div>
<div class="line"><span class="lineno"> 1101</span>            <span class="keywordflow">if</span> x.ndim == 1:</div>
<div class="line"><span class="lineno"> 1102</span>                x = safe_masked_invalid(x)</div>
<div class="line"><span class="lineno"> 1103</span>                seqlist[i] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1104</span>                <span class="keywordflow">if</span> np.ma.is_masked(x):</div>
<div class="line"><span class="lineno"> 1105</span>                    masks.append(np.ma.getmaskarray(x))</div>
<div class="line"><span class="lineno"> 1106</span>            margs.append(x)  <span class="comment"># Possibly modified.</span></div>
<div class="line"><span class="lineno"> 1107</span>    <span class="keywordflow">if</span> len(masks):</div>
<div class="line"><span class="lineno"> 1108</span>        mask = np.logical_or.reduce(masks)</div>
<div class="line"><span class="lineno"> 1109</span>        <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(margs):</div>
<div class="line"><span class="lineno"> 1110</span>            <span class="keywordflow">if</span> seqlist[i]:</div>
<div class="line"><span class="lineno"> 1111</span>                margs[i] = np.ma.array(x, mask=mask)</div>
<div class="line"><span class="lineno"> 1112</span>    <span class="keywordflow">return</span> margs</div>
<div class="line"><span class="lineno"> 1113</span> </div>
<div class="line"><span class="lineno"> 1114</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a91cd7ed2d0d8c7d6397ad493194605a9" name="a91cd7ed2d0d8c7d6397ad493194605a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cd7ed2d0d8c7d6397ad493194605a9">&#9670;&#160;</a></span>_exception_printer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._exception_printer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   94</span><span class="keyword">def </span>_exception_printer(exc):</div>
<div class="line"><span class="lineno">   95</span>    <span class="keywordflow">if</span> _get_running_interactive_framework() <span class="keywordflow">in</span> [<span class="stringliteral">&quot;headless&quot;</span>, <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno">   96</span>        <span class="keywordflow">raise</span> exc</div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   98</span>        traceback.print_exc()</div>
<div class="line"><span class="lineno">   99</span> </div>
<div class="line"><span class="lineno">  100</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ad4aee4f643a22c9fc5048dac3b3f60" name="a2ad4aee4f643a22c9fc5048dac3b3f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad4aee4f643a22c9fc5048dac3b3f60">&#9670;&#160;</a></span>_format_approx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._format_approx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Format the number with at most the number of decimals given as precision.
Remove trailing zeros and possibly the decimal point.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2216</span><span class="keyword">def </span>_format_approx(number, precision):</div>
<div class="line"><span class="lineno"> 2217</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">    Format the number with at most the number of decimals given as precision.</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">    Remove trailing zeros and possibly the decimal point.</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2221</span>    <span class="keywordflow">return</span> f<span class="stringliteral">&#39;{number:.{precision}f}&#39;</span>.rstrip(<span class="stringliteral">&#39;0&#39;</span>).rstrip(<span class="stringliteral">&#39;.&#39;</span>) <span class="keywordflow">or</span> <span class="stringliteral">&#39;0&#39;</span></div>
<div class="line"><span class="lineno"> 2222</span> </div>
<div class="line"><span class="lineno"> 2223</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a793dfe91107a4df41029c34233e0f202" name="a793dfe91107a4df41029c34233e0f202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793dfe91107a4df41029c34233e0f202">&#9670;&#160;</a></span>_g_sig_digits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._g_sig_digits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the number of significant digits to %g-format *value*, assuming that
it is known with an error of *delta*.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2224</span><span class="keyword">def </span>_g_sig_digits(value, delta):</div>
<div class="line"><span class="lineno"> 2225</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral">    Return the number of significant digits to %g-format *value*, assuming that</span></div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">    it is known with an error of *delta*.</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2229</span>    <span class="keywordflow">if</span> delta == 0:</div>
<div class="line"><span class="lineno"> 2230</span>        <span class="comment"># delta = 0 may occur when trying to format values over a tiny range;</span></div>
<div class="line"><span class="lineno"> 2231</span>        <span class="comment"># in that case, replace it by the distance to the closest float.</span></div>
<div class="line"><span class="lineno"> 2232</span>        delta = abs(np.spacing(value))</div>
<div class="line"><span class="lineno"> 2233</span>    <span class="comment"># If e.g. value = 45.67 and delta = 0.02, then we want to round to 2 digits</span></div>
<div class="line"><span class="lineno"> 2234</span>    <span class="comment"># after the decimal point (floor(log10(0.02)) = -2); 45.67 contributes 2</span></div>
<div class="line"><span class="lineno"> 2235</span>    <span class="comment"># digits before the decimal point (floor(log10(45.67)) + 1 = 2): the total</span></div>
<div class="line"><span class="lineno"> 2236</span>    <span class="comment"># is 4 significant digits.  A value of 0 contributes 1 &quot;digit&quot; before the</span></div>
<div class="line"><span class="lineno"> 2237</span>    <span class="comment"># decimal point.</span></div>
<div class="line"><span class="lineno"> 2238</span>    <span class="comment"># For inf or nan, the precision doesn&#39;t matter.</span></div>
<div class="line"><span class="lineno"> 2239</span>    <span class="keywordflow">return</span> max(</div>
<div class="line"><span class="lineno"> 2240</span>        0,</div>
<div class="line"><span class="lineno"> 2241</span>        (math.floor(math.log10(abs(value))) + 1 <span class="keywordflow">if</span> value <span class="keywordflow">else</span> 1)</div>
<div class="line"><span class="lineno"> 2242</span>        - math.floor(math.log10(delta))) <span class="keywordflow">if</span> math.isfinite(value) <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno"> 2243</span> </div>
<div class="line"><span class="lineno"> 2244</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a95a470632d0225fcb3bf9fa4c4a03337" name="a95a470632d0225fcb3bf9fa4c4a03337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a470632d0225fcb3bf9fa4c4a03337">&#9670;&#160;</a></span>_get_data_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._get_data_path </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the `pathlib.Path` to a resource file provided by Matplotlib.

``*args`` specify a path relative to the base data path.
</pre> <div class="fragment"><div class="line"><span class="lineno">  553</span><span class="keyword">def </span>_get_data_path(*args):</div>
<div class="line"><span class="lineno">  554</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    Return the `pathlib.Path` to a resource file provided by Matplotlib.</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    ``*args`` specify a path relative to the base data path.</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  559</span>    <span class="keywordflow">return</span> Path(<a class="code hl_function" href="namespacematplotlib.html#a5923de9c5788a8dd687a83d8fa671a50">matplotlib.get_data_path</a>(), *args)</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span> </div>
<div class="ttc" id="anamespacematplotlib_html_a5923de9c5788a8dd687a83d8fa671a50"><div class="ttname"><a href="namespacematplotlib.html#a5923de9c5788a8dd687a83d8fa671a50">matplotlib.get_data_path</a></div><div class="ttdeci">get_data_path()</div><div class="ttdef"><b>Definition</b> __init__.py:541</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a997b7c02808d1d141bb979581133aa15" name="a997b7c02808d1d141bb979581133aa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997b7c02808d1d141bb979581133aa15">&#9670;&#160;</a></span>_get_nonzero_slices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._get_nonzero_slices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the bounds of the nonzero region of a 2D array as a pair of slices.

``buf[_get_nonzero_slices(buf)]`` is the smallest sub-rectangle in *buf*
that encloses all non-zero entries in *buf*.  If *buf* is fully zero, then
``(slice(0, 0), slice(0, 0))`` is returned.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2135</span><span class="keyword">def </span>_get_nonzero_slices(buf):</div>
<div class="line"><span class="lineno"> 2136</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral">    Return the bounds of the nonzero region of a 2D array as a pair of slices.</span></div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">    ``buf[_get_nonzero_slices(buf)]`` is the smallest sub-rectangle in *buf*</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral">    that encloses all non-zero entries in *buf*.  If *buf* is fully zero, then</span></div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">    ``(slice(0, 0), slice(0, 0))`` is returned.</span></div>
<div class="line"><span class="lineno"> 2142</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2143</span>    x_nz, = buf.any(axis=0).nonzero()</div>
<div class="line"><span class="lineno"> 2144</span>    y_nz, = buf.any(axis=1).nonzero()</div>
<div class="line"><span class="lineno"> 2145</span>    <span class="keywordflow">if</span> len(x_nz) <span class="keywordflow">and</span> len(y_nz):</div>
<div class="line"><span class="lineno"> 2146</span>        l, r = x_nz[[0, -1]]</div>
<div class="line"><span class="lineno"> 2147</span>        b, t = y_nz[[0, -1]]</div>
<div class="line"><span class="lineno"> 2148</span>        <span class="keywordflow">return</span> slice(b, t + 1), slice(l, r + 1)</div>
<div class="line"><span class="lineno"> 2149</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2150</span>        <span class="keywordflow">return</span> slice(0, 0), slice(0, 0)</div>
<div class="line"><span class="lineno"> 2151</span> </div>
<div class="line"><span class="lineno"> 2152</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a82d17f813574add65a17202ef36063" name="a0a82d17f813574add65a17202ef36063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a82d17f813574add65a17202ef36063">&#9670;&#160;</a></span>_get_running_interactive_framework()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._get_running_interactive_framework </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the interactive framework whose event loop is currently running, if
any, or "headless" if no event loop can be started, or None.

Returns
-------
Optional[str]
    One of the following values: "qt", "gtk3", "gtk4", "wx", "tk",
    "macosx", "headless", ``None``.
</pre> <div class="fragment"><div class="line"><span class="lineno">   46</span><span class="keyword">def </span>_get_running_interactive_framework():</div>
<div class="line"><span class="lineno">   47</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    Return the interactive framework whose event loop is currently running, if</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    any, or &quot;headless&quot; if no event loop can be started, or None.</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    Optional[str]</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        One of the following values: &quot;qt&quot;, &quot;gtk3&quot;, &quot;gtk4&quot;, &quot;wx&quot;, &quot;tk&quot;,</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">        &quot;macosx&quot;, &quot;headless&quot;, ``None``.</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   57</span>    <span class="comment"># Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as</span></div>
<div class="line"><span class="lineno">   58</span>    <span class="comment"># entries can also have been explicitly set to None.</span></div>
<div class="line"><span class="lineno">   59</span>    QtWidgets = (</div>
<div class="line"><span class="lineno">   60</span>        sys.modules.get(<span class="stringliteral">&quot;PyQt6.QtWidgets&quot;</span>)</div>
<div class="line"><span class="lineno">   61</span>        <span class="keywordflow">or</span> sys.modules.get(<span class="stringliteral">&quot;PySide6.QtWidgets&quot;</span>)</div>
<div class="line"><span class="lineno">   62</span>        <span class="keywordflow">or</span> sys.modules.get(<span class="stringliteral">&quot;PyQt5.QtWidgets&quot;</span>)</div>
<div class="line"><span class="lineno">   63</span>        <span class="keywordflow">or</span> sys.modules.get(<span class="stringliteral">&quot;PySide2.QtWidgets&quot;</span>)</div>
<div class="line"><span class="lineno">   64</span>    )</div>
<div class="line"><span class="lineno">   65</span>    <span class="keywordflow">if</span> QtWidgets <span class="keywordflow">and</span> QtWidgets.QApplication.instance():</div>
<div class="line"><span class="lineno">   66</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;qt&quot;</span></div>
<div class="line"><span class="lineno">   67</span>    Gtk = sys.modules.get(<span class="stringliteral">&quot;gi.repository.Gtk&quot;</span>)</div>
<div class="line"><span class="lineno">   68</span>    <span class="keywordflow">if</span> Gtk:</div>
<div class="line"><span class="lineno">   69</span>        <span class="keywordflow">if</span> Gtk.MAJOR_VERSION == 4:</div>
<div class="line"><span class="lineno">   70</span>            <span class="keyword">from</span> gi.repository <span class="keyword">import</span> GLib</div>
<div class="line"><span class="lineno">   71</span>            <span class="keywordflow">if</span> GLib.main_depth():</div>
<div class="line"><span class="lineno">   72</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;gtk4&quot;</span></div>
<div class="line"><span class="lineno">   73</span>        <span class="keywordflow">if</span> Gtk.MAJOR_VERSION == 3 <span class="keywordflow">and</span> Gtk.main_level():</div>
<div class="line"><span class="lineno">   74</span>            <span class="keywordflow">return</span> <span class="stringliteral">&quot;gtk3&quot;</span></div>
<div class="line"><span class="lineno">   75</span>    wx = sys.modules.get(<span class="stringliteral">&quot;wx&quot;</span>)</div>
<div class="line"><span class="lineno">   76</span>    <span class="keywordflow">if</span> wx <span class="keywordflow">and</span> wx.GetApp():</div>
<div class="line"><span class="lineno">   77</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;wx&quot;</span></div>
<div class="line"><span class="lineno">   78</span>    tkinter = sys.modules.get(<span class="stringliteral">&quot;tkinter&quot;</span>)</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">if</span> tkinter:</div>
<div class="line"><span class="lineno">   80</span>        codes = {tkinter.mainloop.__code__, tkinter.Misc.mainloop.__code__}</div>
<div class="line"><span class="lineno">   81</span>        <span class="keywordflow">for</span> frame <span class="keywordflow">in</span> sys._current_frames().values():</div>
<div class="line"><span class="lineno">   82</span>            <span class="keywordflow">while</span> frame:</div>
<div class="line"><span class="lineno">   83</span>                <span class="keywordflow">if</span> frame.f_code <span class="keywordflow">in</span> codes:</div>
<div class="line"><span class="lineno">   84</span>                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;tk&quot;</span></div>
<div class="line"><span class="lineno">   85</span>                frame = frame.f_back</div>
<div class="line"><span class="lineno">   86</span>    macosx = sys.modules.get(<span class="stringliteral">&quot;matplotlib.backends._macosx&quot;</span>)</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">if</span> macosx <span class="keywordflow">and</span> macosx.event_loop_is_running():</div>
<div class="line"><span class="lineno">   88</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;macosx&quot;</span></div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _c_internal_utils.display_is_valid():</div>
<div class="line"><span class="lineno">   90</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;headless&quot;</span></div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">   92</span> </div>
<div class="line"><span class="lineno">   93</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f41a8134471986341d71d0012458cc7" name="a1f41a8134471986341d71d0012458cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f41a8134471986341d71d0012458cc7">&#9670;&#160;</a></span>_local_over_kwdict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._local_over_kwdict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>local_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>warning_cls</em> = <code><a class="el" href="classmatplotlib_1_1__api_1_1deprecation_1_1_matplotlib_deprecation_warning.html">_api.MatplotlibDeprecationWarning</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  378</span>        warning_cls=_api.MatplotlibDeprecationWarning):</div>
<div class="line"><span class="lineno">  379</span>    out = local_var</div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">for</span> key <span class="keywordflow">in</span> keys:</div>
<div class="line"><span class="lineno">  381</span>        kwarg_val = kwargs.pop(key, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  382</span>        <span class="keywordflow">if</span> kwarg_val <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  383</span>            <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  384</span>                out = kwarg_val</div>
<div class="line"><span class="lineno">  385</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  386</span>                _api.warn_external(f<span class="stringliteral">&#39;&quot;{key}&quot; keyword argument will be ignored&#39;</span>,</div>
<div class="line"><span class="lineno">  387</span>                                   warning_cls)</div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cba13ce0ddeaaa4cab0f5853654619d" name="a7cba13ce0ddeaaa4cab0f5853654619d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cba13ce0ddeaaa4cab0f5853654619d">&#9670;&#160;</a></span>_lock_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._lock_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Context manager for locking a path.

Usage::

    with _lock_path(path):
        ...

Another thread or process that attempts to lock the same path will wait
until this context manager is exited.

The lock is implemented by creating a temporary file in the parent
directory, so that directory must exist and be writable.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1817</span><span class="keyword">def </span>_lock_path(path):</div>
<div class="line"><span class="lineno"> 1818</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">    Context manager for locking a path.</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    Usage::</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">        with _lock_path(path):</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">            ...</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    Another thread or process that attempts to lock the same path will wait</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    until this context manager is exited.</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    The lock is implemented by creating a temporary file in the parent</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    directory, so that directory must exist and be writable.</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1832</span>    path = Path(path)</div>
<div class="line"><span class="lineno"> 1833</span>    lock_path = path.with_name(path.name + <span class="stringliteral">&quot;.matplotlib-lock&quot;</span>)</div>
<div class="line"><span class="lineno"> 1834</span>    retries = 50</div>
<div class="line"><span class="lineno"> 1835</span>    sleeptime = 0.1</div>
<div class="line"><span class="lineno"> 1836</span>    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(retries):</div>
<div class="line"><span class="lineno"> 1837</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1838</span>            <span class="keyword">with</span> lock_path.open(<span class="stringliteral">&quot;xb&quot;</span>):</div>
<div class="line"><span class="lineno"> 1839</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1840</span>        <span class="keywordflow">except</span> FileExistsError:</div>
<div class="line"><span class="lineno"> 1841</span>            time.sleep(sleeptime)</div>
<div class="line"><span class="lineno"> 1842</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1843</span>        <span class="keywordflow">raise</span> TimeoutError(<span class="stringliteral">&quot;&quot;&quot;\</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">Lock error: Matplotlib failed to acquire the following lock file:</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">    {}</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">This maybe due to another process holding this lock file.  If you are sure no</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">other Matplotlib process is running, remove this file and try again.&quot;&quot;&quot;</span>.format(</div>
<div class="line"><span class="lineno"> 1848</span>            lock_path))</div>
<div class="line"><span class="lineno"> 1849</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1850</span>        <span class="keywordflow">yield</span></div>
<div class="line"><span class="lineno"> 1851</span>    <span class="keywordflow">finally</span>:</div>
<div class="line"><span class="lineno"> 1852</span>        lock_path.unlink()</div>
<div class="line"><span class="lineno"> 1853</span> </div>
<div class="line"><span class="lineno"> 1854</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa00cdcb6df024bad2f373397194b7f51" name="aa00cdcb6df024bad2f373397194b7f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00cdcb6df024bad2f373397194b7f51">&#9670;&#160;</a></span>_make_class_factory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._make_class_factory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mixin_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attr_name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a function that creates picklable classes inheriting from a mixin.

After ::

    factory = _make_class_factory(FooMixin, fmt, attr_name)
    FooAxes = factory(Axes)

``Foo`` is a class that inherits from ``FooMixin`` and ``Axes`` and **is
picklable** (picklability is what differentiates this from a plain call to
`type`).  Its ``__name__`` is set to ``fmt.format(Axes.__name__)`` and the
base class is stored in the ``attr_name`` attribute, if not None.

Moreover, the return value of ``factory`` is memoized: calls with the same
``Axes`` class always return the same subclass.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2271</span><span class="keyword">def </span>_make_class_factory(mixin_class, fmt, attr_name=None):</div>
<div class="line"><span class="lineno"> 2272</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2273</span><span class="stringliteral">    Return a function that creates picklable classes inheriting from a mixin.</span></div>
<div class="line"><span class="lineno"> 2274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral">    After ::</span></div>
<div class="line"><span class="lineno"> 2276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2277</span><span class="stringliteral">        factory = _make_class_factory(FooMixin, fmt, attr_name)</span></div>
<div class="line"><span class="lineno"> 2278</span><span class="stringliteral">        FooAxes = factory(Axes)</span></div>
<div class="line"><span class="lineno"> 2279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2280</span><span class="stringliteral">    ``Foo`` is a class that inherits from ``FooMixin`` and ``Axes`` and **is</span></div>
<div class="line"><span class="lineno"> 2281</span><span class="stringliteral">    picklable** (picklability is what differentiates this from a plain call to</span></div>
<div class="line"><span class="lineno"> 2282</span><span class="stringliteral">    `type`).  Its ``__name__`` is set to ``fmt.format(Axes.__name__)`` and the</span></div>
<div class="line"><span class="lineno"> 2283</span><span class="stringliteral">    base class is stored in the ``attr_name`` attribute, if not None.</span></div>
<div class="line"><span class="lineno"> 2284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2285</span><span class="stringliteral">    Moreover, the return value of ``factory`` is memoized: calls with the same</span></div>
<div class="line"><span class="lineno"> 2286</span><span class="stringliteral">    ``Axes`` class always return the same subclass.</span></div>
<div class="line"><span class="lineno"> 2287</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2288</span> </div>
<div class="line"><span class="lineno"> 2289</span>    <span class="preprocessor">@functools.lru_cache(None)</span></div>
<div class="line"><span class="lineno"> 2290</span>    <span class="keyword">def </span>class_factory(axes_class):</div>
<div class="line"><span class="lineno"> 2291</span>        <span class="comment"># if we have already wrapped this class, declare victory!</span></div>
<div class="line"><span class="lineno"> 2292</span>        <span class="keywordflow">if</span> issubclass(axes_class, mixin_class):</div>
<div class="line"><span class="lineno"> 2293</span>            <span class="keywordflow">return</span> axes_class</div>
<div class="line"><span class="lineno"> 2294</span> </div>
<div class="line"><span class="lineno"> 2295</span>        <span class="comment"># The parameter is named &quot;axes_class&quot; for backcompat but is really just</span></div>
<div class="line"><span class="lineno"> 2296</span>        <span class="comment"># a base class; no axes semantics are used.</span></div>
<div class="line"><span class="lineno"> 2297</span>        base_class = axes_class</div>
<div class="line"><span class="lineno"> 2298</span> </div>
<div class="line"><span class="lineno"> 2299</span>        <span class="keyword">class </span>subcls(mixin_class, base_class):</div>
<div class="line"><span class="lineno"> 2300</span>            <span class="comment"># Better approximation than __module__ = &quot;matplotlib.cbook&quot;.</span></div>
<div class="line"><span class="lineno"> 2301</span>            __module__ = mixin_class.__module__</div>
<div class="line"><span class="lineno"> 2302</span> </div>
<div class="line"><span class="lineno"> 2303</span>            <span class="keyword">def </span>__reduce__(self):</div>
<div class="line"><span class="lineno"> 2304</span>                <span class="keywordflow">return</span> (_picklable_class_constructor,</div>
<div class="line"><span class="lineno"> 2305</span>                        (mixin_class, fmt, attr_name, base_class),</div>
<div class="line"><span class="lineno"> 2306</span>                        self.__getstate__())</div>
<div class="line"><span class="lineno"> 2307</span> </div>
<div class="line"><span class="lineno"> 2308</span>        subcls.__name__ = subcls.__qualname__ = fmt.format(base_class.__name__)</div>
<div class="line"><span class="lineno"> 2309</span>        <span class="keywordflow">if</span> attr_name <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2310</span>            setattr(subcls, attr_name, base_class)</div>
<div class="line"><span class="lineno"> 2311</span>        <span class="keywordflow">return</span> subcls</div>
<div class="line"><span class="lineno"> 2312</span> </div>
<div class="line"><span class="lineno"> 2313</span>    class_factory.__module__ = mixin_class.__module__</div>
<div class="line"><span class="lineno"> 2314</span>    <span class="keywordflow">return</span> class_factory</div>
<div class="line"><span class="lineno"> 2315</span> </div>
<div class="line"><span class="lineno"> 2316</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a882ca280dc7d788e959489498cedd00a" name="a882ca280dc7d788e959489498cedd00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882ca280dc7d788e959489498cedd00a">&#9670;&#160;</a></span>_pformat_subprocess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._pformat_subprocess </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pretty-format a subprocess command for printing/logging purposes.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2153</span><span class="keyword">def </span>_pformat_subprocess(command):</div>
<div class="line"><span class="lineno"> 2154</span>    <span class="stringliteral">&quot;&quot;&quot;Pretty-format a subprocess command for printing/logging purposes.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2155</span>    <span class="keywordflow">return</span> (command <span class="keywordflow">if</span> isinstance(command, str)</div>
<div class="line"><span class="lineno"> 2156</span>            <span class="keywordflow">else</span> <span class="stringliteral">&quot; &quot;</span>.join(shlex.quote(os.fspath(arg)) <span class="keywordflow">for</span> arg <span class="keywordflow">in</span> command))</div>
<div class="line"><span class="lineno"> 2157</span> </div>
<div class="line"><span class="lineno"> 2158</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a84188524761b67762a1c838e98fbcaf0" name="a84188524761b67762a1c838e98fbcaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84188524761b67762a1c838e98fbcaf0">&#9670;&#160;</a></span>_picklable_class_constructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._picklable_class_constructor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mixin_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_class</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Internal helper for _make_class_factory.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2317</span><span class="keyword">def </span>_picklable_class_constructor(mixin_class, fmt, attr_name, base_class):</div>
<div class="line"><span class="lineno"> 2318</span>    <span class="stringliteral">&quot;&quot;&quot;Internal helper for _make_class_factory.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2319</span>    factory = _make_class_factory(mixin_class, fmt, attr_name)</div>
<div class="line"><span class="lineno"> 2320</span>    cls = factory(base_class)</div>
<div class="line"><span class="lineno"> 2321</span>    <span class="keywordflow">return</span> cls.__new__(cls)</div>
<div class="line"><span class="lineno"> 2322</span> </div>
<div class="line"><span class="lineno"> 2323</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cfeb18389b728208d6847c1276d9727" name="a8cfeb18389b728208d6847c1276d9727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfeb18389b728208d6847c1276d9727">&#9670;&#160;</a></span>_premultiplied_argb32_to_unmultiplied_rgba8888()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._premultiplied_argb32_to_unmultiplied_rgba8888 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a premultiplied ARGB32 buffer to an unmultiplied RGBA8888 buffer.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2097</span><span class="keyword">def </span>_premultiplied_argb32_to_unmultiplied_rgba8888(buf):</div>
<div class="line"><span class="lineno"> 2098</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">    Convert a premultiplied ARGB32 buffer to an unmultiplied RGBA8888 buffer.</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2101</span>    rgba = np.take(  <span class="comment"># .take() ensures C-contiguity of the result.</span></div>
<div class="line"><span class="lineno"> 2102</span>        buf,</div>
<div class="line"><span class="lineno"> 2103</span>        [2, 1, 0, 3] <span class="keywordflow">if</span> sys.byteorder == <span class="stringliteral">&quot;little&quot;</span> <span class="keywordflow">else</span> [1, 2, 3, 0], axis=2)</div>
<div class="line"><span class="lineno"> 2104</span>    rgb = rgba[..., :-1]</div>
<div class="line"><span class="lineno"> 2105</span>    alpha = rgba[..., -1]</div>
<div class="line"><span class="lineno"> 2106</span>    <span class="comment"># Un-premultiply alpha.  The formula is the same as in cairo-png.c.</span></div>
<div class="line"><span class="lineno"> 2107</span>    mask = alpha != 0</div>
<div class="line"><span class="lineno"> 2108</span>    <span class="keywordflow">for</span> channel <span class="keywordflow">in</span> np.rollaxis(rgb, -1):</div>
<div class="line"><span class="lineno"> 2109</span>        channel[mask] = (</div>
<div class="line"><span class="lineno"> 2110</span>            (channel[mask].astype(int) * 255 + alpha[mask] // 2)</div>
<div class="line"><span class="lineno"> 2111</span>            // alpha[mask])</div>
<div class="line"><span class="lineno"> 2112</span>    <span class="keywordflow">return</span> rgba</div>
<div class="line"><span class="lineno"> 2113</span> </div>
<div class="line"><span class="lineno"> 2114</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6662f7f6096aececf309bac8a9245aa3" name="a6662f7f6096aececf309bac8a9245aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6662f7f6096aececf309bac8a9245aa3">&#9670;&#160;</a></span>_reshape_2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._reshape_2D </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Use Fortran ordering to convert ndarrays and lists of iterables to lists of
1D arrays.

Lists of iterables are converted by applying `numpy.asanyarray` to each of
their elements.  1D ndarrays are returned in a singleton list containing
them.  2D ndarrays are converted to the list of their *columns*.

*name* is used to generate the error message for invalid inputs.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1387</span><span class="keyword">def </span>_reshape_2D(X, name):</div>
<div class="line"><span class="lineno"> 1388</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    Use Fortran ordering to convert ndarrays and lists of iterables to lists of</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    1D arrays.</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">    Lists of iterables are converted by applying `numpy.asanyarray` to each of</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">    their elements.  1D ndarrays are returned in a singleton list containing</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    them.  2D ndarrays are converted to the list of their *columns*.</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">    *name* is used to generate the error message for invalid inputs.</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1398</span> </div>
<div class="line"><span class="lineno"> 1399</span>    <span class="comment"># Unpack in case of e.g. Pandas or xarray object</span></div>
<div class="line"><span class="lineno"> 1400</span>    X = _unpack_to_numpy(X)</div>
<div class="line"><span class="lineno"> 1401</span> </div>
<div class="line"><span class="lineno"> 1402</span>    <span class="comment"># Iterate over columns for ndarrays.</span></div>
<div class="line"><span class="lineno"> 1403</span>    <span class="keywordflow">if</span> isinstance(X, np.ndarray):</div>
<div class="line"><span class="lineno"> 1404</span>        X = X.T</div>
<div class="line"><span class="lineno"> 1405</span> </div>
<div class="line"><span class="lineno"> 1406</span>        <span class="keywordflow">if</span> len(X) == 0:</div>
<div class="line"><span class="lineno"> 1407</span>            <span class="keywordflow">return</span> [[]]</div>
<div class="line"><span class="lineno"> 1408</span>        <span class="keywordflow">elif</span> X.ndim == 1 <span class="keywordflow">and</span> np.ndim(X[0]) == 0:</div>
<div class="line"><span class="lineno"> 1409</span>            <span class="comment"># 1D array of scalars: directly return it.</span></div>
<div class="line"><span class="lineno"> 1410</span>            <span class="keywordflow">return</span> [X]</div>
<div class="line"><span class="lineno"> 1411</span>        <span class="keywordflow">elif</span> X.ndim <span class="keywordflow">in</span> [1, 2]:</div>
<div class="line"><span class="lineno"> 1412</span>            <span class="comment"># 2D array, or 1D array of iterables: flatten them first.</span></div>
<div class="line"><span class="lineno"> 1413</span>            <span class="keywordflow">return</span> [np.reshape(x, -1) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> X]</div>
<div class="line"><span class="lineno"> 1414</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1415</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;{name} must have 2 or fewer dimensions&#39;</span>)</div>
<div class="line"><span class="lineno"> 1416</span> </div>
<div class="line"><span class="lineno"> 1417</span>    <span class="comment"># Iterate over list of iterables.</span></div>
<div class="line"><span class="lineno"> 1418</span>    <span class="keywordflow">if</span> len(X) == 0:</div>
<div class="line"><span class="lineno"> 1419</span>        <span class="keywordflow">return</span> [[]]</div>
<div class="line"><span class="lineno"> 1420</span> </div>
<div class="line"><span class="lineno"> 1421</span>    result = []</div>
<div class="line"><span class="lineno"> 1422</span>    is_1d = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1423</span>    <span class="keywordflow">for</span> xi <span class="keywordflow">in</span> X:</div>
<div class="line"><span class="lineno"> 1424</span>        <span class="comment"># check if this is iterable, except for strings which we</span></div>
<div class="line"><span class="lineno"> 1425</span>        <span class="comment"># treat as singletons.</span></div>
<div class="line"><span class="lineno"> 1426</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(xi, str):</div>
<div class="line"><span class="lineno"> 1427</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1428</span>                <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(xi)</div>
<div class="line"><span class="lineno"> 1429</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1430</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1431</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1432</span>                is_1d = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1433</span>        xi = np.asanyarray(xi)</div>
<div class="line"><span class="lineno"> 1434</span>        nd = np.ndim(xi)</div>
<div class="line"><span class="lineno"> 1435</span>        <span class="keywordflow">if</span> nd &gt; 1:</div>
<div class="line"><span class="lineno"> 1436</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;{name} must have 2 or fewer dimensions&#39;</span>)</div>
<div class="line"><span class="lineno"> 1437</span>        result.append(xi.reshape(-1))</div>
<div class="line"><span class="lineno"> 1438</span> </div>
<div class="line"><span class="lineno"> 1439</span>    <span class="keywordflow">if</span> is_1d:</div>
<div class="line"><span class="lineno"> 1440</span>        <span class="comment"># 1D array of scalars: directly return it.</span></div>
<div class="line"><span class="lineno"> 1441</span>        <span class="keywordflow">return</span> [np.reshape(result, -1)]</div>
<div class="line"><span class="lineno"> 1442</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1443</span>        <span class="comment"># 2D array, or 1D array of iterables: use flattened version.</span></div>
<div class="line"><span class="lineno"> 1444</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1445</span> </div>
<div class="line"><span class="lineno"> 1446</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae40f89ba5238e44c7ba777cce2218344" name="ae40f89ba5238e44c7ba777cce2218344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40f89ba5238e44c7ba777cce2218344">&#9670;&#160;</a></span>_safe_first_finite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._safe_first_finite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>skip_nonfinite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the first non-None (and optionally finite) element in *obj*.

This is a method for internal use.

This is an type-independent way of obtaining the first non-None element,
supporting both index access and the iterator protocol.
The first non-None element will be obtained when skip_none is True.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1709</span><span class="keyword">def </span>_safe_first_finite(obj, *, skip_nonfinite=True):</div>
<div class="line"><span class="lineno"> 1710</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">    Return the first non-None (and optionally finite) element in *obj*.</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">    This is a method for internal use.</span></div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral">    This is an type-independent way of obtaining the first non-None element,</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">    supporting both index access and the iterator protocol.</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral">    The first non-None element will be obtained when skip_none is True.</span></div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1719</span>    <span class="keyword">def </span>safe_isfinite(val):</div>
<div class="line"><span class="lineno"> 1720</span>        <span class="keywordflow">if</span> val <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1721</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1722</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1723</span>            <span class="keywordflow">return</span> np.isfinite(val) <span class="keywordflow">if</span> np.isscalar(val) <span class="keywordflow">else</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1724</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1725</span>            <span class="comment"># This is something that numpy can not make heads or tails</span></div>
<div class="line"><span class="lineno"> 1726</span>            <span class="comment"># of, assume &quot;finite&quot;</span></div>
<div class="line"><span class="lineno"> 1727</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1728</span>    <span class="keywordflow">if</span> skip_nonfinite <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno"> 1729</span>        <span class="keywordflow">if</span> isinstance(obj, collections.abc.Iterator):</div>
<div class="line"><span class="lineno"> 1730</span>            <span class="comment"># needed to accept `array.flat` as input.</span></div>
<div class="line"><span class="lineno"> 1731</span>            <span class="comment"># np.flatiter reports as an instance of collections.Iterator</span></div>
<div class="line"><span class="lineno"> 1732</span>            <span class="comment"># but can still be indexed via [].</span></div>
<div class="line"><span class="lineno"> 1733</span>            <span class="comment"># This has the side effect of re-setting the iterator, but</span></div>
<div class="line"><span class="lineno"> 1734</span>            <span class="comment"># that is acceptable.</span></div>
<div class="line"><span class="lineno"> 1735</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1736</span>                <span class="keywordflow">return</span> obj[0]</div>
<div class="line"><span class="lineno"> 1737</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1738</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1739</span>            <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;matplotlib does not support generators &quot;</span></div>
<div class="line"><span class="lineno"> 1740</span>                               <span class="stringliteral">&quot;as input&quot;</span>)</div>
<div class="line"><span class="lineno"> 1741</span>        <span class="keywordflow">return</span> next(<a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(obj))</div>
<div class="line"><span class="lineno"> 1742</span>    <span class="keywordflow">elif</span> isinstance(obj, np.flatiter):</div>
<div class="line"><span class="lineno"> 1743</span>        <span class="comment"># TODO do the finite filtering on this</span></div>
<div class="line"><span class="lineno"> 1744</span>        <span class="keywordflow">return</span> obj[0]</div>
<div class="line"><span class="lineno"> 1745</span>    <span class="keywordflow">elif</span> isinstance(obj, collections.abc.Iterator):</div>
<div class="line"><span class="lineno"> 1746</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;matplotlib does not &quot;</span></div>
<div class="line"><span class="lineno"> 1747</span>                           <span class="stringliteral">&quot;support generators as input&quot;</span>)</div>
<div class="line"><span class="lineno"> 1748</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1749</span>        <span class="keywordflow">return</span> next(val <span class="keywordflow">for</span> val <span class="keywordflow">in</span> obj <span class="keywordflow">if</span> safe_isfinite(val))</div>
<div class="line"><span class="lineno"> 1750</span> </div>
<div class="line"><span class="lineno"> 1751</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a57a04194d4852a148476be525caefe70" name="a57a04194d4852a148476be525caefe70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a04194d4852a148476be525caefe70">&#9670;&#160;</a></span>_setattr_cm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._setattr_cm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Temporarily set some attributes; restore original state at context exit.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2029</span><span class="keyword">def </span>_setattr_cm(obj, **kwargs):</div>
<div class="line"><span class="lineno"> 2030</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2031</span><span class="stringliteral">    Temporarily set some attributes; restore original state at context exit.</span></div>
<div class="line"><span class="lineno"> 2032</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2033</span>    sentinel = object()</div>
<div class="line"><span class="lineno"> 2034</span>    origs = {}</div>
<div class="line"><span class="lineno"> 2035</span>    <span class="keywordflow">for</span> attr <span class="keywordflow">in</span> kwargs:</div>
<div class="line"><span class="lineno"> 2036</span>        orig = getattr(obj, attr, sentinel)</div>
<div class="line"><span class="lineno"> 2037</span>        <span class="keywordflow">if</span> attr <span class="keywordflow">in</span> obj.__dict__ <span class="keywordflow">or</span> orig <span class="keywordflow">is</span> sentinel:</div>
<div class="line"><span class="lineno"> 2038</span>            <span class="comment"># if we are pulling from the instance dict or the object</span></div>
<div class="line"><span class="lineno"> 2039</span>            <span class="comment"># does not have this attribute we can trust the above</span></div>
<div class="line"><span class="lineno"> 2040</span>            origs[attr] = orig</div>
<div class="line"><span class="lineno"> 2041</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2042</span>            <span class="comment"># if the attribute is not in the instance dict it must be</span></div>
<div class="line"><span class="lineno"> 2043</span>            <span class="comment"># from the class level</span></div>
<div class="line"><span class="lineno"> 2044</span>            cls_orig = getattr(type(obj), attr)</div>
<div class="line"><span class="lineno"> 2045</span>            <span class="comment"># if we are dealing with a property (but not a general descriptor)</span></div>
<div class="line"><span class="lineno"> 2046</span>            <span class="comment"># we want to set the original value back.</span></div>
<div class="line"><span class="lineno"> 2047</span>            <span class="keywordflow">if</span> isinstance(cls_orig, property):</div>
<div class="line"><span class="lineno"> 2048</span>                origs[attr] = orig</div>
<div class="line"><span class="lineno"> 2049</span>            <span class="comment"># otherwise this is _something_ we are going to shadow at</span></div>
<div class="line"><span class="lineno"> 2050</span>            <span class="comment"># the instance dict level from higher up in the MRO.  We</span></div>
<div class="line"><span class="lineno"> 2051</span>            <span class="comment"># are going to assume we can delattr(obj, attr) to clean</span></div>
<div class="line"><span class="lineno"> 2052</span>            <span class="comment"># up after ourselves.  It is possible that this code will</span></div>
<div class="line"><span class="lineno"> 2053</span>            <span class="comment"># fail if used with a non-property custom descriptor which</span></div>
<div class="line"><span class="lineno"> 2054</span>            <span class="comment"># implements __set__ (and __delete__ does not act like a</span></div>
<div class="line"><span class="lineno"> 2055</span>            <span class="comment"># stack).  However, this is an internal tool and we do not</span></div>
<div class="line"><span class="lineno"> 2056</span>            <span class="comment"># currently have any custom descriptors.</span></div>
<div class="line"><span class="lineno"> 2057</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2058</span>                origs[attr] = sentinel</div>
<div class="line"><span class="lineno"> 2059</span> </div>
<div class="line"><span class="lineno"> 2060</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2061</span>        <span class="keywordflow">for</span> attr, val <span class="keywordflow">in</span> kwargs.items():</div>
<div class="line"><span class="lineno"> 2062</span>            setattr(obj, attr, val)</div>
<div class="line"><span class="lineno"> 2063</span>        <span class="keywordflow">yield</span></div>
<div class="line"><span class="lineno"> 2064</span>    <span class="keywordflow">finally</span>:</div>
<div class="line"><span class="lineno"> 2065</span>        <span class="keywordflow">for</span> attr, orig <span class="keywordflow">in</span> origs.items():</div>
<div class="line"><span class="lineno"> 2066</span>            <span class="keywordflow">if</span> orig <span class="keywordflow">is</span> sentinel:</div>
<div class="line"><span class="lineno"> 2067</span>                delattr(obj, attr)</div>
<div class="line"><span class="lineno"> 2068</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2069</span>                setattr(obj, attr, orig)</div>
<div class="line"><span class="lineno"> 2070</span> </div>
<div class="line"><span class="lineno"> 2071</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a28c2cb0a13c60720d2362f88f4922ca0" name="a28c2cb0a13c60720d2362f88f4922ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c2cb0a13c60720d2362f88f4922ca0">&#9670;&#160;</a></span>_setup_new_guiapp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._setup_new_guiapp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Perform OS-dependent setup when Matplotlib creates a new GUI application.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2202</span><span class="keyword">def </span>_setup_new_guiapp():</div>
<div class="line"><span class="lineno"> 2203</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2204</span><span class="stringliteral">    Perform OS-dependent setup when Matplotlib creates a new GUI application.</span></div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2206</span>    <span class="comment"># Windows: If not explicit app user model id has been set yet (so we&#39;re not</span></div>
<div class="line"><span class="lineno"> 2207</span>    <span class="comment"># already embedded), then set it to &quot;matplotlib&quot;, so that taskbar icons are</span></div>
<div class="line"><span class="lineno"> 2208</span>    <span class="comment"># correct.</span></div>
<div class="line"><span class="lineno"> 2209</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2210</span>        _c_internal_utils.Win32_GetCurrentProcessExplicitAppUserModelID()</div>
<div class="line"><span class="lineno"> 2211</span>    <span class="keywordflow">except</span> OSError:</div>
<div class="line"><span class="lineno"> 2212</span>        _c_internal_utils.Win32_SetCurrentProcessExplicitAppUserModelID(</div>
<div class="line"><span class="lineno"> 2213</span>            <span class="stringliteral">&quot;matplotlib&quot;</span>)</div>
<div class="line"><span class="lineno"> 2214</span> </div>
<div class="line"><span class="lineno"> 2215</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b7397fb4d93e6422ba2765dcfc8df22" name="a6b7397fb4d93e6422ba2765dcfc8df22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7397fb4d93e6422ba2765dcfc8df22">&#9670;&#160;</a></span>_str_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._str_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return whether *obj* is a string equal to string *s*.

This helper solely exists to handle the case where *obj* is a numpy array,
because in such cases, a naive ``obj == s`` would yield an array, which
cannot be used in a boolean context.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1868</span><span class="keyword">def </span>_str_equal(obj, s):</div>
<div class="line"><span class="lineno"> 1869</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">    Return whether *obj* is a string equal to string *s*.</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">    This helper solely exists to handle the case where *obj* is a numpy array,</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">    because in such cases, a naive ``obj == s`` would yield an array, which</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral">    cannot be used in a boolean context.</span></div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1876</span>    <span class="keywordflow">return</span> isinstance(obj, str) <span class="keywordflow">and</span> obj == s</div>
<div class="line"><span class="lineno"> 1877</span> </div>
<div class="line"><span class="lineno"> 1878</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a337321261dbc8043fca6e63f618001d3" name="a337321261dbc8043fca6e63f618001d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337321261dbc8043fca6e63f618001d3">&#9670;&#160;</a></span>_str_lower_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._str_lower_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return whether *obj* is a string equal, when lowercased, to string *s*.

This helper solely exists to handle the case where *obj* is a numpy array,
because in such cases, a naive ``obj == s`` would yield an array, which
cannot be used in a boolean context.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1879</span><span class="keyword">def </span>_str_lower_equal(obj, s):</div>
<div class="line"><span class="lineno"> 1880</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">    Return whether *obj* is a string equal, when lowercased, to string *s*.</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral">    This helper solely exists to handle the case where *obj* is a numpy array,</span></div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">    because in such cases, a naive ``obj == s`` would yield an array, which</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">    cannot be used in a boolean context.</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1887</span>    <span class="keywordflow">return</span> isinstance(obj, str) <span class="keywordflow">and</span> obj.lower() == s</div>
<div class="line"><span class="lineno"> 1888</span> </div>
<div class="line"><span class="lineno"> 1889</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae261a6b14eaeac6086209c9ffcacd275" name="ae261a6b14eaeac6086209c9ffcacd275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae261a6b14eaeac6086209c9ffcacd275">&#9670;&#160;</a></span>_strip_comment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._strip_comment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Strip everything from the first unquoted #.</pre> <div class="fragment"><div class="line"><span class="lineno">  414</span><span class="keyword">def </span>_strip_comment(s):</div>
<div class="line"><span class="lineno">  415</span>    <span class="stringliteral">&quot;&quot;&quot;Strip everything from the first unquoted #.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  416</span>    pos = 0</div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  418</span>        quote_pos = s.find(<span class="stringliteral">&#39;&quot;&#39;</span>, pos)</div>
<div class="line"><span class="lineno">  419</span>        hash_pos = s.find(<span class="stringliteral">&#39;#&#39;</span>, pos)</div>
<div class="line"><span class="lineno">  420</span>        <span class="keywordflow">if</span> quote_pos &lt; 0:</div>
<div class="line"><span class="lineno">  421</span>            without_comment = s <span class="keywordflow">if</span> hash_pos &lt; 0 <span class="keywordflow">else</span> s[:hash_pos]</div>
<div class="line"><span class="lineno">  422</span>            <span class="keywordflow">return</span> without_comment.strip()</div>
<div class="line"><span class="lineno">  423</span>        <span class="keywordflow">elif</span> 0 &lt;= hash_pos &lt; quote_pos:</div>
<div class="line"><span class="lineno">  424</span>            <span class="keywordflow">return</span> s[:hash_pos].strip()</div>
<div class="line"><span class="lineno">  425</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  426</span>            closing_quote_pos = s.find(<span class="stringliteral">&#39;&quot;&#39;</span>, quote_pos + 1)</div>
<div class="line"><span class="lineno">  427</span>            <span class="keywordflow">if</span> closing_quote_pos &lt; 0:</div>
<div class="line"><span class="lineno">  428</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  429</span>                    f<span class="stringliteral">&quot;Missing closing quote in: {s!r}. If you need a double-&quot;</span></div>
<div class="line"><span class="lineno">  430</span>                    <span class="stringliteral">&#39;quote inside a string, use escaping: e.g. &quot;the \&quot; char&quot;&#39;</span>)</div>
<div class="line"><span class="lineno">  431</span>            pos = closing_quote_pos + 1  <span class="comment"># behind closing quote</span></div>
<div class="line"><span class="lineno">  432</span> </div>
<div class="line"><span class="lineno">  433</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad249e91f741a55f32f6bf9822b197af8" name="ad249e91f741a55f32f6bf9822b197af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad249e91f741a55f32f6bf9822b197af8">&#9670;&#160;</a></span>_to_unmasked_float_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._to_unmasked_float_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a sequence to a float array; if input was a masked array, masked
values are converted to nans.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1361</span><span class="keyword">def </span>_to_unmasked_float_array(x):</div>
<div class="line"><span class="lineno"> 1362</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    Convert a sequence to a float array; if input was a masked array, masked</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    values are converted to nans.</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1366</span>    <span class="keywordflow">if</span> hasattr(x, <span class="stringliteral">&#39;mask&#39;</span>):</div>
<div class="line"><span class="lineno"> 1367</span>        <span class="keywordflow">return</span> np.ma.asarray(x, float).filled(np.nan)</div>
<div class="line"><span class="lineno"> 1368</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1369</span>        <span class="keywordflow">return</span> np.asarray(x, float)</div>
<div class="line"><span class="lineno"> 1370</span> </div>
<div class="line"><span class="lineno"> 1371</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b338551ede51e78c27afe25c36abdd6" name="a7b338551ede51e78c27afe25c36abdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b338551ede51e78c27afe25c36abdd6">&#9670;&#160;</a></span>_topmost_artist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._topmost_artist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>artists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_cached_max</em> = <code>functools.partial(max,&#160;key=operator.attrgetter(&quot;zorder&quot;))</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get the topmost artist of a list.

In case of a tie, return the *last* of the tied artists, as it will be
drawn on top of the others. `max` returns the first maximum in case of
ties, so we need to iterate over the list in reverse order.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1857</span>        _cached_max=functools.partial(max, key=operator.attrgetter(<span class="stringliteral">&quot;zorder&quot;</span>))):</div>
<div class="line"><span class="lineno"> 1858</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    Get the topmost artist of a list.</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">    In case of a tie, return the *last* of the tied artists, as it will be</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">    drawn on top of the others. `max` returns the first maximum in case of</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    ties, so we need to iterate over the list in reverse order.</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1865</span>    <span class="keywordflow">return</span> _cached_max(reversed(artists))</div>
<div class="line"><span class="lineno"> 1866</span> </div>
<div class="line"><span class="lineno"> 1867</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e1b7d0d215afd906f3842ed8fca8076" name="a3e1b7d0d215afd906f3842ed8fca8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1b7d0d215afd906f3842ed8fca8076">&#9670;&#160;</a></span>_unfold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._unfold </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Append an extra dimension containing sliding windows along *axis*.

All windows are of size *size* and begin with every *step* elements.

Parameters
----------
arr : ndarray, shape (N_1, ..., N_k)
    The input array
axis : int
    Axis along which the windows are extracted
size : int
    Size of the windows
step : int
    Stride between first elements of subsequent windows.

Returns
-------
ndarray, shape (N_1, ..., 1 + (N_axis-size)/step, ..., N_k, size)

Examples
--------
&gt;&gt;&gt; i, j = np.ogrid[:3, :7]
&gt;&gt;&gt; a = i*10 + j
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4,  5,  6],
       [10, 11, 12, 13, 14, 15, 16],
       [20, 21, 22, 23, 24, 25, 26]])
&gt;&gt;&gt; _unfold(a, axis=1, size=3, step=2)
array([[[ 0,  1,  2],
        [ 2,  3,  4],
        [ 4,  5,  6]],
       [[10, 11, 12],
        [12, 13, 14],
        [14, 15, 16]],
       [[20, 21, 22],
        [22, 23, 24],
        [24, 25, 26]]])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1929</span><span class="keyword">def </span>_unfold(arr, axis, size, step):</div>
<div class="line"><span class="lineno"> 1930</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">    Append an extra dimension containing sliding windows along *axis*.</span></div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">    All windows are of size *size* and begin with every *step* elements.</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral">    arr : ndarray, shape (N_1, ..., N_k)</span></div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral">        The input array</span></div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral">        Axis along which the windows are extracted</span></div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral">    size : int</span></div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">        Size of the windows</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">    step : int</span></div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">        Stride between first elements of subsequent windows.</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral">    ndarray, shape (N_1, ..., 1 + (N_axis-size)/step, ..., N_k, size)</span></div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1950</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1951</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1952</span><span class="stringliteral">    &gt;&gt;&gt; i, j = np.ogrid[:3, :7]</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral">    &gt;&gt;&gt; a = i*10 + j</span></div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">    array([[ 0,  1,  2,  3,  4,  5,  6],</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral">           [10, 11, 12, 13, 14, 15, 16],</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral">           [20, 21, 22, 23, 24, 25, 26]])</span></div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">    &gt;&gt;&gt; _unfold(a, axis=1, size=3, step=2)</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">    array([[[ 0,  1,  2],</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">            [ 2,  3,  4],</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">            [ 4,  5,  6]],</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">           [[10, 11, 12],</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">            [12, 13, 14],</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral">            [14, 15, 16]],</span></div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">           [[20, 21, 22],</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">            [22, 23, 24],</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">            [24, 25, 26]]])</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1969</span>    new_shape = [*arr.shape, size]</div>
<div class="line"><span class="lineno"> 1970</span>    new_strides = [*arr.strides, arr.strides[axis]]</div>
<div class="line"><span class="lineno"> 1971</span>    new_shape[axis] = (new_shape[axis] - size) // step + 1</div>
<div class="line"><span class="lineno"> 1972</span>    new_strides[axis] = new_strides[axis] * step</div>
<div class="line"><span class="lineno"> 1973</span>    <span class="keywordflow">return</span> np.lib.stride_tricks.as_strided(arr,</div>
<div class="line"><span class="lineno"> 1974</span>                                           shape=new_shape,</div>
<div class="line"><span class="lineno"> 1975</span>                                           strides=new_strides,</div>
<div class="line"><span class="lineno"> 1976</span>                                           writeable=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1977</span> </div>
<div class="line"><span class="lineno"> 1978</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a133998aa5b4c40759be93a618a798a0e" name="a133998aa5b4c40759be93a618a798a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133998aa5b4c40759be93a618a798a0e">&#9670;&#160;</a></span>_unikey_or_keysym_to_mplkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._unikey_or_keysym_to_mplkey </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unikey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keysym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a Unicode key or X keysym to a Matplotlib key name.

The Unicode key is checked first; this avoids having to list most printable
keysyms such as ``EuroSign``.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2245</span><span class="keyword">def </span>_unikey_or_keysym_to_mplkey(unikey, keysym):</div>
<div class="line"><span class="lineno"> 2246</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">    Convert a Unicode key or X keysym to a Matplotlib key name.</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral">    The Unicode key is checked first; this avoids having to list most printable</span></div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral">    keysyms such as ``EuroSign``.</span></div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2252</span>    <span class="comment"># For non-printable characters, gtk3 passes &quot;\0&quot; whereas tk passes an &quot;&quot;.</span></div>
<div class="line"><span class="lineno"> 2253</span>    <span class="keywordflow">if</span> unikey <span class="keywordflow">and</span> unikey.isprintable():</div>
<div class="line"><span class="lineno"> 2254</span>        <span class="keywordflow">return</span> unikey</div>
<div class="line"><span class="lineno"> 2255</span>    key = keysym.lower()</div>
<div class="line"><span class="lineno"> 2256</span>    <span class="keywordflow">if</span> key.startswith(<span class="stringliteral">&quot;kp_&quot;</span>):  <span class="comment"># keypad_x (including kp_enter).</span></div>
<div class="line"><span class="lineno"> 2257</span>        key = key[3:]</div>
<div class="line"><span class="lineno"> 2258</span>    <span class="keywordflow">if</span> key.startswith(<span class="stringliteral">&quot;page_&quot;</span>):  <span class="comment"># page_{up,down}</span></div>
<div class="line"><span class="lineno"> 2259</span>        key = key.replace(<span class="stringliteral">&quot;page_&quot;</span>, <span class="stringliteral">&quot;page&quot;</span>)</div>
<div class="line"><span class="lineno"> 2260</span>    <span class="keywordflow">if</span> key.endswith((<span class="stringliteral">&quot;_l&quot;</span>, <span class="stringliteral">&quot;_r&quot;</span>)):  <span class="comment"># alt_l, ctrl_l, shift_l.</span></div>
<div class="line"><span class="lineno"> 2261</span>        key = key[:-2]</div>
<div class="line"><span class="lineno"> 2262</span>    key = {</div>
<div class="line"><span class="lineno"> 2263</span>        <span class="stringliteral">&quot;return&quot;</span>: <span class="stringliteral">&quot;enter&quot;</span>,</div>
<div class="line"><span class="lineno"> 2264</span>        <span class="stringliteral">&quot;prior&quot;</span>: <span class="stringliteral">&quot;pageup&quot;</span>,  <span class="comment"># Used by tk.</span></div>
<div class="line"><span class="lineno"> 2265</span>        <span class="stringliteral">&quot;next&quot;</span>: <span class="stringliteral">&quot;pagedown&quot;</span>,  <span class="comment"># Used by tk.</span></div>
<div class="line"><span class="lineno"> 2266</span>    }.get(key, key)</div>
<div class="line"><span class="lineno"> 2267</span>    <span class="keywordflow">return</span> key</div>
<div class="line"><span class="lineno"> 2268</span> </div>
<div class="line"><span class="lineno"> 2269</span> </div>
<div class="line"><span class="lineno"> 2270</span><span class="preprocessor">@functools.lru_cache(None)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1650c0b8742e83d1de5ef078ed1c0e53" name="a1650c0b8742e83d1de5ef078ed1c0e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1650c0b8742e83d1de5ef078ed1c0e53">&#9670;&#160;</a></span>_unmultiplied_rgba8888_to_premultiplied_argb32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._unmultiplied_rgba8888_to_premultiplied_argb32 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rgba8888</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert an unmultiplied RGBA8888 buffer to a premultiplied ARGB32 buffer.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2115</span><span class="keyword">def </span>_unmultiplied_rgba8888_to_premultiplied_argb32(rgba8888):</div>
<div class="line"><span class="lineno"> 2116</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">    Convert an unmultiplied RGBA8888 buffer to a premultiplied ARGB32 buffer.</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2119</span>    <span class="keywordflow">if</span> sys.byteorder == <span class="stringliteral">&quot;little&quot;</span>:</div>
<div class="line"><span class="lineno"> 2120</span>        argb32 = np.take(rgba8888, [2, 1, 0, 3], axis=2)</div>
<div class="line"><span class="lineno"> 2121</span>        rgb24 = argb32[..., :-1]</div>
<div class="line"><span class="lineno"> 2122</span>        alpha8 = argb32[..., -1:]</div>
<div class="line"><span class="lineno"> 2123</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2124</span>        argb32 = np.take(rgba8888, [3, 0, 1, 2], axis=2)</div>
<div class="line"><span class="lineno"> 2125</span>        alpha8 = argb32[..., :1]</div>
<div class="line"><span class="lineno"> 2126</span>        rgb24 = argb32[..., 1:]</div>
<div class="line"><span class="lineno"> 2127</span>    <span class="comment"># Only bother premultiplying when the alpha channel is not fully opaque,</span></div>
<div class="line"><span class="lineno"> 2128</span>    <span class="comment"># as the cost is not negligible.  The unsafe cast is needed to do the</span></div>
<div class="line"><span class="lineno"> 2129</span>    <span class="comment"># multiplication in-place in an integer buffer.</span></div>
<div class="line"><span class="lineno"> 2130</span>    <span class="keywordflow">if</span> alpha8.min() != 0xff:</div>
<div class="line"><span class="lineno"> 2131</span>        np.multiply(rgb24, alpha8 / 0xff, out=rgb24, casting=<span class="stringliteral">&quot;unsafe&quot;</span>)</div>
<div class="line"><span class="lineno"> 2132</span>    <span class="keywordflow">return</span> argb32</div>
<div class="line"><span class="lineno"> 2133</span> </div>
<div class="line"><span class="lineno"> 2134</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ababb5661eae59d4838cc47c978484452" name="ababb5661eae59d4838cc47c978484452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababb5661eae59d4838cc47c978484452">&#9670;&#160;</a></span>_unpack_to_numpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._unpack_to_numpy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Internal helper to extract data from e.g. pandas and xarray objects.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2324</span><span class="keyword">def </span>_unpack_to_numpy(x):</div>
<div class="line"><span class="lineno"> 2325</span>    <span class="stringliteral">&quot;&quot;&quot;Internal helper to extract data from e.g. pandas and xarray objects.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2326</span>    <span class="keywordflow">if</span> isinstance(x, np.ndarray):</div>
<div class="line"><span class="lineno"> 2327</span>        <span class="comment"># If numpy, return directly</span></div>
<div class="line"><span class="lineno"> 2328</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 2329</span>    <span class="keywordflow">if</span> hasattr(x, <span class="stringliteral">&#39;to_numpy&#39;</span>):</div>
<div class="line"><span class="lineno"> 2330</span>        <span class="comment"># Assume that any function to_numpy() do actually return a numpy array</span></div>
<div class="line"><span class="lineno"> 2331</span>        <span class="keywordflow">return</span> x.to_numpy()</div>
<div class="line"><span class="lineno"> 2332</span>    <span class="keywordflow">if</span> hasattr(x, <span class="stringliteral">&#39;values&#39;</span>):</div>
<div class="line"><span class="lineno"> 2333</span>        xtmp = x.values</div>
<div class="line"><span class="lineno"> 2334</span>        <span class="comment"># For example a dict has a &#39;values&#39; attribute, but it is not a property</span></div>
<div class="line"><span class="lineno"> 2335</span>        <span class="comment"># so in this case we do not want to return a function</span></div>
<div class="line"><span class="lineno"> 2336</span>        <span class="keywordflow">if</span> isinstance(xtmp, np.ndarray):</div>
<div class="line"><span class="lineno"> 2337</span>            <span class="keywordflow">return</span> xtmp</div>
<div class="line"><span class="lineno"> 2338</span>    <span class="keywordflow">return</span> x</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e39620ff7f937326c451e7a49a51177" name="a3e39620ff7f937326c451e7a49a51177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e39620ff7f937326c451e7a49a51177">&#9670;&#160;</a></span>_weak_or_strong_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook._weak_or_strong_ref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a `WeakMethod` wrapping *func* if possible, else a `_StrongRef`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  119</span><span class="keyword">def </span>_weak_or_strong_ref(func, callback):</div>
<div class="line"><span class="lineno">  120</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    Return a `WeakMethod` wrapping *func* if possible, else a `_StrongRef`.</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  123</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  124</span>        <span class="keywordflow">return</span> weakref.WeakMethod(func, callback)</div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  126</span>        <span class="keywordflow">return</span> _StrongRef(func)</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a52b74e34e2ec3a6424c4b5d4e1fc2325" name="a52b74e34e2ec3a6424c4b5d4e1fc2325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b74e34e2ec3a6424c4b5d4e1fc2325">&#9670;&#160;</a></span>boxplot_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.boxplot_stats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>whis</em> = <code>1.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bootstrap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>autorange</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of dictionaries of statistics used to draw a series of box
and whisker plots using `~.Axes.bxp`.

Parameters
----------
X : array-like
Data that will be represented in the boxplots. Should have 2 or
fewer dimensions.

whis : float or (float, float), default: 1.5
The position of the whiskers.

If a float, the lower whisker is at the lowest datum above
``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below
``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third
quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's
original definition of boxplots.

If a pair of floats, they indicate the percentiles at which to draw the
whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)
results in whiskers covering the whole range of the data.

In the edge case where ``Q1 == Q3``, *whis* is automatically set to
(0, 100) (cover the whole range of the data) if *autorange* is True.

Beyond the whiskers, data are considered outliers and are plotted as
individual points.

bootstrap : int, optional
Number of times the confidence intervals around the median
should be bootstrapped (percentile method).

labels : array-like, optional
Labels for each dataset. Length must be compatible with
dimensions of *X*.

autorange : bool, optional (False)
When `True` and the data are distributed such that the 25th and 75th
percentiles are equal, ``whis`` is set to (0, 100) such that the
whisker ends are at the minimum and maximum of the data.

Returns
-------
list of dict
A list of dictionaries containing the results for each column
of data. Keys of each dictionary are the following:

========   ===================================
Key        Value Description
========   ===================================
label      tick label for the boxplot
mean       arithmetic mean value
med        50th percentile
q1         first quartile (25th percentile)
q3         third quartile (75th percentile)
iqr        interquartile range
cilo       lower notch around the median
cihi       upper notch around the median
whislo     end of the lower whisker
whishi     end of the upper whisker
fliers     outliers
========   ===================================

Notes
-----
Non-bootstrapping approach to confidence interval uses Gaussian-based
asymptotic approximation:

.. math::

\mathrm{med} \pm 1.57 \times \frac{\mathrm{iqr}}{\sqrt{N}}

General approach from:
McGill, R., Tukey, J.W., and Larsen, W.A. (1978) "Variations of
Boxplots", The American Statistician, 32:12-16.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1116</span>                  autorange=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 1117</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    Return a list of dictionaries of statistics used to draw a series of box</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    and whisker plots using `~.Axes.bxp`.</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    X : array-like</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">        Data that will be represented in the boxplots. Should have 2 or</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">        fewer dimensions.</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    whis : float or (float, float), default: 1.5</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">        The position of the whiskers.</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">        If a float, the lower whisker is at the lowest datum above</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">        ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">        ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">        quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey&#39;s</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">        original definition of boxplots.</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">        If a pair of floats, they indicate the percentiles at which to draw the</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">        whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">        results in whiskers covering the whole range of the data.</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">        In the edge case where ``Q1 == Q3``, *whis* is automatically set to</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">        (0, 100) (cover the whole range of the data) if *autorange* is True.</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">        Beyond the whiskers, data are considered outliers and are plotted as</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">        individual points.</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    bootstrap : int, optional</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">        Number of times the confidence intervals around the median</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">        should be bootstrapped (percentile method).</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    labels : array-like, optional</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">        Labels for each dataset. Length must be compatible with</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">        dimensions of *X*.</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    autorange : bool, optional (False)</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">        When `True` and the data are distributed such that the 25th and 75th</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">        percentiles are equal, ``whis`` is set to (0, 100) such that the</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">        whisker ends are at the minimum and maximum of the data.</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    list of dict</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">        A list of dictionaries containing the results for each column</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">        of data. Keys of each dictionary are the following:</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">        ========   ===================================</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">        Key        Value Description</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">        ========   ===================================</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">        label      tick label for the boxplot</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">        mean       arithmetic mean value</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">        med        50th percentile</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">        q1         first quartile (25th percentile)</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">        q3         third quartile (75th percentile)</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">        iqr        interquartile range</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">        cilo       lower notch around the median</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">        cihi       upper notch around the median</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">        whislo     end of the lower whisker</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">        whishi     end of the upper whisker</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">        fliers     outliers</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">        ========   ===================================</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    Non-bootstrapping approach to confidence interval uses Gaussian-based</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    asymptotic approximation:</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">        \mathrm{med} \pm 1.57 \times \frac{\mathrm{iqr}}{\sqrt{N}}</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    General approach from:</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) &quot;Variations of</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    Boxplots&quot;, The American Statistician, 32:12-16.</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1194</span> </div>
<div class="line"><span class="lineno"> 1195</span>    <span class="keyword">def </span>_bootstrap_median(data, N=5000):</div>
<div class="line"><span class="lineno"> 1196</span>        <span class="comment"># determine 95% confidence intervals of the median</span></div>
<div class="line"><span class="lineno"> 1197</span>        M = len(data)</div>
<div class="line"><span class="lineno"> 1198</span>        percentiles = [2.5, 97.5]</div>
<div class="line"><span class="lineno"> 1199</span> </div>
<div class="line"><span class="lineno"> 1200</span>        bs_index = np.random.randint(M, size=(N, M))</div>
<div class="line"><span class="lineno"> 1201</span>        bsData = data[bs_index]</div>
<div class="line"><span class="lineno"> 1202</span>        estimate = np.median(bsData, axis=1, overwrite_input=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1203</span> </div>
<div class="line"><span class="lineno"> 1204</span>        CI = np.percentile(estimate, percentiles)</div>
<div class="line"><span class="lineno"> 1205</span>        <span class="keywordflow">return</span> CI</div>
<div class="line"><span class="lineno"> 1206</span> </div>
<div class="line"><span class="lineno"> 1207</span>    <span class="keyword">def </span>_compute_conf_interval(data, med, iqr, bootstrap):</div>
<div class="line"><span class="lineno"> 1208</span>        <span class="keywordflow">if</span> bootstrap <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1209</span>            <span class="comment"># Do a bootstrap estimate of notch locations.</span></div>
<div class="line"><span class="lineno"> 1210</span>            <span class="comment"># get conf. intervals around median</span></div>
<div class="line"><span class="lineno"> 1211</span>            CI = _bootstrap_median(data, N=bootstrap)</div>
<div class="line"><span class="lineno"> 1212</span>            notch_min = CI[0]</div>
<div class="line"><span class="lineno"> 1213</span>            notch_max = CI[1]</div>
<div class="line"><span class="lineno"> 1214</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1215</span> </div>
<div class="line"><span class="lineno"> 1216</span>            N = len(data)</div>
<div class="line"><span class="lineno"> 1217</span>            notch_min = med - 1.57 * iqr / np.sqrt(N)</div>
<div class="line"><span class="lineno"> 1218</span>            notch_max = med + 1.57 * iqr / np.sqrt(N)</div>
<div class="line"><span class="lineno"> 1219</span> </div>
<div class="line"><span class="lineno"> 1220</span>        <span class="keywordflow">return</span> notch_min, notch_max</div>
<div class="line"><span class="lineno"> 1221</span> </div>
<div class="line"><span class="lineno"> 1222</span>    <span class="comment"># output is a list of dicts</span></div>
<div class="line"><span class="lineno"> 1223</span>    bxpstats = []</div>
<div class="line"><span class="lineno"> 1224</span> </div>
<div class="line"><span class="lineno"> 1225</span>    <span class="comment"># convert X to a list of lists</span></div>
<div class="line"><span class="lineno"> 1226</span>    X = _reshape_2D(X, <span class="stringliteral">&quot;X&quot;</span>)</div>
<div class="line"><span class="lineno"> 1227</span> </div>
<div class="line"><span class="lineno"> 1228</span>    ncols = len(X)</div>
<div class="line"><span class="lineno"> 1229</span>    <span class="keywordflow">if</span> labels <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1230</span>        labels = itertools.repeat(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1231</span>    <span class="keywordflow">elif</span> len(labels) != ncols:</div>
<div class="line"><span class="lineno"> 1232</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Dimensions of labels and X must be compatible&quot;</span>)</div>
<div class="line"><span class="lineno"> 1233</span> </div>
<div class="line"><span class="lineno"> 1234</span>    input_whis = whis</div>
<div class="line"><span class="lineno"> 1235</span>    <span class="keywordflow">for</span> ii, (x, label) <span class="keywordflow">in</span> enumerate(zip(X, labels)):</div>
<div class="line"><span class="lineno"> 1236</span> </div>
<div class="line"><span class="lineno"> 1237</span>        <span class="comment"># empty dict</span></div>
<div class="line"><span class="lineno"> 1238</span>        stats = {}</div>
<div class="line"><span class="lineno"> 1239</span>        <span class="keywordflow">if</span> label <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1240</span>            stats[<span class="stringliteral">&#39;label&#39;</span>] = label</div>
<div class="line"><span class="lineno"> 1241</span> </div>
<div class="line"><span class="lineno"> 1242</span>        <span class="comment"># restore whis to the input values in case it got changed in the loop</span></div>
<div class="line"><span class="lineno"> 1243</span>        whis = input_whis</div>
<div class="line"><span class="lineno"> 1244</span> </div>
<div class="line"><span class="lineno"> 1245</span>        <span class="comment"># note tricksiness, append up here and then mutate below</span></div>
<div class="line"><span class="lineno"> 1246</span>        bxpstats.append(stats)</div>
<div class="line"><span class="lineno"> 1247</span> </div>
<div class="line"><span class="lineno"> 1248</span>        <span class="comment"># if empty, bail</span></div>
<div class="line"><span class="lineno"> 1249</span>        <span class="keywordflow">if</span> len(x) == 0:</div>
<div class="line"><span class="lineno"> 1250</span>            stats[<span class="stringliteral">&#39;fliers&#39;</span>] = np.array([])</div>
<div class="line"><span class="lineno"> 1251</span>            stats[<span class="stringliteral">&#39;mean&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1252</span>            stats[<span class="stringliteral">&#39;med&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1253</span>            stats[<span class="stringliteral">&#39;q1&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1254</span>            stats[<span class="stringliteral">&#39;q3&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1255</span>            stats[<span class="stringliteral">&#39;iqr&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1256</span>            stats[<span class="stringliteral">&#39;cilo&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1257</span>            stats[<span class="stringliteral">&#39;cihi&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1258</span>            stats[<span class="stringliteral">&#39;whislo&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1259</span>            stats[<span class="stringliteral">&#39;whishi&#39;</span>] = np.nan</div>
<div class="line"><span class="lineno"> 1260</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1261</span> </div>
<div class="line"><span class="lineno"> 1262</span>        <span class="comment"># up-convert to an array, just to be safe</span></div>
<div class="line"><span class="lineno"> 1263</span>        x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 1264</span> </div>
<div class="line"><span class="lineno"> 1265</span>        <span class="comment"># arithmetic mean</span></div>
<div class="line"><span class="lineno"> 1266</span>        stats[<span class="stringliteral">&#39;mean&#39;</span>] = np.mean(x)</div>
<div class="line"><span class="lineno"> 1267</span> </div>
<div class="line"><span class="lineno"> 1268</span>        <span class="comment"># medians and quartiles</span></div>
<div class="line"><span class="lineno"> 1269</span>        q1, med, q3 = np.percentile(x, [25, 50, 75])</div>
<div class="line"><span class="lineno"> 1270</span> </div>
<div class="line"><span class="lineno"> 1271</span>        <span class="comment"># interquartile range</span></div>
<div class="line"><span class="lineno"> 1272</span>        stats[<span class="stringliteral">&#39;iqr&#39;</span>] = q3 - q1</div>
<div class="line"><span class="lineno"> 1273</span>        <span class="keywordflow">if</span> stats[<span class="stringliteral">&#39;iqr&#39;</span>] == 0 <span class="keywordflow">and</span> autorange:</div>
<div class="line"><span class="lineno"> 1274</span>            whis = (0, 100)</div>
<div class="line"><span class="lineno"> 1275</span> </div>
<div class="line"><span class="lineno"> 1276</span>        <span class="comment"># conf. interval around median</span></div>
<div class="line"><span class="lineno"> 1277</span>        stats[<span class="stringliteral">&#39;cilo&#39;</span>], stats[<span class="stringliteral">&#39;cihi&#39;</span>] = _compute_conf_interval(</div>
<div class="line"><span class="lineno"> 1278</span>            x, med, stats[<span class="stringliteral">&#39;iqr&#39;</span>], bootstrap</div>
<div class="line"><span class="lineno"> 1279</span>        )</div>
<div class="line"><span class="lineno"> 1280</span> </div>
<div class="line"><span class="lineno"> 1281</span>        <span class="comment"># lowest/highest non-outliers</span></div>
<div class="line"><span class="lineno"> 1282</span>        <span class="keywordflow">if</span> np.iterable(whis) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(whis, str):</div>
<div class="line"><span class="lineno"> 1283</span>            loval, hival = np.percentile(x, whis)</div>
<div class="line"><span class="lineno"> 1284</span>        <span class="keywordflow">elif</span> np.isreal(whis):</div>
<div class="line"><span class="lineno"> 1285</span>            loval = q1 - whis * stats[<span class="stringliteral">&#39;iqr&#39;</span>]</div>
<div class="line"><span class="lineno"> 1286</span>            hival = q3 + whis * stats[<span class="stringliteral">&#39;iqr&#39;</span>]</div>
<div class="line"><span class="lineno"> 1287</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1288</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;whis must be a float or list of percentiles&#39;</span>)</div>
<div class="line"><span class="lineno"> 1289</span> </div>
<div class="line"><span class="lineno"> 1290</span>        <span class="comment"># get high extreme</span></div>
<div class="line"><span class="lineno"> 1291</span>        wiskhi = x[x &lt;= hival]</div>
<div class="line"><span class="lineno"> 1292</span>        <span class="keywordflow">if</span> len(wiskhi) == 0 <span class="keywordflow">or</span> np.max(wiskhi) &lt; q3:</div>
<div class="line"><span class="lineno"> 1293</span>            stats[<span class="stringliteral">&#39;whishi&#39;</span>] = q3</div>
<div class="line"><span class="lineno"> 1294</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1295</span>            stats[<span class="stringliteral">&#39;whishi&#39;</span>] = np.max(wiskhi)</div>
<div class="line"><span class="lineno"> 1296</span> </div>
<div class="line"><span class="lineno"> 1297</span>        <span class="comment"># get low extreme</span></div>
<div class="line"><span class="lineno"> 1298</span>        wisklo = x[x &gt;= loval]</div>
<div class="line"><span class="lineno"> 1299</span>        <span class="keywordflow">if</span> len(wisklo) == 0 <span class="keywordflow">or</span> np.min(wisklo) &gt; q1:</div>
<div class="line"><span class="lineno"> 1300</span>            stats[<span class="stringliteral">&#39;whislo&#39;</span>] = q1</div>
<div class="line"><span class="lineno"> 1301</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1302</span>            stats[<span class="stringliteral">&#39;whislo&#39;</span>] = np.min(wisklo)</div>
<div class="line"><span class="lineno"> 1303</span> </div>
<div class="line"><span class="lineno"> 1304</span>        <span class="comment"># compute a single array of outliers</span></div>
<div class="line"><span class="lineno"> 1305</span>        stats[<span class="stringliteral">&#39;fliers&#39;</span>] = np.concatenate([</div>
<div class="line"><span class="lineno"> 1306</span>            x[x &lt; stats[<span class="stringliteral">&#39;whislo&#39;</span>]],</div>
<div class="line"><span class="lineno"> 1307</span>            x[x &gt; stats[<span class="stringliteral">&#39;whishi&#39;</span>]],</div>
<div class="line"><span class="lineno"> 1308</span>        ])</div>
<div class="line"><span class="lineno"> 1309</span> </div>
<div class="line"><span class="lineno"> 1310</span>        <span class="comment"># add in the remaining stats</span></div>
<div class="line"><span class="lineno"> 1311</span>        stats[<span class="stringliteral">&#39;q1&#39;</span>], stats[<span class="stringliteral">&#39;med&#39;</span>], stats[<span class="stringliteral">&#39;q3&#39;</span>] = q1, med, q3</div>
<div class="line"><span class="lineno"> 1312</span> </div>
<div class="line"><span class="lineno"> 1313</span>    <span class="keywordflow">return</span> bxpstats</div>
<div class="line"><span class="lineno"> 1314</span> </div>
<div class="line"><span class="lineno"> 1315</span> </div>
<div class="line"><span class="lineno"> 1316</span><span class="comment">#: Maps short codes for line style to their full name used by backends.</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5d76f664e49c525a81f696623093978" name="aa5d76f664e49c525a81f696623093978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d76f664e49c525a81f696623093978">&#9670;&#160;</a></span>contiguous_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.contiguous_regions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is
True and we cover all such regions.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1322</span><span class="keyword">def </span>contiguous_regions(mask):</div>
<div class="line"><span class="lineno"> 1323</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    True and we cover all such regions.</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1327</span>    mask = np.asarray(mask, dtype=bool)</div>
<div class="line"><span class="lineno"> 1328</span> </div>
<div class="line"><span class="lineno"> 1329</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> mask.size:</div>
<div class="line"><span class="lineno"> 1330</span>        <span class="keywordflow">return</span> []</div>
<div class="line"><span class="lineno"> 1331</span> </div>
<div class="line"><span class="lineno"> 1332</span>    <span class="comment"># Find the indices of region changes, and correct offset</span></div>
<div class="line"><span class="lineno"> 1333</span>    idx, = np.nonzero(mask[:-1] != mask[1:])</div>
<div class="line"><span class="lineno"> 1334</span>    idx += 1</div>
<div class="line"><span class="lineno"> 1335</span> </div>
<div class="line"><span class="lineno"> 1336</span>    <span class="comment"># List operations are faster for moderately sized arrays</span></div>
<div class="line"><span class="lineno"> 1337</span>    idx = idx.tolist()</div>
<div class="line"><span class="lineno"> 1338</span> </div>
<div class="line"><span class="lineno"> 1339</span>    <span class="comment"># Add first and/or last index if needed</span></div>
<div class="line"><span class="lineno"> 1340</span>    <span class="keywordflow">if</span> mask[0]:</div>
<div class="line"><span class="lineno"> 1341</span>        idx = [0] + idx</div>
<div class="line"><span class="lineno"> 1342</span>    <span class="keywordflow">if</span> mask[-1]:</div>
<div class="line"><span class="lineno"> 1343</span>        idx.append(len(mask))</div>
<div class="line"><span class="lineno"> 1344</span> </div>
<div class="line"><span class="lineno"> 1345</span>    <span class="keywordflow">return</span> list(zip(idx[::2], idx[1::2]))</div>
<div class="line"><span class="lineno"> 1346</span> </div>
<div class="line"><span class="lineno"> 1347</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0574192dc644b3f7276891b1a963b533" name="a0574192dc644b3f7276891b1a963b533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0574192dc644b3f7276891b1a963b533">&#9670;&#160;</a></span>delete_masked_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.delete_masked_points </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all masked and/or non-finite points in a set of arguments,
and return the arguments with only the unmasked points remaining.

Arguments can be in any of 5 categories:

1) 1-D masked arrays
2) 1-D ndarrays
3) ndarrays with more than one dimension
4) other non-string iterables
5) anything else

The first argument must be in one of the first four categories;
any argument with a length differing from that of the first
argument (and hence anything in category 5) then will be
passed through unchanged.

Masks are obtained from all arguments of the correct length
in categories 1, 2, and 4; a point is bad if masked in a masked
array or if it is a nan or inf.  No attempt is made to
extract a mask from categories 2, 3, and 4 if `numpy.isfinite`
does not yield a Boolean array.

All input arguments that are not passed unchanged are returned
as ndarrays after removing the points or rows corresponding to
masks in any of the arguments.

A vastly simpler version of this function was originally
written as a helper for Axes.scatter().</pre> <div class="fragment"><div class="line"><span class="lineno">  973</span><span class="keyword">def </span>delete_masked_points(*args):</div>
<div class="line"><span class="lineno">  974</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    Find all masked and/or non-finite points in a set of arguments,</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    and return the arguments with only the unmasked points remaining.</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    Arguments can be in any of 5 categories:</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    1) 1-D masked arrays</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    2) 1-D ndarrays</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    3) ndarrays with more than one dimension</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    4) other non-string iterables</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    5) anything else</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    The first argument must be in one of the first four categories;</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">    any argument with a length differing from that of the first</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">    argument (and hence anything in category 5) then will be</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    passed through unchanged.</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    Masks are obtained from all arguments of the correct length</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    in categories 1, 2, and 4; a point is bad if masked in a masked</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    array or if it is a nan or inf.  No attempt is made to</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    extract a mask from categories 2, 3, and 4 if `numpy.isfinite`</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    does not yield a Boolean array.</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    All input arguments that are not passed unchanged are returned</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    as ndarrays after removing the points or rows corresponding to</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    masks in any of the arguments.</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    A vastly simpler version of this function was originally</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    written as a helper for Axes.scatter().</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1005</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(args):</div>
<div class="line"><span class="lineno"> 1006</span>        <span class="keywordflow">return</span> ()</div>
<div class="line"><span class="lineno"> 1007</span>    <span class="keywordflow">if</span> is_scalar_or_string(args[0]):</div>
<div class="line"><span class="lineno"> 1008</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;First argument must be a sequence&quot;</span>)</div>
<div class="line"><span class="lineno"> 1009</span>    nrecs = len(args[0])</div>
<div class="line"><span class="lineno"> 1010</span>    margs = []</div>
<div class="line"><span class="lineno"> 1011</span>    seqlist = [<span class="keyword">False</span>] * len(args)</div>
<div class="line"><span class="lineno"> 1012</span>    <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(args):</div>
<div class="line"><span class="lineno"> 1013</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(x, str) <span class="keywordflow">and</span> np.iterable(x) <span class="keywordflow">and</span> len(x) == nrecs:</div>
<div class="line"><span class="lineno"> 1014</span>            seqlist[i] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1015</span>            <span class="keywordflow">if</span> isinstance(x, np.ma.MaskedArray):</div>
<div class="line"><span class="lineno"> 1016</span>                <span class="keywordflow">if</span> x.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 1017</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Masked arrays must be 1-D&quot;</span>)</div>
<div class="line"><span class="lineno"> 1018</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1019</span>                x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 1020</span>        margs.append(x)</div>
<div class="line"><span class="lineno"> 1021</span>    masks = []  <span class="comment"># List of masks that are True where good.</span></div>
<div class="line"><span class="lineno"> 1022</span>    <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(margs):</div>
<div class="line"><span class="lineno"> 1023</span>        <span class="keywordflow">if</span> seqlist[i]:</div>
<div class="line"><span class="lineno"> 1024</span>            <span class="keywordflow">if</span> x.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 1025</span>                <span class="keywordflow">continue</span>  <span class="comment"># Don&#39;t try to get nan locations unless 1-D.</span></div>
<div class="line"><span class="lineno"> 1026</span>            <span class="keywordflow">if</span> isinstance(x, np.ma.MaskedArray):</div>
<div class="line"><span class="lineno"> 1027</span>                masks.append(~np.ma.getmaskarray(x))  <span class="comment"># invert the mask</span></div>
<div class="line"><span class="lineno"> 1028</span>                xd = x.data</div>
<div class="line"><span class="lineno"> 1029</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1030</span>                xd = x</div>
<div class="line"><span class="lineno"> 1031</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1032</span>                mask = np.isfinite(xd)</div>
<div class="line"><span class="lineno"> 1033</span>                <span class="keywordflow">if</span> isinstance(mask, np.ndarray):</div>
<div class="line"><span class="lineno"> 1034</span>                    masks.append(mask)</div>
<div class="line"><span class="lineno"> 1035</span>            <span class="keywordflow">except</span> Exception:  <span class="comment"># Fixme: put in tuple of possible exceptions?</span></div>
<div class="line"><span class="lineno"> 1036</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1037</span>    <span class="keywordflow">if</span> len(masks):</div>
<div class="line"><span class="lineno"> 1038</span>        mask = np.logical_and.reduce(masks)</div>
<div class="line"><span class="lineno"> 1039</span>        igood = mask.nonzero()[0]</div>
<div class="line"><span class="lineno"> 1040</span>        <span class="keywordflow">if</span> len(igood) &lt; nrecs:</div>
<div class="line"><span class="lineno"> 1041</span>            <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(margs):</div>
<div class="line"><span class="lineno"> 1042</span>                <span class="keywordflow">if</span> seqlist[i]:</div>
<div class="line"><span class="lineno"> 1043</span>                    margs[i] = x[igood]</div>
<div class="line"><span class="lineno"> 1044</span>    <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(margs):</div>
<div class="line"><span class="lineno"> 1045</span>        <span class="keywordflow">if</span> seqlist[i] <span class="keywordflow">and</span> isinstance(x, np.ma.MaskedArray):</div>
<div class="line"><span class="lineno"> 1046</span>            margs[i] = x.filled()</div>
<div class="line"><span class="lineno"> 1047</span>    <span class="keywordflow">return</span> margs</div>
<div class="line"><span class="lineno"> 1048</span> </div>
<div class="line"><span class="lineno"> 1049</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ca7e7ca86e08046948b3456e1a0b46b" name="a7ca7e7ca86e08046948b3456e1a0b46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca7e7ca86e08046948b3456e1a0b46b">&#9670;&#160;</a></span>file_requires_unicode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.file_requires_unicode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the given writable file-like object requires Unicode to be
written to it.
</pre> <div class="fragment"><div class="line"><span class="lineno">  439</span><span class="keyword">def </span>file_requires_unicode(x):</div>
<div class="line"><span class="lineno">  440</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    Return whether the given writable file-like object requires Unicode to be</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    written to it.</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  445</span>        x.write(b<span class="stringliteral">&#39;&#39;</span>)</div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  447</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  449</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a90545f359bbd7e521186d834ee7f0ddb" name="a90545f359bbd7e521186d834ee7f0ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90545f359bbd7e521186d834ee7f0ddb">&#9670;&#160;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.flatten </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scalarp</em> = <code><a class="el" href="namespacematplotlib_1_1cbook.html#a77164721afd81a2b73e8cc7502f72032">is_scalar_or_string</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a generator of flattened nested containers.

For example:

    &gt;&gt;&gt; from matplotlib.cbook import flatten
    &gt;&gt;&gt; l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])
    &gt;&gt;&gt; print(list(flatten(l)))
    ['John', 'Hunter', 1, 23, 42, 5, 23]

By: Composite of Holger Krekel and Luther Blissett
From: https://code.activestate.com/recipes/121294/
and Recipe 1.12 in cookbook
</pre> <div class="fragment"><div class="line"><span class="lineno">  562</span><span class="keyword">def </span>flatten(seq, scalarp=is_scalar_or_string):</div>
<div class="line"><span class="lineno">  563</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    Return a generator of flattened nested containers.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    For example:</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">        &gt;&gt;&gt; from matplotlib.cbook import flatten</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        &gt;&gt;&gt; l = ((&#39;John&#39;, [&#39;Hunter&#39;]), (1, 23), [[([42, (5, 23)], )]])</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        &gt;&gt;&gt; print(list(flatten(l)))</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        [&#39;John&#39;, &#39;Hunter&#39;, 1, 23, 42, 5, 23]</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    By: Composite of Holger Krekel and Luther Blissett</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    From: https://code.activestate.com/recipes/121294/</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    and Recipe 1.12 in cookbook</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  577</span>    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> seq:</div>
<div class="line"><span class="lineno">  578</span>        <span class="keywordflow">if</span> scalarp(item) <span class="keywordflow">or</span> item <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  579</span>            <span class="keywordflow">yield</span> item</div>
<div class="line"><span class="lineno">  580</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  581</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> flatten(item, scalarp)</div>
<div class="line"><span class="lineno">  582</span> </div>
<div class="line"><span class="lineno">  583</span> </div>
<div class="line"><span class="lineno">  584</span><span class="preprocessor">@_api.deprecated(&quot;3.6&quot;, alternative=&quot;functools.lru_cache&quot;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af32a9279c159539e253e9e58f195c054" name="af32a9279c159539e253e9e58f195c054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32a9279c159539e253e9e58f195c054">&#9670;&#160;</a></span>get_sample_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.get_sample_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asfileobj</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>np_load</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sample data file.  *fname* is a path relative to the
:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`
return a file object, otherwise just a file path.

Sample data files are stored in the 'mpl-data/sample_data' directory within
the Matplotlib package.

If the filename ends in .gz, the file is implicitly ungzipped.  If the
filename ends with .npy or .npz, *asfileobj* is True, and *np_load* is
True, the file is loaded with `numpy.load`.  *np_load* currently defaults
to False but will default to True in a future release.
</pre> <div class="fragment"><div class="line"><span class="lineno">  515</span><span class="keyword">def </span>get_sample_data(fname, asfileobj=True, *, np_load=False):</div>
<div class="line"><span class="lineno">  516</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    Return a sample data file.  *fname* is a path relative to the</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    :file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    return a file object, otherwise just a file path.</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    Sample data files are stored in the &#39;mpl-data/sample_data&#39; directory within</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    the Matplotlib package.</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    If the filename ends in .gz, the file is implicitly ungzipped.  If the</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    filename ends with .npy or .npz, *asfileobj* is True, and *np_load* is</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    True, the file is loaded with `numpy.load`.  *np_load* currently defaults</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    to False but will default to True in a future release.</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  529</span>    path = _get_data_path(<span class="stringliteral">&#39;sample_data&#39;</span>, fname)</div>
<div class="line"><span class="lineno">  530</span>    <span class="keywordflow">if</span> asfileobj:</div>
<div class="line"><span class="lineno">  531</span>        suffix = path.suffix.lower()</div>
<div class="line"><span class="lineno">  532</span>        <span class="keywordflow">if</span> suffix == <span class="stringliteral">&#39;.gz&#39;</span>:</div>
<div class="line"><span class="lineno">  533</span>            <span class="keywordflow">return</span> gzip.open(path)</div>
<div class="line"><span class="lineno">  534</span>        <span class="keywordflow">elif</span> suffix <span class="keywordflow">in</span> [<span class="stringliteral">&#39;.npy&#39;</span>, <span class="stringliteral">&#39;.npz&#39;</span>]:</div>
<div class="line"><span class="lineno">  535</span>            <span class="keywordflow">if</span> np_load:</div>
<div class="line"><span class="lineno">  536</span>                <span class="keywordflow">return</span> np.load(path)</div>
<div class="line"><span class="lineno">  537</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  538</span>                _api.warn_deprecated(</div>
<div class="line"><span class="lineno">  539</span>                    <span class="stringliteral">&quot;3.3&quot;</span>, message=<span class="stringliteral">&quot;In a future release, get_sample_data &quot;</span></div>
<div class="line"><span class="lineno">  540</span>                    <span class="stringliteral">&quot;will automatically load numpy arrays.  Set np_load to &quot;</span></div>
<div class="line"><span class="lineno">  541</span>                    <span class="stringliteral">&quot;True to get the array and suppress this warning.  Set &quot;</span></div>
<div class="line"><span class="lineno">  542</span>                    <span class="stringliteral">&quot;asfileobj to False to get the path to the data file and &quot;</span></div>
<div class="line"><span class="lineno">  543</span>                    <span class="stringliteral">&quot;suppress this warning.&quot;</span>)</div>
<div class="line"><span class="lineno">  544</span>                <span class="keywordflow">return</span> path.open(<span class="stringliteral">&#39;rb&#39;</span>)</div>
<div class="line"><span class="lineno">  545</span>        <span class="keywordflow">elif</span> suffix <span class="keywordflow">in</span> [<span class="stringliteral">&#39;.csv&#39;</span>, <span class="stringliteral">&#39;.xrc&#39;</span>, <span class="stringliteral">&#39;.txt&#39;</span>]:</div>
<div class="line"><span class="lineno">  546</span>            <span class="keywordflow">return</span> path.open(<span class="stringliteral">&#39;r&#39;</span>)</div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  548</span>            <span class="keywordflow">return</span> path.open(<span class="stringliteral">&#39;rb&#39;</span>)</div>
<div class="line"><span class="lineno">  549</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  550</span>        <span class="keywordflow">return</span> str(path)</div>
<div class="line"><span class="lineno">  551</span> </div>
<div class="line"><span class="lineno">  552</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b5d1ad31c90a6479c5938d793401a99" name="a3b5d1ad31c90a6479c5938d793401a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5d1ad31c90a6479c5938d793401a99">&#9670;&#160;</a></span>index_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.index_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A helper function to create reasonable x values for the given *y*.

This is used for plotting (x, y) if x values are not explicitly given.

First try ``y.index`` (assuming *y* is a `pandas.Series`), if that
fails, use ``range(len(y))``.

This will be extended in the future to deal with more types of
labeled data.

Parameters
----------
y : float or array-like

Returns
-------
x, y : ndarray
   The x and y values to plot.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1664</span><span class="keyword">def </span>index_of(y):</div>
<div class="line"><span class="lineno"> 1665</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">    A helper function to create reasonable x values for the given *y*.</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    This is used for plotting (x, y) if x values are not explicitly given.</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    fails, use ``range(len(y))``.</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    This will be extended in the future to deal with more types of</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">    labeled data.</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    y : float or array-like</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">    x, y : ndarray</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">       The x and y values to plot.</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1685</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1686</span>        <span class="keywordflow">return</span> y.index.to_numpy(), y.to_numpy()</div>
<div class="line"><span class="lineno"> 1687</span>    <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 1688</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1689</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1690</span>        y = _check_1d(y)</div>
<div class="line"><span class="lineno"> 1691</span>    <span class="keywordflow">except</span> (np.VisibleDeprecationWarning, ValueError):</div>
<div class="line"><span class="lineno"> 1692</span>        <span class="comment"># NumPy 1.19 will warn on ragged input, and we can&#39;t actually use it.</span></div>
<div class="line"><span class="lineno"> 1693</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1694</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1695</span>        <span class="keywordflow">return</span> np.arange(y.shape[0], dtype=float), y</div>
<div class="line"><span class="lineno"> 1696</span>    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Input could not be cast to an at-least-1D NumPy array&#39;</span>)</div>
<div class="line"><span class="lineno"> 1697</span> </div>
<div class="line"><span class="lineno"> 1698</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac9d892c39527908e25bc5bf1bb9414a1" name="ac9d892c39527908e25bc5bf1bb9414a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d892c39527908e25bc5bf1bb9414a1">&#9670;&#160;</a></span>is_math_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.is_math_text </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the string *s* contains math expressions.

This is done by checking whether *s* contains an even number of
non-escaped dollar signs.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1348</span><span class="keyword">def </span>is_math_text(s):</div>
<div class="line"><span class="lineno"> 1349</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    Return whether the string *s* contains math expressions.</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    This is done by checking whether *s* contains an even number of</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    non-escaped dollar signs.</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1355</span>    s = str(s)</div>
<div class="line"><span class="lineno"> 1356</span>    dollar_count = s.count(<span class="stringliteral">r&#39;$&#39;</span>) - s.count(<span class="stringliteral">r&#39;\$&#39;</span>)</div>
<div class="line"><span class="lineno"> 1357</span>    even_dollars = (dollar_count &gt; 0 <span class="keywordflow">and</span> dollar_count % 2 == 0)</div>
<div class="line"><span class="lineno"> 1358</span>    <span class="keywordflow">return</span> even_dollars</div>
<div class="line"><span class="lineno"> 1359</span> </div>
<div class="line"><span class="lineno"> 1360</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a77164721afd81a2b73e8cc7502f72032" name="a77164721afd81a2b73e8cc7502f72032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77164721afd81a2b73e8cc7502f72032">&#9670;&#160;</a></span>is_scalar_or_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.is_scalar_or_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the given object is a scalar or string like.</pre> <div class="fragment"><div class="line"><span class="lineno">  510</span><span class="keyword">def </span>is_scalar_or_string(val):</div>
<div class="line"><span class="lineno">  511</span>    <span class="stringliteral">&quot;&quot;&quot;Return whether the given object is a scalar or string like.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  512</span>    <span class="keywordflow">return</span> isinstance(val, str) <span class="keywordflow">or</span> <span class="keywordflow">not</span> np.iterable(val)</div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a818dda18d21f657aa92908e429b51c1f" name="a818dda18d21f657aa92908e429b51c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818dda18d21f657aa92908e429b51c1f">&#9670;&#160;</a></span>is_writable_file_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.is_writable_file_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether *obj* looks like a file object with a *write* method.</pre> <div class="fragment"><div class="line"><span class="lineno">  434</span><span class="keyword">def </span>is_writable_file_like(obj):</div>
<div class="line"><span class="lineno">  435</span>    <span class="stringliteral">&quot;&quot;&quot;Return whether *obj* looks like a file object with a *write* method.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  436</span>    <span class="keywordflow">return</span> callable(getattr(obj, <span class="stringliteral">&#39;write&#39;</span>, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7263ff5dd36e3ce8c9a99108749f099" name="ae7263ff5dd36e3ce8c9a99108749f099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7263ff5dd36e3ce8c9a99108749f099">&#9670;&#160;</a></span>normalize_kwargs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.normalize_kwargs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alias_mapping</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function to normalize kwarg inputs.

Parameters
----------
kw : dict or None
    A dict of keyword arguments.  None is explicitly supported and treated
    as an empty dict, to support functions with an optional parameter of
    the form ``props=None``.

alias_mapping : dict or Artist subclass or Artist instance, optional
    A mapping between a canonical name to a list of aliases, in order of
    precedence from lowest to highest.

    If the canonical value is not in the list it is assumed to have the
    highest priority.

    If an Artist subclass or instance is passed, use its properties alias
    mapping.

Raises
------
TypeError
    To match what Python raises if invalid arguments/keyword arguments are
    passed to a callable.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1760</span><span class="keyword">def </span>normalize_kwargs(kw, alias_mapping=None):</div>
<div class="line"><span class="lineno"> 1761</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">    Helper function to normalize kwarg inputs.</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">    kw : dict or None</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">        A dict of keyword arguments.  None is explicitly supported and treated</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">        as an empty dict, to support functions with an optional parameter of</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">        the form ``props=None``.</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    alias_mapping : dict or Artist subclass or Artist instance, optional</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">        A mapping between a canonical name to a list of aliases, in order of</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">        precedence from lowest to highest.</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">        If the canonical value is not in the list it is assumed to have the</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">        highest priority.</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">        If an Artist subclass or instance is passed, use its properties alias</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">        mapping.</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">        To match what Python raises if invalid arguments/keyword arguments are</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">        passed to a callable.</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1787</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacematplotlib_1_1artist.html">matplotlib.artist</a> <span class="keyword">import</span> Artist</div>
<div class="line"><span class="lineno"> 1788</span> </div>
<div class="line"><span class="lineno"> 1789</span>    <span class="keywordflow">if</span> kw <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1790</span>        <span class="keywordflow">return</span> {}</div>
<div class="line"><span class="lineno"> 1791</span> </div>
<div class="line"><span class="lineno"> 1792</span>    <span class="comment"># deal with default value of alias_mapping</span></div>
<div class="line"><span class="lineno"> 1793</span>    <span class="keywordflow">if</span> alias_mapping <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1794</span>        alias_mapping = dict()</div>
<div class="line"><span class="lineno"> 1795</span>    <span class="keywordflow">elif</span> (isinstance(alias_mapping, type) <span class="keywordflow">and</span> issubclass(alias_mapping, Artist)</div>
<div class="line"><span class="lineno"> 1796</span>          <span class="keywordflow">or</span> isinstance(alias_mapping, Artist)):</div>
<div class="line"><span class="lineno"> 1797</span>        alias_mapping = getattr(alias_mapping, <span class="stringliteral">&quot;_alias_map&quot;</span>, {})</div>
<div class="line"><span class="lineno"> 1798</span> </div>
<div class="line"><span class="lineno"> 1799</span>    to_canonical = {alias: canonical</div>
<div class="line"><span class="lineno"> 1800</span>                    <span class="keywordflow">for</span> canonical, alias_list <span class="keywordflow">in</span> alias_mapping.items()</div>
<div class="line"><span class="lineno"> 1801</span>                    <span class="keywordflow">for</span> alias <span class="keywordflow">in</span> alias_list}</div>
<div class="line"><span class="lineno"> 1802</span>    canonical_to_seen = {}</div>
<div class="line"><span class="lineno"> 1803</span>    ret = {}  <span class="comment"># output dictionary</span></div>
<div class="line"><span class="lineno"> 1804</span> </div>
<div class="line"><span class="lineno"> 1805</span>    <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> kw.items():</div>
<div class="line"><span class="lineno"> 1806</span>        canonical = to_canonical.get(k, k)</div>
<div class="line"><span class="lineno"> 1807</span>        <span class="keywordflow">if</span> canonical <span class="keywordflow">in</span> canonical_to_seen:</div>
<div class="line"><span class="lineno"> 1808</span>            <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;Got both {canonical_to_seen[canonical]!r} and &quot;</span></div>
<div class="line"><span class="lineno"> 1809</span>                            f<span class="stringliteral">&quot;{k!r}, which are aliases of one another&quot;</span>)</div>
<div class="line"><span class="lineno"> 1810</span>        canonical_to_seen[canonical] = k</div>
<div class="line"><span class="lineno"> 1811</span>        ret[canonical] = v</div>
<div class="line"><span class="lineno"> 1812</span> </div>
<div class="line"><span class="lineno"> 1813</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 1814</span> </div>
<div class="line"><span class="lineno"> 1815</span> </div>
<div class="line"><span class="lineno"> 1816</span><span class="preprocessor">@contextlib.contextmanager</span></div>
<div class="ttc" id="anamespacematplotlib_1_1artist_html"><div class="ttname"><a href="namespacematplotlib_1_1artist.html">matplotlib.artist</a></div><div class="ttdef"><b>Definition</b> artist.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7d5df85847a367d002b2711ed1663f0" name="aa7d5df85847a367d002b2711ed1663f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d5df85847a367d002b2711ed1663f0">&#9670;&#160;</a></span>open_file_cm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.open_file_cm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path_or_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;r&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pass through file objects and context-manage path-likes.</pre> <div class="fragment"><div class="line"><span class="lineno">  504</span><span class="keyword">def </span>open_file_cm(path_or_file, mode=&quot;r&quot;, encoding=None):</div>
<div class="line"><span class="lineno">  505</span>    <span class="stringliteral">r&quot;&quot;&quot;Pass through file objects and context-manage path-likes.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  506</span>    fh, opened = to_filehandle(path_or_file, mode, <span class="keyword">True</span>, encoding)</div>
<div class="line"><span class="lineno">  507</span>    <span class="keywordflow">return</span> fh <span class="keywordflow">if</span> opened <span class="keywordflow">else</span> contextlib.nullcontext(fh)</div>
<div class="line"><span class="lineno">  508</span> </div>
<div class="line"><span class="lineno">  509</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a701b0bb4c152d0bcc615bd421406293b" name="a701b0bb4c152d0bcc615bd421406293b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701b0bb4c152d0bcc615bd421406293b">&#9670;&#160;</a></span>print_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.print_cycles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outstream</em> = <code>sys.stdout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>show_progress</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Print loops of cyclic references in the given *objects*.

It is often useful to pass in ``gc.garbage`` to find the cycles that are
preventing some objects from being garbage collected.

Parameters
----------
objects
    A list of objects to find cycles in.
outstream
    The stream for output.
show_progress : bool
    If True, print the number of objects reached as they are found.
</pre> <div class="fragment"><div class="line"><span class="lineno">  756</span><span class="keyword">def </span>print_cycles(objects, outstream=sys.stdout, show_progress=False):</div>
<div class="line"><span class="lineno">  757</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    Print loops of cyclic references in the given *objects*.</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    It is often useful to pass in ``gc.garbage`` to find the cycles that are</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    preventing some objects from being garbage collected.</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    objects</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        A list of objects to find cycles in.</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    outstream</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">        The stream for output.</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    show_progress : bool</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        If True, print the number of objects reached as they are found.</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  772</span>    <span class="keyword">import</span> gc</div>
<div class="line"><span class="lineno">  773</span> </div>
<div class="line"><span class="lineno">  774</span>    <span class="keyword">def </span>print_path(path):</div>
<div class="line"><span class="lineno">  775</span>        <span class="keywordflow">for</span> i, step <span class="keywordflow">in</span> enumerate(path):</div>
<div class="line"><span class="lineno">  776</span>            <span class="comment"># next &quot;wraps around&quot;</span></div>
<div class="line"><span class="lineno">  777</span>            next = path[(i + 1) % len(path)]</div>
<div class="line"><span class="lineno">  778</span> </div>
<div class="line"><span class="lineno">  779</span>            outstream.write(<span class="stringliteral">&quot;   %s -- &quot;</span> % type(step))</div>
<div class="line"><span class="lineno">  780</span>            <span class="keywordflow">if</span> isinstance(step, dict):</div>
<div class="line"><span class="lineno">  781</span>                <span class="keywordflow">for</span> key, val <span class="keywordflow">in</span> step.items():</div>
<div class="line"><span class="lineno">  782</span>                    <span class="keywordflow">if</span> val <span class="keywordflow">is</span> next:</div>
<div class="line"><span class="lineno">  783</span>                        outstream.write(<span class="stringliteral">&quot;[{!r}]&quot;</span>.format(key))</div>
<div class="line"><span class="lineno">  784</span>                        <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  785</span>                    <span class="keywordflow">if</span> key <span class="keywordflow">is</span> next:</div>
<div class="line"><span class="lineno">  786</span>                        outstream.write(<span class="stringliteral">&quot;[key] = {!r}&quot;</span>.format(val))</div>
<div class="line"><span class="lineno">  787</span>                        <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  788</span>            <span class="keywordflow">elif</span> isinstance(step, list):</div>
<div class="line"><span class="lineno">  789</span>                outstream.write(<span class="stringliteral">&quot;[%d]&quot;</span> % step.index(next))</div>
<div class="line"><span class="lineno">  790</span>            <span class="keywordflow">elif</span> isinstance(step, tuple):</div>
<div class="line"><span class="lineno">  791</span>                outstream.write(<span class="stringliteral">&quot;( tuple )&quot;</span>)</div>
<div class="line"><span class="lineno">  792</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  793</span>                outstream.write(repr(step))</div>
<div class="line"><span class="lineno">  794</span>            outstream.write(<span class="stringliteral">&quot; -&gt;\n&quot;</span>)</div>
<div class="line"><span class="lineno">  795</span>        outstream.write(<span class="stringliteral">&quot;\n&quot;</span>)</div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span>    <span class="keyword">def </span>recurse(obj, start, all, current_path):</div>
<div class="line"><span class="lineno">  798</span>        <span class="keywordflow">if</span> show_progress:</div>
<div class="line"><span class="lineno">  799</span>            outstream.write(<span class="stringliteral">&quot;%d\r&quot;</span> % len(all))</div>
<div class="line"><span class="lineno">  800</span> </div>
<div class="line"><span class="lineno">  801</span>        all[id(obj)] = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  802</span> </div>
<div class="line"><span class="lineno">  803</span>        referents = gc.get_referents(obj)</div>
<div class="line"><span class="lineno">  804</span>        <span class="keywordflow">for</span> referent <span class="keywordflow">in</span> referents:</div>
<div class="line"><span class="lineno">  805</span>            <span class="comment"># If we&#39;ve found our way back to the start, this is</span></div>
<div class="line"><span class="lineno">  806</span>            <span class="comment"># a cycle, so print it out</span></div>
<div class="line"><span class="lineno">  807</span>            <span class="keywordflow">if</span> referent <span class="keywordflow">is</span> start:</div>
<div class="line"><span class="lineno">  808</span>                print_path(current_path)</div>
<div class="line"><span class="lineno">  809</span> </div>
<div class="line"><span class="lineno">  810</span>            <span class="comment"># Don&#39;t go back through the original list of objects, or</span></div>
<div class="line"><span class="lineno">  811</span>            <span class="comment"># through temporary references to the object, since those</span></div>
<div class="line"><span class="lineno">  812</span>            <span class="comment"># are just an artifact of the cycle detector itself.</span></div>
<div class="line"><span class="lineno">  813</span>            <span class="keywordflow">elif</span> referent <span class="keywordflow">is</span> objects <span class="keywordflow">or</span> isinstance(referent, types.FrameType):</div>
<div class="line"><span class="lineno">  814</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  815</span> </div>
<div class="line"><span class="lineno">  816</span>            <span class="comment"># We haven&#39;t seen this object before, so recurse</span></div>
<div class="line"><span class="lineno">  817</span>            <span class="keywordflow">elif</span> id(referent) <span class="keywordflow">not</span> <span class="keywordflow">in</span> all:</div>
<div class="line"><span class="lineno">  818</span>                recurse(referent, start, all, current_path + [obj])</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>    <span class="keywordflow">for</span> obj <span class="keywordflow">in</span> objects:</div>
<div class="line"><span class="lineno">  821</span>        outstream.write(f<span class="stringliteral">&quot;Examining: {obj!r}\n&quot;</span>)</div>
<div class="line"><span class="lineno">  822</span>        recurse(obj, obj, {}, [])</div>
<div class="line"><span class="lineno">  823</span> </div>
<div class="line"><span class="lineno">  824</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac61bb795ec107bf3f683b4c32ecc970a" name="ac61bb795ec107bf3f683b4c32ecc970a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61bb795ec107bf3f683b4c32ecc970a">&#9670;&#160;</a></span>pts_to_midstep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.pts_to_midstep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert continuous line to mid-steps.

Given a set of ``N`` points convert to ``2N`` points which when connected
linearly give a step function which changes values at the middle of the
intervals.

Parameters
----------
x : array
    The x location of the steps. May be empty.

y1, ..., yp : array
    y arrays to be turned into steps; all must be the same length as
    ``x``.

Returns
-------
array
    The x and y values converted to steps in the same order as the input;
    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is
    length ``N``, each of these arrays will be length ``2N``.

Examples
--------
&gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1619</span><span class="keyword">def </span>pts_to_midstep(x, *args):</div>
<div class="line"><span class="lineno"> 1620</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">    Convert continuous line to mid-steps.</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    Given a set of ``N`` points convert to ``2N`` points which when connected</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    linearly give a step function which changes values at the middle of the</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    intervals.</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    x : array</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">        The x location of the steps. May be empty.</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">    y1, ..., yp : array</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">        y arrays to be turned into steps; all must be the same length as</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">        ``x``.</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">    array</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">        The x and y values converted to steps in the same order as the input;</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">        length ``N``, each of these arrays will be length ``2N``.</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">    &gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1647</span>    steps = np.zeros((1 + len(args), 2 * len(x)))</div>
<div class="line"><span class="lineno"> 1648</span>    x = np.asanyarray(x)</div>
<div class="line"><span class="lineno"> 1649</span>    steps[0, 1:-1:2] = steps[0, 2::2] = (x[:-1] + x[1:]) / 2</div>
<div class="line"><span class="lineno"> 1650</span>    steps[0, :1] = x[:1]  <span class="comment"># Also works for zero-sized input.</span></div>
<div class="line"><span class="lineno"> 1651</span>    steps[0, -1:] = x[-1:]</div>
<div class="line"><span class="lineno"> 1652</span>    steps[1:, 0::2] = args</div>
<div class="line"><span class="lineno"> 1653</span>    steps[1:, 1::2] = steps[1:, 0::2]</div>
<div class="line"><span class="lineno"> 1654</span>    <span class="keywordflow">return</span> steps</div>
<div class="line"><span class="lineno"> 1655</span> </div>
<div class="line"><span class="lineno"> 1656</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ab2f98cb68bdff50b1ea50705e01c99" name="a8ab2f98cb68bdff50b1ea50705e01c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab2f98cb68bdff50b1ea50705e01c99">&#9670;&#160;</a></span>pts_to_poststep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.pts_to_poststep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert continuous line to post-steps.

Given a set of ``N`` points convert to ``2N + 1`` points, which when
connected linearly give a step function which changes values at the end of
the intervals.

Parameters
----------
x : array
    The x location of the steps. May be empty.

y1, ..., yp : array
    y arrays to be turned into steps; all must be the same length as ``x``.

Returns
-------
array
    The x and y values converted to steps in the same order as the input;
    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is
    length ``N``, each of these arrays will be length ``2N + 1``. For
    ``N=0``, the length will be 0.

Examples
--------
&gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1583</span><span class="keyword">def </span>pts_to_poststep(x, *args):</div>
<div class="line"><span class="lineno"> 1584</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    Convert continuous line to post-steps.</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    Given a set of ``N`` points convert to ``2N + 1`` points, which when</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    connected linearly give a step function which changes values at the end of</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    the intervals.</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    x : array</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">        The x location of the steps. May be empty.</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    y1, ..., yp : array</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">        y arrays to be turned into steps; all must be the same length as ``x``.</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    array</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">        The x and y values converted to steps in the same order as the input;</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">        length ``N``, each of these arrays will be length ``2N + 1``. For</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        ``N=0``, the length will be 0.</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">    &gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1611</span>    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))</div>
<div class="line"><span class="lineno"> 1612</span>    steps[0, 0::2] = x</div>
<div class="line"><span class="lineno"> 1613</span>    steps[0, 1::2] = steps[0, 2::2]</div>
<div class="line"><span class="lineno"> 1614</span>    steps[1:, 0::2] = args</div>
<div class="line"><span class="lineno"> 1615</span>    steps[1:, 1::2] = steps[1:, 0:-2:2]</div>
<div class="line"><span class="lineno"> 1616</span>    <span class="keywordflow">return</span> steps</div>
<div class="line"><span class="lineno"> 1617</span> </div>
<div class="line"><span class="lineno"> 1618</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a003d9aa87eb2e3afeaf02fc980d4c175" name="a003d9aa87eb2e3afeaf02fc980d4c175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003d9aa87eb2e3afeaf02fc980d4c175">&#9670;&#160;</a></span>pts_to_prestep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.pts_to_prestep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert continuous line to pre-steps.

Given a set of ``N`` points, convert to ``2N - 1`` points, which when
connected linearly give a step function which changes values at the
beginning of the intervals.

Parameters
----------
x : array
    The x location of the steps. May be empty.

y1, ..., yp : array
    y arrays to be turned into steps; all must be the same length as ``x``.

Returns
-------
array
    The x and y values converted to steps in the same order as the input;
    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is
    length ``N``, each of these arrays will be length ``2N + 1``. For
    ``N=0``, the length will be 0.

Examples
--------
&gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1545</span><span class="keyword">def </span>pts_to_prestep(x, *args):</div>
<div class="line"><span class="lineno"> 1546</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    Convert continuous line to pre-steps.</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    Given a set of ``N`` points, convert to ``2N - 1`` points, which when</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    connected linearly give a step function which changes values at the</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    beginning of the intervals.</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    x : array</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">        The x location of the steps. May be empty.</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    y1, ..., yp : array</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">        y arrays to be turned into steps; all must be the same length as ``x``.</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    array</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">        The x and y values converted to steps in the same order as the input;</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">        length ``N``, each of these arrays will be length ``2N + 1``. For</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">        ``N=0``, the length will be 0.</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">    &gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1573</span>    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))</div>
<div class="line"><span class="lineno"> 1574</span>    <span class="comment"># In all `pts_to_*step` functions, only assign once using *x* and *args*,</span></div>
<div class="line"><span class="lineno"> 1575</span>    <span class="comment"># as converting to an array may be expensive.</span></div>
<div class="line"><span class="lineno"> 1576</span>    steps[0, 0::2] = x</div>
<div class="line"><span class="lineno"> 1577</span>    steps[0, 1::2] = steps[0, 0:-2:2]</div>
<div class="line"><span class="lineno"> 1578</span>    steps[1:, 0::2] = args</div>
<div class="line"><span class="lineno"> 1579</span>    steps[1:, 1::2] = steps[1:, 2::2]</div>
<div class="line"><span class="lineno"> 1580</span>    <span class="keywordflow">return</span> steps</div>
<div class="line"><span class="lineno"> 1581</span> </div>
<div class="line"><span class="lineno"> 1582</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a299da0bfc3414c276418ed1808a93b4c" name="a299da0bfc3414c276418ed1808a93b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299da0bfc3414c276418ed1808a93b4c">&#9670;&#160;</a></span>report_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.report_memory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the memory consumed by the process.</pre> <div class="fragment"><div class="line"><span class="lineno">  712</span><span class="keyword">def </span>report_memory(i=0):  <span class="comment"># argument may go away</span></div>
<div class="line"><span class="lineno">  713</span>    <span class="stringliteral">&quot;&quot;&quot;Return the memory consumed by the process.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  714</span>    <span class="keyword">def </span>call(command, os_name):</div>
<div class="line"><span class="lineno">  715</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  716</span>            <span class="keywordflow">return</span> subprocess.check_output(command)</div>
<div class="line"><span class="lineno">  717</span>        <span class="keywordflow">except</span> subprocess.CalledProcessError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  718</span>            <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno">  719</span>                <span class="stringliteral">&quot;report_memory works on %s only if &quot;</span></div>
<div class="line"><span class="lineno">  720</span>                <span class="stringliteral">&quot;the &#39;%s&#39; program is found&quot;</span> % (os_name, command[0])</div>
<div class="line"><span class="lineno">  721</span>            ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span>    pid = os.getpid()</div>
<div class="line"><span class="lineno">  724</span>    <span class="keywordflow">if</span> sys.platform == <span class="stringliteral">&#39;sunos5&#39;</span>:</div>
<div class="line"><span class="lineno">  725</span>        lines = call([<span class="stringliteral">&#39;ps&#39;</span>, <span class="stringliteral">&#39;-p&#39;</span>, <span class="stringliteral">&#39;%d&#39;</span> % pid, <span class="stringliteral">&#39;-o&#39;</span>, <span class="stringliteral">&#39;osz&#39;</span>], <span class="stringliteral">&#39;Sun OS&#39;</span>)</div>
<div class="line"><span class="lineno">  726</span>        mem = int(lines[-1].strip())</div>
<div class="line"><span class="lineno">  727</span>    <span class="keywordflow">elif</span> sys.platform == <span class="stringliteral">&#39;linux&#39;</span>:</div>
<div class="line"><span class="lineno">  728</span>        lines = call([<span class="stringliteral">&#39;ps&#39;</span>, <span class="stringliteral">&#39;-p&#39;</span>, <span class="stringliteral">&#39;%d&#39;</span> % pid, <span class="stringliteral">&#39;-o&#39;</span>, <span class="stringliteral">&#39;rss,sz&#39;</span>], <span class="stringliteral">&#39;Linux&#39;</span>)</div>
<div class="line"><span class="lineno">  729</span>        mem = int(lines[1].split()[1])</div>
<div class="line"><span class="lineno">  730</span>    <span class="keywordflow">elif</span> sys.platform == <span class="stringliteral">&#39;darwin&#39;</span>:</div>
<div class="line"><span class="lineno">  731</span>        lines = call([<span class="stringliteral">&#39;ps&#39;</span>, <span class="stringliteral">&#39;-p&#39;</span>, <span class="stringliteral">&#39;%d&#39;</span> % pid, <span class="stringliteral">&#39;-o&#39;</span>, <span class="stringliteral">&#39;rss,vsz&#39;</span>], <span class="stringliteral">&#39;Mac OS&#39;</span>)</div>
<div class="line"><span class="lineno">  732</span>        mem = int(lines[1].split()[0])</div>
<div class="line"><span class="lineno">  733</span>    <span class="keywordflow">elif</span> sys.platform == <span class="stringliteral">&#39;win32&#39;</span>:</div>
<div class="line"><span class="lineno">  734</span>        lines = call([<span class="stringliteral">&quot;tasklist&quot;</span>, <span class="stringliteral">&quot;/nh&quot;</span>, <span class="stringliteral">&quot;/fi&quot;</span>, <span class="stringliteral">&quot;pid eq %d&quot;</span> % pid], <span class="stringliteral">&#39;Windows&#39;</span>)</div>
<div class="line"><span class="lineno">  735</span>        mem = int(lines.strip().split()[-2].replace(<span class="stringliteral">&#39;,&#39;</span>, <span class="stringliteral">&#39;&#39;</span>))</div>
<div class="line"><span class="lineno">  736</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  737</span>        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno">  738</span>            <span class="stringliteral">&quot;We don&#39;t have a memory monitor for %s&quot;</span> % sys.platform)</div>
<div class="line"><span class="lineno">  739</span>    <span class="keywordflow">return</span> mem</div>
<div class="line"><span class="lineno">  740</span> </div>
<div class="line"><span class="lineno">  741</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ada775c72111d2e19c04b0a34b570cd8f" name="ada775c72111d2e19c04b0a34b570cd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada775c72111d2e19c04b0a34b570cd8f">&#9670;&#160;</a></span>safe_first_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.safe_first_element </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the first element in *obj*.

This is an type-independent way of obtaining the first element,
supporting both index access and the iterator protocol.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1699</span><span class="keyword">def </span>safe_first_element(obj):</div>
<div class="line"><span class="lineno"> 1700</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">    Return the first element in *obj*.</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    This is an type-independent way of obtaining the first element,</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral">    supporting both index access and the iterator protocol.</span></div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1706</span>    <span class="keywordflow">return</span> _safe_first_finite(obj, skip_nonfinite=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1707</span> </div>
<div class="line"><span class="lineno"> 1708</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeaf188d34bbfeb6fd34da4b60388cc88" name="aeaf188d34bbfeb6fd34da4b60388cc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf188d34bbfeb6fd34da4b60388cc88">&#9670;&#160;</a></span>safe_masked_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.safe_masked_invalid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  742</span><span class="keyword">def </span>safe_masked_invalid(x, copy=False):</div>
<div class="line"><span class="lineno">  743</span>    x = np.array(x, subok=<span class="keyword">True</span>, copy=copy)</div>
<div class="line"><span class="lineno">  744</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> x.dtype.isnative:</div>
<div class="line"><span class="lineno">  745</span>        <span class="comment"># If we have already made a copy, do the byteswap in place, else make a</span></div>
<div class="line"><span class="lineno">  746</span>        <span class="comment"># copy with the byte order swapped.</span></div>
<div class="line"><span class="lineno">  747</span>        x = x.byteswap(inplace=copy).newbyteorder(<span class="stringliteral">&#39;N&#39;</span>)  <span class="comment"># Swap to native order.</span></div>
<div class="line"><span class="lineno">  748</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  749</span>        xm = np.ma.masked_invalid(x, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  750</span>        xm.shrink_mask()</div>
<div class="line"><span class="lineno">  751</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  752</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">  753</span>    <span class="keywordflow">return</span> xm</div>
<div class="line"><span class="lineno">  754</span> </div>
<div class="line"><span class="lineno">  755</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af3c74e70d962066a34fd7ffc9707fb65" name="af3c74e70d962066a34fd7ffc9707fb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c74e70d962066a34fd7ffc9707fb65">&#9670;&#160;</a></span>sanitize_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.sanitize_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert dictview objects to list. Other inputs are returned unchanged.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1752</span><span class="keyword">def </span>sanitize_sequence(data):</div>
<div class="line"><span class="lineno"> 1753</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">    Convert dictview objects to list. Other inputs are returned unchanged.</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1756</span>    <span class="keywordflow">return</span> (list(data) <span class="keywordflow">if</span> isinstance(data, collections.abc.MappingView)</div>
<div class="line"><span class="lineno"> 1757</span>            <span class="keywordflow">else</span> data)</div>
<div class="line"><span class="lineno"> 1758</span> </div>
<div class="line"><span class="lineno"> 1759</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7009c1e775ac01e9aba6eb62178e8b30" name="a7009c1e775ac01e9aba6eb62178e8b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7009c1e775ac01e9aba6eb62178e8b30">&#9670;&#160;</a></span>simple_linear_interpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.simple_linear_interpolation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Resample an array with ``steps - 1`` points between original point pairs.

Along each column of *a*, ``(steps - 1)`` points are introduced between
each original values; the values are linearly interpolated.

Parameters
----------
a : array, shape (n, ...)
steps : int

Returns
-------
array
    shape ``((n - 1) * steps + 1, ...)``
</pre> <div class="fragment"><div class="line"><span class="lineno">  949</span><span class="keyword">def </span>simple_linear_interpolation(a, steps):</div>
<div class="line"><span class="lineno">  950</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    Resample an array with ``steps - 1`` points between original point pairs.</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    Along each column of *a*, ``(steps - 1)`` points are introduced between</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">    each original values; the values are linearly interpolated.</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">    a : array, shape (n, ...)</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    steps : int</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    array</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">        shape ``((n - 1) * steps + 1, ...)``</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  966</span>    fps = a.reshape((len(a), -1))</div>
<div class="line"><span class="lineno">  967</span>    xp = np.arange(len(a)) * steps</div>
<div class="line"><span class="lineno">  968</span>    x = np.arange((len(a) - 1) * steps + 1)</div>
<div class="line"><span class="lineno">  969</span>    <span class="keywordflow">return</span> (np.column_stack([np.interp(x, xp, fp) <span class="keywordflow">for</span> fp <span class="keywordflow">in</span> fps.T])</div>
<div class="line"><span class="lineno">  970</span>            .reshape((len(x),) + a.shape[1:]))</div>
<div class="line"><span class="lineno">  971</span> </div>
<div class="line"><span class="lineno">  972</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1ea7c7c3361971b38b78d6e568e0025" name="aa1ea7c7c3361971b38b78d6e568e0025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ea7c7c3361971b38b78d6e568e0025">&#9670;&#160;</a></span>strip_math()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.strip_math </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove latex formatting from mathtext.

Only handles fully math and fully non-math strings.
</pre> <div class="fragment"><div class="line"><span class="lineno">  391</span><span class="keyword">def </span>strip_math(s):</div>
<div class="line"><span class="lineno">  392</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    Remove latex formatting from mathtext.</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    Only handles fully math and fully non-math strings.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  397</span>    <span class="keywordflow">if</span> len(s) &gt;= 2 <span class="keywordflow">and</span> s[0] == s[-1] == <span class="stringliteral">&quot;$&quot;</span>:</div>
<div class="line"><span class="lineno">  398</span>        s = s[1:-1]</div>
<div class="line"><span class="lineno">  399</span>        <span class="keywordflow">for</span> tex, plain <span class="keywordflow">in</span> [</div>
<div class="line"><span class="lineno">  400</span>                (<span class="stringliteral">r&quot;\times&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>),  <span class="comment"># Specifically for Formatter support.</span></div>
<div class="line"><span class="lineno">  401</span>                (<span class="stringliteral">r&quot;\mathdefault&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  402</span>                (<span class="stringliteral">r&quot;\rm&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  403</span>                (<span class="stringliteral">r&quot;\cal&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  404</span>                (<span class="stringliteral">r&quot;\tt&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  405</span>                (<span class="stringliteral">r&quot;\it&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  406</span>                (<span class="stringliteral">&quot;\\&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  407</span>                (<span class="stringliteral">&quot;{&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  408</span>                (<span class="stringliteral">&quot;}&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line"><span class="lineno">  409</span>        ]:</div>
<div class="line"><span class="lineno">  410</span>            s = s.replace(tex, plain)</div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">return</span> s</div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae466f3a4c5faca4911ec7caa9ab003dc" name="ae466f3a4c5faca4911ec7caa9ab003dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae466f3a4c5faca4911ec7caa9ab003dc">&#9670;&#160;</a></span>to_filehandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.to_filehandle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flag</em> = <code>'<a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_opened</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a path to an open file handle or pass-through a file-like object.

Consider using `open_file_cm` instead, as it allows one to properly close
newly created file objects more easily.

Parameters
----------
fname : str or path-like or file-like
    If `str` or `os.PathLike`, the file is opened using the flags specified
    by *flag* and *encoding*.  If a file-like object, it is passed through.
flag : str, default: 'r'
    Passed as the *mode* argument to `open` when *fname* is `str` or
    `os.PathLike`; ignored if *fname* is file-like.
return_opened : bool, default: False
    If True, return both the file object and a boolean indicating whether
    this was a new file (that the caller needs to close).  If False, return
    only the new file.
encoding : str or None, default: None
    Passed as the *mode* argument to `open` when *fname* is `str` or
    `os.PathLike`; ignored if *fname* is file-like.

Returns
-------
fh : file-like
opened : bool
    *opened* is only returned if *return_opened* is True.
</pre> <div class="fragment"><div class="line"><span class="lineno">  452</span><span class="keyword">def </span>to_filehandle(fname, flag=&#39;r&#39;, return_opened=False, encoding=None):</div>
<div class="line"><span class="lineno">  453</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    Convert a path to an open file handle or pass-through a file-like object.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Consider using `open_file_cm` instead, as it allows one to properly close</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    newly created file objects more easily.</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    fname : str or path-like or file-like</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        If `str` or `os.PathLike`, the file is opened using the flags specified</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        by *flag* and *encoding*.  If a file-like object, it is passed through.</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    flag : str, default: &#39;r&#39;</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">        Passed as the *mode* argument to `open` when *fname* is `str` or</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">        `os.PathLike`; ignored if *fname* is file-like.</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    return_opened : bool, default: False</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        If True, return both the file object and a boolean indicating whether</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        this was a new file (that the caller needs to close).  If False, return</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        only the new file.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    encoding : str or None, default: None</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        Passed as the *mode* argument to `open` when *fname* is `str` or</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        `os.PathLike`; ignored if *fname* is file-like.</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    fh : file-like</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    opened : bool</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        *opened* is only returned if *return_opened* is True.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  481</span>    <span class="keywordflow">if</span> isinstance(fname, os.PathLike):</div>
<div class="line"><span class="lineno">  482</span>        fname = os.fspath(fname)</div>
<div class="line"><span class="lineno">  483</span>    <span class="keywordflow">if</span> isinstance(fname, str):</div>
<div class="line"><span class="lineno">  484</span>        <span class="keywordflow">if</span> fname.endswith(<span class="stringliteral">&#39;.gz&#39;</span>):</div>
<div class="line"><span class="lineno">  485</span>            fh = gzip.open(fname, flag)</div>
<div class="line"><span class="lineno">  486</span>        <span class="keywordflow">elif</span> fname.endswith(<span class="stringliteral">&#39;.bz2&#39;</span>):</div>
<div class="line"><span class="lineno">  487</span>            <span class="comment"># python may not be compiled with bz2 support,</span></div>
<div class="line"><span class="lineno">  488</span>            <span class="comment"># bury import until we need it</span></div>
<div class="line"><span class="lineno">  489</span>            <span class="keyword">import</span> bz2</div>
<div class="line"><span class="lineno">  490</span>            fh = bz2.BZ2File(fname, flag)</div>
<div class="line"><span class="lineno">  491</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  492</span>            fh = open(fname, flag, encoding=encoding)</div>
<div class="line"><span class="lineno">  493</span>        opened = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">elif</span> hasattr(fname, <span class="stringliteral">&#39;seek&#39;</span>):</div>
<div class="line"><span class="lineno">  495</span>        fh = fname</div>
<div class="line"><span class="lineno">  496</span>        opened = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  497</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  498</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;fname must be a PathLike or file handle&#39;</span>)</div>
<div class="line"><span class="lineno">  499</span>    <span class="keywordflow">if</span> return_opened:</div>
<div class="line"><span class="lineno">  500</span>        <span class="keywordflow">return</span> fh, opened</div>
<div class="line"><span class="lineno">  501</span>    <span class="keywordflow">return</span> fh</div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a90e7862da93ffb8e0f23314d55a8654c" name="a90e7862da93ffb8e0f23314d55a8654c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e7862da93ffb8e0f23314d55a8654c">&#9670;&#160;</a></span>violin_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.cbook.violin_stats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>quantiles</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of dictionaries of data which can be used to draw a series
of violin plots.

See the ``Returns`` section below to view the required keys of the
dictionary.

Users can skip this function and pass a user-defined set of dictionaries
with the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib
to do the calculations. See the *Returns* section below for the keys
that must be present in the dictionaries.

Parameters
----------
X : array-like
    Sample data that will be used to produce the gaussian kernel density
    estimates. Must have 2 or fewer dimensions.

method : callable
    The method used to calculate the kernel density estimate for each
    column of data. When called via ``method(v, coords)``, it should
    return a vector of the values of the KDE evaluated at the values
    specified in coords.

points : int, default: 100
    Defines the number of points to evaluate each of the gaussian kernel
    density estimates at.

quantiles : array-like, default: None
    Defines (if not None) a list of floats in interval [0, 1] for each
    column of data, which represents the quantiles that will be rendered
    for that column of data. Must have 2 or fewer dimensions. 1D array will
    be treated as a singleton list containing them.

Returns
-------
list of dict
    A list of dictionaries containing the results for each column of data.
    The dictionaries contain at least the following:

    - coords: A list of scalars containing the coordinates this particular
      kernel density estimate was evaluated at.
    - vals: A list of scalars containing the values of the kernel density
      estimate at each of the coordinates given in *coords*.
    - mean: The mean value for this column of data.
    - median: The median value for this column of data.
    - min: The minimum value for this column of data.
    - max: The maximum value for this column of data.
    - quantiles: The quantile values for this column of data.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1447</span><span class="keyword">def </span>violin_stats(X, method, points=100, quantiles=None):</div>
<div class="line"><span class="lineno"> 1448</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">    Return a list of dictionaries of data which can be used to draw a series</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">    of violin plots.</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">    See the ``Returns`` section below to view the required keys of the</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    dictionary.</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">    Users can skip this function and pass a user-defined set of dictionaries</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">    with the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">    to do the calculations. See the *Returns* section below for the keys</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">    that must be present in the dictionaries.</span></div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">    X : array-like</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">        Sample data that will be used to produce the gaussian kernel density</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">        estimates. Must have 2 or fewer dimensions.</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    method : callable</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral">        The method used to calculate the kernel density estimate for each</span></div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">        column of data. When called via ``method(v, coords)``, it should</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">        return a vector of the values of the KDE evaluated at the values</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">        specified in coords.</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    points : int, default: 100</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">        Defines the number of points to evaluate each of the gaussian kernel</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">        density estimates at.</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">    quantiles : array-like, default: None</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">        Defines (if not None) a list of floats in interval [0, 1] for each</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">        column of data, which represents the quantiles that will be rendered</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">        for that column of data. Must have 2 or fewer dimensions. 1D array will</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">        be treated as a singleton list containing them.</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">    list of dict</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">        A list of dictionaries containing the results for each column of data.</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">        The dictionaries contain at least the following:</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">        - coords: A list of scalars containing the coordinates this particular</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">          kernel density estimate was evaluated at.</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">        - vals: A list of scalars containing the values of the kernel density</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">          estimate at each of the coordinates given in *coords*.</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">        - mean: The mean value for this column of data.</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">        - median: The median value for this column of data.</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">        - min: The minimum value for this column of data.</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">        - max: The maximum value for this column of data.</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">        - quantiles: The quantile values for this column of data.</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1498</span> </div>
<div class="line"><span class="lineno"> 1499</span>    <span class="comment"># List of dictionaries describing each of the violins.</span></div>
<div class="line"><span class="lineno"> 1500</span>    vpstats = []</div>
<div class="line"><span class="lineno"> 1501</span> </div>
<div class="line"><span class="lineno"> 1502</span>    <span class="comment"># Want X to be a list of data sequences</span></div>
<div class="line"><span class="lineno"> 1503</span>    X = _reshape_2D(X, <span class="stringliteral">&quot;X&quot;</span>)</div>
<div class="line"><span class="lineno"> 1504</span> </div>
<div class="line"><span class="lineno"> 1505</span>    <span class="comment"># Want quantiles to be as the same shape as data sequences</span></div>
<div class="line"><span class="lineno"> 1506</span>    <span class="keywordflow">if</span> quantiles <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> len(quantiles) != 0:</div>
<div class="line"><span class="lineno"> 1507</span>        quantiles = _reshape_2D(quantiles, <span class="stringliteral">&quot;quantiles&quot;</span>)</div>
<div class="line"><span class="lineno"> 1508</span>    <span class="comment"># Else, mock quantiles if it&#39;s none or empty</span></div>
<div class="line"><span class="lineno"> 1509</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1510</span>        quantiles = [[]] * len(X)</div>
<div class="line"><span class="lineno"> 1511</span> </div>
<div class="line"><span class="lineno"> 1512</span>    <span class="comment"># quantiles should has the same size as dataset</span></div>
<div class="line"><span class="lineno"> 1513</span>    <span class="keywordflow">if</span> len(X) != len(quantiles):</div>
<div class="line"><span class="lineno"> 1514</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;List of violinplot statistics and quantiles values&quot;</span></div>
<div class="line"><span class="lineno"> 1515</span>                         <span class="stringliteral">&quot; must have the same length&quot;</span>)</div>
<div class="line"><span class="lineno"> 1516</span> </div>
<div class="line"><span class="lineno"> 1517</span>    <span class="comment"># Zip x and quantiles</span></div>
<div class="line"><span class="lineno"> 1518</span>    <span class="keywordflow">for</span> (x, q) <span class="keywordflow">in</span> zip(X, quantiles):</div>
<div class="line"><span class="lineno"> 1519</span>        <span class="comment"># Dictionary of results for this distribution</span></div>
<div class="line"><span class="lineno"> 1520</span>        stats = {}</div>
<div class="line"><span class="lineno"> 1521</span> </div>
<div class="line"><span class="lineno"> 1522</span>        <span class="comment"># Calculate basic stats for the distribution</span></div>
<div class="line"><span class="lineno"> 1523</span>        min_val = np.min(x)</div>
<div class="line"><span class="lineno"> 1524</span>        max_val = np.max(x)</div>
<div class="line"><span class="lineno"> 1525</span>        quantile_val = np.percentile(x, 100 * q)</div>
<div class="line"><span class="lineno"> 1526</span> </div>
<div class="line"><span class="lineno"> 1527</span>        <span class="comment"># Evaluate the kernel density estimate</span></div>
<div class="line"><span class="lineno"> 1528</span>        coords = np.linspace(min_val, max_val, points)</div>
<div class="line"><span class="lineno"> 1529</span>        stats[<span class="stringliteral">&#39;vals&#39;</span>] = method(x, coords)</div>
<div class="line"><span class="lineno"> 1530</span>        stats[<span class="stringliteral">&#39;coords&#39;</span>] = coords</div>
<div class="line"><span class="lineno"> 1531</span> </div>
<div class="line"><span class="lineno"> 1532</span>        <span class="comment"># Store additional statistics for this distribution</span></div>
<div class="line"><span class="lineno"> 1533</span>        stats[<span class="stringliteral">&#39;mean&#39;</span>] = np.mean(x)</div>
<div class="line"><span class="lineno"> 1534</span>        stats[<span class="stringliteral">&#39;median&#39;</span>] = np.median(x)</div>
<div class="line"><span class="lineno"> 1535</span>        stats[<span class="stringliteral">&#39;min&#39;</span>] = min_val</div>
<div class="line"><span class="lineno"> 1536</span>        stats[<span class="stringliteral">&#39;max&#39;</span>] = max_val</div>
<div class="line"><span class="lineno"> 1537</span>        stats[<span class="stringliteral">&#39;quantiles&#39;</span>] = np.atleast_1d(quantile_val)</div>
<div class="line"><span class="lineno"> 1538</span> </div>
<div class="line"><span class="lineno"> 1539</span>        <span class="comment"># Append to output</span></div>
<div class="line"><span class="lineno"> 1540</span>        vpstats.append(stats)</div>
<div class="line"><span class="lineno"> 1541</span> </div>
<div class="line"><span class="lineno"> 1542</span>    <span class="keywordflow">return</span> vpstats</div>
<div class="line"><span class="lineno"> 1543</span> </div>
<div class="line"><span class="lineno"> 1544</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9f8bddda84669c9ebb7be9a3c701f29d" name="a9f8bddda84669c9ebb7be9a3c701f29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8bddda84669c9ebb7be9a3c701f29d">&#9670;&#160;</a></span>ls_mapper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict matplotlib.cbook.ls_mapper = {'-': 'solid', '--': 'dashed', '-.': 'dashdot', ':': 'dotted'}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86e70193717f5fa3143a98525a891d01" name="a86e70193717f5fa3143a98525a891d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e70193717f5fa3143a98525a891d01">&#9670;&#160;</a></span>ls_mapper_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict matplotlib.cbook.ls_mapper_r = {v: <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a> for <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, v <a class="el" href="__lapack__subroutines_8h.html#aa83d4778c28341ab79b01b2371f666fe">in</a> ls_mapper.items()}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af24f8a763f388b46b3bac623389c4856" name="af24f8a763f388b46b3bac623389c4856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24f8a763f388b46b3bac623389c4856">&#9670;&#160;</a></span>STEP_LOOKUP_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict matplotlib.cbook.STEP_LOOKUP_MAP</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {<span class="stringliteral">&#39;default&#39;</span>: <span class="keyword">lambda</span> x, y: (x, y),</div>
<div class="line"><span class="lineno">    2</span>                   <span class="stringliteral">&#39;steps&#39;</span>: pts_to_prestep,</div>
<div class="line"><span class="lineno">    3</span>                   <span class="stringliteral">&#39;steps-pre&#39;</span>: pts_to_prestep,</div>
<div class="line"><span class="lineno">    4</span>                   <span class="stringliteral">&#39;steps-post&#39;</span>: pts_to_poststep,</div>
<div class="line"><span class="lineno">    5</span>                   <span class="stringliteral">&#39;steps-mid&#39;</span>: pts_to_midstep}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
