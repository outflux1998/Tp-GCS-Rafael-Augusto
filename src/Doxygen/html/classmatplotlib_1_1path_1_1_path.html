<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.path.Path Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1path.html">path</a></li><li class="navelem"><a class="el" href="classmatplotlib_1_1path_1_1_path.html">Path</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classmatplotlib_1_1path_1_1_path-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.path.Path Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for matplotlib.path.Path:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmatplotlib_1_1path_1_1_path.png" usemap="#matplotlib.path.Path_map" alt=""/>
  <map id="matplotlib.path.Path_map" name="matplotlib.path.Path_map">
<area href="classmatplotlib_1_1textpath_1_1_text_path.html" alt="matplotlib.textpath.TextPath" shape="rect" coords="0,56,163,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc022e3e64b23cd854757089ed158e2e" id="r_adc022e3e64b23cd854757089ed158e2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#adc022e3e64b23cd854757089ed158e2e">__init__</a> (self, <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a0776b7f5ca038f593efc44ba38dc3a6b">vertices</a>, <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a6c5c1b3d9cfa6ff7c06e23601c567e0b">codes</a>=None, <a class="el" href="classmatplotlib_1_1path_1_1_path.html#af0a1307b4d90f72d9b15cbbad4fb244a">_interpolation_steps</a>=1, closed=False, <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a409d2496b816f3158133d8c6559e36c4">readonly</a>=False)</td></tr>
<tr class="separator:adc022e3e64b23cd854757089ed158e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f544d1e907f82186403662c09d86ac8" id="r_a5f544d1e907f82186403662c09d86ac8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a5f544d1e907f82186403662c09d86ac8">vertices</a> (self)</td></tr>
<tr class="separator:a5f544d1e907f82186403662c09d86ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ed90a393875fbe566028138f8ed92b" id="r_a68ed90a393875fbe566028138f8ed92b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a68ed90a393875fbe566028138f8ed92b">vertices</a> (self, vertices)</td></tr>
<tr class="separator:a68ed90a393875fbe566028138f8ed92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe998ea0d6b05793e9d6057a5543df62" id="r_afe998ea0d6b05793e9d6057a5543df62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#afe998ea0d6b05793e9d6057a5543df62">codes</a> (self)</td></tr>
<tr class="separator:afe998ea0d6b05793e9d6057a5543df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c144d5781ba8f4b5fbc483ff3237b3f" id="r_a8c144d5781ba8f4b5fbc483ff3237b3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a8c144d5781ba8f4b5fbc483ff3237b3f">codes</a> (self, codes)</td></tr>
<tr class="separator:a8c144d5781ba8f4b5fbc483ff3237b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a602dcda982582ea2034b020f0676ba" id="r_a9a602dcda982582ea2034b020f0676ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a9a602dcda982582ea2034b020f0676ba">simplify_threshold</a> (self)</td></tr>
<tr class="separator:a9a602dcda982582ea2034b020f0676ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfd9f6052ceddf72fba5a07c4655e50" id="r_a8cfd9f6052ceddf72fba5a07c4655e50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a8cfd9f6052ceddf72fba5a07c4655e50">simplify_threshold</a> (self, threshold)</td></tr>
<tr class="separator:a8cfd9f6052ceddf72fba5a07c4655e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afc6db27356bbdccb88457c07d6a44" id="r_a48afc6db27356bbdccb88457c07d6a44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a48afc6db27356bbdccb88457c07d6a44">should_simplify</a> (self)</td></tr>
<tr class="separator:a48afc6db27356bbdccb88457c07d6a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52d6afe59811e6cd28a7dbbc980a83c" id="r_af52d6afe59811e6cd28a7dbbc980a83c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#af52d6afe59811e6cd28a7dbbc980a83c">should_simplify</a> (self, should_simplify)</td></tr>
<tr class="separator:af52d6afe59811e6cd28a7dbbc980a83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409d2496b816f3158133d8c6559e36c4" id="r_a409d2496b816f3158133d8c6559e36c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a409d2496b816f3158133d8c6559e36c4">readonly</a> (self)</td></tr>
<tr class="separator:a409d2496b816f3158133d8c6559e36c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff434f82845d852852aadd2ea77f635a" id="r_aff434f82845d852852aadd2ea77f635a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#aff434f82845d852852aadd2ea77f635a">copy</a> (self)</td></tr>
<tr class="separator:aff434f82845d852852aadd2ea77f635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616e6dcaa6b90c505e656353947ba78" id="r_af616e6dcaa6b90c505e656353947ba78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#af616e6dcaa6b90c505e656353947ba78">__deepcopy__</a> (self, memo=None)</td></tr>
<tr class="separator:af616e6dcaa6b90c505e656353947ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc0a2ba8166260f37d76601a231784e" id="r_a7bc0a2ba8166260f37d76601a231784e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a7bc0a2ba8166260f37d76601a231784e">make_compound_path_from_polys</a> (cls, XY)</td></tr>
<tr class="separator:a7bc0a2ba8166260f37d76601a231784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda6e2ad3c910ed2095f43c634f8e8b2" id="r_aeda6e2ad3c910ed2095f43c634f8e8b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#aeda6e2ad3c910ed2095f43c634f8e8b2">make_compound_path</a> (cls, *args)</td></tr>
<tr class="separator:aeda6e2ad3c910ed2095f43c634f8e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af245e26b8f08593fc67d4403862fdb24" id="r_af245e26b8f08593fc67d4403862fdb24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#af245e26b8f08593fc67d4403862fdb24">__repr__</a> (self)</td></tr>
<tr class="separator:af245e26b8f08593fc67d4403862fdb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae47d8c3d58c18c4f19faa1cdceda728" id="r_aae47d8c3d58c18c4f19faa1cdceda728"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#aae47d8c3d58c18c4f19faa1cdceda728">__len__</a> (self)</td></tr>
<tr class="separator:aae47d8c3d58c18c4f19faa1cdceda728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c98bb35e3b7720189afaeadade8ed4" id="r_ac5c98bb35e3b7720189afaeadade8ed4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ac5c98bb35e3b7720189afaeadade8ed4">iter_segments</a> (self, transform=None, remove_nans=True, clip=None, snap=False, stroke_width=1.0, simplify=None, curves=True, sketch=None)</td></tr>
<tr class="separator:ac5c98bb35e3b7720189afaeadade8ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bc6f4f234ab0bd120f6a21ba99bfb9" id="r_a01bc6f4f234ab0bd120f6a21ba99bfb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a01bc6f4f234ab0bd120f6a21ba99bfb9">iter_bezier</a> (self, **kwargs)</td></tr>
<tr class="separator:a01bc6f4f234ab0bd120f6a21ba99bfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211aa46e2ddfe9ccce990f375b632a98" id="r_a211aa46e2ddfe9ccce990f375b632a98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a211aa46e2ddfe9ccce990f375b632a98">cleaned</a> (self, transform=None, remove_nans=False, clip=None, *simplify=False, curves=False, stroke_width=1.0, snap=False, sketch=None)</td></tr>
<tr class="separator:a211aa46e2ddfe9ccce990f375b632a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201e83d31984e299842be8cd6f2b88c" id="r_ac201e83d31984e299842be8cd6f2b88c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ac201e83d31984e299842be8cd6f2b88c">transformed</a> (self, transform)</td></tr>
<tr class="separator:ac201e83d31984e299842be8cd6f2b88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50feb4a3645c2a5b1f5aaacd596dfef" id="r_ae50feb4a3645c2a5b1f5aaacd596dfef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ae50feb4a3645c2a5b1f5aaacd596dfef">contains_point</a> (self, point, transform=None, radius=0.0)</td></tr>
<tr class="separator:ae50feb4a3645c2a5b1f5aaacd596dfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59aa207de062647998c651c80e256ee5" id="r_a59aa207de062647998c651c80e256ee5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a59aa207de062647998c651c80e256ee5">contains_points</a> (self, points, transform=None, radius=0.0)</td></tr>
<tr class="separator:a59aa207de062647998c651c80e256ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa7bb3f42ac23f35b36c79b592c38e0" id="r_a3aa7bb3f42ac23f35b36c79b592c38e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a3aa7bb3f42ac23f35b36c79b592c38e0">contains_path</a> (self, path, transform=None)</td></tr>
<tr class="separator:a3aa7bb3f42ac23f35b36c79b592c38e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ff5d5d2eddc95a6337266db0ba528a" id="r_a46ff5d5d2eddc95a6337266db0ba528a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a46ff5d5d2eddc95a6337266db0ba528a">get_extents</a> (self, transform=None, **kwargs)</td></tr>
<tr class="separator:a46ff5d5d2eddc95a6337266db0ba528a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb737afdfeac3adf8f5c4e827a629d3" id="r_a2bb737afdfeac3adf8f5c4e827a629d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a2bb737afdfeac3adf8f5c4e827a629d3">intersects_path</a> (self, other, filled=True)</td></tr>
<tr class="separator:a2bb737afdfeac3adf8f5c4e827a629d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae630ece0ec1f528347fc7134b154b9e9" id="r_ae630ece0ec1f528347fc7134b154b9e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ae630ece0ec1f528347fc7134b154b9e9">intersects_bbox</a> (self, bbox, filled=True)</td></tr>
<tr class="separator:ae630ece0ec1f528347fc7134b154b9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a3da4d45f60b0154da43fcad25bd61" id="r_a65a3da4d45f60b0154da43fcad25bd61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a65a3da4d45f60b0154da43fcad25bd61">interpolated</a> (self, steps)</td></tr>
<tr class="separator:a65a3da4d45f60b0154da43fcad25bd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8876b44d733b4702429bff2221eb47" id="r_a1b8876b44d733b4702429bff2221eb47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a1b8876b44d733b4702429bff2221eb47">to_polygons</a> (self, transform=None, width=0, height=0, closed_only=True)</td></tr>
<tr class="separator:a1b8876b44d733b4702429bff2221eb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ba77dda5f0d8003857eb1fd5034962" id="r_a49ba77dda5f0d8003857eb1fd5034962"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a49ba77dda5f0d8003857eb1fd5034962">unit_rectangle</a> (cls)</td></tr>
<tr class="separator:a49ba77dda5f0d8003857eb1fd5034962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3220713fb5fe470442da9396f344ef" id="r_a2b3220713fb5fe470442da9396f344ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a2b3220713fb5fe470442da9396f344ef">unit_regular_polygon</a> (cls, numVertices)</td></tr>
<tr class="separator:a2b3220713fb5fe470442da9396f344ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48d569869352bc9480f52082c3e9640" id="r_ae48d569869352bc9480f52082c3e9640"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ae48d569869352bc9480f52082c3e9640">unit_regular_star</a> (cls, numVertices, innerCircle=0.5)</td></tr>
<tr class="separator:ae48d569869352bc9480f52082c3e9640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc01de19ca1b6dacb74e5b1252a9d61e" id="r_acc01de19ca1b6dacb74e5b1252a9d61e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#acc01de19ca1b6dacb74e5b1252a9d61e">unit_regular_asterisk</a> (cls, numVertices)</td></tr>
<tr class="separator:acc01de19ca1b6dacb74e5b1252a9d61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9c8e4739390b9a371b1c9b19c09e9" id="r_aa1f9c8e4739390b9a371b1c9b19c09e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#aa1f9c8e4739390b9a371b1c9b19c09e9">unit_circle</a> (cls)</td></tr>
<tr class="separator:aa1f9c8e4739390b9a371b1c9b19c09e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82a88020b719e952f30f04ff23434f2" id="r_ad82a88020b719e952f30f04ff23434f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ad82a88020b719e952f30f04ff23434f2">circle</a> (cls, center=(0., 0.), radius=1., <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a409d2496b816f3158133d8c6559e36c4">readonly</a>=False)</td></tr>
<tr class="separator:ad82a88020b719e952f30f04ff23434f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba433ba020bb6577031ae875e00e35fa" id="r_aba433ba020bb6577031ae875e00e35fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#aba433ba020bb6577031ae875e00e35fa">unit_circle_righthalf</a> (cls)</td></tr>
<tr class="separator:aba433ba020bb6577031ae875e00e35fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8211deedc0f642eb6d58bb23648da944" id="r_a8211deedc0f642eb6d58bb23648da944"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a8211deedc0f642eb6d58bb23648da944">arc</a> (cls, theta1, theta2, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, is_wedge=False)</td></tr>
<tr class="separator:a8211deedc0f642eb6d58bb23648da944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4686fca1edba39d194b3076476202b6" id="r_ad4686fca1edba39d194b3076476202b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ad4686fca1edba39d194b3076476202b6">wedge</a> (cls, theta1, theta2, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None)</td></tr>
<tr class="separator:ad4686fca1edba39d194b3076476202b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3557379f22a58b0a9a3038049d5c4c2" id="r_ae3557379f22a58b0a9a3038049d5c4c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ae3557379f22a58b0a9a3038049d5c4c2">clip_to_bbox</a> (self, bbox, inside=True)</td></tr>
<tr class="separator:ae3557379f22a58b0a9a3038049d5c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a60e0b253e84c683a2498cf45cb306cdf" id="r_a60e0b253e84c683a2498cf45cb306cdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a60e0b253e84c683a2498cf45cb306cdf">hatch</a> (hatchpattern, density=6)</td></tr>
<tr class="separator:a60e0b253e84c683a2498cf45cb306cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0776b7f5ca038f593efc44ba38dc3a6b" id="r_a0776b7f5ca038f593efc44ba38dc3a6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a0776b7f5ca038f593efc44ba38dc3a6b">vertices</a></td></tr>
<tr class="separator:a0776b7f5ca038f593efc44ba38dc3a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5c1b3d9cfa6ff7c06e23601c567e0b" id="r_a6c5c1b3d9cfa6ff7c06e23601c567e0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a6c5c1b3d9cfa6ff7c06e23601c567e0b">codes</a></td></tr>
<tr class="separator:a6c5c1b3d9cfa6ff7c06e23601c567e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a89ee1cccd6a24fe1f278d18d77d84438" id="r_a89ee1cccd6a24fe1f278d18d77d84438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a> = np.uint8</td></tr>
<tr class="separator:a89ee1cccd6a24fe1f278d18d77d84438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0f0350d40f9d676f842f7a191cea97" id="r_a9c0f0350d40f9d676f842f7a191cea97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a9c0f0350d40f9d676f842f7a191cea97">STOP</a> = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(0)</td></tr>
<tr class="separator:a9c0f0350d40f9d676f842f7a191cea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e9c539ff8aa6ea04fbe89d48e20221" id="r_ab9e9c539ff8aa6ea04fbe89d48e20221"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ab9e9c539ff8aa6ea04fbe89d48e20221">MOVETO</a> = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(1)</td></tr>
<tr class="separator:ab9e9c539ff8aa6ea04fbe89d48e20221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32d8730490de4520b4ef5d4b4a85a96" id="r_af32d8730490de4520b4ef5d4b4a85a96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#af32d8730490de4520b4ef5d4b4a85a96">LINETO</a> = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(2)</td></tr>
<tr class="separator:af32d8730490de4520b4ef5d4b4a85a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd69ee9fc2a1051a8d67d12910bab4e" id="r_a8fd69ee9fc2a1051a8d67d12910bab4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a8fd69ee9fc2a1051a8d67d12910bab4e">CURVE3</a> = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(3)</td></tr>
<tr class="separator:a8fd69ee9fc2a1051a8d67d12910bab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec98baae7ae38e7a0ae680fc945f051e" id="r_aec98baae7ae38e7a0ae680fc945f051e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#aec98baae7ae38e7a0ae680fc945f051e">CURVE4</a> = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(4)</td></tr>
<tr class="separator:aec98baae7ae38e7a0ae680fc945f051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02575b90932a2331c8e95fce7b11848c" id="r_a02575b90932a2331c8e95fce7b11848c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a02575b90932a2331c8e95fce7b11848c">CLOSEPOLY</a> = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(79)</td></tr>
<tr class="separator:a02575b90932a2331c8e95fce7b11848c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf08d00fec083fa01537120bd7a05ed" id="r_aedf08d00fec083fa01537120bd7a05ed"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#aedf08d00fec083fa01537120bd7a05ed">NUM_VERTICES_FOR_CODE</a></td></tr>
<tr class="separator:aedf08d00fec083fa01537120bd7a05ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b78245ec8753fe8b5c84755a5f36f3" id="r_ae9b78245ec8753fe8b5c84755a5f36f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ae9b78245ec8753fe8b5c84755a5f36f3">deepcopy</a> = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#af616e6dcaa6b90c505e656353947ba78">__deepcopy__</a></td></tr>
<tr class="separator:ae9b78245ec8753fe8b5c84755a5f36f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a81bf2ba66cfbea4c3a1168ab19ddf335" id="r_a81bf2ba66cfbea4c3a1168ab19ddf335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a81bf2ba66cfbea4c3a1168ab19ddf335">_fast_from_codes_and_verts</a> (cls, verts, <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a6c5c1b3d9cfa6ff7c06e23601c567e0b">codes</a>, internals_from=None)</td></tr>
<tr class="separator:a81bf2ba66cfbea4c3a1168ab19ddf335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c731efc5f6b7f96aa431a8c3c7762fc" id="r_a7c731efc5f6b7f96aa431a8c3c7762fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a7c731efc5f6b7f96aa431a8c3c7762fc">_create_closed</a> (cls, <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a0776b7f5ca038f593efc44ba38dc3a6b">vertices</a>)</td></tr>
<tr class="separator:a7c731efc5f6b7f96aa431a8c3c7762fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475ecfce457c0ae4e6181ef3fa71232e" id="r_a475ecfce457c0ae4e6181ef3fa71232e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a475ecfce457c0ae4e6181ef3fa71232e">_update_values</a> (self)</td></tr>
<tr class="separator:a475ecfce457c0ae4e6181ef3fa71232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0af8e997d1bab5890f89e544134d0e1b" id="r_a0af8e997d1bab5890f89e544134d0e1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a0af8e997d1bab5890f89e544134d0e1b">_vertices</a></td></tr>
<tr class="separator:a0af8e997d1bab5890f89e544134d0e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad410ced0ba2b2f8cf92f65119eafc480" id="r_ad410ced0ba2b2f8cf92f65119eafc480"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#ad410ced0ba2b2f8cf92f65119eafc480">_codes</a></td></tr>
<tr class="separator:ad410ced0ba2b2f8cf92f65119eafc480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a1307b4d90f72d9b15cbbad4fb244a" id="r_af0a1307b4d90f72d9b15cbbad4fb244a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#af0a1307b4d90f72d9b15cbbad4fb244a">_interpolation_steps</a></td></tr>
<tr class="separator:af0a1307b4d90f72d9b15cbbad4fb244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce26848d76d242baf8fa1bc50a9b980" id="r_afce26848d76d242baf8fa1bc50a9b980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#afce26848d76d242baf8fa1bc50a9b980">_readonly</a></td></tr>
<tr class="separator:afce26848d76d242baf8fa1bc50a9b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007bfa3b782135defeb37f18ebe0a5f5" id="r_a007bfa3b782135defeb37f18ebe0a5f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a007bfa3b782135defeb37f18ebe0a5f5">_simplify_threshold</a></td></tr>
<tr class="separator:a007bfa3b782135defeb37f18ebe0a5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3af14421cfd81382d36b82bd04afcd" id="r_a7d3af14421cfd81382d36b82bd04afcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a7d3af14421cfd81382d36b82bd04afcd">_should_simplify</a></td></tr>
<tr class="separator:a7d3af14421cfd81382d36b82bd04afcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a603ec377abe5dcfbdbc94aa64309f580" id="r_a603ec377abe5dcfbdbc94aa64309f580"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a603ec377abe5dcfbdbc94aa64309f580">_unit_rectangle</a> = None</td></tr>
<tr class="separator:a603ec377abe5dcfbdbc94aa64309f580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28037223f6bc997693c8219c79afbd47" id="r_a28037223f6bc997693c8219c79afbd47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a28037223f6bc997693c8219c79afbd47">_unit_regular_polygons</a> = WeakValueDictionary()</td></tr>
<tr class="separator:a28037223f6bc997693c8219c79afbd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05190eb4e831305e2ce3e319ac6aedb6" id="r_a05190eb4e831305e2ce3e319ac6aedb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a05190eb4e831305e2ce3e319ac6aedb6">_unit_regular_stars</a> = WeakValueDictionary()</td></tr>
<tr class="separator:a05190eb4e831305e2ce3e319ac6aedb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2267e8cfe9a5bbd9c7080eadf1560d26" id="r_a2267e8cfe9a5bbd9c7080eadf1560d26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#a2267e8cfe9a5bbd9c7080eadf1560d26">_unit_circle</a> = None</td></tr>
<tr class="separator:a2267e8cfe9a5bbd9c7080eadf1560d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf607cc12149155feb616192d9fd249c" id="r_acf607cc12149155feb616192d9fd249c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1path_1_1_path.html#acf607cc12149155feb616192d9fd249c">_unit_circle_righthalf</a> = None</td></tr>
<tr class="separator:acf607cc12149155feb616192d9fd249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">A series of possibly disconnected, possibly closed, line and curve
segments.

The underlying storage is made up of two parallel numpy arrays:

- *vertices*: an Nx2 float array of vertices
- *codes*: an N-length uint8 array of path codes, or None

These two arrays always have the same length in the first
dimension.  For example, to represent a cubic curve, you must
provide three vertices and three ``CURVE4`` codes.

The code types are:

- ``STOP``   :  1 vertex (ignored)
    A marker for the end of the entire path (currently not required and
    ignored)

- ``MOVETO`` :  1 vertex
    Pick up the pen and move to the given vertex.

- ``LINETO`` :  1 vertex
    Draw a line from the current position to the given vertex.

- ``CURVE3`` :  1 control point, 1 endpoint
    Draw a quadratic Bezier curve from the current position, with the given
    control point, to the given end point.

- ``CURVE4`` :  2 control points, 1 endpoint
    Draw a cubic Bezier curve from the current position, with the given
    control points, to the given end point.

- ``CLOSEPOLY`` : 1 vertex (ignored)
    Draw a line segment to the start point of the current polyline.

If *codes* is None, it is interpreted as a ``MOVETO`` followed by a series
of ``LINETO``.

Users of Path objects should not access the vertices and codes arrays
directly.  Instead, they should use `iter_segments` or `cleaned` to get the
vertex/code pairs.  This helps, in particular, to consistently handle the
case of *codes* being None.

Some behavior of Path objects can be controlled by rcParams. See the
rcParams whose keys start with 'path.'.

.. note::

    The vertices and codes arrays should be treated as
    immutable -- there are a number of optimizations and assumptions
    made up front in the constructor that will not change when the
    data changes.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc022e3e64b23cd854757089ed158e2e" name="adc022e3e64b23cd854757089ed158e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc022e3e64b23cd854757089ed158e2e">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>codes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_interpolation_steps</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>closed</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>readonly</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new path with the given vertices and codes.

Parameters
----------
vertices : (N, 2) array-like
    The path vertices, as an array, masked array or sequence of pairs.
    Masked values, if any, will be converted to NaNs, which are then
    handled correctly by the Agg PathIterator and other consumers of
    path data, such as :meth:`iter_segments`.
codes : array-like or None, optional
    N-length array of integers representing the codes of the path.
    If not None, codes must be the same length as vertices.
    If None, *vertices* will be treated as a series of line segments.
_interpolation_steps : int, optional
    Used as a hint to certain projections, such as Polar, that this
    path should be linearly interpolated immediately before drawing.
    This attribute is primarily an implementation detail and is not
    intended for public use.
closed : bool, optional
    If *codes* is None and closed is True, vertices will be treated as
    line segments of a closed polygon.  Note that the last vertex will
    then be ignored (as the corresponding code will be set to
    CLOSEPOLY).
readonly : bool, optional
    Makes the path behave in an immutable way and sets the vertices
    and codes as read-only arrays.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1textpath_1_1_text_path.html#af07e078361c55994b7231a7bd6fe43dd">matplotlib.textpath.TextPath</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  100</span>                 closed=<span class="keyword">False</span>, readonly=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  101</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        Create a new path with the given vertices and codes.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        vertices : (N, 2) array-like</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">            The path vertices, as an array, masked array or sequence of pairs.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">            Masked values, if any, will be converted to NaNs, which are then</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">            handled correctly by the Agg PathIterator and other consumers of</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">            path data, such as :meth:`iter_segments`.</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        codes : array-like or None, optional</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">            N-length array of integers representing the codes of the path.</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">            If not None, codes must be the same length as vertices.</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">            If None, *vertices* will be treated as a series of line segments.</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        _interpolation_steps : int, optional</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">            Used as a hint to certain projections, such as Polar, that this</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">            path should be linearly interpolated immediately before drawing.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">            This attribute is primarily an implementation detail and is not</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">            intended for public use.</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        closed : bool, optional</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">            If *codes* is None and closed is True, vertices will be treated as</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">            line segments of a closed polygon.  Note that the last vertex will</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">            then be ignored (as the corresponding code will be set to</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">            CLOSEPOLY).</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        readonly : bool, optional</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">            Makes the path behave in an immutable way and sets the vertices</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">            and codes as read-only arrays.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  129</span>        vertices = _to_unmasked_float_array(vertices)</div>
<div class="line"><span class="lineno">  130</span>        _api.check_shape((<span class="keywordtype">None</span>, 2), vertices=vertices)</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">if</span> codes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  133</span>            codes = np.asarray(codes, self.code_type)</div>
<div class="line"><span class="lineno">  134</span>            <span class="keywordflow">if</span> codes.ndim != 1 <span class="keywordflow">or</span> len(codes) != len(vertices):</div>
<div class="line"><span class="lineno">  135</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;codes&#39; must be a 1D list or array with the &quot;</span></div>
<div class="line"><span class="lineno">  136</span>                                 <span class="stringliteral">&quot;same length of &#39;vertices&#39;. &quot;</span></div>
<div class="line"><span class="lineno">  137</span>                                 f<span class="stringliteral">&quot;Your vertices have shape {vertices.shape} &quot;</span></div>
<div class="line"><span class="lineno">  138</span>                                 f<span class="stringliteral">&quot;but your codes have shape {codes.shape}&quot;</span>)</div>
<div class="line"><span class="lineno">  139</span>            <span class="keywordflow">if</span> len(codes) <span class="keywordflow">and</span> codes[0] != self.MOVETO:</div>
<div class="line"><span class="lineno">  140</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The first element of &#39;code&#39; must be equal &quot;</span></div>
<div class="line"><span class="lineno">  141</span>                                 f<span class="stringliteral">&quot;to &#39;MOVETO&#39; ({self.MOVETO}).  &quot;</span></div>
<div class="line"><span class="lineno">  142</span>                                 f<span class="stringliteral">&quot;Your first code is {codes[0]}&quot;</span>)</div>
<div class="line"><span class="lineno">  143</span>        <span class="keywordflow">elif</span> closed <span class="keywordflow">and</span> len(vertices):</div>
<div class="line"><span class="lineno">  144</span>            codes = np.empty(len(vertices), dtype=self.code_type)</div>
<div class="line"><span class="lineno">  145</span>            codes[0] = self.MOVETO</div>
<div class="line"><span class="lineno">  146</span>            codes[1:-1] = self.LINETO</div>
<div class="line"><span class="lineno">  147</span>            codes[-1] = self.CLOSEPOLY</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>        self._vertices = vertices</div>
<div class="line"><span class="lineno">  150</span>        self._codes = codes</div>
<div class="line"><span class="lineno">  151</span>        self._interpolation_steps = _interpolation_steps</div>
<div class="line"><span class="lineno">  152</span>        self._update_values()</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordflow">if</span> readonly:</div>
<div class="line"><span class="lineno">  155</span>            self._vertices.flags.writeable = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  156</span>            <span class="keywordflow">if</span> self._codes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  157</span>                self._codes.flags.writeable = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  158</span>            self._readonly = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  160</span>            self._readonly = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  161</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af616e6dcaa6b90c505e656353947ba78" name="af616e6dcaa6b90c505e656353947ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af616e6dcaa6b90c505e656353947ba78">&#9670;&#160;</a></span>__deepcopy__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.__deepcopy__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>memo</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a deepcopy of the `Path`.  The `Path` will not be
readonly, even if the source `Path` is.
</pre> <div class="fragment"><div class="line"><span class="lineno">  281</span>    <span class="keyword">def </span>__deepcopy__(self, memo=None):</div>
<div class="line"><span class="lineno">  282</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        Return a deepcopy of the `Path`.  The `Path` will not be</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        readonly, even if the source `Path` is.</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  286</span>        <span class="comment"># Deepcopying arrays (vertices, codes) strips the writeable=False flag.</span></div>
<div class="line"><span class="lineno">  287</span>        p = copy.deepcopy(super(), memo)</div>
<div class="line"><span class="lineno">  288</span>        p._readonly = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  289</span>        <span class="keywordflow">return</span> p</div>
<div class="line"><span class="lineno">  290</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae47d8c3d58c18c4f19faa1cdceda728" name="aae47d8c3d58c18c4f19faa1cdceda728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae47d8c3d58c18c4f19faa1cdceda728">&#9670;&#160;</a></span>__len__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.__len__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  351</span>    <span class="keyword">def </span>__len__(self):</div>
<div class="line"><span class="lineno">  352</span>        <span class="keywordflow">return</span> len(self.vertices)</div>
<div class="line"><span class="lineno">  353</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af245e26b8f08593fc67d4403862fdb24" name="af245e26b8f08593fc67d4403862fdb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af245e26b8f08593fc67d4403862fdb24">&#9670;&#160;</a></span>__repr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  348</span>    <span class="keyword">def </span>__repr__(self):</div>
<div class="line"><span class="lineno">  349</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Path(%r, %r)&quot;</span> % (self.vertices, self.codes)</div>
<div class="line"><span class="lineno">  350</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c731efc5f6b7f96aa431a8c3c7762fc" name="a7c731efc5f6b7f96aa431a8c3c7762fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c731efc5f6b7f96aa431a8c3c7762fc">&#9670;&#160;</a></span>_create_closed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._create_closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create a closed polygonal path going through *vertices*.

Unlike ``Path(..., closed=True)``, *vertices* should **not** end with
an entry for the CLOSEPATH; this entry is added by `._create_closed`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  192</span>    <span class="keyword">def </span>_create_closed(cls, vertices):</div>
<div class="line"><span class="lineno">  193</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">        Create a closed polygonal path going through *vertices*.</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">        Unlike ``Path(..., closed=True)``, *vertices* should **not** end with</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        an entry for the CLOSEPATH; this entry is added by `._create_closed`.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  199</span>        v = _to_unmasked_float_array(vertices)</div>
<div class="line"><span class="lineno">  200</span>        <span class="keywordflow">return</span> cls(np.concatenate([v, v[:1]]), closed=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  201</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a81bf2ba66cfbea4c3a1168ab19ddf335" name="a81bf2ba66cfbea4c3a1168ab19ddf335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bf2ba66cfbea4c3a1168ab19ddf335">&#9670;&#160;</a></span>_fast_from_codes_and_verts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._fast_from_codes_and_verts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>codes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>internals_from</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create a Path instance without the expense of calling the constructor.

Parameters
----------
verts : numpy array
codes : numpy array
internals_from : Path or None
    If not None, another `Path` from which the attributes
    ``should_simplify``, ``simplify_threshold``, and
    ``interpolation_steps`` will be copied.  Note that ``readonly`` is
    never copied, and always set to ``False`` by this constructor.
</pre> <div class="fragment"><div class="line"><span class="lineno">  163</span>    <span class="keyword">def </span>_fast_from_codes_and_verts(cls, verts, codes, internals_from=None):</div>
<div class="line"><span class="lineno">  164</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        Create a Path instance without the expense of calling the constructor.</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        verts : numpy array</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        codes : numpy array</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        internals_from : Path or None</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">            If not None, another `Path` from which the attributes</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">            ``should_simplify``, ``simplify_threshold``, and</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">            ``interpolation_steps`` will be copied.  Note that ``readonly`` is</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">            never copied, and always set to ``False`` by this constructor.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  177</span>        pth = cls.__new__(cls)</div>
<div class="line"><span class="lineno">  178</span>        pth._vertices = _to_unmasked_float_array(verts)</div>
<div class="line"><span class="lineno">  179</span>        pth._codes = codes</div>
<div class="line"><span class="lineno">  180</span>        pth._readonly = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  181</span>        <span class="keywordflow">if</span> internals_from <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  182</span>            pth._should_simplify = internals_from._should_simplify</div>
<div class="line"><span class="lineno">  183</span>            pth._simplify_threshold = internals_from._simplify_threshold</div>
<div class="line"><span class="lineno">  184</span>            pth._interpolation_steps = internals_from._interpolation_steps</div>
<div class="line"><span class="lineno">  185</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  186</span>            pth._should_simplify = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  187</span>            pth._simplify_threshold = mpl.rcParams[<span class="stringliteral">&#39;path.simplify_threshold&#39;</span>]</div>
<div class="line"><span class="lineno">  188</span>            pth._interpolation_steps = 1</div>
<div class="line"><span class="lineno">  189</span>        <span class="keywordflow">return</span> pth</div>
<div class="line"><span class="lineno">  190</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a475ecfce457c0ae4e6181ef3fa71232e" name="a475ecfce457c0ae4e6181ef3fa71232e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475ecfce457c0ae4e6181ef3fa71232e">&#9670;&#160;</a></span>_update_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._update_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  202</span>    <span class="keyword">def </span>_update_values(self):</div>
<div class="line"><span class="lineno">  203</span>        self._simplify_threshold = mpl.rcParams[<span class="stringliteral">&#39;path.simplify_threshold&#39;</span>]</div>
<div class="line"><span class="lineno">  204</span>        self._should_simplify = (</div>
<div class="line"><span class="lineno">  205</span>            self._simplify_threshold &gt; 0 <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  206</span>            mpl.rcParams[<span class="stringliteral">&#39;path.simplify&#39;</span>] <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  207</span>            len(self._vertices) &gt;= 128 <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  208</span>            (self._codes <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> np.all(self._codes &lt;= Path.LINETO))</div>
<div class="line"><span class="lineno">  209</span>        )</div>
<div class="line"><span class="lineno">  210</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8211deedc0f642eb6d58bb23648da944" name="a8211deedc0f642eb6d58bb23648da944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8211deedc0f642eb6d58bb23648da944">&#9670;&#160;</a></span>arc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.arc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>is_wedge</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a `Path` for the unit circle arc from angles *theta1* to
*theta2* (in degrees).

*theta2* is unwrapped to produce the shortest arc within 360 degrees.
That is, if *theta2* &gt; *theta1* + 360, the arc will be from *theta1* to
*theta2* - 360 and not a full circle plus some extra overlap.

If *n* is provided, it is the number of spline segments to make.
If *n* is not provided, the number of spline segments is
determined based on the delta between *theta1* and *theta2*.

   Masionobe, L.  2003.  `Drawing an elliptical arc using
   polylines, quadratic or cubic Bezier curves
   &lt;http://www.spaceroots.org/documents/ellipse/index.html&gt;`_.
</pre> <div class="fragment"><div class="line"><span class="lineno">  926</span>    <span class="keyword">def </span>arc(cls, theta1, theta2, n=None, is_wedge=False):</div>
<div class="line"><span class="lineno">  927</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">        Return a `Path` for the unit circle arc from angles *theta1* to</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">        *theta2* (in degrees).</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">        *theta2* is unwrapped to produce the shortest arc within 360 degrees.</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">        That is, if *theta2* &gt; *theta1* + 360, the arc will be from *theta1* to</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">        *theta2* - 360 and not a full circle plus some extra overlap.</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">        If *n* is provided, it is the number of spline segments to make.</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">        If *n* is not provided, the number of spline segments is</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">        determined based on the delta between *theta1* and *theta2*.</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">           Masionobe, L.  2003.  `Drawing an elliptical arc using</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">           polylines, quadratic or cubic Bezier curves</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">           &lt;http://www.spaceroots.org/documents/ellipse/index.html&gt;`_.</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  943</span>        halfpi = np.pi * 0.5</div>
<div class="line"><span class="lineno">  944</span> </div>
<div class="line"><span class="lineno">  945</span>        eta1 = theta1</div>
<div class="line"><span class="lineno">  946</span>        eta2 = theta2 - 360 * np.floor((theta2 - theta1) / 360)</div>
<div class="line"><span class="lineno">  947</span>        <span class="comment"># Ensure 2pi range is not flattened to 0 due to floating-point errors,</span></div>
<div class="line"><span class="lineno">  948</span>        <span class="comment"># but don&#39;t try to expand existing 0 range.</span></div>
<div class="line"><span class="lineno">  949</span>        <span class="keywordflow">if</span> theta2 != theta1 <span class="keywordflow">and</span> eta2 &lt;= eta1:</div>
<div class="line"><span class="lineno">  950</span>            eta2 += 360</div>
<div class="line"><span class="lineno">  951</span>        eta1, eta2 = np.deg2rad([eta1, eta2])</div>
<div class="line"><span class="lineno">  952</span> </div>
<div class="line"><span class="lineno">  953</span>        <span class="comment"># number of curve segments to make</span></div>
<div class="line"><span class="lineno">  954</span>        <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  955</span>            n = int(2 ** np.ceil((eta2 - eta1) / halfpi))</div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordflow">if</span> n &lt; 1:</div>
<div class="line"><span class="lineno">  957</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;n must be &gt;= 1 or None&quot;</span>)</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span>        deta = (eta2 - eta1) / n</div>
<div class="line"><span class="lineno">  960</span>        t = np.tan(0.5 * deta)</div>
<div class="line"><span class="lineno">  961</span>        alpha = np.sin(deta) * (np.sqrt(4.0 + 3.0 * t * t) - 1) / 3.0</div>
<div class="line"><span class="lineno">  962</span> </div>
<div class="line"><span class="lineno">  963</span>        steps = np.linspace(eta1, eta2, n + 1, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  964</span>        cos_eta = np.cos(steps)</div>
<div class="line"><span class="lineno">  965</span>        sin_eta = np.sin(steps)</div>
<div class="line"><span class="lineno">  966</span> </div>
<div class="line"><span class="lineno">  967</span>        xA = cos_eta[:-1]</div>
<div class="line"><span class="lineno">  968</span>        yA = sin_eta[:-1]</div>
<div class="line"><span class="lineno">  969</span>        xA_dot = -yA</div>
<div class="line"><span class="lineno">  970</span>        yA_dot = xA</div>
<div class="line"><span class="lineno">  971</span> </div>
<div class="line"><span class="lineno">  972</span>        xB = cos_eta[1:]</div>
<div class="line"><span class="lineno">  973</span>        yB = sin_eta[1:]</div>
<div class="line"><span class="lineno">  974</span>        xB_dot = -yB</div>
<div class="line"><span class="lineno">  975</span>        yB_dot = xB</div>
<div class="line"><span class="lineno">  976</span> </div>
<div class="line"><span class="lineno">  977</span>        <span class="keywordflow">if</span> is_wedge:</div>
<div class="line"><span class="lineno">  978</span>            length = n * 3 + 4</div>
<div class="line"><span class="lineno">  979</span>            vertices = np.zeros((length, 2), float)</div>
<div class="line"><span class="lineno">  980</span>            codes = np.full(length, cls.CURVE4, dtype=cls.code_type)</div>
<div class="line"><span class="lineno">  981</span>            vertices[1] = [xA[0], yA[0]]</div>
<div class="line"><span class="lineno">  982</span>            codes[0:2] = [cls.MOVETO, cls.LINETO]</div>
<div class="line"><span class="lineno">  983</span>            codes[-2:] = [cls.LINETO, cls.CLOSEPOLY]</div>
<div class="line"><span class="lineno">  984</span>            vertex_offset = 2</div>
<div class="line"><span class="lineno">  985</span>            end = length - 2</div>
<div class="line"><span class="lineno">  986</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  987</span>            length = n * 3 + 1</div>
<div class="line"><span class="lineno">  988</span>            vertices = np.empty((length, 2), float)</div>
<div class="line"><span class="lineno">  989</span>            codes = np.full(length, cls.CURVE4, dtype=cls.code_type)</div>
<div class="line"><span class="lineno">  990</span>            vertices[0] = [xA[0], yA[0]]</div>
<div class="line"><span class="lineno">  991</span>            codes[0] = cls.MOVETO</div>
<div class="line"><span class="lineno">  992</span>            vertex_offset = 1</div>
<div class="line"><span class="lineno">  993</span>            end = length</div>
<div class="line"><span class="lineno">  994</span> </div>
<div class="line"><span class="lineno">  995</span>        vertices[vertex_offset:end:3, 0] = xA + alpha * xA_dot</div>
<div class="line"><span class="lineno">  996</span>        vertices[vertex_offset:end:3, 1] = yA + alpha * yA_dot</div>
<div class="line"><span class="lineno">  997</span>        vertices[vertex_offset+1:end:3, 0] = xB - alpha * xB_dot</div>
<div class="line"><span class="lineno">  998</span>        vertices[vertex_offset+1:end:3, 1] = yB - alpha * yB_dot</div>
<div class="line"><span class="lineno">  999</span>        vertices[vertex_offset+2:end:3, 0] = xB</div>
<div class="line"><span class="lineno"> 1000</span>        vertices[vertex_offset+2:end:3, 1] = yB</div>
<div class="line"><span class="lineno"> 1001</span> </div>
<div class="line"><span class="lineno"> 1002</span>        <span class="keywordflow">return</span> cls(vertices, codes, readonly=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1003</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad82a88020b719e952f30f04ff23434f2" name="ad82a88020b719e952f30f04ff23434f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82a88020b719e952f30f04ff23434f2">&#9670;&#160;</a></span>circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.circle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>(0.,&#160;0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>readonly</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a `Path` representing a circle of a given radius and center.

Parameters
----------
center : (float, float), default: (0, 0)
    The center of the circle.
radius : float, default: 1
    The radius of the circle.
readonly : bool
    Whether the created path should have the "readonly" argument
    set when creating the Path instance.

Notes
-----
The circle is approximated using 8 cubic Bezier curves, as described in

  Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four
  Bezier Cubic Splines &lt;https://www.tinaja.com/glib/ellipse4.pdf&gt;`_.
</pre> <div class="fragment"><div class="line"><span class="lineno">  814</span>    <span class="keyword">def </span>circle(cls, center=(0., 0.), radius=1., readonly=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  815</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">        Return a `Path` representing a circle of a given radius and center.</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">        center : (float, float), default: (0, 0)</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">            The center of the circle.</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        radius : float, default: 1</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">            The radius of the circle.</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        readonly : bool</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">            Whether the created path should have the &quot;readonly&quot; argument</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">            set when creating the Path instance.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">        The circle is approximated using 8 cubic Bezier curves, as described in</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">          Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">          Bezier Cubic Splines &lt;https://www.tinaja.com/glib/ellipse4.pdf&gt;`_.</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  835</span>        MAGIC = 0.2652031</div>
<div class="line"><span class="lineno">  836</span>        SQRTHALF = np.sqrt(0.5)</div>
<div class="line"><span class="lineno">  837</span>        MAGIC45 = SQRTHALF * MAGIC</div>
<div class="line"><span class="lineno">  838</span> </div>
<div class="line"><span class="lineno">  839</span>        vertices = np.array([[0.0, -1.0],</div>
<div class="line"><span class="lineno">  840</span> </div>
<div class="line"><span class="lineno">  841</span>                             [MAGIC, -1.0],</div>
<div class="line"><span class="lineno">  842</span>                             [SQRTHALF-MAGIC45, -SQRTHALF-MAGIC45],</div>
<div class="line"><span class="lineno">  843</span>                             [SQRTHALF, -SQRTHALF],</div>
<div class="line"><span class="lineno">  844</span> </div>
<div class="line"><span class="lineno">  845</span>                             [SQRTHALF+MAGIC45, -SQRTHALF+MAGIC45],</div>
<div class="line"><span class="lineno">  846</span>                             [1.0, -MAGIC],</div>
<div class="line"><span class="lineno">  847</span>                             [1.0, 0.0],</div>
<div class="line"><span class="lineno">  848</span> </div>
<div class="line"><span class="lineno">  849</span>                             [1.0, MAGIC],</div>
<div class="line"><span class="lineno">  850</span>                             [SQRTHALF+MAGIC45, SQRTHALF-MAGIC45],</div>
<div class="line"><span class="lineno">  851</span>                             [SQRTHALF, SQRTHALF],</div>
<div class="line"><span class="lineno">  852</span> </div>
<div class="line"><span class="lineno">  853</span>                             [SQRTHALF-MAGIC45, SQRTHALF+MAGIC45],</div>
<div class="line"><span class="lineno">  854</span>                             [MAGIC, 1.0],</div>
<div class="line"><span class="lineno">  855</span>                             [0.0, 1.0],</div>
<div class="line"><span class="lineno">  856</span> </div>
<div class="line"><span class="lineno">  857</span>                             [-MAGIC, 1.0],</div>
<div class="line"><span class="lineno">  858</span>                             [-SQRTHALF+MAGIC45, SQRTHALF+MAGIC45],</div>
<div class="line"><span class="lineno">  859</span>                             [-SQRTHALF, SQRTHALF],</div>
<div class="line"><span class="lineno">  860</span> </div>
<div class="line"><span class="lineno">  861</span>                             [-SQRTHALF-MAGIC45, SQRTHALF-MAGIC45],</div>
<div class="line"><span class="lineno">  862</span>                             [-1.0, MAGIC],</div>
<div class="line"><span class="lineno">  863</span>                             [-1.0, 0.0],</div>
<div class="line"><span class="lineno">  864</span> </div>
<div class="line"><span class="lineno">  865</span>                             [-1.0, -MAGIC],</div>
<div class="line"><span class="lineno">  866</span>                             [-SQRTHALF-MAGIC45, -SQRTHALF+MAGIC45],</div>
<div class="line"><span class="lineno">  867</span>                             [-SQRTHALF, -SQRTHALF],</div>
<div class="line"><span class="lineno">  868</span> </div>
<div class="line"><span class="lineno">  869</span>                             [-SQRTHALF+MAGIC45, -SQRTHALF-MAGIC45],</div>
<div class="line"><span class="lineno">  870</span>                             [-MAGIC, -1.0],</div>
<div class="line"><span class="lineno">  871</span>                             [0.0, -1.0],</div>
<div class="line"><span class="lineno">  872</span> </div>
<div class="line"><span class="lineno">  873</span>                             [0.0, -1.0]],</div>
<div class="line"><span class="lineno">  874</span>                            dtype=float)</div>
<div class="line"><span class="lineno">  875</span> </div>
<div class="line"><span class="lineno">  876</span>        codes = [cls.CURVE4] * 26</div>
<div class="line"><span class="lineno">  877</span>        codes[0] = cls.MOVETO</div>
<div class="line"><span class="lineno">  878</span>        codes[-1] = cls.CLOSEPOLY</div>
<div class="line"><span class="lineno">  879</span>        <span class="keywordflow">return</span> Path(vertices * radius + center, codes, readonly=readonly)</div>
<div class="line"><span class="lineno">  880</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a211aa46e2ddfe9ccce990f375b632a98" name="a211aa46e2ddfe9ccce990f375b632a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211aa46e2ddfe9ccce990f375b632a98">&#9670;&#160;</a></span>cleaned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.cleaned </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remove_nans</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clip</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stroke_width</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>snap</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sketch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new Path with vertices and codes cleaned according to the
parameters.

See Also
--------
Path.iter_segments : for details of the keyword arguments.
</pre> <div class="fragment"><div class="line"><span class="lineno">  469</span>                stroke_width=1.0, snap=<span class="keyword">False</span>, sketch=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  470</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">        Return a new Path with vertices and codes cleaned according to the</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        parameters.</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        Path.iter_segments : for details of the keyword arguments.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  478</span>        vertices, codes = _path.cleanup_path(</div>
<div class="line"><span class="lineno">  479</span>            self, transform, remove_nans, clip, snap, stroke_width, simplify,</div>
<div class="line"><span class="lineno">  480</span>            curves, sketch)</div>
<div class="line"><span class="lineno">  481</span>        pth = Path._fast_from_codes_and_verts(vertices, codes, self)</div>
<div class="line"><span class="lineno">  482</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> simplify:</div>
<div class="line"><span class="lineno">  483</span>            pth._should_simplify = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  484</span>        <span class="keywordflow">return</span> pth</div>
<div class="line"><span class="lineno">  485</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3557379f22a58b0a9a3038049d5c4c2" name="ae3557379f22a58b0a9a3038049d5c4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3557379f22a58b0a9a3038049d5c4c2">&#9670;&#160;</a></span>clip_to_bbox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.clip_to_bbox </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inside</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clip the path to the given bounding box.

The path must be made up of one or more closed polygons.  This
algorithm will not behave correctly for unclosed paths.

If *inside* is `True`, clip to the inside of the box, otherwise
to the outside of the box.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1034</span>    <span class="keyword">def </span>clip_to_bbox(self, bbox, inside=True):</div>
<div class="line"><span class="lineno"> 1035</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">        Clip the path to the given bounding box.</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">        The path must be made up of one or more closed polygons.  This</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">        algorithm will not behave correctly for unclosed paths.</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">        If *inside* is `True`, clip to the inside of the box, otherwise</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        to the outside of the box.</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1044</span>        <span class="comment"># Use make_compound_path_from_polys</span></div>
<div class="line"><span class="lineno"> 1045</span>        verts = _path.clip_path_to_rect(self, bbox, inside)</div>
<div class="line"><span class="lineno"> 1046</span>        paths = [Path(poly) <span class="keywordflow">for</span> poly <span class="keywordflow">in</span> verts]</div>
<div class="line"><span class="lineno"> 1047</span>        <span class="keywordflow">return</span> self.make_compound_path(*paths)</div>
<div class="line"><span class="lineno"> 1048</span> </div>
<div class="line"><span class="lineno"> 1049</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afe998ea0d6b05793e9d6057a5543df62" name="afe998ea0d6b05793e9d6057a5543df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe998ea0d6b05793e9d6057a5543df62">&#9670;&#160;</a></span>codes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.codes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The list of codes in the `Path` as a 1D numpy array.  Each
code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4`
or `CLOSEPOLY`.  For codes that correspond to more than one
vertex (`CURVE3` and `CURVE4`), that code will be repeated so
that the length of `vertices` and `codes` is always
the same.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1textpath_1_1_text_path.html#a0d3deb42b166303a99befedc0a2548d4">matplotlib.textpath.TextPath</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  226</span>    <span class="keyword">def </span>codes(self):</div>
<div class="line"><span class="lineno">  227</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">        The list of codes in the `Path` as a 1D numpy array.  Each</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4`</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        or `CLOSEPOLY`.  For codes that correspond to more than one</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        vertex (`CURVE3` and `CURVE4`), that code will be repeated so</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        that the length of `vertices` and `codes` is always</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        the same.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  235</span>        <span class="keywordflow">return</span> self._codes</div>
<div class="line"><span class="lineno">  236</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c144d5781ba8f4b5fbc483ff3237b3f" name="a8c144d5781ba8f4b5fbc483ff3237b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c144d5781ba8f4b5fbc483ff3237b3f">&#9670;&#160;</a></span>codes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.codes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>codes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1textpath_1_1_text_path.html#a0d3deb42b166303a99befedc0a2548d4">matplotlib.textpath.TextPath</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  238</span>    <span class="keyword">def </span>codes(self, codes):</div>
<div class="line"><span class="lineno">  239</span>        <span class="keywordflow">if</span> self._readonly:</div>
<div class="line"><span class="lineno">  240</span>            <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&quot;Can&#39;t set codes on a readonly Path&quot;</span>)</div>
<div class="line"><span class="lineno">  241</span>        self._codes = codes</div>
<div class="line"><span class="lineno">  242</span>        self._update_values()</div>
<div class="line"><span class="lineno">  243</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3aa7bb3f42ac23f35b36c79b592c38e0" name="a3aa7bb3f42ac23f35b36c79b592c38e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa7bb3f42ac23f35b36c79b592c38e0">&#9670;&#160;</a></span>contains_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.contains_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether this (closed) path completely contains the given path.

If *transform* is not ``None``, the path will be transformed before
checking for containment.
</pre> <div class="fragment"><div class="line"><span class="lineno">  593</span>    <span class="keyword">def </span>contains_path(self, path, transform=None):</div>
<div class="line"><span class="lineno">  594</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        Return whether this (closed) path completely contains the given path.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        If *transform* is not ``None``, the path will be transformed before</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">        checking for containment.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  600</span>        <span class="keywordflow">if</span> transform <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  601</span>            transform = transform.frozen()</div>
<div class="line"><span class="lineno">  602</span>        <span class="keywordflow">return</span> _path.path_in_path(self, <span class="keywordtype">None</span>, path, transform)</div>
<div class="line"><span class="lineno">  603</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae50feb4a3645c2a5b1f5aaacd596dfef" name="ae50feb4a3645c2a5b1f5aaacd596dfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50feb4a3645c2a5b1f5aaacd596dfef">&#9670;&#160;</a></span>contains_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.contains_point </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radius</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the area enclosed by the path contains the given point.

The path is always treated as closed; i.e. if the last code is not
CLOSEPOLY an implicit segment connecting the last vertex to the first
vertex is assumed.

Parameters
----------
point : (float, float)
    The point (x, y) to check.
transform : `matplotlib.transforms.Transform`, optional
    If not ``None``, *point* will be compared to ``self`` transformed
    by *transform*; i.e. for a correct check, *transform* should
    transform the path into the coordinate system of *point*.
radius : float, default: 0
    Add an additional margin on the path in coordinates of *point*.
    The path is extended tangentially by *radius/2*; i.e. if you would
    draw the path with a linewidth of *radius*, all points on the line
    would still be considered to be contained in the area. Conversely,
    negative values shrink the area: Points on the imaginary line
    will be considered outside the area.

Returns
-------
bool

Notes
-----
The current algorithm has some limitations:

- The result is undefined for points exactly at the boundary
  (i.e. at the path shifted by *radius/2*).
- The result is undefined if there is no enclosed area, i.e. all
  vertices are on a straight line.
- If bounding lines start to cross each other due to *radius* shift,
  the result is not guaranteed to be correct.
</pre> <div class="fragment"><div class="line"><span class="lineno">  499</span>    <span class="keyword">def </span>contains_point(self, point, transform=None, radius=0.0):</div>
<div class="line"><span class="lineno">  500</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        Return whether the area enclosed by the path contains the given point.</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        The path is always treated as closed; i.e. if the last code is not</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        CLOSEPOLY an implicit segment connecting the last vertex to the first</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        vertex is assumed.</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        point : (float, float)</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">            The point (x, y) to check.</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        transform : `matplotlib.transforms.Transform`, optional</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">            If not ``None``, *point* will be compared to ``self`` transformed</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">            by *transform*; i.e. for a correct check, *transform* should</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">            transform the path into the coordinate system of *point*.</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        radius : float, default: 0</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">            Add an additional margin on the path in coordinates of *point*.</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">            The path is extended tangentially by *radius/2*; i.e. if you would</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">            draw the path with a linewidth of *radius*, all points on the line</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">            would still be considered to be contained in the area. Conversely,</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">            negative values shrink the area: Points on the imaginary line</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">            will be considered outside the area.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        The current algorithm has some limitations:</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        - The result is undefined for points exactly at the boundary</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">          (i.e. at the path shifted by *radius/2*).</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        - The result is undefined if there is no enclosed area, i.e. all</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">          vertices are on a straight line.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        - If bounding lines start to cross each other due to *radius* shift,</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">          the result is not guaranteed to be correct.</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  538</span>        <span class="keywordflow">if</span> transform <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  539</span>            transform = transform.frozen()</div>
<div class="line"><span class="lineno">  540</span>        <span class="comment"># `point_in_path` does not handle nonlinear transforms, so we</span></div>
<div class="line"><span class="lineno">  541</span>        <span class="comment"># transform the path ourselves.  If *transform* is affine, letting</span></div>
<div class="line"><span class="lineno">  542</span>        <span class="comment"># `point_in_path` handle the transform avoids allocating an extra</span></div>
<div class="line"><span class="lineno">  543</span>        <span class="comment"># buffer.</span></div>
<div class="line"><span class="lineno">  544</span>        <span class="keywordflow">if</span> transform <span class="keywordflow">and</span> <span class="keywordflow">not</span> transform.is_affine:</div>
<div class="line"><span class="lineno">  545</span>            self = transform.transform_path(self)</div>
<div class="line"><span class="lineno">  546</span>            transform = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">return</span> _path.point_in_path(point[0], point[1], radius, self, transform)</div>
<div class="line"><span class="lineno">  548</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a59aa207de062647998c651c80e256ee5" name="a59aa207de062647998c651c80e256ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59aa207de062647998c651c80e256ee5">&#9670;&#160;</a></span>contains_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.contains_points </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radius</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the area enclosed by the path contains the given points.

The path is always treated as closed; i.e. if the last code is not
CLOSEPOLY an implicit segment connecting the last vertex to the first
vertex is assumed.

Parameters
----------
points : (N, 2) array
    The points to check. Columns contain x and y values.
transform : `matplotlib.transforms.Transform`, optional
    If not ``None``, *points* will be compared to ``self`` transformed
    by *transform*; i.e. for a correct check, *transform* should
    transform the path into the coordinate system of *points*.
radius : float, default: 0
    Add an additional margin on the path in coordinates of *points*.
    The path is extended tangentially by *radius/2*; i.e. if you would
    draw the path with a linewidth of *radius*, all points on the line
    would still be considered to be contained in the area. Conversely,
    negative values shrink the area: Points on the imaginary line
    will be considered outside the area.

Returns
-------
length-N bool array

Notes
-----
The current algorithm has some limitations:

- The result is undefined for points exactly at the boundary
  (i.e. at the path shifted by *radius/2*).
- The result is undefined if there is no enclosed area, i.e. all
  vertices are on a straight line.
- If bounding lines start to cross each other due to *radius* shift,
  the result is not guaranteed to be correct.
</pre> <div class="fragment"><div class="line"><span class="lineno">  549</span>    <span class="keyword">def </span>contains_points(self, points, transform=None, radius=0.0):</div>
<div class="line"><span class="lineno">  550</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        Return whether the area enclosed by the path contains the given points.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        The path is always treated as closed; i.e. if the last code is not</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">        CLOSEPOLY an implicit segment connecting the last vertex to the first</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">        vertex is assumed.</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        points : (N, 2) array</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">            The points to check. Columns contain x and y values.</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">        transform : `matplotlib.transforms.Transform`, optional</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">            If not ``None``, *points* will be compared to ``self`` transformed</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">            by *transform*; i.e. for a correct check, *transform* should</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">            transform the path into the coordinate system of *points*.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">        radius : float, default: 0</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">            Add an additional margin on the path in coordinates of *points*.</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">            The path is extended tangentially by *radius/2*; i.e. if you would</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">            draw the path with a linewidth of *radius*, all points on the line</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">            would still be considered to be contained in the area. Conversely,</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">            negative values shrink the area: Points on the imaginary line</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">            will be considered outside the area.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">        length-N bool array</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        The current algorithm has some limitations:</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        - The result is undefined for points exactly at the boundary</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">          (i.e. at the path shifted by *radius/2*).</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        - The result is undefined if there is no enclosed area, i.e. all</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">          vertices are on a straight line.</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        - If bounding lines start to cross each other due to *radius* shift,</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">          the result is not guaranteed to be correct.</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  588</span>        <span class="keywordflow">if</span> transform <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  589</span>            transform = transform.frozen()</div>
<div class="line"><span class="lineno">  590</span>        result = _path.points_in_path(points, radius, self, transform)</div>
<div class="line"><span class="lineno">  591</span>        <span class="keywordflow">return</span> result.astype(<span class="stringliteral">&#39;bool&#39;</span>)</div>
<div class="line"><span class="lineno">  592</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aff434f82845d852852aadd2ea77f635a" name="aff434f82845d852852aadd2ea77f635a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff434f82845d852852aadd2ea77f635a">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a shallow copy of the `Path`, which will share the
vertices and codes with the source `Path`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  274</span>    <span class="keyword">def </span>copy(self):</div>
<div class="line"><span class="lineno">  275</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        Return a shallow copy of the `Path`, which will share the</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        vertices and codes with the source `Path`.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  279</span>        <span class="keywordflow">return</span> copy.copy(self)</div>
<div class="line"><span class="lineno">  280</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a46ff5d5d2eddc95a6337266db0ba528a" name="a46ff5d5d2eddc95a6337266db0ba528a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ff5d5d2eddc95a6337266db0ba528a">&#9670;&#160;</a></span>get_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.get_extents </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get Bbox of the path.

Parameters
----------
transform : matplotlib.transforms.Transform, optional
    Transform to apply to path before computing extents, if any.
**kwargs
    Forwarded to `.iter_bezier`.

Returns
-------
matplotlib.transforms.Bbox
    The extents of the path Bbox([[xmin, ymin], [xmax, ymax]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  604</span>    <span class="keyword">def </span>get_extents(self, transform=None, **kwargs):</div>
<div class="line"><span class="lineno">  605</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        Get Bbox of the path.</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">        transform : matplotlib.transforms.Transform, optional</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">            Transform to apply to path before computing extents, if any.</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">        **kwargs</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">            Forwarded to `.iter_bezier`.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">        matplotlib.transforms.Bbox</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">            The extents of the path Bbox([[xmin, ymin], [xmax, ymax]])</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="keyword">from</span> .transforms <span class="keyword">import</span> Bbox</div>
<div class="line"><span class="lineno">  621</span>        <span class="keywordflow">if</span> transform <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  622</span>            self = transform.transform_path(self)</div>
<div class="line"><span class="lineno">  623</span>        <span class="keywordflow">if</span> self.codes <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  624</span>            xys = self.vertices</div>
<div class="line"><span class="lineno">  625</span>        <span class="keywordflow">elif</span> len(np.intersect1d(self.codes, [Path.CURVE3, Path.CURVE4])) == 0:</div>
<div class="line"><span class="lineno">  626</span>            <span class="comment"># Optimization for the straight line case.</span></div>
<div class="line"><span class="lineno">  627</span>            <span class="comment"># Instead of iterating through each curve, consider</span></div>
<div class="line"><span class="lineno">  628</span>            <span class="comment"># each line segment&#39;s end-points</span></div>
<div class="line"><span class="lineno">  629</span>            <span class="comment"># (recall that STOP and CLOSEPOLY vertices are ignored)</span></div>
<div class="line"><span class="lineno">  630</span>            xys = self.vertices[np.isin(self.codes,</div>
<div class="line"><span class="lineno">  631</span>                                        [Path.MOVETO, Path.LINETO])]</div>
<div class="line"><span class="lineno">  632</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  633</span>            xys = []</div>
<div class="line"><span class="lineno">  634</span>            <span class="keywordflow">for</span> curve, code <span class="keywordflow">in</span> self.iter_bezier(**kwargs):</div>
<div class="line"><span class="lineno">  635</span>                <span class="comment"># places where the derivative is zero can be extrema</span></div>
<div class="line"><span class="lineno">  636</span>                _, dzeros = curve.axis_aligned_extrema()</div>
<div class="line"><span class="lineno">  637</span>                <span class="comment"># as can the ends of the curve</span></div>
<div class="line"><span class="lineno">  638</span>                xys.append(curve([0, *dzeros, 1]))</div>
<div class="line"><span class="lineno">  639</span>            xys = np.concatenate(xys)</div>
<div class="line"><span class="lineno">  640</span>        <span class="keywordflow">if</span> len(xys):</div>
<div class="line"><span class="lineno">  641</span>            <span class="keywordflow">return</span> Bbox([xys.min(axis=0), xys.max(axis=0)])</div>
<div class="line"><span class="lineno">  642</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  643</span>            <span class="keywordflow">return</span> Bbox.null()</div>
<div class="line"><span class="lineno">  644</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a60e0b253e84c683a2498cf45cb306cdf" name="a60e0b253e84c683a2498cf45cb306cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e0b253e84c683a2498cf45cb306cdf">&#9670;&#160;</a></span>hatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.hatch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hatchpattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Given a hatch specifier, *hatchpattern*, generates a Path that
can be used in a repeated hatching pattern.  *density* is the
number of lines per unit square.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1024</span>    <span class="keyword">def </span>hatch(hatchpattern, density=6):</div>
<div class="line"><span class="lineno"> 1025</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">        Given a hatch specifier, *hatchpattern*, generates a Path that</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">        can be used in a repeated hatching pattern.  *density* is the</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">        number of lines per unit square.</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1030</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacematplotlib_1_1hatch.html">matplotlib.hatch</a> <span class="keyword">import</span> get_path</div>
<div class="line"><span class="lineno"> 1031</span>        <span class="keywordflow">return</span> (get_path(hatchpattern, density)</div>
<div class="line"><span class="lineno"> 1032</span>                <span class="keywordflow">if</span> hatchpattern <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1033</span> </div>
<div class="ttc" id="anamespacematplotlib_1_1hatch_html"><div class="ttname"><a href="namespacematplotlib_1_1hatch.html">matplotlib.hatch</a></div><div class="ttdef"><b>Definition</b> hatch.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a65a3da4d45f60b0154da43fcad25bd61" name="a65a3da4d45f60b0154da43fcad25bd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a3da4d45f60b0154da43fcad25bd61">&#9670;&#160;</a></span>interpolated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.interpolated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new path resampled to length N x steps.

Codes other than LINETO are not handled correctly.
</pre> <div class="fragment"><div class="line"><span class="lineno">  666</span>    <span class="keyword">def </span>interpolated(self, steps):</div>
<div class="line"><span class="lineno">  667</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">        Return a new path resampled to length N x steps.</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        Codes other than LINETO are not handled correctly.</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  672</span>        <span class="keywordflow">if</span> steps == 1:</div>
<div class="line"><span class="lineno">  673</span>            <span class="keywordflow">return</span> self</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span>        vertices = simple_linear_interpolation(self.vertices, steps)</div>
<div class="line"><span class="lineno">  676</span>        codes = self.codes</div>
<div class="line"><span class="lineno">  677</span>        <span class="keywordflow">if</span> codes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  678</span>            new_codes = np.full((len(codes) - 1) * steps + 1, Path.LINETO,</div>
<div class="line"><span class="lineno">  679</span>                                dtype=self.code_type)</div>
<div class="line"><span class="lineno">  680</span>            new_codes[0::steps] = codes</div>
<div class="line"><span class="lineno">  681</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  682</span>            new_codes = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  683</span>        <span class="keywordflow">return</span> Path(vertices, new_codes)</div>
<div class="line"><span class="lineno">  684</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae630ece0ec1f528347fc7134b154b9e9" name="ae630ece0ec1f528347fc7134b154b9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae630ece0ec1f528347fc7134b154b9e9">&#9670;&#160;</a></span>intersects_bbox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.intersects_bbox </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filled</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether this path intersects a given `~.transforms.Bbox`.

If *filled* is True, then this also returns True if the path completely
encloses the `.Bbox` (i.e., the path is treated as filled).

The bounding box is always considered filled.
</pre> <div class="fragment"><div class="line"><span class="lineno">  654</span>    <span class="keyword">def </span>intersects_bbox(self, bbox, filled=True):</div>
<div class="line"><span class="lineno">  655</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        Return whether this path intersects a given `~.transforms.Bbox`.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        If *filled* is True, then this also returns True if the path completely</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        encloses the `.Bbox` (i.e., the path is treated as filled).</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">        The bounding box is always considered filled.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  663</span>        <span class="keywordflow">return</span> _path.path_intersects_rectangle(</div>
<div class="line"><span class="lineno">  664</span>            self, bbox.x0, bbox.y0, bbox.x1, bbox.y1, filled)</div>
<div class="line"><span class="lineno">  665</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2bb737afdfeac3adf8f5c4e827a629d3" name="a2bb737afdfeac3adf8f5c4e827a629d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb737afdfeac3adf8f5c4e827a629d3">&#9670;&#160;</a></span>intersects_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.intersects_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filled</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether if this path intersects another given path.

If *filled* is True, then this also returns True if one path completely
encloses the other (i.e., the paths are treated as filled).
</pre> <div class="fragment"><div class="line"><span class="lineno">  645</span>    <span class="keyword">def </span>intersects_path(self, other, filled=True):</div>
<div class="line"><span class="lineno">  646</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        Return whether if this path intersects another given path.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        If *filled* is True, then this also returns True if one path completely</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">        encloses the other (i.e., the paths are treated as filled).</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">return</span> _path.path_intersects_path(self, other, filled)</div>
<div class="line"><span class="lineno">  653</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a01bc6f4f234ab0bd120f6a21ba99bfb9" name="a01bc6f4f234ab0bd120f6a21ba99bfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bc6f4f234ab0bd120f6a21ba99bfb9">&#9670;&#160;</a></span>iter_bezier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.iter_bezier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over each bezier curve (lines included) in a Path.

Parameters
----------
**kwargs
    Forwarded to `.iter_segments`.

Yields
------
B : matplotlib.bezier.BezierSegment
    The bezier curves that make up the current path. Note in particular
    that freestanding points are bezier curves of order 0, and lines
    are bezier curves of order 1 (with two control points).
code : Path.code_type
    The code describing what kind of curve is being returned.
    Path.MOVETO, Path.LINETO, Path.CURVE3, Path.CURVE4 correspond to
    bezier curves with 1, 2, 3, and 4 control points (respectively).
    Path.CLOSEPOLY is a Path.LINETO with the control points correctly
    chosen based on the start/end points of the current stroke.
</pre> <div class="fragment"><div class="line"><span class="lineno">  420</span>    <span class="keyword">def </span>iter_bezier(self, **kwargs):</div>
<div class="line"><span class="lineno">  421</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        Iterate over each bezier curve (lines included) in a Path.</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        **kwargs</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">            Forwarded to `.iter_segments`.</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">        Yields</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        B : matplotlib.bezier.BezierSegment</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">            The bezier curves that make up the current path. Note in particular</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">            that freestanding points are bezier curves of order 0, and lines</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">            are bezier curves of order 1 (with two control points).</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        code : Path.code_type</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">            The code describing what kind of curve is being returned.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">            Path.MOVETO, Path.LINETO, Path.CURVE3, Path.CURVE4 correspond to</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">            bezier curves with 1, 2, 3, and 4 control points (respectively).</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">            Path.CLOSEPOLY is a Path.LINETO with the control points correctly</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">            chosen based on the start/end points of the current stroke.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  442</span>        first_vert = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  443</span>        prev_vert = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  444</span>        <span class="keywordflow">for</span> verts, code <span class="keywordflow">in</span> self.iter_segments(**kwargs):</div>
<div class="line"><span class="lineno">  445</span>            <span class="keywordflow">if</span> first_vert <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  446</span>                <span class="keywordflow">if</span> code != Path.MOVETO:</div>
<div class="line"><span class="lineno">  447</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Malformed path, must start with MOVETO.&quot;</span>)</div>
<div class="line"><span class="lineno">  448</span>            <span class="keywordflow">if</span> code == Path.MOVETO:  <span class="comment"># a point is like &quot;CURVE1&quot;</span></div>
<div class="line"><span class="lineno">  449</span>                first_vert = verts</div>
<div class="line"><span class="lineno">  450</span>                <span class="keywordflow">yield</span> BezierSegment(np.array([first_vert])), code</div>
<div class="line"><span class="lineno">  451</span>            <span class="keywordflow">elif</span> code == Path.LINETO:  <span class="comment"># &quot;CURVE2&quot;</span></div>
<div class="line"><span class="lineno">  452</span>                <span class="keywordflow">yield</span> BezierSegment(np.array([prev_vert, verts])), code</div>
<div class="line"><span class="lineno">  453</span>            <span class="keywordflow">elif</span> code == Path.CURVE3:</div>
<div class="line"><span class="lineno">  454</span>                <span class="keywordflow">yield</span> BezierSegment(np.array([prev_vert, verts[:2],</div>
<div class="line"><span class="lineno">  455</span>                                              verts[2:]])), code</div>
<div class="line"><span class="lineno">  456</span>            <span class="keywordflow">elif</span> code == Path.CURVE4:</div>
<div class="line"><span class="lineno">  457</span>                <span class="keywordflow">yield</span> BezierSegment(np.array([prev_vert, verts[:2],</div>
<div class="line"><span class="lineno">  458</span>                                              verts[2:4], verts[4:]])), code</div>
<div class="line"><span class="lineno">  459</span>            <span class="keywordflow">elif</span> code == Path.CLOSEPOLY:</div>
<div class="line"><span class="lineno">  460</span>                <span class="keywordflow">yield</span> BezierSegment(np.array([prev_vert, first_vert])), code</div>
<div class="line"><span class="lineno">  461</span>            <span class="keywordflow">elif</span> code == Path.STOP:</div>
<div class="line"><span class="lineno">  462</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  463</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  464</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid Path.code_type: &quot;</span> + str(code))</div>
<div class="line"><span class="lineno">  465</span>            prev_vert = verts[-2:]</div>
<div class="line"><span class="lineno">  466</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac5c98bb35e3b7720189afaeadade8ed4" name="ac5c98bb35e3b7720189afaeadade8ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c98bb35e3b7720189afaeadade8ed4">&#9670;&#160;</a></span>iter_segments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.iter_segments </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remove_nans</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clip</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>snap</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stroke_width</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sketch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over all curve segments in the path.

Each iteration returns a pair ``(vertices, code)``, where ``vertices``
is a sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.

Additionally, this method can provide a number of standard cleanups and
conversions to the path.

Parameters
----------
transform : None or :class:`~matplotlib.transforms.Transform`
    If not None, the given affine transformation will be applied to the
    path.
remove_nans : bool, optional
    Whether to remove all NaNs from the path and skip over them using
    MOVETO commands.
clip : None or (float, float, float, float), optional
    If not None, must be a four-tuple (x1, y1, x2, y2)
    defining a rectangle in which to clip the path.
snap : None or bool, optional
    If True, snap all nodes to pixels; if False, don't snap them.
    If None, snap if the path contains only segments
    parallel to the x or y axes, and no more than 1024 of them.
stroke_width : float, optional
    The width of the stroke being drawn (used for path snapping).
simplify : None or bool, optional
    Whether to simplify the path by removing vertices
    that do not affect its appearance.  If None, use the
    :attr:`should_simplify` attribute.  See also :rc:`path.simplify`
    and :rc:`path.simplify_threshold`.
curves : bool, optional
    If True, curve segments will be returned as curve segments.
    If False, all curves will be converted to line segments.
sketch : None or sequence, optional
    If not None, must be a 3-tuple of the form
    (scale, length, randomness), representing the sketch parameters.
</pre> <div class="fragment"><div class="line"><span class="lineno">  356</span>                      curves=<span class="keyword">True</span>, sketch=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  357</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">        Iterate over all curve segments in the path.</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        Each iteration returns a pair ``(vertices, code)``, where ``vertices``</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">        is a sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">        Additionally, this method can provide a number of standard cleanups and</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">        conversions to the path.</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">        transform : None or :class:`~matplotlib.transforms.Transform`</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">            If not None, the given affine transformation will be applied to the</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">            path.</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">        remove_nans : bool, optional</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">            Whether to remove all NaNs from the path and skip over them using</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">            MOVETO commands.</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        clip : None or (float, float, float, float), optional</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">            If not None, must be a four-tuple (x1, y1, x2, y2)</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">            defining a rectangle in which to clip the path.</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        snap : None or bool, optional</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">            If True, snap all nodes to pixels; if False, don&#39;t snap them.</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">            If None, snap if the path contains only segments</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">            parallel to the x or y axes, and no more than 1024 of them.</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        stroke_width : float, optional</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">            The width of the stroke being drawn (used for path snapping).</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        simplify : None or bool, optional</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">            Whether to simplify the path by removing vertices</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">            that do not affect its appearance.  If None, use the</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">            :attr:`should_simplify` attribute.  See also :rc:`path.simplify`</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">            and :rc:`path.simplify_threshold`.</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        curves : bool, optional</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">            If True, curve segments will be returned as curve segments.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">            If False, all curves will be converted to line segments.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        sketch : None or sequence, optional</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">            If not None, must be a 3-tuple of the form</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">            (scale, length, randomness), representing the sketch parameters.</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  395</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self):</div>
<div class="line"><span class="lineno">  396</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span>        cleaned = self.cleaned(transform=transform,</div>
<div class="line"><span class="lineno">  399</span>                               remove_nans=remove_nans, clip=clip,</div>
<div class="line"><span class="lineno">  400</span>                               snap=snap, stroke_width=stroke_width,</div>
<div class="line"><span class="lineno">  401</span>                               simplify=simplify, curves=curves,</div>
<div class="line"><span class="lineno">  402</span>                               sketch=sketch)</div>
<div class="line"><span class="lineno">  403</span> </div>
<div class="line"><span class="lineno">  404</span>        <span class="comment"># Cache these object lookups for performance in the loop.</span></div>
<div class="line"><span class="lineno">  405</span>        NUM_VERTICES_FOR_CODE = self.NUM_VERTICES_FOR_CODE</div>
<div class="line"><span class="lineno">  406</span>        STOP = self.STOP</div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span>        vertices = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(cleaned.vertices)</div>
<div class="line"><span class="lineno">  409</span>        codes = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(cleaned.codes)</div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">for</span> curr_vertices, code <span class="keywordflow">in</span> zip(vertices, codes):</div>
<div class="line"><span class="lineno">  411</span>            <span class="keywordflow">if</span> code == STOP:</div>
<div class="line"><span class="lineno">  412</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  413</span>            extra_vertices = NUM_VERTICES_FOR_CODE[code] - 1</div>
<div class="line"><span class="lineno">  414</span>            <span class="keywordflow">if</span> extra_vertices:</div>
<div class="line"><span class="lineno">  415</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(extra_vertices):</div>
<div class="line"><span class="lineno">  416</span>                    next(codes)</div>
<div class="line"><span class="lineno">  417</span>                    curr_vertices = np.append(curr_vertices, next(vertices))</div>
<div class="line"><span class="lineno">  418</span>            <span class="keywordflow">yield</span> curr_vertices, code</div>
<div class="line"><span class="lineno">  419</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeda6e2ad3c910ed2095f43c634f8e8b2" name="aeda6e2ad3c910ed2095f43c634f8e8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda6e2ad3c910ed2095f43c634f8e8b2">&#9670;&#160;</a></span>make_compound_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.make_compound_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a compound path from a list of `Path` objects. Blindly removes
all `Path.STOP` control points.
</pre> <div class="fragment"><div class="line"><span class="lineno">  323</span>    <span class="keyword">def </span>make_compound_path(cls, *args):</div>
<div class="line"><span class="lineno">  324</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        Make a compound path from a list of `Path` objects. Blindly removes</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">        all `Path.STOP` control points.</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  328</span>        <span class="comment"># Handle an empty list in args (i.e. no args).</span></div>
<div class="line"><span class="lineno">  329</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> args:</div>
<div class="line"><span class="lineno">  330</span>            <span class="keywordflow">return</span> Path(np.empty([0, 2], dtype=np.float32))</div>
<div class="line"><span class="lineno">  331</span>        vertices = np.concatenate([x.vertices <span class="keywordflow">for</span> x <span class="keywordflow">in</span> args])</div>
<div class="line"><span class="lineno">  332</span>        codes = np.empty(len(vertices), dtype=cls.code_type)</div>
<div class="line"><span class="lineno">  333</span>        i = 0</div>
<div class="line"><span class="lineno">  334</span>        <span class="keywordflow">for</span> path <span class="keywordflow">in</span> args:</div>
<div class="line"><span class="lineno">  335</span>            <span class="keywordflow">if</span> path.codes <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  336</span>                codes[i] = cls.MOVETO</div>
<div class="line"><span class="lineno">  337</span>                codes[i + 1:i + len(path.vertices)] = cls.LINETO</div>
<div class="line"><span class="lineno">  338</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  339</span>                codes[i:i + len(path.codes)] = path.codes</div>
<div class="line"><span class="lineno">  340</span>            i += len(path.vertices)</div>
<div class="line"><span class="lineno">  341</span>        <span class="comment"># remove STOP&#39;s, since internal STOPs are a bug</span></div>
<div class="line"><span class="lineno">  342</span>        not_stop_mask = codes != cls.STOP</div>
<div class="line"><span class="lineno">  343</span>        vertices = vertices[not_stop_mask, :]</div>
<div class="line"><span class="lineno">  344</span>        codes = codes[not_stop_mask]</div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>        <span class="keywordflow">return</span> cls(vertices, codes)</div>
<div class="line"><span class="lineno">  347</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7bc0a2ba8166260f37d76601a231784e" name="a7bc0a2ba8166260f37d76601a231784e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc0a2ba8166260f37d76601a231784e">&#9670;&#160;</a></span>make_compound_path_from_polys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.make_compound_path_from_polys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>XY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a compound path object to draw a number
of polygons with equal numbers of sides XY is a (numpolys x
numsides x 2) numpy array of vertices.  Return object is a
:class:`Path`.

.. plot:: gallery/misc/histogram_path.py</pre> <div class="fragment"><div class="line"><span class="lineno">  294</span>    <span class="keyword">def </span>make_compound_path_from_polys(cls, XY):</div>
<div class="line"><span class="lineno">  295</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        Make a compound path object to draw a number</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        of polygons with equal numbers of sides XY is a (numpolys x</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        numsides x 2) numpy array of vertices.  Return object is a</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        :class:`Path`.</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        .. plot:: gallery/misc/histogram_path.py</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  304</span> </div>
<div class="line"><span class="lineno">  305</span>        <span class="comment"># for each poly: 1 for the MOVETO, (numsides-1) for the LINETO, 1 for</span></div>
<div class="line"><span class="lineno">  306</span>        <span class="comment"># the CLOSEPOLY; the vert for the closepoly is ignored but we still</span></div>
<div class="line"><span class="lineno">  307</span>        <span class="comment"># need it to keep the codes aligned with the vertices</span></div>
<div class="line"><span class="lineno">  308</span>        numpolys, numsides, two = XY.shape</div>
<div class="line"><span class="lineno">  309</span>        <span class="keywordflow">if</span> two != 2:</div>
<div class="line"><span class="lineno">  310</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The third dimension of &#39;XY&#39; must be 2&quot;</span>)</div>
<div class="line"><span class="lineno">  311</span>        stride = numsides + 1</div>
<div class="line"><span class="lineno">  312</span>        nverts = numpolys * stride</div>
<div class="line"><span class="lineno">  313</span>        verts = np.zeros((nverts, 2))</div>
<div class="line"><span class="lineno">  314</span>        codes = np.full(nverts, cls.LINETO, dtype=cls.code_type)</div>
<div class="line"><span class="lineno">  315</span>        codes[0::stride] = cls.MOVETO</div>
<div class="line"><span class="lineno">  316</span>        codes[numsides::stride] = cls.CLOSEPOLY</div>
<div class="line"><span class="lineno">  317</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(numsides):</div>
<div class="line"><span class="lineno">  318</span>            verts[i::stride] = XY[:, i]</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>        <span class="keywordflow">return</span> cls(verts, codes)</div>
<div class="line"><span class="lineno">  321</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a409d2496b816f3158133d8c6559e36c4" name="a409d2496b816f3158133d8c6559e36c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409d2496b816f3158133d8c6559e36c4">&#9670;&#160;</a></span>readonly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.readonly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">`True` if the `Path` is read-only.
</pre> <div class="fragment"><div class="line"><span class="lineno">  268</span>    <span class="keyword">def </span>readonly(self):</div>
<div class="line"><span class="lineno">  269</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">        `True` if the `Path` is read-only.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  272</span>        <span class="keywordflow">return</span> self._readonly</div>
<div class="line"><span class="lineno">  273</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a48afc6db27356bbdccb88457c07d6a44" name="a48afc6db27356bbdccb88457c07d6a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48afc6db27356bbdccb88457c07d6a44">&#9670;&#160;</a></span>should_simplify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.should_simplify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">`True` if the vertices array should be simplified.
</pre> <div class="fragment"><div class="line"><span class="lineno">  257</span>    <span class="keyword">def </span>should_simplify(self):</div>
<div class="line"><span class="lineno">  258</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        `True` if the vertices array should be simplified.</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  261</span>        <span class="keywordflow">return</span> self._should_simplify</div>
<div class="line"><span class="lineno">  262</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af52d6afe59811e6cd28a7dbbc980a83c" name="af52d6afe59811e6cd28a7dbbc980a83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52d6afe59811e6cd28a7dbbc980a83c">&#9670;&#160;</a></span>should_simplify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.should_simplify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>should_simplify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  264</span>    <span class="keyword">def </span>should_simplify(self, should_simplify):</div>
<div class="line"><span class="lineno">  265</span>        self._should_simplify = should_simplify</div>
<div class="line"><span class="lineno">  266</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a602dcda982582ea2034b020f0676ba" name="a9a602dcda982582ea2034b020f0676ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a602dcda982582ea2034b020f0676ba">&#9670;&#160;</a></span>simplify_threshold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.simplify_threshold </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The fraction of a pixel difference below which vertices will
be simplified out.
</pre> <div class="fragment"><div class="line"><span class="lineno">  245</span>    <span class="keyword">def </span>simplify_threshold(self):</div>
<div class="line"><span class="lineno">  246</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        The fraction of a pixel difference below which vertices will</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        be simplified out.</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  250</span>        <span class="keywordflow">return</span> self._simplify_threshold</div>
<div class="line"><span class="lineno">  251</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cfd9f6052ceddf72fba5a07c4655e50" name="a8cfd9f6052ceddf72fba5a07c4655e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd9f6052ceddf72fba5a07c4655e50">&#9670;&#160;</a></span>simplify_threshold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.simplify_threshold </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  253</span>    <span class="keyword">def </span>simplify_threshold(self, threshold):</div>
<div class="line"><span class="lineno">  254</span>        self._simplify_threshold = threshold</div>
<div class="line"><span class="lineno">  255</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b8876b44d733b4702429bff2221eb47" name="a1b8876b44d733b4702429bff2221eb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8876b44d733b4702429bff2221eb47">&#9670;&#160;</a></span>to_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.to_polygons </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>height</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>closed_only</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert this path to a list of polygons or polylines.  Each
polygon/polyline is an Nx2 array of vertices.  In other words,
each polygon has no ``MOVETO`` instructions or curves.  This
is useful for displaying in backends that do not support
compound paths or Bezier curves.

If *width* and *height* are both non-zero then the lines will
be simplified so that vertices outside of (0, 0), (width,
height) will be clipped.

If *closed_only* is `True` (default), only closed polygons,
with the last point being the same as the first point, will be
returned.  Any unclosed polylines in the path will be
explicitly closed.  If *closed_only* is `False`, any unclosed
polygons in the path will be returned as unclosed polygons,
and the closed polygons will be returned explicitly closed by
setting the last point to the same as the first point.
</pre> <div class="fragment"><div class="line"><span class="lineno">  685</span>    <span class="keyword">def </span>to_polygons(self, transform=None, width=0, height=0, closed_only=True):</div>
<div class="line"><span class="lineno">  686</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        Convert this path to a list of polygons or polylines.  Each</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        polygon/polyline is an Nx2 array of vertices.  In other words,</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        each polygon has no ``MOVETO`` instructions or curves.  This</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        is useful for displaying in backends that do not support</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        compound paths or Bezier curves.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        If *width* and *height* are both non-zero then the lines will</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        be simplified so that vertices outside of (0, 0), (width,</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        height) will be clipped.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        If *closed_only* is `True` (default), only closed polygons,</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        with the last point being the same as the first point, will be</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        returned.  Any unclosed polylines in the path will be</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        explicitly closed.  If *closed_only* is `False`, any unclosed</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        polygons in the path will be returned as unclosed polygons,</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        and the closed polygons will be returned explicitly closed by</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        setting the last point to the same as the first point.</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  705</span>        <span class="keywordflow">if</span> len(self.vertices) == 0:</div>
<div class="line"><span class="lineno">  706</span>            <span class="keywordflow">return</span> []</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span>        <span class="keywordflow">if</span> transform <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  709</span>            transform = transform.frozen()</div>
<div class="line"><span class="lineno">  710</span> </div>
<div class="line"><span class="lineno">  711</span>        <span class="keywordflow">if</span> self.codes <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> (width == 0 <span class="keywordflow">or</span> height == 0):</div>
<div class="line"><span class="lineno">  712</span>            vertices = self.vertices</div>
<div class="line"><span class="lineno">  713</span>            <span class="keywordflow">if</span> closed_only:</div>
<div class="line"><span class="lineno">  714</span>                <span class="keywordflow">if</span> len(vertices) &lt; 3:</div>
<div class="line"><span class="lineno">  715</span>                    <span class="keywordflow">return</span> []</div>
<div class="line"><span class="lineno">  716</span>                <span class="keywordflow">elif</span> np.any(vertices[0] != vertices[-1]):</div>
<div class="line"><span class="lineno">  717</span>                    vertices = [*vertices, vertices[0]]</div>
<div class="line"><span class="lineno">  718</span> </div>
<div class="line"><span class="lineno">  719</span>            <span class="keywordflow">if</span> transform <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  720</span>                <span class="keywordflow">return</span> [vertices]</div>
<div class="line"><span class="lineno">  721</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  722</span>                <span class="keywordflow">return</span> [transform.transform(vertices)]</div>
<div class="line"><span class="lineno">  723</span> </div>
<div class="line"><span class="lineno">  724</span>        <span class="comment"># Deal with the case where there are curves and/or multiple</span></div>
<div class="line"><span class="lineno">  725</span>        <span class="comment"># subpaths (using extension code)</span></div>
<div class="line"><span class="lineno">  726</span>        <span class="keywordflow">return</span> _path.convert_path_to_polygons(</div>
<div class="line"><span class="lineno">  727</span>            self, transform, width, height, closed_only)</div>
<div class="line"><span class="lineno">  728</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac201e83d31984e299842be8cd6f2b88c" name="ac201e83d31984e299842be8cd6f2b88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201e83d31984e299842be8cd6f2b88c">&#9670;&#160;</a></span>transformed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.transformed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a transformed copy of the path.

See Also
--------
matplotlib.transforms.TransformedPath
    A specialized path class that will cache the transformed result and
    automatically update when the transform changes.
</pre> <div class="fragment"><div class="line"><span class="lineno">  486</span>    <span class="keyword">def </span>transformed(self, transform):</div>
<div class="line"><span class="lineno">  487</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        Return a transformed copy of the path.</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">        matplotlib.transforms.TransformedPath</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">            A specialized path class that will cache the transformed result and</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">            automatically update when the transform changes.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  496</span>        <span class="keywordflow">return</span> Path(transform.transform(self.vertices), self.codes,</div>
<div class="line"><span class="lineno">  497</span>                    self._interpolation_steps)</div>
<div class="line"><span class="lineno">  498</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1f9c8e4739390b9a371b1c9b19c09e9" name="aa1f9c8e4739390b9a371b1c9b19c09e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f9c8e4739390b9a371b1c9b19c09e9">&#9670;&#160;</a></span>unit_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.unit_circle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the readonly :class:`Path` of the unit circle.

For most cases, :func:`Path.circle` will be what you want.
</pre> <div class="fragment"><div class="line"><span class="lineno">  802</span>    <span class="keyword">def </span>unit_circle(cls):</div>
<div class="line"><span class="lineno">  803</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        Return the readonly :class:`Path` of the unit circle.</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        For most cases, :func:`Path.circle` will be what you want.</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  808</span>        <span class="keywordflow">if</span> cls._unit_circle <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  809</span>            cls._unit_circle = cls.circle(center=(0, 0), radius=1,</div>
<div class="line"><span class="lineno">  810</span>                                          readonly=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  811</span>        <span class="keywordflow">return</span> cls._unit_circle</div>
<div class="line"><span class="lineno">  812</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aba433ba020bb6577031ae875e00e35fa" name="aba433ba020bb6577031ae875e00e35fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba433ba020bb6577031ae875e00e35fa">&#9670;&#160;</a></span>unit_circle_righthalf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.unit_circle_righthalf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a `Path` of the right half of a unit circle.

See `Path.circle` for the reference on the approximation used.
</pre> <div class="fragment"><div class="line"><span class="lineno">  884</span>    <span class="keyword">def </span>unit_circle_righthalf(cls):</div>
<div class="line"><span class="lineno">  885</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">        Return a `Path` of the right half of a unit circle.</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        See `Path.circle` for the reference on the approximation used.</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  890</span>        <span class="keywordflow">if</span> cls._unit_circle_righthalf <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  891</span>            MAGIC = 0.2652031</div>
<div class="line"><span class="lineno">  892</span>            SQRTHALF = np.sqrt(0.5)</div>
<div class="line"><span class="lineno">  893</span>            MAGIC45 = SQRTHALF * MAGIC</div>
<div class="line"><span class="lineno">  894</span> </div>
<div class="line"><span class="lineno">  895</span>            vertices = np.array(</div>
<div class="line"><span class="lineno">  896</span>                [[0.0, -1.0],</div>
<div class="line"><span class="lineno">  897</span> </div>
<div class="line"><span class="lineno">  898</span>                 [MAGIC, -1.0],</div>
<div class="line"><span class="lineno">  899</span>                 [SQRTHALF-MAGIC45, -SQRTHALF-MAGIC45],</div>
<div class="line"><span class="lineno">  900</span>                 [SQRTHALF, -SQRTHALF],</div>
<div class="line"><span class="lineno">  901</span> </div>
<div class="line"><span class="lineno">  902</span>                 [SQRTHALF+MAGIC45, -SQRTHALF+MAGIC45],</div>
<div class="line"><span class="lineno">  903</span>                 [1.0, -MAGIC],</div>
<div class="line"><span class="lineno">  904</span>                 [1.0, 0.0],</div>
<div class="line"><span class="lineno">  905</span> </div>
<div class="line"><span class="lineno">  906</span>                 [1.0, MAGIC],</div>
<div class="line"><span class="lineno">  907</span>                 [SQRTHALF+MAGIC45, SQRTHALF-MAGIC45],</div>
<div class="line"><span class="lineno">  908</span>                 [SQRTHALF, SQRTHALF],</div>
<div class="line"><span class="lineno">  909</span> </div>
<div class="line"><span class="lineno">  910</span>                 [SQRTHALF-MAGIC45, SQRTHALF+MAGIC45],</div>
<div class="line"><span class="lineno">  911</span>                 [MAGIC, 1.0],</div>
<div class="line"><span class="lineno">  912</span>                 [0.0, 1.0],</div>
<div class="line"><span class="lineno">  913</span> </div>
<div class="line"><span class="lineno">  914</span>                 [0.0, -1.0]],</div>
<div class="line"><span class="lineno">  915</span> </div>
<div class="line"><span class="lineno">  916</span>                float)</div>
<div class="line"><span class="lineno">  917</span> </div>
<div class="line"><span class="lineno">  918</span>            codes = np.full(14, cls.CURVE4, dtype=cls.code_type)</div>
<div class="line"><span class="lineno">  919</span>            codes[0] = cls.MOVETO</div>
<div class="line"><span class="lineno">  920</span>            codes[-1] = cls.CLOSEPOLY</div>
<div class="line"><span class="lineno">  921</span> </div>
<div class="line"><span class="lineno">  922</span>            cls._unit_circle_righthalf = cls(vertices, codes, readonly=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  923</span>        <span class="keywordflow">return</span> cls._unit_circle_righthalf</div>
<div class="line"><span class="lineno">  924</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a49ba77dda5f0d8003857eb1fd5034962" name="a49ba77dda5f0d8003857eb1fd5034962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ba77dda5f0d8003857eb1fd5034962">&#9670;&#160;</a></span>unit_rectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.unit_rectangle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1).
</pre> <div class="fragment"><div class="line"><span class="lineno">  732</span>    <span class="keyword">def </span>unit_rectangle(cls):</div>
<div class="line"><span class="lineno">  733</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">        Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1).</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  736</span>        <span class="keywordflow">if</span> cls._unit_rectangle <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  737</span>            cls._unit_rectangle = cls([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]],</div>
<div class="line"><span class="lineno">  738</span>                                      closed=<span class="keyword">True</span>, readonly=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  739</span>        <span class="keywordflow">return</span> cls._unit_rectangle</div>
<div class="line"><span class="lineno">  740</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acc01de19ca1b6dacb74e5b1252a9d61e" name="acc01de19ca1b6dacb74e5b1252a9d61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc01de19ca1b6dacb74e5b1252a9d61e">&#9670;&#160;</a></span>unit_regular_asterisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.unit_regular_asterisk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`Path` for a unit regular asterisk with the given
numVertices and radius of 1.0, centered at (0, 0).
</pre> <div class="fragment"><div class="line"><span class="lineno">  792</span>    <span class="keyword">def </span>unit_regular_asterisk(cls, numVertices):</div>
<div class="line"><span class="lineno">  793</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        Return a :class:`Path` for a unit regular asterisk with the given</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        numVertices and radius of 1.0, centered at (0, 0).</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  797</span>        <span class="keywordflow">return</span> cls.unit_regular_star(numVertices, 0.0)</div>
<div class="line"><span class="lineno">  798</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b3220713fb5fe470442da9396f344ef" name="a2b3220713fb5fe470442da9396f344ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3220713fb5fe470442da9396f344ef">&#9670;&#160;</a></span>unit_regular_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.unit_regular_polygon </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`Path` instance for a unit regular polygon with the
given *numVertices* such that the circumscribing circle has radius 1.0,
centered at (0, 0).
</pre> <div class="fragment"><div class="line"><span class="lineno">  744</span>    <span class="keyword">def </span>unit_regular_polygon(cls, numVertices):</div>
<div class="line"><span class="lineno">  745</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        Return a :class:`Path` instance for a unit regular polygon with the</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        given *numVertices* such that the circumscribing circle has radius 1.0,</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        centered at (0, 0).</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  750</span>        <span class="keywordflow">if</span> numVertices &lt;= 16:</div>
<div class="line"><span class="lineno">  751</span>            path = cls._unit_regular_polygons.get(numVertices)</div>
<div class="line"><span class="lineno">  752</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  753</span>            path = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  754</span>        <span class="keywordflow">if</span> path <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  755</span>            theta = ((2 * np.pi / numVertices) * np.arange(numVertices + 1)</div>
<div class="line"><span class="lineno">  756</span>                     <span class="comment"># This initial rotation is to make sure the polygon always</span></div>
<div class="line"><span class="lineno">  757</span>                     <span class="comment"># &quot;points-up&quot;.</span></div>
<div class="line"><span class="lineno">  758</span>                     + np.pi / 2)</div>
<div class="line"><span class="lineno">  759</span>            verts = np.column_stack((np.cos(theta), np.sin(theta)))</div>
<div class="line"><span class="lineno">  760</span>            path = cls(verts, closed=<span class="keyword">True</span>, readonly=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  761</span>            <span class="keywordflow">if</span> numVertices &lt;= 16:</div>
<div class="line"><span class="lineno">  762</span>                cls._unit_regular_polygons[numVertices] = path</div>
<div class="line"><span class="lineno">  763</span>        <span class="keywordflow">return</span> path</div>
<div class="line"><span class="lineno">  764</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae48d569869352bc9480f52082c3e9640" name="ae48d569869352bc9480f52082c3e9640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48d569869352bc9480f52082c3e9640">&#9670;&#160;</a></span>unit_regular_star()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.unit_regular_star </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>innerCircle</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`Path` for a unit regular star with the given
numVertices and radius of 1.0, centered at (0, 0).
</pre> <div class="fragment"><div class="line"><span class="lineno">  768</span>    <span class="keyword">def </span>unit_regular_star(cls, numVertices, innerCircle=0.5):</div>
<div class="line"><span class="lineno">  769</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        Return a :class:`Path` for a unit regular star with the given</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        numVertices and radius of 1.0, centered at (0, 0).</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  773</span>        <span class="keywordflow">if</span> numVertices &lt;= 16:</div>
<div class="line"><span class="lineno">  774</span>            path = cls._unit_regular_stars.get((numVertices, innerCircle))</div>
<div class="line"><span class="lineno">  775</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  776</span>            path = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  777</span>        <span class="keywordflow">if</span> path <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  778</span>            ns2 = numVertices * 2</div>
<div class="line"><span class="lineno">  779</span>            theta = (2*np.pi/ns2 * np.arange(ns2 + 1))</div>
<div class="line"><span class="lineno">  780</span>            <span class="comment"># This initial rotation is to make sure the polygon always</span></div>
<div class="line"><span class="lineno">  781</span>            <span class="comment"># &quot;points-up&quot;</span></div>
<div class="line"><span class="lineno">  782</span>            theta += np.pi / 2.0</div>
<div class="line"><span class="lineno">  783</span>            r = np.ones(ns2 + 1)</div>
<div class="line"><span class="lineno">  784</span>            r[1::2] = innerCircle</div>
<div class="line"><span class="lineno">  785</span>            verts = (r * np.vstack((np.cos(theta), np.sin(theta)))).T</div>
<div class="line"><span class="lineno">  786</span>            path = cls(verts, closed=<span class="keyword">True</span>, readonly=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  787</span>            <span class="keywordflow">if</span> numVertices &lt;= 16:</div>
<div class="line"><span class="lineno">  788</span>                cls._unit_regular_stars[(numVertices, innerCircle)] = path</div>
<div class="line"><span class="lineno">  789</span>        <span class="keywordflow">return</span> path</div>
<div class="line"><span class="lineno">  790</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f544d1e907f82186403662c09d86ac8" name="a5f544d1e907f82186403662c09d86ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f544d1e907f82186403662c09d86ac8">&#9670;&#160;</a></span>vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.vertices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The list of vertices in the `Path` as an Nx2 numpy array.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1textpath_1_1_text_path.html#acd03d567f7f27bb2a863d5e2a9af98b0">matplotlib.textpath.TextPath</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  212</span>    <span class="keyword">def </span>vertices(self):</div>
<div class="line"><span class="lineno">  213</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        The list of vertices in the `Path` as an Nx2 numpy array.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  216</span>        <span class="keywordflow">return</span> self._vertices</div>
<div class="line"><span class="lineno">  217</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a68ed90a393875fbe566028138f8ed92b" name="a68ed90a393875fbe566028138f8ed92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ed90a393875fbe566028138f8ed92b">&#9670;&#160;</a></span>vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.vertices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1textpath_1_1_text_path.html#acd03d567f7f27bb2a863d5e2a9af98b0">matplotlib.textpath.TextPath</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  219</span>    <span class="keyword">def </span>vertices(self, vertices):</div>
<div class="line"><span class="lineno">  220</span>        <span class="keywordflow">if</span> self._readonly:</div>
<div class="line"><span class="lineno">  221</span>            <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&quot;Can&#39;t set vertices on a readonly Path&quot;</span>)</div>
<div class="line"><span class="lineno">  222</span>        self._vertices = vertices</div>
<div class="line"><span class="lineno">  223</span>        self._update_values()</div>
<div class="line"><span class="lineno">  224</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4686fca1edba39d194b3076476202b6" name="ad4686fca1edba39d194b3076476202b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4686fca1edba39d194b3076476202b6">&#9670;&#160;</a></span>wedge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.wedge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a `Path` for the unit circle wedge from angles *theta1* to
*theta2* (in degrees).

*theta2* is unwrapped to produce the shortest wedge within 360 degrees.
That is, if *theta2* &gt; *theta1* + 360, the wedge will be from *theta1*
to *theta2* - 360 and not a full circle plus some extra overlap.

If *n* is provided, it is the number of spline segments to make.
If *n* is not provided, the number of spline segments is
determined based on the delta between *theta1* and *theta2*.

See `Path.arc` for the reference on the approximation used.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1005</span>    <span class="keyword">def </span>wedge(cls, theta1, theta2, n=None):</div>
<div class="line"><span class="lineno"> 1006</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">        Return a `Path` for the unit circle wedge from angles *theta1* to</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">        *theta2* (in degrees).</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">        *theta2* is unwrapped to produce the shortest wedge within 360 degrees.</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">        That is, if *theta2* &gt; *theta1* + 360, the wedge will be from *theta1*</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">        to *theta2* - 360 and not a full circle plus some extra overlap.</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">        If *n* is provided, it is the number of spline segments to make.</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">        If *n* is not provided, the number of spline segments is</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">        determined based on the delta between *theta1* and *theta2*.</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">        See `Path.arc` for the reference on the approximation used.</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1020</span>        <span class="keywordflow">return</span> cls.arc(theta1, theta2, n, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1021</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad410ced0ba2b2f8cf92f65119eafc480" name="ad410ced0ba2b2f8cf92f65119eafc480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad410ced0ba2b2f8cf92f65119eafc480">&#9670;&#160;</a></span>_codes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._codes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0a1307b4d90f72d9b15cbbad4fb244a" name="af0a1307b4d90f72d9b15cbbad4fb244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a1307b4d90f72d9b15cbbad4fb244a">&#9670;&#160;</a></span>_interpolation_steps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._interpolation_steps</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afce26848d76d242baf8fa1bc50a9b980" name="afce26848d76d242baf8fa1bc50a9b980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce26848d76d242baf8fa1bc50a9b980">&#9670;&#160;</a></span>_readonly</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._readonly</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d3af14421cfd81382d36b82bd04afcd" name="a7d3af14421cfd81382d36b82bd04afcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3af14421cfd81382d36b82bd04afcd">&#9670;&#160;</a></span>_should_simplify</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._should_simplify</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a007bfa3b782135defeb37f18ebe0a5f5" name="a007bfa3b782135defeb37f18ebe0a5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007bfa3b782135defeb37f18ebe0a5f5">&#9670;&#160;</a></span>_simplify_threshold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._simplify_threshold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2267e8cfe9a5bbd9c7080eadf1560d26" name="a2267e8cfe9a5bbd9c7080eadf1560d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2267e8cfe9a5bbd9c7080eadf1560d26">&#9670;&#160;</a></span>_unit_circle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._unit_circle = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf607cc12149155feb616192d9fd249c" name="acf607cc12149155feb616192d9fd249c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf607cc12149155feb616192d9fd249c">&#9670;&#160;</a></span>_unit_circle_righthalf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._unit_circle_righthalf = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a603ec377abe5dcfbdbc94aa64309f580" name="a603ec377abe5dcfbdbc94aa64309f580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603ec377abe5dcfbdbc94aa64309f580">&#9670;&#160;</a></span>_unit_rectangle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._unit_rectangle = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28037223f6bc997693c8219c79afbd47" name="a28037223f6bc997693c8219c79afbd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28037223f6bc997693c8219c79afbd47">&#9670;&#160;</a></span>_unit_regular_polygons</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._unit_regular_polygons = WeakValueDictionary()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05190eb4e831305e2ce3e319ac6aedb6" name="a05190eb4e831305e2ce3e319ac6aedb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05190eb4e831305e2ce3e319ac6aedb6">&#9670;&#160;</a></span>_unit_regular_stars</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._unit_regular_stars = WeakValueDictionary()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0af8e997d1bab5890f89e544134d0e1b" name="a0af8e997d1bab5890f89e544134d0e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af8e997d1bab5890f89e544134d0e1b">&#9670;&#160;</a></span>_vertices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path._vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02575b90932a2331c8e95fce7b11848c" name="a02575b90932a2331c8e95fce7b11848c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02575b90932a2331c8e95fce7b11848c">&#9670;&#160;</a></span>CLOSEPOLY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.CLOSEPOLY = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(79)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89ee1cccd6a24fe1f278d18d77d84438" name="a89ee1cccd6a24fe1f278d18d77d84438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ee1cccd6a24fe1f278d18d77d84438">&#9670;&#160;</a></span>code_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.code_type = np.uint8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c5c1b3d9cfa6ff7c06e23601c567e0b" name="a6c5c1b3d9cfa6ff7c06e23601c567e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5c1b3d9cfa6ff7c06e23601c567e0b">&#9670;&#160;</a></span>codes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.codes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1textpath_1_1_text_path.html#a0d3deb42b166303a99befedc0a2548d4">matplotlib.textpath.TextPath</a>.</p>

</div>
</div>
<a id="a8fd69ee9fc2a1051a8d67d12910bab4e" name="a8fd69ee9fc2a1051a8d67d12910bab4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd69ee9fc2a1051a8d67d12910bab4e">&#9670;&#160;</a></span>CURVE3</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.CURVE3 = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(3)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec98baae7ae38e7a0ae680fc945f051e" name="aec98baae7ae38e7a0ae680fc945f051e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec98baae7ae38e7a0ae680fc945f051e">&#9670;&#160;</a></span>CURVE4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.CURVE4 = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(4)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b78245ec8753fe8b5c84755a5f36f3" name="ae9b78245ec8753fe8b5c84755a5f36f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b78245ec8753fe8b5c84755a5f36f3">&#9670;&#160;</a></span>deepcopy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.deepcopy = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#af616e6dcaa6b90c505e656353947ba78">__deepcopy__</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af32d8730490de4520b4ef5d4b4a85a96" name="af32d8730490de4520b4ef5d4b4a85a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32d8730490de4520b4ef5d4b4a85a96">&#9670;&#160;</a></span>LINETO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.LINETO = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9e9c539ff8aa6ea04fbe89d48e20221" name="ab9e9c539ff8aa6ea04fbe89d48e20221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e9c539ff8aa6ea04fbe89d48e20221">&#9670;&#160;</a></span>MOVETO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.MOVETO = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedf08d00fec083fa01537120bd7a05ed" name="aedf08d00fec083fa01537120bd7a05ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf08d00fec083fa01537120bd7a05ed">&#9670;&#160;</a></span>NUM_VERTICES_FOR_CODE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict matplotlib.path.Path.NUM_VERTICES_FOR_CODE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  {STOP: 1,</div>
<div class="line">                             MOVETO: 1,</div>
<div class="line">                             LINETO: 1,</div>
<div class="line">                             CURVE3: 2,</div>
<div class="line">                             CURVE4: 3,</div>
<div class="line">                             CLOSEPOLY: 1}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c0f0350d40f9d676f842f7a191cea97" name="a9c0f0350d40f9d676f842f7a191cea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0f0350d40f9d676f842f7a191cea97">&#9670;&#160;</a></span>STOP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.STOP = <a class="el" href="classmatplotlib_1_1path_1_1_path.html#a89ee1cccd6a24fe1f278d18d77d84438">code_type</a>(0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0776b7f5ca038f593efc44ba38dc3a6b" name="a0776b7f5ca038f593efc44ba38dc3a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0776b7f5ca038f593efc44ba38dc3a6b">&#9670;&#160;</a></span>vertices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.path.Path.vertices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1textpath_1_1_text_path.html#acd03d567f7f27bb2a863d5e2a9af98b0">matplotlib.textpath.TextPath</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/matplotlib/<a class="el" href="matplotlib_2path_8py.html">path.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
