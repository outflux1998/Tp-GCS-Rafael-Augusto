<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.optimize._zeros_py Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize.html">optimize</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html">_zeros_py</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.optimize._zeros_py Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__zeros__py_1_1_root_results.html">RootResults</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__zeros__py_1_1_t_o_m_s748_solver.html">TOMS748Solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3235dfa672e442b19c26409aac1b5346" id="r_a3235dfa672e442b19c26409aac1b5346"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a3235dfa672e442b19c26409aac1b5346">results_c</a> (full_output, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>)</td></tr>
<tr class="separator:a3235dfa672e442b19c26409aac1b5346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689dbe6d59afcdcfbd13ead0be02055" id="r_aa689dbe6d59afcdcfbd13ead0be02055"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#aa689dbe6d59afcdcfbd13ead0be02055">_results_select</a> (full_output, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>)</td></tr>
<tr class="separator:aa689dbe6d59afcdcfbd13ead0be02055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af424d369dfc1d4ecc41591ee71ec0c8e" id="r_af424d369dfc1d4ecc41591ee71ec0c8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#af424d369dfc1d4ecc41591ee71ec0c8e">newton</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, x0, fprime=None, args=(), <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1.48e-8, maxiter=50, fprime2=None, x1=None, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=0.0, full_output=False, disp=True)</td></tr>
<tr class="separator:af424d369dfc1d4ecc41591ee71ec0c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f02f91e30ce5256d47c82a773c0da" id="r_a816f02f91e30ce5256d47c82a773c0da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a816f02f91e30ce5256d47c82a773c0da">_array_newton</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, x0, fprime, args, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>, maxiter, fprime2, full_output)</td></tr>
<tr class="separator:a816f02f91e30ce5256d47c82a773c0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ca5c9782c2ff22c2f5b8ea9081d190" id="r_ac2ca5c9782c2ff22c2f5b8ea9081d190"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ac2ca5c9782c2ff22c2f5b8ea9081d190">bisect</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, args=(), xtol=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a>, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a>, maxiter=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a>, full_output=False, disp=True)</td></tr>
<tr class="separator:ac2ca5c9782c2ff22c2f5b8ea9081d190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd37dc830933efa5e8629b8b3f4aa0" id="r_a00cd37dc830933efa5e8629b8b3f4aa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a00cd37dc830933efa5e8629b8b3f4aa0">ridder</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, args=(), xtol=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a>, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a>, maxiter=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a>, full_output=False, disp=True)</td></tr>
<tr class="separator:a00cd37dc830933efa5e8629b8b3f4aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d4c7381bf744ebf05e3f6038e44291" id="r_a22d4c7381bf744ebf05e3f6038e44291"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a22d4c7381bf744ebf05e3f6038e44291">brentq</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, args=(), xtol=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a>, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a>, maxiter=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a>, full_output=False, disp=True)</td></tr>
<tr class="separator:a22d4c7381bf744ebf05e3f6038e44291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5639636c7d4e83b35a9226e6f0ac26" id="r_a2b5639636c7d4e83b35a9226e6f0ac26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a2b5639636c7d4e83b35a9226e6f0ac26">brenth</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, args=(), xtol=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a>, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a>, maxiter=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a>, full_output=False, disp=True)</td></tr>
<tr class="separator:a2b5639636c7d4e83b35a9226e6f0ac26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624b3723b6549240919ca0c48ba2605b" id="r_a624b3723b6549240919ca0c48ba2605b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a624b3723b6549240919ca0c48ba2605b">_notclose</a> (fs, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a>, atol=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a>)</td></tr>
<tr class="memdesc:a624b3723b6549240919ca0c48ba2605b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TOMS "Algorithm 748: Enclosing Zeros of Continuous Functions", by Alefeld, G.  <br /></td></tr>
<tr class="separator:a624b3723b6549240919ca0c48ba2605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceb913cf0d9139944a688b40f06be50" id="r_a4ceb913cf0d9139944a688b40f06be50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a4ceb913cf0d9139944a688b40f06be50">_secant</a> (xvals, fvals)</td></tr>
<tr class="separator:a4ceb913cf0d9139944a688b40f06be50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19a3ffa91c232ae3807d37fe5629855" id="r_af19a3ffa91c232ae3807d37fe5629855"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#af19a3ffa91c232ae3807d37fe5629855">_update_bracket</a> (<a class="el" href="__lapack__subroutines_8h.html#ac5085aa45a46dc3bb6b493f94e6c91f4">ab</a>, fab, c, fc)</td></tr>
<tr class="separator:af19a3ffa91c232ae3807d37fe5629855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aa25d3c0b08e83de24ede212ac55a9" id="r_af8aa25d3c0b08e83de24ede212ac55a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#af8aa25d3c0b08e83de24ede212ac55a9">_compute_divided_differences</a> (xvals, fvals, N=None, full=True, forward=True)</td></tr>
<tr class="separator:af8aa25d3c0b08e83de24ede212ac55a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4a7be3de6d8012d9eab76f941da21" id="r_a2fb4a7be3de6d8012d9eab76f941da21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a2fb4a7be3de6d8012d9eab76f941da21">_interpolated_poly</a> (xvals, fvals, <a class="el" href="namespacescipy_1_1optimize_1_1__nonlin.html#a9f63beec99dbf869db2b02f71b2dd31e">x</a>)</td></tr>
<tr class="separator:a2fb4a7be3de6d8012d9eab76f941da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4170f46e79e01e260f5a249adc29ac5a" id="r_a4170f46e79e01e260f5a249adc29ac5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a4170f46e79e01e260f5a249adc29ac5a">_inverse_poly_zero</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, c, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>, fa, fb, fc, fd)</td></tr>
<tr class="separator:a4170f46e79e01e260f5a249adc29ac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38db354308b7ebbb332753e4c89400a5" id="r_a38db354308b7ebbb332753e4c89400a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a38db354308b7ebbb332753e4c89400a5">_newton_quadratic</a> (<a class="el" href="__lapack__subroutines_8h.html#ac5085aa45a46dc3bb6b493f94e6c91f4">ab</a>, fab, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>, fd, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:a38db354308b7ebbb332753e4c89400a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5004a1b9230e65d0ae385379d1cf1ed" id="r_ae5004a1b9230e65d0ae385379d1cf1ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ae5004a1b9230e65d0ae385379d1cf1ed">toms748</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, args=(), <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>=1, xtol=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a>, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a>, maxiter=<a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a>, full_output=False, disp=True)</td></tr>
<tr class="separator:ae5004a1b9230e65d0ae385379d1cf1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab4b892c756bdbbd1cbc39f27d92df5c2" id="r_ab4b892c756bdbbd1cbc39f27d92df5c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a> = 100</td></tr>
<tr class="separator:ab4b892c756bdbbd1cbc39f27d92df5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7eb0e42203b1c6c4b40521ec16bea9" id="r_afd7eb0e42203b1c6c4b40521ec16bea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a> = 2e-12</td></tr>
<tr class="separator:afd7eb0e42203b1c6c4b40521ec16bea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9dbe7fa007420b1d111c3329e3b89a" id="r_a9d9dbe7fa007420b1d111c3329e3b89a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a> = 4 * np.finfo(float).<a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a></td></tr>
<tr class="separator:a9d9dbe7fa007420b1d111c3329e3b89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bcdd971836677ee38d2d86f050888b" id="r_af4bcdd971836677ee38d2d86f050888b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#af4bcdd971836677ee38d2d86f050888b">_ECONVERGED</a> = 0</td></tr>
<tr class="separator:af4bcdd971836677ee38d2d86f050888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0238c88b7478ae9555103137c3275405" id="r_a0238c88b7478ae9555103137c3275405"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a0238c88b7478ae9555103137c3275405">_ESIGNERR</a> = -1</td></tr>
<tr class="separator:a0238c88b7478ae9555103137c3275405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774fd1666eaace48a1e96b5cb57ad8be" id="r_a774fd1666eaace48a1e96b5cb57ad8be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a774fd1666eaace48a1e96b5cb57ad8be">_ECONVERR</a> = -2</td></tr>
<tr class="separator:a774fd1666eaace48a1e96b5cb57ad8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd7b77302c86b135a86e9ecf6dc96ee" id="r_a9dd7b77302c86b135a86e9ecf6dc96ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9dd7b77302c86b135a86e9ecf6dc96ee">_EVALUEERR</a> = -3</td></tr>
<tr class="separator:a9dd7b77302c86b135a86e9ecf6dc96ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510c7861992d3edabbc67eb63bab3025" id="r_a510c7861992d3edabbc67eb63bab3025"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a510c7861992d3edabbc67eb63bab3025">_EINPROGRESS</a> = 1</td></tr>
<tr class="separator:a510c7861992d3edabbc67eb63bab3025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789cf251f5f3f8dda6d1572a32a2d100" id="r_a789cf251f5f3f8dda6d1572a32a2d100"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a789cf251f5f3f8dda6d1572a32a2d100">CONVERGED</a> = 'converged'</td></tr>
<tr class="separator:a789cf251f5f3f8dda6d1572a32a2d100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b07357c3683e74fc4b96789a269db62" id="r_a5b07357c3683e74fc4b96789a269db62"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a5b07357c3683e74fc4b96789a269db62">SIGNERR</a> = 'sign <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td></tr>
<tr class="separator:a5b07357c3683e74fc4b96789a269db62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce602a6739ba11af2e141dc0c2ba91" id="r_a13ce602a6739ba11af2e141dc0c2ba91"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a13ce602a6739ba11af2e141dc0c2ba91">CONVERR</a> = 'convergence <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td></tr>
<tr class="separator:a13ce602a6739ba11af2e141dc0c2ba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed4a7ba25901d7400ec1b2872815dac" id="r_abed4a7ba25901d7400ec1b2872815dac"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#abed4a7ba25901d7400ec1b2872815dac">VALUEERR</a> = 'value <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td></tr>
<tr class="separator:abed4a7ba25901d7400ec1b2872815dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8381cb99a373fe3c6579e004730edb03" id="r_a8381cb99a373fe3c6579e004730edb03"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a8381cb99a373fe3c6579e004730edb03">INPROGRESS</a> = 'No <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td></tr>
<tr class="separator:a8381cb99a373fe3c6579e004730edb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7947d48cdb026201f385bde32e43b21" id="r_af7947d48cdb026201f385bde32e43b21"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#af7947d48cdb026201f385bde32e43b21">flag_map</a></td></tr>
<tr class="separator:af7947d48cdb026201f385bde32e43b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a816f02f91e30ce5256d47c82a773c0da" name="a816f02f91e30ce5256d47c82a773c0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816f02f91e30ce5256d47c82a773c0da">&#9670;&#160;</a></span>_array_newton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._array_newton </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fprime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fprime2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A vectorized version of Newton, Halley, and secant methods for arrays.

Do not use this method directly. This method is called from `newton`
when ``np.size(x0) &gt; 1`` is ``True``. For docstring, see `newton`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  373</span><span class="keyword">def </span>_array_newton(func, x0, fprime, args, tol, maxiter, fprime2, full_output):</div>
<div class="line"><span class="lineno">  374</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    A vectorized version of Newton, Halley, and secant methods for arrays.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    Do not use this method directly. This method is called from `newton`</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    when ``np.size(x0) &gt; 1`` is ``True``. For docstring, see `newton`.</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  380</span>    <span class="comment"># Explicitly copy `x0` as `p` will be modified inplace, but the</span></div>
<div class="line"><span class="lineno">  381</span>    <span class="comment"># user&#39;s array should not be altered.</span></div>
<div class="line"><span class="lineno">  382</span>    p = np.array(x0, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  383</span> </div>
<div class="line"><span class="lineno">  384</span>    failures = np.ones_like(p, dtype=bool)</div>
<div class="line"><span class="lineno">  385</span>    nz_der = np.ones_like(failures)</div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">if</span> fprime <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  387</span>        <span class="comment"># Newton-Raphson method</span></div>
<div class="line"><span class="lineno">  388</span>        <span class="keywordflow">for</span> iteration <span class="keywordflow">in</span> range(maxiter):</div>
<div class="line"><span class="lineno">  389</span>            <span class="comment"># first evaluate fval</span></div>
<div class="line"><span class="lineno">  390</span>            fval = np.asarray(<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p, *args))</div>
<div class="line"><span class="lineno">  391</span>            <span class="comment"># If all fval are 0, all roots have been found, then terminate</span></div>
<div class="line"><span class="lineno">  392</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> fval.any():</div>
<div class="line"><span class="lineno">  393</span>                failures = fval.astype(bool)</div>
<div class="line"><span class="lineno">  394</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  395</span>            fder = np.asarray(fprime(p, *args))</div>
<div class="line"><span class="lineno">  396</span>            nz_der = (fder != 0)</div>
<div class="line"><span class="lineno">  397</span>            <span class="comment"># stop iterating if all derivatives are zero</span></div>
<div class="line"><span class="lineno">  398</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> nz_der.any():</div>
<div class="line"><span class="lineno">  399</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  400</span>            <span class="comment"># Newton step</span></div>
<div class="line"><span class="lineno">  401</span>            dp = fval[nz_der] / fder[nz_der]</div>
<div class="line"><span class="lineno">  402</span>            <span class="keywordflow">if</span> fprime2 <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  403</span>                fder2 = np.asarray(fprime2(p, *args))</div>
<div class="line"><span class="lineno">  404</span>                dp = dp / (1.0 - 0.5 * dp * fder2[nz_der] / fder[nz_der])</div>
<div class="line"><span class="lineno">  405</span>            <span class="comment"># only update nonzero derivatives</span></div>
<div class="line"><span class="lineno">  406</span>            p = np.asarray(p, dtype=np.result_type(p, dp, np.float64))</div>
<div class="line"><span class="lineno">  407</span>            p[nz_der] -= dp</div>
<div class="line"><span class="lineno">  408</span>            failures[nz_der] = np.abs(dp) &gt;= tol  <span class="comment"># items not yet converged</span></div>
<div class="line"><span class="lineno">  409</span>            <span class="comment"># stop iterating if there aren&#39;t any failures, not incl zero der</span></div>
<div class="line"><span class="lineno">  410</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> failures[nz_der].any():</div>
<div class="line"><span class="lineno">  411</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  412</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  413</span>        <span class="comment"># Secant method</span></div>
<div class="line"><span class="lineno">  414</span>        dx = np.finfo(float).eps**0.33</div>
<div class="line"><span class="lineno">  415</span>        p1 = p * (1 + dx) + np.where(p &gt;= 0, dx, -dx)</div>
<div class="line"><span class="lineno">  416</span>        q0 = np.asarray(<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p, *args))</div>
<div class="line"><span class="lineno">  417</span>        q1 = np.asarray(<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p1, *args))</div>
<div class="line"><span class="lineno">  418</span>        active = np.ones_like(p, dtype=bool)</div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">for</span> iteration <span class="keywordflow">in</span> range(maxiter):</div>
<div class="line"><span class="lineno">  420</span>            nz_der = (q1 != q0)</div>
<div class="line"><span class="lineno">  421</span>            <span class="comment"># stop iterating if all derivatives are zero</span></div>
<div class="line"><span class="lineno">  422</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> nz_der.any():</div>
<div class="line"><span class="lineno">  423</span>                p = (p1 + p) / 2.0</div>
<div class="line"><span class="lineno">  424</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  425</span>            <span class="comment"># Secant Step</span></div>
<div class="line"><span class="lineno">  426</span>            dp = (q1 * (p1 - p))[nz_der] / (q1 - q0)[nz_der]</div>
<div class="line"><span class="lineno">  427</span>            <span class="comment"># only update nonzero derivatives</span></div>
<div class="line"><span class="lineno">  428</span>            p = np.asarray(p, dtype=np.result_type(p, p1, dp, np.float64))</div>
<div class="line"><span class="lineno">  429</span>            p[nz_der] = p1[nz_der] - dp</div>
<div class="line"><span class="lineno">  430</span>            active_zero_der = ~nz_der &amp; active</div>
<div class="line"><span class="lineno">  431</span>            p[active_zero_der] = (p1 + p)[active_zero_der] / 2.0</div>
<div class="line"><span class="lineno">  432</span>            active &amp;= nz_der  <span class="comment"># don&#39;t assign zero derivatives again</span></div>
<div class="line"><span class="lineno">  433</span>            failures[nz_der] = np.abs(dp) &gt;= tol  <span class="comment"># not yet converged</span></div>
<div class="line"><span class="lineno">  434</span>            <span class="comment"># stop iterating if there aren&#39;t any failures, not incl zero der</span></div>
<div class="line"><span class="lineno">  435</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> failures[nz_der].any():</div>
<div class="line"><span class="lineno">  436</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  437</span>            p1, p = p, p1</div>
<div class="line"><span class="lineno">  438</span>            q0 = q1</div>
<div class="line"><span class="lineno">  439</span>            q1 = np.asarray(<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p1, *args))</div>
<div class="line"><span class="lineno">  440</span> </div>
<div class="line"><span class="lineno">  441</span>    zero_der = ~nz_der &amp; failures  <span class="comment"># don&#39;t include converged with zero-ders</span></div>
<div class="line"><span class="lineno">  442</span>    <span class="keywordflow">if</span> zero_der.any():</div>
<div class="line"><span class="lineno">  443</span>        <span class="comment"># Secant warnings</span></div>
<div class="line"><span class="lineno">  444</span>        <span class="keywordflow">if</span> fprime <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  445</span>            nonzero_dp = (p1 != p)</div>
<div class="line"><span class="lineno">  446</span>            <span class="comment"># non-zero dp, but infinite newton step</span></div>
<div class="line"><span class="lineno">  447</span>            zero_der_nz_dp = (zero_der &amp; nonzero_dp)</div>
<div class="line"><span class="lineno">  448</span>            <span class="keywordflow">if</span> zero_der_nz_dp.any():</div>
<div class="line"><span class="lineno">  449</span>                rms = np.sqrt(</div>
<div class="line"><span class="lineno">  450</span>                    sum((p1[zero_der_nz_dp] - p[zero_der_nz_dp]) ** 2)</div>
<div class="line"><span class="lineno">  451</span>                )</div>
<div class="line"><span class="lineno">  452</span>                warnings.warn(</div>
<div class="line"><span class="lineno">  453</span>                    <span class="stringliteral">&#39;RMS of {:g} reached&#39;</span>.format(rms), RuntimeWarning)</div>
<div class="line"><span class="lineno">  454</span>        <span class="comment"># Newton or Halley warnings</span></div>
<div class="line"><span class="lineno">  455</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  456</span>            all_or_some = <span class="stringliteral">&#39;all&#39;</span> <span class="keywordflow">if</span> zero_der.all() <span class="keywordflow">else</span> <span class="stringliteral">&#39;some&#39;</span></div>
<div class="line"><span class="lineno">  457</span>            msg = <span class="stringliteral">&#39;{:s} derivatives were zero&#39;</span>.format(all_or_some)</div>
<div class="line"><span class="lineno">  458</span>            warnings.warn(msg, RuntimeWarning)</div>
<div class="line"><span class="lineno">  459</span>    <span class="keywordflow">elif</span> failures.any():</div>
<div class="line"><span class="lineno">  460</span>        all_or_some = <span class="stringliteral">&#39;all&#39;</span> <span class="keywordflow">if</span> failures.all() <span class="keywordflow">else</span> <span class="stringliteral">&#39;some&#39;</span></div>
<div class="line"><span class="lineno">  461</span>        msg = <span class="stringliteral">&#39;{0:s} failed to converge after {1:d} iterations&#39;</span>.format(</div>
<div class="line"><span class="lineno">  462</span>            all_or_some, maxiter</div>
<div class="line"><span class="lineno">  463</span>        )</div>
<div class="line"><span class="lineno">  464</span>        <span class="keywordflow">if</span> failures.all():</div>
<div class="line"><span class="lineno">  465</span>            <span class="keywordflow">raise</span> RuntimeError(msg)</div>
<div class="line"><span class="lineno">  466</span>        warnings.warn(msg, RuntimeWarning)</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>    <span class="keywordflow">if</span> full_output:</div>
<div class="line"><span class="lineno">  469</span>        result = namedtuple(<span class="stringliteral">&#39;result&#39;</span>, (<span class="stringliteral">&#39;root&#39;</span>, <span class="stringliteral">&#39;converged&#39;</span>, <span class="stringliteral">&#39;zero_der&#39;</span>))</div>
<div class="line"><span class="lineno">  470</span>        p = result(p, ~failures, zero_der)</div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>    <span class="keywordflow">return</span> p</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af8aa25d3c0b08e83de24ede212ac55a9" name="af8aa25d3c0b08e83de24ede212ac55a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8aa25d3c0b08e83de24ede212ac55a9">&#9670;&#160;</a></span>_compute_divided_differences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._compute_divided_differences </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>forward</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a matrix of divided differences for the xvals, fvals pairs

DD[i, j] = f[x_{i-j}, ..., x_i] for 0 &lt;= j &lt;= i

If full is False, just return the main diagonal(or last row):
  f[a], f[a, b] and f[a, b, c].
If forward is False, return f[c], f[b, c], f[a, b, c].</pre> <div class="fragment"><div class="line"><span class="lineno">  942</span>                                 forward=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  943</span>    <span class="stringliteral">&quot;&quot;&quot;Return a matrix of divided differences for the xvals, fvals pairs</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    DD[i, j] = f[x_{i-j}, ..., x_i] for 0 &lt;= j &lt;= i</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    If full is False, just return the main diagonal(or last row):</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">      f[a], f[a, b] and f[a, b, c].</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">    If forward is False, return f[c], f[b, c], f[a, b, c].&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  950</span>    <span class="keywordflow">if</span> full:</div>
<div class="line"><span class="lineno">  951</span>        <span class="keywordflow">if</span> forward:</div>
<div class="line"><span class="lineno">  952</span>            xvals = np.asarray(xvals)</div>
<div class="line"><span class="lineno">  953</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  954</span>            xvals = np.array(xvals)[::-1]</div>
<div class="line"><span class="lineno">  955</span>        M = len(xvals)</div>
<div class="line"><span class="lineno">  956</span>        N = M <span class="keywordflow">if</span> N <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> min(N, M)</div>
<div class="line"><span class="lineno">  957</span>        DD = np.zeros([M, N])</div>
<div class="line"><span class="lineno">  958</span>        DD[:, 0] = fvals[:]</div>
<div class="line"><span class="lineno">  959</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, N):</div>
<div class="line"><span class="lineno">  960</span>            DD[i:, i] = (np.diff(DD[i - 1:, i - 1]) /</div>
<div class="line"><span class="lineno">  961</span>                         (xvals[i:] - xvals[:M - i]))</div>
<div class="line"><span class="lineno">  962</span>        <span class="keywordflow">return</span> DD</div>
<div class="line"><span class="lineno">  963</span> </div>
<div class="line"><span class="lineno">  964</span>    xvals = np.asarray(xvals)</div>
<div class="line"><span class="lineno">  965</span>    dd = np.array(fvals)</div>
<div class="line"><span class="lineno">  966</span>    row = np.array(fvals)</div>
<div class="line"><span class="lineno">  967</span>    idx2Use = (0 <span class="keywordflow">if</span> forward <span class="keywordflow">else</span> -1)</div>
<div class="line"><span class="lineno">  968</span>    dd[0] = fvals[idx2Use]</div>
<div class="line"><span class="lineno">  969</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, len(xvals)):</div>
<div class="line"><span class="lineno">  970</span>        denom = xvals[i:i + len(row) - 1] - xvals[:len(row) - 1]</div>
<div class="line"><span class="lineno">  971</span>        row = np.diff(row)[:] / denom</div>
<div class="line"><span class="lineno">  972</span>        dd[i] = row[idx2Use]</div>
<div class="line"><span class="lineno">  973</span>    <span class="keywordflow">return</span> dd</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fb4a7be3de6d8012d9eab76f941da21" name="a2fb4a7be3de6d8012d9eab76f941da21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb4a7be3de6d8012d9eab76f941da21">&#9670;&#160;</a></span>_interpolated_poly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._interpolated_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute p(x) for the polynomial passing through the specified locations.

Use Neville's algorithm to compute p(x) where p is the minimal degree
polynomial passing through the points xvals, fvals</pre> <div class="fragment"><div class="line"><span class="lineno">  976</span><span class="keyword">def </span>_interpolated_poly(xvals, fvals, x):</div>
<div class="line"><span class="lineno">  977</span>    <span class="stringliteral">&quot;&quot;&quot;Compute p(x) for the polynomial passing through the specified locations.</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    Use Neville&#39;s algorithm to compute p(x) where p is the minimal degree</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    polynomial passing through the points xvals, fvals&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  981</span>    xvals = np.asarray(xvals)</div>
<div class="line"><span class="lineno">  982</span>    N = len(xvals)</div>
<div class="line"><span class="lineno">  983</span>    Q = np.zeros([N, N])</div>
<div class="line"><span class="lineno">  984</span>    D = np.zeros([N, N])</div>
<div class="line"><span class="lineno">  985</span>    Q[:, 0] = fvals[:]</div>
<div class="line"><span class="lineno">  986</span>    D[:, 0] = fvals[:]</div>
<div class="line"><span class="lineno">  987</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(1, N):</div>
<div class="line"><span class="lineno">  988</span>        alpha = D[k:, k - 1] - Q[k - 1:N - 1, k - 1]</div>
<div class="line"><span class="lineno">  989</span>        diffik = xvals[0:N - k] - xvals[k:N]</div>
<div class="line"><span class="lineno">  990</span>        Q[k:, k] = (xvals[k:] - x) / diffik * alpha</div>
<div class="line"><span class="lineno">  991</span>        D[k:, k] = (xvals[:N - k] - x) / diffik * alpha</div>
<div class="line"><span class="lineno">  992</span>    <span class="comment"># Expect Q[-1, 1:] to be small relative to Q[-1, 0] as x approaches a root</span></div>
<div class="line"><span class="lineno">  993</span>    <span class="keywordflow">return</span> np.sum(Q[-1, 1:]) + Q[-1, 0]</div>
<div class="line"><span class="lineno">  994</span> </div>
<div class="line"><span class="lineno">  995</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4170f46e79e01e260f5a249adc29ac5a" name="a4170f46e79e01e260f5a249adc29ac5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4170f46e79e01e260f5a249adc29ac5a">&#9670;&#160;</a></span>_inverse_poly_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._inverse_poly_zero </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Inverse cubic interpolation f-values -&gt; x-values

Given four points (fa, a), (fb, b), (fc, c), (fd, d) with
fa, fb, fc, fd all distinct, find poly IP(y) through the 4 points
and compute x=IP(0).
</pre> <div class="fragment"><div class="line"><span class="lineno">  996</span><span class="keyword">def </span>_inverse_poly_zero(a, b, c, d, fa, fb, fc, fd):</div>
<div class="line"><span class="lineno">  997</span>    <span class="stringliteral">&quot;&quot;&quot;Inverse cubic interpolation f-values -&gt; x-values</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    Given four points (fa, a), (fb, b), (fc, c), (fd, d) with</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    fa, fb, fc, fd all distinct, find poly IP(y) through the 4 points</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    and compute x=IP(0).</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1003</span>    <span class="keywordflow">return</span> _interpolated_poly([fa, fb, fc, fd], [a, b, c, d], 0)</div>
<div class="line"><span class="lineno"> 1004</span> </div>
<div class="line"><span class="lineno"> 1005</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a38db354308b7ebbb332753e4c89400a5" name="a38db354308b7ebbb332753e4c89400a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38db354308b7ebbb332753e4c89400a5">&#9670;&#160;</a></span>_newton_quadratic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._newton_quadratic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Apply Newton-Raphson like steps, using divided differences to approximate f'

ab is a real interval [a, b] containing a root,
fab holds the real values of f(a), f(b)
d is a real number outside [ab, b]
k is the number of steps to apply
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1006</span><span class="keyword">def </span>_newton_quadratic(ab, fab, d, fd, k):</div>
<div class="line"><span class="lineno"> 1007</span>    <span class="stringliteral">&quot;&quot;&quot;Apply Newton-Raphson like steps, using divided differences to approximate f&#39;</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    ab is a real interval [a, b] containing a root,</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    fab holds the real values of f(a), f(b)</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    d is a real number outside [ab, b]</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    k is the number of steps to apply</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1014</span>    a, b = ab</div>
<div class="line"><span class="lineno"> 1015</span>    fa, fb = fab</div>
<div class="line"><span class="lineno"> 1016</span>    _, B, A = _compute_divided_differences([a, b, d], [fa, fb, fd],</div>
<div class="line"><span class="lineno"> 1017</span>                                           forward=<span class="keyword">True</span>, full=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1018</span> </div>
<div class="line"><span class="lineno"> 1019</span>    <span class="comment"># _P  is the quadratic polynomial through the 3 points</span></div>
<div class="line"><span class="lineno"> 1020</span>    <span class="keyword">def </span>_P(x):</div>
<div class="line"><span class="lineno"> 1021</span>        <span class="comment"># Horner evaluation of fa + B * (x - a) + A * (x - a) * (x - b)</span></div>
<div class="line"><span class="lineno"> 1022</span>        <span class="keywordflow">return</span> (A * (x - b) + B) * (x - a) + fa</div>
<div class="line"><span class="lineno"> 1023</span> </div>
<div class="line"><span class="lineno"> 1024</span>    <span class="keywordflow">if</span> A == 0:</div>
<div class="line"><span class="lineno"> 1025</span>        r = a - fa / B</div>
<div class="line"><span class="lineno"> 1026</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1027</span>        r = (a <span class="keywordflow">if</span> np.sign(A) * np.sign(fa) &gt; 0 <span class="keywordflow">else</span> b)</div>
<div class="line"><span class="lineno"> 1028</span>    <span class="comment"># Apply k Newton-Raphson steps to _P(x), starting from x=r</span></div>
<div class="line"><span class="lineno"> 1029</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 1030</span>        r1 = r - _P(r) / (B + A * (2 * r - a - b))</div>
<div class="line"><span class="lineno"> 1031</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (ab[0] &lt; r1 &lt; ab[1]):</div>
<div class="line"><span class="lineno"> 1032</span>            <span class="keywordflow">if</span> (ab[0] &lt; r &lt; ab[1]):</div>
<div class="line"><span class="lineno"> 1033</span>                <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno"> 1034</span>            r = sum(ab) / 2.0</div>
<div class="line"><span class="lineno"> 1035</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1036</span>        r = r1</div>
<div class="line"><span class="lineno"> 1037</span> </div>
<div class="line"><span class="lineno"> 1038</span>    <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno"> 1039</span> </div>
<div class="line"><span class="lineno"> 1040</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a624b3723b6549240919ca0c48ba2605b" name="a624b3723b6549240919ca0c48ba2605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624b3723b6549240919ca0c48ba2605b">&#9670;&#160;</a></span>_notclose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._notclose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TOMS "Algorithm 748: Enclosing Zeros of Continuous Functions", by Alefeld, G. </p>
<p>E. and Potra, F. A. and Shi, Yixun, See [1] </p>
<div class="fragment"><div class="line"><span class="lineno">  903</span><span class="keyword">def </span>_notclose(fs, rtol=_rtol, atol=_xtol):</div>
<div class="line"><span class="lineno">  904</span>    <span class="comment"># Ensure not None, not 0, all finite, and not very close to each other</span></div>
<div class="line"><span class="lineno">  905</span>    notclosefvals = (</div>
<div class="line"><span class="lineno">  906</span>            all(fs) <span class="keywordflow">and</span> all(np.isfinite(fs)) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  907</span>            <span class="keywordflow">not</span> any(any(np.isclose(_f, fs[i + 1:], rtol=rtol, atol=atol))</div>
<div class="line"><span class="lineno">  908</span>                    <span class="keywordflow">for</span> i, _f <span class="keywordflow">in</span> enumerate(fs[:-1])))</div>
<div class="line"><span class="lineno">  909</span>    <span class="keywordflow">return</span> notclosefvals</div>
<div class="line"><span class="lineno">  910</span> </div>
<div class="line"><span class="lineno">  911</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa689dbe6d59afcdcfbd13ead0be02055" name="aa689dbe6d59afcdcfbd13ead0be02055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa689dbe6d59afcdcfbd13ead0be02055">&#9670;&#160;</a></span>_results_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._results_select </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Select from a tuple of (root, funccalls, iterations, flag)</pre> <div class="fragment"><div class="line"><span class="lineno">   82</span><span class="keyword">def </span>_results_select(full_output, r):</div>
<div class="line"><span class="lineno">   83</span>    <span class="stringliteral">&quot;&quot;&quot;Select from a tuple of (root, funccalls, iterations, flag)&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   84</span>    x, funcalls, iterations, flag = r</div>
<div class="line"><span class="lineno">   85</span>    <span class="keywordflow">if</span> full_output:</div>
<div class="line"><span class="lineno">   86</span>        results = RootResults(root=x,</div>
<div class="line"><span class="lineno">   87</span>                              iterations=iterations,</div>
<div class="line"><span class="lineno">   88</span>                              function_calls=funcalls,</div>
<div class="line"><span class="lineno">   89</span>                              flag=flag)</div>
<div class="line"><span class="lineno">   90</span>        <span class="keywordflow">return</span> x, results</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">   92</span> </div>
<div class="line"><span class="lineno">   93</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ceb913cf0d9139944a688b40f06be50" name="a4ceb913cf0d9139944a688b40f06be50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceb913cf0d9139944a688b40f06be50">&#9670;&#160;</a></span>_secant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._secant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fvals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Perform a secant step, taking a little care</pre> <div class="fragment"><div class="line"><span class="lineno">  912</span><span class="keyword">def </span>_secant(xvals, fvals):</div>
<div class="line"><span class="lineno">  913</span>    <span class="stringliteral">&quot;&quot;&quot;Perform a secant step, taking a little care&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  914</span>    <span class="comment"># Secant has many &quot;mathematically&quot; equivalent formulations</span></div>
<div class="line"><span class="lineno">  915</span>    <span class="comment"># x2 = x0 - (x1 - x0)/(f1 - f0) * f0</span></div>
<div class="line"><span class="lineno">  916</span>    <span class="comment">#    = x1 - (x1 - x0)/(f1 - f0) * f1</span></div>
<div class="line"><span class="lineno">  917</span>    <span class="comment">#    = (-x1 * f0 + x0 * f1) / (f1 - f0)</span></div>
<div class="line"><span class="lineno">  918</span>    <span class="comment">#    = (-f0 / f1 * x1 + x0) / (1 - f0 / f1)</span></div>
<div class="line"><span class="lineno">  919</span>    <span class="comment">#    = (-f1 / f0 * x0 + x1) / (1 - f1 / f0)</span></div>
<div class="line"><span class="lineno">  920</span>    x0, x1 = xvals[:2]</div>
<div class="line"><span class="lineno">  921</span>    f0, f1 = fvals[:2]</div>
<div class="line"><span class="lineno">  922</span>    <span class="keywordflow">if</span> f0 == f1:</div>
<div class="line"><span class="lineno">  923</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno">  924</span>    <span class="keywordflow">if</span> np.abs(f1) &gt; np.abs(f0):</div>
<div class="line"><span class="lineno">  925</span>        x2 = (-f0 / f1 * x1 + x0) / (1 - f0 / f1)</div>
<div class="line"><span class="lineno">  926</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  927</span>        x2 = (-f1 / f0 * x0 + x1) / (1 - f1 / f0)</div>
<div class="line"><span class="lineno">  928</span>    <span class="keywordflow">return</span> x2</div>
<div class="line"><span class="lineno">  929</span> </div>
<div class="line"><span class="lineno">  930</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af19a3ffa91c232ae3807d37fe5629855" name="af19a3ffa91c232ae3807d37fe5629855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19a3ffa91c232ae3807d37fe5629855">&#9670;&#160;</a></span>_update_bracket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py._update_bracket </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Update a bracket given (c, fc), return the discarded endpoints.</pre> <div class="fragment"><div class="line"><span class="lineno">  931</span><span class="keyword">def </span>_update_bracket(ab, fab, c, fc):</div>
<div class="line"><span class="lineno">  932</span>    <span class="stringliteral">&quot;&quot;&quot;Update a bracket given (c, fc), return the discarded endpoints.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  933</span>    fa, fb = fab</div>
<div class="line"><span class="lineno">  934</span>    idx = (0 <span class="keywordflow">if</span> np.sign(fa) * np.sign(fc) &gt; 0 <span class="keywordflow">else</span> 1)</div>
<div class="line"><span class="lineno">  935</span>    rx, rfx = ab[idx], fab[idx]</div>
<div class="line"><span class="lineno">  936</span>    fab[idx] = fc</div>
<div class="line"><span class="lineno">  937</span>    ab[idx] = c</div>
<div class="line"><span class="lineno">  938</span>    <span class="keywordflow">return</span> rx, rfx</div>
<div class="line"><span class="lineno">  939</span> </div>
<div class="line"><span class="lineno">  940</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2ca5c9782c2ff22c2f5b8ea9081d190" name="ac2ca5c9782c2ff22c2f5b8ea9081d190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ca5c9782c2ff22c2f5b8ea9081d190">&#9670;&#160;</a></span>bisect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py.bisect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find root of a function within an interval using bisection.

Basic bisection routine to find a zero of the function `f` between the
arguments `a` and `b`. `f(a)` and `f(b)` cannot have the same signs.
Slow but sure.

Parameters
----------
f : function
    Python function returning a number.  `f` must be continuous, and
    f(a) and f(b) must have opposite signs.
a : scalar
    One end of the bracketing interval [a,b].
b : scalar
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be nonnegative.
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be &gt;= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where x is the root, and r is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in a `RootResults`
    return object.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

Examples
--------

&gt;&gt;&gt; def f(x):
...     return (x**2 - 1)

&gt;&gt;&gt; from scipy import optimize

&gt;&gt;&gt; root = optimize.bisect(f, 0, 2)
&gt;&gt;&gt; root
1.0

&gt;&gt;&gt; root = optimize.bisect(f, -2, 0)
&gt;&gt;&gt; root
-1.0

See Also
--------
brentq, brenth, bisect, newton
fixed_point : scalar fixed-point finder
fsolve : n-dimensional root-finding</pre> <div class="fragment"><div class="line"><span class="lineno">  477</span>           full_output=<span class="keyword">False</span>, disp=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  478</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    Find root of a function within an interval using bisection.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    Basic bisection routine to find a zero of the function `f` between the</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    arguments `a` and `b`. `f(a)` and `f(b)` cannot have the same signs.</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    Slow but sure.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    f : function</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        Python function returning a number.  `f` must be continuous, and</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        f(a) and f(b) must have opposite signs.</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    a : scalar</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        One end of the bracketing interval [a,b].</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    b : scalar</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        The other end of the bracketing interval [a,b].</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    xtol : number, optional</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">        parameter must be nonnegative.</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    rtol : number, optional</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        parameter cannot be smaller than its default value of</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        ``4*np.finfo(float).eps``.</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        If convergence is not achieved in `maxiter` iterations, an error is</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        raised. Must be &gt;= 0.</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        Containing extra arguments for the function `f`.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        `f` is called by ``apply(f, (x)+args)``.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    full_output : bool, optional</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        If `full_output` is False, the root is returned. If `full_output` is</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        True, the return value is ``(x, r)``, where x is the root, and r is</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        a `RootResults` object.</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        If True, raise RuntimeError if the algorithm didn&#39;t converge.</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        Otherwise, the convergence status is recorded in a `RootResults`</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        return object.</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    x0 : float</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        Zero of `f` between `a` and `b`.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    r : `RootResults` (present if ``full_output = True``)</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        Object containing information about the convergence. In particular,</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        ``r.converged`` is True if the routine converged.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    ...     return (x**2 - 1)</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import optimize</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.bisect(f, 0, 2)</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.bisect(f, -2, 0)</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    -1.0</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    brentq, brenth, bisect, newton</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    fixed_point : scalar fixed-point finder</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    fsolve : n-dimensional root-finding</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  549</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(args, tuple):</div>
<div class="line"><span class="lineno">  550</span>        args = (args,)</div>
<div class="line"><span class="lineno">  551</span>    maxiter = operator.index(maxiter)</div>
<div class="line"><span class="lineno">  552</span>    <span class="keywordflow">if</span> xtol &lt;= 0:</div>
<div class="line"><span class="lineno">  553</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;xtol too small (%g &lt;= 0)&quot;</span> % xtol)</div>
<div class="line"><span class="lineno">  554</span>    <span class="keywordflow">if</span> rtol &lt; _rtol:</div>
<div class="line"><span class="lineno">  555</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;rtol too small (%g &lt; %g)&quot;</span> % (rtol, _rtol))</div>
<div class="line"><span class="lineno">  556</span>    r = _zeros._bisect(f, a, b, xtol, rtol, maxiter, args, full_output, disp)</div>
<div class="line"><span class="lineno">  557</span>    <span class="keywordflow">return</span> results_c(full_output, r)</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b5639636c7d4e83b35a9226e6f0ac26" name="a2b5639636c7d4e83b35a9226e6f0ac26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5639636c7d4e83b35a9226e6f0ac26">&#9670;&#160;</a></span>brenth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py.brenth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a root of a function in a bracketing interval using Brent's
method with hyperbolic extrapolation.

A variation on the classic Brent routine to find a zero of the function f
between the arguments a and b that uses hyperbolic extrapolation instead of
inverse quadratic extrapolation. Bus &amp; Dekker (1975) guarantee convergence
for this method, claiming that the upper bound of function evaluations here
is 4 or 5 times lesser than that for bisection.
f(a) and f(b) cannot have the same signs. Generally, on a par with the
brent routine, but not as heavily tested. It is a safe version of the
secant method that uses hyperbolic extrapolation.
The version here is by Chuck Harris, and implements Algorithm M of
[BusAndDekker1975]_, where further details (convergence properties,
additional remarks and such) can be found

Parameters
----------
f : function
    Python function returning a number. f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : scalar
    One end of the bracketing interval [a,b].
b : scalar
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be nonnegative. As with `brentq`, for nice
    functions the method will often satisfy the above condition
    with ``xtol/2`` and ``rtol/2``.
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``. As with `brentq`, for nice functions
    the method will often satisfy the above condition with
    ``xtol/2`` and ``rtol/2``.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be &gt;= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in any `RootResults`
    return object.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
fmin, fmin_powell, fmin_cg, fmin_bfgs, fmin_ncg : multivariate local optimizers
leastsq : nonlinear least squares minimizer
fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers
basinhopping, differential_evolution, brute : global optimizers
fminbound, brent, golden, bracket : local scalar minimizers
fsolve : N-D root-finding
brentq, brenth, ridder, bisect, newton : 1-D root-finding
fixed_point : scalar fixed-point finder

References
----------
.. [BusAndDekker1975]
   Bus, J. C. P., Dekker, T. J.,
   "Two Efficient Algorithms with Guaranteed Convergence for Finding a Zero
   of a Function", ACM Transactions on Mathematical Software, Vol. 1, Issue
   4, Dec. 1975, pp. 330-345. Section 3: "Algorithm M".
   :doi:`10.1145/355656.355659`

Examples
--------
&gt;&gt;&gt; def f(x):
...     return (x**2 - 1)

&gt;&gt;&gt; from scipy import optimize

&gt;&gt;&gt; root = optimize.brenth(f, -2, 0)
&gt;&gt;&gt; root
-1.0

&gt;&gt;&gt; root = optimize.brenth(f, 0, 2)
&gt;&gt;&gt; root
1.0</pre> <div class="fragment"><div class="line"><span class="lineno">  789</span>           full_output=<span class="keyword">False</span>, disp=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  790</span>    <span class="stringliteral">&quot;&quot;&quot;Find a root of a function in a bracketing interval using Brent&#39;s</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    method with hyperbolic extrapolation.</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    A variation on the classic Brent routine to find a zero of the function f</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    between the arguments a and b that uses hyperbolic extrapolation instead of</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    inverse quadratic extrapolation. Bus &amp; Dekker (1975) guarantee convergence</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    for this method, claiming that the upper bound of function evaluations here</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    is 4 or 5 times lesser than that for bisection.</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    f(a) and f(b) cannot have the same signs. Generally, on a par with the</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    brent routine, but not as heavily tested. It is a safe version of the</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    secant method that uses hyperbolic extrapolation.</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    The version here is by Chuck Harris, and implements Algorithm M of</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    [BusAndDekker1975]_, where further details (convergence properties,</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    additional remarks and such) can be found</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    f : function</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        Python function returning a number. f must be continuous, and f(a) and</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        f(b) must have opposite signs.</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    a : scalar</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        One end of the bracketing interval [a,b].</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    b : scalar</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">        The other end of the bracketing interval [a,b].</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    xtol : number, optional</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        parameter must be nonnegative. As with `brentq`, for nice</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">        functions the method will often satisfy the above condition</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        with ``xtol/2`` and ``rtol/2``.</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    rtol : number, optional</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">        parameter cannot be smaller than its default value of</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        ``4*np.finfo(float).eps``. As with `brentq`, for nice functions</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">        the method will often satisfy the above condition with</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        ``xtol/2`` and ``rtol/2``.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        If convergence is not achieved in `maxiter` iterations, an error is</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">        raised. Must be &gt;= 0.</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">        Containing extra arguments for the function `f`.</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">        `f` is called by ``apply(f, (x)+args)``.</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    full_output : bool, optional</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        If `full_output` is False, the root is returned. If `full_output` is</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">        True, the return value is ``(x, r)``, where `x` is the root, and `r` is</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">        a `RootResults` object.</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">        If True, raise RuntimeError if the algorithm didn&#39;t converge.</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        Otherwise, the convergence status is recorded in any `RootResults`</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        return object.</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    x0 : float</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        Zero of `f` between `a` and `b`.</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    r : `RootResults` (present if ``full_output = True``)</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        Object containing information about the convergence. In particular,</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">        ``r.converged`` is True if the routine converged.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    fmin, fmin_powell, fmin_cg, fmin_bfgs, fmin_ncg : multivariate local optimizers</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    leastsq : nonlinear least squares minimizer</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    basinhopping, differential_evolution, brute : global optimizers</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    fminbound, brent, golden, bracket : local scalar minimizers</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    fsolve : N-D root-finding</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    brentq, brenth, ridder, bisect, newton : 1-D root-finding</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    fixed_point : scalar fixed-point finder</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    .. [BusAndDekker1975]</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">       Bus, J. C. P., Dekker, T. J.,</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">       &quot;Two Efficient Algorithms with Guaranteed Convergence for Finding a Zero</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">       of a Function&quot;, ACM Transactions on Mathematical Software, Vol. 1, Issue</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">       4, Dec. 1975, pp. 330-345. Section 3: &quot;Algorithm M&quot;.</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">       :doi:`10.1145/355656.355659`</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    ...     return (x**2 - 1)</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import optimize</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.brenth(f, -2, 0)</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    -1.0</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.brenth(f, 0, 2)</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  886</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(args, tuple):</div>
<div class="line"><span class="lineno">  887</span>        args = (args,)</div>
<div class="line"><span class="lineno">  888</span>    maxiter = operator.index(maxiter)</div>
<div class="line"><span class="lineno">  889</span>    <span class="keywordflow">if</span> xtol &lt;= 0:</div>
<div class="line"><span class="lineno">  890</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;xtol too small (%g &lt;= 0)&quot;</span> % xtol)</div>
<div class="line"><span class="lineno">  891</span>    <span class="keywordflow">if</span> rtol &lt; _rtol:</div>
<div class="line"><span class="lineno">  892</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;rtol too small (%g &lt; %g)&quot;</span> % (rtol, _rtol))</div>
<div class="line"><span class="lineno">  893</span>    r = _zeros._brenth(f, a, b, xtol, rtol, maxiter, args, full_output, disp)</div>
<div class="line"><span class="lineno">  894</span>    <span class="keywordflow">return</span> results_c(full_output, r)</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a22d4c7381bf744ebf05e3f6038e44291" name="a22d4c7381bf744ebf05e3f6038e44291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d4c7381bf744ebf05e3f6038e44291">&#9670;&#160;</a></span>brentq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py.brentq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a root of a function in a bracketing interval using Brent's method.

Uses the classic Brent's method to find a zero of the function `f` on
the sign changing interval [a , b]. Generally considered the best of the
rootfinding routines here. It is a safe version of the secant method that
uses inverse quadratic extrapolation. Brent's method combines root
bracketing, interval bisection, and inverse quadratic interpolation. It is
sometimes known as the van Wijngaarden-Dekker-Brent method. Brent (1973)
claims convergence is guaranteed for functions computable within [a,b].

[Brent1973]_ provides the classic description of the algorithm. Another
description can be found in a recent edition of Numerical Recipes, including
[PressEtal1992]_. A third description is at
http://mathworld.wolfram.com/BrentsMethod.html. It should be easy to
understand the algorithm just by reading our code. Our code diverges a bit
from standard presentations: we choose a different formula for the
extrapolation step.

Parameters
----------
f : function
    Python function returning a number. The function :math:`f`
    must be continuous, and :math:`f(a)` and :math:`f(b)` must
    have opposite signs.
a : scalar
    One end of the bracketing interval :math:`[a, b]`.
b : scalar
    The other end of the bracketing interval :math:`[a, b]`.
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be nonnegative. For nice functions, Brent's
    method will often satisfy the above condition with ``xtol/2``
    and ``rtol/2``. [Brent1973]_
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``. For nice functions, Brent's
    method will often satisfy the above condition with ``xtol/2``
    and ``rtol/2``. [Brent1973]_
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be &gt;= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in any `RootResults`
    return object.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

Notes
-----
`f` must be continuous.  f(a) and f(b) must have opposite signs.

Related functions fall into several classes:

multivariate local optimizers
  `fmin`, `fmin_powell`, `fmin_cg`, `fmin_bfgs`, `fmin_ncg`
nonlinear least squares minimizer
  `leastsq`
constrained multivariate optimizers
  `fmin_l_bfgs_b`, `fmin_tnc`, `fmin_cobyla`
global optimizers
  `basinhopping`, `brute`, `differential_evolution`
local scalar minimizers
  `fminbound`, `brent`, `golden`, `bracket`
N-D root-finding
  `fsolve`
1-D root-finding
  `brenth`, `ridder`, `bisect`, `newton`
scalar fixed-point finder
  `fixed_point`

References
----------
.. [Brent1973]
   Brent, R. P.,
   *Algorithms for Minimization Without Derivatives*.
   Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.

.. [PressEtal1992]
   Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.
   *Numerical Recipes in FORTRAN: The Art of Scientific Computing*, 2nd ed.
   Cambridge, England: Cambridge University Press, pp. 352-355, 1992.
   Section 9.3:  "Van Wijngaarden-Dekker-Brent Method."

Examples
--------
&gt;&gt;&gt; def f(x):
...     return (x**2 - 1)

&gt;&gt;&gt; from scipy import optimize

&gt;&gt;&gt; root = optimize.brentq(f, -2, 0)
&gt;&gt;&gt; root
-1.0

&gt;&gt;&gt; root = optimize.brentq(f, 0, 2)
&gt;&gt;&gt; root
1.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  659</span>           full_output=<span class="keyword">False</span>, disp=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  660</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    Find a root of a function in a bracketing interval using Brent&#39;s method.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    Uses the classic Brent&#39;s method to find a zero of the function `f` on</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    the sign changing interval [a , b]. Generally considered the best of the</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    rootfinding routines here. It is a safe version of the secant method that</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    uses inverse quadratic extrapolation. Brent&#39;s method combines root</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    bracketing, interval bisection, and inverse quadratic interpolation. It is</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    sometimes known as the van Wijngaarden-Dekker-Brent method. Brent (1973)</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    claims convergence is guaranteed for functions computable within [a,b].</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    [Brent1973]_ provides the classic description of the algorithm. Another</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    description can be found in a recent edition of Numerical Recipes, including</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    [PressEtal1992]_. A third description is at</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    http://mathworld.wolfram.com/BrentsMethod.html. It should be easy to</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    understand the algorithm just by reading our code. Our code diverges a bit</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    from standard presentations: we choose a different formula for the</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    extrapolation step.</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    f : function</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">        Python function returning a number. The function :math:`f`</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">        must be continuous, and :math:`f(a)` and :math:`f(b)` must</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">        have opposite signs.</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    a : scalar</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">        One end of the bracketing interval :math:`[a, b]`.</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    b : scalar</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        The other end of the bracketing interval :math:`[a, b]`.</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    xtol : number, optional</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">        parameter must be nonnegative. For nice functions, Brent&#39;s</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        method will often satisfy the above condition with ``xtol/2``</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        and ``rtol/2``. [Brent1973]_</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    rtol : number, optional</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        parameter cannot be smaller than its default value of</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        ``4*np.finfo(float).eps``. For nice functions, Brent&#39;s</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        method will often satisfy the above condition with ``xtol/2``</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        and ``rtol/2``. [Brent1973]_</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        If convergence is not achieved in `maxiter` iterations, an error is</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        raised. Must be &gt;= 0.</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">        Containing extra arguments for the function `f`.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">        `f` is called by ``apply(f, (x)+args)``.</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    full_output : bool, optional</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">        If `full_output` is False, the root is returned. If `full_output` is</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">        True, the return value is ``(x, r)``, where `x` is the root, and `r` is</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        a `RootResults` object.</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        If True, raise RuntimeError if the algorithm didn&#39;t converge.</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        Otherwise, the convergence status is recorded in any `RootResults`</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">        return object.</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    x0 : float</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">        Zero of `f` between `a` and `b`.</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    r : `RootResults` (present if ``full_output = True``)</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">        Object containing information about the convergence. In particular,</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">        ``r.converged`` is True if the routine converged.</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    `f` must be continuous.  f(a) and f(b) must have opposite signs.</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    Related functions fall into several classes:</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    multivariate local optimizers</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">      `fmin`, `fmin_powell`, `fmin_cg`, `fmin_bfgs`, `fmin_ncg`</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    nonlinear least squares minimizer</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">      `leastsq`</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    constrained multivariate optimizers</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">      `fmin_l_bfgs_b`, `fmin_tnc`, `fmin_cobyla`</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    global optimizers</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">      `basinhopping`, `brute`, `differential_evolution`</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    local scalar minimizers</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">      `fminbound`, `brent`, `golden`, `bracket`</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    N-D root-finding</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">      `fsolve`</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    1-D root-finding</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">      `brenth`, `ridder`, `bisect`, `newton`</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    scalar fixed-point finder</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">      `fixed_point`</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    .. [Brent1973]</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">       Brent, R. P.,</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">       *Algorithms for Minimization Without Derivatives*.</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">       Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    .. [PressEtal1992]</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">       Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">       *Numerical Recipes in FORTRAN: The Art of Scientific Computing*, 2nd ed.</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">       Cambridge, England: Cambridge University Press, pp. 352-355, 1992.</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">       Section 9.3:  &quot;Van Wijngaarden-Dekker-Brent Method.&quot;</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    ...     return (x**2 - 1)</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import optimize</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.brentq(f, -2, 0)</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    -1.0</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.brentq(f, 0, 2)</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  776</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(args, tuple):</div>
<div class="line"><span class="lineno">  777</span>        args = (args,)</div>
<div class="line"><span class="lineno">  778</span>    maxiter = operator.index(maxiter)</div>
<div class="line"><span class="lineno">  779</span>    <span class="keywordflow">if</span> xtol &lt;= 0:</div>
<div class="line"><span class="lineno">  780</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;xtol too small (%g &lt;= 0)&quot;</span> % xtol)</div>
<div class="line"><span class="lineno">  781</span>    <span class="keywordflow">if</span> rtol &lt; _rtol:</div>
<div class="line"><span class="lineno">  782</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;rtol too small (%g &lt; %g)&quot;</span> % (rtol, _rtol))</div>
<div class="line"><span class="lineno">  783</span>    r = _zeros._brentq(f, a, b, xtol, rtol, maxiter, args, full_output, disp)</div>
<div class="line"><span class="lineno">  784</span>    <span class="keywordflow">return</span> results_c(full_output, r)</div>
<div class="line"><span class="lineno">  785</span> </div>
<div class="line"><span class="lineno">  786</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af424d369dfc1d4ecc41591ee71ec0c8e" name="af424d369dfc1d4ecc41591ee71ec0c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af424d369dfc1d4ecc41591ee71ec0c8e">&#9670;&#160;</a></span>newton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py.newton </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fprime</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1.48e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fprime2</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a zero of a real or complex function using the Newton-Raphson
(or secant or Halley's) method.

Find a zero of the scalar-valued function `func` given a nearby scalar
starting point `x0`.
The Newton-Raphson method is used if the derivative `fprime` of `func`
is provided, otherwise the secant method is used. If the second order
derivative `fprime2` of `func` is also provided, then Halley's method is
used.

If `x0` is a sequence with more than one item, `newton` returns an array:
the zeros of the function from each (scalar) starting point in `x0`.
In this case, `func` must be vectorized to return a sequence or array of
the same shape as its first argument. If `fprime` (`fprime2`) is given,
then its return must also have the same shape: each element is the first
(second) derivative of `func` with respect to its only variable evaluated
at each element of its first argument.

`newton` is for finding roots of a scalar-valued functions of a single
variable. For problems involving several variables, see `root`.

Parameters
----------
func : callable
    The function whose zero is wanted. It must be a function of a
    single variable of the form ``f(x,a,b,c...)``, where ``a,b,c...``
    are extra arguments that can be passed in the `args` parameter.
x0 : float, sequence, or ndarray
    An initial estimate of the zero that should be somewhere near the
    actual zero. If not scalar, then `func` must be vectorized and return
    a sequence or array of the same shape as its first argument.
fprime : callable, optional
    The derivative of the function when available and convenient. If it
    is None (default), then the secant method is used.
args : tuple, optional
    Extra arguments to be used in the function call.
tol : float, optional
    The allowable error of the zero value. If `func` is complex-valued,
    a larger `tol` is recommended as both the real and imaginary parts
    of `x` contribute to ``|x - x0|``.
maxiter : int, optional
    Maximum number of iterations.
fprime2 : callable, optional
    The second order derivative of the function when available and
    convenient. If it is None (default), then the normal Newton-Raphson
    or the secant method is used. If it is not None, then Halley's method
    is used.
x1 : float, optional
    Another estimate of the zero that should be somewhere near the
    actual zero. Used if `fprime` is not provided.
rtol : float, optional
    Tolerance (relative) for termination.
full_output : bool, optional
    If `full_output` is False (default), the root is returned.
    If True and `x0` is scalar, the return value is ``(x, r)``, where ``x``
    is the root and ``r`` is a `RootResults` object.
    If True and `x0` is non-scalar, the return value is ``(x, converged,
    zero_der)`` (see Returns section for details).
disp : bool, optional
    If True, raise a RuntimeError if the algorithm didn't converge, with
    the error message containing the number of iterations and current
    function value. Otherwise, the convergence status is recorded in a
    `RootResults` return object.
    Ignored if `x0` is not scalar.
    *Note: this has little to do with displaying, however,
    the `disp` keyword cannot be renamed for backwards compatibility.*

Returns
-------
root : float, sequence, or ndarray
    Estimated location where function is zero.
r : `RootResults`, optional
    Present if ``full_output=True`` and `x0` is scalar.
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.
converged : ndarray of bool, optional
    Present if ``full_output=True`` and `x0` is non-scalar.
    For vector functions, indicates which elements converged successfully.
zero_der : ndarray of bool, optional
    Present if ``full_output=True`` and `x0` is non-scalar.
    For vector functions, indicates which elements had a zero derivative.

See Also
--------
root_scalar : interface to root solvers for scalar functions
root : interface to root solvers for multi-input, multi-output functions

Notes
-----
The convergence rate of the Newton-Raphson method is quadratic,
the Halley method is cubic, and the secant method is
sub-quadratic. This means that if the function is well-behaved
the actual error in the estimated zero after the nth iteration
is approximately the square (cube for Halley) of the error
after the (n-1)th step. However, the stopping criterion used
here is the step size and there is no guarantee that a zero
has been found. Consequently, the result should be verified.
Safer algorithms are brentq, brenth, ridder, and bisect,
but they all require that the root first be bracketed in an
interval where the function changes sign. The brentq algorithm
is recommended for general use in one dimensional problems
when such an interval has been found.

When `newton` is used with arrays, it is best suited for the following
types of problems:

* The initial guesses, `x0`, are all relatively the same distance from
  the roots.
* Some or all of the extra arguments, `args`, are also arrays so that a
  class of similar problems can be solved together.
* The size of the initial guesses, `x0`, is larger than O(100) elements.
  Otherwise, a naive loop may perform as well or better than a vector.

Examples
--------
&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; def f(x):
...     return (x**3 - 1)  # only one real root at x = 1

``fprime`` is not provided, use the secant method:

&gt;&gt;&gt; root = optimize.newton(f, 1.5)
&gt;&gt;&gt; root
1.0000000000000016
&gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime2=lambda x: 6 * x)
&gt;&gt;&gt; root
1.0000000000000016

Only ``fprime`` is provided, use the Newton-Raphson method:

&gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2)
&gt;&gt;&gt; root
1.0

Both ``fprime2`` and ``fprime`` are provided, use Halley's method:

&gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2,
...                        fprime2=lambda x: 6 * x)
&gt;&gt;&gt; root
1.0

When we want to find zeros for a set of related starting values and/or
function parameters, we can provide both of those as an array of inputs:

&gt;&gt;&gt; f = lambda x, a: x**3 - a
&gt;&gt;&gt; fder = lambda x, a: 3 * x**2
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = rng.standard_normal(100)
&gt;&gt;&gt; a = np.arange(-50, 50)
&gt;&gt;&gt; vec_res = optimize.newton(f, x, fprime=fder, args=(a, ), maxiter=200)

The above is the equivalent of solving for each value in ``(x, a)``
separately in a for-loop, just faster:

&gt;&gt;&gt; loop_res = [optimize.newton(f, x0, fprime=fder, args=(a0,),
...                             maxiter=200)
...             for x0, a0 in zip(x, a)]
&gt;&gt;&gt; np.allclose(vec_res, loop_res)
True

Plot the results found for all values of ``a``:

&gt;&gt;&gt; analytical_result = np.sign(a) * np.abs(a)**(1/3)
&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; ax.plot(a, analytical_result, 'o')
&gt;&gt;&gt; ax.plot(a, vec_res, '.')
&gt;&gt;&gt; ax.set_xlabel('$a$')
&gt;&gt;&gt; ax.set_ylabel('$x$ where $f(x, a)=0$')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">   96</span>           full_output=<span class="keyword">False</span>, disp=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">   97</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    Find a zero of a real or complex function using the Newton-Raphson</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    (or secant or Halley&#39;s) method.</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    Find a zero of the scalar-valued function `func` given a nearby scalar</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    starting point `x0`.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    The Newton-Raphson method is used if the derivative `fprime` of `func`</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    is provided, otherwise the secant method is used. If the second order</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    derivative `fprime2` of `func` is also provided, then Halley&#39;s method is</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    used.</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    If `x0` is a sequence with more than one item, `newton` returns an array:</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    the zeros of the function from each (scalar) starting point in `x0`.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    In this case, `func` must be vectorized to return a sequence or array of</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    the same shape as its first argument. If `fprime` (`fprime2`) is given,</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    then its return must also have the same shape: each element is the first</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    (second) derivative of `func` with respect to its only variable evaluated</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    at each element of its first argument.</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    `newton` is for finding roots of a scalar-valued functions of a single</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    variable. For problems involving several variables, see `root`.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    func : callable</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        The function whose zero is wanted. It must be a function of a</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">        single variable of the form ``f(x,a,b,c...)``, where ``a,b,c...``</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">        are extra arguments that can be passed in the `args` parameter.</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    x0 : float, sequence, or ndarray</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        An initial estimate of the zero that should be somewhere near the</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        actual zero. If not scalar, then `func` must be vectorized and return</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        a sequence or array of the same shape as its first argument.</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    fprime : callable, optional</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">        The derivative of the function when available and convenient. If it</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        is None (default), then the secant method is used.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">        Extra arguments to be used in the function call.</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">        The allowable error of the zero value. If `func` is complex-valued,</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        a larger `tol` is recommended as both the real and imaginary parts</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        of `x` contribute to ``|x - x0|``.</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        Maximum number of iterations.</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    fprime2 : callable, optional</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        The second order derivative of the function when available and</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">        convenient. If it is None (default), then the normal Newton-Raphson</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        or the secant method is used. If it is not None, then Halley&#39;s method</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        is used.</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    x1 : float, optional</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">        Another estimate of the zero that should be somewhere near the</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">        actual zero. Used if `fprime` is not provided.</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    rtol : float, optional</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        Tolerance (relative) for termination.</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    full_output : bool, optional</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        If `full_output` is False (default), the root is returned.</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        If True and `x0` is scalar, the return value is ``(x, r)``, where ``x``</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        is the root and ``r`` is a `RootResults` object.</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        If True and `x0` is non-scalar, the return value is ``(x, converged,</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        zero_der)`` (see Returns section for details).</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">        If True, raise a RuntimeError if the algorithm didn&#39;t converge, with</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        the error message containing the number of iterations and current</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">        function value. Otherwise, the convergence status is recorded in a</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        `RootResults` return object.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        Ignored if `x0` is not scalar.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        *Note: this has little to do with displaying, however,</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">        the `disp` keyword cannot be renamed for backwards compatibility.*</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    root : float, sequence, or ndarray</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        Estimated location where function is zero.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    r : `RootResults`, optional</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        Present if ``full_output=True`` and `x0` is scalar.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        Object containing information about the convergence. In particular,</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        ``r.converged`` is True if the routine converged.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    converged : ndarray of bool, optional</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        Present if ``full_output=True`` and `x0` is non-scalar.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        For vector functions, indicates which elements converged successfully.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    zero_der : ndarray of bool, optional</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">        Present if ``full_output=True`` and `x0` is non-scalar.</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">        For vector functions, indicates which elements had a zero derivative.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    root_scalar : interface to root solvers for scalar functions</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    root : interface to root solvers for multi-input, multi-output functions</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    The convergence rate of the Newton-Raphson method is quadratic,</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    the Halley method is cubic, and the secant method is</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    sub-quadratic. This means that if the function is well-behaved</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    the actual error in the estimated zero after the nth iteration</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    is approximately the square (cube for Halley) of the error</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    after the (n-1)th step. However, the stopping criterion used</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    here is the step size and there is no guarantee that a zero</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    has been found. Consequently, the result should be verified.</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    Safer algorithms are brentq, brenth, ridder, and bisect,</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    but they all require that the root first be bracketed in an</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    interval where the function changes sign. The brentq algorithm</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    is recommended for general use in one dimensional problems</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    when such an interval has been found.</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    When `newton` is used with arrays, it is best suited for the following</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    types of problems:</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    * The initial guesses, `x0`, are all relatively the same distance from</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">      the roots.</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    * Some or all of the extra arguments, `args`, are also arrays so that a</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">      class of similar problems can be solved together.</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    * The size of the initial guesses, `x0`, is larger than O(100) elements.</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">      Otherwise, a naive loop may perform as well or better than a vector.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import optimize</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    ...     return (x**3 - 1)  # only one real root at x = 1</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    ``fprime`` is not provided, use the secant method:</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.newton(f, 1.5)</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    1.0000000000000016</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime2=lambda x: 6 * x)</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    1.0000000000000016</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Only ``fprime`` is provided, use the Newton-Raphson method:</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2)</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Both ``fprime2`` and ``fprime`` are provided, use Halley&#39;s method:</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2,</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    ...                        fprime2=lambda x: 6 * x)</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    When we want to find zeros for a set of related starting values and/or</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    function parameters, we can provide both of those as an array of inputs:</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    &gt;&gt;&gt; f = lambda x, a: x**3 - a</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    &gt;&gt;&gt; fder = lambda x, a: 3 * x**2</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.standard_normal(100)</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(-50, 50)</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    &gt;&gt;&gt; vec_res = optimize.newton(f, x, fprime=fder, args=(a, ), maxiter=200)</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    The above is the equivalent of solving for each value in ``(x, a)``</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    separately in a for-loop, just faster:</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    &gt;&gt;&gt; loop_res = [optimize.newton(f, x0, fprime=fder, args=(a0,),</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    ...                             maxiter=200)</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    ...             for x0, a0 in zip(x, a)]</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(vec_res, loop_res)</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    Plot the results found for all values of ``a``:</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    &gt;&gt;&gt; analytical_result = np.sign(a) * np.abs(a)**(1/3)</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    &gt;&gt;&gt; fig, ax = plt.subplots()</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    &gt;&gt;&gt; ax.plot(a, analytical_result, &#39;o&#39;)</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    &gt;&gt;&gt; ax.plot(a, vec_res, &#39;.&#39;)</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_xlabel(&#39;$a$&#39;)</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_ylabel(&#39;$x$ where $f(x, a)=0$&#39;)</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  271</span>    <span class="keywordflow">if</span> tol &lt;= 0:</div>
<div class="line"><span class="lineno">  272</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;tol too small (%g &lt;= 0)&quot;</span> % tol)</div>
<div class="line"><span class="lineno">  273</span>    maxiter = operator.index(maxiter)</div>
<div class="line"><span class="lineno">  274</span>    <span class="keywordflow">if</span> maxiter &lt; 1:</div>
<div class="line"><span class="lineno">  275</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;maxiter must be greater than 0&quot;</span>)</div>
<div class="line"><span class="lineno">  276</span>    <span class="keywordflow">if</span> np.size(x0) &gt; 1:</div>
<div class="line"><span class="lineno">  277</span>        <span class="keywordflow">return</span> _array_newton(func, x0, fprime, args, tol, maxiter, fprime2,</div>
<div class="line"><span class="lineno">  278</span>                             full_output)</div>
<div class="line"><span class="lineno">  279</span> </div>
<div class="line"><span class="lineno">  280</span>    <span class="comment"># Convert to float (don&#39;t use float(x0); this works also for complex x0)</span></div>
<div class="line"><span class="lineno">  281</span>    p0 = 1.0 * x0</div>
<div class="line"><span class="lineno">  282</span>    funcalls = 0</div>
<div class="line"><span class="lineno">  283</span>    <span class="keywordflow">if</span> fprime <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  284</span>        <span class="comment"># Newton-Raphson method</span></div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">for</span> itr <span class="keywordflow">in</span> range(maxiter):</div>
<div class="line"><span class="lineno">  286</span>            <span class="comment"># first evaluate fval</span></div>
<div class="line"><span class="lineno">  287</span>            fval = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p0, *args)</div>
<div class="line"><span class="lineno">  288</span>            funcalls += 1</div>
<div class="line"><span class="lineno">  289</span>            <span class="comment"># If fval is 0, a root has been found, then terminate</span></div>
<div class="line"><span class="lineno">  290</span>            <span class="keywordflow">if</span> fval == 0:</div>
<div class="line"><span class="lineno">  291</span>                <span class="keywordflow">return</span> _results_select(</div>
<div class="line"><span class="lineno">  292</span>                    full_output, (p0, funcalls, itr, _ECONVERGED))</div>
<div class="line"><span class="lineno">  293</span>            fder = fprime(p0, *args)</div>
<div class="line"><span class="lineno">  294</span>            funcalls += 1</div>
<div class="line"><span class="lineno">  295</span>            <span class="keywordflow">if</span> fder == 0:</div>
<div class="line"><span class="lineno">  296</span>                msg = <span class="stringliteral">&quot;Derivative was zero.&quot;</span></div>
<div class="line"><span class="lineno">  297</span>                <span class="keywordflow">if</span> disp:</div>
<div class="line"><span class="lineno">  298</span>                    msg += (</div>
<div class="line"><span class="lineno">  299</span>                        <span class="stringliteral">&quot; Failed to converge after %d iterations, value is %s.&quot;</span></div>
<div class="line"><span class="lineno">  300</span>                        % (itr + 1, p0))</div>
<div class="line"><span class="lineno">  301</span>                    <span class="keywordflow">raise</span> RuntimeError(msg)</div>
<div class="line"><span class="lineno">  302</span>                warnings.warn(msg, RuntimeWarning)</div>
<div class="line"><span class="lineno">  303</span>                <span class="keywordflow">return</span> _results_select(</div>
<div class="line"><span class="lineno">  304</span>                    full_output, (p0, funcalls, itr + 1, _ECONVERR))</div>
<div class="line"><span class="lineno">  305</span>            newton_step = fval / fder</div>
<div class="line"><span class="lineno">  306</span>            <span class="keywordflow">if</span> fprime2:</div>
<div class="line"><span class="lineno">  307</span>                fder2 = fprime2(p0, *args)</div>
<div class="line"><span class="lineno">  308</span>                funcalls += 1</div>
<div class="line"><span class="lineno">  309</span>                <span class="comment"># Halley&#39;s method:</span></div>
<div class="line"><span class="lineno">  310</span>                <span class="comment">#   newton_step /= (1.0 - 0.5 * newton_step * fder2 / fder)</span></div>
<div class="line"><span class="lineno">  311</span>                <span class="comment"># Only do it if denominator stays close enough to 1</span></div>
<div class="line"><span class="lineno">  312</span>                <span class="comment"># Rationale: If 1-adj &lt; 0, then Halley sends x in the</span></div>
<div class="line"><span class="lineno">  313</span>                <span class="comment"># opposite direction to Newton. Doesn&#39;t happen if x is close</span></div>
<div class="line"><span class="lineno">  314</span>                <span class="comment"># enough to root.</span></div>
<div class="line"><span class="lineno">  315</span>                adj = newton_step * fder2 / fder / 2</div>
<div class="line"><span class="lineno">  316</span>                <span class="keywordflow">if</span> np.abs(adj) &lt; 1:</div>
<div class="line"><span class="lineno">  317</span>                    newton_step /= 1.0 - adj</div>
<div class="line"><span class="lineno">  318</span>            p = p0 - newton_step</div>
<div class="line"><span class="lineno">  319</span>            <span class="keywordflow">if</span> np.isclose(p, p0, rtol=rtol, atol=tol):</div>
<div class="line"><span class="lineno">  320</span>                <span class="keywordflow">return</span> _results_select(</div>
<div class="line"><span class="lineno">  321</span>                    full_output, (p, funcalls, itr + 1, _ECONVERGED))</div>
<div class="line"><span class="lineno">  322</span>            p0 = p</div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  324</span>        <span class="comment"># Secant method</span></div>
<div class="line"><span class="lineno">  325</span>        <span class="keywordflow">if</span> x1 <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  326</span>            <span class="keywordflow">if</span> x1 == x0:</div>
<div class="line"><span class="lineno">  327</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;x1 and x0 must be different&quot;</span>)</div>
<div class="line"><span class="lineno">  328</span>            p1 = x1</div>
<div class="line"><span class="lineno">  329</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  330</span>            eps = 1e-4</div>
<div class="line"><span class="lineno">  331</span>            p1 = x0 * (1 + eps)</div>
<div class="line"><span class="lineno">  332</span>            p1 += (eps <span class="keywordflow">if</span> p1 &gt;= 0 <span class="keywordflow">else</span> -eps)</div>
<div class="line"><span class="lineno">  333</span>        q0 = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p0, *args)</div>
<div class="line"><span class="lineno">  334</span>        funcalls += 1</div>
<div class="line"><span class="lineno">  335</span>        q1 = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p1, *args)</div>
<div class="line"><span class="lineno">  336</span>        funcalls += 1</div>
<div class="line"><span class="lineno">  337</span>        <span class="keywordflow">if</span> abs(q1) &lt; abs(q0):</div>
<div class="line"><span class="lineno">  338</span>            p0, p1, q0, q1 = p1, p0, q1, q0</div>
<div class="line"><span class="lineno">  339</span>        <span class="keywordflow">for</span> itr <span class="keywordflow">in</span> range(maxiter):</div>
<div class="line"><span class="lineno">  340</span>            <span class="keywordflow">if</span> q1 == q0:</div>
<div class="line"><span class="lineno">  341</span>                <span class="keywordflow">if</span> p1 != p0:</div>
<div class="line"><span class="lineno">  342</span>                    msg = <span class="stringliteral">&quot;Tolerance of %s reached.&quot;</span> % (p1 - p0)</div>
<div class="line"><span class="lineno">  343</span>                    <span class="keywordflow">if</span> disp:</div>
<div class="line"><span class="lineno">  344</span>                        msg += (</div>
<div class="line"><span class="lineno">  345</span>                            <span class="stringliteral">&quot; Failed to converge after %d iterations, value is %s.&quot;</span></div>
<div class="line"><span class="lineno">  346</span>                            % (itr + 1, p1))</div>
<div class="line"><span class="lineno">  347</span>                        <span class="keywordflow">raise</span> RuntimeError(msg)</div>
<div class="line"><span class="lineno">  348</span>                    warnings.warn(msg, RuntimeWarning)</div>
<div class="line"><span class="lineno">  349</span>                p = (p1 + p0) / 2.0</div>
<div class="line"><span class="lineno">  350</span>                <span class="keywordflow">return</span> _results_select(</div>
<div class="line"><span class="lineno">  351</span>                    full_output, (p, funcalls, itr + 1, _ECONVERGED))</div>
<div class="line"><span class="lineno">  352</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  353</span>                <span class="keywordflow">if</span> abs(q1) &gt; abs(q0):</div>
<div class="line"><span class="lineno">  354</span>                    p = (-q0 / q1 * p1 + p0) / (1 - q0 / q1)</div>
<div class="line"><span class="lineno">  355</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  356</span>                    p = (-q1 / q0 * p0 + p1) / (1 - q1 / q0)</div>
<div class="line"><span class="lineno">  357</span>            <span class="keywordflow">if</span> np.isclose(p, p1, rtol=rtol, atol=tol):</div>
<div class="line"><span class="lineno">  358</span>                <span class="keywordflow">return</span> _results_select(</div>
<div class="line"><span class="lineno">  359</span>                    full_output, (p, funcalls, itr + 1, _ECONVERGED))</div>
<div class="line"><span class="lineno">  360</span>            p0, q0 = p1, q1</div>
<div class="line"><span class="lineno">  361</span>            p1 = p</div>
<div class="line"><span class="lineno">  362</span>            q1 = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(p1, *args)</div>
<div class="line"><span class="lineno">  363</span>            funcalls += 1</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordflow">if</span> disp:</div>
<div class="line"><span class="lineno">  366</span>        msg = (<span class="stringliteral">&quot;Failed to converge after %d iterations, value is %s.&quot;</span></div>
<div class="line"><span class="lineno">  367</span>               % (itr + 1, p))</div>
<div class="line"><span class="lineno">  368</span>        <span class="keywordflow">raise</span> RuntimeError(msg)</div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>    <span class="keywordflow">return</span> _results_select(full_output, (p, funcalls, itr + 1, _ECONVERR))</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3235dfa672e442b19c26409aac1b5346" name="a3235dfa672e442b19c26409aac1b5346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3235dfa672e442b19c26409aac1b5346">&#9670;&#160;</a></span>results_c()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py.results_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   70</span><span class="keyword">def </span>results_c(full_output, r):</div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">if</span> full_output:</div>
<div class="line"><span class="lineno">   72</span>        x, funcalls, iterations, flag = r</div>
<div class="line"><span class="lineno">   73</span>        results = RootResults(root=x,</div>
<div class="line"><span class="lineno">   74</span>                              iterations=iterations,</div>
<div class="line"><span class="lineno">   75</span>                              function_calls=funcalls,</div>
<div class="line"><span class="lineno">   76</span>                              flag=flag)</div>
<div class="line"><span class="lineno">   77</span>        <span class="keywordflow">return</span> x, results</div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   79</span>        <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a00cd37dc830933efa5e8629b8b3f4aa0" name="a00cd37dc830933efa5e8629b8b3f4aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cd37dc830933efa5e8629b8b3f4aa0">&#9670;&#160;</a></span>ridder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py.ridder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a root of a function in an interval using Ridder's method.

Parameters
----------
f : function
    Python function returning a number. f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : scalar
    One end of the bracketing interval [a,b].
b : scalar
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be nonnegative.
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be &gt;= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in any `RootResults`
    return object.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence.
    In particular, ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, bisect, newton : 1-D root-finding
fixed_point : scalar fixed-point finder

Notes
-----
Uses [Ridders1979]_ method to find a zero of the function `f` between the
arguments `a` and `b`. Ridders' method is faster than bisection, but not
generally as fast as the Brent routines. [Ridders1979]_ provides the
classic description and source of the algorithm. A description can also be
found in any recent edition of Numerical Recipes.

The routine used here diverges slightly from standard presentations in
order to be a bit more careful of tolerance.

References
----------
.. [Ridders1979]
   Ridders, C. F. J. "A New Algorithm for Computing a
   Single Root of a Real Continuous Function."
   IEEE Trans. Circuits Systems 26, 979-980, 1979.

Examples
--------

&gt;&gt;&gt; def f(x):
...     return (x**2 - 1)

&gt;&gt;&gt; from scipy import optimize

&gt;&gt;&gt; root = optimize.ridder(f, 0, 2)
&gt;&gt;&gt; root
1.0

&gt;&gt;&gt; root = optimize.ridder(f, -2, 0)
&gt;&gt;&gt; root
-1.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  562</span>           full_output=<span class="keyword">False</span>, disp=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno">  563</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    Find a root of a function in an interval using Ridder&#39;s method.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    f : function</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        Python function returning a number. f must be continuous, and f(a) and</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        f(b) must have opposite signs.</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    a : scalar</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        One end of the bracketing interval [a,b].</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    b : scalar</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        The other end of the bracketing interval [a,b].</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    xtol : number, optional</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        parameter must be nonnegative.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    rtol : number, optional</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        parameter cannot be smaller than its default value of</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        ``4*np.finfo(float).eps``.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        If convergence is not achieved in `maxiter` iterations, an error is</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        raised. Must be &gt;= 0.</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">        Containing extra arguments for the function `f`.</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        `f` is called by ``apply(f, (x)+args)``.</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    full_output : bool, optional</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        If `full_output` is False, the root is returned. If `full_output` is</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        True, the return value is ``(x, r)``, where `x` is the root, and `r` is</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        a `RootResults` object.</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        If True, raise RuntimeError if the algorithm didn&#39;t converge.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        Otherwise, the convergence status is recorded in any `RootResults`</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        return object.</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    x0 : float</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        Zero of `f` between `a` and `b`.</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    r : `RootResults` (present if ``full_output = True``)</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        Object containing information about the convergence.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        In particular, ``r.converged`` is True if the routine converged.</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    brentq, brenth, bisect, newton : 1-D root-finding</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    fixed_point : scalar fixed-point finder</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    Uses [Ridders1979]_ method to find a zero of the function `f` between the</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    arguments `a` and `b`. Ridders&#39; method is faster than bisection, but not</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    generally as fast as the Brent routines. [Ridders1979]_ provides the</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    classic description and source of the algorithm. A description can also be</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    found in any recent edition of Numerical Recipes.</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    The routine used here diverges slightly from standard presentations in</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    order to be a bit more careful of tolerance.</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    .. [Ridders1979]</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">       Ridders, C. F. J. &quot;A New Algorithm for Computing a</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">       Single Root of a Real Continuous Function.&quot;</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">       IEEE Trans. Circuits Systems 26, 979-980, 1979.</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    ...     return (x**2 - 1)</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import optimize</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.ridder(f, 0, 2)</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    &gt;&gt;&gt; root = optimize.ridder(f, -2, 0)</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    -1.0</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  646</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(args, tuple):</div>
<div class="line"><span class="lineno">  647</span>        args = (args,)</div>
<div class="line"><span class="lineno">  648</span>    maxiter = operator.index(maxiter)</div>
<div class="line"><span class="lineno">  649</span>    <span class="keywordflow">if</span> xtol &lt;= 0:</div>
<div class="line"><span class="lineno">  650</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;xtol too small (%g &lt;= 0)&quot;</span> % xtol)</div>
<div class="line"><span class="lineno">  651</span>    <span class="keywordflow">if</span> rtol &lt; _rtol:</div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;rtol too small (%g &lt; %g)&quot;</span> % (rtol, _rtol))</div>
<div class="line"><span class="lineno">  653</span>    r = _zeros._ridder(f, a, b, xtol, rtol, maxiter, args, full_output, disp)</div>
<div class="line"><span class="lineno">  654</span>    <span class="keywordflow">return</span> results_c(full_output, r)</div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5004a1b9230e65d0ae385379d1cf1ed" name="ae5004a1b9230e65d0ae385379d1cf1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5004a1b9230e65d0ae385379d1cf1ed">&#9670;&#160;</a></span>toms748()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._zeros_py.toms748 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#afd7eb0e42203b1c6c4b40521ec16bea9">_xtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#a9d9dbe7fa007420b1d111c3329e3b89a">_rtol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code><a class="el" href="namespacescipy_1_1optimize_1_1__zeros__py.html#ab4b892c756bdbbd1cbc39f27d92df5c2">_iter</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a zero using TOMS Algorithm 748 method.

Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a
zero of the function `f` on the interval `[a , b]`, where `f(a)` and
`f(b)` must have opposite signs.

It uses a mixture of inverse cubic interpolation and
"Newton-quadratic" steps. [APS1995].

Parameters
----------
f : function
    Python function returning a scalar. The function :math:`f`
    must be continuous, and :math:`f(a)` and :math:`f(b)`
    have opposite signs.
a : scalar,
    lower boundary of the search interval
b : scalar,
    upper boundary of the search interval
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``f(x, *args)``.
k : int, optional
    The number of Newton quadratic steps to perform each
    iteration. ``k&gt;=1``.
xtol : scalar, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be nonnegative.
rtol : scalar, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be &gt;= 0.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in the `RootResults`
    return object.

Returns
-------
x0 : float
    Approximate Zero of `f`
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, ridder, bisect, newton
fsolve : find zeroes in N dimensions.

Notes
-----
`f` must be continuous.
Algorithm 748 with ``k=2`` is asymptotically the most efficient
algorithm known for finding roots of a four times continuously
differentiable function.
In contrast with Brent's algorithm, which may only decrease the length of
the enclosing bracket on the last step, Algorithm 748 decreases it each
iteration with the same asymptotic efficiency as it finds the root.

For easy statement of efficiency indices, assume that `f` has 4
continuouous deriviatives.
For ``k=1``, the convergence order is at least 2.7, and with about
asymptotically 2 function evaluations per iteration, the efficiency
index is approximately 1.65.
For ``k=2``, the order is about 4.6 with asymptotically 3 function
evaluations per iteration, and the efficiency index 1.66.
For higher values of `k`, the efficiency index approaches
the kth root of ``(3k-2)``, hence ``k=1`` or ``k=2`` are
usually appropriate.

References
----------
.. [APS1995]
   Alefeld, G. E. and Potra, F. A. and Shi, Yixun,
   *Algorithm 748: Enclosing Zeros of Continuous Functions*,
   ACM Trans. Math. Softw. Volume 221(1995)
   doi = {10.1145/210089.210111}

Examples
--------
&gt;&gt;&gt; def f(x):
...     return (x**3 - 1)  # only one real root at x = 1

&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; root, results = optimize.toms748(f, 0, 2, full_output=True)
&gt;&gt;&gt; root
1.0
&gt;&gt;&gt; results
      converged: True
           flag: 'converged'
 function_calls: 11
     iterations: 5
           root: 1.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1250</span>            full_output=<span class="keyword">False</span>, disp=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 1251</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    Find a zero using TOMS Algorithm 748 method.</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    zero of the function `f` on the interval `[a , b]`, where `f(a)` and</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    `f(b)` must have opposite signs.</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    It uses a mixture of inverse cubic interpolation and</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    &quot;Newton-quadratic&quot; steps. [APS1995].</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    f : function</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">        Python function returning a scalar. The function :math:`f`</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">        must be continuous, and :math:`f(a)` and :math:`f(b)`</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        have opposite signs.</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">    a : scalar,</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        lower boundary of the search interval</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    b : scalar,</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">        upper boundary of the search interval</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">        containing extra arguments for the function `f`.</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">        `f` is called by ``f(x, *args)``.</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    k : int, optional</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">        The number of Newton quadratic steps to perform each</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">        iteration. ``k&gt;=1``.</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">    xtol : scalar, optional</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">        parameter must be nonnegative.</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    rtol : scalar, optional</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">        The computed root ``x0`` will satisfy ``np.allclose(x, x0,</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">        atol=xtol, rtol=rtol)``, where ``x`` is the exact root.</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        If convergence is not achieved in `maxiter` iterations, an error is</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">        raised. Must be &gt;= 0.</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    full_output : bool, optional</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">        If `full_output` is False, the root is returned. If `full_output` is</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">        True, the return value is ``(x, r)``, where `x` is the root, and `r` is</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">        a `RootResults` object.</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">        If True, raise RuntimeError if the algorithm didn&#39;t converge.</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">        Otherwise, the convergence status is recorded in the `RootResults`</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">        return object.</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    x0 : float</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">        Approximate Zero of `f`</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    r : `RootResults` (present if ``full_output = True``)</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">        Object containing information about the convergence. In particular,</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">        ``r.converged`` is True if the routine converged.</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">    brentq, brenth, ridder, bisect, newton</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    fsolve : find zeroes in N dimensions.</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    `f` must be continuous.</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral">    Algorithm 748 with ``k=2`` is asymptotically the most efficient</span></div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    algorithm known for finding roots of a four times continuously</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">    differentiable function.</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    In contrast with Brent&#39;s algorithm, which may only decrease the length of</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    the enclosing bracket on the last step, Algorithm 748 decreases it each</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    iteration with the same asymptotic efficiency as it finds the root.</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    For easy statement of efficiency indices, assume that `f` has 4</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    continuouous deriviatives.</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    For ``k=1``, the convergence order is at least 2.7, and with about</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    asymptotically 2 function evaluations per iteration, the efficiency</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    index is approximately 1.65.</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    For ``k=2``, the order is about 4.6 with asymptotically 3 function</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    evaluations per iteration, and the efficiency index 1.66.</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    For higher values of `k`, the efficiency index approaches</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    the kth root of ``(3k-2)``, hence ``k=1`` or ``k=2`` are</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    usually appropriate.</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    .. [APS1995]</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">       Alefeld, G. E. and Potra, F. A. and Shi, Yixun,</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">       *Algorithm 748: Enclosing Zeros of Continuous Functions*,</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">       ACM Trans. Math. Softw. Volume 221(1995)</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">       doi = {10.1145/210089.210111}</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    ...     return (x**3 - 1)  # only one real root at x = 1</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import optimize</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    &gt;&gt;&gt; root, results = optimize.toms748(f, 0, 2, full_output=True)</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    &gt;&gt;&gt; root</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &gt;&gt;&gt; results</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">          converged: True</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">               flag: &#39;converged&#39;</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">     function_calls: 11</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">         iterations: 5</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">               root: 1.0</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1354</span>    <span class="keywordflow">if</span> xtol &lt;= 0:</div>
<div class="line"><span class="lineno"> 1355</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;xtol too small (%g &lt;= 0)&quot;</span> % xtol)</div>
<div class="line"><span class="lineno"> 1356</span>    <span class="keywordflow">if</span> rtol &lt; _rtol / 4:</div>
<div class="line"><span class="lineno"> 1357</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;rtol too small (%g &lt; %g)&quot;</span> % (rtol, _rtol))</div>
<div class="line"><span class="lineno"> 1358</span>    maxiter = operator.index(maxiter)</div>
<div class="line"><span class="lineno"> 1359</span>    <span class="keywordflow">if</span> maxiter &lt; 1:</div>
<div class="line"><span class="lineno"> 1360</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;maxiter must be greater than 0&quot;</span>)</div>
<div class="line"><span class="lineno"> 1361</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(a):</div>
<div class="line"><span class="lineno"> 1362</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;a is not finite %s&quot;</span> % a)</div>
<div class="line"><span class="lineno"> 1363</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(b):</div>
<div class="line"><span class="lineno"> 1364</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;b is not finite %s&quot;</span> % b)</div>
<div class="line"><span class="lineno"> 1365</span>    <span class="keywordflow">if</span> a &gt;= b:</div>
<div class="line"><span class="lineno"> 1366</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;a and b are not an interval [{}, {}]&quot;</span>.format(a, b))</div>
<div class="line"><span class="lineno"> 1367</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> k &gt;= 1:</div>
<div class="line"><span class="lineno"> 1368</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;k too small (%s &lt; 1)&quot;</span> % k)</div>
<div class="line"><span class="lineno"> 1369</span> </div>
<div class="line"><span class="lineno"> 1370</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(args, tuple):</div>
<div class="line"><span class="lineno"> 1371</span>        args = (args,)</div>
<div class="line"><span class="lineno"> 1372</span>    solver = TOMS748Solver()</div>
<div class="line"><span class="lineno"> 1373</span>    result = solver.solve(f, a, b, args=args, k=k, xtol=xtol, rtol=rtol,</div>
<div class="line"><span class="lineno"> 1374</span>                          maxiter=maxiter, disp=disp)</div>
<div class="line"><span class="lineno"> 1375</span>    x, function_calls, iterations, flag = result</div>
<div class="line"><span class="lineno"> 1376</span>    <span class="keywordflow">return</span> _results_select(full_output, (x, function_calls, iterations, flag))</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af4bcdd971836677ee38d2d86f050888b" name="af4bcdd971836677ee38d2d86f050888b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bcdd971836677ee38d2d86f050888b">&#9670;&#160;</a></span>_ECONVERGED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._ECONVERGED = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a774fd1666eaace48a1e96b5cb57ad8be" name="a774fd1666eaace48a1e96b5cb57ad8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774fd1666eaace48a1e96b5cb57ad8be">&#9670;&#160;</a></span>_ECONVERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._ECONVERR = -2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a510c7861992d3edabbc67eb63bab3025" name="a510c7861992d3edabbc67eb63bab3025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510c7861992d3edabbc67eb63bab3025">&#9670;&#160;</a></span>_EINPROGRESS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._EINPROGRESS = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0238c88b7478ae9555103137c3275405" name="a0238c88b7478ae9555103137c3275405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0238c88b7478ae9555103137c3275405">&#9670;&#160;</a></span>_ESIGNERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._ESIGNERR = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dd7b77302c86b135a86e9ecf6dc96ee" name="a9dd7b77302c86b135a86e9ecf6dc96ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd7b77302c86b135a86e9ecf6dc96ee">&#9670;&#160;</a></span>_EVALUEERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._EVALUEERR = -3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4b892c756bdbbd1cbc39f27d92df5c2" name="ab4b892c756bdbbd1cbc39f27d92df5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b892c756bdbbd1cbc39f27d92df5c2">&#9670;&#160;</a></span>_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._iter = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d9dbe7fa007420b1d111c3329e3b89a" name="a9d9dbe7fa007420b1d111c3329e3b89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9dbe7fa007420b1d111c3329e3b89a">&#9670;&#160;</a></span>_rtol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._rtol = 4 * np.finfo(float).<a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd7eb0e42203b1c6c4b40521ec16bea9" name="afd7eb0e42203b1c6c4b40521ec16bea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7eb0e42203b1c6c4b40521ec16bea9">&#9670;&#160;</a></span>_xtol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize._zeros_py._xtol = 2e-12</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a789cf251f5f3f8dda6d1572a32a2d100" name="a789cf251f5f3f8dda6d1572a32a2d100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789cf251f5f3f8dda6d1572a32a2d100">&#9670;&#160;</a></span>CONVERGED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str scipy.optimize._zeros_py.CONVERGED = 'converged'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13ce602a6739ba11af2e141dc0c2ba91" name="a13ce602a6739ba11af2e141dc0c2ba91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ce602a6739ba11af2e141dc0c2ba91">&#9670;&#160;</a></span>CONVERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str scipy.optimize._zeros_py.CONVERR = 'convergence <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7947d48cdb026201f385bde32e43b21" name="af7947d48cdb026201f385bde32e43b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7947d48cdb026201f385bde32e43b21">&#9670;&#160;</a></span>flag_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.optimize._zeros_py.flag_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {_ECONVERGED: CONVERGED, _ESIGNERR: SIGNERR, _ECONVERR: CONVERR,</div>
<div class="line"><span class="lineno">    2</span>            _EVALUEERR: VALUEERR, _EINPROGRESS: INPROGRESS}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8381cb99a373fe3c6579e004730edb03" name="a8381cb99a373fe3c6579e004730edb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8381cb99a373fe3c6579e004730edb03">&#9670;&#160;</a></span>INPROGRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str scipy.optimize._zeros_py.INPROGRESS = 'No <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b07357c3683e74fc4b96789a269db62" name="a5b07357c3683e74fc4b96789a269db62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b07357c3683e74fc4b96789a269db62">&#9670;&#160;</a></span>SIGNERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str scipy.optimize._zeros_py.SIGNERR = 'sign <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abed4a7ba25901d7400ec1b2872815dac" name="abed4a7ba25901d7400ec1b2872815dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed4a7ba25901d7400ec1b2872815dac">&#9670;&#160;</a></span>VALUEERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str scipy.optimize._zeros_py.VALUEERR = 'value <a class="el" href="namespacescipy_1_1optimize_1_1__minpack__py.html#a1bbbcae076659d8fb7ef47b694715cde">error</a>'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
