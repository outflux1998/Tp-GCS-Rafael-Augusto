<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.feature_extraction.image Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1feature__extraction.html">feature_extraction</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html">image</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.feature_extraction.image Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1feature__extraction_1_1image_1_1_patch_extractor.html">PatchExtractor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a479887780bec6b5a3f989f6c86610bab" id="r_a479887780bec6b5a3f989f6c86610bab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#a479887780bec6b5a3f989f6c86610bab">_make_edges_3d</a> (n_x, n_y, n_z=1)</td></tr>
<tr class="memdesc:a479887780bec6b5a3f989f6c86610bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">From an image to a graph.  <br /></td></tr>
<tr class="separator:a479887780bec6b5a3f989f6c86610bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11d2551c8dba88d3f191ed86ac61b17" id="r_ae11d2551c8dba88d3f191ed86ac61b17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#ae11d2551c8dba88d3f191ed86ac61b17">_compute_gradient_3d</a> (edges, img)</td></tr>
<tr class="separator:ae11d2551c8dba88d3f191ed86ac61b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d491a5256901a07dccc48f98f2154a8" id="r_a0d491a5256901a07dccc48f98f2154a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#a0d491a5256901a07dccc48f98f2154a8">_mask_edges_weights</a> (mask, edges, weights=None)</td></tr>
<tr class="separator:a0d491a5256901a07dccc48f98f2154a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8572e8109d312aeaf844c76535aeea96" id="r_a8572e8109d312aeaf844c76535aeea96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#a8572e8109d312aeaf844c76535aeea96">_to_graph</a> (n_x, n_y, n_z, mask=None, img=None, return_as=sparse.coo_matrix, dtype=None)</td></tr>
<tr class="separator:a8572e8109d312aeaf844c76535aeea96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf47550004206b77a3b7af6e1503066" id="r_a7cf47550004206b77a3b7af6e1503066"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#a7cf47550004206b77a3b7af6e1503066">img_to_graph</a> (img, *mask=None, return_as=sparse.coo_matrix, dtype=None)</td></tr>
<tr class="separator:a7cf47550004206b77a3b7af6e1503066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90ac5343378334bf3ec66b4c6d574ee" id="r_ac90ac5343378334bf3ec66b4c6d574ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#ac90ac5343378334bf3ec66b4c6d574ee">grid_to_graph</a> (n_x, n_y, n_z=1, *mask=None, return_as=sparse.coo_matrix, dtype=int)</td></tr>
<tr class="separator:ac90ac5343378334bf3ec66b4c6d574ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5d0e38fa15fa1437d44149572dcaea" id="r_a9d5d0e38fa15fa1437d44149572dcaea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#a9d5d0e38fa15fa1437d44149572dcaea">_compute_n_patches</a> (i_h, i_w, p_h, p_w, max_patches=None)</td></tr>
<tr class="memdesc:a9d5d0e38fa15fa1437d44149572dcaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">From an image to a set of small image patches.  <br /></td></tr>
<tr class="separator:a9d5d0e38fa15fa1437d44149572dcaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43a02e87afb752c6c26e763a24ce3a6" id="r_ad43a02e87afb752c6c26e763a24ce3a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#ad43a02e87afb752c6c26e763a24ce3a6">_extract_patches</a> (arr, patch_shape=8, extraction_step=1)</td></tr>
<tr class="separator:ad43a02e87afb752c6c26e763a24ce3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068c99fb3ce2557aae4aa2039a311dd4" id="r_a068c99fb3ce2557aae4aa2039a311dd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#a068c99fb3ce2557aae4aa2039a311dd4">extract_patches_2d</a> (image, patch_size, *max_patches=None, random_state=None)</td></tr>
<tr class="separator:a068c99fb3ce2557aae4aa2039a311dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d31839d5fed72f5e44e56e162fd66a" id="r_a36d31839d5fed72f5e44e56e162fd66a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1feature__extraction_1_1image.html#a36d31839d5fed72f5e44e56e162fd66a">reconstruct_from_patches_2d</a> (patches, image_size)</td></tr>
<tr class="separator:a36d31839d5fed72f5e44e56e162fd66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The :mod:`sklearn.feature_extraction.image` submodule gathers utilities to
extract features from images.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae11d2551c8dba88d3f191ed86ac61b17" name="ae11d2551c8dba88d3f191ed86ac61b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11d2551c8dba88d3f191ed86ac61b17">&#9670;&#160;</a></span>_compute_gradient_3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image._compute_gradient_3d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   54</span><span class="keyword">def </span>_compute_gradient_3d(edges, img):</div>
<div class="line"><span class="lineno">   55</span>    _, n_y, n_z = img.shape</div>
<div class="line"><span class="lineno">   56</span>    gradient = np.abs(</div>
<div class="line"><span class="lineno">   57</span>        img[</div>
<div class="line"><span class="lineno">   58</span>            edges[0] // (n_y * n_z),</div>
<div class="line"><span class="lineno">   59</span>            (edges[0] % (n_y * n_z)) // n_z,</div>
<div class="line"><span class="lineno">   60</span>            (edges[0] % (n_y * n_z)) % n_z,</div>
<div class="line"><span class="lineno">   61</span>        ]</div>
<div class="line"><span class="lineno">   62</span>        - img[</div>
<div class="line"><span class="lineno">   63</span>            edges[1] // (n_y * n_z),</div>
<div class="line"><span class="lineno">   64</span>            (edges[1] % (n_y * n_z)) // n_z,</div>
<div class="line"><span class="lineno">   65</span>            (edges[1] % (n_y * n_z)) % n_z,</div>
<div class="line"><span class="lineno">   66</span>        ]</div>
<div class="line"><span class="lineno">   67</span>    )</div>
<div class="line"><span class="lineno">   68</span>    <span class="keywordflow">return</span> gradient</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span> </div>
<div class="line"><span class="lineno">   71</span><span class="comment"># XXX: Why mask the image after computing the weights?</span></div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d5d0e38fa15fa1437d44149572dcaea" name="a9d5d0e38fa15fa1437d44149572dcaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5d0e38fa15fa1437d44149572dcaea">&#9670;&#160;</a></span>_compute_n_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image._compute_n_patches </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_patches</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>From an image to a set of small image patches. </p>
<pre class="fragment">Compute the number of patches that will be extracted in an image.

Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.

Parameters
----------
i_h : int
    The image height
i_w : int
    The image with
p_h : int
    The height of a patch
p_w : int
    The width of a patch
max_patches : int or float, default=None
    The maximum number of patches to extract. If max_patches is a float
    between 0 and 1, it is taken to be a proportion of the total number
    of patches.
</pre> <div class="fragment"><div class="line"><span class="lineno">  228</span><span class="keyword">def </span>_compute_n_patches(i_h, i_w, p_h, p_w, max_patches=None):</div>
<div class="line"><span class="lineno">  229</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the number of patches that will be extracted in an image.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    i_h : int</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        The image height</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    i_w : int</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        The image with</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    p_h : int</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">        The height of a patch</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    p_w : int</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        The width of a patch</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    max_patches : int or float, default=None</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        The maximum number of patches to extract. If max_patches is a float</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        between 0 and 1, it is taken to be a proportion of the total number</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">        of patches.</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  248</span>    n_h = i_h - p_h + 1</div>
<div class="line"><span class="lineno">  249</span>    n_w = i_w - p_w + 1</div>
<div class="line"><span class="lineno">  250</span>    all_patches = n_h * n_w</div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span>    <span class="keywordflow">if</span> max_patches:</div>
<div class="line"><span class="lineno">  253</span>        <span class="keywordflow">if</span> isinstance(max_patches, (Integral)) <span class="keywordflow">and</span> max_patches &lt; all_patches:</div>
<div class="line"><span class="lineno">  254</span>            <span class="keywordflow">return</span> max_patches</div>
<div class="line"><span class="lineno">  255</span>        <span class="keywordflow">elif</span> isinstance(max_patches, (Integral)) <span class="keywordflow">and</span> max_patches &gt;= all_patches:</div>
<div class="line"><span class="lineno">  256</span>            <span class="keywordflow">return</span> all_patches</div>
<div class="line"><span class="lineno">  257</span>        <span class="keywordflow">elif</span> isinstance(max_patches, (Real)) <span class="keywordflow">and</span> 0 &lt; max_patches &lt; 1:</div>
<div class="line"><span class="lineno">  258</span>            <span class="keywordflow">return</span> int(max_patches * all_patches)</div>
<div class="line"><span class="lineno">  259</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  260</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid value for max_patches: %r&quot;</span> % max_patches)</div>
<div class="line"><span class="lineno">  261</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  262</span>        <span class="keywordflow">return</span> all_patches</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad43a02e87afb752c6c26e763a24ce3a6" name="ad43a02e87afb752c6c26e763a24ce3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43a02e87afb752c6c26e763a24ce3a6">&#9670;&#160;</a></span>_extract_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image._extract_patches </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patch_shape</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extraction_step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Extracts patches of any n-dimensional array in place using strides.

Given an n-dimensional array it will return a 2n-dimensional array with
the first n dimensions indexing patch position and the last n indexing
the patch content. This operation is immediate (O(1)). A reshape
performed on the first n dimensions will cause numpy to copy data, leading
to a list of extracted patches.

Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.

Parameters
----------
arr : ndarray
    n-dimensional array of which patches are to be extracted

patch_shape : int or tuple of length arr.ndim.default=8
    Indicates the shape of the patches to be extracted. If an
    integer is given, the shape will be a hypercube of
    sidelength given by its value.

extraction_step : int or tuple of length arr.ndim, default=1
    Indicates step size at which extraction shall be performed.
    If integer is given, then the step is uniform in all dimensions.


Returns
-------
patches : strided ndarray
    2n-dimensional array indexing patches on first n dimensions and
    containing patches on the last n dimensions. These dimensions
    are fake, but this way no data is copied. A simple reshape invokes
    a copying operation to obtain a list of patches:
    result.reshape([-1] + list(patch_shape))
</pre> <div class="fragment"><div class="line"><span class="lineno">  265</span><span class="keyword">def </span>_extract_patches(arr, patch_shape=8, extraction_step=1):</div>
<div class="line"><span class="lineno">  266</span>    <span class="stringliteral">&quot;&quot;&quot;Extracts patches of any n-dimensional array in place using strides.</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    Given an n-dimensional array it will return a 2n-dimensional array with</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    the first n dimensions indexing patch position and the last n indexing</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    the patch content. This operation is immediate (O(1)). A reshape</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    performed on the first n dimensions will cause numpy to copy data, leading</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    to a list of extracted patches.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    arr : ndarray</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        n-dimensional array of which patches are to be extracted</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    patch_shape : int or tuple of length arr.ndim.default=8</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        Indicates the shape of the patches to be extracted. If an</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        integer is given, the shape will be a hypercube of</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        sidelength given by its value.</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    extraction_step : int or tuple of length arr.ndim, default=1</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">        Indicates step size at which extraction shall be performed.</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        If integer is given, then the step is uniform in all dimensions.</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    patches : strided ndarray</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        2n-dimensional array indexing patches on first n dimensions and</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        containing patches on the last n dimensions. These dimensions</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        are fake, but this way no data is copied. A simple reshape invokes</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        a copying operation to obtain a list of patches:</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        result.reshape([-1] + list(patch_shape))</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>    arr_ndim = arr.ndim</div>
<div class="line"><span class="lineno">  302</span> </div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">if</span> isinstance(patch_shape, Number):</div>
<div class="line"><span class="lineno">  304</span>        patch_shape = tuple([patch_shape] * arr_ndim)</div>
<div class="line"><span class="lineno">  305</span>    <span class="keywordflow">if</span> isinstance(extraction_step, Number):</div>
<div class="line"><span class="lineno">  306</span>        extraction_step = tuple([extraction_step] * arr_ndim)</div>
<div class="line"><span class="lineno">  307</span> </div>
<div class="line"><span class="lineno">  308</span>    patch_strides = arr.strides</div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>    slices = tuple(slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, st) <span class="keywordflow">for</span> st <span class="keywordflow">in</span> extraction_step)</div>
<div class="line"><span class="lineno">  311</span>    indexing_strides = arr[slices].strides</div>
<div class="line"><span class="lineno">  312</span> </div>
<div class="line"><span class="lineno">  313</span>    patch_indices_shape = (</div>
<div class="line"><span class="lineno">  314</span>        (np.array(arr.shape) - np.array(patch_shape)) // np.array(extraction_step)</div>
<div class="line"><span class="lineno">  315</span>    ) + 1</div>
<div class="line"><span class="lineno">  316</span> </div>
<div class="line"><span class="lineno">  317</span>    shape = tuple(list(patch_indices_shape) + list(patch_shape))</div>
<div class="line"><span class="lineno">  318</span>    strides = tuple(list(indexing_strides) + list(patch_strides))</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>    patches = as_strided(arr, shape=shape, strides=strides)</div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">return</span> patches</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a479887780bec6b5a3f989f6c86610bab" name="a479887780bec6b5a3f989f6c86610bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479887780bec6b5a3f989f6c86610bab">&#9670;&#160;</a></span>_make_edges_3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image._make_edges_3d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_z</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>From an image to a graph. </p>
<pre class="fragment">Returns a list of edges for a 3D image.

Parameters
----------
n_x : int
    The size of the grid in the x direction.
n_y : int
    The size of the grid in the y direction.
n_z : integer, default=1
    The size of the grid in the z direction, defaults to 1
</pre> <div class="fragment"><div class="line"><span class="lineno">   34</span><span class="keyword">def </span>_make_edges_3d(n_x, n_y, n_z=1):</div>
<div class="line"><span class="lineno">   35</span>    <span class="stringliteral">&quot;&quot;&quot;Returns a list of edges for a 3D image.</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    n_x : int</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        The size of the grid in the x direction.</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    n_y : int</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        The size of the grid in the y direction.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    n_z : integer, default=1</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">        The size of the grid in the z direction, defaults to 1</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   46</span>    vertices = np.arange(n_x * n_y * n_z).reshape((n_x, n_y, n_z))</div>
<div class="line"><span class="lineno">   47</span>    edges_deep = np.vstack((vertices[:, :, :-1].ravel(), vertices[:, :, 1:].ravel()))</div>
<div class="line"><span class="lineno">   48</span>    edges_right = np.vstack((vertices[:, :-1].ravel(), vertices[:, 1:].ravel()))</div>
<div class="line"><span class="lineno">   49</span>    edges_down = np.vstack((vertices[:-1].ravel(), vertices[1:].ravel()))</div>
<div class="line"><span class="lineno">   50</span>    edges = np.hstack((edges_deep, edges_right, edges_down))</div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordflow">return</span> edges</div>
<div class="line"><span class="lineno">   52</span> </div>
<div class="line"><span class="lineno">   53</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d491a5256901a07dccc48f98f2154a8" name="a0d491a5256901a07dccc48f98f2154a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d491a5256901a07dccc48f98f2154a8">&#9670;&#160;</a></span>_mask_edges_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image._mask_edges_weights </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Apply a mask to edges (weighted or not)</pre> <div class="fragment"><div class="line"><span class="lineno">   74</span><span class="keyword">def </span>_mask_edges_weights(mask, edges, weights=None):</div>
<div class="line"><span class="lineno">   75</span>    <span class="stringliteral">&quot;&quot;&quot;Apply a mask to edges (weighted or not)&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   76</span>    inds = np.arange(mask.size)</div>
<div class="line"><span class="lineno">   77</span>    inds = inds[mask.ravel()]</div>
<div class="line"><span class="lineno">   78</span>    ind_mask = np.logical_and(np.in1d(edges[0], inds), np.in1d(edges[1], inds))</div>
<div class="line"><span class="lineno">   79</span>    edges = edges[:, ind_mask]</div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   81</span>        weights = weights[ind_mask]</div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">if</span> len(edges.ravel()):</div>
<div class="line"><span class="lineno">   83</span>        maxval = edges.max()</div>
<div class="line"><span class="lineno">   84</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   85</span>        maxval = 0</div>
<div class="line"><span class="lineno">   86</span>    order = np.searchsorted(np.flatnonzero(mask), np.arange(maxval + 1))</div>
<div class="line"><span class="lineno">   87</span>    edges = order[edges]</div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   89</span>        <span class="keywordflow">return</span> edges</div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   91</span>        <span class="keywordflow">return</span> edges, weights</div>
<div class="line"><span class="lineno">   92</span> </div>
<div class="line"><span class="lineno">   93</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8572e8109d312aeaf844c76535aeea96" name="a8572e8109d312aeaf844c76535aeea96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8572e8109d312aeaf844c76535aeea96">&#9670;&#160;</a></span>_to_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image._to_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>img</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_as</em> = <code>sparse.coo_matrix</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Auxiliary function for img_to_graph and grid_to_graph</pre> <div class="fragment"><div class="line"><span class="lineno">   96</span>):</div>
<div class="line"><span class="lineno">   97</span>    <span class="stringliteral">&quot;&quot;&quot;Auxiliary function for img_to_graph and grid_to_graph&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   98</span>    edges = _make_edges_3d(n_x, n_y, n_z)</div>
<div class="line"><span class="lineno">   99</span> </div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  101</span>        <span class="keywordflow">if</span> img <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  102</span>            dtype = int</div>
<div class="line"><span class="lineno">  103</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  104</span>            dtype = img.dtype</div>
<div class="line"><span class="lineno">  105</span> </div>
<div class="line"><span class="lineno">  106</span>    <span class="keywordflow">if</span> img <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  107</span>        img = np.atleast_3d(img)</div>
<div class="line"><span class="lineno">  108</span>        weights = _compute_gradient_3d(edges, img)</div>
<div class="line"><span class="lineno">  109</span>        <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  110</span>            edges, weights = _mask_edges_weights(mask, edges, weights)</div>
<div class="line"><span class="lineno">  111</span>            diag = img.squeeze()[mask]</div>
<div class="line"><span class="lineno">  112</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  113</span>            diag = img.ravel()</div>
<div class="line"><span class="lineno">  114</span>        n_voxels = diag.size</div>
<div class="line"><span class="lineno">  115</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  116</span>        <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  117</span>            mask = mask.astype(dtype=bool, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  118</span>            mask = np.asarray(mask, dtype=bool)</div>
<div class="line"><span class="lineno">  119</span>            edges = _mask_edges_weights(mask, edges)</div>
<div class="line"><span class="lineno">  120</span>            n_voxels = np.sum(mask)</div>
<div class="line"><span class="lineno">  121</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  122</span>            n_voxels = n_x * n_y * n_z</div>
<div class="line"><span class="lineno">  123</span>        weights = np.ones(edges.shape[1], dtype=dtype)</div>
<div class="line"><span class="lineno">  124</span>        diag = np.ones(n_voxels, dtype=dtype)</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>    diag_idx = np.arange(n_voxels)</div>
<div class="line"><span class="lineno">  127</span>    i_idx = np.hstack((edges[0], edges[1]))</div>
<div class="line"><span class="lineno">  128</span>    j_idx = np.hstack((edges[1], edges[0]))</div>
<div class="line"><span class="lineno">  129</span>    graph = sparse.coo_matrix(</div>
<div class="line"><span class="lineno">  130</span>        (</div>
<div class="line"><span class="lineno">  131</span>            np.hstack((weights, weights, diag)),</div>
<div class="line"><span class="lineno">  132</span>            (np.hstack((i_idx, diag_idx)), np.hstack((j_idx, diag_idx))),</div>
<div class="line"><span class="lineno">  133</span>        ),</div>
<div class="line"><span class="lineno">  134</span>        (n_voxels, n_voxels),</div>
<div class="line"><span class="lineno">  135</span>        dtype=dtype,</div>
<div class="line"><span class="lineno">  136</span>    )</div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">if</span> return_as <span class="keywordflow">is</span> np.ndarray:</div>
<div class="line"><span class="lineno">  138</span>        <span class="keywordflow">return</span> graph.toarray()</div>
<div class="line"><span class="lineno">  139</span>    <span class="keywordflow">return</span> return_as(graph)</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a068c99fb3ce2557aae4aa2039a311dd4" name="a068c99fb3ce2557aae4aa2039a311dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068c99fb3ce2557aae4aa2039a311dd4">&#9670;&#160;</a></span>extract_patches_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image.extract_patches_2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>max_patches</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reshape a 2D image into a collection of patches.

The resulting patches are allocated in a dedicated array.

Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.

Parameters
----------
image : ndarray of shape (image_height, image_width) or \
    (image_height, image_width, n_channels)
    The original image data. For color images, the last dimension specifies
    the channel: a RGB image would have `n_channels=3`.

patch_size : tuple of int (patch_height, patch_width)
    The dimensions of one patch.

max_patches : int or float, default=None
    The maximum number of patches to extract. If `max_patches` is a float
    between 0 and 1, it is taken to be a proportion of the total number
    of patches.

random_state : int, RandomState instance, default=None
    Determines the random number generator used for random sampling when
    `max_patches` is not None. Use an int to make the randomness
    deterministic.
    See :term:`Glossary &lt;random_state&gt;`.

Returns
-------
patches : array of shape (n_patches, patch_height, patch_width) or \
    (n_patches, patch_height, patch_width, n_channels)
    The collection of patches extracted from the image, where `n_patches`
    is either `max_patches` or the total number of patches that can be
    extracted.

Examples
--------
&gt;&gt;&gt; from sklearn.datasets import load_sample_image
&gt;&gt;&gt; from sklearn.feature_extraction import image
&gt;&gt;&gt; # Use the array data from the first image in this dataset:
&gt;&gt;&gt; one_image = load_sample_image("china.jpg")
&gt;&gt;&gt; print('Image shape: {}'.format(one_image.shape))
Image shape: (427, 640, 3)
&gt;&gt;&gt; patches = image.extract_patches_2d(one_image, (2, 2))
&gt;&gt;&gt; print('Patches shape: {}'.format(patches.shape))
Patches shape: (272214, 2, 2, 3)
&gt;&gt;&gt; # Here are just two of these patches:
&gt;&gt;&gt; print(patches[1])
[[[174 201 231]
  [174 201 231]]
 [[173 200 230]
  [173 200 230]]]
&gt;&gt;&gt; print(patches[800])
[[[187 214 243]
  [188 215 244]]
 [[187 214 243]
  [188 215 244]]]
</pre> <div class="fragment"><div class="line"><span class="lineno">  324</span><span class="keyword">def </span>extract_patches_2d(image, patch_size, *, max_patches=None, random_state=None):</div>
<div class="line"><span class="lineno">  325</span>    <span class="stringliteral">&quot;&quot;&quot;Reshape a 2D image into a collection of patches.</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    The resulting patches are allocated in a dedicated array.</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    image : ndarray of shape (image_height, image_width) or \</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        (image_height, image_width, n_channels)</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">        The original image data. For color images, the last dimension specifies</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        the channel: a RGB image would have `n_channels=3`.</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    patch_size : tuple of int (patch_height, patch_width)</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">        The dimensions of one patch.</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    max_patches : int or float, default=None</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">        The maximum number of patches to extract. If `max_patches` is a float</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">        between 0 and 1, it is taken to be a proportion of the total number</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">        of patches.</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    random_state : int, RandomState instance, default=None</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">        Determines the random number generator used for random sampling when</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        `max_patches` is not None. Use an int to make the randomness</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">        deterministic.</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    patches : array of shape (n_patches, patch_height, patch_width) or \</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        (n_patches, patch_height, patch_width, n_channels)</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        The collection of patches extracted from the image, where `n_patches`</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        is either `max_patches` or the total number of patches that can be</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">        extracted.</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.datasets import load_sample_image</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.feature_extraction import image</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    &gt;&gt;&gt; # Use the array data from the first image in this dataset:</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    &gt;&gt;&gt; one_image = load_sample_image(&quot;china.jpg&quot;)</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    &gt;&gt;&gt; print(&#39;Image shape: {}&#39;.format(one_image.shape))</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Image shape: (427, 640, 3)</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    &gt;&gt;&gt; patches = image.extract_patches_2d(one_image, (2, 2))</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    &gt;&gt;&gt; print(&#39;Patches shape: {}&#39;.format(patches.shape))</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    Patches shape: (272214, 2, 2, 3)</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    &gt;&gt;&gt; # Here are just two of these patches:</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    &gt;&gt;&gt; print(patches[1])</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    [[[174 201 231]</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">      [174 201 231]]</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">     [[173 200 230]</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">      [173 200 230]]]</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    &gt;&gt;&gt; print(patches[800])</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    [[[187 214 243]</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">      [188 215 244]]</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">     [[187 214 243]</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">      [188 215 244]]]</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  383</span>    i_h, i_w = image.shape[:2]</div>
<div class="line"><span class="lineno">  384</span>    p_h, p_w = patch_size</div>
<div class="line"><span class="lineno">  385</span> </div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">if</span> p_h &gt; i_h:</div>
<div class="line"><span class="lineno">  387</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  388</span>            <span class="stringliteral">&quot;Height of the patch should be less than the height of the image.&quot;</span></div>
<div class="line"><span class="lineno">  389</span>        )</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span>    <span class="keywordflow">if</span> p_w &gt; i_w:</div>
<div class="line"><span class="lineno">  392</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  393</span>            <span class="stringliteral">&quot;Width of the patch should be less than the width of the image.&quot;</span></div>
<div class="line"><span class="lineno">  394</span>        )</div>
<div class="line"><span class="lineno">  395</span> </div>
<div class="line"><span class="lineno">  396</span>    image = check_array(image, allow_nd=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  397</span>    image = image.reshape((i_h, i_w, -1))</div>
<div class="line"><span class="lineno">  398</span>    n_colors = image.shape[-1]</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>    extracted_patches = _extract_patches(</div>
<div class="line"><span class="lineno">  401</span>        image, patch_shape=(p_h, p_w, n_colors), extraction_step=1</div>
<div class="line"><span class="lineno">  402</span>    )</div>
<div class="line"><span class="lineno">  403</span> </div>
<div class="line"><span class="lineno">  404</span>    n_patches = _compute_n_patches(i_h, i_w, p_h, p_w, max_patches)</div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordflow">if</span> max_patches:</div>
<div class="line"><span class="lineno">  406</span>        rng = check_random_state(random_state)</div>
<div class="line"><span class="lineno">  407</span>        i_s = rng.randint(i_h - p_h + 1, size=n_patches)</div>
<div class="line"><span class="lineno">  408</span>        j_s = rng.randint(i_w - p_w + 1, size=n_patches)</div>
<div class="line"><span class="lineno">  409</span>        patches = extracted_patches[i_s, j_s, 0]</div>
<div class="line"><span class="lineno">  410</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  411</span>        patches = extracted_patches</div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span>    patches = patches.reshape(-1, p_h, p_w, n_colors)</div>
<div class="line"><span class="lineno">  414</span>    <span class="comment"># remove the color dimension if useless</span></div>
<div class="line"><span class="lineno">  415</span>    <span class="keywordflow">if</span> patches.shape[-1] == 1:</div>
<div class="line"><span class="lineno">  416</span>        <span class="keywordflow">return</span> patches.reshape((n_patches, p_h, p_w))</div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  418</span>        <span class="keywordflow">return</span> patches</div>
<div class="line"><span class="lineno">  419</span> </div>
<div class="line"><span class="lineno">  420</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac90ac5343378334bf3ec66b4c6d574ee" name="ac90ac5343378334bf3ec66b4c6d574ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90ac5343378334bf3ec66b4c6d574ee">&#9670;&#160;</a></span>grid_to_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image.grid_to_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_z</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_as</em> = <code>sparse.coo_matrix</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>int</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Graph of the pixel-to-pixel connections.

Edges exist if 2 voxels are connected.

Parameters
----------
n_x : int
    Dimension in x axis.
n_y : int
    Dimension in y axis.
n_z : int, default=1
    Dimension in z axis.
mask : ndarray of shape (n_x, n_y, n_z), dtype=bool, default=None
    An optional mask of the image, to consider only part of the
    pixels.
return_as : np.ndarray or a sparse matrix class, \
        default=sparse.coo_matrix
    The class to use to build the returned adjacency matrix.
dtype : dtype, default=int
    The data of the returned sparse matrix. By default it is int.

Returns
-------
graph : np.ndarray or a sparse matrix class
    The computed adjacency matrix.

Notes
-----
For scikit-learn versions 0.14.1 and prior, return_as=np.ndarray was
handled by returning a dense np.matrix instance.  Going forward, np.ndarray
returns an np.ndarray, as expected.

For compatibility, user code relying on this method should wrap its
calls in ``np.asarray`` to avoid type issues.
</pre> <div class="fragment"><div class="line"><span class="lineno">  185</span>):</div>
<div class="line"><span class="lineno">  186</span>    <span class="stringliteral">&quot;&quot;&quot;Graph of the pixel-to-pixel connections.</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    Edges exist if 2 voxels are connected.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    n_x : int</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        Dimension in x axis.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    n_y : int</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        Dimension in y axis.</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    n_z : int, default=1</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        Dimension in z axis.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    mask : ndarray of shape (n_x, n_y, n_z), dtype=bool, default=None</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">        An optional mask of the image, to consider only part of the</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        pixels.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    return_as : np.ndarray or a sparse matrix class, \</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">            default=sparse.coo_matrix</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        The class to use to build the returned adjacency matrix.</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    dtype : dtype, default=int</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">        The data of the returned sparse matrix. By default it is int.</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    graph : np.ndarray or a sparse matrix class</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        The computed adjacency matrix.</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    For scikit-learn versions 0.14.1 and prior, return_as=np.ndarray was</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    handled by returning a dense np.matrix instance.  Going forward, np.ndarray</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    returns an np.ndarray, as expected.</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    For compatibility, user code relying on this method should wrap its</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    calls in ``np.asarray`` to avoid type issues.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">return</span> _to_graph(n_x, n_y, n_z, mask=mask, return_as=return_as, dtype=dtype)</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cf47550004206b77a3b7af6e1503066" name="a7cf47550004206b77a3b7af6e1503066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf47550004206b77a3b7af6e1503066">&#9670;&#160;</a></span>img_to_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image.img_to_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_as</em> = <code>sparse.coo_matrix</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Graph of the pixel-to-pixel gradient connections.

Edges are weighted with the gradient values.

Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.

Parameters
----------
img : ndarray of shape (height, width) or (height, width, channel)
    2D or 3D image.
mask : ndarray of shape (height, width) or \
        (height, width, channel), dtype=bool, default=None
    An optional mask of the image, to consider only part of the
    pixels.
return_as : np.ndarray or a sparse matrix class, \
        default=sparse.coo_matrix
    The class to use to build the returned adjacency matrix.
dtype : dtype, default=None
    The data of the returned sparse matrix. By default it is the
    dtype of img.

Returns
-------
graph : ndarray or a sparse matrix class
    The computed adjacency matrix.

Notes
-----
For scikit-learn versions 0.14.1 and prior, return_as=np.ndarray was
handled by returning a dense np.matrix instance.  Going forward, np.ndarray
returns an np.ndarray, as expected.

For compatibility, user code relying on this method should wrap its
calls in ``np.asarray`` to avoid type issues.
</pre> <div class="fragment"><div class="line"><span class="lineno">  142</span><span class="keyword">def </span>img_to_graph(img, *, mask=None, return_as=sparse.coo_matrix, dtype=None):</div>
<div class="line"><span class="lineno">  143</span>    <span class="stringliteral">&quot;&quot;&quot;Graph of the pixel-to-pixel gradient connections.</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    Edges are weighted with the gradient values.</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    img : ndarray of shape (height, width) or (height, width, channel)</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        2D or 3D image.</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    mask : ndarray of shape (height, width) or \</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">            (height, width, channel), dtype=bool, default=None</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        An optional mask of the image, to consider only part of the</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">        pixels.</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    return_as : np.ndarray or a sparse matrix class, \</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">            default=sparse.coo_matrix</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">        The class to use to build the returned adjacency matrix.</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    dtype : dtype, default=None</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        The data of the returned sparse matrix. By default it is the</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        dtype of img.</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    graph : ndarray or a sparse matrix class</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">        The computed adjacency matrix.</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    For scikit-learn versions 0.14.1 and prior, return_as=np.ndarray was</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    handled by returning a dense np.matrix instance.  Going forward, np.ndarray</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    returns an np.ndarray, as expected.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    For compatibility, user code relying on this method should wrap its</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    calls in ``np.asarray`` to avoid type issues.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  178</span>    img = np.atleast_3d(img)</div>
<div class="line"><span class="lineno">  179</span>    n_x, n_y, n_z = img.shape</div>
<div class="line"><span class="lineno">  180</span>    <span class="keywordflow">return</span> _to_graph(n_x, n_y, n_z, mask, img, return_as, dtype)</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a36d31839d5fed72f5e44e56e162fd66a" name="a36d31839d5fed72f5e44e56e162fd66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d31839d5fed72f5e44e56e162fd66a">&#9670;&#160;</a></span>reconstruct_from_patches_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.feature_extraction.image.reconstruct_from_patches_2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct the image from all of its patches.

Patches are assumed to overlap and the image is constructed by filling in
the patches from left to right, top to bottom, averaging the overlapping
regions.

Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.

Parameters
----------
patches : ndarray of shape (n_patches, patch_height, patch_width) or \
    (n_patches, patch_height, patch_width, n_channels)
    The complete set of patches. If the patches contain colour information,
    channels are indexed along the last dimension: RGB patches would
    have `n_channels=3`.

image_size : tuple of int (image_height, image_width) or \
    (image_height, image_width, n_channels)
    The size of the image that will be reconstructed.

Returns
-------
image : ndarray of shape image_size
    The reconstructed image.
</pre> <div class="fragment"><div class="line"><span class="lineno">  421</span><span class="keyword">def </span>reconstruct_from_patches_2d(patches, image_size):</div>
<div class="line"><span class="lineno">  422</span>    <span class="stringliteral">&quot;&quot;&quot;Reconstruct the image from all of its patches.</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    Patches are assumed to overlap and the image is constructed by filling in</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    the patches from left to right, top to bottom, averaging the overlapping</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    regions.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;image_feature_extraction&gt;`.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    patches : ndarray of shape (n_patches, patch_height, patch_width) or \</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        (n_patches, patch_height, patch_width, n_channels)</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        The complete set of patches. If the patches contain colour information,</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        channels are indexed along the last dimension: RGB patches would</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">        have `n_channels=3`.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    image_size : tuple of int (image_height, image_width) or \</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        (image_height, image_width, n_channels)</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        The size of the image that will be reconstructed.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    image : ndarray of shape image_size</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        The reconstructed image.</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  447</span>    i_h, i_w = image_size[:2]</div>
<div class="line"><span class="lineno">  448</span>    p_h, p_w = patches.shape[1:3]</div>
<div class="line"><span class="lineno">  449</span>    img = np.zeros(image_size)</div>
<div class="line"><span class="lineno">  450</span>    <span class="comment"># compute the dimensions of the patches array</span></div>
<div class="line"><span class="lineno">  451</span>    n_h = i_h - p_h + 1</div>
<div class="line"><span class="lineno">  452</span>    n_w = i_w - p_w + 1</div>
<div class="line"><span class="lineno">  453</span>    <span class="keywordflow">for</span> p, (i, j) <span class="keywordflow">in</span> zip(patches, product(range(n_h), range(n_w))):</div>
<div class="line"><span class="lineno">  454</span>        img[i : i + p_h, j : j + p_w] += p</div>
<div class="line"><span class="lineno">  455</span> </div>
<div class="line"><span class="lineno">  456</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(i_h):</div>
<div class="line"><span class="lineno">  457</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(i_w):</div>
<div class="line"><span class="lineno">  458</span>            <span class="comment"># divide by the amount of overlap</span></div>
<div class="line"><span class="lineno">  459</span>            <span class="comment"># XXX: is this the most efficient way? memory-wise yes, cpu wise?</span></div>
<div class="line"><span class="lineno">  460</span>            img[i, j] /= float(min(i + 1, p_h, i_h - i) * min(j + 1, p_w, i_w - j))</div>
<div class="line"><span class="lineno">  461</span>    <span class="keywordflow">return</span> img</div>
<div class="line"><span class="lineno">  462</span> </div>
<div class="line"><span class="lineno">  463</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
