<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1ensemble.html">ensemble</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1ensemble_1_1__hist__gradient__boosting.html">_hist_gradient_boosting</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower.html">grower</a></li><li class="navelem"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html">TreeGrower</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc9ba46b86d7f927e4eae9b936191340" id="r_adc9ba46b86d7f927e4eae9b936191340"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#adc9ba46b86d7f927e4eae9b936191340">__init__</a> (self, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a093223b3f0f7f9761c3e2068fd53422e">X_binned</a>, gradients, hessians, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#aae63f70b5cf8ece75596428281f02fd8">max_leaf_nodes</a>=None, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a3ee0a782d7a6bb1305a75139cb309146">max_depth</a>=None, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#aaba7f2c606aabb87a6ddc17acf94a271">min_samples_leaf</a>=20, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a47818d5ff59e49a16e099375911e2b20">min_gain_to_split</a>=0.0, n_bins=256, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#abb0c2abfb62e5315538c76623ee705d1">n_bins_non_missing</a>=None, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a6d94e2ec02a37c92f98231aca536a713">has_missing_values</a>=False, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#ad1a5bdc68bd2e1ce3b365c4755f3f8ee">is_categorical</a>=None, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a6c253d487b7c6e622ece0ad7006e7589">monotonic_cst</a>=None, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#ab3cb30f6b8c0f8fac68f81105070978d">interaction_cst</a>=None, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a9680731084b0dae78744089bc6795ea4">l2_regularization</a>=0.0, min_hessian_to_split=1e-3, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a499a564d8be08b6e1b5fd73f8ea110d7">shrinkage</a>=1.0, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#adc88af4ec5eaec728cb5c946fbfc92d4">n_threads</a>=None)</td></tr>
<tr class="separator:adc9ba46b86d7f927e4eae9b936191340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd539b9dd6f2480ffad98a22cee0790" id="r_a4bd539b9dd6f2480ffad98a22cee0790"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a4bd539b9dd6f2480ffad98a22cee0790">grow</a> (self)</td></tr>
<tr class="separator:a4bd539b9dd6f2480ffad98a22cee0790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2e2a2481a65930ddeee59022ce1e3b" id="r_a3f2e2a2481a65930ddeee59022ce1e3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a3f2e2a2481a65930ddeee59022ce1e3b">split_next</a> (self)</td></tr>
<tr class="separator:a3f2e2a2481a65930ddeee59022ce1e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4ebae417f9d66674fcba654582a009" id="r_a6c4ebae417f9d66674fcba654582a009"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a6c4ebae417f9d66674fcba654582a009">make_predictor</a> (self, binning_thresholds)</td></tr>
<tr class="separator:a6c4ebae417f9d66674fcba654582a009"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2e62bb82bf21952c67362d41ad96200f" id="r_a2e62bb82bf21952c67362d41ad96200f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a2e62bb82bf21952c67362d41ad96200f">with_monotonic_cst</a></td></tr>
<tr class="separator:a2e62bb82bf21952c67362d41ad96200f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8030235233d3bf7f48fb4de32d075f6c" id="r_a8030235233d3bf7f48fb4de32d075f6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a8030235233d3bf7f48fb4de32d075f6c">histogram_builder</a></td></tr>
<tr class="separator:a8030235233d3bf7f48fb4de32d075f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ff86f349380a192b2412deb911beda" id="r_ae6ff86f349380a192b2412deb911beda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#ae6ff86f349380a192b2412deb911beda">splitter</a></td></tr>
<tr class="separator:ae6ff86f349380a192b2412deb911beda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c2abfb62e5315538c76623ee705d1" id="r_abb0c2abfb62e5315538c76623ee705d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#abb0c2abfb62e5315538c76623ee705d1">n_bins_non_missing</a></td></tr>
<tr class="separator:abb0c2abfb62e5315538c76623ee705d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee0124202e9f19ef1d9a6c6c016e018" id="r_a0ee0124202e9f19ef1d9a6c6c016e018"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a0ee0124202e9f19ef1d9a6c6c016e018">missing_values_bin_idx</a></td></tr>
<tr class="separator:a0ee0124202e9f19ef1d9a6c6c016e018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae63f70b5cf8ece75596428281f02fd8" id="r_aae63f70b5cf8ece75596428281f02fd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#aae63f70b5cf8ece75596428281f02fd8">max_leaf_nodes</a></td></tr>
<tr class="separator:aae63f70b5cf8ece75596428281f02fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d94e2ec02a37c92f98231aca536a713" id="r_a6d94e2ec02a37c92f98231aca536a713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a6d94e2ec02a37c92f98231aca536a713">has_missing_values</a></td></tr>
<tr class="separator:a6d94e2ec02a37c92f98231aca536a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c253d487b7c6e622ece0ad7006e7589" id="r_a6c253d487b7c6e622ece0ad7006e7589"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a6c253d487b7c6e622ece0ad7006e7589">monotonic_cst</a></td></tr>
<tr class="separator:a6c253d487b7c6e622ece0ad7006e7589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cb30f6b8c0f8fac68f81105070978d" id="r_ab3cb30f6b8c0f8fac68f81105070978d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#ab3cb30f6b8c0f8fac68f81105070978d">interaction_cst</a></td></tr>
<tr class="separator:ab3cb30f6b8c0f8fac68f81105070978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a5bdc68bd2e1ce3b365c4755f3f8ee" id="r_ad1a5bdc68bd2e1ce3b365c4755f3f8ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#ad1a5bdc68bd2e1ce3b365c4755f3f8ee">is_categorical</a></td></tr>
<tr class="separator:ad1a5bdc68bd2e1ce3b365c4755f3f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9680731084b0dae78744089bc6795ea4" id="r_a9680731084b0dae78744089bc6795ea4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a9680731084b0dae78744089bc6795ea4">l2_regularization</a></td></tr>
<tr class="separator:a9680731084b0dae78744089bc6795ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a960d67537b50a075aefd8c485a3913" id="r_a8a960d67537b50a075aefd8c485a3913"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a8a960d67537b50a075aefd8c485a3913">n_features</a></td></tr>
<tr class="separator:a8a960d67537b50a075aefd8c485a3913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee0a782d7a6bb1305a75139cb309146" id="r_a3ee0a782d7a6bb1305a75139cb309146"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a3ee0a782d7a6bb1305a75139cb309146">max_depth</a></td></tr>
<tr class="separator:a3ee0a782d7a6bb1305a75139cb309146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba7f2c606aabb87a6ddc17acf94a271" id="r_aaba7f2c606aabb87a6ddc17acf94a271"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#aaba7f2c606aabb87a6ddc17acf94a271">min_samples_leaf</a></td></tr>
<tr class="separator:aaba7f2c606aabb87a6ddc17acf94a271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093223b3f0f7f9761c3e2068fd53422e" id="r_a093223b3f0f7f9761c3e2068fd53422e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a093223b3f0f7f9761c3e2068fd53422e">X_binned</a></td></tr>
<tr class="separator:a093223b3f0f7f9761c3e2068fd53422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47818d5ff59e49a16e099375911e2b20" id="r_a47818d5ff59e49a16e099375911e2b20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a47818d5ff59e49a16e099375911e2b20">min_gain_to_split</a></td></tr>
<tr class="separator:a47818d5ff59e49a16e099375911e2b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499a564d8be08b6e1b5fd73f8ea110d7" id="r_a499a564d8be08b6e1b5fd73f8ea110d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a499a564d8be08b6e1b5fd73f8ea110d7">shrinkage</a></td></tr>
<tr class="separator:a499a564d8be08b6e1b5fd73f8ea110d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc88af4ec5eaec728cb5c946fbfc92d4" id="r_adc88af4ec5eaec728cb5c946fbfc92d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#adc88af4ec5eaec728cb5c946fbfc92d4">n_threads</a></td></tr>
<tr class="separator:adc88af4ec5eaec728cb5c946fbfc92d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65773c34c03afde92738ec51151acbe8" id="r_a65773c34c03afde92738ec51151acbe8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a65773c34c03afde92738ec51151acbe8">splittable_nodes</a></td></tr>
<tr class="separator:a65773c34c03afde92738ec51151acbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1d9de78f3c9bbbdd7759dfc604902b" id="r_abf1d9de78f3c9bbbdd7759dfc604902b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#abf1d9de78f3c9bbbdd7759dfc604902b">finalized_leaves</a></td></tr>
<tr class="separator:abf1d9de78f3c9bbbdd7759dfc604902b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a3a99bcb089565d9c47cddc666b754" id="r_a65a3a99bcb089565d9c47cddc666b754"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a65a3a99bcb089565d9c47cddc666b754">total_find_split_time</a></td></tr>
<tr class="separator:a65a3a99bcb089565d9c47cddc666b754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2920b82ceff65dd098d21ba756802135" id="r_a2920b82ceff65dd098d21ba756802135"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a2920b82ceff65dd098d21ba756802135">total_compute_hist_time</a></td></tr>
<tr class="separator:a2920b82ceff65dd098d21ba756802135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf77375a6ee84d28301040299a15fc9d" id="r_adf77375a6ee84d28301040299a15fc9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#adf77375a6ee84d28301040299a15fc9d">total_apply_split_time</a></td></tr>
<tr class="separator:adf77375a6ee84d28301040299a15fc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bb1a04f1d902c99579652e296c59c4" id="r_a07bb1a04f1d902c99579652e296c59c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a07bb1a04f1d902c99579652e296c59c4">n_categorical_splits</a></td></tr>
<tr class="separator:a07bb1a04f1d902c99579652e296c59c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdc776724c394104a94d7d19a7dba69" id="r_a0cdc776724c394104a94d7d19a7dba69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a0cdc776724c394104a94d7d19a7dba69">n_nodes</a></td></tr>
<tr class="separator:a0cdc776724c394104a94d7d19a7dba69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a46cce61e95fbdf63f21aa9794449d" id="r_ad6a46cce61e95fbdf63f21aa9794449d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#ad6a46cce61e95fbdf63f21aa9794449d">root</a></td></tr>
<tr class="separator:ad6a46cce61e95fbdf63f21aa9794449d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa0e15bbf4084c47d77f9393dabc09957" id="r_aa0e15bbf4084c47d77f9393dabc09957"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#aa0e15bbf4084c47d77f9393dabc09957">_validate_parameters</a> (self, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a093223b3f0f7f9761c3e2068fd53422e">X_binned</a>, <a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a47818d5ff59e49a16e099375911e2b20">min_gain_to_split</a>, min_hessian_to_split)</td></tr>
<tr class="separator:aa0e15bbf4084c47d77f9393dabc09957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18b93b60bcf00e94324f6ba3c016817" id="r_ad18b93b60bcf00e94324f6ba3c016817"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#ad18b93b60bcf00e94324f6ba3c016817">_apply_shrinkage</a> (self)</td></tr>
<tr class="separator:ad18b93b60bcf00e94324f6ba3c016817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9e67f6186b5021eed9424cf657663e" id="r_aac9e67f6186b5021eed9424cf657663e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#aac9e67f6186b5021eed9424cf657663e">_intilialize_root</a> (self, gradients, hessians, hessians_are_constant)</td></tr>
<tr class="separator:aac9e67f6186b5021eed9424cf657663e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405e7722d1fa5065438979bd61e85c73" id="r_a405e7722d1fa5065438979bd61e85c73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a405e7722d1fa5065438979bd61e85c73">_compute_best_split_and_push</a> (self, node)</td></tr>
<tr class="separator:a405e7722d1fa5065438979bd61e85c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5661008a8da1224dbf553977641eac93" id="r_a5661008a8da1224dbf553977641eac93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a5661008a8da1224dbf553977641eac93">_compute_interactions</a> (self, node)</td></tr>
<tr class="separator:a5661008a8da1224dbf553977641eac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de6e7310beaee9aabea0dd0b18b85b0" id="r_a3de6e7310beaee9aabea0dd0b18b85b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a3de6e7310beaee9aabea0dd0b18b85b0">_finalize_leaf</a> (self, node)</td></tr>
<tr class="separator:a3de6e7310beaee9aabea0dd0b18b85b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d10173e3342b78dc187aae750eee8cf" id="r_a9d10173e3342b78dc187aae750eee8cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1ensemble_1_1__hist__gradient__boosting_1_1grower_1_1_tree_grower.html#a9d10173e3342b78dc187aae750eee8cf">_finalize_splittable_nodes</a> (self)</td></tr>
<tr class="separator:a9d10173e3342b78dc187aae750eee8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Tree grower class used to build a tree.

The tree is fitted to predict the values of a Newton-Raphson step. The
splits are considered in a best-first fashion, and the quality of a
split is defined in splitting._split_gain.

Parameters
----------
X_binned : ndarray of shape (n_samples, n_features), dtype=np.uint8
    The binned input samples. Must be Fortran-aligned.
gradients : ndarray of shape (n_samples,)
    The gradients of each training sample. Those are the gradients of the
    loss w.r.t the predictions, evaluated at iteration ``i - 1``.
hessians : ndarray of shape (n_samples,)
    The hessians of each training sample. Those are the hessians of the
    loss w.r.t the predictions, evaluated at iteration ``i - 1``.
max_leaf_nodes : int, default=None
    The maximum number of leaves for each tree. If None, there is no
    maximum limit.
max_depth : int, default=None
    The maximum depth of each tree. The depth of a tree is the number of
    edges to go from the root to the deepest leaf.
    Depth isn't constrained by default.
min_samples_leaf : int, default=20
    The minimum number of samples per leaf.
min_gain_to_split : float, default=0.
    The minimum gain needed to split a node. Splits with lower gain will
    be ignored.
n_bins : int, default=256
    The total number of bins, including the bin for missing values. Used
    to define the shape of the histograms.
n_bins_non_missing : ndarray, dtype=np.uint32, default=None
    For each feature, gives the number of bins actually used for
    non-missing values. For features with a lot of unique values, this
    is equal to ``n_bins - 1``. If it's an int, all features are
    considered to have the same number of bins. If None, all features
    are considered to have ``n_bins - 1`` bins.
has_missing_values : bool or ndarray, dtype=bool, default=False
    Whether each feature contains missing values (in the training data).
    If it's a bool, the same value is used for all features.
is_categorical : ndarray of bool of shape (n_features,), default=None
    Indicates categorical features.
monotonic_cst : array-like of int of shape (n_features,), dtype=int, default=None
    Indicates the monotonic constraint to enforce on each feature.
      - 1: monotonic increase
      - 0: no constraint
      - -1: monotonic decrease

    Read more in the :ref:`User Guide &lt;monotonic_cst_gbdt&gt;`.
interaction_cst : list of sets of integers, default=None
    List of interaction constraints.
l2_regularization : float, default=0.
    The L2 regularization parameter.
min_hessian_to_split : float, default=1e-3
    The minimum sum of hessians needed in each node. Splits that result in
    at least one child having a sum of hessians less than
    ``min_hessian_to_split`` are discarded.
shrinkage : float, default=1.
    The shrinkage parameter to apply to the leaves values, also known as
    learning rate.
n_threads : int, default=None
    Number of OpenMP threads to use. `_openmp_effective_n_threads` is called
    to determine the effective number of threads use, which takes cgroups CPU
    quotes into account. See the docstring of `_openmp_effective_n_threads`
    for details.

Attributes
----------
histogram_builder : HistogramBuilder
splitter : Splitter
root : TreeNode
finalized_leaves : list of TreeNode
splittable_nodes : list of TreeNode
missing_values_bin_idx : int
    Equals n_bins - 1
n_categorical_splits : int
n_features : int
n_nodes : int
total_find_split_time : float
    Time spent finding the best splits
total_compute_hist_time : float
    Time spent computing histograms
total_apply_split_time : float
    Time spent splitting nodes
with_monotonic_cst : bool
    Whether there are monotonic constraints that apply. False iff monotonic_cst is
    None.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc9ba46b86d7f927e4eae9b936191340" name="adc9ba46b86d7f927e4eae9b936191340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9ba46b86d7f927e4eae9b936191340">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X_binned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_leaf_nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_samples_leaf</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_gain_to_split</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_bins</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_bins_non_missing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>has_missing_values</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>is_categorical</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>monotonic_cst</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interaction_cst</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l2_regularization</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_hessian_to_split</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shrinkage</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  244</span>    ):</div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span>        self._validate_parameters(</div>
<div class="line"><span class="lineno">  247</span>            X_binned,</div>
<div class="line"><span class="lineno">  248</span>            min_gain_to_split,</div>
<div class="line"><span class="lineno">  249</span>            min_hessian_to_split,</div>
<div class="line"><span class="lineno">  250</span>        )</div>
<div class="line"><span class="lineno">  251</span>        n_threads = _openmp_effective_n_threads(n_threads)</div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span>        <span class="keywordflow">if</span> n_bins_non_missing <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  254</span>            n_bins_non_missing = n_bins - 1</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordflow">if</span> isinstance(n_bins_non_missing, numbers.Integral):</div>
<div class="line"><span class="lineno">  257</span>            n_bins_non_missing = np.array(</div>
<div class="line"><span class="lineno">  258</span>                [n_bins_non_missing] * X_binned.shape[1], dtype=np.uint32</div>
<div class="line"><span class="lineno">  259</span>            )</div>
<div class="line"><span class="lineno">  260</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  261</span>            n_bins_non_missing = np.asarray(n_bins_non_missing, dtype=np.uint32)</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span>        <span class="keywordflow">if</span> isinstance(has_missing_values, bool):</div>
<div class="line"><span class="lineno">  264</span>            has_missing_values = [has_missing_values] * X_binned.shape[1]</div>
<div class="line"><span class="lineno">  265</span>        has_missing_values = np.asarray(has_missing_values, dtype=np.uint8)</div>
<div class="line"><span class="lineno">  266</span> </div>
<div class="line"><span class="lineno">  267</span>        <span class="comment"># `monotonic_cst` validation is done in _validate_monotonic_cst</span></div>
<div class="line"><span class="lineno">  268</span>        <span class="comment"># at the estimator level and therefore the following should not be</span></div>
<div class="line"><span class="lineno">  269</span>        <span class="comment"># needed when using the public API.</span></div>
<div class="line"><span class="lineno">  270</span>        <span class="keywordflow">if</span> monotonic_cst <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  271</span>            monotonic_cst = np.full(</div>
<div class="line"><span class="lineno">  272</span>                shape=X_binned.shape[1],</div>
<div class="line"><span class="lineno">  273</span>                fill_value=MonotonicConstraint.NO_CST,</div>
<div class="line"><span class="lineno">  274</span>                dtype=np.int8,</div>
<div class="line"><span class="lineno">  275</span>            )</div>
<div class="line"><span class="lineno">  276</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  277</span>            monotonic_cst = np.asarray(monotonic_cst, dtype=np.int8)</div>
<div class="line"><span class="lineno">  278</span>        self.with_monotonic_cst = np.any(monotonic_cst != MonotonicConstraint.NO_CST)</div>
<div class="line"><span class="lineno">  279</span> </div>
<div class="line"><span class="lineno">  280</span>        <span class="keywordflow">if</span> is_categorical <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  281</span>            is_categorical = np.zeros(shape=X_binned.shape[1], dtype=np.uint8)</div>
<div class="line"><span class="lineno">  282</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  283</span>            is_categorical = np.asarray(is_categorical, dtype=np.uint8)</div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">if</span> np.any(</div>
<div class="line"><span class="lineno">  286</span>            np.logical_and(</div>
<div class="line"><span class="lineno">  287</span>                is_categorical == 1, monotonic_cst != MonotonicConstraint.NO_CST</div>
<div class="line"><span class="lineno">  288</span>            )</div>
<div class="line"><span class="lineno">  289</span>        ):</div>
<div class="line"><span class="lineno">  290</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Categorical features cannot have monotonic constraints.&quot;</span>)</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>        hessians_are_constant = hessians.shape[0] == 1</div>
<div class="line"><span class="lineno">  293</span>        self.histogram_builder = HistogramBuilder(</div>
<div class="line"><span class="lineno">  294</span>            X_binned, n_bins, gradients, hessians, hessians_are_constant, n_threads</div>
<div class="line"><span class="lineno">  295</span>        )</div>
<div class="line"><span class="lineno">  296</span>        missing_values_bin_idx = n_bins - 1</div>
<div class="line"><span class="lineno">  297</span>        self.splitter = Splitter(</div>
<div class="line"><span class="lineno">  298</span>            X_binned,</div>
<div class="line"><span class="lineno">  299</span>            n_bins_non_missing,</div>
<div class="line"><span class="lineno">  300</span>            missing_values_bin_idx,</div>
<div class="line"><span class="lineno">  301</span>            has_missing_values,</div>
<div class="line"><span class="lineno">  302</span>            is_categorical,</div>
<div class="line"><span class="lineno">  303</span>            monotonic_cst,</div>
<div class="line"><span class="lineno">  304</span>            l2_regularization,</div>
<div class="line"><span class="lineno">  305</span>            min_hessian_to_split,</div>
<div class="line"><span class="lineno">  306</span>            min_samples_leaf,</div>
<div class="line"><span class="lineno">  307</span>            min_gain_to_split,</div>
<div class="line"><span class="lineno">  308</span>            hessians_are_constant,</div>
<div class="line"><span class="lineno">  309</span>            n_threads,</div>
<div class="line"><span class="lineno">  310</span>        )</div>
<div class="line"><span class="lineno">  311</span>        self.n_bins_non_missing = n_bins_non_missing</div>
<div class="line"><span class="lineno">  312</span>        self.missing_values_bin_idx = missing_values_bin_idx</div>
<div class="line"><span class="lineno">  313</span>        self.max_leaf_nodes = max_leaf_nodes</div>
<div class="line"><span class="lineno">  314</span>        self.has_missing_values = has_missing_values</div>
<div class="line"><span class="lineno">  315</span>        self.monotonic_cst = monotonic_cst</div>
<div class="line"><span class="lineno">  316</span>        self.interaction_cst = interaction_cst</div>
<div class="line"><span class="lineno">  317</span>        self.is_categorical = is_categorical</div>
<div class="line"><span class="lineno">  318</span>        self.l2_regularization = l2_regularization</div>
<div class="line"><span class="lineno">  319</span>        self.n_features = X_binned.shape[1]</div>
<div class="line"><span class="lineno">  320</span>        self.max_depth = max_depth</div>
<div class="line"><span class="lineno">  321</span>        self.min_samples_leaf = min_samples_leaf</div>
<div class="line"><span class="lineno">  322</span>        self.X_binned = X_binned</div>
<div class="line"><span class="lineno">  323</span>        self.min_gain_to_split = min_gain_to_split</div>
<div class="line"><span class="lineno">  324</span>        self.shrinkage = shrinkage</div>
<div class="line"><span class="lineno">  325</span>        self.n_threads = n_threads</div>
<div class="line"><span class="lineno">  326</span>        self.splittable_nodes = []</div>
<div class="line"><span class="lineno">  327</span>        self.finalized_leaves = []</div>
<div class="line"><span class="lineno">  328</span>        self.total_find_split_time = 0.0  <span class="comment"># time spent finding the best splits</span></div>
<div class="line"><span class="lineno">  329</span>        self.total_compute_hist_time = 0.0  <span class="comment"># time spent computing histograms</span></div>
<div class="line"><span class="lineno">  330</span>        self.total_apply_split_time = 0.0  <span class="comment"># time spent splitting nodes</span></div>
<div class="line"><span class="lineno">  331</span>        self.n_categorical_splits = 0</div>
<div class="line"><span class="lineno">  332</span>        self._intilialize_root(gradients, hessians, hessians_are_constant)</div>
<div class="line"><span class="lineno">  333</span>        self.n_nodes = 1</div>
<div class="line"><span class="lineno">  334</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad18b93b60bcf00e94324f6ba3c016817" name="ad18b93b60bcf00e94324f6ba3c016817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18b93b60bcf00e94324f6ba3c016817">&#9670;&#160;</a></span>_apply_shrinkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower._apply_shrinkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Multiply leaves values by shrinkage parameter.

This must be done at the very end of the growing process. If this were
done during the growing process e.g. in finalize_leaf(), then a leaf
would be shrunk but its sibling would potentially not be (if it's a
non-leaf), which would lead to a wrong computation of the 'middle'
value needed to enforce the monotonic constraints.
</pre> <div class="fragment"><div class="line"><span class="lineno">  368</span>    <span class="keyword">def </span>_apply_shrinkage(self):</div>
<div class="line"><span class="lineno">  369</span>        <span class="stringliteral">&quot;&quot;&quot;Multiply leaves values by shrinkage parameter.</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">        This must be done at the very end of the growing process. If this were</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">        done during the growing process e.g. in finalize_leaf(), then a leaf</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">        would be shrunk but its sibling would potentially not be (if it&#39;s a</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        non-leaf), which would lead to a wrong computation of the &#39;middle&#39;</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        value needed to enforce the monotonic constraints.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  377</span>        <span class="keywordflow">for</span> leaf <span class="keywordflow">in</span> self.finalized_leaves:</div>
<div class="line"><span class="lineno">  378</span>            leaf.value *= self.shrinkage</div>
<div class="line"><span class="lineno">  379</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a405e7722d1fa5065438979bd61e85c73" name="a405e7722d1fa5065438979bd61e85c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405e7722d1fa5065438979bd61e85c73">&#9670;&#160;</a></span>_compute_best_split_and_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower._compute_best_split_and_push </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the best possible split (SplitInfo) of a given node.

Also push it in the heap of splittable nodes if gain isn't zero.
The gain of a node is 0 if either all the leaves are pure
(best gain = 0), or if no split would satisfy the constraints,
(min_hessians_to_split, min_gain_to_split, min_samples_leaf)
</pre> <div class="fragment"><div class="line"><span class="lineno">  425</span>    <span class="keyword">def </span>_compute_best_split_and_push(self, node):</div>
<div class="line"><span class="lineno">  426</span>        <span class="stringliteral">&quot;&quot;&quot;Compute the best possible split (SplitInfo) of a given node.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">        Also push it in the heap of splittable nodes if gain isn&#39;t zero.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">        The gain of a node is 0 if either all the leaves are pure</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        (best gain = 0), or if no split would satisfy the constraints,</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        (min_hessians_to_split, min_gain_to_split, min_samples_leaf)</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>        node.split_info = self.splitter.find_node_split(</div>
<div class="line"><span class="lineno">  435</span>            n_samples=node.n_samples,</div>
<div class="line"><span class="lineno">  436</span>            histograms=node.histograms,</div>
<div class="line"><span class="lineno">  437</span>            sum_gradients=node.sum_gradients,</div>
<div class="line"><span class="lineno">  438</span>            sum_hessians=node.sum_hessians,</div>
<div class="line"><span class="lineno">  439</span>            value=node.value,</div>
<div class="line"><span class="lineno">  440</span>            lower_bound=node.children_lower_bound,</div>
<div class="line"><span class="lineno">  441</span>            upper_bound=node.children_upper_bound,</div>
<div class="line"><span class="lineno">  442</span>            allowed_features=node.allowed_features,</div>
<div class="line"><span class="lineno">  443</span>        )</div>
<div class="line"><span class="lineno">  444</span> </div>
<div class="line"><span class="lineno">  445</span>        <span class="keywordflow">if</span> node.split_info.gain &lt;= 0:  <span class="comment"># no valid split</span></div>
<div class="line"><span class="lineno">  446</span>            self._finalize_leaf(node)</div>
<div class="line"><span class="lineno">  447</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  448</span>            heappush(self.splittable_nodes, node)</div>
<div class="line"><span class="lineno">  449</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5661008a8da1224dbf553977641eac93" name="a5661008a8da1224dbf553977641eac93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5661008a8da1224dbf553977641eac93">&#9670;&#160;</a></span>_compute_interactions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower._compute_interactions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute features allowed by interactions to be inherited by child nodes.

Example: Assume constraints [{0, 1}, {1, 2}].
   1      &lt;- Both constraint groups could be applied from now on
  / \
 1   2    &lt;- Left split still fulfills both constraint groups.
/ \ / \      Right split at feature 2 has only group {1, 2} from now on.

LightGBM uses the same logic for overlapping groups. See
https://github.com/microsoft/LightGBM/issues/4481 for details.

Parameters:
----------
node : TreeNode
    A node that might have children. Based on its feature_idx, the interaction
    constraints for possible child nodes are computed.

Returns
-------
allowed_features : ndarray, dtype=uint32
    Indices of features allowed to split for children.
interaction_cst_indices : list of ints
    Indices of the interaction sets that have to be applied on splits of
    child nodes. The fewer sets the stronger the constraint as fewer sets
    contain fewer features.
</pre> <div class="fragment"><div class="line"><span class="lineno">  616</span>    <span class="keyword">def </span>_compute_interactions(self, node):</div>
<div class="line"><span class="lineno">  617</span>        <span class="stringliteral">r&quot;&quot;&quot;Compute features allowed by interactions to be inherited by child nodes.</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">        Example: Assume constraints [{0, 1}, {1, 2}].</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">           1      &lt;- Both constraint groups could be applied from now on</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">          / \</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">         1   2    &lt;- Left split still fulfills both constraint groups.</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">        / \ / \      Right split at feature 2 has only group {1, 2} from now on.</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        LightGBM uses the same logic for overlapping groups. See</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">        https://github.com/microsoft/LightGBM/issues/4481 for details.</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">        Parameters:</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        node : TreeNode</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">            A node that might have children. Based on its feature_idx, the interaction</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">            constraints for possible child nodes are computed.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">        allowed_features : ndarray, dtype=uint32</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">            Indices of features allowed to split for children.</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">        interaction_cst_indices : list of ints</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">            Indices of the interaction sets that have to be applied on splits of</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">            child nodes. The fewer sets the stronger the constraint as fewer sets</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">            contain fewer features.</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  643</span>        <span class="comment"># Note:</span></div>
<div class="line"><span class="lineno">  644</span>        <span class="comment">#  - Case of no interactions is already captured before function call.</span></div>
<div class="line"><span class="lineno">  645</span>        <span class="comment">#  - This is for nodes that are already split and have a</span></div>
<div class="line"><span class="lineno">  646</span>        <span class="comment">#    node.split_info.feature_idx.</span></div>
<div class="line"><span class="lineno">  647</span>        allowed_features = set()</div>
<div class="line"><span class="lineno">  648</span>        interaction_cst_indices = []</div>
<div class="line"><span class="lineno">  649</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> node.interaction_cst_indices:</div>
<div class="line"><span class="lineno">  650</span>            <span class="keywordflow">if</span> node.split_info.feature_idx <span class="keywordflow">in</span> self.interaction_cst[i]:</div>
<div class="line"><span class="lineno">  651</span>                interaction_cst_indices.append(i)</div>
<div class="line"><span class="lineno">  652</span>                allowed_features.update(self.interaction_cst[i])</div>
<div class="line"><span class="lineno">  653</span>        <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">  654</span>            np.fromiter(allowed_features, dtype=np.uint32, count=len(allowed_features)),</div>
<div class="line"><span class="lineno">  655</span>            interaction_cst_indices,</div>
<div class="line"><span class="lineno">  656</span>        )</div>
<div class="line"><span class="lineno">  657</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3de6e7310beaee9aabea0dd0b18b85b0" name="a3de6e7310beaee9aabea0dd0b18b85b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de6e7310beaee9aabea0dd0b18b85b0">&#9670;&#160;</a></span>_finalize_leaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower._finalize_leaf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Make node a leaf of the tree being grown.</pre> <div class="fragment"><div class="line"><span class="lineno">  658</span>    <span class="keyword">def </span>_finalize_leaf(self, node):</div>
<div class="line"><span class="lineno">  659</span>        <span class="stringliteral">&quot;&quot;&quot;Make node a leaf of the tree being grown.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span>        node.is_leaf = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  662</span>        self.finalized_leaves.append(node)</div>
<div class="line"><span class="lineno">  663</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d10173e3342b78dc187aae750eee8cf" name="a9d10173e3342b78dc187aae750eee8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d10173e3342b78dc187aae750eee8cf">&#9670;&#160;</a></span>_finalize_splittable_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower._finalize_splittable_nodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Transform all splittable nodes into leaves.

Used when some constraint is met e.g. maximum number of leaves or
maximum depth.</pre> <div class="fragment"><div class="line"><span class="lineno">  664</span>    <span class="keyword">def </span>_finalize_splittable_nodes(self):</div>
<div class="line"><span class="lineno">  665</span>        <span class="stringliteral">&quot;&quot;&quot;Transform all splittable nodes into leaves.</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">        Used when some constraint is met e.g. maximum number of leaves or</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">        maximum depth.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  669</span>        <span class="keywordflow">while</span> len(self.splittable_nodes) &gt; 0:</div>
<div class="line"><span class="lineno">  670</span>            node = self.splittable_nodes.pop()</div>
<div class="line"><span class="lineno">  671</span>            self._finalize_leaf(node)</div>
<div class="line"><span class="lineno">  672</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aac9e67f6186b5021eed9424cf657663e" name="aac9e67f6186b5021eed9424cf657663e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9e67f6186b5021eed9424cf657663e">&#9670;&#160;</a></span>_intilialize_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower._intilialize_root </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hessians_are_constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Initialize root node and finalize it if needed.</pre> <div class="fragment"><div class="line"><span class="lineno">  380</span>    <span class="keyword">def </span>_intilialize_root(self, gradients, hessians, hessians_are_constant):</div>
<div class="line"><span class="lineno">  381</span>        <span class="stringliteral">&quot;&quot;&quot;Initialize root node and finalize it if needed.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  382</span>        n_samples = self.X_binned.shape[0]</div>
<div class="line"><span class="lineno">  383</span>        depth = 0</div>
<div class="line"><span class="lineno">  384</span>        sum_gradients = sum_parallel(gradients, self.n_threads)</div>
<div class="line"><span class="lineno">  385</span>        <span class="keywordflow">if</span> self.histogram_builder.hessians_are_constant:</div>
<div class="line"><span class="lineno">  386</span>            sum_hessians = hessians[0] * n_samples</div>
<div class="line"><span class="lineno">  387</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  388</span>            sum_hessians = sum_parallel(hessians, self.n_threads)</div>
<div class="line"><span class="lineno">  389</span>        self.root = TreeNode(</div>
<div class="line"><span class="lineno">  390</span>            depth=depth,</div>
<div class="line"><span class="lineno">  391</span>            sample_indices=self.splitter.partition,</div>
<div class="line"><span class="lineno">  392</span>            sum_gradients=sum_gradients,</div>
<div class="line"><span class="lineno">  393</span>            sum_hessians=sum_hessians,</div>
<div class="line"><span class="lineno">  394</span>            value=0,</div>
<div class="line"><span class="lineno">  395</span>        )</div>
<div class="line"><span class="lineno">  396</span> </div>
<div class="line"><span class="lineno">  397</span>        self.root.partition_start = 0</div>
<div class="line"><span class="lineno">  398</span>        self.root.partition_stop = n_samples</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>        <span class="keywordflow">if</span> self.root.n_samples &lt; 2 * self.min_samples_leaf:</div>
<div class="line"><span class="lineno">  401</span>            <span class="comment"># Do not even bother computing any splitting statistics.</span></div>
<div class="line"><span class="lineno">  402</span>            self._finalize_leaf(self.root)</div>
<div class="line"><span class="lineno">  403</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  404</span>        <span class="keywordflow">if</span> sum_hessians &lt; self.splitter.min_hessian_to_split:</div>
<div class="line"><span class="lineno">  405</span>            self._finalize_leaf(self.root)</div>
<div class="line"><span class="lineno">  406</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span>        <span class="keywordflow">if</span> self.interaction_cst <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  409</span>            self.root.interaction_cst_indices = range(len(self.interaction_cst))</div>
<div class="line"><span class="lineno">  410</span>            allowed_features = set().union(*self.interaction_cst)</div>
<div class="line"><span class="lineno">  411</span>            self.root.allowed_features = np.fromiter(</div>
<div class="line"><span class="lineno">  412</span>                allowed_features, dtype=np.uint32, count=len(allowed_features)</div>
<div class="line"><span class="lineno">  413</span>            )</div>
<div class="line"><span class="lineno">  414</span> </div>
<div class="line"><span class="lineno">  415</span>        tic = time()</div>
<div class="line"><span class="lineno">  416</span>        self.root.histograms = self.histogram_builder.compute_histograms_brute(</div>
<div class="line"><span class="lineno">  417</span>            self.root.sample_indices, self.root.allowed_features</div>
<div class="line"><span class="lineno">  418</span>        )</div>
<div class="line"><span class="lineno">  419</span>        self.total_compute_hist_time += time() - tic</div>
<div class="line"><span class="lineno">  420</span> </div>
<div class="line"><span class="lineno">  421</span>        tic = time()</div>
<div class="line"><span class="lineno">  422</span>        self._compute_best_split_and_push(self.root)</div>
<div class="line"><span class="lineno">  423</span>        self.total_find_split_time += time() - tic</div>
<div class="line"><span class="lineno">  424</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa0e15bbf4084c47d77f9393dabc09957" name="aa0e15bbf4084c47d77f9393dabc09957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e15bbf4084c47d77f9393dabc09957">&#9670;&#160;</a></span>_validate_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower._validate_parameters </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X_binned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_gain_to_split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_hessian_to_split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validate parameters passed to __init__.

Also validate parameters passed to splitter.
</pre> <div class="fragment"><div class="line"><span class="lineno">  340</span>    ):</div>
<div class="line"><span class="lineno">  341</span>        <span class="stringliteral">&quot;&quot;&quot;Validate parameters passed to __init__.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">        Also validate parameters passed to splitter.</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  345</span>        <span class="keywordflow">if</span> X_binned.dtype != np.uint8:</div>
<div class="line"><span class="lineno">  346</span>            <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;X_binned must be of type uint8.&quot;</span>)</div>
<div class="line"><span class="lineno">  347</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> X_binned.flags.f_contiguous:</div>
<div class="line"><span class="lineno">  348</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  349</span>                <span class="stringliteral">&quot;X_binned should be passed as Fortran contiguous &quot;</span></div>
<div class="line"><span class="lineno">  350</span>                <span class="stringliteral">&quot;array for maximum efficiency.&quot;</span></div>
<div class="line"><span class="lineno">  351</span>            )</div>
<div class="line"><span class="lineno">  352</span>        <span class="keywordflow">if</span> min_gain_to_split &lt; 0:</div>
<div class="line"><span class="lineno">  353</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  354</span>                <span class="stringliteral">&quot;min_gain_to_split={} must be positive.&quot;</span>.format(min_gain_to_split)</div>
<div class="line"><span class="lineno">  355</span>            )</div>
<div class="line"><span class="lineno">  356</span>        <span class="keywordflow">if</span> min_hessian_to_split &lt; 0:</div>
<div class="line"><span class="lineno">  357</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  358</span>                <span class="stringliteral">&quot;min_hessian_to_split={} must be positive.&quot;</span>.format(min_hessian_to_split)</div>
<div class="line"><span class="lineno">  359</span>            )</div>
<div class="line"><span class="lineno">  360</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4bd539b9dd6f2480ffad98a22cee0790" name="a4bd539b9dd6f2480ffad98a22cee0790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd539b9dd6f2480ffad98a22cee0790">&#9670;&#160;</a></span>grow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.grow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Grow the tree, from root to leaves.</pre> <div class="fragment"><div class="line"><span class="lineno">  361</span>    <span class="keyword">def </span>grow(self):</div>
<div class="line"><span class="lineno">  362</span>        <span class="stringliteral">&quot;&quot;&quot;Grow the tree, from root to leaves.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  363</span>        <span class="keywordflow">while</span> self.splittable_nodes:</div>
<div class="line"><span class="lineno">  364</span>            self.split_next()</div>
<div class="line"><span class="lineno">  365</span> </div>
<div class="line"><span class="lineno">  366</span>        self._apply_shrinkage()</div>
<div class="line"><span class="lineno">  367</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c4ebae417f9d66674fcba654582a009" name="a6c4ebae417f9d66674fcba654582a009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4ebae417f9d66674fcba654582a009">&#9670;&#160;</a></span>make_predictor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.make_predictor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>binning_thresholds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a TreePredictor object out of the current tree.

Parameters
----------
binning_thresholds : array-like of floats
    Corresponds to the bin_thresholds_ attribute of the BinMapper.
    For each feature, this stores:

    - the bin frontiers for continuous features
    - the unique raw category values for categorical features

Returns
-------
A TreePredictor object.
</pre> <div class="fragment"><div class="line"><span class="lineno">  673</span>    <span class="keyword">def </span>make_predictor(self, binning_thresholds):</div>
<div class="line"><span class="lineno">  674</span>        <span class="stringliteral">&quot;&quot;&quot;Make a TreePredictor object out of the current tree.</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">        binning_thresholds : array-like of floats</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">            Corresponds to the bin_thresholds_ attribute of the BinMapper.</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">            For each feature, this stores:</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">            - the bin frontiers for continuous features</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">            - the unique raw category values for categorical features</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        A TreePredictor object.</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  689</span>        predictor_nodes = np.zeros(self.n_nodes, dtype=PREDICTOR_RECORD_DTYPE)</div>
<div class="line"><span class="lineno">  690</span>        binned_left_cat_bitsets = np.zeros(</div>
<div class="line"><span class="lineno">  691</span>            (self.n_categorical_splits, 8), dtype=X_BITSET_INNER_DTYPE</div>
<div class="line"><span class="lineno">  692</span>        )</div>
<div class="line"><span class="lineno">  693</span>        raw_left_cat_bitsets = np.zeros(</div>
<div class="line"><span class="lineno">  694</span>            (self.n_categorical_splits, 8), dtype=X_BITSET_INNER_DTYPE</div>
<div class="line"><span class="lineno">  695</span>        )</div>
<div class="line"><span class="lineno">  696</span>        _fill_predictor_arrays(</div>
<div class="line"><span class="lineno">  697</span>            predictor_nodes,</div>
<div class="line"><span class="lineno">  698</span>            binned_left_cat_bitsets,</div>
<div class="line"><span class="lineno">  699</span>            raw_left_cat_bitsets,</div>
<div class="line"><span class="lineno">  700</span>            self.root,</div>
<div class="line"><span class="lineno">  701</span>            binning_thresholds,</div>
<div class="line"><span class="lineno">  702</span>            self.n_bins_non_missing,</div>
<div class="line"><span class="lineno">  703</span>        )</div>
<div class="line"><span class="lineno">  704</span>        <span class="keywordflow">return</span> TreePredictor(</div>
<div class="line"><span class="lineno">  705</span>            predictor_nodes, binned_left_cat_bitsets, raw_left_cat_bitsets</div>
<div class="line"><span class="lineno">  706</span>        )</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f2e2a2481a65930ddeee59022ce1e3b" name="a3f2e2a2481a65930ddeee59022ce1e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2e2a2481a65930ddeee59022ce1e3b">&#9670;&#160;</a></span>split_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.split_next </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Split the node with highest potential gain.

Returns
-------
left : TreeNode
    The resulting left child.
right : TreeNode
    The resulting right child.
</pre> <div class="fragment"><div class="line"><span class="lineno">  450</span>    <span class="keyword">def </span>split_next(self):</div>
<div class="line"><span class="lineno">  451</span>        <span class="stringliteral">&quot;&quot;&quot;Split the node with highest potential gain.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">        left : TreeNode</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">            The resulting left child.</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">        right : TreeNode</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">            The resulting right child.</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  460</span>        <span class="comment"># Consider the node with the highest loss reduction (a.k.a. gain)</span></div>
<div class="line"><span class="lineno">  461</span>        node = heappop(self.splittable_nodes)</div>
<div class="line"><span class="lineno">  462</span> </div>
<div class="line"><span class="lineno">  463</span>        tic = time()</div>
<div class="line"><span class="lineno">  464</span>        (</div>
<div class="line"><span class="lineno">  465</span>            sample_indices_left,</div>
<div class="line"><span class="lineno">  466</span>            sample_indices_right,</div>
<div class="line"><span class="lineno">  467</span>            right_child_pos,</div>
<div class="line"><span class="lineno">  468</span>        ) = self.splitter.split_indices(node.split_info, node.sample_indices)</div>
<div class="line"><span class="lineno">  469</span>        self.total_apply_split_time += time() - tic</div>
<div class="line"><span class="lineno">  470</span> </div>
<div class="line"><span class="lineno">  471</span>        depth = node.depth + 1</div>
<div class="line"><span class="lineno">  472</span>        n_leaf_nodes = len(self.finalized_leaves) + len(self.splittable_nodes)</div>
<div class="line"><span class="lineno">  473</span>        n_leaf_nodes += 2</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span>        left_child_node = TreeNode(</div>
<div class="line"><span class="lineno">  476</span>            depth,</div>
<div class="line"><span class="lineno">  477</span>            sample_indices_left,</div>
<div class="line"><span class="lineno">  478</span>            node.split_info.sum_gradient_left,</div>
<div class="line"><span class="lineno">  479</span>            node.split_info.sum_hessian_left,</div>
<div class="line"><span class="lineno">  480</span>            value=node.split_info.value_left,</div>
<div class="line"><span class="lineno">  481</span>        )</div>
<div class="line"><span class="lineno">  482</span>        right_child_node = TreeNode(</div>
<div class="line"><span class="lineno">  483</span>            depth,</div>
<div class="line"><span class="lineno">  484</span>            sample_indices_right,</div>
<div class="line"><span class="lineno">  485</span>            node.split_info.sum_gradient_right,</div>
<div class="line"><span class="lineno">  486</span>            node.split_info.sum_hessian_right,</div>
<div class="line"><span class="lineno">  487</span>            value=node.split_info.value_right,</div>
<div class="line"><span class="lineno">  488</span>        )</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>        node.right_child = right_child_node</div>
<div class="line"><span class="lineno">  491</span>        node.left_child = left_child_node</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>        <span class="comment"># set start and stop indices</span></div>
<div class="line"><span class="lineno">  494</span>        left_child_node.partition_start = node.partition_start</div>
<div class="line"><span class="lineno">  495</span>        left_child_node.partition_stop = node.partition_start + right_child_pos</div>
<div class="line"><span class="lineno">  496</span>        right_child_node.partition_start = left_child_node.partition_stop</div>
<div class="line"><span class="lineno">  497</span>        right_child_node.partition_stop = node.partition_stop</div>
<div class="line"><span class="lineno">  498</span> </div>
<div class="line"><span class="lineno">  499</span>        <span class="comment"># set interaction constraints (the indices of the constraints sets)</span></div>
<div class="line"><span class="lineno">  500</span>        <span class="keywordflow">if</span> self.interaction_cst <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  501</span>            <span class="comment"># Calculate allowed_features and interaction_cst_indices only once. Child</span></div>
<div class="line"><span class="lineno">  502</span>            <span class="comment"># nodes inherit them before they get split.</span></div>
<div class="line"><span class="lineno">  503</span>            (</div>
<div class="line"><span class="lineno">  504</span>                left_child_node.allowed_features,</div>
<div class="line"><span class="lineno">  505</span>                left_child_node.interaction_cst_indices,</div>
<div class="line"><span class="lineno">  506</span>            ) = self._compute_interactions(node)</div>
<div class="line"><span class="lineno">  507</span>            right_child_node.interaction_cst_indices = (</div>
<div class="line"><span class="lineno">  508</span>                left_child_node.interaction_cst_indices</div>
<div class="line"><span class="lineno">  509</span>            )</div>
<div class="line"><span class="lineno">  510</span>            right_child_node.allowed_features = left_child_node.allowed_features</div>
<div class="line"><span class="lineno">  511</span> </div>
<div class="line"><span class="lineno">  512</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.has_missing_values[node.split_info.feature_idx]:</div>
<div class="line"><span class="lineno">  513</span>            <span class="comment"># If no missing values are encountered at fit time, then samples</span></div>
<div class="line"><span class="lineno">  514</span>            <span class="comment"># with missing values during predict() will go to whichever child</span></div>
<div class="line"><span class="lineno">  515</span>            <span class="comment"># has the most samples.</span></div>
<div class="line"><span class="lineno">  516</span>            node.split_info.missing_go_to_left = (</div>
<div class="line"><span class="lineno">  517</span>                left_child_node.n_samples &gt; right_child_node.n_samples</div>
<div class="line"><span class="lineno">  518</span>            )</div>
<div class="line"><span class="lineno">  519</span> </div>
<div class="line"><span class="lineno">  520</span>        self.n_nodes += 2</div>
<div class="line"><span class="lineno">  521</span>        self.n_categorical_splits += node.split_info.is_categorical</div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span>        <span class="keywordflow">if</span> self.max_leaf_nodes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> n_leaf_nodes == self.max_leaf_nodes:</div>
<div class="line"><span class="lineno">  524</span>            self._finalize_leaf(left_child_node)</div>
<div class="line"><span class="lineno">  525</span>            self._finalize_leaf(right_child_node)</div>
<div class="line"><span class="lineno">  526</span>            self._finalize_splittable_nodes()</div>
<div class="line"><span class="lineno">  527</span>            <span class="keywordflow">return</span> left_child_node, right_child_node</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>        <span class="keywordflow">if</span> self.max_depth <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> depth == self.max_depth:</div>
<div class="line"><span class="lineno">  530</span>            self._finalize_leaf(left_child_node)</div>
<div class="line"><span class="lineno">  531</span>            self._finalize_leaf(right_child_node)</div>
<div class="line"><span class="lineno">  532</span>            <span class="keywordflow">return</span> left_child_node, right_child_node</div>
<div class="line"><span class="lineno">  533</span> </div>
<div class="line"><span class="lineno">  534</span>        <span class="keywordflow">if</span> left_child_node.n_samples &lt; self.min_samples_leaf * 2:</div>
<div class="line"><span class="lineno">  535</span>            self._finalize_leaf(left_child_node)</div>
<div class="line"><span class="lineno">  536</span>        <span class="keywordflow">if</span> right_child_node.n_samples &lt; self.min_samples_leaf * 2:</div>
<div class="line"><span class="lineno">  537</span>            self._finalize_leaf(right_child_node)</div>
<div class="line"><span class="lineno">  538</span> </div>
<div class="line"><span class="lineno">  539</span>        <span class="keywordflow">if</span> self.with_monotonic_cst:</div>
<div class="line"><span class="lineno">  540</span>            <span class="comment"># Set value bounds for respecting monotonic constraints</span></div>
<div class="line"><span class="lineno">  541</span>            <span class="comment"># See test_nodes_values() for details</span></div>
<div class="line"><span class="lineno">  542</span>            <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  543</span>                self.monotonic_cst[node.split_info.feature_idx]</div>
<div class="line"><span class="lineno">  544</span>                == MonotonicConstraint.NO_CST</div>
<div class="line"><span class="lineno">  545</span>            ):</div>
<div class="line"><span class="lineno">  546</span>                lower_left = lower_right = node.children_lower_bound</div>
<div class="line"><span class="lineno">  547</span>                upper_left = upper_right = node.children_upper_bound</div>
<div class="line"><span class="lineno">  548</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  549</span>                mid = (left_child_node.value + right_child_node.value) / 2</div>
<div class="line"><span class="lineno">  550</span>                <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  551</span>                    self.monotonic_cst[node.split_info.feature_idx]</div>
<div class="line"><span class="lineno">  552</span>                    == MonotonicConstraint.POS</div>
<div class="line"><span class="lineno">  553</span>                ):</div>
<div class="line"><span class="lineno">  554</span>                    lower_left, upper_left = node.children_lower_bound, mid</div>
<div class="line"><span class="lineno">  555</span>                    lower_right, upper_right = mid, node.children_upper_bound</div>
<div class="line"><span class="lineno">  556</span>                <span class="keywordflow">else</span>:  <span class="comment"># NEG</span></div>
<div class="line"><span class="lineno">  557</span>                    lower_left, upper_left = mid, node.children_upper_bound</div>
<div class="line"><span class="lineno">  558</span>                    lower_right, upper_right = node.children_lower_bound, mid</div>
<div class="line"><span class="lineno">  559</span>            left_child_node.set_children_bounds(lower_left, upper_left)</div>
<div class="line"><span class="lineno">  560</span>            right_child_node.set_children_bounds(lower_right, upper_right)</div>
<div class="line"><span class="lineno">  561</span> </div>
<div class="line"><span class="lineno">  562</span>        <span class="comment"># Compute histograms of children, and compute their best possible split</span></div>
<div class="line"><span class="lineno">  563</span>        <span class="comment"># (if needed)</span></div>
<div class="line"><span class="lineno">  564</span>        should_split_left = <span class="keywordflow">not</span> left_child_node.is_leaf</div>
<div class="line"><span class="lineno">  565</span>        should_split_right = <span class="keywordflow">not</span> right_child_node.is_leaf</div>
<div class="line"><span class="lineno">  566</span>        <span class="keywordflow">if</span> should_split_left <span class="keywordflow">or</span> should_split_right:</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>            <span class="comment"># We will compute the histograms of both nodes even if one of them</span></div>
<div class="line"><span class="lineno">  569</span>            <span class="comment"># is a leaf, since computing the second histogram is very cheap</span></div>
<div class="line"><span class="lineno">  570</span>            <span class="comment"># (using histogram subtraction).</span></div>
<div class="line"><span class="lineno">  571</span>            n_samples_left = left_child_node.sample_indices.shape[0]</div>
<div class="line"><span class="lineno">  572</span>            n_samples_right = right_child_node.sample_indices.shape[0]</div>
<div class="line"><span class="lineno">  573</span>            <span class="keywordflow">if</span> n_samples_left &lt; n_samples_right:</div>
<div class="line"><span class="lineno">  574</span>                smallest_child = left_child_node</div>
<div class="line"><span class="lineno">  575</span>                largest_child = right_child_node</div>
<div class="line"><span class="lineno">  576</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  577</span>                smallest_child = right_child_node</div>
<div class="line"><span class="lineno">  578</span>                largest_child = left_child_node</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span>            <span class="comment"># We use the brute O(n_samples) method on the child that has the</span></div>
<div class="line"><span class="lineno">  581</span>            <span class="comment"># smallest number of samples, and the subtraction trick O(n_bins)</span></div>
<div class="line"><span class="lineno">  582</span>            <span class="comment"># on the other one.</span></div>
<div class="line"><span class="lineno">  583</span>            <span class="comment"># Note that both left and right child have the same allowed_features.</span></div>
<div class="line"><span class="lineno">  584</span>            tic = time()</div>
<div class="line"><span class="lineno">  585</span>            smallest_child.histograms = self.histogram_builder.compute_histograms_brute(</div>
<div class="line"><span class="lineno">  586</span>                smallest_child.sample_indices, smallest_child.allowed_features</div>
<div class="line"><span class="lineno">  587</span>            )</div>
<div class="line"><span class="lineno">  588</span>            largest_child.histograms = (</div>
<div class="line"><span class="lineno">  589</span>                self.histogram_builder.compute_histograms_subtraction(</div>
<div class="line"><span class="lineno">  590</span>                    node.histograms,</div>
<div class="line"><span class="lineno">  591</span>                    smallest_child.histograms,</div>
<div class="line"><span class="lineno">  592</span>                    smallest_child.allowed_features,</div>
<div class="line"><span class="lineno">  593</span>                )</div>
<div class="line"><span class="lineno">  594</span>            )</div>
<div class="line"><span class="lineno">  595</span>            self.total_compute_hist_time += time() - tic</div>
<div class="line"><span class="lineno">  596</span> </div>
<div class="line"><span class="lineno">  597</span>            tic = time()</div>
<div class="line"><span class="lineno">  598</span>            <span class="keywordflow">if</span> should_split_left:</div>
<div class="line"><span class="lineno">  599</span>                self._compute_best_split_and_push(left_child_node)</div>
<div class="line"><span class="lineno">  600</span>            <span class="keywordflow">if</span> should_split_right:</div>
<div class="line"><span class="lineno">  601</span>                self._compute_best_split_and_push(right_child_node)</div>
<div class="line"><span class="lineno">  602</span>            self.total_find_split_time += time() - tic</div>
<div class="line"><span class="lineno">  603</span> </div>
<div class="line"><span class="lineno">  604</span>            <span class="comment"># Release memory used by histograms as they are no longer needed</span></div>
<div class="line"><span class="lineno">  605</span>            <span class="comment"># for leaf nodes since they won&#39;t be split.</span></div>
<div class="line"><span class="lineno">  606</span>            <span class="keywordflow">for</span> child <span class="keywordflow">in</span> (left_child_node, right_child_node):</div>
<div class="line"><span class="lineno">  607</span>                <span class="keywordflow">if</span> child.is_leaf:</div>
<div class="line"><span class="lineno">  608</span>                    del child.histograms</div>
<div class="line"><span class="lineno">  609</span> </div>
<div class="line"><span class="lineno">  610</span>        <span class="comment"># Release memory used by histograms as they are no longer needed for</span></div>
<div class="line"><span class="lineno">  611</span>        <span class="comment"># internal nodes once children histograms have been computed.</span></div>
<div class="line"><span class="lineno">  612</span>        del node.histograms</div>
<div class="line"><span class="lineno">  613</span> </div>
<div class="line"><span class="lineno">  614</span>        <span class="keywordflow">return</span> left_child_node, right_child_node</div>
<div class="line"><span class="lineno">  615</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abf1d9de78f3c9bbbdd7759dfc604902b" name="abf1d9de78f3c9bbbdd7759dfc604902b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1d9de78f3c9bbbdd7759dfc604902b">&#9670;&#160;</a></span>finalized_leaves</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.finalized_leaves</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d94e2ec02a37c92f98231aca536a713" name="a6d94e2ec02a37c92f98231aca536a713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d94e2ec02a37c92f98231aca536a713">&#9670;&#160;</a></span>has_missing_values</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.has_missing_values</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8030235233d3bf7f48fb4de32d075f6c" name="a8030235233d3bf7f48fb4de32d075f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8030235233d3bf7f48fb4de32d075f6c">&#9670;&#160;</a></span>histogram_builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.histogram_builder</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3cb30f6b8c0f8fac68f81105070978d" name="ab3cb30f6b8c0f8fac68f81105070978d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cb30f6b8c0f8fac68f81105070978d">&#9670;&#160;</a></span>interaction_cst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.interaction_cst</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1a5bdc68bd2e1ce3b365c4755f3f8ee" name="ad1a5bdc68bd2e1ce3b365c4755f3f8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a5bdc68bd2e1ce3b365c4755f3f8ee">&#9670;&#160;</a></span>is_categorical</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.is_categorical</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9680731084b0dae78744089bc6795ea4" name="a9680731084b0dae78744089bc6795ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9680731084b0dae78744089bc6795ea4">&#9670;&#160;</a></span>l2_regularization</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.l2_regularization</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ee0a782d7a6bb1305a75139cb309146" name="a3ee0a782d7a6bb1305a75139cb309146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee0a782d7a6bb1305a75139cb309146">&#9670;&#160;</a></span>max_depth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.max_depth</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae63f70b5cf8ece75596428281f02fd8" name="aae63f70b5cf8ece75596428281f02fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae63f70b5cf8ece75596428281f02fd8">&#9670;&#160;</a></span>max_leaf_nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.max_leaf_nodes</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47818d5ff59e49a16e099375911e2b20" name="a47818d5ff59e49a16e099375911e2b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47818d5ff59e49a16e099375911e2b20">&#9670;&#160;</a></span>min_gain_to_split</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.min_gain_to_split</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaba7f2c606aabb87a6ddc17acf94a271" name="aaba7f2c606aabb87a6ddc17acf94a271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba7f2c606aabb87a6ddc17acf94a271">&#9670;&#160;</a></span>min_samples_leaf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.min_samples_leaf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ee0124202e9f19ef1d9a6c6c016e018" name="a0ee0124202e9f19ef1d9a6c6c016e018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee0124202e9f19ef1d9a6c6c016e018">&#9670;&#160;</a></span>missing_values_bin_idx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.missing_values_bin_idx</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c253d487b7c6e622ece0ad7006e7589" name="a6c253d487b7c6e622ece0ad7006e7589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c253d487b7c6e622ece0ad7006e7589">&#9670;&#160;</a></span>monotonic_cst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.monotonic_cst</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb0c2abfb62e5315538c76623ee705d1" name="abb0c2abfb62e5315538c76623ee705d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0c2abfb62e5315538c76623ee705d1">&#9670;&#160;</a></span>n_bins_non_missing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.n_bins_non_missing</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07bb1a04f1d902c99579652e296c59c4" name="a07bb1a04f1d902c99579652e296c59c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bb1a04f1d902c99579652e296c59c4">&#9670;&#160;</a></span>n_categorical_splits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.n_categorical_splits</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a960d67537b50a075aefd8c485a3913" name="a8a960d67537b50a075aefd8c485a3913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a960d67537b50a075aefd8c485a3913">&#9670;&#160;</a></span>n_features</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.n_features</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cdc776724c394104a94d7d19a7dba69" name="a0cdc776724c394104a94d7d19a7dba69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdc776724c394104a94d7d19a7dba69">&#9670;&#160;</a></span>n_nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.n_nodes</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc88af4ec5eaec728cb5c946fbfc92d4" name="adc88af4ec5eaec728cb5c946fbfc92d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc88af4ec5eaec728cb5c946fbfc92d4">&#9670;&#160;</a></span>n_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.n_threads</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6a46cce61e95fbdf63f21aa9794449d" name="ad6a46cce61e95fbdf63f21aa9794449d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a46cce61e95fbdf63f21aa9794449d">&#9670;&#160;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.root</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a499a564d8be08b6e1b5fd73f8ea110d7" name="a499a564d8be08b6e1b5fd73f8ea110d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499a564d8be08b6e1b5fd73f8ea110d7">&#9670;&#160;</a></span>shrinkage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.shrinkage</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65773c34c03afde92738ec51151acbe8" name="a65773c34c03afde92738ec51151acbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65773c34c03afde92738ec51151acbe8">&#9670;&#160;</a></span>splittable_nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.splittable_nodes</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6ff86f349380a192b2412deb911beda" name="ae6ff86f349380a192b2412deb911beda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ff86f349380a192b2412deb911beda">&#9670;&#160;</a></span>splitter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.splitter</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf77375a6ee84d28301040299a15fc9d" name="adf77375a6ee84d28301040299a15fc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf77375a6ee84d28301040299a15fc9d">&#9670;&#160;</a></span>total_apply_split_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.total_apply_split_time</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2920b82ceff65dd098d21ba756802135" name="a2920b82ceff65dd098d21ba756802135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2920b82ceff65dd098d21ba756802135">&#9670;&#160;</a></span>total_compute_hist_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.total_compute_hist_time</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65a3a99bcb089565d9c47cddc666b754" name="a65a3a99bcb089565d9c47cddc666b754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a3a99bcb089565d9c47cddc666b754">&#9670;&#160;</a></span>total_find_split_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.total_find_split_time</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e62bb82bf21952c67362d41ad96200f" name="a2e62bb82bf21952c67362d41ad96200f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e62bb82bf21952c67362d41ad96200f">&#9670;&#160;</a></span>with_monotonic_cst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.with_monotonic_cst</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a093223b3f0f7f9761c3e2068fd53422e" name="a093223b3f0f7f9761c3e2068fd53422e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093223b3f0f7f9761c3e2068fd53422e">&#9670;&#160;</a></span>X_binned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.ensemble._hist_gradient_boosting.grower.TreeGrower.X_binned</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/sklearn/ensemble/_hist_gradient_boosting/<a class="el" href="grower_8py.html">grower.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
