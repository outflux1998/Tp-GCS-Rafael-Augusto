<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: smart_open.bytebuffer.ByteBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesmart__open.html">smart_open</a></li><li class="navelem"><a class="el" href="namespacesmart__open_1_1bytebuffer.html">bytebuffer</a></li><li class="navelem"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html">ByteBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsmart__open_1_1bytebuffer_1_1_byte_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">smart_open.bytebuffer.ByteBuffer Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for smart_open.bytebuffer.ByteBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsmart__open_1_1bytebuffer_1_1_byte_buffer.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f7ef9e1019c77b39a5e46f6bbdfb7c5" id="r_a0f7ef9e1019c77b39a5e46f6bbdfb7c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a0f7ef9e1019c77b39a5e46f6bbdfb7c5">__init__</a> (self, chunk_size=io.DEFAULT_BUFFER_SIZE)</td></tr>
<tr class="separator:a0f7ef9e1019c77b39a5e46f6bbdfb7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956ac7a06925e28090847701469b18e2" id="r_a956ac7a06925e28090847701469b18e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a956ac7a06925e28090847701469b18e2">__len__</a> (self)</td></tr>
<tr class="separator:a956ac7a06925e28090847701469b18e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c65917cf2e94aa77d7fefa77f09e7c3" id="r_a4c65917cf2e94aa77d7fefa77f09e7c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a4c65917cf2e94aa77d7fefa77f09e7c3">read</a> (self, size=-1)</td></tr>
<tr class="separator:a4c65917cf2e94aa77d7fefa77f09e7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cac9f61dc02807869c8bc818227a20" id="r_a46cac9f61dc02807869c8bc818227a20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a46cac9f61dc02807869c8bc818227a20">peek</a> (self, size=-1)</td></tr>
<tr class="separator:a46cac9f61dc02807869c8bc818227a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82aaa1f7a98479eb86745813da098c35" id="r_a82aaa1f7a98479eb86745813da098c35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a82aaa1f7a98479eb86745813da098c35">empty</a> (self)</td></tr>
<tr class="separator:a82aaa1f7a98479eb86745813da098c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1396cc599d24b8371a0394eca6a703" id="r_abc1396cc599d24b8371a0394eca6a703"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#abc1396cc599d24b8371a0394eca6a703">fill</a> (self, source, size=-1)</td></tr>
<tr class="separator:abc1396cc599d24b8371a0394eca6a703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a899d67b52fa9cabd9e058c7c5df31" id="r_a25a899d67b52fa9cabd9e058c7c5df31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a25a899d67b52fa9cabd9e058c7c5df31">readline</a> (self, terminator)</td></tr>
<tr class="separator:a25a899d67b52fa9cabd9e058c7c5df31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1c5550981fcdb887ef3205a669333c75" id="r_a1c5550981fcdb887ef3205a669333c75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a1c5550981fcdb887ef3205a669333c75">_chunk_size</a></td></tr>
<tr class="separator:a1c5550981fcdb887ef3205a669333c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563cfbd1d42af109c9d4cdb50db7e30d" id="r_a563cfbd1d42af109c9d4cdb50db7e30d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#a563cfbd1d42af109c9d4cdb50db7e30d">_bytes</a></td></tr>
<tr class="separator:a563cfbd1d42af109c9d4cdb50db7e30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49ffba3fca778275d1fde7a220aa993" id="r_aa49ffba3fca778275d1fde7a220aa993"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmart__open_1_1bytebuffer_1_1_byte_buffer.html#aa49ffba3fca778275d1fde7a220aa993">_pos</a></td></tr>
<tr class="separator:aa49ffba3fca778275d1fde7a220aa993"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Implements a byte buffer that allows callers to read data with minimal
copying, and has a fast __len__ method. The buffer is parametrized by its
chunk_size, which is the number of bytes that it will read in from the
supplied reader or iterable when the buffer is being filled. As primary use
case for this buffer is to amortize the overhead costs of transferring data
over the network (rather than capping memory consumption), it leads to more
predictable performance to always read the same amount of bytes each time
the buffer is filled, hence the chunk_size parameter instead of some fixed
capacity.

The bytes are stored in a bytestring, and previously-read bytes are freed
when the buffer is next filled (by slicing the bytestring into a smaller
copy).

Example
-------

Note that while this example works in both Python 2 and 3, the doctest only
passes in Python 3 due to the bytestring literals in the expected values.

&gt;&gt;&gt; buf = ByteBuffer(chunk_size = 8)
&gt;&gt;&gt; message_bytes = iter([b'Hello, W', b'orld!'])
&gt;&gt;&gt; buf.fill(message_bytes)
8
&gt;&gt;&gt; len(buf) # only chunk_size bytes are filled
8
&gt;&gt;&gt; buf.peek()
b'Hello, W'
&gt;&gt;&gt; len(buf) # peek() does not change read position
8
&gt;&gt;&gt; buf.read(6)
b'Hello,'
&gt;&gt;&gt; len(buf) # read() does change read position
2
&gt;&gt;&gt; buf.fill(message_bytes)
5
&gt;&gt;&gt; buf.read()
b' World!'
&gt;&gt;&gt; len(buf)
0
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0f7ef9e1019c77b39a5e46f6bbdfb7c5" name="a0f7ef9e1019c77b39a5e46f6bbdfb7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7ef9e1019c77b39a5e46f6bbdfb7c5">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>io.DEFAULT_BUFFER_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a ByteBuffer instance that reads chunk_size bytes when filled.
Note that the buffer has no maximum size.

Parameters
-----------
chunk_size: int, optional
    The the number of bytes that will be read from the supplied reader
    or iterable when filling the buffer.
</pre> <div class="fragment"><div class="line"><span class="lineno">   56</span>    <span class="keyword">def </span>__init__(self, chunk_size=io.DEFAULT_BUFFER_SIZE):</div>
<div class="line"><span class="lineno">   57</span>        <span class="stringliteral">&quot;&quot;&quot;Create a ByteBuffer instance that reads chunk_size bytes when filled.</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        Note that the buffer has no maximum size.</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        -----------</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        chunk_size: int, optional</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">            The the number of bytes that will be read from the supplied reader</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">            or iterable when filling the buffer.</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   66</span>        self._chunk_size = chunk_size</div>
<div class="line"><span class="lineno">   67</span>        self.empty()</div>
<div class="line"><span class="lineno">   68</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a956ac7a06925e28090847701469b18e2" name="a956ac7a06925e28090847701469b18e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956ac7a06925e28090847701469b18e2">&#9670;&#160;</a></span>__len__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer.__len__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of unread bytes in the buffer as an int</pre> <div class="fragment"><div class="line"><span class="lineno">   69</span>    <span class="keyword">def </span>__len__(self):</div>
<div class="line"><span class="lineno">   70</span>        <span class="stringliteral">&quot;&quot;&quot;Return the number of unread bytes in the buffer as an int&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   71</span>        <span class="keywordflow">return</span> len(self._bytes) - self._pos</div>
<div class="line"><span class="lineno">   72</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a82aaa1f7a98479eb86745813da098c35" name="a82aaa1f7a98479eb86745813da098c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82aaa1f7a98479eb86745813da098c35">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer.empty </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove all bytes from the buffer</pre> <div class="fragment"><div class="line"><span class="lineno">  111</span>    <span class="keyword">def </span>empty(self):</div>
<div class="line"><span class="lineno">  112</span>        <span class="stringliteral">&quot;&quot;&quot;Remove all bytes from the buffer&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        self._bytes = bytearray()</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        self._pos = 0</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral"></span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abc1396cc599d24b8371a0394eca6a703" name="abc1396cc599d24b8371a0394eca6a703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1396cc599d24b8371a0394eca6a703">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer.fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fill the buffer with bytes from source until one of these
conditions is met:
    * size bytes have been read from source (if size &gt;= 0);
    * chunk_size bytes have been read from source;
    * no more bytes can be read from source;
Returns the number of new bytes added to the buffer.
Note: all previously-read bytes in the buffer are removed.

Parameters
----------
source: a file-like object, or iterable/list that contains bytes
    The source of bytes to fill the buffer with. If this argument has
    the `read` attribute, it's assumed to be a file-like object and
    `read` is called to get the bytes; otherwise it's assumed to be an
    iterable or list that contains bytes, and a for loop is used to get
    the bytes.
size: int, optional
    The number of bytes to try to read from source. If not supplied,
    negative, or larger than the buffer's chunk_size, then chunk_size
    bytes are read. Note that if source is an iterable or list, then
    it's possible that more than size bytes will be read if iterating
    over source produces more than one byte at a time.

Returns
-------
int, the number of new bytes added to the buffer.
</pre> <div class="fragment"><div class="line"><span class="lineno">  116</span>    <span class="keyword">def </span>fill(self, source, size=-1):</div>
<div class="line"><span class="lineno">  117</span>        <span class="stringliteral">&quot;&quot;&quot;Fill the buffer with bytes from source until one of these</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        conditions is met:</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">            * size bytes have been read from source (if size &gt;= 0);</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">            * chunk_size bytes have been read from source;</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">            * no more bytes can be read from source;</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        Returns the number of new bytes added to the buffer.</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">        Note: all previously-read bytes in the buffer are removed.</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        source: a file-like object, or iterable/list that contains bytes</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">            The source of bytes to fill the buffer with. If this argument has</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">            the `read` attribute, it&#39;s assumed to be a file-like object and</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">            `read` is called to get the bytes; otherwise it&#39;s assumed to be an</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">            iterable or list that contains bytes, and a for loop is used to get</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">            the bytes.</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">        size: int, optional</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">            The number of bytes to try to read from source. If not supplied,</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">            negative, or larger than the buffer&#39;s chunk_size, then chunk_size</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">            bytes are read. Note that if source is an iterable or list, then</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">            it&#39;s possible that more than size bytes will be read if iterating</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">            over source produces more than one byte at a time.</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">        int, the number of new bytes added to the buffer.</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  144</span>        size = size <span class="keywordflow">if</span> size &gt;= 0 <span class="keywordflow">else</span> self._chunk_size</div>
<div class="line"><span class="lineno">  145</span>        size = min(size, self._chunk_size)</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>        <span class="keywordflow">if</span> self._pos != 0:</div>
<div class="line"><span class="lineno">  148</span>            self._bytes = self._bytes[self._pos:]</div>
<div class="line"><span class="lineno">  149</span>            self._pos = 0</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">if</span> hasattr(source, <span class="stringliteral">&#39;read&#39;</span>):</div>
<div class="line"><span class="lineno">  152</span>            new_bytes = source.read(size)</div>
<div class="line"><span class="lineno">  153</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  154</span>            new_bytes = bytearray()</div>
<div class="line"><span class="lineno">  155</span>            <span class="keywordflow">for</span> more_bytes <span class="keywordflow">in</span> source:</div>
<div class="line"><span class="lineno">  156</span>                new_bytes += more_bytes</div>
<div class="line"><span class="lineno">  157</span>                <span class="keywordflow">if</span> len(new_bytes) &gt;= size:</div>
<div class="line"><span class="lineno">  158</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>        self._bytes += new_bytes</div>
<div class="line"><span class="lineno">  161</span>        <span class="keywordflow">return</span> len(new_bytes)</div>
<div class="line"><span class="lineno">  162</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a46cac9f61dc02807869c8bc818227a20" name="a46cac9f61dc02807869c8bc818227a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cac9f61dc02807869c8bc818227a20">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer.peek </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get bytes from the buffer without advancing the read position.
Returns the bytes in a bytestring.

Parameters
----------
size: int, optional
    Maximum number of bytes to return. If negative or not supplied,
    return all unread bytes in the buffer.

Returns
-------
bytes
</pre> <div class="fragment"><div class="line"><span class="lineno">   91</span>    <span class="keyword">def </span>peek(self, size=-1):</div>
<div class="line"><span class="lineno">   92</span>        <span class="stringliteral">&quot;&quot;&quot;Get bytes from the buffer without advancing the read position.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        Returns the bytes in a bytestring.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        size: int, optional</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">            Maximum number of bytes to return. If negative or not supplied,</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">            return all unread bytes in the buffer.</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        bytes</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">if</span> size &lt; 0 <span class="keywordflow">or</span> size &gt; len(self):</div>
<div class="line"><span class="lineno">  106</span>            size = len(self)</div>
<div class="line"><span class="lineno">  107</span> </div>
<div class="line"><span class="lineno">  108</span>        part = bytes(self._bytes[self._pos:self._pos+size])</div>
<div class="line"><span class="lineno">  109</span>        <span class="keywordflow">return</span> part</div>
<div class="line"><span class="lineno">  110</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c65917cf2e94aa77d7fefa77f09e7c3" name="a4c65917cf2e94aa77d7fefa77f09e7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c65917cf2e94aa77d7fefa77f09e7c3">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer.read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read bytes from the buffer and advance the read position. Returns
the bytes in a bytestring.

Parameters
----------
size: int, optional
    Maximum number of bytes to read. If negative or not supplied, read
    all unread bytes in the buffer.

Returns
-------
bytes
</pre> <div class="fragment"><div class="line"><span class="lineno">   73</span>    <span class="keyword">def </span>read(self, size=-1):</div>
<div class="line"><span class="lineno">   74</span>        <span class="stringliteral">&quot;&quot;&quot;Read bytes from the buffer and advance the read position. Returns</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        the bytes in a bytestring.</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        size: int, optional</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">            Maximum number of bytes to read. If negative or not supplied, read</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">            all unread bytes in the buffer.</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        bytes</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   87</span>        part = self.peek(size)</div>
<div class="line"><span class="lineno">   88</span>        self._pos += len(part)</div>
<div class="line"><span class="lineno">   89</span>        <span class="keywordflow">return</span> part</div>
<div class="line"><span class="lineno">   90</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a25a899d67b52fa9cabd9e058c7c5df31" name="a25a899d67b52fa9cabd9e058c7c5df31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a899d67b52fa9cabd9e058c7c5df31">&#9670;&#160;</a></span>readline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer.readline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a line from this buffer efficiently.

A line is a contiguous sequence of bytes that ends with either:

1. The ``terminator`` character
2. The end of the buffer itself

:param byte terminator: The line terminator character.
:rtype: bytes</pre> <div class="fragment"><div class="line"><span class="lineno">  163</span>    <span class="keyword">def </span>readline(self, terminator):</div>
<div class="line"><span class="lineno">  164</span>        <span class="stringliteral">&quot;&quot;&quot;Read a line from this buffer efficiently.</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">        A line is a contiguous sequence of bytes that ends with either:</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        1. The ``terminator`` character</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        2. The end of the buffer itself</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        :param byte terminator: The line terminator character.</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        :rtype: bytes</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  175</span>        index = self._bytes.find(terminator, self._pos)</div>
<div class="line"><span class="lineno">  176</span>        <span class="keywordflow">if</span> index == -1:</div>
<div class="line"><span class="lineno">  177</span>            size = len(self)</div>
<div class="line"><span class="lineno">  178</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  179</span>            size = index - self._pos + 1</div>
<div class="line"><span class="lineno">  180</span>        <span class="keywordflow">return</span> self.read(size)</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a563cfbd1d42af109c9d4cdb50db7e30d" name="a563cfbd1d42af109c9d4cdb50db7e30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563cfbd1d42af109c9d4cdb50db7e30d">&#9670;&#160;</a></span>_bytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer._bytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5550981fcdb887ef3205a669333c75" name="a1c5550981fcdb887ef3205a669333c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5550981fcdb887ef3205a669333c75">&#9670;&#160;</a></span>_chunk_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer._chunk_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa49ffba3fca778275d1fde7a220aa993" name="aa49ffba3fca778275d1fde7a220aa993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49ffba3fca778275d1fde7a220aa993">&#9670;&#160;</a></span>_pos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">smart_open.bytebuffer.ByteBuffer._pos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/smart_open/<a class="el" href="bytebuffer_8py.html">bytebuffer.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
