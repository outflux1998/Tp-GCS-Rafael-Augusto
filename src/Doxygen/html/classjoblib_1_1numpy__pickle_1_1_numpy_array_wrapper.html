<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: joblib.numpy_pickle.NumpyArrayWrapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejoblib.html">joblib</a></li><li class="navelem"><a class="el" href="namespacejoblib_1_1numpy__pickle.html">numpy_pickle</a></li><li class="navelem"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html">NumpyArrayWrapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">joblib.numpy_pickle.NumpyArrayWrapper Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for joblib.numpy_pickle.NumpyArrayWrapper:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28bd32fd41961052b14603f38b1cafc1" id="r_a28bd32fd41961052b14603f38b1cafc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a28bd32fd41961052b14603f38b1cafc1">__init__</a> (self, <a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a489c4ca8d74e6d242ee2f6bef86b798d">subclass</a>, <a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a4be6eeee53a69bd192094ee379f51f00">shape</a>, <a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a51c09c86d7987be168f4dc151f9596ca">order</a>, <a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a19ea505b7e50f883d8233999fd9430b7">dtype</a>, <a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a8c75ff07473accaa5663067c84737cf8">allow_mmap</a>=False, <a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a298c8605ee086721723e0bc72091b489">numpy_array_alignment_bytes</a>=<a class="el" href="namespacejoblib_1_1numpy__pickle.html#ad6d3badf88f2c018e22355eecb2579d8">NUMPY_ARRAY_ALIGNMENT_BYTES</a>)</td></tr>
<tr class="separator:a28bd32fd41961052b14603f38b1cafc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef1ee41e9ee4d84305b74523c167dc6" id="r_a7ef1ee41e9ee4d84305b74523c167dc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a7ef1ee41e9ee4d84305b74523c167dc6">safe_get_numpy_array_alignment_bytes</a> (self)</td></tr>
<tr class="separator:a7ef1ee41e9ee4d84305b74523c167dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e60313e271460e9524d3ce0c2b57ba7" id="r_a6e60313e271460e9524d3ce0c2b57ba7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a6e60313e271460e9524d3ce0c2b57ba7">write_array</a> (self, array, pickler)</td></tr>
<tr class="separator:a6e60313e271460e9524d3ce0c2b57ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b606e63567069c831a551e0844b6b1" id="r_ad5b606e63567069c831a551e0844b6b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#ad5b606e63567069c831a551e0844b6b1">read_array</a> (self, unpickler)</td></tr>
<tr class="separator:ad5b606e63567069c831a551e0844b6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4393679e50d11b0fd7d2e73066810d07" id="r_a4393679e50d11b0fd7d2e73066810d07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a4393679e50d11b0fd7d2e73066810d07">read_mmap</a> (self, unpickler)</td></tr>
<tr class="separator:a4393679e50d11b0fd7d2e73066810d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0c0ceccc63fb36fb55ffbc3413c3d" id="r_a7ca0c0ceccc63fb36fb55ffbc3413c3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a7ca0c0ceccc63fb36fb55ffbc3413c3d">read</a> (self, unpickler)</td></tr>
<tr class="separator:a7ca0c0ceccc63fb36fb55ffbc3413c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a489c4ca8d74e6d242ee2f6bef86b798d" id="r_a489c4ca8d74e6d242ee2f6bef86b798d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a489c4ca8d74e6d242ee2f6bef86b798d">subclass</a></td></tr>
<tr class="separator:a489c4ca8d74e6d242ee2f6bef86b798d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be6eeee53a69bd192094ee379f51f00" id="r_a4be6eeee53a69bd192094ee379f51f00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a4be6eeee53a69bd192094ee379f51f00">shape</a></td></tr>
<tr class="separator:a4be6eeee53a69bd192094ee379f51f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c09c86d7987be168f4dc151f9596ca" id="r_a51c09c86d7987be168f4dc151f9596ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a51c09c86d7987be168f4dc151f9596ca">order</a></td></tr>
<tr class="separator:a51c09c86d7987be168f4dc151f9596ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ea505b7e50f883d8233999fd9430b7" id="r_a19ea505b7e50f883d8233999fd9430b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a19ea505b7e50f883d8233999fd9430b7">dtype</a></td></tr>
<tr class="separator:a19ea505b7e50f883d8233999fd9430b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c75ff07473accaa5663067c84737cf8" id="r_a8c75ff07473accaa5663067c84737cf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a8c75ff07473accaa5663067c84737cf8">allow_mmap</a></td></tr>
<tr class="separator:a8c75ff07473accaa5663067c84737cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298c8605ee086721723e0bc72091b489" id="r_a298c8605ee086721723e0bc72091b489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjoblib_1_1numpy__pickle_1_1_numpy_array_wrapper.html#a298c8605ee086721723e0bc72091b489">numpy_array_alignment_bytes</a></td></tr>
<tr class="separator:a298c8605ee086721723e0bc72091b489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">An object to be persisted instead of numpy arrays.

This object is used to hack into the pickle machinery and read numpy
array data from our custom persistence format.
More precisely, this object is used for:
* carrying the information of the persisted array: subclass, shape, order,
dtype. Those ndarray metadata are used to correctly reconstruct the array
with low level numpy functions.
* determining if memmap is allowed on the array.
* reading the array bytes from a file.
* reading the array using memorymap from a file.
* writing the array bytes to a file.

Attributes
----------
subclass: numpy.ndarray subclass
    Determine the subclass of the wrapped array.
shape: numpy.ndarray shape
    Determine the shape of the wrapped array.
order: {'C', 'F'}
    Determine the order of wrapped array data. 'C' is for C order, 'F' is
    for fortran order.
dtype: numpy.ndarray dtype
    Determine the data type of the wrapped array.
allow_mmap: bool
    Determine if memory mapping is allowed on the wrapped array.
    Default: False.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a28bd32fd41961052b14603f38b1cafc1" name="a28bd32fd41961052b14603f38b1cafc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bd32fd41961052b14603f38b1cafc1">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_mmap</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numpy_array_alignment_bytes</em> = <code><a class="el" href="namespacejoblib_1_1numpy__pickle.html#ad6d3badf88f2c018e22355eecb2579d8">NUMPY_ARRAY_ALIGNMENT_BYTES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Constructor. Store the useful information for later.</pre> <div class="fragment"><div class="line"><span class="lineno">   80</span>                 numpy_array_alignment_bytes=NUMPY_ARRAY_ALIGNMENT_BYTES):</div>
<div class="line"><span class="lineno">   81</span>        <span class="stringliteral">&quot;&quot;&quot;Constructor. Store the useful information for later.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   82</span>        self.subclass = subclass</div>
<div class="line"><span class="lineno">   83</span>        self.shape = shape</div>
<div class="line"><span class="lineno">   84</span>        self.order = order</div>
<div class="line"><span class="lineno">   85</span>        self.dtype = dtype</div>
<div class="line"><span class="lineno">   86</span>        self.allow_mmap = allow_mmap</div>
<div class="line"><span class="lineno">   87</span>        <span class="comment"># We make numpy_array_alignment_bytes an instance attribute to allow us</span></div>
<div class="line"><span class="lineno">   88</span>        <span class="comment"># to change our mind about the default alignment and still load the old</span></div>
<div class="line"><span class="lineno">   89</span>        <span class="comment"># pickles (with the previous alignment) correctly</span></div>
<div class="line"><span class="lineno">   90</span>        self.numpy_array_alignment_bytes = numpy_array_alignment_bytes</div>
<div class="line"><span class="lineno">   91</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ca0c0ceccc63fb36fb55ffbc3413c3d" name="a7ca0c0ceccc63fb36fb55ffbc3413c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca0c0ceccc63fb36fb55ffbc3413c3d">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpickler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read the array corresponding to this wrapper.

Use the unpickler to get all information to correctly read the array.

Parameters
----------
unpickler: NumpyUnpickler

Returns
-------
array: numpy.ndarray</pre> <div class="fragment"><div class="line"><span class="lineno">  234</span>    <span class="keyword">def </span>read(self, unpickler):</div>
<div class="line"><span class="lineno">  235</span>        <span class="stringliteral">&quot;&quot;&quot;Read the array corresponding to this wrapper.</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        Use the unpickler to get all information to correctly read the array.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">        unpickler: NumpyUnpickler</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        array: numpy.ndarray</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  248</span>        <span class="comment"># When requested, only use memmap mode if allowed.</span></div>
<div class="line"><span class="lineno">  249</span>        <span class="keywordflow">if</span> unpickler.mmap_mode <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> self.allow_mmap:</div>
<div class="line"><span class="lineno">  250</span>            array = self.read_mmap(unpickler)</div>
<div class="line"><span class="lineno">  251</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  252</span>            array = self.read_array(unpickler)</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>        <span class="comment"># Manage array subclass case</span></div>
<div class="line"><span class="lineno">  255</span>        <span class="keywordflow">if</span> (hasattr(array, <span class="stringliteral">&#39;__array_prepare__&#39;</span>) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  256</span>            self.subclass <span class="keywordflow">not</span> <span class="keywordflow">in</span> (unpickler.np.ndarray,</div>
<div class="line"><span class="lineno">  257</span>                                  unpickler.np.memmap)):</div>
<div class="line"><span class="lineno">  258</span>            <span class="comment"># We need to reconstruct another subclass</span></div>
<div class="line"><span class="lineno">  259</span>            new_array = unpickler.np.core.multiarray._reconstruct(</div>
<div class="line"><span class="lineno">  260</span>                self.subclass, (0,), <span class="stringliteral">&#39;b&#39;</span>)</div>
<div class="line"><span class="lineno">  261</span>            <span class="keywordflow">return</span> new_array.__array_prepare__(array)</div>
<div class="line"><span class="lineno">  262</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  263</span>            <span class="keywordflow">return</span> array</div>
<div class="line"><span class="lineno">  264</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5b606e63567069c831a551e0844b6b1" name="ad5b606e63567069c831a551e0844b6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b606e63567069c831a551e0844b6b1">&#9670;&#160;</a></span>read_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.read_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpickler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read array from unpickler file handle.

This function is an adaptation of the numpy read_array function
available in version 1.10.1 in numpy/lib/format.py.
</pre> <div class="fragment"><div class="line"><span class="lineno">  136</span>    <span class="keyword">def </span>read_array(self, unpickler):</div>
<div class="line"><span class="lineno">  137</span>        <span class="stringliteral">&quot;&quot;&quot;Read array from unpickler file handle.</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        This function is an adaptation of the numpy read_array function</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        available in version 1.10.1 in numpy/lib/format.py.</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  142</span>        <span class="keywordflow">if</span> len(self.shape) == 0:</div>
<div class="line"><span class="lineno">  143</span>            count = 1</div>
<div class="line"><span class="lineno">  144</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  145</span>            <span class="comment"># joblib issue #859: we cast the elements of self.shape to int64 to</span></div>
<div class="line"><span class="lineno">  146</span>            <span class="comment"># prevent a potential overflow when computing their product.</span></div>
<div class="line"><span class="lineno">  147</span>            shape_int64 = [unpickler.np.int64(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> self.shape]</div>
<div class="line"><span class="lineno">  148</span>            count = unpickler.np.multiply.reduce(shape_int64)</div>
<div class="line"><span class="lineno">  149</span>        <span class="comment"># Now read the actual data.</span></div>
<div class="line"><span class="lineno">  150</span>        <span class="keywordflow">if</span> self.dtype.hasobject:</div>
<div class="line"><span class="lineno">  151</span>            <span class="comment"># The array contained Python objects. We need to unpickle the data.</span></div>
<div class="line"><span class="lineno">  152</span>            array = pickle.load(unpickler.file_handle)</div>
<div class="line"><span class="lineno">  153</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  154</span>            numpy_array_alignment_bytes = \</div>
<div class="line"><span class="lineno">  155</span>                self.safe_get_numpy_array_alignment_bytes()</div>
<div class="line"><span class="lineno">  156</span>            <span class="keywordflow">if</span> numpy_array_alignment_bytes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  157</span>                padding_byte = unpickler.file_handle.read(1)</div>
<div class="line"><span class="lineno">  158</span>                padding_length = int.from_bytes(</div>
<div class="line"><span class="lineno">  159</span>                    padding_byte, byteorder=<span class="stringliteral">&#39;little&#39;</span>)</div>
<div class="line"><span class="lineno">  160</span>                <span class="keywordflow">if</span> padding_length != 0:</div>
<div class="line"><span class="lineno">  161</span>                    unpickler.file_handle.read(padding_length)</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>            <span class="comment"># This is not a real file. We have to read it the</span></div>
<div class="line"><span class="lineno">  164</span>            <span class="comment"># memory-intensive way.</span></div>
<div class="line"><span class="lineno">  165</span>            <span class="comment"># crc32 module fails on reads greater than 2 ** 32 bytes,</span></div>
<div class="line"><span class="lineno">  166</span>            <span class="comment"># breaking large reads from gzip streams. Chunk reads to</span></div>
<div class="line"><span class="lineno">  167</span>            <span class="comment"># BUFFER_SIZE bytes to avoid issue and reduce memory overhead</span></div>
<div class="line"><span class="lineno">  168</span>            <span class="comment"># of the read. In non-chunked case count &lt; max_read_count, so</span></div>
<div class="line"><span class="lineno">  169</span>            <span class="comment"># only one read is performed.</span></div>
<div class="line"><span class="lineno">  170</span>            max_read_count = BUFFER_SIZE // min(BUFFER_SIZE,</div>
<div class="line"><span class="lineno">  171</span>                                                self.dtype.itemsize)</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>            array = unpickler.np.empty(count, dtype=self.dtype)</div>
<div class="line"><span class="lineno">  174</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, count, max_read_count):</div>
<div class="line"><span class="lineno">  175</span>                read_count = min(max_read_count, count - i)</div>
<div class="line"><span class="lineno">  176</span>                read_size = int(read_count * self.dtype.itemsize)</div>
<div class="line"><span class="lineno">  177</span>                data = _read_bytes(unpickler.file_handle,</div>
<div class="line"><span class="lineno">  178</span>                                   read_size, <span class="stringliteral">&quot;array data&quot;</span>)</div>
<div class="line"><span class="lineno">  179</span>                array[i:i + read_count] = \</div>
<div class="line"><span class="lineno">  180</span>                    unpickler.np.frombuffer(data, dtype=self.dtype,</div>
<div class="line"><span class="lineno">  181</span>                                            count=read_count)</div>
<div class="line"><span class="lineno">  182</span>                del data</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>            <span class="keywordflow">if</span> self.order == <span class="stringliteral">&#39;F&#39;</span>:</div>
<div class="line"><span class="lineno">  185</span>                array.shape = self.shape[::-1]</div>
<div class="line"><span class="lineno">  186</span>                array = array.transpose()</div>
<div class="line"><span class="lineno">  187</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  188</span>                array.shape = self.shape</div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="line"><span class="lineno">  190</span>        <span class="comment"># Detect byte order mismatch and swap as needed.</span></div>
<div class="line"><span class="lineno">  191</span>        <span class="keywordflow">return</span> _ensure_native_byte_order(array)</div>
<div class="line"><span class="lineno">  192</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4393679e50d11b0fd7d2e73066810d07" name="a4393679e50d11b0fd7d2e73066810d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4393679e50d11b0fd7d2e73066810d07">&#9670;&#160;</a></span>read_mmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.read_mmap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpickler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read an array using numpy memmap.</pre> <div class="fragment"><div class="line"><span class="lineno">  193</span>    <span class="keyword">def </span>read_mmap(self, unpickler):</div>
<div class="line"><span class="lineno">  194</span>        <span class="stringliteral">&quot;&quot;&quot;Read an array using numpy memmap.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  195</span>        current_pos = unpickler.file_handle.tell()</div>
<div class="line"><span class="lineno">  196</span>        offset = current_pos</div>
<div class="line"><span class="lineno">  197</span>        numpy_array_alignment_bytes = \</div>
<div class="line"><span class="lineno">  198</span>            self.safe_get_numpy_array_alignment_bytes()</div>
<div class="line"><span class="lineno">  199</span> </div>
<div class="line"><span class="lineno">  200</span>        <span class="keywordflow">if</span> numpy_array_alignment_bytes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  201</span>            padding_byte = unpickler.file_handle.read(1)</div>
<div class="line"><span class="lineno">  202</span>            padding_length = int.from_bytes(padding_byte, byteorder=<span class="stringliteral">&#39;little&#39;</span>)</div>
<div class="line"><span class="lineno">  203</span>            <span class="comment"># + 1 is for the padding byte</span></div>
<div class="line"><span class="lineno">  204</span>            offset += padding_length + 1</div>
<div class="line"><span class="lineno">  205</span> </div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">if</span> unpickler.mmap_mode == <span class="stringliteral">&#39;w+&#39;</span>:</div>
<div class="line"><span class="lineno">  207</span>            unpickler.mmap_mode = <span class="stringliteral">&#39;r+&#39;</span></div>
<div class="line"><span class="lineno">  208</span> </div>
<div class="line"><span class="lineno">  209</span>        marray = make_memmap(unpickler.filename,</div>
<div class="line"><span class="lineno">  210</span>                             dtype=self.dtype,</div>
<div class="line"><span class="lineno">  211</span>                             shape=self.shape,</div>
<div class="line"><span class="lineno">  212</span>                             order=self.order,</div>
<div class="line"><span class="lineno">  213</span>                             mode=unpickler.mmap_mode,</div>
<div class="line"><span class="lineno">  214</span>                             offset=offset)</div>
<div class="line"><span class="lineno">  215</span>        <span class="comment"># update the offset so that it corresponds to the end of the read array</span></div>
<div class="line"><span class="lineno">  216</span>        unpickler.file_handle.seek(offset + marray.nbytes)</div>
<div class="line"><span class="lineno">  217</span> </div>
<div class="line"><span class="lineno">  218</span>        <span class="keywordflow">if</span> (numpy_array_alignment_bytes <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  219</span>                current_pos % NUMPY_ARRAY_ALIGNMENT_BYTES != 0):</div>
<div class="line"><span class="lineno">  220</span>            message = (</div>
<div class="line"><span class="lineno">  221</span>                f<span class="stringliteral">&#39;The memmapped array {marray} loaded from the file &#39;</span></div>
<div class="line"><span class="lineno">  222</span>                f<span class="stringliteral">&#39;{unpickler.file_handle.name} is not not bytes aligned. &#39;</span></div>
<div class="line"><span class="lineno">  223</span>                <span class="stringliteral">&#39;This may cause segmentation faults if this memmapped array &#39;</span></div>
<div class="line"><span class="lineno">  224</span>                <span class="stringliteral">&#39;is used in some libraries like BLAS or PyTorch. &#39;</span></div>
<div class="line"><span class="lineno">  225</span>                <span class="stringliteral">&#39;To get rid of this warning, regenerate your pickle file &#39;</span></div>
<div class="line"><span class="lineno">  226</span>                <span class="stringliteral">&#39;with joblib &gt;= 1.2.0. &#39;</span></div>
<div class="line"><span class="lineno">  227</span>                <span class="stringliteral">&#39;See https://github.com/joblib/joblib/issues/563 &#39;</span></div>
<div class="line"><span class="lineno">  228</span>                <span class="stringliteral">&#39;for more details&#39;</span></div>
<div class="line"><span class="lineno">  229</span>            )</div>
<div class="line"><span class="lineno">  230</span>            warnings.warn(message)</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>        <span class="keywordflow">return</span> marray</div>
<div class="line"><span class="lineno">  233</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ef1ee41e9ee4d84305b74523c167dc6" name="a7ef1ee41e9ee4d84305b74523c167dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef1ee41e9ee4d84305b74523c167dc6">&#9670;&#160;</a></span>safe_get_numpy_array_alignment_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.safe_get_numpy_array_alignment_bytes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   92</span>    <span class="keyword">def </span>safe_get_numpy_array_alignment_bytes(self):</div>
<div class="line"><span class="lineno">   93</span>        <span class="comment"># NumpyArrayWrapper instances loaded from joblib &lt;= 1.1 pickles don&#39;t</span></div>
<div class="line"><span class="lineno">   94</span>        <span class="comment"># have an numpy_array_alignment_bytes attribute</span></div>
<div class="line"><span class="lineno">   95</span>        <span class="keywordflow">return</span> getattr(self, <span class="stringliteral">&#39;numpy_array_alignment_bytes&#39;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">   96</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e60313e271460e9524d3ce0c2b57ba7" name="a6e60313e271460e9524d3ce0c2b57ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e60313e271460e9524d3ce0c2b57ba7">&#9670;&#160;</a></span>write_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.write_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pickler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write array bytes to pickler file handle.

This function is an adaptation of the numpy write_array function
available in version 1.10.1 in numpy/lib/format.py.
</pre> <div class="fragment"><div class="line"><span class="lineno">   97</span>    <span class="keyword">def </span>write_array(self, array, pickler):</div>
<div class="line"><span class="lineno">   98</span>        <span class="stringliteral">&quot;&quot;&quot;Write array bytes to pickler file handle.</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        This function is an adaptation of the numpy write_array function</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        available in version 1.10.1 in numpy/lib/format.py.</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  103</span>        <span class="comment"># Set buffer size to 16 MiB to hide the Python loop overhead.</span></div>
<div class="line"><span class="lineno">  104</span>        buffersize = max(16 * 1024 ** 2 // array.itemsize, 1)</div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">if</span> array.dtype.hasobject:</div>
<div class="line"><span class="lineno">  106</span>            <span class="comment"># We contain Python objects so we cannot write out the data</span></div>
<div class="line"><span class="lineno">  107</span>            <span class="comment"># directly. Instead, we will pickle it out with version 2 of the</span></div>
<div class="line"><span class="lineno">  108</span>            <span class="comment"># pickle protocol.</span></div>
<div class="line"><span class="lineno">  109</span>            pickle.dump(array, pickler.file_handle, protocol=2)</div>
<div class="line"><span class="lineno">  110</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  111</span>            numpy_array_alignment_bytes = \</div>
<div class="line"><span class="lineno">  112</span>                self.safe_get_numpy_array_alignment_bytes()</div>
<div class="line"><span class="lineno">  113</span>            <span class="keywordflow">if</span> numpy_array_alignment_bytes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  114</span>                current_pos = pickler.file_handle.tell()</div>
<div class="line"><span class="lineno">  115</span>                pos_after_padding_byte = current_pos + 1</div>
<div class="line"><span class="lineno">  116</span>                padding_length = numpy_array_alignment_bytes - (</div>
<div class="line"><span class="lineno">  117</span>                    pos_after_padding_byte % numpy_array_alignment_bytes)</div>
<div class="line"><span class="lineno">  118</span>                <span class="comment"># A single byte is written that contains the padding length in</span></div>
<div class="line"><span class="lineno">  119</span>                <span class="comment"># bytes</span></div>
<div class="line"><span class="lineno">  120</span>                padding_length_byte = int.to_bytes(</div>
<div class="line"><span class="lineno">  121</span>                    padding_length, length=1, byteorder=<span class="stringliteral">&#39;little&#39;</span>)</div>
<div class="line"><span class="lineno">  122</span>                pickler.file_handle.write(padding_length_byte)</div>
<div class="line"><span class="lineno">  123</span> </div>
<div class="line"><span class="lineno">  124</span>                <span class="keywordflow">if</span> padding_length != 0:</div>
<div class="line"><span class="lineno">  125</span>                    padding = b<span class="stringliteral">&#39;\xff&#39;</span> * padding_length</div>
<div class="line"><span class="lineno">  126</span>                    pickler.file_handle.write(padding)</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>            <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> pickler.np.nditer(array,</div>
<div class="line"><span class="lineno">  129</span>                                           flags=[<span class="stringliteral">&#39;external_loop&#39;</span>,</div>
<div class="line"><span class="lineno">  130</span>                                                  <span class="stringliteral">&#39;buffered&#39;</span>,</div>
<div class="line"><span class="lineno">  131</span>                                                  <span class="stringliteral">&#39;zerosize_ok&#39;</span>],</div>
<div class="line"><span class="lineno">  132</span>                                           buffersize=buffersize,</div>
<div class="line"><span class="lineno">  133</span>                                           order=self.order):</div>
<div class="line"><span class="lineno">  134</span>                pickler.file_handle.write(chunk.tobytes(<span class="stringliteral">&#39;C&#39;</span>))</div>
<div class="line"><span class="lineno">  135</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8c75ff07473accaa5663067c84737cf8" name="a8c75ff07473accaa5663067c84737cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c75ff07473accaa5663067c84737cf8">&#9670;&#160;</a></span>allow_mmap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.allow_mmap</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19ea505b7e50f883d8233999fd9430b7" name="a19ea505b7e50f883d8233999fd9430b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ea505b7e50f883d8233999fd9430b7">&#9670;&#160;</a></span>dtype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.dtype</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a298c8605ee086721723e0bc72091b489" name="a298c8605ee086721723e0bc72091b489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298c8605ee086721723e0bc72091b489">&#9670;&#160;</a></span>numpy_array_alignment_bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.numpy_array_alignment_bytes</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51c09c86d7987be168f4dc151f9596ca" name="a51c09c86d7987be168f4dc151f9596ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c09c86d7987be168f4dc151f9596ca">&#9670;&#160;</a></span>order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.order</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4be6eeee53a69bd192094ee379f51f00" name="a4be6eeee53a69bd192094ee379f51f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be6eeee53a69bd192094ee379f51f00">&#9670;&#160;</a></span>shape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.shape</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a489c4ca8d74e6d242ee2f6bef86b798d" name="a489c4ca8d74e6d242ee2f6bef86b798d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489c4ca8d74e6d242ee2f6bef86b798d">&#9670;&#160;</a></span>subclass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">joblib.numpy_pickle.NumpyArrayWrapper.subclass</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/joblib/<a class="el" href="numpy__pickle_8py.html">numpy_pickle.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
