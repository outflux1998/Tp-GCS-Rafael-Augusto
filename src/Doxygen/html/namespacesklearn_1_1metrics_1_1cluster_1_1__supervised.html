<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.metrics.cluster._supervised Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1metrics.html">metrics</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html">_supervised</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.metrics.cluster._supervised Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9ede3a9f83c02952cadece7910465b6" id="r_ad9ede3a9f83c02952cadece7910465b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#ad9ede3a9f83c02952cadece7910465b6">check_clusterings</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:ad9ede3a9f83c02952cadece7910465b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b19ae497dbdcd1efa9e35f55dbbfc7" id="r_a67b19ae497dbdcd1efa9e35f55dbbfc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a67b19ae497dbdcd1efa9e35f55dbbfc7">_generalized_average</a> (U, V, average_method)</td></tr>
<tr class="separator:a67b19ae497dbdcd1efa9e35f55dbbfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922d375ca4a222f6a8987fcf6dc27fb6" id="r_a922d375ca4a222f6a8987fcf6dc27fb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a922d375ca4a222f6a8987fcf6dc27fb6">contingency_matrix</a> (labels_true, labels_pred, *<a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=None, sparse=False, dtype=np.int64)</td></tr>
<tr class="separator:a922d375ca4a222f6a8987fcf6dc27fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e10db8525d943e132641d887df35d1" id="r_a91e10db8525d943e132641d887df35d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a91e10db8525d943e132641d887df35d1">pair_confusion_matrix</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a91e10db8525d943e132641d887df35d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730947c8e7e9b0e67c8b8e2370accf67" id="r_a730947c8e7e9b0e67c8b8e2370accf67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a730947c8e7e9b0e67c8b8e2370accf67">rand_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a730947c8e7e9b0e67c8b8e2370accf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34402b0738a8cbc3a89c2a13fe75daba" id="r_a34402b0738a8cbc3a89c2a13fe75daba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a34402b0738a8cbc3a89c2a13fe75daba">adjusted_rand_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a34402b0738a8cbc3a89c2a13fe75daba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24408142336c80bb84f14a35d6d85a75" id="r_a24408142336c80bb84f14a35d6d85a75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a24408142336c80bb84f14a35d6d85a75">homogeneity_completeness_v_measure</a> (labels_true, labels_pred, *beta=1.0)</td></tr>
<tr class="separator:a24408142336c80bb84f14a35d6d85a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f3b0a25f6e1f4f1088a64ae1600bef" id="r_a90f3b0a25f6e1f4f1088a64ae1600bef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a90f3b0a25f6e1f4f1088a64ae1600bef">homogeneity_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a90f3b0a25f6e1f4f1088a64ae1600bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3545c1577bdb7d983eaabd92ec7a1a00" id="r_a3545c1577bdb7d983eaabd92ec7a1a00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a3545c1577bdb7d983eaabd92ec7a1a00">completeness_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a3545c1577bdb7d983eaabd92ec7a1a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711f406b9bc0a884c92cf76c0f31e5be" id="r_a711f406b9bc0a884c92cf76c0f31e5be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a711f406b9bc0a884c92cf76c0f31e5be">v_measure_score</a> (labels_true, labels_pred, *beta=1.0)</td></tr>
<tr class="separator:a711f406b9bc0a884c92cf76c0f31e5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0dafc12a174d7d2ff094dd71596f06" id="r_acd0dafc12a174d7d2ff094dd71596f06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#acd0dafc12a174d7d2ff094dd71596f06">mutual_info_score</a> (labels_true, labels_pred, *contingency=None)</td></tr>
<tr class="separator:acd0dafc12a174d7d2ff094dd71596f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7b3f29426b5a0470af10f3b38f8ac" id="r_acfa7b3f29426b5a0470af10f3b38f8ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#acfa7b3f29426b5a0470af10f3b38f8ac">adjusted_mutual_info_score</a> (labels_true, labels_pred, *average_method=&quot;arithmetic&quot;)</td></tr>
<tr class="separator:acfa7b3f29426b5a0470af10f3b38f8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4102c2e09acfb54cdac2c0ccd50964" id="r_afd4102c2e09acfb54cdac2c0ccd50964"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#afd4102c2e09acfb54cdac2c0ccd50964">normalized_mutual_info_score</a> (labels_true, labels_pred, *average_method=&quot;arithmetic&quot;)</td></tr>
<tr class="separator:afd4102c2e09acfb54cdac2c0ccd50964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ddaa40c9efb84dee93b875e09bf052" id="r_a53ddaa40c9efb84dee93b875e09bf052"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#a53ddaa40c9efb84dee93b875e09bf052">fowlkes_mallows_score</a> (labels_true, labels_pred, *sparse=False)</td></tr>
<tr class="separator:a53ddaa40c9efb84dee93b875e09bf052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69009aa559a2656c733bd33fe144b21" id="r_af69009aa559a2656c733bd33fe144b21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html#af69009aa559a2656c733bd33fe144b21">entropy</a> (labels)</td></tr>
<tr class="separator:af69009aa559a2656c733bd33fe144b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Utilities to evaluate the clustering performance of models.

Functions named as *_score return a scalar value to maximize: the higher the
better.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a67b19ae497dbdcd1efa9e35f55dbbfc7" name="a67b19ae497dbdcd1efa9e35f55dbbfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b19ae497dbdcd1efa9e35f55dbbfc7">&#9670;&#160;</a></span>_generalized_average()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised._generalized_average </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>average_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a particular mean of two numbers.</pre> <div class="fragment"><div class="line"><span class="lineno">   76</span><span class="keyword">def </span>_generalized_average(U, V, average_method):</div>
<div class="line"><span class="lineno">   77</span>    <span class="stringliteral">&quot;&quot;&quot;Return a particular mean of two numbers.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">if</span> average_method == <span class="stringliteral">&quot;min&quot;</span>:</div>
<div class="line"><span class="lineno">   79</span>        <span class="keywordflow">return</span> min(U, V)</div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">elif</span> average_method == <span class="stringliteral">&quot;geometric&quot;</span>:</div>
<div class="line"><span class="lineno">   81</span>        <span class="keywordflow">return</span> np.sqrt(U * V)</div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">elif</span> average_method == <span class="stringliteral">&quot;arithmetic&quot;</span>:</div>
<div class="line"><span class="lineno">   83</span>        <span class="keywordflow">return</span> np.mean([U, V])</div>
<div class="line"><span class="lineno">   84</span>    <span class="keywordflow">elif</span> average_method == <span class="stringliteral">&quot;max&quot;</span>:</div>
<div class="line"><span class="lineno">   85</span>        <span class="keywordflow">return</span> max(U, V)</div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   87</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">   88</span>            <span class="stringliteral">&quot;&#39;average_method&#39; must be &#39;min&#39;, &#39;geometric&#39;, &#39;arithmetic&#39;, or &#39;max&#39;&quot;</span></div>
<div class="line"><span class="lineno">   89</span>        )</div>
<div class="line"><span class="lineno">   90</span> </div>
<div class="line"><span class="lineno">   91</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acfa7b3f29426b5a0470af10f3b38f8ac" name="acfa7b3f29426b5a0470af10f3b38f8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa7b3f29426b5a0470af10f3b38f8ac">&#9670;&#160;</a></span>adjusted_mutual_info_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.adjusted_mutual_info_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>average_method</em> = <code>&quot;arithmetic&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjusted Mutual Information between two clusterings.

Adjusted Mutual Information (AMI) is an adjustment of the Mutual
Information (MI) score to account for chance. It accounts for the fact that
the MI is generally higher for two clusterings with a larger number of
clusters, regardless of whether there is actually more information shared.
For two clusterings :math:`U` and :math:`V`, the AMI is given as::

    AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [avg(H(U), H(V)) - E(MI(U, V))]

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching :math:`U` (``label_true``)
with :math:`V` (``labels_pred``) will return the same score value. This can
be useful to measure the agreement of two independent label assignments
strategies on the same dataset when the real ground truth is not known.

Be mindful that this function is an order of magnitude slower than other
metrics, such as the Adjusted Rand Index.

Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    A clustering of the data into disjoint subsets, called :math:`U` in
    the above formula.

labels_pred : int array-like of shape (n_samples,)
    A clustering of the data into disjoint subsets, called :math:`V` in
    the above formula.

average_method : str, default='arithmetic'
    How to compute the normalizer in the denominator. Possible options
    are 'min', 'geometric', 'arithmetic', and 'max'.

    .. versionadded:: 0.20

    .. versionchanged:: 0.22
       The default value of ``average_method`` changed from 'max' to
       'arithmetic'.

Returns
-------
ami: float (upperlimited by 1.0)
   The AMI returns a value of 1 when the two partitions are identical
   (ie perfectly matched). Random partitions (independent labellings) have
   an expected AMI around 0 on average hence can be negative. The value is
   in adjusted nats (based on the natural logarithm).

See Also
--------
adjusted_rand_score : Adjusted Rand Index.
mutual_info_score : Mutual Information (not adjusted for chance).

References
----------
.. [1] `Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for
   Clusterings Comparison: Variants, Properties, Normalization and
   Correction for Chance, JMLR
   &lt;http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf&gt;`_

.. [2] `Wikipedia entry for the Adjusted Mutual Information
   &lt;https://en.wikipedia.org/wiki/Adjusted_Mutual_Information&gt;`_

Examples
--------

Perfect labelings are both homogeneous and complete, hence have
score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import adjusted_mutual_info_score
  &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])
  ... # doctest: +SKIP
  1.0
  &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])
  ... # doctest: +SKIP
  1.0

If classes members are completely split across different clusters,
the assignment is totally in-complete, hence the AMI is null::

  &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])
  ... # doctest: +SKIP
  0.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  835</span>):</div>
<div class="line"><span class="lineno">  836</span>    <span class="stringliteral">&quot;&quot;&quot;Adjusted Mutual Information between two clusterings.</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    Adjusted Mutual Information (AMI) is an adjustment of the Mutual</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    Information (MI) score to account for chance. It accounts for the fact that</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    the MI is generally higher for two clusterings with a larger number of</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    clusters, regardless of whether there is actually more information shared.</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    For two clusterings :math:`U` and :math:`V`, the AMI is given as::</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [avg(H(U), H(V)) - E(MI(U, V))]</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    This metric is independent of the absolute values of the labels:</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    a permutation of the class or cluster label values won&#39;t change the</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    score value in any way.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    This metric is furthermore symmetric: switching :math:`U` (``label_true``)</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    with :math:`V` (``labels_pred``) will return the same score value. This can</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    be useful to measure the agreement of two independent label assignments</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    strategies on the same dataset when the real ground truth is not known.</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    Be mindful that this function is an order of magnitude slower than other</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    metrics, such as the Adjusted Rand Index.</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">        A clustering of the data into disjoint subsets, called :math:`U` in</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">        the above formula.</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    labels_pred : int array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">        A clustering of the data into disjoint subsets, called :math:`V` in</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">        the above formula.</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    average_method : str, default=&#39;arithmetic&#39;</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">        How to compute the normalizer in the denominator. Possible options</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">        are &#39;min&#39;, &#39;geometric&#39;, &#39;arithmetic&#39;, and &#39;max&#39;.</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">           The default value of ``average_method`` changed from &#39;max&#39; to</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">           &#39;arithmetic&#39;.</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    ami: float (upperlimited by 1.0)</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">       The AMI returns a value of 1 when the two partitions are identical</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">       (ie perfectly matched). Random partitions (independent labellings) have</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">       an expected AMI around 0 on average hence can be negative. The value is</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">       in adjusted nats (based on the natural logarithm).</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    adjusted_rand_score : Adjusted Rand Index.</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    mutual_info_score : Mutual Information (not adjusted for chance).</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    .. [1] `Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">       Clusterings Comparison: Variants, Properties, Normalization and</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">       Correction for Chance, JMLR</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">       &lt;http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf&gt;`_</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    .. [2] `Wikipedia entry for the Adjusted Mutual Information</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">       &lt;https://en.wikipedia.org/wiki/Adjusted_Mutual_Information&gt;`_</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    Perfect labelings are both homogeneous and complete, hence have</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    score 1.0::</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import adjusted_mutual_info_score</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">      ... # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">      ... # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    If classes members are completely split across different clusters,</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    the assignment is totally in-complete, hence the AMI is null::</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">      ... # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">      0.0</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  924</span>    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)</div>
<div class="line"><span class="lineno">  925</span>    n_samples = labels_true.shape[0]</div>
<div class="line"><span class="lineno">  926</span>    classes = np.unique(labels_true)</div>
<div class="line"><span class="lineno">  927</span>    clusters = np.unique(labels_pred)</div>
<div class="line"><span class="lineno">  928</span> </div>
<div class="line"><span class="lineno">  929</span>    <span class="comment"># Special limit cases: no clustering since the data is not split.</span></div>
<div class="line"><span class="lineno">  930</span>    <span class="comment"># It corresponds to both labellings having zero entropy.</span></div>
<div class="line"><span class="lineno">  931</span>    <span class="comment"># This is a perfect match hence return 1.0.</span></div>
<div class="line"><span class="lineno">  932</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  933</span>        classes.shape[0] == clusters.shape[0] == 1</div>
<div class="line"><span class="lineno">  934</span>        <span class="keywordflow">or</span> classes.shape[0] == clusters.shape[0] == 0</div>
<div class="line"><span class="lineno">  935</span>    ):</div>
<div class="line"><span class="lineno">  936</span>        <span class="keywordflow">return</span> 1.0</div>
<div class="line"><span class="lineno">  937</span> </div>
<div class="line"><span class="lineno">  938</span>    contingency = contingency_matrix(labels_true, labels_pred, sparse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  939</span>    contingency = contingency.astype(np.float64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  940</span>    <span class="comment"># Calculate the MI for the two clusterings</span></div>
<div class="line"><span class="lineno">  941</span>    mi = mutual_info_score(labels_true, labels_pred, contingency=contingency)</div>
<div class="line"><span class="lineno">  942</span>    <span class="comment"># Calculate the expected value for the mutual information</span></div>
<div class="line"><span class="lineno">  943</span>    emi = expected_mutual_information(contingency, n_samples)</div>
<div class="line"><span class="lineno">  944</span>    <span class="comment"># Calculate entropy for each labeling</span></div>
<div class="line"><span class="lineno">  945</span>    h_true, h_pred = entropy(labels_true), entropy(labels_pred)</div>
<div class="line"><span class="lineno">  946</span>    normalizer = _generalized_average(h_true, h_pred, average_method)</div>
<div class="line"><span class="lineno">  947</span>    denominator = normalizer - emi</div>
<div class="line"><span class="lineno">  948</span>    <span class="comment"># Avoid 0.0 / 0.0 when expectation equals maximum, i.e a perfect match.</span></div>
<div class="line"><span class="lineno">  949</span>    <span class="comment"># normalizer should always be &gt;= emi, but because of floating-point</span></div>
<div class="line"><span class="lineno">  950</span>    <span class="comment"># representation, sometimes emi is slightly larger. Correct this</span></div>
<div class="line"><span class="lineno">  951</span>    <span class="comment"># by preserving the sign.</span></div>
<div class="line"><span class="lineno">  952</span>    <span class="keywordflow">if</span> denominator &lt; 0:</div>
<div class="line"><span class="lineno">  953</span>        denominator = min(denominator, -np.finfo(<span class="stringliteral">&quot;float64&quot;</span>).eps)</div>
<div class="line"><span class="lineno">  954</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  955</span>        denominator = max(denominator, np.finfo(<span class="stringliteral">&quot;float64&quot;</span>).eps)</div>
<div class="line"><span class="lineno">  956</span>    ami = (mi - emi) / denominator</div>
<div class="line"><span class="lineno">  957</span>    <span class="keywordflow">return</span> ami</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a34402b0738a8cbc3a89c2a13fe75daba" name="a34402b0738a8cbc3a89c2a13fe75daba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34402b0738a8cbc3a89c2a13fe75daba">&#9670;&#160;</a></span>adjusted_rand_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.adjusted_rand_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rand index adjusted for chance.

The Rand Index computes a similarity measure between two clusterings
by considering all pairs of samples and counting pairs that are
assigned in the same or different clusters in the predicted and
true clusterings.

The raw RI score is then "adjusted for chance" into the ARI score
using the following scheme::

    ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)

The adjusted Rand index is thus ensured to have a value close to
0.0 for random labeling independently of the number of clusters and
samples and exactly 1.0 when the clusterings are identical (up to
a permutation). The adjusted Rand index is bounded below by -0.5 for
especially discordant clusterings.

ARI is a symmetric measure::

    adjusted_rand_score(a, b) == adjusted_rand_score(b, a)

Read more in the :ref:`User Guide &lt;adjusted_rand_score&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

Returns
-------
ARI : float
   Similarity score between -0.5 and 1.0. Random labelings have an ARI
   close to 0.0. 1.0 stands for perfect match.

See Also
--------
adjusted_mutual_info_score : Adjusted Mutual Information.

References
----------
.. [Hubert1985] L. Hubert and P. Arabie, Comparing Partitions,
  Journal of Classification 1985
  https://link.springer.com/article/10.1007%2FBF01908075

.. [Steinley2004] D. Steinley, Properties of the Hubert-Arabie
  adjusted Rand index, Psychological Methods 2004

.. [wk] https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index

.. [Chacon] :doi:`Minimum adjusted Rand index for two clusterings of a given size,
  2022, J. E. Chacón and A. I. Rastrojo &lt;10.1007/s11634-022-00491-w&gt;`

Examples
--------
Perfectly matching labelings have a score of 1 even

  &gt;&gt;&gt; from sklearn.metrics.cluster import adjusted_rand_score
  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Labelings that assign all classes members to the same clusters
are complete but may not always be pure, hence penalized::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 2], [0, 0, 1, 1])
  0.57...

ARI is symmetric, so labelings that have pure clusters with members
coming from the same classes but unnecessary splits are penalized::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 2])
  0.57...

If classes members are completely split across different clusters, the
assignment is totally incomplete, hence the ARI is very low::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 0, 0], [0, 1, 2, 3])
  0.0

ARI may take a negative value for especially discordant labelings that
are a worse choice than the expected value of random labels::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 1, 0, 1])
  -0.5
</pre> <div class="fragment"><div class="line"><span class="lineno">  310</span><span class="keyword">def </span>adjusted_rand_score(labels_true, labels_pred):</div>
<div class="line"><span class="lineno">  311</span>    <span class="stringliteral">&quot;&quot;&quot;Rand index adjusted for chance.</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    The Rand Index computes a similarity measure between two clusterings</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    by considering all pairs of samples and counting pairs that are</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    assigned in the same or different clusters in the predicted and</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    true clusterings.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    The raw RI score is then &quot;adjusted for chance&quot; into the ARI score</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    using the following scheme::</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    The adjusted Rand index is thus ensured to have a value close to</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    0.0 for random labeling independently of the number of clusters and</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    samples and exactly 1.0 when the clusterings are identical (up to</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    a permutation). The adjusted Rand index is bounded below by -0.5 for</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    especially discordant clusterings.</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    ARI is a symmetric measure::</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        adjusted_rand_score(a, b) == adjusted_rand_score(b, a)</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;adjusted_rand_score&gt;`.</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">        Cluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    ARI : float</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">       Similarity score between -0.5 and 1.0. Random labelings have an ARI</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">       close to 0.0. 1.0 stands for perfect match.</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    adjusted_mutual_info_score : Adjusted Mutual Information.</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    .. [Hubert1985] L. Hubert and P. Arabie, Comparing Partitions,</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">      Journal of Classification 1985</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">      https://link.springer.com/article/10.1007%2FBF01908075</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    .. [Steinley2004] D. Steinley, Properties of the Hubert-Arabie</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">      adjusted Rand index, Psychological Methods 2004</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    .. [wk] https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    .. [Chacon] :doi:`Minimum adjusted Rand index for two clusterings of a given size,</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">      2022, J. E. Chacón and A. I. Rastrojo &lt;10.1007/s11634-022-00491-w&gt;`</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    Perfectly matching labelings have a score of 1 even</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import adjusted_rand_score</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    Labelings that assign all classes members to the same clusters</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    are complete but may not always be pure, hence penalized::</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 2], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">      0.57...</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    ARI is symmetric, so labelings that have pure clusters with members</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    coming from the same classes but unnecessary splits are penalized::</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 2])</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">      0.57...</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    If classes members are completely split across different clusters, the</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    assignment is totally incomplete, hence the ARI is very low::</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_rand_score([0, 0, 0, 0], [0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">      0.0</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    ARI may take a negative value for especially discordant labelings that</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    are a worse choice than the expected value of random labels::</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">      &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 1, 0, 1])</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">      -0.5</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  401</span>    (tn, fp), (fn, tp) = pair_confusion_matrix(labels_true, labels_pred)</div>
<div class="line"><span class="lineno">  402</span>    <span class="comment"># convert to Python integer types, to avoid overflow or underflow</span></div>
<div class="line"><span class="lineno">  403</span>    tn, fp, fn, tp = int(tn), int(fp), int(fn), int(tp)</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>    <span class="comment"># Special cases: empty data or full agreement</span></div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">if</span> fn == 0 <span class="keywordflow">and</span> fp == 0:</div>
<div class="line"><span class="lineno">  407</span>        <span class="keywordflow">return</span> 1.0</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">return</span> 2.0 * (tp * tn - fn * fp) / ((tp + fn) * (fn + tn) + (tp + fp) * (fp + tn))</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9ede3a9f83c02952cadece7910465b6" name="ad9ede3a9f83c02952cadece7910465b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ede3a9f83c02952cadece7910465b6">&#9670;&#160;</a></span>check_clusterings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.check_clusterings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the labels arrays are 1D and of same dimension.

Parameters
----------
labels_true : array-like of shape (n_samples,)
    The true labels.

labels_pred : array-like of shape (n_samples,)
    The predicted labels.
</pre> <div class="fragment"><div class="line"><span class="lineno">   30</span><span class="keyword">def </span>check_clusterings(labels_true, labels_pred):</div>
<div class="line"><span class="lineno">   31</span>    <span class="stringliteral">&quot;&quot;&quot;Check that the labels arrays are 1D and of same dimension.</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    labels_true : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">        The true labels.</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        The predicted labels.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   41</span>    labels_true = check_array(</div>
<div class="line"><span class="lineno">   42</span>        labels_true,</div>
<div class="line"><span class="lineno">   43</span>        ensure_2d=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">   44</span>        ensure_min_samples=0,</div>
<div class="line"><span class="lineno">   45</span>        dtype=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">   46</span>    )</div>
<div class="line"><span class="lineno">   47</span> </div>
<div class="line"><span class="lineno">   48</span>    labels_pred = check_array(</div>
<div class="line"><span class="lineno">   49</span>        labels_pred,</div>
<div class="line"><span class="lineno">   50</span>        ensure_2d=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">   51</span>        ensure_min_samples=0,</div>
<div class="line"><span class="lineno">   52</span>        dtype=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">   53</span>    )</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    type_label = type_of_target(labels_true)</div>
<div class="line"><span class="lineno">   56</span>    type_pred = type_of_target(labels_pred)</div>
<div class="line"><span class="lineno">   57</span> </div>
<div class="line"><span class="lineno">   58</span>    <span class="keywordflow">if</span> <span class="stringliteral">&quot;continuous&quot;</span> <span class="keywordflow">in</span> (type_pred, type_label):</div>
<div class="line"><span class="lineno">   59</span>        msg = (</div>
<div class="line"><span class="lineno">   60</span>            <span class="stringliteral">&quot;Clustering metrics expects discrete values but received&quot;</span></div>
<div class="line"><span class="lineno">   61</span>            f<span class="stringliteral">&quot; {type_label} values for label, and {type_pred} values &quot;</span></div>
<div class="line"><span class="lineno">   62</span>            <span class="stringliteral">&quot;for target&quot;</span></div>
<div class="line"><span class="lineno">   63</span>        )</div>
<div class="line"><span class="lineno">   64</span>        warnings.warn(msg, UserWarning)</div>
<div class="line"><span class="lineno">   65</span> </div>
<div class="line"><span class="lineno">   66</span>    <span class="comment"># input checks</span></div>
<div class="line"><span class="lineno">   67</span>    <span class="keywordflow">if</span> labels_true.ndim != 1:</div>
<div class="line"><span class="lineno">   68</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;labels_true must be 1D: shape is %r&quot;</span> % (labels_true.shape,))</div>
<div class="line"><span class="lineno">   69</span>    <span class="keywordflow">if</span> labels_pred.ndim != 1:</div>
<div class="line"><span class="lineno">   70</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;labels_pred must be 1D: shape is %r&quot;</span> % (labels_pred.shape,))</div>
<div class="line"><span class="lineno">   71</span>    check_consistent_length(labels_true, labels_pred)</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">return</span> labels_true, labels_pred</div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3545c1577bdb7d983eaabd92ec7a1a00" name="a3545c1577bdb7d983eaabd92ec7a1a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3545c1577bdb7d983eaabd92ec7a1a00">&#9670;&#160;</a></span>completeness_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.completeness_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute completeness metric of a cluster labeling given a ground truth.

A clustering result satisfies completeness if all the data points
that are members of a given class are elements of the same cluster.

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is not symmetric: switching ``label_true`` with ``label_pred``
will return the :func:`homogeneity_score` which will be different in
general.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

Returns
-------
completeness : float
   Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.

See Also
--------
homogeneity_score : Homogeneity metric of cluster labeling.
v_measure_score : V-Measure (NMI with arithmetic mean option).

References
----------

.. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   conditional entropy-based external cluster evaluation measure
   &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_

Examples
--------

Perfect labelings are complete::

  &gt;&gt;&gt; from sklearn.metrics.cluster import completeness_score
  &gt;&gt;&gt; completeness_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Non-perfect labelings that assign all classes members to the same clusters
are still complete::

  &gt;&gt;&gt; print(completeness_score([0, 0, 1, 1], [0, 0, 0, 0]))
  1.0
  &gt;&gt;&gt; print(completeness_score([0, 1, 2, 3], [0, 0, 1, 1]))
  0.999...

If classes members are split across different clusters, the
assignment cannot be complete::

  &gt;&gt;&gt; print(completeness_score([0, 0, 1, 1], [0, 1, 0, 1]))
  0.0
  &gt;&gt;&gt; print(completeness_score([0, 0, 0, 0], [0, 1, 2, 3]))
  0.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  567</span><span class="keyword">def </span>completeness_score(labels_true, labels_pred):</div>
<div class="line"><span class="lineno">  568</span>    <span class="stringliteral">&quot;&quot;&quot;Compute completeness metric of a cluster labeling given a ground truth.</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    A clustering result satisfies completeness if all the data points</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    that are members of a given class are elements of the same cluster.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    This metric is independent of the absolute values of the labels:</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    a permutation of the class or cluster label values won&#39;t change the</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    score value in any way.</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    This metric is not symmetric: switching ``label_true`` with ``label_pred``</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    will return the :func:`homogeneity_score` which will be different in</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    general.</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        Cluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    completeness : float</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">       Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    homogeneity_score : Homogeneity metric of cluster labeling.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    v_measure_score : V-Measure (NMI with arithmetic mean option).</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    .. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">       conditional entropy-based external cluster evaluation measure</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">       &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    Perfect labelings are complete::</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import completeness_score</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">      &gt;&gt;&gt; completeness_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    Non-perfect labelings that assign all classes members to the same clusters</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    are still complete::</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">      &gt;&gt;&gt; print(completeness_score([0, 0, 1, 1], [0, 0, 0, 0]))</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">      &gt;&gt;&gt; print(completeness_score([0, 1, 2, 3], [0, 0, 1, 1]))</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">      0.999...</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    If classes members are split across different clusters, the</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    assignment cannot be complete::</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">      &gt;&gt;&gt; print(completeness_score([0, 0, 1, 1], [0, 1, 0, 1]))</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">      0.0</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">      &gt;&gt;&gt; print(completeness_score([0, 0, 0, 0], [0, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">      0.0</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  633</span>    <span class="keywordflow">return</span> homogeneity_completeness_v_measure(labels_true, labels_pred)[1]</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a922d375ca4a222f6a8987fcf6dc27fb6" name="a922d375ca4a222f6a8987fcf6dc27fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922d375ca4a222f6a8987fcf6dc27fb6">&#9670;&#160;</a></span>contingency_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.contingency_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>eps</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>np.int64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a contingency matrix describing the relationship between labels.

Parameters
----------
labels_true : int array, shape = [n_samples]
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

eps : float, default=None
    If a float, that value is added to all values in the contingency
    matrix. This helps to stop NaN propagation.
    If ``None``, nothing is adjusted.

sparse : bool, default=False
    If `True`, return a sparse CSR continency matrix. If `eps` is not
    `None` and `sparse` is `True` will raise ValueError.

    .. versionadded:: 0.18

dtype : numeric type, default=np.int64
    Output dtype. Ignored if `eps` is not `None`.

    .. versionadded:: 0.24

Returns
-------
contingency : {array-like, sparse}, shape=[n_classes_true, n_classes_pred]
    Matrix :math:`C` such that :math:`C_{i, j}` is the number of samples in
    true class :math:`i` and in predicted class :math:`j`. If
    ``eps is None``, the dtype of this array will be integer unless set
    otherwise with the ``dtype`` argument. If ``eps`` is given, the dtype
    will be float.
    Will be a ``sklearn.sparse.csr_matrix`` if ``sparse=True``.
</pre> <div class="fragment"><div class="line"><span class="lineno">   94</span>):</div>
<div class="line"><span class="lineno">   95</span>    <span class="stringliteral">&quot;&quot;&quot;Build a contingency matrix describing the relationship between labels.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        Cluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    eps : float, default=None</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        If a float, that value is added to all values in the contingency</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        matrix. This helps to stop NaN propagation.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        If ``None``, nothing is adjusted.</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    sparse : bool, default=False</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        If `True`, return a sparse CSR continency matrix. If `eps` is not</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        `None` and `sparse` is `True` will raise ValueError.</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        .. versionadded:: 0.18</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    dtype : numeric type, default=np.int64</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">        Output dtype. Ignored if `eps` is not `None`.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        .. versionadded:: 0.24</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    contingency : {array-like, sparse}, shape=[n_classes_true, n_classes_pred]</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">        Matrix :math:`C` such that :math:`C_{i, j}` is the number of samples in</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        true class :math:`i` and in predicted class :math:`j`. If</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        ``eps is None``, the dtype of this array will be integer unless set</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        otherwise with the ``dtype`` argument. If ``eps`` is given, the dtype</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        will be float.</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">        Will be a ``sklearn.sparse.csr_matrix`` if ``sparse=True``.</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">if</span> eps <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> sparse:</div>
<div class="line"><span class="lineno">  133</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Cannot set &#39;eps&#39; when sparse=True&quot;</span>)</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>    classes, class_idx = np.unique(labels_true, return_inverse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  136</span>    clusters, cluster_idx = np.unique(labels_pred, return_inverse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  137</span>    n_classes = classes.shape[0]</div>
<div class="line"><span class="lineno">  138</span>    n_clusters = clusters.shape[0]</div>
<div class="line"><span class="lineno">  139</span>    <span class="comment"># Using coo_matrix to accelerate simple histogram calculation,</span></div>
<div class="line"><span class="lineno">  140</span>    <span class="comment"># i.e. bins are consecutive integers</span></div>
<div class="line"><span class="lineno">  141</span>    <span class="comment"># Currently, coo_matrix is faster than histogram2d for simple cases</span></div>
<div class="line"><span class="lineno">  142</span>    contingency = sp.coo_matrix(</div>
<div class="line"><span class="lineno">  143</span>        (np.ones(class_idx.shape[0]), (class_idx, cluster_idx)),</div>
<div class="line"><span class="lineno">  144</span>        shape=(n_classes, n_clusters),</div>
<div class="line"><span class="lineno">  145</span>        dtype=dtype,</div>
<div class="line"><span class="lineno">  146</span>    )</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">if</span> sparse:</div>
<div class="line"><span class="lineno">  148</span>        contingency = contingency.tocsr()</div>
<div class="line"><span class="lineno">  149</span>        contingency.sum_duplicates()</div>
<div class="line"><span class="lineno">  150</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  151</span>        contingency = contingency.toarray()</div>
<div class="line"><span class="lineno">  152</span>        <span class="keywordflow">if</span> eps <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  153</span>            <span class="comment"># don&#39;t use += as contingency is integer</span></div>
<div class="line"><span class="lineno">  154</span>            contingency = contingency + eps</div>
<div class="line"><span class="lineno">  155</span>    <span class="keywordflow">return</span> contingency</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span> </div>
<div class="line"><span class="lineno">  158</span><span class="comment"># clustering measures</span></div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af69009aa559a2656c733bd33fe144b21" name="af69009aa559a2656c733bd33fe144b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69009aa559a2656c733bd33fe144b21">&#9670;&#160;</a></span>entropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.entropy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the entropy for a labeling.

Parameters
----------
labels : array-like of shape (n_samples,), dtype=int
    The labels.

Returns
-------
entropy : float
   The entropy for a labeling.

Notes
-----
The logarithm used is the natural logarithm (base-e).
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1146</span><span class="keyword">def </span>entropy(labels):</div>
<div class="line"><span class="lineno"> 1147</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the entropy for a labeling.</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    labels : array-like of shape (n_samples,), dtype=int</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">        The labels.</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    entropy : float</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">       The entropy for a labeling.</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    The logarithm used is the natural logarithm (base-e).</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1163</span>    <span class="keywordflow">if</span> len(labels) == 0:</div>
<div class="line"><span class="lineno"> 1164</span>        <span class="keywordflow">return</span> 1.0</div>
<div class="line"><span class="lineno"> 1165</span>    label_idx = np.unique(labels, return_inverse=<span class="keyword">True</span>)[1]</div>
<div class="line"><span class="lineno"> 1166</span>    pi = np.bincount(label_idx).astype(np.float64)</div>
<div class="line"><span class="lineno"> 1167</span>    pi = pi[pi &gt; 0]</div>
<div class="line"><span class="lineno"> 1168</span> </div>
<div class="line"><span class="lineno"> 1169</span>    <span class="comment"># single cluster =&gt; zero entropy</span></div>
<div class="line"><span class="lineno"> 1170</span>    <span class="keywordflow">if</span> pi.size == 1:</div>
<div class="line"><span class="lineno"> 1171</span>        <span class="keywordflow">return</span> 0.0</div>
<div class="line"><span class="lineno"> 1172</span> </div>
<div class="line"><span class="lineno"> 1173</span>    pi_sum = np.sum(pi)</div>
<div class="line"><span class="lineno"> 1174</span>    <span class="comment"># log(a / b) should be calculated as log(a) - log(b) for</span></div>
<div class="line"><span class="lineno"> 1175</span>    <span class="comment"># possible loss of precision</span></div>
<div class="line"><span class="lineno"> 1176</span>    <span class="keywordflow">return</span> -np.sum((pi / pi_sum) * (np.log(pi) - log(pi_sum)))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a53ddaa40c9efb84dee93b875e09bf052" name="a53ddaa40c9efb84dee93b875e09bf052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ddaa40c9efb84dee93b875e09bf052">&#9670;&#160;</a></span>fowlkes_mallows_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.fowlkes_mallows_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Measure the similarity of two clusterings of a set of points.

.. versionadded:: 0.18

The Fowlkes-Mallows index (FMI) is defined as the geometric mean between of
the precision and recall::

    FMI = TP / sqrt((TP + FP) * (TP + FN))

Where ``TP`` is the number of **True Positive** (i.e. the number of pair of
points that belongs in the same clusters in both ``labels_true`` and
``labels_pred``), ``FP`` is the number of **False Positive** (i.e. the
number of pair of points that belongs in the same clusters in
``labels_true`` and not in ``labels_pred``) and ``FN`` is the number of
**False Negative** (i.e the number of pair of points that belongs in the
same clusters in ``labels_pred`` and not in ``labels_True``).

The score ranges from 0 to 1. A high value indicates a good similarity
between two clusters.

Read more in the :ref:`User Guide &lt;fowlkes_mallows_scores&gt;`.

Parameters
----------
labels_true : int array, shape = (``n_samples``,)
    A clustering of the data into disjoint subsets.

labels_pred : array, shape = (``n_samples``, )
    A clustering of the data into disjoint subsets.

sparse : bool, default=False
    Compute contingency matrix internally with sparse matrix.

Returns
-------
score : float
   The resulting Fowlkes-Mallows score.

References
----------
.. [1] `E. B. Fowkles and C. L. Mallows, 1983. "A method for comparing two
   hierarchical clusterings". Journal of the American Statistical
   Association
   &lt;https://www.tandfonline.com/doi/abs/10.1080/01621459.1983.10478008&gt;`_

.. [2] `Wikipedia entry for the Fowlkes-Mallows Index
       &lt;https://en.wikipedia.org/wiki/Fowlkes-Mallows_index&gt;`_

Examples
--------

Perfect labelings are both homogeneous and complete, hence have
score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import fowlkes_mallows_score
  &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

If classes members are completely split across different clusters,
the assignment is totally random, hence the FMI is null::

  &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 0, 0], [0, 1, 2, 3])
  0.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1068</span><span class="keyword">def </span>fowlkes_mallows_score(labels_true, labels_pred, *, sparse=False):</div>
<div class="line"><span class="lineno"> 1069</span>    <span class="stringliteral">&quot;&quot;&quot;Measure the similarity of two clusterings of a set of points.</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    .. versionadded:: 0.18</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    The Fowlkes-Mallows index (FMI) is defined as the geometric mean between of</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    the precision and recall::</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        FMI = TP / sqrt((TP + FP) * (TP + FN))</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    Where ``TP`` is the number of **True Positive** (i.e. the number of pair of</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    points that belongs in the same clusters in both ``labels_true`` and</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">    ``labels_pred``), ``FP`` is the number of **False Positive** (i.e. the</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    number of pair of points that belongs in the same clusters in</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    ``labels_true`` and not in ``labels_pred``) and ``FN`` is the number of</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">    **False Negative** (i.e the number of pair of points that belongs in the</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    same clusters in ``labels_pred`` and not in ``labels_True``).</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    The score ranges from 0 to 1. A high value indicates a good similarity</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    between two clusters.</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;fowlkes_mallows_scores&gt;`.</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    labels_true : int array, shape = (``n_samples``,)</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        A clustering of the data into disjoint subsets.</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">    labels_pred : array, shape = (``n_samples``, )</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">        A clustering of the data into disjoint subsets.</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    sparse : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">        Compute contingency matrix internally with sparse matrix.</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    score : float</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">       The resulting Fowlkes-Mallows score.</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">    .. [1] `E. B. Fowkles and C. L. Mallows, 1983. &quot;A method for comparing two</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">       hierarchical clusterings&quot;. Journal of the American Statistical</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">       Association</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">       &lt;https://www.tandfonline.com/doi/abs/10.1080/01621459.1983.10478008&gt;`_</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    .. [2] `Wikipedia entry for the Fowlkes-Mallows Index</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">           &lt;https://en.wikipedia.org/wiki/Fowlkes-Mallows_index&gt;`_</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    Perfect labelings are both homogeneous and complete, hence have</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    score 1.0::</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import fowlkes_mallows_score</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">      &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 1, 1], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">      &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    If classes members are completely split across different clusters,</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    the assignment is totally random, hence the FMI is null::</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">      &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 0, 0], [0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">      0.0</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1135</span>    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)</div>
<div class="line"><span class="lineno"> 1136</span>    (n_samples,) = labels_true.shape</div>
<div class="line"><span class="lineno"> 1137</span> </div>
<div class="line"><span class="lineno"> 1138</span>    c = contingency_matrix(labels_true, labels_pred, sparse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1139</span>    c = c.astype(np.int64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1140</span>    tk = np.dot(c.data, c.data) - n_samples</div>
<div class="line"><span class="lineno"> 1141</span>    pk = np.sum(np.asarray(c.sum(axis=0)).ravel() ** 2) - n_samples</div>
<div class="line"><span class="lineno"> 1142</span>    qk = np.sum(np.asarray(c.sum(axis=1)).ravel() ** 2) - n_samples</div>
<div class="line"><span class="lineno"> 1143</span>    <span class="keywordflow">return</span> np.sqrt(tk / pk) * np.sqrt(tk / qk) <span class="keywordflow">if</span> tk != 0.0 <span class="keywordflow">else</span> 0.0</div>
<div class="line"><span class="lineno"> 1144</span> </div>
<div class="line"><span class="lineno"> 1145</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a24408142336c80bb84f14a35d6d85a75" name="a24408142336c80bb84f14a35d6d85a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24408142336c80bb84f14a35d6d85a75">&#9670;&#160;</a></span>homogeneity_completeness_v_measure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.homogeneity_completeness_v_measure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>beta</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the homogeneity and completeness and V-Measure scores at once.

Those metrics are based on normalized conditional entropy measures of
the clustering labeling to evaluate given the knowledge of a Ground
Truth class labels of the same samples.

A clustering result satisfies homogeneity if all of its clusters
contain only data points which are members of a single class.

A clustering result satisfies completeness if all the data points
that are members of a given class are elements of the same cluster.

Both scores have positive values between 0.0 and 1.0, larger values
being desirable.

Those 3 metrics are independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score values in any way.

V-Measure is furthermore symmetric: swapping ``labels_true`` and
``label_pred`` will give the same score. This does not hold for
homogeneity and completeness. V-Measure is identical to
:func:`normalized_mutual_info_score` with the arithmetic averaging
method.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Gluster labels to evaluate.

beta : float, default=1.0
    Ratio of weight attributed to ``homogeneity`` vs ``completeness``.
    If ``beta`` is greater than 1, ``completeness`` is weighted more
    strongly in the calculation. If ``beta`` is less than 1,
    ``homogeneity`` is weighted more strongly.

Returns
-------
homogeneity : float
    Score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling.

completeness : float
    Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.

v_measure : float
    Harmonic mean of the first two.

See Also
--------
homogeneity_score : Homogeneity metric of cluster labeling.
completeness_score : Completeness metric of cluster labeling.
v_measure_score : V-Measure (NMI with arithmetic mean option).
</pre> <div class="fragment"><div class="line"><span class="lineno">  412</span><span class="keyword">def </span>homogeneity_completeness_v_measure(labels_true, labels_pred, *, beta=1.0):</div>
<div class="line"><span class="lineno">  413</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the homogeneity and completeness and V-Measure scores at once.</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    Those metrics are based on normalized conditional entropy measures of</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    the clustering labeling to evaluate given the knowledge of a Ground</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    Truth class labels of the same samples.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    A clustering result satisfies homogeneity if all of its clusters</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    contain only data points which are members of a single class.</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    A clustering result satisfies completeness if all the data points</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    that are members of a given class are elements of the same cluster.</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    Both scores have positive values between 0.0 and 1.0, larger values</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    being desirable.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    Those 3 metrics are independent of the absolute values of the labels:</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    a permutation of the class or cluster label values won&#39;t change the</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    score values in any way.</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    V-Measure is furthermore symmetric: swapping ``labels_true`` and</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    ``label_pred`` will give the same score. This does not hold for</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    homogeneity and completeness. V-Measure is identical to</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    :func:`normalized_mutual_info_score` with the arithmetic averaging</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    method.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        Gluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    beta : float, default=1.0</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        Ratio of weight attributed to ``homogeneity`` vs ``completeness``.</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        If ``beta`` is greater than 1, ``completeness`` is weighted more</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        strongly in the calculation. If ``beta`` is less than 1,</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        ``homogeneity`` is weighted more strongly.</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    homogeneity : float</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">        Score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling.</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    completeness : float</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    v_measure : float</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        Harmonic mean of the first two.</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    homogeneity_score : Homogeneity metric of cluster labeling.</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    completeness_score : Completeness metric of cluster labeling.</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    v_measure_score : V-Measure (NMI with arithmetic mean option).</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  471</span>    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordflow">if</span> len(labels_true) == 0:</div>
<div class="line"><span class="lineno">  474</span>        <span class="keywordflow">return</span> 1.0, 1.0, 1.0</div>
<div class="line"><span class="lineno">  475</span> </div>
<div class="line"><span class="lineno">  476</span>    entropy_C = entropy(labels_true)</div>
<div class="line"><span class="lineno">  477</span>    entropy_K = entropy(labels_pred)</div>
<div class="line"><span class="lineno">  478</span> </div>
<div class="line"><span class="lineno">  479</span>    contingency = contingency_matrix(labels_true, labels_pred, sparse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  480</span>    MI = mutual_info_score(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, contingency=contingency)</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span>    homogeneity = MI / (entropy_C) <span class="keywordflow">if</span> entropy_C <span class="keywordflow">else</span> 1.0</div>
<div class="line"><span class="lineno">  483</span>    completeness = MI / (entropy_K) <span class="keywordflow">if</span> entropy_K <span class="keywordflow">else</span> 1.0</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span>    <span class="keywordflow">if</span> homogeneity + completeness == 0.0:</div>
<div class="line"><span class="lineno">  486</span>        v_measure_score = 0.0</div>
<div class="line"><span class="lineno">  487</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  488</span>        v_measure_score = (</div>
<div class="line"><span class="lineno">  489</span>            (1 + beta)</div>
<div class="line"><span class="lineno">  490</span>            * homogeneity</div>
<div class="line"><span class="lineno">  491</span>            * completeness</div>
<div class="line"><span class="lineno">  492</span>            / (beta * homogeneity + completeness)</div>
<div class="line"><span class="lineno">  493</span>        )</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>    <span class="keywordflow">return</span> homogeneity, completeness, v_measure_score</div>
<div class="line"><span class="lineno">  496</span> </div>
<div class="line"><span class="lineno">  497</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a90f3b0a25f6e1f4f1088a64ae1600bef" name="a90f3b0a25f6e1f4f1088a64ae1600bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f3b0a25f6e1f4f1088a64ae1600bef">&#9670;&#160;</a></span>homogeneity_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.homogeneity_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Homogeneity metric of a cluster labeling given a ground truth.

A clustering result satisfies homogeneity if all of its clusters
contain only data points which are members of a single class.

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is not symmetric: switching ``label_true`` with ``label_pred``
will return the :func:`completeness_score` which will be different in
general.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

Returns
-------
homogeneity : float
   Score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling.

See Also
--------
completeness_score : Completeness metric of cluster labeling.
v_measure_score : V-Measure (NMI with arithmetic mean option).

References
----------

.. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   conditional entropy-based external cluster evaluation measure
   &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_

Examples
--------

Perfect labelings are homogeneous::

  &gt;&gt;&gt; from sklearn.metrics.cluster import homogeneity_score
  &gt;&gt;&gt; homogeneity_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Non-perfect labelings that further split classes into more clusters can be
perfectly homogeneous::

  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 0, 1, 2]))
  1.000000
  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 1, 2, 3]))
  1.000000

Clusters that include samples from different classes do not make for an
homogeneous labeling::

  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 1, 0, 1]))
  0.0...
  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 0, 0, 0]))
  0.0...
</pre> <div class="fragment"><div class="line"><span class="lineno">  498</span><span class="keyword">def </span>homogeneity_score(labels_true, labels_pred):</div>
<div class="line"><span class="lineno">  499</span>    <span class="stringliteral">&quot;&quot;&quot;Homogeneity metric of a cluster labeling given a ground truth.</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    A clustering result satisfies homogeneity if all of its clusters</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    contain only data points which are members of a single class.</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    This metric is independent of the absolute values of the labels:</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    a permutation of the class or cluster label values won&#39;t change the</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    score value in any way.</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    This metric is not symmetric: switching ``label_true`` with ``label_pred``</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    will return the :func:`completeness_score` which will be different in</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    general.</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        Cluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    homogeneity : float</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">       Score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling.</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    completeness_score : Completeness metric of cluster labeling.</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    v_measure_score : V-Measure (NMI with arithmetic mean option).</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    .. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">       conditional entropy-based external cluster evaluation measure</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">       &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    Perfect labelings are homogeneous::</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import homogeneity_score</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">      &gt;&gt;&gt; homogeneity_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    Non-perfect labelings that further split classes into more clusters can be</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    perfectly homogeneous::</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % homogeneity_score([0, 0, 1, 1], [0, 0, 1, 2]))</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">      1.000000</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % homogeneity_score([0, 0, 1, 1], [0, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">      1.000000</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    Clusters that include samples from different classes do not make for an</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    homogeneous labeling::</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % homogeneity_score([0, 0, 1, 1], [0, 1, 0, 1]))</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">      0.0...</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % homogeneity_score([0, 0, 1, 1], [0, 0, 0, 0]))</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">      0.0...</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  564</span>    <span class="keywordflow">return</span> homogeneity_completeness_v_measure(labels_true, labels_pred)[0]</div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acd0dafc12a174d7d2ff094dd71596f06" name="acd0dafc12a174d7d2ff094dd71596f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0dafc12a174d7d2ff094dd71596f06">&#9670;&#160;</a></span>mutual_info_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.mutual_info_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>contingency</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Mutual Information between two clusterings.

The Mutual Information is a measure of the similarity between two labels
of the same data. Where :math:`|U_i|` is the number of the samples
in cluster :math:`U_i` and :math:`|V_j|` is the number of the
samples in cluster :math:`V_j`, the Mutual Information
between clusterings :math:`U` and :math:`V` is given as:

.. math::

    MI(U,V)=\\sum_{i=1}^{|U|} \\sum_{j=1}^{|V|} \\frac{|U_i\\cap V_j|}{N}
    \\log\\frac{N|U_i \\cap V_j|}{|U_i||V_j|}

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching :math:`U` (i.e
``label_true``) with :math:`V` (i.e. ``label_pred``) will return the
same score value. This can be useful to measure the agreement of two
independent label assignments strategies on the same dataset when the
real ground truth is not known.

Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    A clustering of the data into disjoint subsets, called :math:`U` in
    the above formula.

labels_pred : int array-like of shape (n_samples,)
    A clustering of the data into disjoint subsets, called :math:`V` in
    the above formula.

contingency : {ndarray, sparse matrix} of shape \
        (n_classes_true, n_classes_pred), default=None
    A contingency matrix given by the :func:`contingency_matrix` function.
    If value is ``None``, it will be computed, otherwise the given value is
    used, with ``labels_true`` and ``labels_pred`` ignored.

Returns
-------
mi : float
   Mutual information, a non-negative value, measured in nats using the
   natural logarithm.

See Also
--------
adjusted_mutual_info_score : Adjusted against chance Mutual Information.
normalized_mutual_info_score : Normalized Mutual Information.

Notes
-----
The logarithm used is the natural logarithm (base-e).
</pre> <div class="fragment"><div class="line"><span class="lineno">  732</span><span class="keyword">def </span>mutual_info_score(labels_true, labels_pred, *, contingency=None):</div>
<div class="line"><span class="lineno">  733</span>    <span class="stringliteral">&quot;&quot;&quot;Mutual Information between two clusterings.</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    The Mutual Information is a measure of the similarity between two labels</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    of the same data. Where :math:`|U_i|` is the number of the samples</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    in cluster :math:`U_i` and :math:`|V_j|` is the number of the</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    samples in cluster :math:`V_j`, the Mutual Information</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    between clusterings :math:`U` and :math:`V` is given as:</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        MI(U,V)=\\sum_{i=1}^{|U|} \\sum_{j=1}^{|V|} \\frac{|U_i\\cap V_j|}{N}</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        \\log\\frac{N|U_i \\cap V_j|}{|U_i||V_j|}</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    This metric is independent of the absolute values of the labels:</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    a permutation of the class or cluster label values won&#39;t change the</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    score value in any way.</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    This metric is furthermore symmetric: switching :math:`U` (i.e</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    ``label_true``) with :math:`V` (i.e. ``label_pred``) will return the</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    same score value. This can be useful to measure the agreement of two</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    independent label assignments strategies on the same dataset when the</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    real ground truth is not known.</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        A clustering of the data into disjoint subsets, called :math:`U` in</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        the above formula.</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    labels_pred : int array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        A clustering of the data into disjoint subsets, called :math:`V` in</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        the above formula.</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    contingency : {ndarray, sparse matrix} of shape \</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">            (n_classes_true, n_classes_pred), default=None</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        A contingency matrix given by the :func:`contingency_matrix` function.</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        If value is ``None``, it will be computed, otherwise the given value is</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">        used, with ``labels_true`` and ``labels_pred`` ignored.</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    mi : float</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">       Mutual information, a non-negative value, measured in nats using the</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">       natural logarithm.</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    adjusted_mutual_info_score : Adjusted against chance Mutual Information.</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    normalized_mutual_info_score : Normalized Mutual Information.</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    The logarithm used is the natural logarithm (base-e).</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  789</span>    <span class="keywordflow">if</span> contingency <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  790</span>        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)</div>
<div class="line"><span class="lineno">  791</span>        contingency = contingency_matrix(labels_true, labels_pred, sparse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  792</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  793</span>        contingency = check_array(</div>
<div class="line"><span class="lineno">  794</span>            contingency,</div>
<div class="line"><span class="lineno">  795</span>            accept_sparse=[<span class="stringliteral">&quot;csr&quot;</span>, <span class="stringliteral">&quot;csc&quot;</span>, <span class="stringliteral">&quot;coo&quot;</span>],</div>
<div class="line"><span class="lineno">  796</span>            dtype=[int, np.int32, np.int64],</div>
<div class="line"><span class="lineno">  797</span>        )</div>
<div class="line"><span class="lineno">  798</span> </div>
<div class="line"><span class="lineno">  799</span>    <span class="keywordflow">if</span> isinstance(contingency, np.ndarray):</div>
<div class="line"><span class="lineno">  800</span>        <span class="comment"># For an array</span></div>
<div class="line"><span class="lineno">  801</span>        nzx, nzy = np.nonzero(contingency)</div>
<div class="line"><span class="lineno">  802</span>        nz_val = contingency[nzx, nzy]</div>
<div class="line"><span class="lineno">  803</span>    <span class="keywordflow">elif</span> sp.issparse(contingency):</div>
<div class="line"><span class="lineno">  804</span>        <span class="comment"># For a sparse matrix</span></div>
<div class="line"><span class="lineno">  805</span>        nzx, nzy, nz_val = sp.find(contingency)</div>
<div class="line"><span class="lineno">  806</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  807</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unsupported type for &#39;contingency&#39;: %s&quot;</span> % type(contingency))</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>    contingency_sum = contingency.sum()</div>
<div class="line"><span class="lineno">  810</span>    pi = np.ravel(contingency.sum(axis=1))</div>
<div class="line"><span class="lineno">  811</span>    pj = np.ravel(contingency.sum(axis=0))</div>
<div class="line"><span class="lineno">  812</span> </div>
<div class="line"><span class="lineno">  813</span>    <span class="comment"># Since MI &lt;= min(H(X), H(Y)), any labelling with zero entropy, i.e. containing a</span></div>
<div class="line"><span class="lineno">  814</span>    <span class="comment"># single cluster, implies MI = 0</span></div>
<div class="line"><span class="lineno">  815</span>    <span class="keywordflow">if</span> pi.size == 1 <span class="keywordflow">or</span> pj.size == 1:</div>
<div class="line"><span class="lineno">  816</span>        <span class="keywordflow">return</span> 0.0</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span>    log_contingency_nm = np.log(nz_val)</div>
<div class="line"><span class="lineno">  819</span>    contingency_nm = nz_val / contingency_sum</div>
<div class="line"><span class="lineno">  820</span>    <span class="comment"># Don&#39;t need to calculate the full outer product, just for non-zeroes</span></div>
<div class="line"><span class="lineno">  821</span>    outer = pi.take(nzx).astype(np.int64, copy=<span class="keyword">False</span>) * pj.take(nzy).astype(</div>
<div class="line"><span class="lineno">  822</span>        np.int64, copy=<span class="keyword">False</span></div>
<div class="line"><span class="lineno">  823</span>    )</div>
<div class="line"><span class="lineno">  824</span>    log_outer = -np.log(outer) + log(pi.sum()) + log(pj.sum())</div>
<div class="line"><span class="lineno">  825</span>    mi = (</div>
<div class="line"><span class="lineno">  826</span>        contingency_nm * (log_contingency_nm - log(contingency_sum))</div>
<div class="line"><span class="lineno">  827</span>        + contingency_nm * log_outer</div>
<div class="line"><span class="lineno">  828</span>    )</div>
<div class="line"><span class="lineno">  829</span>    mi = np.where(np.abs(mi) &lt; np.finfo(mi.dtype).eps, 0.0, mi)</div>
<div class="line"><span class="lineno">  830</span>    <span class="keywordflow">return</span> np.clip(mi.sum(), 0.0, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afd4102c2e09acfb54cdac2c0ccd50964" name="afd4102c2e09acfb54cdac2c0ccd50964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4102c2e09acfb54cdac2c0ccd50964">&#9670;&#160;</a></span>normalized_mutual_info_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.normalized_mutual_info_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>average_method</em> = <code>&quot;arithmetic&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Normalized Mutual Information between two clusterings.

Normalized Mutual Information (NMI) is a normalization of the Mutual
Information (MI) score to scale the results between 0 (no mutual
information) and 1 (perfect correlation). In this function, mutual
information is normalized by some generalized mean of ``H(labels_true)``
and ``H(labels_pred))``, defined by the `average_method`.

This measure is not adjusted for chance. Therefore
:func:`adjusted_mutual_info_score` might be preferred.

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching ``label_true`` with
``label_pred`` will return the same score value. This can be useful to
measure the agreement of two independent label assignments strategies
on the same dataset when the real ground truth is not known.

Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    A clustering of the data into disjoint subsets.

labels_pred : int array-like of shape (n_samples,)
    A clustering of the data into disjoint subsets.

average_method : str, default='arithmetic'
    How to compute the normalizer in the denominator. Possible options
    are 'min', 'geometric', 'arithmetic', and 'max'.

    .. versionadded:: 0.20

    .. versionchanged:: 0.22
       The default value of ``average_method`` changed from 'geometric' to
       'arithmetic'.

Returns
-------
nmi : float
   Score between 0.0 and 1.0 in normalized nats (based on the natural
   logarithm). 1.0 stands for perfectly complete labeling.

See Also
--------
v_measure_score : V-Measure (NMI with arithmetic mean option).
adjusted_rand_score : Adjusted Rand Index.
adjusted_mutual_info_score : Adjusted Mutual Information (adjusted
    against chance).

Examples
--------

Perfect labelings are both homogeneous and complete, hence have
score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import normalized_mutual_info_score
  &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])
  ... # doctest: +SKIP
  1.0
  &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])
  ... # doctest: +SKIP
  1.0

If classes members are completely split across different clusters,
the assignment is totally in-complete, hence the NMI is null::

  &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])
  ... # doctest: +SKIP
  0.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  962</span>):</div>
<div class="line"><span class="lineno">  963</span>    <span class="stringliteral">&quot;&quot;&quot;Normalized Mutual Information between two clusterings.</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    Normalized Mutual Information (NMI) is a normalization of the Mutual</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    Information (MI) score to scale the results between 0 (no mutual</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    information) and 1 (perfect correlation). In this function, mutual</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    information is normalized by some generalized mean of ``H(labels_true)``</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    and ``H(labels_pred))``, defined by the `average_method`.</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    This measure is not adjusted for chance. Therefore</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">    :func:`adjusted_mutual_info_score` might be preferred.</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">    This metric is independent of the absolute values of the labels:</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    a permutation of the class or cluster label values won&#39;t change the</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    score value in any way.</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    This metric is furthermore symmetric: switching ``label_true`` with</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    ``label_pred`` will return the same score value. This can be useful to</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    measure the agreement of two independent label assignments strategies</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    on the same dataset when the real ground truth is not known.</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">        A clustering of the data into disjoint subsets.</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    labels_pred : int array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">        A clustering of the data into disjoint subsets.</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    average_method : str, default=&#39;arithmetic&#39;</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">        How to compute the normalizer in the denominator. Possible options</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">        are &#39;min&#39;, &#39;geometric&#39;, &#39;arithmetic&#39;, and &#39;max&#39;.</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">           The default value of ``average_method`` changed from &#39;geometric&#39; to</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">           &#39;arithmetic&#39;.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    nmi : float</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">       Score between 0.0 and 1.0 in normalized nats (based on the natural</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">       logarithm). 1.0 stands for perfectly complete labeling.</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    v_measure_score : V-Measure (NMI with arithmetic mean option).</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    adjusted_rand_score : Adjusted Rand Index.</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    adjusted_mutual_info_score : Adjusted Mutual Information (adjusted</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">        against chance).</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    Perfect labelings are both homogeneous and complete, hence have</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    score 1.0::</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import normalized_mutual_info_score</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">      &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">      ... # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">      &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">      ... # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    If classes members are completely split across different clusters,</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    the assignment is totally in-complete, hence the NMI is null::</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">      &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">      ... # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">      0.0</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1037</span>    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)</div>
<div class="line"><span class="lineno"> 1038</span>    classes = np.unique(labels_true)</div>
<div class="line"><span class="lineno"> 1039</span>    clusters = np.unique(labels_pred)</div>
<div class="line"><span class="lineno"> 1040</span> </div>
<div class="line"><span class="lineno"> 1041</span>    <span class="comment"># Special limit cases: no clustering since the data is not split.</span></div>
<div class="line"><span class="lineno"> 1042</span>    <span class="comment"># It corresponds to both labellings having zero entropy.</span></div>
<div class="line"><span class="lineno"> 1043</span>    <span class="comment"># This is a perfect match hence return 1.0.</span></div>
<div class="line"><span class="lineno"> 1044</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1045</span>        classes.shape[0] == clusters.shape[0] == 1</div>
<div class="line"><span class="lineno"> 1046</span>        <span class="keywordflow">or</span> classes.shape[0] == clusters.shape[0] == 0</div>
<div class="line"><span class="lineno"> 1047</span>    ):</div>
<div class="line"><span class="lineno"> 1048</span>        <span class="keywordflow">return</span> 1.0</div>
<div class="line"><span class="lineno"> 1049</span> </div>
<div class="line"><span class="lineno"> 1050</span>    contingency = contingency_matrix(labels_true, labels_pred, sparse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1051</span>    contingency = contingency.astype(np.float64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1052</span>    <span class="comment"># Calculate the MI for the two clusterings</span></div>
<div class="line"><span class="lineno"> 1053</span>    mi = mutual_info_score(labels_true, labels_pred, contingency=contingency)</div>
<div class="line"><span class="lineno"> 1054</span> </div>
<div class="line"><span class="lineno"> 1055</span>    <span class="comment"># At this point mi = 0 can&#39;t be a perfect match (the special case of a single</span></div>
<div class="line"><span class="lineno"> 1056</span>    <span class="comment"># cluster has been dealt with before). Hence, if mi = 0, the nmi must be 0 whatever</span></div>
<div class="line"><span class="lineno"> 1057</span>    <span class="comment"># the normalization.</span></div>
<div class="line"><span class="lineno"> 1058</span>    <span class="keywordflow">if</span> mi == 0:</div>
<div class="line"><span class="lineno"> 1059</span>        <span class="keywordflow">return</span> 0.0</div>
<div class="line"><span class="lineno"> 1060</span> </div>
<div class="line"><span class="lineno"> 1061</span>    <span class="comment"># Calculate entropy for each labeling</span></div>
<div class="line"><span class="lineno"> 1062</span>    h_true, h_pred = entropy(labels_true), entropy(labels_pred)</div>
<div class="line"><span class="lineno"> 1063</span> </div>
<div class="line"><span class="lineno"> 1064</span>    normalizer = _generalized_average(h_true, h_pred, average_method)</div>
<div class="line"><span class="lineno"> 1065</span>    <span class="keywordflow">return</span> mi / normalizer</div>
<div class="line"><span class="lineno"> 1066</span> </div>
<div class="line"><span class="lineno"> 1067</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a91e10db8525d943e132641d887df35d1" name="a91e10db8525d943e132641d887df35d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e10db8525d943e132641d887df35d1">&#9670;&#160;</a></span>pair_confusion_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.pair_confusion_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pair confusion matrix arising from two clusterings [1]_.

The pair confusion matrix :math:`C` computes a 2 by 2 similarity matrix
between two clusterings by considering all pairs of samples and counting
pairs that are assigned into the same or into different clusters under
the true and predicted clusterings.

Considering a pair of samples that is clustered together a positive pair,
then as in binary classification the count of true negatives is
:math:`C_{00}`, false negatives is :math:`C_{10}`, true positives is
:math:`C_{11}` and false positives is :math:`C_{01}`.

Read more in the :ref:`User Guide &lt;pair_confusion_matrix&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,), dtype=integral
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,), dtype=integral
    Cluster labels to evaluate.

Returns
-------
C : ndarray of shape (2, 2), dtype=np.int64
    The contingency matrix.

See Also
--------
rand_score: Rand Score.
adjusted_rand_score: Adjusted Rand Score.
adjusted_mutual_info_score: Adjusted Mutual Information.

References
----------
.. [1] :doi:`Hubert, L., Arabie, P. "Comparing partitions."
       Journal of Classification 2, 193–218 (1985).
       &lt;10.1007/BF01908075&gt;`

Examples
--------
Perfectly matching labelings have all non-zero entries on the
diagonal regardless of actual label values:

  &gt;&gt;&gt; from sklearn.metrics.cluster import pair_confusion_matrix
  &gt;&gt;&gt; pair_confusion_matrix([0, 0, 1, 1], [1, 1, 0, 0])
  array([[8, 0],
         [0, 4]]...

Labelings that assign all classes members to the same clusters
are complete but may be not always pure, hence penalized, and
have some off-diagonal non-zero entries:

  &gt;&gt;&gt; pair_confusion_matrix([0, 0, 1, 2], [0, 0, 1, 1])
  array([[8, 2],
         [0, 2]]...

Note that the matrix is not symmetric.
</pre> <div class="fragment"><div class="line"><span class="lineno">  161</span><span class="keyword">def </span>pair_confusion_matrix(labels_true, labels_pred):</div>
<div class="line"><span class="lineno">  162</span>    <span class="stringliteral">&quot;&quot;&quot;Pair confusion matrix arising from two clusterings [1]_.</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    The pair confusion matrix :math:`C` computes a 2 by 2 similarity matrix</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    between two clusterings by considering all pairs of samples and counting</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    pairs that are assigned into the same or into different clusters under</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    the true and predicted clusterings.</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    Considering a pair of samples that is clustered together a positive pair,</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    then as in binary classification the count of true negatives is</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    :math:`C_{00}`, false negatives is :math:`C_{10}`, true positives is</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    :math:`C_{11}` and false positives is :math:`C_{01}`.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;pair_confusion_matrix&gt;`.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    labels_true : array-like of shape (n_samples,), dtype=integral</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,), dtype=integral</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        Cluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    C : ndarray of shape (2, 2), dtype=np.int64</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">        The contingency matrix.</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    rand_score: Rand Score.</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    adjusted_rand_score: Adjusted Rand Score.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    adjusted_mutual_info_score: Adjusted Mutual Information.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    .. [1] :doi:`Hubert, L., Arabie, P. &quot;Comparing partitions.&quot;</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">           Journal of Classification 2, 193–218 (1985).</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">           &lt;10.1007/BF01908075&gt;`</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Perfectly matching labelings have all non-zero entries on the</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    diagonal regardless of actual label values:</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import pair_confusion_matrix</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">      &gt;&gt;&gt; pair_confusion_matrix([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">      array([[8, 0],</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">             [0, 4]]...</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Labelings that assign all classes members to the same clusters</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    are complete but may be not always pure, hence penalized, and</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    have some off-diagonal non-zero entries:</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">      &gt;&gt;&gt; pair_confusion_matrix([0, 0, 1, 2], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">      array([[8, 2],</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">             [0, 2]]...</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    Note that the matrix is not symmetric.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  221</span>    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)</div>
<div class="line"><span class="lineno">  222</span>    n_samples = np.int64(labels_true.shape[0])</div>
<div class="line"><span class="lineno">  223</span> </div>
<div class="line"><span class="lineno">  224</span>    <span class="comment"># Computation using the contingency data</span></div>
<div class="line"><span class="lineno">  225</span>    contingency = contingency_matrix(</div>
<div class="line"><span class="lineno">  226</span>        labels_true, labels_pred, sparse=<span class="keyword">True</span>, dtype=np.int64</div>
<div class="line"><span class="lineno">  227</span>    )</div>
<div class="line"><span class="lineno">  228</span>    n_c = np.ravel(contingency.sum(axis=1))</div>
<div class="line"><span class="lineno">  229</span>    n_k = np.ravel(contingency.sum(axis=0))</div>
<div class="line"><span class="lineno">  230</span>    sum_squares = (contingency.data**2).sum()</div>
<div class="line"><span class="lineno">  231</span>    C = np.empty((2, 2), dtype=np.int64)</div>
<div class="line"><span class="lineno">  232</span>    C[1, 1] = sum_squares - n_samples</div>
<div class="line"><span class="lineno">  233</span>    C[0, 1] = contingency.dot(n_k).sum() - sum_squares</div>
<div class="line"><span class="lineno">  234</span>    C[1, 0] = contingency.transpose().dot(n_c).sum() - sum_squares</div>
<div class="line"><span class="lineno">  235</span>    C[0, 0] = n_samples**2 - C[0, 1] - C[1, 0] - sum_squares</div>
<div class="line"><span class="lineno">  236</span>    <span class="keywordflow">return</span> C</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a730947c8e7e9b0e67c8b8e2370accf67" name="a730947c8e7e9b0e67c8b8e2370accf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730947c8e7e9b0e67c8b8e2370accf67">&#9670;&#160;</a></span>rand_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.rand_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rand index.

The Rand Index computes a similarity measure between two clusterings
by considering all pairs of samples and counting pairs that are
assigned in the same or different clusters in the predicted and
true clusterings [1]_ [2]_.

The raw RI score [3]_ is:

    RI = (number of agreeing pairs) / (number of pairs)

Read more in the :ref:`User Guide &lt;rand_score&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,), dtype=integral
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,), dtype=integral
    Cluster labels to evaluate.

Returns
-------
RI : float
   Similarity score between 0.0 and 1.0, inclusive, 1.0 stands for
   perfect match.

See Also
--------
adjusted_rand_score: Adjusted Rand Score.
adjusted_mutual_info_score: Adjusted Mutual Information.

References
----------
.. [1] :doi:`Hubert, L., Arabie, P. "Comparing partitions."
   Journal of Classification 2, 193–218 (1985).
   &lt;10.1007/BF01908075&gt;`.

.. [2] `Wikipedia: Simple Matching Coefficient
    &lt;https://en.wikipedia.org/wiki/Simple_matching_coefficient&gt;`_

.. [3] `Wikipedia: Rand Index &lt;https://en.wikipedia.org/wiki/Rand_index&gt;`_

Examples
--------
Perfectly matching labelings have a score of 1 even

  &gt;&gt;&gt; from sklearn.metrics.cluster import rand_score
  &gt;&gt;&gt; rand_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Labelings that assign all classes members to the same clusters
are complete but may not always be pure, hence penalized:

  &gt;&gt;&gt; rand_score([0, 0, 1, 2], [0, 0, 1, 1])
  0.83...
</pre> <div class="fragment"><div class="line"><span class="lineno">  239</span><span class="keyword">def </span>rand_score(labels_true, labels_pred):</div>
<div class="line"><span class="lineno">  240</span>    <span class="stringliteral">&quot;&quot;&quot;Rand index.</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    The Rand Index computes a similarity measure between two clusterings</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    by considering all pairs of samples and counting pairs that are</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    assigned in the same or different clusters in the predicted and</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    true clusterings [1]_ [2]_.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    The raw RI score [3]_ is:</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        RI = (number of agreeing pairs) / (number of pairs)</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;rand_score&gt;`.</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    labels_true : array-like of shape (n_samples,), dtype=integral</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,), dtype=integral</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        Cluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    RI : float</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">       Similarity score between 0.0 and 1.0, inclusive, 1.0 stands for</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">       perfect match.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    adjusted_rand_score: Adjusted Rand Score.</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    adjusted_mutual_info_score: Adjusted Mutual Information.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    .. [1] :doi:`Hubert, L., Arabie, P. &quot;Comparing partitions.&quot;</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">       Journal of Classification 2, 193–218 (1985).</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">       &lt;10.1007/BF01908075&gt;`.</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    .. [2] `Wikipedia: Simple Matching Coefficient</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        &lt;https://en.wikipedia.org/wiki/Simple_matching_coefficient&gt;`_</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    .. [3] `Wikipedia: Rand Index &lt;https://en.wikipedia.org/wiki/Rand_index&gt;`_</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    Perfectly matching labelings have a score of 1 even</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import rand_score</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">      &gt;&gt;&gt; rand_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    Labelings that assign all classes members to the same clusters</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    are complete but may not always be pure, hence penalized:</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">      &gt;&gt;&gt; rand_score([0, 0, 1, 2], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">      0.83...</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  297</span>    contingency = pair_confusion_matrix(labels_true, labels_pred)</div>
<div class="line"><span class="lineno">  298</span>    numerator = contingency.diagonal().sum()</div>
<div class="line"><span class="lineno">  299</span>    denominator = contingency.sum()</div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>    <span class="keywordflow">if</span> numerator == denominator <span class="keywordflow">or</span> denominator == 0:</div>
<div class="line"><span class="lineno">  302</span>        <span class="comment"># Special limit cases: no clustering since the data is not split;</span></div>
<div class="line"><span class="lineno">  303</span>        <span class="comment"># or trivial clustering where each document is assigned a unique</span></div>
<div class="line"><span class="lineno">  304</span>        <span class="comment"># cluster. These are perfect matches hence return 1.0.</span></div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordflow">return</span> 1.0</div>
<div class="line"><span class="lineno">  306</span> </div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">return</span> numerator / denominator</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a711f406b9bc0a884c92cf76c0f31e5be" name="a711f406b9bc0a884c92cf76c0f31e5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711f406b9bc0a884c92cf76c0f31e5be">&#9670;&#160;</a></span>v_measure_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.v_measure_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>beta</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">V-measure cluster labeling given a ground truth.

This score is identical to :func:`normalized_mutual_info_score` with
the ``'arithmetic'`` option for averaging.

The V-measure is the harmonic mean between homogeneity and completeness::

    v = (1 + beta) * homogeneity * completeness
         / (beta * homogeneity + completeness)

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching ``label_true`` with
``label_pred`` will return the same score value. This can be useful to
measure the agreement of two independent label assignments strategies
on the same dataset when the real ground truth is not known.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : int array, shape = [n_samples]
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

beta : float, default=1.0
    Ratio of weight attributed to ``homogeneity`` vs ``completeness``.
    If ``beta`` is greater than 1, ``completeness`` is weighted more
    strongly in the calculation. If ``beta`` is less than 1,
    ``homogeneity`` is weighted more strongly.

Returns
-------
v_measure : float
   Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.

See Also
--------
homogeneity_score : Homogeneity metric of cluster labeling.
completeness_score : Completeness metric of cluster labeling.
normalized_mutual_info_score : Normalized Mutual Information.

References
----------

.. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   conditional entropy-based external cluster evaluation measure
   &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_

Examples
--------
Perfect labelings are both homogeneous and complete, hence have score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import v_measure_score
  &gt;&gt;&gt; v_measure_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; v_measure_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Labelings that assign all classes members to the same clusters
are complete but not homogeneous, hence penalized::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 2], [0, 0, 1, 1]))
  0.8...
  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 1, 2, 3], [0, 0, 1, 1]))
  0.66...

Labelings that have pure clusters with members coming from the same
classes are homogeneous but un-necessary splits harm completeness
and thus penalize V-measure as well::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 0, 1, 2]))
  0.8...
  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 1, 2, 3]))
  0.66...

If classes members are completely split across different clusters,
the assignment is totally incomplete, hence the V-Measure is null::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 0, 0], [0, 1, 2, 3]))
  0.0...

Clusters that include samples from totally different classes totally
destroy the homogeneity of the labeling, hence::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 0, 0, 0]))
  0.0...
</pre> <div class="fragment"><div class="line"><span class="lineno">  636</span><span class="keyword">def </span>v_measure_score(labels_true, labels_pred, *, beta=1.0):</div>
<div class="line"><span class="lineno">  637</span>    <span class="stringliteral">&quot;&quot;&quot;V-measure cluster labeling given a ground truth.</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    This score is identical to :func:`normalized_mutual_info_score` with</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    the ``&#39;arithmetic&#39;`` option for averaging.</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    The V-measure is the harmonic mean between homogeneity and completeness::</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">        v = (1 + beta) * homogeneity * completeness</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">             / (beta * homogeneity + completeness)</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    This metric is independent of the absolute values of the labels:</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    a permutation of the class or cluster label values won&#39;t change the</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    score value in any way.</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    This metric is furthermore symmetric: switching ``label_true`` with</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    ``label_pred`` will return the same score value. This can be useful to</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    measure the agreement of two independent label assignments strategies</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    on the same dataset when the real ground truth is not known.</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    labels_true : int array, shape = [n_samples]</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">        Ground truth class labels to be used as a reference.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    labels_pred : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">        Cluster labels to evaluate.</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    beta : float, default=1.0</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">        Ratio of weight attributed to ``homogeneity`` vs ``completeness``.</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">        If ``beta`` is greater than 1, ``completeness`` is weighted more</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">        strongly in the calculation. If ``beta`` is less than 1,</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        ``homogeneity`` is weighted more strongly.</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    v_measure : float</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">       Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    homogeneity_score : Homogeneity metric of cluster labeling.</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    completeness_score : Completeness metric of cluster labeling.</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    normalized_mutual_info_score : Normalized Mutual Information.</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    .. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">       conditional entropy-based external cluster evaluation measure</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">       &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    Perfect labelings are both homogeneous and complete, hence have score 1.0::</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">      &gt;&gt;&gt; from sklearn.metrics.cluster import v_measure_score</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">      &gt;&gt;&gt; v_measure_score([0, 0, 1, 1], [0, 0, 1, 1])</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">      &gt;&gt;&gt; v_measure_score([0, 0, 1, 1], [1, 1, 0, 0])</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">      1.0</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    Labelings that assign all classes members to the same clusters</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    are complete but not homogeneous, hence penalized::</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % v_measure_score([0, 0, 1, 2], [0, 0, 1, 1]))</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">      0.8...</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % v_measure_score([0, 1, 2, 3], [0, 0, 1, 1]))</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">      0.66...</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    Labelings that have pure clusters with members coming from the same</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    classes are homogeneous but un-necessary splits harm completeness</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    and thus penalize V-measure as well::</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % v_measure_score([0, 0, 1, 1], [0, 0, 1, 2]))</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">      0.8...</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % v_measure_score([0, 0, 1, 1], [0, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">      0.66...</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    If classes members are completely split across different clusters,</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    the assignment is totally incomplete, hence the V-Measure is null::</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % v_measure_score([0, 0, 0, 0], [0, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">      0.0...</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    Clusters that include samples from totally different classes totally</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    destroy the homogeneity of the labeling, hence::</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">      &gt;&gt;&gt; print(&quot;%.6f&quot; % v_measure_score([0, 0, 1, 1], [0, 0, 0, 0]))</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">      0.0...</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  729</span>    <span class="keywordflow">return</span> homogeneity_completeness_v_measure(labels_true, labels_pred, beta=beta)[2]</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
