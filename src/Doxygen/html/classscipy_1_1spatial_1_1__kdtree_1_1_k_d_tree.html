<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.spatial._kdtree.KDTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1spatial.html">spatial</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1spatial_1_1__kdtree.html">_kdtree</a></li><li class="navelem"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html">KDTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scipy.spatial._kdtree.KDTree Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for scipy.spatial._kdtree.KDTree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree_1_1innernode.html">innernode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree_1_1leafnode.html">leafnode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree_1_1node.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a242bf6f29c9115d103e8f1f5f043452d" id="r_a242bf6f29c9115d103e8f1f5f043452d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a242bf6f29c9115d103e8f1f5f043452d">tree</a> (self)</td></tr>
<tr class="separator:a242bf6f29c9115d103e8f1f5f043452d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f49765dc2cdd2f39a566739edd13b4" id="r_a59f49765dc2cdd2f39a566739edd13b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a59f49765dc2cdd2f39a566739edd13b4">__init__</a> (self, data, leafsize=10, compact_nodes=True, copy_data=False, balanced_tree=True, boxsize=None)</td></tr>
<tr class="separator:a59f49765dc2cdd2f39a566739edd13b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126e43a27df314c23b9f13a34f3bee08" id="r_a126e43a27df314c23b9f13a34f3bee08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a126e43a27df314c23b9f13a34f3bee08">query</a> (self, x, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>=1, <a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=0, p=2, distance_upper_bound=np.inf, workers=1)</td></tr>
<tr class="separator:a126e43a27df314c23b9f13a34f3bee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f19f0b1745e1ae911a00b3e8b24766" id="r_a48f19f0b1745e1ae911a00b3e8b24766"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a48f19f0b1745e1ae911a00b3e8b24766">query_ball_point</a> (self, x, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, p=2., <a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=0, workers=1, return_sorted=None, return_length=False)</td></tr>
<tr class="separator:a48f19f0b1745e1ae911a00b3e8b24766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca7883c186ff9961ab66a48ed4a5f80" id="r_a1ca7883c186ff9961ab66a48ed4a5f80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a1ca7883c186ff9961ab66a48ed4a5f80">query_ball_tree</a> (self, other, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, p=2., <a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=0)</td></tr>
<tr class="separator:a1ca7883c186ff9961ab66a48ed4a5f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6571b7cc900c8c68e65ada465f650e" id="r_a6e6571b7cc900c8c68e65ada465f650e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a6e6571b7cc900c8c68e65ada465f650e">query_pairs</a> (self, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, p=2., <a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a>=0, output_type='set')</td></tr>
<tr class="separator:a6e6571b7cc900c8c68e65ada465f650e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96012fbd0af1ff0a91e6caafd36698f7" id="r_a96012fbd0af1ff0a91e6caafd36698f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a96012fbd0af1ff0a91e6caafd36698f7">count_neighbors</a> (self, other, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, p=2., weights=None, cumulative=True)</td></tr>
<tr class="separator:a96012fbd0af1ff0a91e6caafd36698f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6af0fd0efe438bc22cfd523e6305f4" id="r_a1d6af0fd0efe438bc22cfd523e6305f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a1d6af0fd0efe438bc22cfd523e6305f4">sparse_distance_matrix</a> (self, other, max_distance, p=2., output_type='dok_matrix')</td></tr>
<tr class="separator:a1d6af0fd0efe438bc22cfd523e6305f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4d4282aaf08138f150f841356430acd1" id="r_a4d4282aaf08138f150f841356430acd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1__kdtree_1_1_k_d_tree.html#a4d4282aaf08138f150f841356430acd1">_tree</a></td></tr>
<tr class="separator:a4d4282aaf08138f150f841356430acd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">kd-tree for quick nearest-neighbor lookup.

This class provides an index into a set of k-dimensional points
which can be used to rapidly look up the nearest neighbors of any
point.

Parameters
----------
data : array_like, shape (n,m)
    The n data points of dimension m to be indexed. This array is
    not copied unless this is necessary to produce a contiguous
    array of doubles, and so modifying this data will result in
    bogus results. The data are also copied if the kd-tree is built
    with copy_data=True.
leafsize : positive int, optional
    The number of points at which the algorithm switches over to
    brute-force.  Default: 10.
compact_nodes : bool, optional
    If True, the kd-tree is built to shrink the hyperrectangles to
    the actual data range. This usually gives a more compact tree that
    is robust against degenerated input data and gives faster queries
    at the expense of longer build time. Default: True.
copy_data : bool, optional
    If True the data is always copied to protect the kd-tree against
    data corruption. Default: False.
balanced_tree : bool, optional
    If True, the median is used to split the hyperrectangles instead of
    the midpoint. This usually gives a more compact tree and
    faster queries at the expense of longer build time. Default: True.
boxsize : array_like or scalar, optional
    Apply a m-d toroidal topology to the KDTree.. The topology is generated
    by :math:`x_i + n_i L_i` where :math:`n_i` are integers and :math:`L_i`
    is the boxsize along i-th dimension. The input data shall be wrapped
    into :math:`[0, L_i)`. A ValueError is raised if any of the data is
    outside of this bound.

Notes
-----
The algorithm used is described in Maneewongvatana and Mount 1999.
The general idea is that the kd-tree is a binary tree, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value.

During construction, the axis and splitting point are chosen by the
"sliding midpoint" rule, which ensures that the cells do not all
become long and thin.

The tree can be queried for the r closest neighbors of any given point
(optionally returning only those within some maximum distance of the
point). It can also be queried, with a substantial gain in efficiency,
for the r approximate closest neighbors.

For large dimensions (20 is already large) do not expect this to run
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.

Attributes
----------
data : ndarray, shape (n,m)
    The n data points of dimension m to be indexed. This array is
    not copied unless this is necessary to produce a contiguous
    array of doubles. The data are also copied if the kd-tree is built
    with `copy_data=True`.
leafsize : positive int
    The number of points at which the algorithm switches over to
    brute-force.
m : int
    The dimension of a single data-point.
n : int
    The number of data points.
maxes : ndarray, shape (m,)
    The maximum value in each dimension of the n data points.
mins : ndarray, shape (m,)
    The minimum value in each dimension of the n data points.
size : int
    The number of nodes in the tree.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a59f49765dc2cdd2f39a566739edd13b4" name="a59f49765dc2cdd2f39a566739edd13b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f49765dc2cdd2f39a566739edd13b4">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leafsize</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compact_nodes</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy_data</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>balanced_tree</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>boxsize</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  337</span>                 balanced_tree=<span class="keyword">True</span>, boxsize=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  338</span>        data = np.asarray(data)</div>
<div class="line"><span class="lineno">  339</span>        <span class="keywordflow">if</span> data.dtype.kind == <span class="stringliteral">&#39;c&#39;</span>:</div>
<div class="line"><span class="lineno">  340</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;KDTree does not work with complex data&quot;</span>)</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>        <span class="comment"># Note KDTree has different default leafsize from cKDTree</span></div>
<div class="line"><span class="lineno">  343</span>        super().__init__(data, leafsize, compact_nodes, copy_data,</div>
<div class="line"><span class="lineno">  344</span>                         balanced_tree, boxsize)</div>
<div class="line"><span class="lineno">  345</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a96012fbd0af1ff0a91e6caafd36698f7" name="a96012fbd0af1ff0a91e6caafd36698f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96012fbd0af1ff0a91e6caafd36698f7">&#9670;&#160;</a></span>count_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.count_neighbors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cumulative</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Count how many nearby pairs can be formed.

Count the number of pairs ``(x1,x2)`` can be formed, with ``x1`` drawn
from ``self`` and ``x2`` drawn from ``other``, and where
``distance(x1, x2, p) &lt;= r``.

Data points on ``self`` and ``other`` are optionally weighted by the
``weights`` argument. (See below)

This is adapted from the "two-point correlation" algorithm described by
Gray and Moore [1]_.  See notes for further discussion.

Parameters
----------
other : KDTree
    The other tree to draw points from, can be the same tree as self.
r : float or one-dimensional array of floats
    The radius to produce a count for. Multiple radii are searched with
    a single tree traversal.
    If the count is non-cumulative(``cumulative=False``), ``r`` defines
    the edges of the bins, and must be non-decreasing.
p : float, optional
    1&lt;=p&lt;=infinity.
    Which Minkowski p-norm to use.
    Default 2.0.
    A finite large p may cause a ValueError if overflow can occur.
weights : tuple, array_like, or None, optional
    If None, the pair-counting is unweighted.
    If given as a tuple, weights[0] is the weights of points in
    ``self``, and weights[1] is the weights of points in ``other``;
    either can be None to indicate the points are unweighted.
    If given as an array_like, weights is the weights of points in
    ``self`` and ``other``. For this to make sense, ``self`` and
    ``other`` must be the same tree. If ``self`` and ``other`` are two
    different trees, a ``ValueError`` is raised.
    Default: None

    .. versionadded:: 1.6.0
cumulative : bool, optional
    Whether the returned counts are cumulative. When cumulative is set
    to ``False`` the algorithm is optimized to work with a large number
    of bins (&gt;10) specified by ``r``. When ``cumulative`` is set to
    True, the algorithm is optimized to work with a small number of
    ``r``. Default: True

    .. versionadded:: 1.6.0

Returns
-------
result : scalar or 1-D array
    The number of pairs. For unweighted counts, the result is integer.
    For weighted counts, the result is float.
    If cumulative is False, ``result[i]`` contains the counts with
    ``(-inf if i == 0 else r[i-1]) &lt; R &lt;= r[i]``

Notes
-----
Pair-counting is the basic operation used to calculate the two point
correlation functions from a data set composed of position of objects.

Two point correlation function measures the clustering of objects and
is widely used in cosmology to quantify the large scale structure
in our Universe, but it may be useful for data analysis in other fields
where self-similar assembly of objects also occur.

The Landy-Szalay estimator for the two point correlation function of
``D`` measures the clustering signal in ``D``. [2]_

For example, given the position of two sets of objects,

- objects ``D`` (data) contains the clustering signal, and

- objects ``R`` (random) that contains no signal,

.. math::

     \\xi(r) = \\frac{&lt;D, D&gt; - 2 f &lt;D, R&gt; + f^2&lt;R, R&gt;}{f^2&lt;R, R&gt;},

where the brackets represents counting pairs between two data sets
in a finite bin around ``r`` (distance), corresponding to setting
`cumulative=False`, and ``f = float(len(D)) / float(len(R))`` is the
ratio between number of objects from data and random.

The algorithm implemented here is loosely based on the dual-tree
algorithm described in [1]_. We switch between two different
pair-cumulation scheme depending on the setting of ``cumulative``.
The computing time of the method we use when for
``cumulative == False`` does not scale with the total number of bins.
The algorithm for ``cumulative == True`` scales linearly with the
number of bins, though it is slightly faster when only
1 or 2 bins are used. [5]_.

As an extension to the naive pair-counting,
weighted pair-counting counts the product of weights instead
of number of pairs.
Weighted pair-counting is used to estimate marked correlation functions
([3]_, section 2.2),
or to properly calculate the average of data per distance bin
(e.g. [4]_, section 2.1 on redshift).

.. [1] Gray and Moore,
       "N-body problems in statistical learning",
       Mining the sky, 2000,
       https://arxiv.org/abs/astro-ph/0012333

.. [2] Landy and Szalay,
       "Bias and variance of angular correlation functions",
       The Astrophysical Journal, 1993,
       http://adsabs.harvard.edu/abs/1993ApJ...412...64L

.. [3] Sheth, Connolly and Skibba,
       "Marked correlations in galaxy formation models",
       Arxiv e-print, 2005,
       https://arxiv.org/abs/astro-ph/0511773

.. [4] Hawkins, et al.,
       "The 2dF Galaxy Redshift Survey: correlation functions,
       peculiar velocities and the matter density of the Universe",
       Monthly Notices of the Royal Astronomical Society, 2002,
       http://adsabs.harvard.edu/abs/2003MNRAS.346...78H

.. [5] https://github.com/scipy/scipy/pull/5647#issuecomment-168474926

Examples
--------
You can count neighbors number between two kd-trees within a distance:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.spatial import KDTree
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; points1 = rng.random((5, 2))
&gt;&gt;&gt; points2 = rng.random((5, 2))
&gt;&gt;&gt; kd_tree1 = KDTree(points1)
&gt;&gt;&gt; kd_tree2 = KDTree(points2)
&gt;&gt;&gt; kd_tree1.count_neighbors(kd_tree2, 0.2)
1

This number is same as the total pair number calculated by
`query_ball_tree`:

&gt;&gt;&gt; indexes = kd_tree1.query_ball_tree(kd_tree2, r=0.2)
&gt;&gt;&gt; sum([len(i) for i in indexes])
1</pre> <div class="fragment"><div class="line"><span class="lineno">  638</span>    <span class="keyword">def </span>count_neighbors(self, other, r, p=2., weights=None, cumulative=True):</div>
<div class="line"><span class="lineno">  639</span>        <span class="stringliteral">&quot;&quot;&quot;Count how many nearby pairs can be formed.</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">        Count the number of pairs ``(x1,x2)`` can be formed, with ``x1`` drawn</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        from ``self`` and ``x2`` drawn from ``other``, and where</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">        ``distance(x1, x2, p) &lt;= r``.</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        Data points on ``self`` and ``other`` are optionally weighted by the</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">        ``weights`` argument. (See below)</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">        This is adapted from the &quot;two-point correlation&quot; algorithm described by</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        Gray and Moore [1]_.  See notes for further discussion.</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        other : KDTree</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">            The other tree to draw points from, can be the same tree as self.</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        r : float or one-dimensional array of floats</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">            The radius to produce a count for. Multiple radii are searched with</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">            a single tree traversal.</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">            If the count is non-cumulative(``cumulative=False``), ``r`` defines</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">            the edges of the bins, and must be non-decreasing.</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        p : float, optional</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">            1&lt;=p&lt;=infinity.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">            Which Minkowski p-norm to use.</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">            Default 2.0.</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">            A finite large p may cause a ValueError if overflow can occur.</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        weights : tuple, array_like, or None, optional</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">            If None, the pair-counting is unweighted.</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">            If given as a tuple, weights[0] is the weights of points in</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">            ``self``, and weights[1] is the weights of points in ``other``;</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">            either can be None to indicate the points are unweighted.</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">            If given as an array_like, weights is the weights of points in</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">            ``self`` and ``other``. For this to make sense, ``self`` and</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">            ``other`` must be the same tree. If ``self`` and ``other`` are two</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">            different trees, a ``ValueError`` is raised.</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">            Default: None</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        cumulative : bool, optional</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">            Whether the returned counts are cumulative. When cumulative is set</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">            to ``False`` the algorithm is optimized to work with a large number</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">            of bins (&gt;10) specified by ``r``. When ``cumulative`` is set to</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">            True, the algorithm is optimized to work with a small number of</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">            ``r``. Default: True</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        result : scalar or 1-D array</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">            The number of pairs. For unweighted counts, the result is integer.</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">            For weighted counts, the result is float.</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">            If cumulative is False, ``result[i]`` contains the counts with</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">            ``(-inf if i == 0 else r[i-1]) &lt; R &lt;= r[i]``</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">        Pair-counting is the basic operation used to calculate the two point</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        correlation functions from a data set composed of position of objects.</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        Two point correlation function measures the clustering of objects and</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        is widely used in cosmology to quantify the large scale structure</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        in our Universe, but it may be useful for data analysis in other fields</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        where self-similar assembly of objects also occur.</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        The Landy-Szalay estimator for the two point correlation function of</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">        ``D`` measures the clustering signal in ``D``. [2]_</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">        For example, given the position of two sets of objects,</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">        - objects ``D`` (data) contains the clustering signal, and</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        - objects ``R`` (random) that contains no signal,</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">             \\xi(r) = \\frac{&lt;D, D&gt; - 2 f &lt;D, R&gt; + f^2&lt;R, R&gt;}{f^2&lt;R, R&gt;},</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        where the brackets represents counting pairs between two data sets</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">        in a finite bin around ``r`` (distance), corresponding to setting</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        `cumulative=False`, and ``f = float(len(D)) / float(len(R))`` is the</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">        ratio between number of objects from data and random.</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">        The algorithm implemented here is loosely based on the dual-tree</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">        algorithm described in [1]_. We switch between two different</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">        pair-cumulation scheme depending on the setting of ``cumulative``.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">        The computing time of the method we use when for</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">        ``cumulative == False`` does not scale with the total number of bins.</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">        The algorithm for ``cumulative == True`` scales linearly with the</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        number of bins, though it is slightly faster when only</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">        1 or 2 bins are used. [5]_.</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">        As an extension to the naive pair-counting,</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">        weighted pair-counting counts the product of weights instead</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">        of number of pairs.</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">        Weighted pair-counting is used to estimate marked correlation functions</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        ([3]_, section 2.2),</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        or to properly calculate the average of data per distance bin</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">        (e.g. [4]_, section 2.1 on redshift).</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        .. [1] Gray and Moore,</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">               &quot;N-body problems in statistical learning&quot;,</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">               Mining the sky, 2000,</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">               https://arxiv.org/abs/astro-ph/0012333</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        .. [2] Landy and Szalay,</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">               &quot;Bias and variance of angular correlation functions&quot;,</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">               The Astrophysical Journal, 1993,</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">               http://adsabs.harvard.edu/abs/1993ApJ...412...64L</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        .. [3] Sheth, Connolly and Skibba,</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">               &quot;Marked correlations in galaxy formation models&quot;,</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">               Arxiv e-print, 2005,</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">               https://arxiv.org/abs/astro-ph/0511773</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        .. [4] Hawkins, et al.,</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">               &quot;The 2dF Galaxy Redshift Survey: correlation functions,</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">               peculiar velocities and the matter density of the Universe&quot;,</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">               Monthly Notices of the Royal Astronomical Society, 2002,</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">               http://adsabs.harvard.edu/abs/2003MNRAS.346...78H</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        .. [5] https://github.com/scipy/scipy/pull/5647#issuecomment-168474926</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        You can count neighbors number between two kd-trees within a distance:</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.spatial import KDTree</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">        &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">        &gt;&gt;&gt; points1 = rng.random((5, 2))</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        &gt;&gt;&gt; points2 = rng.random((5, 2))</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree1 = KDTree(points1)</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree2 = KDTree(points2)</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree1.count_neighbors(kd_tree2, 0.2)</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">        1</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        This number is same as the total pair number calculated by</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">        `query_ball_tree`:</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        &gt;&gt;&gt; indexes = kd_tree1.query_ball_tree(kd_tree2, r=0.2)</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">        &gt;&gt;&gt; sum([len(i) for i in indexes])</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">        1</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  784</span>        <span class="keywordflow">return</span> super().count_neighbors(other, r, p, weights, cumulative)</div>
<div class="line"><span class="lineno">  785</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a126e43a27df314c23b9f13a34f3bee08" name="a126e43a27df314c23b9f13a34f3bee08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126e43a27df314c23b9f13a34f3bee08">&#9670;&#160;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance_upper_bound</em> = <code>np.inf</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>workers</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Query the kd-tree for nearest neighbors.

Parameters
----------
x : array_like, last dimension self.m
    An array of points to query.
k : int or Sequence[int], optional
    Either the number of nearest neighbors to return, or a list of the
    k-th nearest neighbors to return, starting from 1.
eps : nonnegative float, optional
    Return approximate nearest neighbors; the kth returned value
    is guaranteed to be no further than (1+eps) times the
    distance to the real kth nearest neighbor.
p : float, 1&lt;=p&lt;=infinity, optional
    Which Minkowski p-norm to use.
    1 is the sum-of-absolute-values distance ("Manhattan" distance).
    2 is the usual Euclidean distance.
    infinity is the maximum-coordinate-difference distance.
    A large, finite p may cause a ValueError if overflow can occur.
distance_upper_bound : nonnegative float, optional
    Return only neighbors within this distance. This is used to prune
    tree searches, so if you are doing a series of nearest-neighbor
    queries, it may help to supply the distance to the nearest neighbor
    of the most recent point.
workers : int, optional
    Number of workers to use for parallel processing. If -1 is given
    all CPU threads are used. Default: 1.

    .. versionadded:: 1.6.0

Returns
-------
d : float or array of floats
    The distances to the nearest neighbors.
    If ``x`` has shape ``tuple+(self.m,)``, then ``d`` has shape
    ``tuple+(k,)``.
    When k == 1, the last dimension of the output is squeezed.
    Missing neighbors are indicated with infinite distances.
    Hits are sorted by distance (nearest first).

    .. versionchanged:: 1.9.0
       Previously if ``k=None``, then `d` was an object array of
       shape ``tuple``, containing lists of distances. This behavior
       has been removed, use `query_ball_point` instead.

i : integer or array of integers
    The index of each neighbor in ``self.data``.
    ``i`` is the same shape as d.
    Missing neighbors are indicated with ``self.n``.

Examples
--------

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.spatial import KDTree
&gt;&gt;&gt; x, y = np.mgrid[0:5, 2:8]
&gt;&gt;&gt; tree = KDTree(np.c_[x.ravel(), y.ravel()])

To query the nearest neighbours and return squeezed result, use

&gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=1)
&gt;&gt;&gt; print(dd, ii, sep='\n')
[2.         0.2236068]
[ 0 13]

To query the nearest neighbours and return unsqueezed result, use

&gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=[1])
&gt;&gt;&gt; print(dd, ii, sep='\n')
[[2.        ]
 [0.2236068]]
[[ 0]
 [13]]

To query the second nearest neighbours and return unsqueezed result,
use

&gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=[2])
&gt;&gt;&gt; print(dd, ii, sep='\n')
[[2.23606798]
 [0.80622577]]
[[ 6]
 [19]]

To query the first and second nearest neighbours, use

&gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=2)
&gt;&gt;&gt; print(dd, ii, sep='\n')
[[2.         2.23606798]
 [0.2236068  0.80622577]]
[[ 0  6]
 [13 19]]

or, be more specific

&gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=[1, 2])
&gt;&gt;&gt; print(dd, ii, sep='\n')
[[2.         2.23606798]
 [0.2236068  0.80622577]]
[[ 0  6]
 [13 19]]</pre> <div class="fragment"><div class="line"><span class="lineno">  347</span>            self, x, k=1, eps=0, p=2, distance_upper_bound=np.inf, workers=1):</div>
<div class="line"><span class="lineno">  348</span>        <span class="stringliteral">r&quot;&quot;&quot;Query the kd-tree for nearest neighbors.</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        x : array_like, last dimension self.m</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">            An array of points to query.</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">        k : int or Sequence[int], optional</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">            Either the number of nearest neighbors to return, or a list of the</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">            k-th nearest neighbors to return, starting from 1.</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        eps : nonnegative float, optional</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">            Return approximate nearest neighbors; the kth returned value</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">            is guaranteed to be no further than (1+eps) times the</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">            distance to the real kth nearest neighbor.</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">        p : float, 1&lt;=p&lt;=infinity, optional</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">            Which Minkowski p-norm to use.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">            1 is the sum-of-absolute-values distance (&quot;Manhattan&quot; distance).</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">            2 is the usual Euclidean distance.</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">            infinity is the maximum-coordinate-difference distance.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">            A large, finite p may cause a ValueError if overflow can occur.</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">        distance_upper_bound : nonnegative float, optional</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">            Return only neighbors within this distance. This is used to prune</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">            tree searches, so if you are doing a series of nearest-neighbor</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">            queries, it may help to supply the distance to the nearest neighbor</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">            of the most recent point.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">        workers : int, optional</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">            Number of workers to use for parallel processing. If -1 is given</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">            all CPU threads are used. Default: 1.</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        d : float or array of floats</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">            The distances to the nearest neighbors.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">            If ``x`` has shape ``tuple+(self.m,)``, then ``d`` has shape</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">            ``tuple+(k,)``.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">            When k == 1, the last dimension of the output is squeezed.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">            Missing neighbors are indicated with infinite distances.</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">            Hits are sorted by distance (nearest first).</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">            .. versionchanged:: 1.9.0</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">               Previously if ``k=None``, then `d` was an object array of</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">               shape ``tuple``, containing lists of distances. This behavior</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">               has been removed, use `query_ball_point` instead.</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">        i : integer or array of integers</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">            The index of each neighbor in ``self.data``.</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">            ``i`` is the same shape as d.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">            Missing neighbors are indicated with ``self.n``.</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">        &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.spatial import KDTree</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">        &gt;&gt;&gt; x, y = np.mgrid[0:5, 2:8]</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">        &gt;&gt;&gt; tree = KDTree(np.c_[x.ravel(), y.ravel()])</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">        To query the nearest neighbours and return squeezed result, use</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">        &gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=1)</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        &gt;&gt;&gt; print(dd, ii, sep=&#39;\n&#39;)</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        [2.         0.2236068]</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        [ 0 13]</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        To query the nearest neighbours and return unsqueezed result, use</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">        &gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=[1])</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        &gt;&gt;&gt; print(dd, ii, sep=&#39;\n&#39;)</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        [[2.        ]</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">         [0.2236068]]</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        [[ 0]</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">         [13]]</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        To query the second nearest neighbours and return unsqueezed result,</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">        use</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">        &gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=[2])</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        &gt;&gt;&gt; print(dd, ii, sep=&#39;\n&#39;)</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">        [[2.23606798]</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">         [0.80622577]]</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">        [[ 6]</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">         [19]]</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        To query the first and second nearest neighbours, use</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        &gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=2)</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        &gt;&gt;&gt; print(dd, ii, sep=&#39;\n&#39;)</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">        [[2.         2.23606798]</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">         [0.2236068  0.80622577]]</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        [[ 0  6]</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">         [13 19]]</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">        or, be more specific</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        &gt;&gt;&gt; dd, ii = tree.query([[0, 0], [2.2, 2.9]], k=[1, 2])</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        &gt;&gt;&gt; print(dd, ii, sep=&#39;\n&#39;)</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        [[2.         2.23606798]</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">         [0.2236068  0.80622577]]</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        [[ 0  6]</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">         [13 19]]</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  451</span>        x = np.asarray(x)</div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordflow">if</span> x.dtype.kind == <span class="stringliteral">&#39;c&#39;</span>:</div>
<div class="line"><span class="lineno">  453</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;KDTree does not work with complex data&quot;</span>)</div>
<div class="line"><span class="lineno">  454</span> </div>
<div class="line"><span class="lineno">  455</span>        <span class="keywordflow">if</span> k <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  456</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;k must be an integer or a sequence of integers&quot;</span>)</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>        d, i = super().query(x, k, eps, p, distance_upper_bound, workers)</div>
<div class="line"><span class="lineno">  459</span>        <span class="keywordflow">if</span> isinstance(i, int):</div>
<div class="line"><span class="lineno">  460</span>            i = np.intp(i)</div>
<div class="line"><span class="lineno">  461</span>        <span class="keywordflow">return</span> d, i</div>
<div class="line"><span class="lineno">  462</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a48f19f0b1745e1ae911a00b3e8b24766" name="a48f19f0b1745e1ae911a00b3e8b24766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f19f0b1745e1ae911a00b3e8b24766">&#9670;&#160;</a></span>query_ball_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.query_ball_point </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>workers</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_sorted</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_length</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all points within distance r of point(s) x.

Parameters
----------
x : array_like, shape tuple + (self.m,)
    The point or points to search for neighbors of.
r : array_like, float
    The radius of points to return, must broadcast to the length of x.
p : float, optional
    Which Minkowski p-norm to use.  Should be in the range [1, inf].
    A finite large p may cause a ValueError if overflow can occur.
eps : nonnegative float, optional
    Approximate search. Branches of the tree are not explored if their
    nearest points are further than ``r / (1 + eps)``, and branches are
    added in bulk if their furthest points are nearer than
    ``r * (1 + eps)``.
workers : int, optional
    Number of jobs to schedule for parallel processing. If -1 is given
    all processors are used. Default: 1.

    .. versionadded:: 1.6.0
return_sorted : bool, optional
    Sorts returned indicies if True and does not sort them if False. If
    None, does not sort single point queries, but does sort
    multi-point queries which was the behavior before this option
    was added.

    .. versionadded:: 1.6.0
return_length : bool, optional
    Return the number of points inside the radius instead of a list
    of the indices.

    .. versionadded:: 1.6.0

Returns
-------
results : list or array of lists
    If `x` is a single point, returns a list of the indices of the
    neighbors of `x`. If `x` is an array of points, returns an object
    array of shape tuple containing lists of neighbors.

Notes
-----
If you have many points whose neighbors you want to find, you may save
substantial amounts of time by putting them in a KDTree and using
query_ball_tree.

Examples
--------
&gt;&gt;&gt; from scipy import spatial
&gt;&gt;&gt; x, y = np.mgrid[0:5, 0:5]
&gt;&gt;&gt; points = np.c_[x.ravel(), y.ravel()]
&gt;&gt;&gt; tree = spatial.KDTree(points)
&gt;&gt;&gt; sorted(tree.query_ball_point([2, 0], 1))
[5, 10, 11, 15]

Query multiple points and plot the results:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; points = np.asarray(points)
&gt;&gt;&gt; plt.plot(points[:,0], points[:,1], '.')
&gt;&gt;&gt; for results in tree.query_ball_point(([2, 0], [3, 3]), 1):
...     nearby_points = points[results]
...     plt.plot(nearby_points[:,0], nearby_points[:,1], 'o')
&gt;&gt;&gt; plt.margins(0.1, 0.1)
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  464</span>                         return_sorted=<span class="keywordtype">None</span>, return_length=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  465</span>        <span class="stringliteral">&quot;&quot;&quot;Find all points within distance r of point(s) x.</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        x : array_like, shape tuple + (self.m,)</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">            The point or points to search for neighbors of.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">        r : array_like, float</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">            The radius of points to return, must broadcast to the length of x.</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        p : float, optional</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">            Which Minkowski p-norm to use.  Should be in the range [1, inf].</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">            A finite large p may cause a ValueError if overflow can occur.</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        eps : nonnegative float, optional</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">            Approximate search. Branches of the tree are not explored if their</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">            nearest points are further than ``r / (1 + eps)``, and branches are</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">            added in bulk if their furthest points are nearer than</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">            ``r * (1 + eps)``.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        workers : int, optional</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">            Number of jobs to schedule for parallel processing. If -1 is given</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">            all processors are used. Default: 1.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        return_sorted : bool, optional</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">            Sorts returned indicies if True and does not sort them if False. If</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">            None, does not sort single point queries, but does sort</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">            multi-point queries which was the behavior before this option</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">            was added.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        return_length : bool, optional</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">            Return the number of points inside the radius instead of a list</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">            of the indices.</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        results : list or array of lists</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">            If `x` is a single point, returns a list of the indices of the</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">            neighbors of `x`. If `x` is an array of points, returns an object</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">            array of shape tuple containing lists of neighbors.</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        If you have many points whose neighbors you want to find, you may save</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        substantial amounts of time by putting them in a KDTree and using</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        query_ball_tree.</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        &gt;&gt;&gt; from scipy import spatial</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        &gt;&gt;&gt; x, y = np.mgrid[0:5, 0:5]</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        &gt;&gt;&gt; points = np.c_[x.ravel(), y.ravel()]</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        &gt;&gt;&gt; tree = spatial.KDTree(points)</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">        &gt;&gt;&gt; sorted(tree.query_ball_point([2, 0], 1))</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        [5, 10, 11, 15]</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        Query multiple points and plot the results:</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        &gt;&gt;&gt; points = np.asarray(points)</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">        &gt;&gt;&gt; plt.plot(points[:,0], points[:,1], &#39;.&#39;)</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">        &gt;&gt;&gt; for results in tree.query_ball_point(([2, 0], [3, 3]), 1):</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        ...     nearby_points = points[results]</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">        ...     plt.plot(nearby_points[:,0], nearby_points[:,1], &#39;o&#39;)</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        &gt;&gt;&gt; plt.margins(0.1, 0.1)</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  533</span>        x = np.asarray(x)</div>
<div class="line"><span class="lineno">  534</span>        <span class="keywordflow">if</span> x.dtype.kind == <span class="stringliteral">&#39;c&#39;</span>:</div>
<div class="line"><span class="lineno">  535</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;KDTree does not work with complex data&quot;</span>)</div>
<div class="line"><span class="lineno">  536</span>        <span class="keywordflow">return</span> super().query_ball_point(</div>
<div class="line"><span class="lineno">  537</span>            x, r, p, eps, workers, return_sorted, return_length)</div>
<div class="line"><span class="lineno">  538</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ca7883c186ff9961ab66a48ed4a5f80" name="a1ca7883c186ff9961ab66a48ed4a5f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca7883c186ff9961ab66a48ed4a5f80">&#9670;&#160;</a></span>query_ball_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.query_ball_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all pairs of points between `self` and `other` whose distance is
at most r.

Parameters
----------
other : KDTree instance
    The tree containing points to search against.
r : float
    The maximum distance, has to be positive.
p : float, optional
    Which Minkowski norm to use.  `p` has to meet the condition
    ``1 &lt;= p &lt;= infinity``.
eps : float, optional
    Approximate search.  Branches of the tree are not explored
    if their nearest points are further than ``r/(1+eps)``, and
    branches are added in bulk if their furthest points are nearer
    than ``r * (1+eps)``.  `eps` has to be non-negative.

Returns
-------
results : list of lists
    For each element ``self.data[i]`` of this tree, ``results[i]`` is a
    list of the indices of its neighbors in ``other.data``.

Examples
--------
You can search all pairs of points between two kd-trees within a distance:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.spatial import KDTree
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; points1 = rng.random((15, 2))
&gt;&gt;&gt; points2 = rng.random((15, 2))
&gt;&gt;&gt; plt.figure(figsize=(6, 6))
&gt;&gt;&gt; plt.plot(points1[:, 0], points1[:, 1], "xk", markersize=14)
&gt;&gt;&gt; plt.plot(points2[:, 0], points2[:, 1], "og", markersize=14)
&gt;&gt;&gt; kd_tree1 = KDTree(points1)
&gt;&gt;&gt; kd_tree2 = KDTree(points2)
&gt;&gt;&gt; indexes = kd_tree1.query_ball_tree(kd_tree2, r=0.2)
&gt;&gt;&gt; for i in range(len(indexes)):
...     for j in indexes[i]:
...         plt.plot([points1[i, 0], points2[j, 0]],
...             [points1[i, 1], points2[j, 1]], "-r")
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  539</span>    <span class="keyword">def </span>query_ball_tree(self, other, r, p=2., eps=0):</div>
<div class="line"><span class="lineno">  540</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        Find all pairs of points between `self` and `other` whose distance is</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        at most r.</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        other : KDTree instance</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">            The tree containing points to search against.</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">        r : float</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">            The maximum distance, has to be positive.</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        p : float, optional</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">            Which Minkowski norm to use.  `p` has to meet the condition</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">            ``1 &lt;= p &lt;= infinity``.</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        eps : float, optional</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">            Approximate search.  Branches of the tree are not explored</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">            if their nearest points are further than ``r/(1+eps)``, and</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">            branches are added in bulk if their furthest points are nearer</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">            than ``r * (1+eps)``.  `eps` has to be non-negative.</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">        results : list of lists</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">            For each element ``self.data[i]`` of this tree, ``results[i]`` is a</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">            list of the indices of its neighbors in ``other.data``.</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        You can search all pairs of points between two kd-trees within a distance:</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.spatial import KDTree</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        &gt;&gt;&gt; points1 = rng.random((15, 2))</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        &gt;&gt;&gt; points2 = rng.random((15, 2))</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">        &gt;&gt;&gt; plt.figure(figsize=(6, 6))</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        &gt;&gt;&gt; plt.plot(points1[:, 0], points1[:, 1], &quot;xk&quot;, markersize=14)</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        &gt;&gt;&gt; plt.plot(points2[:, 0], points2[:, 1], &quot;og&quot;, markersize=14)</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree1 = KDTree(points1)</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree2 = KDTree(points2)</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">        &gt;&gt;&gt; indexes = kd_tree1.query_ball_tree(kd_tree2, r=0.2)</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        &gt;&gt;&gt; for i in range(len(indexes)):</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        ...     for j in indexes[i]:</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        ...         plt.plot([points1[i, 0], points2[j, 0]],</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        ...             [points1[i, 1], points2[j, 1]], &quot;-r&quot;)</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  588</span>        <span class="keywordflow">return</span> super().query_ball_tree(other, r, p, eps)</div>
<div class="line"><span class="lineno">  589</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e6571b7cc900c8c68e65ada465f650e" name="a6e6571b7cc900c8c68e65ada465f650e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6571b7cc900c8c68e65ada465f650e">&#9670;&#160;</a></span>query_pairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.query_pairs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_type</em> = <code>'set'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all pairs of points in `self` whose distance is at most r.

Parameters
----------
r : positive float
    The maximum distance.
p : float, optional
    Which Minkowski norm to use.  `p` has to meet the condition
    ``1 &lt;= p &lt;= infinity``.
eps : float, optional
    Approximate search.  Branches of the tree are not explored
    if their nearest points are further than ``r/(1+eps)``, and
    branches are added in bulk if their furthest points are nearer
    than ``r * (1+eps)``.  `eps` has to be non-negative.
output_type : string, optional
    Choose the output container, 'set' or 'ndarray'. Default: 'set'

    .. versionadded:: 1.6.0

Returns
-------
results : set or ndarray
    Set of pairs ``(i,j)``, with ``i &lt; j``, for which the corresponding
    positions are close. If output_type is 'ndarray', an ndarry is
    returned instead of a set.

Examples
--------
You can search all pairs of points in a kd-tree within a distance:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.spatial import KDTree
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; points = rng.random((20, 2))
&gt;&gt;&gt; plt.figure(figsize=(6, 6))
&gt;&gt;&gt; plt.plot(points[:, 0], points[:, 1], "xk", markersize=14)
&gt;&gt;&gt; kd_tree = KDTree(points)
&gt;&gt;&gt; pairs = kd_tree.query_pairs(r=0.2)
&gt;&gt;&gt; for (i, j) in pairs:
...     plt.plot([points[i, 0], points[j, 0]],
...             [points[i, 1], points[j, 1]], "-r")
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  590</span>    <span class="keyword">def </span>query_pairs(self, r, p=2., eps=0, output_type=&#39;set&#39;):</div>
<div class="line"><span class="lineno">  591</span>        <span class="stringliteral">&quot;&quot;&quot;Find all pairs of points in `self` whose distance is at most r.</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        r : positive float</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">            The maximum distance.</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        p : float, optional</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">            Which Minkowski norm to use.  `p` has to meet the condition</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">            ``1 &lt;= p &lt;= infinity``.</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">        eps : float, optional</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">            Approximate search.  Branches of the tree are not explored</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">            if their nearest points are further than ``r/(1+eps)``, and</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">            branches are added in bulk if their furthest points are nearer</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">            than ``r * (1+eps)``.  `eps` has to be non-negative.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        output_type : string, optional</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">            Choose the output container, &#39;set&#39; or &#39;ndarray&#39;. Default: &#39;set&#39;</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">        results : set or ndarray</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">            Set of pairs ``(i,j)``, with ``i &lt; j``, for which the corresponding</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">            positions are close. If output_type is &#39;ndarray&#39;, an ndarry is</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">            returned instead of a set.</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">        You can search all pairs of points in a kd-tree within a distance:</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">        &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.spatial import KDTree</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        &gt;&gt;&gt; points = rng.random((20, 2))</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">        &gt;&gt;&gt; plt.figure(figsize=(6, 6))</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">        &gt;&gt;&gt; plt.plot(points[:, 0], points[:, 1], &quot;xk&quot;, markersize=14)</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree = KDTree(points)</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">        &gt;&gt;&gt; pairs = kd_tree.query_pairs(r=0.2)</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        &gt;&gt;&gt; for (i, j) in pairs:</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        ...     plt.plot([points[i, 0], points[j, 0]],</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">        ...             [points[i, 1], points[j, 1]], &quot;-r&quot;)</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">        &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  636</span>        <span class="keywordflow">return</span> super().query_pairs(r, p, eps, output_type)</div>
<div class="line"><span class="lineno">  637</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d6af0fd0efe438bc22cfd523e6305f4" name="a1d6af0fd0efe438bc22cfd523e6305f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6af0fd0efe438bc22cfd523e6305f4">&#9670;&#160;</a></span>sparse_distance_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.sparse_distance_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_type</em> = <code>'dok_matrix'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a sparse distance matrix.

Computes a distance matrix between two KDTrees, leaving as zero
any distance greater than max_distance.

Parameters
----------
other : KDTree

max_distance : positive float

p : float, 1&lt;=p&lt;=infinity
    Which Minkowski p-norm to use.
    A finite large p may cause a ValueError if overflow can occur.

output_type : string, optional
    Which container to use for output data. Options: 'dok_matrix',
    'coo_matrix', 'dict', or 'ndarray'. Default: 'dok_matrix'.

    .. versionadded:: 1.6.0

Returns
-------
result : dok_matrix, coo_matrix, dict or ndarray
    Sparse matrix representing the results in "dictionary of keys"
    format. If a dict is returned the keys are (i,j) tuples of indices.
    If output_type is 'ndarray' a record array with fields 'i', 'j',
    and 'v' is returned,

Examples
--------
You can compute a sparse distance matrix between two kd-trees:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.spatial import KDTree
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; points1 = rng.random((5, 2))
&gt;&gt;&gt; points2 = rng.random((5, 2))
&gt;&gt;&gt; kd_tree1 = KDTree(points1)
&gt;&gt;&gt; kd_tree2 = KDTree(points2)
&gt;&gt;&gt; sdm = kd_tree1.sparse_distance_matrix(kd_tree2, 0.3)
&gt;&gt;&gt; sdm.toarray()
array([[0.        , 0.        , 0.12295571, 0.        , 0.        ],
   [0.        , 0.        , 0.        , 0.        , 0.        ],
   [0.28942611, 0.        , 0.        , 0.2333084 , 0.        ],
   [0.        , 0.        , 0.        , 0.        , 0.        ],
   [0.24617575, 0.29571802, 0.26836782, 0.        , 0.        ]])

You can check distances above the `max_distance` are zeros:

&gt;&gt;&gt; from scipy.spatial import distance_matrix
&gt;&gt;&gt; distance_matrix(points1, points2)
array([[0.56906522, 0.39923701, 0.12295571, 0.8658745 , 0.79428925],
   [0.37327919, 0.7225693 , 0.87665969, 0.32580855, 0.75679479],
   [0.28942611, 0.30088013, 0.6395831 , 0.2333084 , 0.33630734],
   [0.31994999, 0.72658602, 0.71124834, 0.55396483, 0.90785663],
   [0.24617575, 0.29571802, 0.26836782, 0.57714465, 0.6473269 ]])</pre> <div class="fragment"><div class="line"><span class="lineno">  787</span>            self, other, max_distance, p=2., output_type=<span class="stringliteral">&#39;dok_matrix&#39;</span>):</div>
<div class="line"><span class="lineno">  788</span>        <span class="stringliteral">&quot;&quot;&quot;Compute a sparse distance matrix.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">        Computes a distance matrix between two KDTrees, leaving as zero</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">        any distance greater than max_distance.</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        other : KDTree</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">        max_distance : positive float</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        p : float, 1&lt;=p&lt;=infinity</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">            Which Minkowski p-norm to use.</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">            A finite large p may cause a ValueError if overflow can occur.</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">        output_type : string, optional</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">            Which container to use for output data. Options: &#39;dok_matrix&#39;,</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">            &#39;coo_matrix&#39;, &#39;dict&#39;, or &#39;ndarray&#39;. Default: &#39;dok_matrix&#39;.</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">            .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        result : dok_matrix, coo_matrix, dict or ndarray</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">            Sparse matrix representing the results in &quot;dictionary of keys&quot;</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">            format. If a dict is returned the keys are (i,j) tuples of indices.</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">            If output_type is &#39;ndarray&#39; a record array with fields &#39;i&#39;, &#39;j&#39;,</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">            and &#39;v&#39; is returned,</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        You can compute a sparse distance matrix between two kd-trees:</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.spatial import KDTree</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">        &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        &gt;&gt;&gt; points1 = rng.random((5, 2))</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">        &gt;&gt;&gt; points2 = rng.random((5, 2))</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree1 = KDTree(points1)</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">        &gt;&gt;&gt; kd_tree2 = KDTree(points2)</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        &gt;&gt;&gt; sdm = kd_tree1.sparse_distance_matrix(kd_tree2, 0.3)</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">        &gt;&gt;&gt; sdm.toarray()</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">        array([[0.        , 0.        , 0.12295571, 0.        , 0.        ],</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">           [0.        , 0.        , 0.        , 0.        , 0.        ],</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">           [0.28942611, 0.        , 0.        , 0.2333084 , 0.        ],</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">           [0.        , 0.        , 0.        , 0.        , 0.        ],</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">           [0.24617575, 0.29571802, 0.26836782, 0.        , 0.        ]])</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">        You can check distances above the `max_distance` are zeros:</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.spatial import distance_matrix</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        &gt;&gt;&gt; distance_matrix(points1, points2)</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        array([[0.56906522, 0.39923701, 0.12295571, 0.8658745 , 0.79428925],</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">           [0.37327919, 0.7225693 , 0.87665969, 0.32580855, 0.75679479],</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">           [0.28942611, 0.30088013, 0.6395831 , 0.2333084 , 0.33630734],</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">           [0.31994999, 0.72658602, 0.71124834, 0.55396483, 0.90785663],</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">           [0.24617575, 0.29571802, 0.26836782, 0.57714465, 0.6473269 ]])</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  847</span>        <span class="keywordflow">return</span> super().sparse_distance_matrix(</div>
<div class="line"><span class="lineno">  848</span>            other, max_distance, p, output_type)</div>
<div class="line"><span class="lineno">  849</span> </div>
<div class="line"><span class="lineno">  850</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a242bf6f29c9115d103e8f1f5f043452d" name="a242bf6f29c9115d103e8f1f5f043452d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242bf6f29c9115d103e8f1f5f043452d">&#9670;&#160;</a></span>tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree.tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  330</span>    <span class="keyword">def </span>tree(self):</div>
<div class="line"><span class="lineno">  331</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(self, <span class="stringliteral">&quot;_tree&quot;</span>):</div>
<div class="line"><span class="lineno">  332</span>            self._tree = KDTree.node._create(super().tree)</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>        <span class="keywordflow">return</span> self._tree</div>
<div class="line"><span class="lineno">  335</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4d4282aaf08138f150f841356430acd1" name="a4d4282aaf08138f150f841356430acd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4282aaf08138f150f841356430acd1">&#9670;&#160;</a></span>_tree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial._kdtree.KDTree._tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/scipy/spatial/<a class="el" href="__kdtree_8py.html">_kdtree.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
