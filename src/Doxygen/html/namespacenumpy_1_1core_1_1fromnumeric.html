<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.core.fromnumeric Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html">fromnumeric</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.core.fromnumeric Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa63c407390f4c2a7cdcf1e4da0ad1235" id="r_aa63c407390f4c2a7cdcf1e4da0ad1235"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa63c407390f4c2a7cdcf1e4da0ad1235">_wrapit</a> (obj, method, *args, **kwds)</td></tr>
<tr class="separator:aa63c407390f4c2a7cdcf1e4da0ad1235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d8c37d3eac5fd5fa3f08c59b982097" id="r_a40d8c37d3eac5fd5fa3f08c59b982097"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a40d8c37d3eac5fd5fa3f08c59b982097">_wrapfunc</a> (obj, method, *args, **kwds)</td></tr>
<tr class="separator:a40d8c37d3eac5fd5fa3f08c59b982097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac826deaded873153a108b522ea804148" id="r_ac826deaded873153a108b522ea804148"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ac826deaded873153a108b522ea804148">_wrapreduction</a> (obj, <a class="el" href="structufunc.html">ufunc</a>, method, axis, dtype, out, **kwargs)</td></tr>
<tr class="separator:ac826deaded873153a108b522ea804148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4efa888065b329f9e6c1f1c3852325" id="r_add4efa888065b329f9e6c1f1c3852325"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#add4efa888065b329f9e6c1f1c3852325">_take_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a9b57e299af9537cd1030c654e4be8abb">indices</a>, axis=None, out=None, mode=None)</td></tr>
<tr class="separator:add4efa888065b329f9e6c1f1c3852325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a26fc629bbaceb4c36bec114e80711" id="r_ac1a26fc629bbaceb4c36bec114e80711"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ac1a26fc629bbaceb4c36bec114e80711">take</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a9b57e299af9537cd1030c654e4be8abb">indices</a>, axis=None, out=None, mode='raise')</td></tr>
<tr class="separator:ac1a26fc629bbaceb4c36bec114e80711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f982c95c364602a153bb1a508e3d14" id="r_ae9f982c95c364602a153bb1a508e3d14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ae9f982c95c364602a153bb1a508e3d14">_reshape_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, newshape, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:ae9f982c95c364602a153bb1a508e3d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805221e91ab6019b13c120c9f6e2cc67" id="r_a805221e91ab6019b13c120c9f6e2cc67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a805221e91ab6019b13c120c9f6e2cc67">reshape</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, newshape, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>='C')</td></tr>
<tr class="separator:a805221e91ab6019b13c120c9f6e2cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675ee6fbe56daf6c888c3d5dffa927c3" id="r_a675ee6fbe56daf6c888c3d5dffa927c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a675ee6fbe56daf6c888c3d5dffa927c3">_choose_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, choices, out=None, mode=None)</td></tr>
<tr class="separator:a675ee6fbe56daf6c888c3d5dffa927c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125a1549efb6bb8a5172e32890812ae6" id="r_a125a1549efb6bb8a5172e32890812ae6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a125a1549efb6bb8a5172e32890812ae6">choose</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, choices, out=None, mode='raise')</td></tr>
<tr class="separator:a125a1549efb6bb8a5172e32890812ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40052e113a889a1e6dfe154f9c2b9ac" id="r_aa40052e113a889a1e6dfe154f9c2b9ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa40052e113a889a1e6dfe154f9c2b9ac">_repeat_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, repeats, axis=None)</td></tr>
<tr class="separator:aa40052e113a889a1e6dfe154f9c2b9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fc1d180913aa6baf5197d59e54e507" id="r_a78fc1d180913aa6baf5197d59e54e507"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a78fc1d180913aa6baf5197d59e54e507">repeat</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, repeats, axis=None)</td></tr>
<tr class="separator:a78fc1d180913aa6baf5197d59e54e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a5ed353745eaca0f3716199dfdd62" id="r_afd4a5ed353745eaca0f3716199dfdd62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#afd4a5ed353745eaca0f3716199dfdd62">_put_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, ind, v, mode=None)</td></tr>
<tr class="separator:afd4a5ed353745eaca0f3716199dfdd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9a708522540311450a0c848c8e67fc" id="r_afc9a708522540311450a0c848c8e67fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#afc9a708522540311450a0c848c8e67fc">put</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, ind, v, mode='raise')</td></tr>
<tr class="separator:afc9a708522540311450a0c848c8e67fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f953253fe8c9e05c6fbe4e08096929c" id="r_a3f953253fe8c9e05c6fbe4e08096929c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a3f953253fe8c9e05c6fbe4e08096929c">_swapaxes_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis1, axis2)</td></tr>
<tr class="separator:a3f953253fe8c9e05c6fbe4e08096929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc6945fa57fb7f804b191a97952b05a" id="r_a6fc6945fa57fb7f804b191a97952b05a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a6fc6945fa57fb7f804b191a97952b05a">swapaxes</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis1, axis2)</td></tr>
<tr class="separator:a6fc6945fa57fb7f804b191a97952b05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7418d5b5328634598c42667c45de7569" id="r_a7418d5b5328634598c42667c45de7569"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a7418d5b5328634598c42667c45de7569">_transpose_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axes=None)</td></tr>
<tr class="separator:a7418d5b5328634598c42667c45de7569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841d0800caffc28ceef9afb4731e6ed5" id="r_a841d0800caffc28ceef9afb4731e6ed5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a841d0800caffc28ceef9afb4731e6ed5">transpose</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axes=None)</td></tr>
<tr class="separator:a841d0800caffc28ceef9afb4731e6ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcac476e142a7cde4bf0c549646e421" id="r_a5fcac476e142a7cde4bf0c549646e421"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a5fcac476e142a7cde4bf0c549646e421">_partition_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, kth, axis=None, kind=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a5fcac476e142a7cde4bf0c549646e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb8e6810a27d408fe67f541620bb1d8" id="r_a5fb8e6810a27d408fe67f541620bb1d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a5fb8e6810a27d408fe67f541620bb1d8">partition</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, kth, axis=-1, kind='introselect', <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a5fb8e6810a27d408fe67f541620bb1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad553e0334f10a9744bab9d64f60baf55" id="r_ad553e0334f10a9744bab9d64f60baf55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ad553e0334f10a9744bab9d64f60baf55">_argpartition_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, kth, axis=None, kind=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:ad553e0334f10a9744bab9d64f60baf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1af02431e998ec84d1dcb1e7a27b79" id="r_adb1af02431e998ec84d1dcb1e7a27b79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#adb1af02431e998ec84d1dcb1e7a27b79">argpartition</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, kth, axis=-1, kind='introselect', <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:adb1af02431e998ec84d1dcb1e7a27b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4210452014a7466e3b4a392bb14947" id="r_a1f4210452014a7466e3b4a392bb14947"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a1f4210452014a7466e3b4a392bb14947">_sort_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, kind=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a1f4210452014a7466e3b4a392bb14947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158463af46fc865a8726ebc234601228" id="r_a158463af46fc865a8726ebc234601228"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a158463af46fc865a8726ebc234601228">sort</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=-1, kind=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a158463af46fc865a8726ebc234601228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f17f33ecc71166ce417d22d38b811c" id="r_ae5f17f33ecc71166ce417d22d38b811c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ae5f17f33ecc71166ce417d22d38b811c">_argsort_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, kind=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:ae5f17f33ecc71166ce417d22d38b811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879deb9e0defb1f65e7527ce3b2ab8f1" id="r_a879deb9e0defb1f65e7527ce3b2ab8f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a879deb9e0defb1f65e7527ce3b2ab8f1">argsort</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=-1, kind=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a879deb9e0defb1f65e7527ce3b2ab8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3b6f93f0e4769340def7b3cc1a914" id="r_ae0c3b6f93f0e4769340def7b3cc1a914"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ae0c3b6f93f0e4769340def7b3cc1a914">_argmax_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=np._NoValue)</td></tr>
<tr class="separator:ae0c3b6f93f0e4769340def7b3cc1a914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf20bc7c07f5a90ffe84fc697d55926d" id="r_acf20bc7c07f5a90ffe84fc697d55926d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#acf20bc7c07f5a90ffe84fc697d55926d">argmax</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=np._NoValue)</td></tr>
<tr class="separator:acf20bc7c07f5a90ffe84fc697d55926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243efae8c691da962d347dc2234642fa" id="r_a243efae8c691da962d347dc2234642fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a243efae8c691da962d347dc2234642fa">_argmin_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=np._NoValue)</td></tr>
<tr class="separator:a243efae8c691da962d347dc2234642fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14ddaa6d6d3309b9b752471f0cb7c25" id="r_af14ddaa6d6d3309b9b752471f0cb7c25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#af14ddaa6d6d3309b9b752471f0cb7c25">argmin</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=np._NoValue)</td></tr>
<tr class="separator:af14ddaa6d6d3309b9b752471f0cb7c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563d0c5e26199b8bbbe8a7ec3b61f84f" id="r_a563d0c5e26199b8bbbe8a7ec3b61f84f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a563d0c5e26199b8bbbe8a7ec3b61f84f">_searchsorted_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, v, <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>=None, sorter=None)</td></tr>
<tr class="separator:a563d0c5e26199b8bbbe8a7ec3b61f84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22cfbbf9d1e32bb23d23824877c3026" id="r_ab22cfbbf9d1e32bb23d23824877c3026"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ab22cfbbf9d1e32bb23d23824877c3026">searchsorted</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, v, <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>='left', sorter=None)</td></tr>
<tr class="separator:ab22cfbbf9d1e32bb23d23824877c3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67276f8453a7c00326116ddbba68eae5" id="r_a67276f8453a7c00326116ddbba68eae5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a67276f8453a7c00326116ddbba68eae5">_resize_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, new_shape)</td></tr>
<tr class="separator:a67276f8453a7c00326116ddbba68eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74f9e7b5dc50af3f3fa0f30e755b323" id="r_ac74f9e7b5dc50af3f3fa0f30e755b323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ac74f9e7b5dc50af3f3fa0f30e755b323">resize</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, new_shape)</td></tr>
<tr class="separator:ac74f9e7b5dc50af3f3fa0f30e755b323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b63e52cfc2a12319d647847837dfae" id="r_a42b63e52cfc2a12319d647847837dfae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a42b63e52cfc2a12319d647847837dfae">_squeeze_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None)</td></tr>
<tr class="separator:a42b63e52cfc2a12319d647847837dfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f8693d70065f98788a77d1bace3923" id="r_ab6f8693d70065f98788a77d1bace3923"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ab6f8693d70065f98788a77d1bace3923">squeeze</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None)</td></tr>
<tr class="separator:ab6f8693d70065f98788a77d1bace3923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350d768e055456ee0f36d3369f06680d" id="r_a350d768e055456ee0f36d3369f06680d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a350d768e055456ee0f36d3369f06680d">_diagonal_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=None, axis1=None, axis2=None)</td></tr>
<tr class="separator:a350d768e055456ee0f36d3369f06680d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac85288109e6be95d222f77f560f78e" id="r_a0ac85288109e6be95d222f77f560f78e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a0ac85288109e6be95d222f77f560f78e">diagonal</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0, axis1=0, axis2=1)</td></tr>
<tr class="separator:a0ac85288109e6be95d222f77f560f78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ab0341eb39a296904bc23f82a511d3" id="r_a50ab0341eb39a296904bc23f82a511d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a50ab0341eb39a296904bc23f82a511d3">_trace_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=None, axis1=None, axis2=None, dtype=None, out=None)</td></tr>
<tr class="separator:a50ab0341eb39a296904bc23f82a511d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50b452c4b243c01ffc5aca1f8301580" id="r_ae50b452c4b243c01ffc5aca1f8301580"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ae50b452c4b243c01ffc5aca1f8301580">trace</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0, axis1=0, axis2=1, dtype=None, out=None)</td></tr>
<tr class="separator:ae50b452c4b243c01ffc5aca1f8301580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3738bd7e25097cf929ba2f3e7468bc" id="r_a6c3738bd7e25097cf929ba2f3e7468bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a6c3738bd7e25097cf929ba2f3e7468bc">_ravel_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:a6c3738bd7e25097cf929ba2f3e7468bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06908f65c1549031f1c4128d90bd4edc" id="r_a06908f65c1549031f1c4128d90bd4edc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a06908f65c1549031f1c4128d90bd4edc">ravel</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>='C')</td></tr>
<tr class="separator:a06908f65c1549031f1c4128d90bd4edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c7c15c0583a39175bd7b0e09425178" id="r_ad5c7c15c0583a39175bd7b0e09425178"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ad5c7c15c0583a39175bd7b0e09425178">_nonzero_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:ad5c7c15c0583a39175bd7b0e09425178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3462a97857a2f1b5199803686152858e" id="r_a3462a97857a2f1b5199803686152858e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a3462a97857a2f1b5199803686152858e">nonzero</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a3462a97857a2f1b5199803686152858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486aeed9c37a17742db7b07cae719c69" id="r_a486aeed9c37a17742db7b07cae719c69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a486aeed9c37a17742db7b07cae719c69">_shape_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a486aeed9c37a17742db7b07cae719c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22b69964320c5aabb55d909c8780c9f" id="r_aa22b69964320c5aabb55d909c8780c9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:aa22b69964320c5aabb55d909c8780c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32276e8cfad1afef011489f50bde316c" id="r_a32276e8cfad1afef011489f50bde316c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a32276e8cfad1afef011489f50bde316c">_compress_dispatcher</a> (condition, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None)</td></tr>
<tr class="separator:a32276e8cfad1afef011489f50bde316c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e05aec90fc741f3919465d12b01193" id="r_a98e05aec90fc741f3919465d12b01193"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a98e05aec90fc741f3919465d12b01193">compress</a> (condition, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None)</td></tr>
<tr class="separator:a98e05aec90fc741f3919465d12b01193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48e65adbb042c3b8b3b9b1f7dd17670" id="r_ac48e65adbb042c3b8b3b9b1f7dd17670"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ac48e65adbb042c3b8b3b9b1f7dd17670">_clip_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, a_min, a_max, out=None, **kwargs)</td></tr>
<tr class="separator:ac48e65adbb042c3b8b3b9b1f7dd17670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ebc234ab70db66e59afbea0ef6d4d2" id="r_ac0ebc234ab70db66e59afbea0ef6d4d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ac0ebc234ab70db66e59afbea0ef6d4d2">clip</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, a_min, a_max, out=None, **kwargs)</td></tr>
<tr class="separator:ac0ebc234ab70db66e59afbea0ef6d4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f6ad75bb9bc310286ca26ff74717aa" id="r_ae6f6ad75bb9bc310286ca26ff74717aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ae6f6ad75bb9bc310286ca26ff74717aa">_sum_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:ae6f6ad75bb9bc310286ca26ff74717aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51411b3b0c037cf12ac140486f46cfd9" id="r_a51411b3b0c037cf12ac140486f46cfd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a51411b3b0c037cf12ac140486f46cfd9">sum</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:a51411b3b0c037cf12ac140486f46cfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b2885cabfbab6b6fb58b64e46dd095" id="r_a64b2885cabfbab6b6fb58b64e46dd095"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a64b2885cabfbab6b6fb58b64e46dd095">_any_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=None, *where=np._NoValue)</td></tr>
<tr class="separator:a64b2885cabfbab6b6fb58b64e46dd095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d688ab4080673659c2857c9266ee52" id="r_a70d688ab4080673659c2857c9266ee52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a70d688ab4080673659c2857c9266ee52">any</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:a70d688ab4080673659c2857c9266ee52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe556e2b7d4e9ae73e3582e8d24e2e1" id="r_adfe556e2b7d4e9ae73e3582e8d24e2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#adfe556e2b7d4e9ae73e3582e8d24e2e1">_all_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=None, *where=None)</td></tr>
<tr class="separator:adfe556e2b7d4e9ae73e3582e8d24e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcf566dccb55a6c6e6fb6197510554e" id="r_abdcf566dccb55a6c6e6fb6197510554e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#abdcf566dccb55a6c6e6fb6197510554e">all</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:abdcf566dccb55a6c6e6fb6197510554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad51b1b7ff60cd97c676f2f3991979b" id="r_abad51b1b7ff60cd97c676f2f3991979b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#abad51b1b7ff60cd97c676f2f3991979b">_cumsum_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:abad51b1b7ff60cd97c676f2f3991979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93104c5560c57709d7afe73edefff1f" id="r_ae93104c5560c57709d7afe73edefff1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ae93104c5560c57709d7afe73edefff1f">cumsum</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:ae93104c5560c57709d7afe73edefff1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef71a3198acfac2e927daf883a0670d" id="r_aaef71a3198acfac2e927daf883a0670d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aaef71a3198acfac2e927daf883a0670d">_ptp_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=None)</td></tr>
<tr class="separator:aaef71a3198acfac2e927daf883a0670d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1063686650ab11f5deb2769ddac6ab" id="r_afb1063686650ab11f5deb2769ddac6ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#afb1063686650ab11f5deb2769ddac6ab">ptp</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=np._NoValue)</td></tr>
<tr class="separator:afb1063686650ab11f5deb2769ddac6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af983a7ca743e8709ccff58c83204547c" id="r_af983a7ca743e8709ccff58c83204547c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#af983a7ca743e8709ccff58c83204547c">_amax_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:af983a7ca743e8709ccff58c83204547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca57c9ee58464a6be1dca84f020a888" id="r_a1ca57c9ee58464a6be1dca84f020a888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a1ca57c9ee58464a6be1dca84f020a888">amax</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:a1ca57c9ee58464a6be1dca84f020a888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb276188e1bfdc7b5a07800fe637bd7d" id="r_abb276188e1bfdc7b5a07800fe637bd7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#abb276188e1bfdc7b5a07800fe637bd7d">_amin_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:abb276188e1bfdc7b5a07800fe637bd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a10b55151866741431b83f40020bb43" id="r_a9a10b55151866741431b83f40020bb43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a9a10b55151866741431b83f40020bb43">amin</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:a9a10b55151866741431b83f40020bb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd2577e918fa5d496a096e8cfba0109" id="r_a8fd2577e918fa5d496a096e8cfba0109"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a8fd2577e918fa5d496a096e8cfba0109">_prod_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:a8fd2577e918fa5d496a096e8cfba0109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2593c145d58708095d7c839abc405591" id="r_a2593c145d58708095d7c839abc405591"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a2593c145d58708095d7c839abc405591">prod</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:a2593c145d58708095d7c839abc405591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8820557bfe50a75fa8f6e687c335784f" id="r_a8820557bfe50a75fa8f6e687c335784f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a8820557bfe50a75fa8f6e687c335784f">_cumprod_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:a8820557bfe50a75fa8f6e687c335784f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687390f64a847f863a48906d95343c5f" id="r_a687390f64a847f863a48906d95343c5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a687390f64a847f863a48906d95343c5f">cumprod</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:a687390f64a847f863a48906d95343c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad44a608e26da8740f7a346df6e1f95" id="r_a3ad44a608e26da8740f7a346df6e1f95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a3ad44a608e26da8740f7a346df6e1f95">_ndim_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a3ad44a608e26da8740f7a346df6e1f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfc7f1d399bd7dbdd89ecb52594e20d" id="r_a9dfc7f1d399bd7dbdd89ecb52594e20d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a9dfc7f1d399bd7dbdd89ecb52594e20d">ndim</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a9dfc7f1d399bd7dbdd89ecb52594e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4c09d0bca3c11789bbb6d668624849" id="r_abf4c09d0bca3c11789bbb6d668624849"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#abf4c09d0bca3c11789bbb6d668624849">_size_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None)</td></tr>
<tr class="separator:abf4c09d0bca3c11789bbb6d668624849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d731b579c770accbe47efa0d327b36e" id="r_a0d731b579c770accbe47efa0d327b36e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a0d731b579c770accbe47efa0d327b36e">size</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None)</td></tr>
<tr class="separator:a0d731b579c770accbe47efa0d327b36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001e6d30631d626a3d7f155a40678cd2" id="r_a001e6d30631d626a3d7f155a40678cd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a001e6d30631d626a3d7f155a40678cd2">_around_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, decimals=None, out=None)</td></tr>
<tr class="separator:a001e6d30631d626a3d7f155a40678cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd18ac16bfbd94ba5bc275f6afbdc8bf" id="r_abd18ac16bfbd94ba5bc275f6afbdc8bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#abd18ac16bfbd94ba5bc275f6afbdc8bf">around</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, decimals=0, out=None)</td></tr>
<tr class="separator:abd18ac16bfbd94ba5bc275f6afbdc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa317941ad1f666e81ce344e4db4dbafd" id="r_aa317941ad1f666e81ce344e4db4dbafd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa317941ad1f666e81ce344e4db4dbafd">_mean_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=None, *where=None)</td></tr>
<tr class="separator:aa317941ad1f666e81ce344e4db4dbafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835aa0a6c668cb6abef119df90098029" id="r_a835aa0a6c668cb6abef119df90098029"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a835aa0a6c668cb6abef119df90098029">mean</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:a835aa0a6c668cb6abef119df90098029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e2f241e8b73e072a10d7ab2250205d" id="r_a50e2f241e8b73e072a10d7ab2250205d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a50e2f241e8b73e072a10d7ab2250205d">_std_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=None, keepdims=None, *where=None)</td></tr>
<tr class="separator:a50e2f241e8b73e072a10d7ab2250205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd08ae9b4e902a5874d0e8b87501578f" id="r_acd08ae9b4e902a5874d0e8b87501578f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#acd08ae9b4e902a5874d0e8b87501578f">std</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:acd08ae9b4e902a5874d0e8b87501578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0eb30133091bf215a421b53e8d65e1" id="r_a3d0eb30133091bf215a421b53e8d65e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a3d0eb30133091bf215a421b53e8d65e1">_var_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=None, keepdims=None, *where=None)</td></tr>
<tr class="separator:a3d0eb30133091bf215a421b53e8d65e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2e33cf9ae838c69941ea5b4a446257" id="r_acb2e33cf9ae838c69941ea5b4a446257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#acb2e33cf9ae838c69941ea5b4a446257">var</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:acb2e33cf9ae838c69941ea5b4a446257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b8ea6060ec94d63fafaddcbe139f4c" id="r_a73b8ea6060ec94d63fafaddcbe139f4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a73b8ea6060ec94d63fafaddcbe139f4c">round_</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, decimals=0, out=None)</td></tr>
<tr class="separator:a73b8ea6060ec94d63fafaddcbe139f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abced3adc3b6a204a28cd07e54b7697" id="r_a0abced3adc3b6a204a28cd07e54b7697"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a0abced3adc3b6a204a28cd07e54b7697">product</a> (*args, **kwargs)</td></tr>
<tr class="separator:a0abced3adc3b6a204a28cd07e54b7697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487c2694c08de00857dee37c272fd0a1" id="r_a487c2694c08de00857dee37c272fd0a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a487c2694c08de00857dee37c272fd0a1">cumproduct</a> (*args, **kwargs)</td></tr>
<tr class="separator:a487c2694c08de00857dee37c272fd0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949b19d68c5a9c2b1e5d4bc8d4aee777" id="r_a949b19d68c5a9c2b1e5d4bc8d4aee777"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a949b19d68c5a9c2b1e5d4bc8d4aee777">sometrue</a> (*args, **kwargs)</td></tr>
<tr class="separator:a949b19d68c5a9c2b1e5d4bc8d4aee777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e7b56544db0d95d4d140862e5b3b49" id="r_a08e7b56544db0d95d4d140862e5b3b49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a08e7b56544db0d95d4d140862e5b3b49">alltrue</a> (*args, **kwargs)</td></tr>
<tr class="separator:a08e7b56544db0d95d4d140862e5b3b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a28ff1fc58b4c23bee779e6518321a21e" id="r_a28ff1fc58b4c23bee779e6518321a21e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a28ff1fc58b4c23bee779e6518321a21e">_dt_</a> = nt.sctype2char</td></tr>
<tr class="separator:a28ff1fc58b4c23bee779e6518321a21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802bc641cf3109c8939c281c8dbfdc21" id="r_a802bc641cf3109c8939c281c8dbfdc21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a802bc641cf3109c8939c281c8dbfdc21">_gentype</a> = types.GeneratorType</td></tr>
<tr class="separator:a802bc641cf3109c8939c281c8dbfdc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887577fe59519966e7b6a3bbf1198a7a" id="r_a887577fe59519966e7b6a3bbf1198a7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a887577fe59519966e7b6a3bbf1198a7a">_sum_</a> = <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a51411b3b0c037cf12ac140486f46cfd9">sum</a></td></tr>
<tr class="separator:a887577fe59519966e7b6a3bbf1198a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d6e3b11669e7f56523052edd3f88f6" id="r_ab2d6e3b11669e7f56523052edd3f88f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#ab2d6e3b11669e7f56523052edd3f88f6">array_function_dispatch</a></td></tr>
<tr class="separator:ab2d6e3b11669e7f56523052edd3f88f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Module containing non-deprecated functions borrowed from Numeric.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="adfe556e2b7d4e9ae73e3582e8d24e2e1" name="adfe556e2b7d4e9ae73e3582e8d24e2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe556e2b7d4e9ae73e3582e8d24e2e1">&#9670;&#160;</a></span>_all_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._all_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2428</span>                    where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2429</span>    <span class="keywordflow">return</span> (a, where, out)</div>
<div class="line"><span class="lineno"> 2430</span> </div>
<div class="line"><span class="lineno"> 2431</span> </div>
<div class="line"><span class="lineno"> 2432</span><span class="preprocessor">@array_function_dispatch(_all_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af983a7ca743e8709ccff58c83204547c" name="af983a7ca743e8709ccff58c83204547c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af983a7ca743e8709ccff58c83204547c">&#9670;&#160;</a></span>_amax_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._amax_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2699</span>                     where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2700</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 2701</span> </div>
<div class="line"><span class="lineno"> 2702</span> </div>
<div class="line"><span class="lineno"> 2703</span><span class="preprocessor">@array_function_dispatch(_amax_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb276188e1bfdc7b5a07800fe637bd7d" name="abb276188e1bfdc7b5a07800fe637bd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb276188e1bfdc7b5a07800fe637bd7d">&#9670;&#160;</a></span>_amin_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._amin_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2825</span>                     where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2826</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 2827</span> </div>
<div class="line"><span class="lineno"> 2828</span> </div>
<div class="line"><span class="lineno"> 2829</span><span class="preprocessor">@array_function_dispatch(_amin_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a64b2885cabfbab6b6fb58b64e46dd095" name="a64b2885cabfbab6b6fb58b64e46dd095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b2885cabfbab6b6fb58b64e46dd095">&#9670;&#160;</a></span>_any_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._any_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2329</span>                    where=np._NoValue):</div>
<div class="line"><span class="lineno"> 2330</span>    <span class="keywordflow">return</span> (a, where, out)</div>
<div class="line"><span class="lineno"> 2331</span> </div>
<div class="line"><span class="lineno"> 2332</span> </div>
<div class="line"><span class="lineno"> 2333</span><span class="preprocessor">@array_function_dispatch(_any_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0c3b6f93f0e4769340def7b3cc1a914" name="ae0c3b6f93f0e4769340def7b3cc1a914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c3b6f93f0e4769340def7b3cc1a914">&#9670;&#160;</a></span>_argmax_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._argmax_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1149</span><span class="keyword">def </span>_argmax_dispatcher(a, axis=None, out=None, *, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno"> 1150</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 1151</span> </div>
<div class="line"><span class="lineno"> 1152</span> </div>
<div class="line"><span class="lineno"> 1153</span><span class="preprocessor">@array_function_dispatch(_argmax_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a243efae8c691da962d347dc2234642fa" name="a243efae8c691da962d347dc2234642fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243efae8c691da962d347dc2234642fa">&#9670;&#160;</a></span>_argmin_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._argmin_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1245</span><span class="keyword">def </span>_argmin_dispatcher(a, axis=None, out=None, *, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno"> 1246</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 1247</span> </div>
<div class="line"><span class="lineno"> 1248</span> </div>
<div class="line"><span class="lineno"> 1249</span><span class="preprocessor">@array_function_dispatch(_argmin_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad553e0334f10a9744bab9d64f60baf55" name="ad553e0334f10a9744bab9d64f60baf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad553e0334f10a9744bab9d64f60baf55">&#9670;&#160;</a></span>_argpartition_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._argpartition_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  788</span><span class="keyword">def </span>_argpartition_dispatcher(a, kth, axis=None, kind=None, order=None):</div>
<div class="line"><span class="lineno">  789</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  790</span> </div>
<div class="line"><span class="lineno">  791</span> </div>
<div class="line"><span class="lineno">  792</span><span class="preprocessor">@array_function_dispatch(_argpartition_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5f17f33ecc71166ce417d22d38b811c" name="ae5f17f33ecc71166ce417d22d38b811c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f17f33ecc71166ce417d22d38b811c">&#9670;&#160;</a></span>_argsort_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._argsort_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1034</span><span class="keyword">def </span>_argsort_dispatcher(a, axis=None, kind=None, order=None):</div>
<div class="line"><span class="lineno"> 1035</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1036</span> </div>
<div class="line"><span class="lineno"> 1037</span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="preprocessor">@array_function_dispatch(_argsort_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a001e6d30631d626a3d7f155a40678cd2" name="a001e6d30631d626a3d7f155a40678cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001e6d30631d626a3d7f155a40678cd2">&#9670;&#160;</a></span>_around_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._around_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>decimals</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3241</span><span class="keyword">def </span>_around_dispatcher(a, decimals=None, out=None):</div>
<div class="line"><span class="lineno"> 3242</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 3243</span> </div>
<div class="line"><span class="lineno"> 3244</span> </div>
<div class="line"><span class="lineno"> 3245</span><span class="preprocessor">@array_function_dispatch(_around_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a675ee6fbe56daf6c888c3d5dffa927c3" name="a675ee6fbe56daf6c888c3d5dffa927c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675ee6fbe56daf6c888c3d5dffa927c3">&#9670;&#160;</a></span>_choose_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._choose_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  301</span><span class="keyword">def </span>_choose_dispatcher(a, choices, out=None, mode=None):</div>
<div class="line"><span class="lineno">  302</span>    <span class="keywordflow">yield</span> a</div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> choices</div>
<div class="line"><span class="lineno">  304</span>    <span class="keywordflow">yield</span> out</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span> </div>
<div class="line"><span class="lineno">  307</span><span class="preprocessor">@array_function_dispatch(_choose_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac48e65adbb042c3b8b3b9b1f7dd17670" name="ac48e65adbb042c3b8b3b9b1f7dd17670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48e65adbb042c3b8b3b9b1f7dd17670">&#9670;&#160;</a></span>_clip_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._clip_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2107</span><span class="keyword">def </span>_clip_dispatcher(a, a_min, a_max, out=None, **kwargs):</div>
<div class="line"><span class="lineno"> 2108</span>    <span class="keywordflow">return</span> (a, a_min, a_max)</div>
<div class="line"><span class="lineno"> 2109</span> </div>
<div class="line"><span class="lineno"> 2110</span> </div>
<div class="line"><span class="lineno"> 2111</span><span class="preprocessor">@array_function_dispatch(_clip_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a32276e8cfad1afef011489f50bde316c" name="a32276e8cfad1afef011489f50bde316c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32276e8cfad1afef011489f50bde316c">&#9670;&#160;</a></span>_compress_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._compress_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2039</span><span class="keyword">def </span>_compress_dispatcher(condition, a, axis=None, out=None):</div>
<div class="line"><span class="lineno"> 2040</span>    <span class="keywordflow">return</span> (condition, a, out)</div>
<div class="line"><span class="lineno"> 2041</span> </div>
<div class="line"><span class="lineno"> 2042</span> </div>
<div class="line"><span class="lineno"> 2043</span><span class="preprocessor">@array_function_dispatch(_compress_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8820557bfe50a75fa8f6e687c335784f" name="a8820557bfe50a75fa8f6e687c335784f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8820557bfe50a75fa8f6e687c335784f">&#9670;&#160;</a></span>_cumprod_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._cumprod_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3080</span><span class="keyword">def </span>_cumprod_dispatcher(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno"> 3081</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 3082</span> </div>
<div class="line"><span class="lineno"> 3083</span> </div>
<div class="line"><span class="lineno"> 3084</span><span class="preprocessor">@array_function_dispatch(_cumprod_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abad51b1b7ff60cd97c676f2f3991979b" name="abad51b1b7ff60cd97c676f2f3991979b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad51b1b7ff60cd97c676f2f3991979b">&#9670;&#160;</a></span>_cumsum_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._cumsum_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2519</span><span class="keyword">def </span>_cumsum_dispatcher(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno"> 2520</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 2521</span> </div>
<div class="line"><span class="lineno"> 2522</span> </div>
<div class="line"><span class="lineno"> 2523</span><span class="preprocessor">@array_function_dispatch(_cumsum_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a350d768e055456ee0f36d3369f06680d" name="a350d768e055456ee0f36d3369f06680d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350d768e055456ee0f36d3369f06680d">&#9670;&#160;</a></span>_diagonal_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._diagonal_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1574</span><span class="keyword">def </span>_diagonal_dispatcher(a, offset=None, axis1=None, axis2=None):</div>
<div class="line"><span class="lineno"> 1575</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1576</span> </div>
<div class="line"><span class="lineno"> 1577</span> </div>
<div class="line"><span class="lineno"> 1578</span><span class="preprocessor">@array_function_dispatch(_diagonal_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa317941ad1f666e81ce344e4db4dbafd" name="aa317941ad1f666e81ce344e4db4dbafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa317941ad1f666e81ce344e4db4dbafd">&#9670;&#160;</a></span>_mean_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._mean_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3341</span>                     where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3342</span>    <span class="keywordflow">return</span> (a, where, out)</div>
<div class="line"><span class="lineno"> 3343</span> </div>
<div class="line"><span class="lineno"> 3344</span> </div>
<div class="line"><span class="lineno"> 3345</span><span class="preprocessor">@array_function_dispatch(_mean_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ad44a608e26da8740f7a346df6e1f95" name="a3ad44a608e26da8740f7a346df6e1f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad44a608e26da8740f7a346df6e1f95">&#9670;&#160;</a></span>_ndim_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._ndim_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3148</span><span class="keyword">def </span>_ndim_dispatcher(a):</div>
<div class="line"><span class="lineno"> 3149</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 3150</span> </div>
<div class="line"><span class="lineno"> 3151</span> </div>
<div class="line"><span class="lineno"> 3152</span><span class="preprocessor">@array_function_dispatch(_ndim_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5c7c15c0583a39175bd7b0e09425178" name="ad5c7c15c0583a39175bd7b0e09425178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c7c15c0583a39175bd7b0e09425178">&#9670;&#160;</a></span>_nonzero_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._nonzero_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1888</span><span class="keyword">def </span>_nonzero_dispatcher(a):</div>
<div class="line"><span class="lineno"> 1889</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1890</span> </div>
<div class="line"><span class="lineno"> 1891</span> </div>
<div class="line"><span class="lineno"> 1892</span><span class="preprocessor">@array_function_dispatch(_nonzero_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5fcac476e142a7cde4bf0c549646e421" name="a5fcac476e142a7cde4bf0c549646e421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcac476e142a7cde4bf0c549646e421">&#9670;&#160;</a></span>_partition_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._partition_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  671</span><span class="keyword">def </span>_partition_dispatcher(a, kth, axis=None, kind=None, order=None):</div>
<div class="line"><span class="lineno">  672</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  673</span> </div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span><span class="preprocessor">@array_function_dispatch(_partition_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8fd2577e918fa5d496a096e8cfba0109" name="a8fd2577e918fa5d496a096e8cfba0109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd2577e918fa5d496a096e8cfba0109">&#9670;&#160;</a></span>_prod_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._prod_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2951</span>                     initial=<span class="keywordtype">None</span>, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2952</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 2953</span> </div>
<div class="line"><span class="lineno"> 2954</span> </div>
<div class="line"><span class="lineno"> 2955</span><span class="preprocessor">@array_function_dispatch(_prod_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaef71a3198acfac2e927daf883a0670d" name="aaef71a3198acfac2e927daf883a0670d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef71a3198acfac2e927daf883a0670d">&#9670;&#160;</a></span>_ptp_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._ptp_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2600</span><span class="keyword">def </span>_ptp_dispatcher(a, axis=None, out=None, keepdims=None):</div>
<div class="line"><span class="lineno"> 2601</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 2602</span> </div>
<div class="line"><span class="lineno"> 2603</span> </div>
<div class="line"><span class="lineno"> 2604</span><span class="preprocessor">@array_function_dispatch(_ptp_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afd4a5ed353745eaca0f3716199dfdd62" name="afd4a5ed353745eaca0f3716199dfdd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4a5ed353745eaca0f3716199dfdd62">&#9670;&#160;</a></span>_put_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._put_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  482</span><span class="keyword">def </span>_put_dispatcher(a, ind, v, mode=None):</div>
<div class="line"><span class="lineno">  483</span>    <span class="keywordflow">return</span> (a, ind, v)</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span> </div>
<div class="line"><span class="lineno">  486</span><span class="preprocessor">@array_function_dispatch(_put_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c3738bd7e25097cf929ba2f3e7468bc" name="a6c3738bd7e25097cf929ba2f3e7468bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3738bd7e25097cf929ba2f3e7468bc">&#9670;&#160;</a></span>_ravel_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._ravel_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1777</span><span class="keyword">def </span>_ravel_dispatcher(a, order=None):</div>
<div class="line"><span class="lineno"> 1778</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1779</span> </div>
<div class="line"><span class="lineno"> 1780</span> </div>
<div class="line"><span class="lineno"> 1781</span><span class="preprocessor">@array_function_dispatch(_ravel_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa40052e113a889a1e6dfe154f9c2b9ac" name="aa40052e113a889a1e6dfe154f9c2b9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40052e113a889a1e6dfe154f9c2b9ac">&#9670;&#160;</a></span>_repeat_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._repeat_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repeats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  432</span><span class="keyword">def </span>_repeat_dispatcher(a, repeats, axis=None):</div>
<div class="line"><span class="lineno">  433</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  434</span> </div>
<div class="line"><span class="lineno">  435</span> </div>
<div class="line"><span class="lineno">  436</span><span class="preprocessor">@array_function_dispatch(_repeat_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9f982c95c364602a153bb1a508e3d14" name="ae9f982c95c364602a153bb1a508e3d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f982c95c364602a153bb1a508e3d14">&#9670;&#160;</a></span>_reshape_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._reshape_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  193</span><span class="keyword">def </span>_reshape_dispatcher(a, newshape, order=None):</div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  195</span> </div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span><span class="comment"># not deprecated --- copy if necessary, view otherwise</span></div>
<div class="line"><span class="lineno">  198</span><span class="preprocessor">@array_function_dispatch(_reshape_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a67276f8453a7c00326116ddbba68eae5" name="a67276f8453a7c00326116ddbba68eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67276f8453a7c00326116ddbba68eae5">&#9670;&#160;</a></span>_resize_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._resize_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1416</span><span class="keyword">def </span>_resize_dispatcher(a, new_shape):</div>
<div class="line"><span class="lineno"> 1417</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1418</span> </div>
<div class="line"><span class="lineno"> 1419</span> </div>
<div class="line"><span class="lineno"> 1420</span><span class="preprocessor">@array_function_dispatch(_resize_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a563d0c5e26199b8bbbe8a7ec3b61f84f" name="a563d0c5e26199b8bbbe8a7ec3b61f84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563d0c5e26199b8bbbe8a7ec3b61f84f">&#9670;&#160;</a></span>_searchsorted_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._searchsorted_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>side</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sorter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1341</span><span class="keyword">def </span>_searchsorted_dispatcher(a, v, side=None, sorter=None):</div>
<div class="line"><span class="lineno"> 1342</span>    <span class="keywordflow">return</span> (a, v, sorter)</div>
<div class="line"><span class="lineno"> 1343</span> </div>
<div class="line"><span class="lineno"> 1344</span> </div>
<div class="line"><span class="lineno"> 1345</span><span class="preprocessor">@array_function_dispatch(_searchsorted_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a486aeed9c37a17742db7b07cae719c69" name="a486aeed9c37a17742db7b07cae719c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486aeed9c37a17742db7b07cae719c69">&#9670;&#160;</a></span>_shape_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._shape_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1987</span><span class="keyword">def </span>_shape_dispatcher(a):</div>
<div class="line"><span class="lineno"> 1988</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1989</span> </div>
<div class="line"><span class="lineno"> 1990</span> </div>
<div class="line"><span class="lineno"> 1991</span><span class="preprocessor">@array_function_dispatch(_shape_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abf4c09d0bca3c11789bbb6d668624849" name="abf4c09d0bca3c11789bbb6d668624849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4c09d0bca3c11789bbb6d668624849">&#9670;&#160;</a></span>_size_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._size_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3190</span><span class="keyword">def </span>_size_dispatcher(a, axis=None):</div>
<div class="line"><span class="lineno"> 3191</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 3192</span> </div>
<div class="line"><span class="lineno"> 3193</span> </div>
<div class="line"><span class="lineno"> 3194</span><span class="preprocessor">@array_function_dispatch(_size_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f4210452014a7466e3b4a392bb14947" name="a1f4210452014a7466e3b4a392bb14947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4210452014a7466e3b4a392bb14947">&#9670;&#160;</a></span>_sort_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._sort_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  874</span><span class="keyword">def </span>_sort_dispatcher(a, axis=None, kind=None, order=None):</div>
<div class="line"><span class="lineno">  875</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span> </div>
<div class="line"><span class="lineno">  878</span><span class="preprocessor">@array_function_dispatch(_sort_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a42b63e52cfc2a12319d647847837dfae" name="a42b63e52cfc2a12319d647847837dfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b63e52cfc2a12319d647847837dfae">&#9670;&#160;</a></span>_squeeze_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._squeeze_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1500</span><span class="keyword">def </span>_squeeze_dispatcher(a, axis=None):</div>
<div class="line"><span class="lineno"> 1501</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1502</span> </div>
<div class="line"><span class="lineno"> 1503</span> </div>
<div class="line"><span class="lineno"> 1504</span><span class="preprocessor">@array_function_dispatch(_squeeze_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a50e2f241e8b73e072a10d7ab2250205d" name="a50e2f241e8b73e072a10d7ab2250205d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e2f241e8b73e072a10d7ab2250205d">&#9670;&#160;</a></span>_std_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._std_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3469</span>                    keepdims=<span class="keywordtype">None</span>, *, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3470</span>    <span class="keywordflow">return</span> (a, where, out)</div>
<div class="line"><span class="lineno"> 3471</span> </div>
<div class="line"><span class="lineno"> 3472</span> </div>
<div class="line"><span class="lineno"> 3473</span><span class="preprocessor">@array_function_dispatch(_std_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6f6ad75bb9bc310286ca26ff74717aa" name="ae6f6ad75bb9bc310286ca26ff74717aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f6ad75bb9bc310286ca26ff74717aa">&#9670;&#160;</a></span>_sum_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._sum_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2184</span>                    initial=<span class="keywordtype">None</span>, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2185</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 2186</span> </div>
<div class="line"><span class="lineno"> 2187</span> </div>
<div class="line"><span class="lineno"> 2188</span><span class="preprocessor">@array_function_dispatch(_sum_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f953253fe8c9e05c6fbe4e08096929c" name="a3f953253fe8c9e05c6fbe4e08096929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f953253fe8c9e05c6fbe4e08096929c">&#9670;&#160;</a></span>_swapaxes_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._swapaxes_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  546</span><span class="keyword">def </span>_swapaxes_dispatcher(a, axis1, axis2):</div>
<div class="line"><span class="lineno">  547</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  548</span> </div>
<div class="line"><span class="lineno">  549</span> </div>
<div class="line"><span class="lineno">  550</span><span class="preprocessor">@array_function_dispatch(_swapaxes_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="add4efa888065b329f9e6c1f1c3852325" name="add4efa888065b329f9e6c1f1c3852325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4efa888065b329f9e6c1f1c3852325">&#9670;&#160;</a></span>_take_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._take_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   89</span><span class="keyword">def </span>_take_dispatcher(a, indices, axis=None, out=None, mode=None):</div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span> </div>
<div class="line"><span class="lineno">   93</span><span class="preprocessor">@array_function_dispatch(_take_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a50ab0341eb39a296904bc23f82a511d3" name="a50ab0341eb39a296904bc23f82a511d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ab0341eb39a296904bc23f82a511d3">&#9670;&#160;</a></span>_trace_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._trace_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1709</span>        a, offset=<span class="keywordtype">None</span>, axis1=<span class="keywordtype">None</span>, axis2=<span class="keywordtype">None</span>, dtype=<span class="keywordtype">None</span>, out=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1710</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 1711</span> </div>
<div class="line"><span class="lineno"> 1712</span> </div>
<div class="line"><span class="lineno"> 1713</span><span class="preprocessor">@array_function_dispatch(_trace_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7418d5b5328634598c42667c45de7569" name="a7418d5b5328634598c42667c45de7569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7418d5b5328634598c42667c45de7569">&#9670;&#160;</a></span>_transpose_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._transpose_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  597</span><span class="keyword">def </span>_transpose_dispatcher(a, axes=None):</div>
<div class="line"><span class="lineno">  598</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  599</span> </div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span><span class="preprocessor">@array_function_dispatch(_transpose_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d0eb30133091bf215a421b53e8d65e1" name="a3d0eb30133091bf215a421b53e8d65e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0eb30133091bf215a421b53e8d65e1">&#9670;&#160;</a></span>_var_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._var_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3610</span>                    keepdims=<span class="keywordtype">None</span>, *, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3611</span>    <span class="keywordflow">return</span> (a, where, out)</div>
<div class="line"><span class="lineno"> 3612</span> </div>
<div class="line"><span class="lineno"> 3613</span> </div>
<div class="line"><span class="lineno"> 3614</span><span class="preprocessor">@array_function_dispatch(_var_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a40d8c37d3eac5fd5fa3f08c59b982097" name="a40d8c37d3eac5fd5fa3f08c59b982097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d8c37d3eac5fd5fa3f08c59b982097">&#9670;&#160;</a></span>_wrapfunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._wrapfunc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   51</span><span class="keyword">def </span>_wrapfunc(obj, method, *args, **kwds):</div>
<div class="line"><span class="lineno">   52</span>    bound = getattr(obj, method, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordflow">if</span> bound <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   54</span>        <span class="keywordflow">return</span> _wrapit(obj, method, *args, **kwds)</div>
<div class="line"><span class="lineno">   55</span> </div>
<div class="line"><span class="lineno">   56</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   57</span>        <span class="keywordflow">return</span> bound(*args, **kwds)</div>
<div class="line"><span class="lineno">   58</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">   59</span>        <span class="comment"># A TypeError occurs if the object does have such a method in its</span></div>
<div class="line"><span class="lineno">   60</span>        <span class="comment"># class, but its signature is not identical to that of NumPy&#39;s. This</span></div>
<div class="line"><span class="lineno">   61</span>        <span class="comment"># situation has occurred in the case of a downstream library like</span></div>
<div class="line"><span class="lineno">   62</span>        <span class="comment"># &#39;pandas&#39;.</span></div>
<div class="line"><span class="lineno">   63</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno">   64</span>        <span class="comment"># Call _wrapit from within the except clause to ensure a potential</span></div>
<div class="line"><span class="lineno">   65</span>        <span class="comment"># exception has a traceback chain.</span></div>
<div class="line"><span class="lineno">   66</span>        <span class="keywordflow">return</span> _wrapit(obj, method, *args, **kwds)</div>
<div class="line"><span class="lineno">   67</span> </div>
<div class="line"><span class="lineno">   68</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa63c407390f4c2a7cdcf1e4da0ad1235" name="aa63c407390f4c2a7cdcf1e4da0ad1235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63c407390f4c2a7cdcf1e4da0ad1235">&#9670;&#160;</a></span>_wrapit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._wrapit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   38</span><span class="keyword">def </span>_wrapit(obj, method, *args, **kwds):</div>
<div class="line"><span class="lineno">   39</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   40</span>        wrap = obj.__array_wrap__</div>
<div class="line"><span class="lineno">   41</span>    <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno">   42</span>        wrap = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">   43</span>    result = getattr(asarray(obj), method)(*args, **kwds)</div>
<div class="line"><span class="lineno">   44</span>    <span class="keywordflow">if</span> wrap:</div>
<div class="line"><span class="lineno">   45</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(result, mu.ndarray):</div>
<div class="line"><span class="lineno">   46</span>            result = asarray(result)</div>
<div class="line"><span class="lineno">   47</span>        result = wrap(result)</div>
<div class="line"><span class="lineno">   48</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac826deaded873153a108b522ea804148" name="ac826deaded873153a108b522ea804148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac826deaded873153a108b522ea804148">&#9670;&#160;</a></span>_wrapreduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._wrapreduction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ufunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   69</span><span class="keyword">def </span>_wrapreduction(obj, ufunc, method, axis, dtype, out, **kwargs):</div>
<div class="line"><span class="lineno">   70</span>    passkwargs = {k: v <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> kwargs.items()</div>
<div class="line"><span class="lineno">   71</span>                  <span class="keywordflow">if</span> v <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue}</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">if</span> type(obj) <span class="keywordflow">is</span> <span class="keywordflow">not</span> mu.ndarray:</div>
<div class="line"><span class="lineno">   74</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   75</span>            reduction = getattr(obj, method)</div>
<div class="line"><span class="lineno">   76</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno">   77</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">   78</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   79</span>            <span class="comment"># This branch is needed for reductions like any which don&#39;t</span></div>
<div class="line"><span class="lineno">   80</span>            <span class="comment"># support a dtype.</span></div>
<div class="line"><span class="lineno">   81</span>            <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   82</span>                <span class="keywordflow">return</span> reduction(axis=axis, dtype=dtype, out=out, **passkwargs)</div>
<div class="line"><span class="lineno">   83</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   84</span>                <span class="keywordflow">return</span> reduction(axis=axis, out=out, **passkwargs)</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordflow">return</span> ufunc.reduce(obj, axis, dtype, out, **passkwargs)</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abdcf566dccb55a6c6e6fb6197510554e" name="abdcf566dccb55a6c6e6fb6197510554e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcf566dccb55a6c6e6fb6197510554e">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether all array elements along a given axis evaluate to True.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical AND reduction is performed.
    The default (``axis=None``) is to perform a logical AND over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.
    It must have the same shape as the expected output and its
    type is preserved (e.g., if ``dtype(out)`` is float, the result
    will consist of 0.0's and 1.0's). See :ref:`ufuncs-output-type` for more
    details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `all` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

where : array_like of bool, optional
    Elements to include in checking for all `True` values.
    See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.20.0

Returns
-------
all : ndarray, bool
    A new boolean or array is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.all : equivalent method

any : Test whether any element along a given axis evaluates to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity
evaluate to `True` because these are not equal to zero.

Examples
--------
&gt;&gt;&gt; np.all([[True,False],[True,True]])
False

&gt;&gt;&gt; np.all([[True,False],[True,True]], axis=0)
array([ True, False])

&gt;&gt;&gt; np.all([-1, 4, 5])
True

&gt;&gt;&gt; np.all([1.0, np.nan])
True

&gt;&gt;&gt; np.all([[True, True], [False, True]], where=[[True], [False]])
True

&gt;&gt;&gt; o=np.array(False)
&gt;&gt;&gt; z=np.all([-1, 4, 5], out=o)
&gt;&gt;&gt; id(z), id(o), z
(28293632, 28293632, array(True)) # may vary</pre> <div class="fragment"><div class="line"><span class="lineno"> 2433</span><span class="keyword">def </span>all(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):</div>
<div class="line"><span class="lineno"> 2434</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">    Test whether all array elements along a given axis evaluate to True.</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">        Axis or axes along which a logical AND reduction is performed.</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">        The default (``axis=None``) is to perform a logical AND over all</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral">        the dimensions of the input array. `axis` may be negative, in</span></div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">        which case it counts from the last to the first axis.</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">        If this is a tuple of ints, a reduction is performed on multiple</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">        axes, instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">        Alternate output array in which to place the result.</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">        It must have the same shape as the expected output and its</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">        type is preserved (e.g., if ``dtype(out)`` is float, the result</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">        will consist of 0.0&#39;s and 1.0&#39;s). See :ref:`ufuncs-output-type` for more</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">        details.</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">        passed through to the `all` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral">        Elements to include in checking for all `True` values.</span></div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral">        See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral">    all : ndarray, bool</span></div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">        A new boolean or array is returned unless `out` is specified,</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">        in which case a reference to `out` is returned.</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">    ndarray.all : equivalent method</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral">    any : Test whether any element along a given axis evaluates to True.</span></div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">    Not a Number (NaN), positive infinity and negative infinity</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral">    evaluate to `True` because these are not equal to zero.</span></div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral">    &gt;&gt;&gt; np.all([[True,False],[True,True]])</span></div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 2496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral">    &gt;&gt;&gt; np.all([[True,False],[True,True]], axis=0)</span></div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral">    array([ True, False])</span></div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral">    &gt;&gt;&gt; np.all([-1, 4, 5])</span></div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">    &gt;&gt;&gt; np.all([1.0, np.nan])</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">    &gt;&gt;&gt; np.all([[True, True], [False, True]], where=[[True], [False]])</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral">    &gt;&gt;&gt; o=np.array(False)</span></div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral">    &gt;&gt;&gt; z=np.all([-1, 4, 5], out=o)</span></div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">    &gt;&gt;&gt; id(z), id(o), z</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">    (28293632, 28293632, array(True)) # may vary</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2515</span>    <span class="keywordflow">return</span> _wrapreduction(a, np.logical_and, <span class="stringliteral">&#39;all&#39;</span>, axis, <span class="keywordtype">None</span>, out,</div>
<div class="line"><span class="lineno"> 2516</span>                          keepdims=keepdims, where=where)</div>
<div class="line"><span class="lineno"> 2517</span> </div>
<div class="line"><span class="lineno"> 2518</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a08e7b56544db0d95d4d140862e5b3b49" name="a08e7b56544db0d95d4d140862e5b3b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e7b56544db0d95d4d140862e5b3b49">&#9670;&#160;</a></span>alltrue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.alltrue </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if all elements of input array are true.

See Also
--------
numpy.all : Equivalent function; see for details.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3805</span><span class="keyword">def </span>alltrue(*args, **kwargs):</div>
<div class="line"><span class="lineno"> 3806</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3807</span><span class="stringliteral">    Check if all elements of input array are true.</span></div>
<div class="line"><span class="lineno"> 3808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3809</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3810</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3811</span><span class="stringliteral">    numpy.all : Equivalent function; see for details.</span></div>
<div class="line"><span class="lineno"> 3812</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3813</span>    <span class="keywordflow">return</span> all(*args, **kwargs)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ca57c9ee58464a6be1dca84f020a888" name="a1ca57c9ee58464a6be1dca84f020a888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca57c9ee58464a6be1dca84f020a888">&#9670;&#160;</a></span>amax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.amax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See :ref:`ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amax` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the maximum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is an int, the result is an array of dimension
    ``a.ndim - 1``. If `axis` is a tuple, the result is an array of 
    dimension ``a.ndim - len(axis)``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array
3
&gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
&gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])
&gt;&gt;&gt; np.amax(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
&gt;&gt;&gt; b = np.arange(5, dtype=float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amax(b)
nan
&gt;&gt;&gt; np.amax(b, where=~np.isnan(b), initial=-1)
4.0
&gt;&gt;&gt; np.nanmax(b)
4.0

You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:

&gt;&gt;&gt; np.amax([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])

Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

&gt;&gt;&gt; np.amax([5], initial=6)
6
&gt;&gt;&gt; max([5], default=6)
5
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2705</span>         where=np._NoValue):</div>
<div class="line"><span class="lineno"> 2706</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2707</span><span class="stringliteral">    Return the maximum of an array or maximum along an axis.</span></div>
<div class="line"><span class="lineno"> 2708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2709</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2710</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2711</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2712</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 2713</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 2714</span><span class="stringliteral">        Axis or axes along which to operate.  By default, flattened input is</span></div>
<div class="line"><span class="lineno"> 2715</span><span class="stringliteral">        used.</span></div>
<div class="line"><span class="lineno"> 2716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2717</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2719</span><span class="stringliteral">        If this is a tuple of ints, the maximum is selected over multiple axes,</span></div>
<div class="line"><span class="lineno"> 2720</span><span class="stringliteral">        instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 2721</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2722</span><span class="stringliteral">        Alternative output array in which to place the result.  Must</span></div>
<div class="line"><span class="lineno"> 2723</span><span class="stringliteral">        be of the same shape and buffer length as the expected output.</span></div>
<div class="line"><span class="lineno"> 2724</span><span class="stringliteral">        See :ref:`ufuncs-output-type` for more details.</span></div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 2728</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 2729</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 2730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2731</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 2732</span><span class="stringliteral">        passed through to the `amax` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 2733</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 2734</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 2735</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 2736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2737</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno"> 2738</span><span class="stringliteral">        The minimum value of an output element. Must be present to allow</span></div>
<div class="line"><span class="lineno"> 2739</span><span class="stringliteral">        computation on empty slice. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 2740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2741</span><span class="stringliteral">        .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno"> 2742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral">        Elements to compare for the maximum. See `~numpy.ufunc.reduce`</span></div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral">        for details.</span></div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2751</span><span class="stringliteral">    amax : ndarray or scalar</span></div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral">        Maximum of `a`. If `axis` is None, the result is a scalar value.</span></div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral">        If `axis` is an int, the result is an array of dimension</span></div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral">        ``a.ndim - 1``. If `axis` is a tuple, the result is an array of </span></div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral">        dimension ``a.ndim - len(axis)``.</span></div>
<div class="line"><span class="lineno"> 2756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral">    amin :</span></div>
<div class="line"><span class="lineno"> 2760</span><span class="stringliteral">        The minimum value of an array along a given axis, propagating any NaNs.</span></div>
<div class="line"><span class="lineno"> 2761</span><span class="stringliteral">    nanmax :</span></div>
<div class="line"><span class="lineno"> 2762</span><span class="stringliteral">        The maximum value of an array along a given axis, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno"> 2763</span><span class="stringliteral">    maximum :</span></div>
<div class="line"><span class="lineno"> 2764</span><span class="stringliteral">        Element-wise maximum of two arrays, propagating any NaNs.</span></div>
<div class="line"><span class="lineno"> 2765</span><span class="stringliteral">    fmax :</span></div>
<div class="line"><span class="lineno"> 2766</span><span class="stringliteral">        Element-wise maximum of two arrays, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno"> 2767</span><span class="stringliteral">    argmax :</span></div>
<div class="line"><span class="lineno"> 2768</span><span class="stringliteral">        Return the indices of the maximum values.</span></div>
<div class="line"><span class="lineno"> 2769</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2770</span><span class="stringliteral">    nanmin, minimum, fmin</span></div>
<div class="line"><span class="lineno"> 2771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2772</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2773</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="stringliteral">    NaN values are propagated, that is if at least one item is NaN, the</span></div>
<div class="line"><span class="lineno"> 2775</span><span class="stringliteral">    corresponding max value will be NaN as well. To ignore NaN values</span></div>
<div class="line"><span class="lineno"> 2776</span><span class="stringliteral">    (MATLAB behavior), please use nanmax.</span></div>
<div class="line"><span class="lineno"> 2777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2778</span><span class="stringliteral">    Don&#39;t use `amax` for element-wise comparison of 2 arrays; when</span></div>
<div class="line"><span class="lineno"> 2779</span><span class="stringliteral">    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than</span></div>
<div class="line"><span class="lineno"> 2780</span><span class="stringliteral">    ``amax(a, axis=0)``.</span></div>
<div class="line"><span class="lineno"> 2781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2782</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2783</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2784</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(4).reshape((2,2))</span></div>
<div class="line"><span class="lineno"> 2785</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2786</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno"> 2787</span><span class="stringliteral">           [2, 3]])</span></div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">    &gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral">    3</span></div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">    &gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">    array([2, 3])</span></div>
<div class="line"><span class="lineno"> 2792</span><span class="stringliteral">    &gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis</span></div>
<div class="line"><span class="lineno"> 2793</span><span class="stringliteral">    array([1, 3])</span></div>
<div class="line"><span class="lineno"> 2794</span><span class="stringliteral">    &gt;&gt;&gt; np.amax(a, where=[False, True], initial=-1, axis=0)</span></div>
<div class="line"><span class="lineno"> 2795</span><span class="stringliteral">    array([-1,  3])</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(5, dtype=float)</span></div>
<div class="line"><span class="lineno"> 2797</span><span class="stringliteral">    &gt;&gt;&gt; b[2] = np.NaN</span></div>
<div class="line"><span class="lineno"> 2798</span><span class="stringliteral">    &gt;&gt;&gt; np.amax(b)</span></div>
<div class="line"><span class="lineno"> 2799</span><span class="stringliteral">    nan</span></div>
<div class="line"><span class="lineno"> 2800</span><span class="stringliteral">    &gt;&gt;&gt; np.amax(b, where=~np.isnan(b), initial=-1)</span></div>
<div class="line"><span class="lineno"> 2801</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno"> 2802</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmax(b)</span></div>
<div class="line"><span class="lineno"> 2803</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno"> 2804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2805</span><span class="stringliteral">    You can use an initial value to compute the maximum of an empty slice, or</span></div>
<div class="line"><span class="lineno"> 2806</span><span class="stringliteral">    to initialize it to a different value:</span></div>
<div class="line"><span class="lineno"> 2807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2808</span><span class="stringliteral">    &gt;&gt;&gt; np.amax([[-50], [10]], axis=-1, initial=0)</span></div>
<div class="line"><span class="lineno"> 2809</span><span class="stringliteral">    array([ 0, 10])</span></div>
<div class="line"><span class="lineno"> 2810</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2811</span><span class="stringliteral">    Notice that the initial value is used as one of the elements for which the</span></div>
<div class="line"><span class="lineno"> 2812</span><span class="stringliteral">    maximum is determined, unlike for the default argument Python&#39;s max</span></div>
<div class="line"><span class="lineno"> 2813</span><span class="stringliteral">    function, which is only used for empty iterables.</span></div>
<div class="line"><span class="lineno"> 2814</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2815</span><span class="stringliteral">    &gt;&gt;&gt; np.amax([5], initial=6)</span></div>
<div class="line"><span class="lineno"> 2816</span><span class="stringliteral">    6</span></div>
<div class="line"><span class="lineno"> 2817</span><span class="stringliteral">    &gt;&gt;&gt; max([5], default=6)</span></div>
<div class="line"><span class="lineno"> 2818</span><span class="stringliteral">    5</span></div>
<div class="line"><span class="lineno"> 2819</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2820</span>    <span class="keywordflow">return</span> _wrapreduction(a, np.maximum, <span class="stringliteral">&#39;max&#39;</span>, axis, <span class="keywordtype">None</span>, out,</div>
<div class="line"><span class="lineno"> 2821</span>                          keepdims=keepdims, initial=initial, where=where)</div>
<div class="line"><span class="lineno"> 2822</span> </div>
<div class="line"><span class="lineno"> 2823</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a10b55151866741431b83f40020bb43" name="a9a10b55151866741431b83f40020bb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a10b55151866741431b83f40020bb43">&#9670;&#160;</a></span>amin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.amin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See :ref:`ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amin` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The maximum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the minimum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is an int, the result is an array of dimension
    ``a.ndim - 1``.  If `axis` is a tuple, the result is an array of 
    dimension ``a.ndim - len(axis)``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array
0
&gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
&gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])
&gt;&gt;&gt; np.amin(a, where=[False, True], initial=10, axis=0)
array([10,  1])

&gt;&gt;&gt; b = np.arange(5, dtype=float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amin(b)
nan
&gt;&gt;&gt; np.amin(b, where=~np.isnan(b), initial=10)
0.0
&gt;&gt;&gt; np.nanmin(b)
0.0

&gt;&gt;&gt; np.amin([[-50], [10]], axis=-1, initial=0)
array([-50,   0])

Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

Notice that this isn't the same as Python's ``default`` argument.

&gt;&gt;&gt; np.amin([6], initial=5)
5
&gt;&gt;&gt; min([6], default=5)
6
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2831</span>         where=np._NoValue):</div>
<div class="line"><span class="lineno"> 2832</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2833</span><span class="stringliteral">    Return the minimum of an array or minimum along an axis.</span></div>
<div class="line"><span class="lineno"> 2834</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2835</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2836</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2837</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2838</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 2839</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 2840</span><span class="stringliteral">        Axis or axes along which to operate.  By default, flattened input is</span></div>
<div class="line"><span class="lineno"> 2841</span><span class="stringliteral">        used.</span></div>
<div class="line"><span class="lineno"> 2842</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2843</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2844</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2845</span><span class="stringliteral">        If this is a tuple of ints, the minimum is selected over multiple axes,</span></div>
<div class="line"><span class="lineno"> 2846</span><span class="stringliteral">        instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 2847</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2848</span><span class="stringliteral">        Alternative output array in which to place the result.  Must</span></div>
<div class="line"><span class="lineno"> 2849</span><span class="stringliteral">        be of the same shape and buffer length as the expected output.</span></div>
<div class="line"><span class="lineno"> 2850</span><span class="stringliteral">        See :ref:`ufuncs-output-type` for more details.</span></div>
<div class="line"><span class="lineno"> 2851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2852</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2853</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 2854</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 2855</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 2856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2857</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 2858</span><span class="stringliteral">        passed through to the `amin` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 2859</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 2860</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 2861</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 2862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2863</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno"> 2864</span><span class="stringliteral">        The maximum value of an output element. Must be present to allow</span></div>
<div class="line"><span class="lineno"> 2865</span><span class="stringliteral">        computation on empty slice. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 2866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2867</span><span class="stringliteral">        .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno"> 2868</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2869</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 2870</span><span class="stringliteral">        Elements to compare for the minimum. See `~numpy.ufunc.reduce`</span></div>
<div class="line"><span class="lineno"> 2871</span><span class="stringliteral">        for details.</span></div>
<div class="line"><span class="lineno"> 2872</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2873</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 2874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2875</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2876</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2877</span><span class="stringliteral">    amin : ndarray or scalar</span></div>
<div class="line"><span class="lineno"> 2878</span><span class="stringliteral">        Minimum of `a`. If `axis` is None, the result is a scalar value.</span></div>
<div class="line"><span class="lineno"> 2879</span><span class="stringliteral">        If `axis` is an int, the result is an array of dimension</span></div>
<div class="line"><span class="lineno"> 2880</span><span class="stringliteral">        ``a.ndim - 1``.  If `axis` is a tuple, the result is an array of </span></div>
<div class="line"><span class="lineno"> 2881</span><span class="stringliteral">        dimension ``a.ndim - len(axis)``.</span></div>
<div class="line"><span class="lineno"> 2882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2883</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2884</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2885</span><span class="stringliteral">    amax :</span></div>
<div class="line"><span class="lineno"> 2886</span><span class="stringliteral">        The maximum value of an array along a given axis, propagating any NaNs.</span></div>
<div class="line"><span class="lineno"> 2887</span><span class="stringliteral">    nanmin :</span></div>
<div class="line"><span class="lineno"> 2888</span><span class="stringliteral">        The minimum value of an array along a given axis, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno"> 2889</span><span class="stringliteral">    minimum :</span></div>
<div class="line"><span class="lineno"> 2890</span><span class="stringliteral">        Element-wise minimum of two arrays, propagating any NaNs.</span></div>
<div class="line"><span class="lineno"> 2891</span><span class="stringliteral">    fmin :</span></div>
<div class="line"><span class="lineno"> 2892</span><span class="stringliteral">        Element-wise minimum of two arrays, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno"> 2893</span><span class="stringliteral">    argmin :</span></div>
<div class="line"><span class="lineno"> 2894</span><span class="stringliteral">        Return the indices of the minimum values.</span></div>
<div class="line"><span class="lineno"> 2895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2896</span><span class="stringliteral">    nanmax, maximum, fmax</span></div>
<div class="line"><span class="lineno"> 2897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2898</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2899</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2900</span><span class="stringliteral">    NaN values are propagated, that is if at least one item is NaN, the</span></div>
<div class="line"><span class="lineno"> 2901</span><span class="stringliteral">    corresponding min value will be NaN as well. To ignore NaN values</span></div>
<div class="line"><span class="lineno"> 2902</span><span class="stringliteral">    (MATLAB behavior), please use nanmin.</span></div>
<div class="line"><span class="lineno"> 2903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2904</span><span class="stringliteral">    Don&#39;t use `amin` for element-wise comparison of 2 arrays; when</span></div>
<div class="line"><span class="lineno"> 2905</span><span class="stringliteral">    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than</span></div>
<div class="line"><span class="lineno"> 2906</span><span class="stringliteral">    ``amin(a, axis=0)``.</span></div>
<div class="line"><span class="lineno"> 2907</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(4).reshape((2,2))</span></div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2912</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral">           [2, 3]])</span></div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral">    &gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array</span></div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno"> 2916</span><span class="stringliteral">    &gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis</span></div>
<div class="line"><span class="lineno"> 2917</span><span class="stringliteral">    array([0, 1])</span></div>
<div class="line"><span class="lineno"> 2918</span><span class="stringliteral">    &gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis</span></div>
<div class="line"><span class="lineno"> 2919</span><span class="stringliteral">    array([0, 2])</span></div>
<div class="line"><span class="lineno"> 2920</span><span class="stringliteral">    &gt;&gt;&gt; np.amin(a, where=[False, True], initial=10, axis=0)</span></div>
<div class="line"><span class="lineno"> 2921</span><span class="stringliteral">    array([10,  1])</span></div>
<div class="line"><span class="lineno"> 2922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2923</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(5, dtype=float)</span></div>
<div class="line"><span class="lineno"> 2924</span><span class="stringliteral">    &gt;&gt;&gt; b[2] = np.NaN</span></div>
<div class="line"><span class="lineno"> 2925</span><span class="stringliteral">    &gt;&gt;&gt; np.amin(b)</span></div>
<div class="line"><span class="lineno"> 2926</span><span class="stringliteral">    nan</span></div>
<div class="line"><span class="lineno"> 2927</span><span class="stringliteral">    &gt;&gt;&gt; np.amin(b, where=~np.isnan(b), initial=10)</span></div>
<div class="line"><span class="lineno"> 2928</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 2929</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmin(b)</span></div>
<div class="line"><span class="lineno"> 2930</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 2931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2932</span><span class="stringliteral">    &gt;&gt;&gt; np.amin([[-50], [10]], axis=-1, initial=0)</span></div>
<div class="line"><span class="lineno"> 2933</span><span class="stringliteral">    array([-50,   0])</span></div>
<div class="line"><span class="lineno"> 2934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2935</span><span class="stringliteral">    Notice that the initial value is used as one of the elements for which the</span></div>
<div class="line"><span class="lineno"> 2936</span><span class="stringliteral">    minimum is determined, unlike for the default argument Python&#39;s max</span></div>
<div class="line"><span class="lineno"> 2937</span><span class="stringliteral">    function, which is only used for empty iterables.</span></div>
<div class="line"><span class="lineno"> 2938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2939</span><span class="stringliteral">    Notice that this isn&#39;t the same as Python&#39;s ``default`` argument.</span></div>
<div class="line"><span class="lineno"> 2940</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2941</span><span class="stringliteral">    &gt;&gt;&gt; np.amin([6], initial=5)</span></div>
<div class="line"><span class="lineno"> 2942</span><span class="stringliteral">    5</span></div>
<div class="line"><span class="lineno"> 2943</span><span class="stringliteral">    &gt;&gt;&gt; min([6], default=5)</span></div>
<div class="line"><span class="lineno"> 2944</span><span class="stringliteral">    6</span></div>
<div class="line"><span class="lineno"> 2945</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2946</span>    <span class="keywordflow">return</span> _wrapreduction(a, np.minimum, <span class="stringliteral">&#39;min&#39;</span>, axis, <span class="keywordtype">None</span>, out,</div>
<div class="line"><span class="lineno"> 2947</span>                          keepdims=keepdims, initial=initial, where=where)</div>
<div class="line"><span class="lineno"> 2948</span> </div>
<div class="line"><span class="lineno"> 2949</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a70d688ab4080673659c2857c9266ee52" name="a70d688ab4080673659c2857c9266ee52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d688ab4080673659c2857c9266ee52">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.any </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether any array element along a given axis evaluates to True.

Returns single boolean if `axis` is ``None``

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical OR reduction is performed.
    The default (``axis=None``) is to perform a logical OR over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output and its type is preserved
    (e.g., if it is of type float, then it will remain so, returning
    1.0 for True and 0.0 for False, regardless of the type of `a`).
    See :ref:`ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `any` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

where : array_like of bool, optional
    Elements to include in checking for any `True` values.
    See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.20.0

Returns
-------
any : bool or ndarray
    A new boolean or `ndarray` is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.any : equivalent method

all : Test whether all elements along a given axis evaluate to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity evaluate
to `True` because these are not equal to zero.

Examples
--------
&gt;&gt;&gt; np.any([[True, False], [True, True]])
True

&gt;&gt;&gt; np.any([[True, False], [False, False]], axis=0)
array([ True, False])

&gt;&gt;&gt; np.any([-1, 0, 5])
True

&gt;&gt;&gt; np.any(np.nan)
True

&gt;&gt;&gt; np.any([[True, False], [False, False]], where=[[False], [True]])
False

&gt;&gt;&gt; o=np.array(False)
&gt;&gt;&gt; z=np.any([-1, 4, 5], out=o)
&gt;&gt;&gt; z, o
(array(True), array(True))
&gt;&gt;&gt; # Check now that z is a reference to o
&gt;&gt;&gt; z is o
True
&gt;&gt;&gt; id(z), id(o) # identity of z and o              # doctest: +SKIP
(191614240, 191614240)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2334</span><span class="keyword">def </span>any(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):</div>
<div class="line"><span class="lineno"> 2335</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">    Test whether any array element along a given axis evaluates to True.</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral">    Returns single boolean if `axis` is ``None``</span></div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 2344</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 2345</span><span class="stringliteral">        Axis or axes along which a logical OR reduction is performed.</span></div>
<div class="line"><span class="lineno"> 2346</span><span class="stringliteral">        The default (``axis=None``) is to perform a logical OR over all</span></div>
<div class="line"><span class="lineno"> 2347</span><span class="stringliteral">        the dimensions of the input array. `axis` may be negative, in</span></div>
<div class="line"><span class="lineno"> 2348</span><span class="stringliteral">        which case it counts from the last to the first axis.</span></div>
<div class="line"><span class="lineno"> 2349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2350</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2352</span><span class="stringliteral">        If this is a tuple of ints, a reduction is performed on multiple</span></div>
<div class="line"><span class="lineno"> 2353</span><span class="stringliteral">        axes, instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 2354</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2355</span><span class="stringliteral">        Alternate output array in which to place the result.  It must have</span></div>
<div class="line"><span class="lineno"> 2356</span><span class="stringliteral">        the same shape as the expected output and its type is preserved</span></div>
<div class="line"><span class="lineno"> 2357</span><span class="stringliteral">        (e.g., if it is of type float, then it will remain so, returning</span></div>
<div class="line"><span class="lineno"> 2358</span><span class="stringliteral">        1.0 for True and 0.0 for False, regardless of the type of `a`).</span></div>
<div class="line"><span class="lineno"> 2359</span><span class="stringliteral">        See :ref:`ufuncs-output-type` for more details.</span></div>
<div class="line"><span class="lineno"> 2360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2361</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2362</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 2363</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 2364</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 2365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2366</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 2367</span><span class="stringliteral">        passed through to the `any` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 2368</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 2369</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 2370</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 2371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2372</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 2373</span><span class="stringliteral">        Elements to include in checking for any `True` values.</span></div>
<div class="line"><span class="lineno"> 2374</span><span class="stringliteral">        See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 2375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2376</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno"> 2377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2378</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2379</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2380</span><span class="stringliteral">    any : bool or ndarray</span></div>
<div class="line"><span class="lineno"> 2381</span><span class="stringliteral">        A new boolean or `ndarray` is returned unless `out` is specified,</span></div>
<div class="line"><span class="lineno"> 2382</span><span class="stringliteral">        in which case a reference to `out` is returned.</span></div>
<div class="line"><span class="lineno"> 2383</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2384</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">    ndarray.any : equivalent method</span></div>
<div class="line"><span class="lineno"> 2387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2388</span><span class="stringliteral">    all : Test whether all elements along a given axis evaluate to True.</span></div>
<div class="line"><span class="lineno"> 2389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2390</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2391</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2392</span><span class="stringliteral">    Not a Number (NaN), positive infinity and negative infinity evaluate</span></div>
<div class="line"><span class="lineno"> 2393</span><span class="stringliteral">    to `True` because these are not equal to zero.</span></div>
<div class="line"><span class="lineno"> 2394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2395</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral">    &gt;&gt;&gt; np.any([[True, False], [True, True]])</span></div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">    &gt;&gt;&gt; np.any([[True, False], [False, False]], axis=0)</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral">    array([ True, False])</span></div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">    &gt;&gt;&gt; np.any([-1, 0, 5])</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">    &gt;&gt;&gt; np.any(np.nan)</span></div>
<div class="line"><span class="lineno"> 2407</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2409</span><span class="stringliteral">    &gt;&gt;&gt; np.any([[True, False], [False, False]], where=[[False], [True]])</span></div>
<div class="line"><span class="lineno"> 2410</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 2411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral">    &gt;&gt;&gt; o=np.array(False)</span></div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral">    &gt;&gt;&gt; z=np.any([-1, 4, 5], out=o)</span></div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral">    &gt;&gt;&gt; z, o</span></div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral">    (array(True), array(True))</span></div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral">    &gt;&gt;&gt; # Check now that z is a reference to o</span></div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral">    &gt;&gt;&gt; z is o</span></div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2419</span><span class="stringliteral">    &gt;&gt;&gt; id(z), id(o) # identity of z and o              # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 2420</span><span class="stringliteral">    (191614240, 191614240)</span></div>
<div class="line"><span class="lineno"> 2421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2422</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2423</span>    <span class="keywordflow">return</span> _wrapreduction(a, np.logical_or, <span class="stringliteral">&#39;any&#39;</span>, axis, <span class="keywordtype">None</span>, out,</div>
<div class="line"><span class="lineno"> 2424</span>                          keepdims=keepdims, where=where)</div>
<div class="line"><span class="lineno"> 2425</span> </div>
<div class="line"><span class="lineno"> 2426</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acf20bc7c07f5a90ffe84fc697d55926d" name="acf20bc7c07f5a90ffe84fc697d55926d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf20bc7c07f5a90ffe84fc697d55926d">&#9670;&#160;</a></span>argmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.argmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the indices of the maximum values along an axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    By default, the index is into the flattened array, otherwise
    along the specified axis.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

    .. versionadded:: 1.22.0

Returns
-------
index_array : ndarray of ints
    Array of indices into the array. It has the same shape as `a.shape`
    with the dimension along `axis` removed. If `keepdims` is set to True,
    then the size of `axis` will be 1 with the resulting array having same
    shape as `a.shape`.

See Also
--------
ndarray.argmax, argmin
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply ``np.expand_dims(index_array, axis)``
                  from argmax to an array as if by calling max.

Notes
-----
In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.

Examples
--------
&gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10
&gt;&gt;&gt; a
array([[10, 11, 12],
       [13, 14, 15]])
&gt;&gt;&gt; np.argmax(a)
5
&gt;&gt;&gt; np.argmax(a, axis=0)
array([1, 1, 1])
&gt;&gt;&gt; np.argmax(a, axis=1)
array([2, 2])

Indexes of the maximal elements of a N-dimensional array:

&gt;&gt;&gt; ind = np.unravel_index(np.argmax(a, axis=None), a.shape)
&gt;&gt;&gt; ind
(1, 2)
&gt;&gt;&gt; a[ind]
15

&gt;&gt;&gt; b = np.arange(6)
&gt;&gt;&gt; b[1] = 5
&gt;&gt;&gt; b
array([0, 5, 2, 3, 4, 5])
&gt;&gt;&gt; np.argmax(b)  # Only the first occurrence is returned.
1

&gt;&gt;&gt; x = np.array([[4,2,3], [1,0,3]])
&gt;&gt;&gt; index_array = np.argmax(x, axis=-1)
&gt;&gt;&gt; # Same as np.amax(x, axis=-1, keepdims=True)
&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
array([[4],
       [3]])
&gt;&gt;&gt; # Same as np.amax(x, axis=-1)
&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
array([4, 3])

Setting `keepdims` to `True`,

&gt;&gt;&gt; x = np.arange(24).reshape((2, 3, 4))
&gt;&gt;&gt; res = np.argmax(x, axis=1, keepdims=True)
&gt;&gt;&gt; res.shape
(2, 1, 4)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1154</span><span class="keyword">def </span>argmax(a, axis=None, out=None, *, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno"> 1155</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    Returns the indices of the maximum values along an axis.</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">        By default, the index is into the flattened array, otherwise</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">        along the specified axis.</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    out : array, optional</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">        If provided, the result will be inserted into this array. It should</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">        be of the appropriate shape and dtype.</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">        the result will broadcast correctly against the array.</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    index_array : ndarray of ints</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">        Array of indices into the array. It has the same shape as `a.shape`</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">        with the dimension along `axis` removed. If `keepdims` is set to True,</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">        then the size of `axis` will be 1 with the resulting array having same</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">        shape as `a.shape`.</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    ndarray.argmax, argmin</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    amax : The maximum value along a given axis.</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    unravel_index : Convert a flat index into an index tuple.</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    take_along_axis : Apply ``np.expand_dims(index_array, axis)``</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">                      from argmax to an array as if by calling max.</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    In case of multiple occurrences of the maximum values, the indices</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    corresponding to the first occurrence are returned.</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    array([[10, 11, 12],</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">           [13, 14, 15]])</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    &gt;&gt;&gt; np.argmax(a)</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    5</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    &gt;&gt;&gt; np.argmax(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    array([1, 1, 1])</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    &gt;&gt;&gt; np.argmax(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">    array([2, 2])</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    Indexes of the maximal elements of a N-dimensional array:</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    &gt;&gt;&gt; ind = np.unravel_index(np.argmax(a, axis=None), a.shape)</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    &gt;&gt;&gt; ind</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    (1, 2)</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">    &gt;&gt;&gt; a[ind]</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    15</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(6)</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    &gt;&gt;&gt; b[1] = 5</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    array([0, 5, 2, 3, 4, 5])</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">    &gt;&gt;&gt; np.argmax(b)  # Only the first occurrence is returned.</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[4,2,3], [1,0,3]])</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">    &gt;&gt;&gt; index_array = np.argmax(x, axis=-1)</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">    &gt;&gt;&gt; # Same as np.amax(x, axis=-1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    &gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">    array([[4],</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">           [3]])</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">    &gt;&gt;&gt; # Same as np.amax(x, axis=-1)</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">    &gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    array([4, 3])</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">    Setting `keepdims` to `True`,</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(24).reshape((2, 3, 4))</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">    &gt;&gt;&gt; res = np.argmax(x, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    &gt;&gt;&gt; res.shape</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">    (2, 1, 4)</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1241</span>    kwds = {<span class="stringliteral">&#39;keepdims&#39;</span>: keepdims} <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue <span class="keywordflow">else</span> {}</div>
<div class="line"><span class="lineno"> 1242</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;argmax&#39;</span>, axis=axis, out=out, **kwds)</div>
<div class="line"><span class="lineno"> 1243</span> </div>
<div class="line"><span class="lineno"> 1244</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af14ddaa6d6d3309b9b752471f0cb7c25" name="af14ddaa6d6d3309b9b752471f0cb7c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14ddaa6d6d3309b9b752471f0cb7c25">&#9670;&#160;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.argmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the indices of the minimum values along an axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    By default, the index is into the flattened array, otherwise
    along the specified axis.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

    .. versionadded:: 1.22.0

Returns
-------
index_array : ndarray of ints
    Array of indices into the array. It has the same shape as `a.shape`
    with the dimension along `axis` removed. If `keepdims` is set to True,
    then the size of `axis` will be 1 with the resulting array having same
    shape as `a.shape`.

See Also
--------
ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply ``np.expand_dims(index_array, axis)``
                  from argmin to an array as if by calling min.

Notes
-----
In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.

Examples
--------
&gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10
&gt;&gt;&gt; a
array([[10, 11, 12],
       [13, 14, 15]])
&gt;&gt;&gt; np.argmin(a)
0
&gt;&gt;&gt; np.argmin(a, axis=0)
array([0, 0, 0])
&gt;&gt;&gt; np.argmin(a, axis=1)
array([0, 0])

Indices of the minimum elements of a N-dimensional array:

&gt;&gt;&gt; ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
&gt;&gt;&gt; ind
(0, 0)
&gt;&gt;&gt; a[ind]
10

&gt;&gt;&gt; b = np.arange(6) + 10
&gt;&gt;&gt; b[4] = 10
&gt;&gt;&gt; b
array([10, 11, 12, 13, 10, 15])
&gt;&gt;&gt; np.argmin(b)  # Only the first occurrence is returned.
0

&gt;&gt;&gt; x = np.array([[4,2,3], [1,0,3]])
&gt;&gt;&gt; index_array = np.argmin(x, axis=-1)
&gt;&gt;&gt; # Same as np.amin(x, axis=-1, keepdims=True)
&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
array([[2],
       [0]])
&gt;&gt;&gt; # Same as np.amax(x, axis=-1)
&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
array([2, 0])

Setting `keepdims` to `True`,

&gt;&gt;&gt; x = np.arange(24).reshape((2, 3, 4))
&gt;&gt;&gt; res = np.argmin(x, axis=1, keepdims=True)
&gt;&gt;&gt; res.shape
(2, 1, 4)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1250</span><span class="keyword">def </span>argmin(a, axis=None, out=None, *, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno"> 1251</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    Returns the indices of the minimum values along an axis.</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">        By default, the index is into the flattened array, otherwise</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">        along the specified axis.</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    out : array, optional</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">        If provided, the result will be inserted into this array. It should</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">        be of the appropriate shape and dtype.</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        the result will broadcast correctly against the array.</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    index_array : ndarray of ints</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">        Array of indices into the array. It has the same shape as `a.shape`</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">        with the dimension along `axis` removed. If `keepdims` is set to True,</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">        then the size of `axis` will be 1 with the resulting array having same</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">        shape as `a.shape`.</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    ndarray.argmin, argmax</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">    amin : The minimum value along a given axis.</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">    unravel_index : Convert a flat index into an index tuple.</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    take_along_axis : Apply ``np.expand_dims(index_array, axis)``</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">                      from argmin to an array as if by calling min.</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    In case of multiple occurrences of the minimum values, the indices</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    corresponding to the first occurrence are returned.</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    array([[10, 11, 12],</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">           [13, 14, 15]])</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    &gt;&gt;&gt; np.argmin(a)</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    &gt;&gt;&gt; np.argmin(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    array([0, 0, 0])</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    &gt;&gt;&gt; np.argmin(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    array([0, 0])</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    Indices of the minimum elements of a N-dimensional array:</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    &gt;&gt;&gt; ind = np.unravel_index(np.argmin(a, axis=None), a.shape)</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">    &gt;&gt;&gt; ind</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">    (0, 0)</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    &gt;&gt;&gt; a[ind]</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    10</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(6) + 10</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">    &gt;&gt;&gt; b[4] = 10</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    array([10, 11, 12, 13, 10, 15])</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    &gt;&gt;&gt; np.argmin(b)  # Only the first occurrence is returned.</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[4,2,3], [1,0,3]])</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    &gt;&gt;&gt; index_array = np.argmin(x, axis=-1)</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    &gt;&gt;&gt; # Same as np.amin(x, axis=-1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    &gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    array([[2],</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">           [0]])</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    &gt;&gt;&gt; # Same as np.amax(x, axis=-1)</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    &gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    array([2, 0])</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    Setting `keepdims` to `True`,</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(24).reshape((2, 3, 4))</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    &gt;&gt;&gt; res = np.argmin(x, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    &gt;&gt;&gt; res.shape</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">    (2, 1, 4)</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1337</span>    kwds = {<span class="stringliteral">&#39;keepdims&#39;</span>: keepdims} <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue <span class="keywordflow">else</span> {}</div>
<div class="line"><span class="lineno"> 1338</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;argmin&#39;</span>, axis=axis, out=out, **kwds)</div>
<div class="line"><span class="lineno"> 1339</span> </div>
<div class="line"><span class="lineno"> 1340</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adb1af02431e998ec84d1dcb1e7a27b79" name="adb1af02431e998ec84d1dcb1e7a27b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1af02431e998ec84d1dcb1e7a27b79">&#9670;&#160;</a></span>argpartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.argpartition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>'introselect'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform an indirect partition along the given axis using the
algorithm specified by the `kind` keyword. It returns an array of
indices of the same shape as `a` that index data along the given
axis in partitioned order.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array to sort.
kth : int or sequence of ints
    Element index to partition by. The k-th element will be in its
    final sorted position and all smaller elements will be moved
    before it and all larger elements behind it. The order of all
    elements in the partitions is undefined. If provided with a
    sequence of k-th it will partition all of them into their sorted
    position at once.

    .. deprecated:: 1.22.0
        Passing booleans as index is deprecated.
axis : int or None, optional
    Axis along which to sort. The default is -1 (the last axis). If
    None, the flattened array is used.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'
order : str or list of str, optional
    When `a` is an array with fields defined, this argument
    specifies which fields to compare first, second, etc. A single
    field can be specified as a string, and not all fields need be
    specified, but unspecified fields will still be used, in the
    order in which they come up in the dtype, to break ties.

Returns
-------
index_array : ndarray, int
    Array of indices that partition `a` along the specified axis.
    If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.
    More generally, ``np.take_along_axis(a, index_array, axis=axis)``
    always yields the partitioned `a`, irrespective of dimensionality.

See Also
--------
partition : Describes partition algorithms used.
ndarray.partition : Inplace partition.
argsort : Full indirect sort.
take_along_axis : Apply ``index_array`` from argpartition
                  to an array as if by calling partition.

Notes
-----
See `partition` for notes on the different selection algorithms.

Examples
--------
One dimensional array:

&gt;&gt;&gt; x = np.array([3, 4, 2, 1])
&gt;&gt;&gt; x[np.argpartition(x, 3)]
array([2, 1, 3, 4])
&gt;&gt;&gt; x[np.argpartition(x, (1, 3))]
array([1, 2, 3, 4])

&gt;&gt;&gt; x = [3, 4, 2, 1]
&gt;&gt;&gt; np.array(x)[np.argpartition(x, 3)]
array([2, 1, 3, 4])

Multi-dimensional array:

&gt;&gt;&gt; x = np.array([[3, 4, 2], [1, 3, 1]])
&gt;&gt;&gt; index_array = np.argpartition(x, kth=1, axis=-1)
&gt;&gt;&gt; np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)
array([[2, 3, 4],
       [1, 1, 3]])</pre> <div class="fragment"><div class="line"><span class="lineno">  793</span><span class="keyword">def </span>argpartition(a, kth, axis=-1, kind=&#39;introselect&#39;, order=None):</div>
<div class="line"><span class="lineno">  794</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    Perform an indirect partition along the given axis using the</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    algorithm specified by the `kind` keyword. It returns an array of</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    indices of the same shape as `a` that index data along the given</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    axis in partitioned order.</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        Array to sort.</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    kth : int or sequence of ints</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        Element index to partition by. The k-th element will be in its</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        final sorted position and all smaller elements will be moved</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        before it and all larger elements behind it. The order of all</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">        elements in the partitions is undefined. If provided with a</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        sequence of k-th it will partition all of them into their sorted</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">        position at once.</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">        .. deprecated:: 1.22.0</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">            Passing booleans as index is deprecated.</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        Axis along which to sort. The default is -1 (the last axis). If</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">        None, the flattened array is used.</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    kind : {&#39;introselect&#39;}, optional</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">        Selection algorithm. Default is &#39;introselect&#39;</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    order : str or list of str, optional</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        When `a` is an array with fields defined, this argument</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">        specifies which fields to compare first, second, etc. A single</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        field can be specified as a string, and not all fields need be</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">        specified, but unspecified fields will still be used, in the</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        order in which they come up in the dtype, to break ties.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    index_array : ndarray, int</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">        Array of indices that partition `a` along the specified axis.</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">        If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">        More generally, ``np.take_along_axis(a, index_array, axis=axis)``</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        always yields the partitioned `a`, irrespective of dimensionality.</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    partition : Describes partition algorithms used.</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    ndarray.partition : Inplace partition.</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    argsort : Full indirect sort.</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    take_along_axis : Apply ``index_array`` from argpartition</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">                      to an array as if by calling partition.</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    See `partition` for notes on the different selection algorithms.</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    One dimensional array:</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([3, 4, 2, 1])</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    &gt;&gt;&gt; x[np.argpartition(x, 3)]</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    array([2, 1, 3, 4])</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    &gt;&gt;&gt; x[np.argpartition(x, (1, 3))]</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    array([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    &gt;&gt;&gt; x = [3, 4, 2, 1]</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    &gt;&gt;&gt; np.array(x)[np.argpartition(x, 3)]</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    array([2, 1, 3, 4])</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    Multi-dimensional array:</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[3, 4, 2], [1, 3, 1]])</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    &gt;&gt;&gt; index_array = np.argpartition(x, kth=1, axis=-1)</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    &gt;&gt;&gt; np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    array([[2, 3, 4],</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">           [1, 1, 3]])</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  871</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;argpartition&#39;</span>, kth, axis=axis, kind=kind, order=order)</div>
<div class="line"><span class="lineno">  872</span> </div>
<div class="line"><span class="lineno">  873</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a879deb9e0defb1f65e7527ce3b2ab8f1" name="a879deb9e0defb1f65e7527ce3b2ab8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879deb9e0defb1f65e7527ce3b2ab8f1">&#9670;&#160;</a></span>argsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.argsort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the indices that would sort an array.

Perform an indirect sort along the given axis using the algorithm specified
by the `kind` keyword. It returns an array of indices of the same shape as
`a` that index data along the given axis in sorted order.

Parameters
----------
a : array_like
    Array to sort.
axis : int or None, optional
    Axis along which to sort.  The default is -1 (the last axis). If None,
    the flattened array is used.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort under the covers and, in general, the
    actual implementation will vary with data type. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified `axis`.
    If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.
    More generally, ``np.take_along_axis(a, index_array, axis=axis)``
    always yields the sorted `a`, irrespective of dimensionality.

See Also
--------
sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.
argpartition : Indirect partial sort.
take_along_axis : Apply ``index_array`` from argsort
                  to an array as if by calling sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
nan values. The enhanced sort order is documented in `sort`.

Examples
--------
One dimensional array:

&gt;&gt;&gt; x = np.array([3, 1, 2])
&gt;&gt;&gt; np.argsort(x)
array([1, 2, 0])

Two-dimensional array:

&gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])
&gt;&gt;&gt; x
array([[0, 3],
       [2, 2]])

&gt;&gt;&gt; ind = np.argsort(x, axis=0)  # sorts along first axis (down)
&gt;&gt;&gt; ind
array([[0, 1],
       [1, 0]])
&gt;&gt;&gt; np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)
array([[0, 2],
       [2, 3]])

&gt;&gt;&gt; ind = np.argsort(x, axis=1)  # sorts along last axis (across)
&gt;&gt;&gt; ind
array([[0, 1],
       [0, 1]])
&gt;&gt;&gt; np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)
array([[0, 3],
       [2, 2]])

Indices of the sorted elements of a N-dimensional array:

&gt;&gt;&gt; ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
&gt;&gt;&gt; ind
(array([0, 1, 1, 0]), array([0, 0, 1, 1]))
&gt;&gt;&gt; x[ind]  # same as np.sort(x, axis=None)
array([0, 2, 2, 3])

Sorting with keys:

&gt;&gt;&gt; x = np.array([(1, 0), (0, 1)], dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])
&gt;&gt;&gt; x
array([(1, 0), (0, 1)],
      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])

&gt;&gt;&gt; np.argsort(x, order=('x','y'))
array([1, 0])

&gt;&gt;&gt; np.argsort(x, order=('y','x'))
array([0, 1])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1039</span><span class="keyword">def </span>argsort(a, axis=-1, kind=None, order=None):</div>
<div class="line"><span class="lineno"> 1040</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    Returns the indices that would sort an array.</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    Perform an indirect sort along the given axis using the algorithm specified</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">    by the `kind` keyword. It returns an array of indices of the same shape as</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    `a` that index data along the given axis in sorted order.</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">        Array to sort.</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">        Axis along which to sort.  The default is -1 (the last axis). If None,</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">        the flattened array is used.</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">    kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">        Sorting algorithm. The default is &#39;quicksort&#39;. Note that both &#39;stable&#39;</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">        and &#39;mergesort&#39; use timsort under the covers and, in general, the</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">        actual implementation will vary with data type. The &#39;mergesort&#39; option</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">        is retained for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">        .. versionchanged:: 1.15.0.</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">           The &#39;stable&#39; option was added.</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    order : str or list of str, optional</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">        When `a` is an array with fields defined, this argument specifies</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        which fields to compare first, second, etc.  A single field can</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">        be specified as a string, and not all fields need be specified,</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">        but unspecified fields will still be used, in the order in which</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">        they come up in the dtype, to break ties.</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    index_array : ndarray, int</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">        Array of indices that sort `a` along the specified `axis`.</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">        More generally, ``np.take_along_axis(a, index_array, axis=axis)``</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        always yields the sorted `a`, irrespective of dimensionality.</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    sort : Describes sorting algorithms used.</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">    lexsort : Indirect stable sort with multiple keys.</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    ndarray.sort : Inplace sort.</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    argpartition : Indirect partial sort.</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">    take_along_axis : Apply ``index_array`` from argsort</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">                      to an array as if by calling sort.</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">    See `sort` for notes on the different sorting algorithms.</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    nan values. The enhanced sort order is documented in `sort`.</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">    One dimensional array:</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([3, 1, 2])</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    &gt;&gt;&gt; np.argsort(x)</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    array([1, 2, 0])</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    Two-dimensional array:</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">    array([[0, 3],</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">           [2, 2]])</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    &gt;&gt;&gt; ind = np.argsort(x, axis=0)  # sorts along first axis (down)</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">    &gt;&gt;&gt; ind</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">           [1, 0]])</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">    &gt;&gt;&gt; np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">    array([[0, 2],</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">           [2, 3]])</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    &gt;&gt;&gt; ind = np.argsort(x, axis=1)  # sorts along last axis (across)</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    &gt;&gt;&gt; ind</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">           [0, 1]])</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    &gt;&gt;&gt; np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    array([[0, 3],</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">           [2, 2]])</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    Indices of the sorted elements of a N-dimensional array:</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    &gt;&gt;&gt; ind = np.unravel_index(np.argsort(x, axis=None), x.shape)</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    &gt;&gt;&gt; ind</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    (array([0, 1, 1, 0]), array([0, 0, 1, 1]))</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    &gt;&gt;&gt; x[ind]  # same as np.sort(x, axis=None)</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    array([0, 2, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    Sorting with keys:</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([(1, 0), (0, 1)], dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    array([(1, 0), (0, 1)],</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">          dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    &gt;&gt;&gt; np.argsort(x, order=(&#39;x&#39;,&#39;y&#39;))</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    array([1, 0])</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    &gt;&gt;&gt; np.argsort(x, order=(&#39;y&#39;,&#39;x&#39;))</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    array([0, 1])</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1146</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;argsort&#39;</span>, axis=axis, kind=kind, order=order)</div>
<div class="line"><span class="lineno"> 1147</span> </div>
<div class="line"><span class="lineno"> 1148</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abd18ac16bfbd94ba5bc275f6afbdc8bf" name="abd18ac16bfbd94ba5bc275f6afbdc8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd18ac16bfbd94ba5bc275f6afbdc8bf">&#9670;&#160;</a></span>around()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.around </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>decimals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evenly round to the given number of decimals.

Parameters
----------
a : array_like
    Input data.
decimals : int, optional
    Number of decimal places to round to (default: 0).  If
    decimals is negative, it specifies the number of positions to
    the left of the decimal point.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary. See :ref:`ufuncs-output-type` for more
    details.

Returns
-------
rounded_array : ndarray
    An array of the same type as `a`, containing the rounded values.
    Unless `out` was specified, a new array is created.  A reference to
    the result is returned.

    The real and imaginary parts of complex numbers are rounded
    separately.  The result of rounding a float is a float.

See Also
--------
ndarray.round : equivalent method
ceil, fix, floor, rint, trunc


Notes
-----
`~numpy.round` is often used as an alias for `~numpy.around`.

For values exactly halfway between rounded decimal values, NumPy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc.

``np.around`` uses a fast but sometimes inexact algorithm to round
floating-point datatypes. For positive `decimals` it is equivalent to
``np.true_divide(np.rint(a * 10**decimals), 10**decimals)``, which has
error due to the inexact representation of decimal fractions in the IEEE
floating point standard [1]_ and errors introduced when scaling by powers
of ten. For instance, note the extra "1" in the following:

    &gt;&gt;&gt; np.round(56294995342131.5, 3)
    56294995342131.51

If your goal is to print such values with a fixed number of decimals, it is
preferable to use numpy's float printing routines to limit the number of
printed decimals:

    &gt;&gt;&gt; np.format_float_positional(56294995342131.5, precision=3)
    '56294995342131.5'

The float printing routines use an accurate but much more computationally
demanding algorithm to compute the number of digits after the decimal
point.

Alternatively, Python's builtin `round` function uses a more accurate
but slower algorithm for 64-bit floating point values:

    &gt;&gt;&gt; round(56294995342131.5, 3)
    56294995342131.5
    &gt;&gt;&gt; np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
    (16.06, 16.05)


References
----------
.. [1] "Lecture Notes on the Status of IEEE 754", William Kahan,
       https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF

Examples
--------
&gt;&gt;&gt; np.around([0.37, 1.64])
array([0., 2.])
&gt;&gt;&gt; np.around([0.37, 1.64], decimals=1)
array([0.4, 1.6])
&gt;&gt;&gt; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
array([0., 2., 2., 4., 4.])
&gt;&gt;&gt; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
array([ 1,  2,  3, 11])
&gt;&gt;&gt; np.around([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3246</span><span class="keyword">def </span>around(a, decimals=0, out=None):</div>
<div class="line"><span class="lineno"> 3247</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">    Evenly round to the given number of decimals.</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">    decimals : int, optional</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">        Number of decimal places to round to (default: 0).  If</span></div>
<div class="line"><span class="lineno"> 3256</span><span class="stringliteral">        decimals is negative, it specifies the number of positions to</span></div>
<div class="line"><span class="lineno"> 3257</span><span class="stringliteral">        the left of the decimal point.</span></div>
<div class="line"><span class="lineno"> 3258</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3259</span><span class="stringliteral">        Alternative output array in which to place the result. It must have</span></div>
<div class="line"><span class="lineno"> 3260</span><span class="stringliteral">        the same shape as the expected output, but the type of the output</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">        values will be cast if necessary. See :ref:`ufuncs-output-type` for more</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral">        details.</span></div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3265</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3266</span><span class="stringliteral">    rounded_array : ndarray</span></div>
<div class="line"><span class="lineno"> 3267</span><span class="stringliteral">        An array of the same type as `a`, containing the rounded values.</span></div>
<div class="line"><span class="lineno"> 3268</span><span class="stringliteral">        Unless `out` was specified, a new array is created.  A reference to</span></div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral">        the result is returned.</span></div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3271</span><span class="stringliteral">        The real and imaginary parts of complex numbers are rounded</span></div>
<div class="line"><span class="lineno"> 3272</span><span class="stringliteral">        separately.  The result of rounding a float is a float.</span></div>
<div class="line"><span class="lineno"> 3273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3274</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3275</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3276</span><span class="stringliteral">    ndarray.round : equivalent method</span></div>
<div class="line"><span class="lineno"> 3277</span><span class="stringliteral">    ceil, fix, floor, rint, trunc</span></div>
<div class="line"><span class="lineno"> 3278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3280</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3281</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3282</span><span class="stringliteral">    `~numpy.round` is often used as an alias for `~numpy.around`.</span></div>
<div class="line"><span class="lineno"> 3283</span><span class="stringliteral">    </span></div>
<div class="line"><span class="lineno"> 3284</span><span class="stringliteral">    For values exactly halfway between rounded decimal values, NumPy</span></div>
<div class="line"><span class="lineno"> 3285</span><span class="stringliteral">    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,</span></div>
<div class="line"><span class="lineno"> 3286</span><span class="stringliteral">    -0.5 and 0.5 round to 0.0, etc.</span></div>
<div class="line"><span class="lineno"> 3287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3288</span><span class="stringliteral">    ``np.around`` uses a fast but sometimes inexact algorithm to round</span></div>
<div class="line"><span class="lineno"> 3289</span><span class="stringliteral">    floating-point datatypes. For positive `decimals` it is equivalent to</span></div>
<div class="line"><span class="lineno"> 3290</span><span class="stringliteral">    ``np.true_divide(np.rint(a * 10**decimals), 10**decimals)``, which has</span></div>
<div class="line"><span class="lineno"> 3291</span><span class="stringliteral">    error due to the inexact representation of decimal fractions in the IEEE</span></div>
<div class="line"><span class="lineno"> 3292</span><span class="stringliteral">    floating point standard [1]_ and errors introduced when scaling by powers</span></div>
<div class="line"><span class="lineno"> 3293</span><span class="stringliteral">    of ten. For instance, note the extra &quot;1&quot; in the following:</span></div>
<div class="line"><span class="lineno"> 3294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3295</span><span class="stringliteral">        &gt;&gt;&gt; np.round(56294995342131.5, 3)</span></div>
<div class="line"><span class="lineno"> 3296</span><span class="stringliteral">        56294995342131.51</span></div>
<div class="line"><span class="lineno"> 3297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3298</span><span class="stringliteral">    If your goal is to print such values with a fixed number of decimals, it is</span></div>
<div class="line"><span class="lineno"> 3299</span><span class="stringliteral">    preferable to use numpy&#39;s float printing routines to limit the number of</span></div>
<div class="line"><span class="lineno"> 3300</span><span class="stringliteral">    printed decimals:</span></div>
<div class="line"><span class="lineno"> 3301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3302</span><span class="stringliteral">        &gt;&gt;&gt; np.format_float_positional(56294995342131.5, precision=3)</span></div>
<div class="line"><span class="lineno"> 3303</span><span class="stringliteral">        &#39;56294995342131.5&#39;</span></div>
<div class="line"><span class="lineno"> 3304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3305</span><span class="stringliteral">    The float printing routines use an accurate but much more computationally</span></div>
<div class="line"><span class="lineno"> 3306</span><span class="stringliteral">    demanding algorithm to compute the number of digits after the decimal</span></div>
<div class="line"><span class="lineno"> 3307</span><span class="stringliteral">    point.</span></div>
<div class="line"><span class="lineno"> 3308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3309</span><span class="stringliteral">    Alternatively, Python&#39;s builtin `round` function uses a more accurate</span></div>
<div class="line"><span class="lineno"> 3310</span><span class="stringliteral">    but slower algorithm for 64-bit floating point values:</span></div>
<div class="line"><span class="lineno"> 3311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3312</span><span class="stringliteral">        &gt;&gt;&gt; round(56294995342131.5, 3)</span></div>
<div class="line"><span class="lineno"> 3313</span><span class="stringliteral">        56294995342131.5</span></div>
<div class="line"><span class="lineno"> 3314</span><span class="stringliteral">        &gt;&gt;&gt; np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997</span></div>
<div class="line"><span class="lineno"> 3315</span><span class="stringliteral">        (16.06, 16.05)</span></div>
<div class="line"><span class="lineno"> 3316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3318</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3319</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3320</span><span class="stringliteral">    .. [1] &quot;Lecture Notes on the Status of IEEE 754&quot;, William Kahan,</span></div>
<div class="line"><span class="lineno"> 3321</span><span class="stringliteral">           https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</span></div>
<div class="line"><span class="lineno"> 3322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3323</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3324</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3325</span><span class="stringliteral">    &gt;&gt;&gt; np.around([0.37, 1.64])</span></div>
<div class="line"><span class="lineno"> 3326</span><span class="stringliteral">    array([0., 2.])</span></div>
<div class="line"><span class="lineno"> 3327</span><span class="stringliteral">    &gt;&gt;&gt; np.around([0.37, 1.64], decimals=1)</span></div>
<div class="line"><span class="lineno"> 3328</span><span class="stringliteral">    array([0.4, 1.6])</span></div>
<div class="line"><span class="lineno"> 3329</span><span class="stringliteral">    &gt;&gt;&gt; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value</span></div>
<div class="line"><span class="lineno"> 3330</span><span class="stringliteral">    array([0., 2., 2., 4., 4.])</span></div>
<div class="line"><span class="lineno"> 3331</span><span class="stringliteral">    &gt;&gt;&gt; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned</span></div>
<div class="line"><span class="lineno"> 3332</span><span class="stringliteral">    array([ 1,  2,  3, 11])</span></div>
<div class="line"><span class="lineno"> 3333</span><span class="stringliteral">    &gt;&gt;&gt; np.around([1,2,3,11], decimals=-1)</span></div>
<div class="line"><span class="lineno"> 3334</span><span class="stringliteral">    array([ 0,  0,  0, 10])</span></div>
<div class="line"><span class="lineno"> 3335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3336</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3337</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;round&#39;</span>, decimals=decimals, out=out)</div>
<div class="line"><span class="lineno"> 3338</span> </div>
<div class="line"><span class="lineno"> 3339</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a125a1549efb6bb8a5172e32890812ae6" name="a125a1549efb6bb8a5172e32890812ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125a1549efb6bb8a5172e32890812ae6">&#9670;&#160;</a></span>choose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.choose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'raise'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct an array from an index array and a list of arrays to choose from.

First of all, if confused or uncertain, definitely look at the Examples -
in its full generality, this function is less simple than it might
seem from the following code description (below ndi =
`numpy.lib.index_tricks`):

``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.

But this omits some subtleties.  Here is a fully general summary:

Given an "index" array (`a`) of integers and a sequence of ``n`` arrays
(`choices`), `a` and each choice array are first broadcast, as necessary,
to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =
0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``
for each ``i``.  Then, a new array with shape ``Ba.shape`` is created as
follows:

* if ``mode='raise'`` (the default), then, first of all, each element of
  ``a`` (and thus ``Ba``) must be in the range ``[0, n-1]``; now, suppose
  that ``i`` (in that range) is the value at the ``(j0, j1, ..., jm)``
  position in ``Ba`` - then the value at the same position in the new array
  is the value in ``Bchoices[i]`` at that same position;

* if ``mode='wrap'``, values in `a` (and thus `Ba`) may be any (signed)
  integer; modular arithmetic is used to map integers outside the range
  `[0, n-1]` back into that range; and then the new array is constructed
  as above;

* if ``mode='clip'``, values in `a` (and thus ``Ba``) may be any (signed)
  integer; negative integers are mapped to 0; values greater than ``n-1``
  are mapped to ``n-1``; and then the new array is constructed as above.

Parameters
----------
a : int array
    This array must contain integers in ``[0, n-1]``, where ``n`` is the
    number of choices, unless ``mode=wrap`` or ``mode=clip``, in which
    cases any integers are permissible.
choices : sequence of arrays
    Choice arrays. `a` and all of the choices must be broadcastable to the
    same shape.  If `choices` is itself an array (not recommended), then
    its outermost dimension (i.e., the one corresponding to
    ``choices.shape[0]``) is taken as defining the "sequence".
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype. Note that `out` is always
    buffered if ``mode='raise'``; use other modes for better performance.
mode : {'raise' (default), 'wrap', 'clip'}, optional
    Specifies how indices outside ``[0, n-1]`` will be treated:

      * 'raise' : an exception is raised
      * 'wrap' : value becomes value mod ``n``
      * 'clip' : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1

Returns
-------
merged_array : array
    The merged result.

Raises
------
ValueError: shape mismatch
    If `a` and each choice array are not all broadcastable to the same
    shape.

See Also
--------
ndarray.choose : equivalent method
numpy.take_along_axis : Preferable if `choices` is an array

Notes
-----
To reduce the chance of misinterpretation, even though the following
"abuse" is nominally supported, `choices` should neither be, nor be
thought of as, a single array, i.e., the outermost sequence-like container
should be either a list or a tuple.

Examples
--------

&gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13],
...   [20, 21, 22, 23], [30, 31, 32, 33]]
&gt;&gt;&gt; np.choose([2, 3, 1, 0], choices
... # the first element of the result will be the first element of the
... # third (2+1) "array" in choices, namely, 20; the second element
... # will be the second element of the fourth (3+1) choice array, i.e.,
... # 31, etc.
... )
array([20, 31, 12,  3])
&gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
array([20, 31, 12,  3])
&gt;&gt;&gt; # because there are 4 choice arrays
&gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
array([20,  1, 12,  3])
&gt;&gt;&gt; # i.e., 0

A couple examples illustrating how choose broadcasts:

&gt;&gt;&gt; a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
&gt;&gt;&gt; choices = [-10, 10]
&gt;&gt;&gt; np.choose(a, choices)
array([[ 10, -10,  10],
       [-10,  10, -10],
       [ 10, -10,  10]])

&gt;&gt;&gt; # With thanks to Anne Archibald
&gt;&gt;&gt; a = np.array([0, 1]).reshape((2,1,1))
&gt;&gt;&gt; c1 = np.array([1, 2, 3]).reshape((1,3,1))
&gt;&gt;&gt; c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
&gt;&gt;&gt; np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
array([[[ 1,  1,  1,  1,  1],
        [ 2,  2,  2,  2,  2],
        [ 3,  3,  3,  3,  3]],
       [[-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5]]])</pre> <div class="fragment"><div class="line"><span class="lineno">  308</span><span class="keyword">def </span>choose(a, choices, out=None, mode=&#39;raise&#39;):</div>
<div class="line"><span class="lineno">  309</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    Construct an array from an index array and a list of arrays to choose from.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    First of all, if confused or uncertain, definitely look at the Examples -</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    in its full generality, this function is less simple than it might</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    seem from the following code description (below ndi =</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    `numpy.lib.index_tricks`):</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    But this omits some subtleties.  Here is a fully general summary:</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    Given an &quot;index&quot; array (`a`) of integers and a sequence of ``n`` arrays</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    (`choices`), `a` and each choice array are first broadcast, as necessary,</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    for each ``i``.  Then, a new array with shape ``Ba.shape`` is created as</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    follows:</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    * if ``mode=&#39;raise&#39;`` (the default), then, first of all, each element of</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">      ``a`` (and thus ``Ba``) must be in the range ``[0, n-1]``; now, suppose</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">      that ``i`` (in that range) is the value at the ``(j0, j1, ..., jm)``</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">      position in ``Ba`` - then the value at the same position in the new array</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">      is the value in ``Bchoices[i]`` at that same position;</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    * if ``mode=&#39;wrap&#39;``, values in `a` (and thus `Ba`) may be any (signed)</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">      integer; modular arithmetic is used to map integers outside the range</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">      `[0, n-1]` back into that range; and then the new array is constructed</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">      as above;</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    * if ``mode=&#39;clip&#39;``, values in `a` (and thus ``Ba``) may be any (signed)</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">      integer; negative integers are mapped to 0; values greater than ``n-1``</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">      are mapped to ``n-1``; and then the new array is constructed as above.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    a : int array</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">        This array must contain integers in ``[0, n-1]``, where ``n`` is the</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">        number of choices, unless ``mode=wrap`` or ``mode=clip``, in which</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        cases any integers are permissible.</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    choices : sequence of arrays</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        Choice arrays. `a` and all of the choices must be broadcastable to the</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">        same shape.  If `choices` is itself an array (not recommended), then</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        its outermost dimension (i.e., the one corresponding to</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">        ``choices.shape[0]``) is taken as defining the &quot;sequence&quot;.</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    out : array, optional</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        If provided, the result will be inserted into this array. It should</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        be of the appropriate shape and dtype. Note that `out` is always</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        buffered if ``mode=&#39;raise&#39;``; use other modes for better performance.</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    mode : {&#39;raise&#39; (default), &#39;wrap&#39;, &#39;clip&#39;}, optional</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">        Specifies how indices outside ``[0, n-1]`` will be treated:</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">          * &#39;raise&#39; : an exception is raised</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">          * &#39;wrap&#39; : value becomes value mod ``n``</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">          * &#39;clip&#39; : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    merged_array : array</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">        The merged result.</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    ValueError: shape mismatch</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">        If `a` and each choice array are not all broadcastable to the same</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        shape.</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    ndarray.choose : equivalent method</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    numpy.take_along_axis : Preferable if `choices` is an array</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    To reduce the chance of misinterpretation, even though the following</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    &quot;abuse&quot; is nominally supported, `choices` should neither be, nor be</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    thought of as, a single array, i.e., the outermost sequence-like container</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    should be either a list or a tuple.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    &gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13],</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    ...   [20, 21, 22, 23], [30, 31, 32, 33]]</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    &gt;&gt;&gt; np.choose([2, 3, 1, 0], choices</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    ... # the first element of the result will be the first element of the</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    ... # third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    ... # will be the second element of the fourth (3+1) choice array, i.e.,</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    ... # 31, etc.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    array([20, 31, 12,  3])</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    &gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode=&#39;clip&#39;) # 4 goes to 3 (4-1)</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    array([20, 31, 12,  3])</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    &gt;&gt;&gt; # because there are 4 choice arrays</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    &gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode=&#39;wrap&#39;) # 4 goes to (4 mod 4)</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    array([20,  1, 12,  3])</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    &gt;&gt;&gt; # i.e., 0</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    A couple examples illustrating how choose broadcasts:</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    &gt;&gt;&gt; a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    &gt;&gt;&gt; choices = [-10, 10]</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    &gt;&gt;&gt; np.choose(a, choices)</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    array([[ 10, -10,  10],</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">           [-10,  10, -10],</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">           [ 10, -10,  10]])</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    &gt;&gt;&gt; # With thanks to Anne Archibald</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([0, 1]).reshape((2,1,1))</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    &gt;&gt;&gt; c1 = np.array([1, 2, 3]).reshape((1,3,1))</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    &gt;&gt;&gt; np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    array([[[ 1,  1,  1,  1,  1],</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">            [ 2,  2,  2,  2,  2],</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">            [ 3,  3,  3,  3,  3]],</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">           [[-1, -2, -3, -4, -5],</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">            [-1, -2, -3, -4, -5],</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">            [-1, -2, -3, -4, -5]]])</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  429</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;choose&#39;</span>, choices, out=out, mode=mode)</div>
<div class="line"><span class="lineno">  430</span> </div>
<div class="line"><span class="lineno">  431</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0ebc234ab70db66e59afbea0ef6d4d2" name="ac0ebc234ab70db66e59afbea0ef6d4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ebc234ab70db66e59afbea0ef6d4d2">&#9670;&#160;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.clip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clip (limit) the values in an array.

Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of ``[0, 1]``
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.

Equivalent to but faster than ``np.minimum(a_max, np.maximum(a, a_min))``.

No check is performed to ensure ``a_min &lt; a_max``.

Parameters
----------
a : array_like
    Array containing elements to clip.
a_min, a_max : array_like or None
    Minimum and maximum value. If ``None``, clipping is not performed on
    the corresponding edge. Only one of `a_min` and `a_max` may be
    ``None``. Both are broadcast against `a`.
out : ndarray, optional
    The results will be placed in this array. It may be the input
    array for in-place clipping.  `out` must be of the right shape
    to hold the output.  Its type is preserved.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.

    .. versionadded:: 1.17.0

Returns
-------
clipped_array : ndarray
    An array with the elements of `a`, but where values
    &lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`
    with `a_max`.

See Also
--------
:ref:`ufuncs-output-type`

Notes
-----
When `a_min` is greater than `a_max`, `clip` returns an
array in which all values are equal to `a_max`,
as shown in the second example.

Examples
--------
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
&gt;&gt;&gt; np.clip(a, 8, 1)
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
&gt;&gt;&gt; np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
&gt;&gt;&gt; a
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</pre> <div class="fragment"><div class="line"><span class="lineno"> 2112</span><span class="keyword">def </span>clip(a, a_min, a_max, out=None, **kwargs):</div>
<div class="line"><span class="lineno"> 2113</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">    Clip (limit) the values in an array.</span></div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral">    Given an interval, values outside the interval are clipped to</span></div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">    the interval edges.  For example, if an interval of ``[0, 1]``</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">    is specified, values smaller than 0 become 0, and values larger</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral">    than 1 become 1.</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">    Equivalent to but faster than ``np.minimum(a_max, np.maximum(a, a_min))``.</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">    No check is performed to ensure ``a_min &lt; a_max``.</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral">        Array containing elements to clip.</span></div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">    a_min, a_max : array_like or None</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral">        Minimum and maximum value. If ``None``, clipping is not performed on</span></div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral">        the corresponding edge. Only one of `a_min` and `a_max` may be</span></div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral">        ``None``. Both are broadcast against `a`.</span></div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral">        The results will be placed in this array. It may be the input</span></div>
<div class="line"><span class="lineno"> 2135</span><span class="stringliteral">        array for in-place clipping.  `out` must be of the right shape</span></div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral">        to hold the output.  Its type is preserved.</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral">    **kwargs</span></div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral">        For other keyword-only arguments, see the</span></div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 2142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2143</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2144</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2145</span><span class="stringliteral">    clipped_array : ndarray</span></div>
<div class="line"><span class="lineno"> 2146</span><span class="stringliteral">        An array with the elements of `a`, but where values</span></div>
<div class="line"><span class="lineno"> 2147</span><span class="stringliteral">        &lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`</span></div>
<div class="line"><span class="lineno"> 2148</span><span class="stringliteral">        with `a_max`.</span></div>
<div class="line"><span class="lineno"> 2149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2150</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2151</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2152</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 2153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2154</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2155</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2156</span><span class="stringliteral">    When `a_min` is greater than `a_max`, `clip` returns an</span></div>
<div class="line"><span class="lineno"> 2157</span><span class="stringliteral">    array in which all values are equal to `a_max`,</span></div>
<div class="line"><span class="lineno"> 2158</span><span class="stringliteral">    as shown in the second example.</span></div>
<div class="line"><span class="lineno"> 2159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2160</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(10)</span></div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral">    &gt;&gt;&gt; np.clip(a, 1, 8)</span></div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">    &gt;&gt;&gt; np.clip(a, 8, 1)</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">    &gt;&gt;&gt; np.clip(a, 3, 6, out=a)</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral">    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span></div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral">    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(10)</span></div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">    &gt;&gt;&gt; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">    array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span></div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2180</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;clip&#39;</span>, a_min, a_max, out=out, **kwargs)</div>
<div class="line"><span class="lineno"> 2181</span> </div>
<div class="line"><span class="lineno"> 2182</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a98e05aec90fc741f3919465d12b01193" name="a98e05aec90fc741f3919465d12b01193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e05aec90fc741f3919465d12b01193">&#9670;&#160;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.compress </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return selected slices of an array along given axis.

When working along a given axis, a slice along that axis is returned in
`output` for each index where `condition` evaluates to True. When
working on a 1-D array, `compress` is equivalent to `extract`.

Parameters
----------
condition : 1-D array of bools
    Array that selects which entries to return. If len(condition)
    is less than the size of `a` along the given axis, then output is
    truncated to the length of the condition array.
a : array_like
    Array from which to extract a part.
axis : int, optional
    Axis along which to take slices. If None (default), work on the
    flattened array.
out : ndarray, optional
    Output array.  Its type is preserved and it must be of the right
    shape to hold the output.

Returns
-------
compressed_array : ndarray
    A copy of `a` without the slices along axis for which `condition`
    is false.

See Also
--------
take, choose, diag, diagonal, select
ndarray.compress : Equivalent method in ndarray
extract : Equivalent method when working on 1-D arrays
:ref:`ufuncs-output-type`

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])
&gt;&gt;&gt; a
array([[1, 2],
       [3, 4],
       [5, 6]])
&gt;&gt;&gt; np.compress([0, 1], a, axis=0)
array([[3, 4]])
&gt;&gt;&gt; np.compress([False, True, True], a, axis=0)
array([[3, 4],
       [5, 6]])
&gt;&gt;&gt; np.compress([False, True], a, axis=1)
array([[2],
       [4],
       [6]])

Working on the flattened array does not return slices along an axis but
selects elements.

&gt;&gt;&gt; np.compress([False, True], a)
array([2])</pre> <div class="fragment"><div class="line"><span class="lineno"> 2044</span><span class="keyword">def </span>compress(condition, a, axis=None, out=None):</div>
<div class="line"><span class="lineno"> 2045</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2046</span><span class="stringliteral">    Return selected slices of an array along given axis.</span></div>
<div class="line"><span class="lineno"> 2047</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2048</span><span class="stringliteral">    When working along a given axis, a slice along that axis is returned in</span></div>
<div class="line"><span class="lineno"> 2049</span><span class="stringliteral">    `output` for each index where `condition` evaluates to True. When</span></div>
<div class="line"><span class="lineno"> 2050</span><span class="stringliteral">    working on a 1-D array, `compress` is equivalent to `extract`.</span></div>
<div class="line"><span class="lineno"> 2051</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2052</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2053</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2054</span><span class="stringliteral">    condition : 1-D array of bools</span></div>
<div class="line"><span class="lineno"> 2055</span><span class="stringliteral">        Array that selects which entries to return. If len(condition)</span></div>
<div class="line"><span class="lineno"> 2056</span><span class="stringliteral">        is less than the size of `a` along the given axis, then output is</span></div>
<div class="line"><span class="lineno"> 2057</span><span class="stringliteral">        truncated to the length of the condition array.</span></div>
<div class="line"><span class="lineno"> 2058</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2059</span><span class="stringliteral">        Array from which to extract a part.</span></div>
<div class="line"><span class="lineno"> 2060</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 2061</span><span class="stringliteral">        Axis along which to take slices. If None (default), work on the</span></div>
<div class="line"><span class="lineno"> 2062</span><span class="stringliteral">        flattened array.</span></div>
<div class="line"><span class="lineno"> 2063</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2064</span><span class="stringliteral">        Output array.  Its type is preserved and it must be of the right</span></div>
<div class="line"><span class="lineno"> 2065</span><span class="stringliteral">        shape to hold the output.</span></div>
<div class="line"><span class="lineno"> 2066</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2067</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2068</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2069</span><span class="stringliteral">    compressed_array : ndarray</span></div>
<div class="line"><span class="lineno"> 2070</span><span class="stringliteral">        A copy of `a` without the slices along axis for which `condition`</span></div>
<div class="line"><span class="lineno"> 2071</span><span class="stringliteral">        is false.</span></div>
<div class="line"><span class="lineno"> 2072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2073</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2074</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2075</span><span class="stringliteral">    take, choose, diag, diagonal, select</span></div>
<div class="line"><span class="lineno"> 2076</span><span class="stringliteral">    ndarray.compress : Equivalent method in ndarray</span></div>
<div class="line"><span class="lineno"> 2077</span><span class="stringliteral">    extract : Equivalent method when working on 1-D arrays</span></div>
<div class="line"><span class="lineno"> 2078</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 2079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2080</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2081</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">    array([[1, 2],</span></div>
<div class="line"><span class="lineno"> 2085</span><span class="stringliteral">           [3, 4],</span></div>
<div class="line"><span class="lineno"> 2086</span><span class="stringliteral">           [5, 6]])</span></div>
<div class="line"><span class="lineno"> 2087</span><span class="stringliteral">    &gt;&gt;&gt; np.compress([0, 1], a, axis=0)</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral">    array([[3, 4]])</span></div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral">    &gt;&gt;&gt; np.compress([False, True, True], a, axis=0)</span></div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral">    array([[3, 4],</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">           [5, 6]])</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral">    &gt;&gt;&gt; np.compress([False, True], a, axis=1)</span></div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">    array([[2],</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">           [4],</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral">           [6]])</span></div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">    Working on the flattened array does not return slices along an axis but</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral">    selects elements.</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">    &gt;&gt;&gt; np.compress([False, True], a)</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">    array([2])</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2104</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;compress&#39;</span>, condition, axis=axis, out=out)</div>
<div class="line"><span class="lineno"> 2105</span> </div>
<div class="line"><span class="lineno"> 2106</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a687390f64a847f863a48906d95343c5f" name="a687390f64a847f863a48906d95343c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687390f64a847f863a48906d95343c5f">&#9670;&#160;</a></span>cumprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.cumprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cumulative product of elements along a given axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative product is computed.  By default
    the input is flattened.
dtype : dtype, optional
    Type of the returned array, as well as of the accumulator in which
    the elements are multiplied.  If *dtype* is not specified, it
    defaults to the dtype of `a`, unless `a` has an integer dtype with
    a precision less than that of the default platform integer.  In
    that case, the default platform integer is used instead.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type of the resulting values will be cast if necessary.

Returns
-------
cumprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case a reference to out is returned.

See Also
--------
:ref:`ufuncs-output-type`

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

Examples
--------
&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; np.cumprod(a) # intermediate results 1, 1*2
...               # total product 1*2*3 = 6
array([1, 2, 6])
&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; np.cumprod(a, dtype=float) # specify type of output
array([   1.,    2.,    6.,   24.,  120.,  720.])

The cumulative product for each column (i.e., over the rows) of `a`:

&gt;&gt;&gt; np.cumprod(a, axis=0)
array([[ 1,  2,  3],
       [ 4, 10, 18]])

The cumulative product for each row (i.e. over the columns) of `a`:

&gt;&gt;&gt; np.cumprod(a,axis=1)
array([[  1,   2,   6],
       [  4,  20, 120]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3085</span><span class="keyword">def </span>cumprod(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno"> 3086</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3087</span><span class="stringliteral">    Return the cumulative product of elements along a given axis.</span></div>
<div class="line"><span class="lineno"> 3088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3089</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3090</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3091</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3092</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 3093</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3094</span><span class="stringliteral">        Axis along which the cumulative product is computed.  By default</span></div>
<div class="line"><span class="lineno"> 3095</span><span class="stringliteral">        the input is flattened.</span></div>
<div class="line"><span class="lineno"> 3096</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 3097</span><span class="stringliteral">        Type of the returned array, as well as of the accumulator in which</span></div>
<div class="line"><span class="lineno"> 3098</span><span class="stringliteral">        the elements are multiplied.  If *dtype* is not specified, it</span></div>
<div class="line"><span class="lineno"> 3099</span><span class="stringliteral">        defaults to the dtype of `a`, unless `a` has an integer dtype with</span></div>
<div class="line"><span class="lineno"> 3100</span><span class="stringliteral">        a precision less than that of the default platform integer.  In</span></div>
<div class="line"><span class="lineno"> 3101</span><span class="stringliteral">        that case, the default platform integer is used instead.</span></div>
<div class="line"><span class="lineno"> 3102</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3103</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno"> 3104</span><span class="stringliteral">        have the same shape and buffer length as the expected output</span></div>
<div class="line"><span class="lineno"> 3105</span><span class="stringliteral">        but the type of the resulting values will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 3106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3107</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3108</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3109</span><span class="stringliteral">    cumprod : ndarray</span></div>
<div class="line"><span class="lineno"> 3110</span><span class="stringliteral">        A new array holding the result is returned unless `out` is</span></div>
<div class="line"><span class="lineno"> 3111</span><span class="stringliteral">        specified, in which case a reference to out is returned.</span></div>
<div class="line"><span class="lineno"> 3112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3113</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3114</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3115</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 3116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3117</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3118</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3119</span><span class="stringliteral">    Arithmetic is modular when using integer types, and no error is</span></div>
<div class="line"><span class="lineno"> 3120</span><span class="stringliteral">    raised on overflow.</span></div>
<div class="line"><span class="lineno"> 3121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3122</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3123</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3124</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1,2,3])</span></div>
<div class="line"><span class="lineno"> 3125</span><span class="stringliteral">    &gt;&gt;&gt; np.cumprod(a) # intermediate results 1, 1*2</span></div>
<div class="line"><span class="lineno"> 3126</span><span class="stringliteral">    ...               # total product 1*2*3 = 6</span></div>
<div class="line"><span class="lineno"> 3127</span><span class="stringliteral">    array([1, 2, 6])</span></div>
<div class="line"><span class="lineno"> 3128</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])</span></div>
<div class="line"><span class="lineno"> 3129</span><span class="stringliteral">    &gt;&gt;&gt; np.cumprod(a, dtype=float) # specify type of output</span></div>
<div class="line"><span class="lineno"> 3130</span><span class="stringliteral">    array([   1.,    2.,    6.,   24.,  120.,  720.])</span></div>
<div class="line"><span class="lineno"> 3131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3132</span><span class="stringliteral">    The cumulative product for each column (i.e., over the rows) of `a`:</span></div>
<div class="line"><span class="lineno"> 3133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3134</span><span class="stringliteral">    &gt;&gt;&gt; np.cumprod(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 3135</span><span class="stringliteral">    array([[ 1,  2,  3],</span></div>
<div class="line"><span class="lineno"> 3136</span><span class="stringliteral">           [ 4, 10, 18]])</span></div>
<div class="line"><span class="lineno"> 3137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3138</span><span class="stringliteral">    The cumulative product for each row (i.e. over the columns) of `a`:</span></div>
<div class="line"><span class="lineno"> 3139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral">    &gt;&gt;&gt; np.cumprod(a,axis=1)</span></div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral">    array([[  1,   2,   6],</span></div>
<div class="line"><span class="lineno"> 3142</span><span class="stringliteral">           [  4,  20, 120]])</span></div>
<div class="line"><span class="lineno"> 3143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3144</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3145</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;cumprod&#39;</span>, axis=axis, dtype=dtype, out=out)</div>
<div class="line"><span class="lineno"> 3146</span> </div>
<div class="line"><span class="lineno"> 3147</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a487c2694c08de00857dee37c272fd0a1" name="a487c2694c08de00857dee37c272fd0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487c2694c08de00857dee37c272fd0a1">&#9670;&#160;</a></span>cumproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.cumproduct </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cumulative product over the given axis.

See Also
--------
cumprod : equivalent function; see for details.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3779</span><span class="keyword">def </span>cumproduct(*args, **kwargs):</div>
<div class="line"><span class="lineno"> 3780</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3781</span><span class="stringliteral">    Return the cumulative product over the given axis.</span></div>
<div class="line"><span class="lineno"> 3782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3783</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3784</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3785</span><span class="stringliteral">    cumprod : equivalent function; see for details.</span></div>
<div class="line"><span class="lineno"> 3786</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3787</span>    <span class="keywordflow">return</span> cumprod(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 3788</span> </div>
<div class="line"><span class="lineno"> 3789</span> </div>
<div class="line"><span class="lineno"> 3790</span><span class="preprocessor">@array_function_dispatch(_any_dispatcher, verify=False)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae93104c5560c57709d7afe73edefff1f" name="ae93104c5560c57709d7afe73edefff1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93104c5560c57709d7afe73edefff1f">&#9670;&#160;</a></span>cumsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.cumsum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cumulative sum of the elements along a given axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative sum is computed. The default
    (None) is to compute the cumsum over the flattened array.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed.  If `dtype` is not specified, it defaults
    to the dtype of `a`, unless `a` has an integer dtype with a
    precision less than that of the default platform integer.  In
    that case, the default platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary. See :ref:`ufuncs-output-type` for
    more details.

Returns
-------
cumsum_along_axis : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which case a reference to `out` is returned. The
    result has the same size as `a`, and the same shape as `a` if
    `axis` is not None or `a` is a 1-d array.

See Also
--------
sum : Sum array elements.
trapz : Integration of array values using the composite trapezoidal rule.
diff : Calculate the n-th discrete difference along given axis.

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

``cumsum(a)[-1]`` may not be equal to ``sum(a)`` for floating-point
values since ``sum`` may use a pairwise summation routine, reducing
the roundoff-error. See `sum` for more information.

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.cumsum(a)
array([ 1,  3,  6, 10, 15, 21])
&gt;&gt;&gt; np.cumsum(a, dtype=float)     # specifies type of output value(s)
array([  1.,   3.,   6.,  10.,  15.,  21.])

&gt;&gt;&gt; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
array([[1, 2, 3],
       [5, 7, 9]])
&gt;&gt;&gt; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
array([[ 1,  3,  6],
       [ 4,  9, 15]])

``cumsum(b)[-1]`` may not be equal to ``sum(b)``

&gt;&gt;&gt; b = np.array([1, 2e-9, 3e-9] * 1000000)
&gt;&gt;&gt; b.cumsum()[-1]
1000000.0050045159
&gt;&gt;&gt; b.sum()
1000000.0050000029</pre> <div class="fragment"><div class="line"><span class="lineno"> 2524</span><span class="keyword">def </span>cumsum(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno"> 2525</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral">    Return the cumulative sum of the elements along a given axis.</span></div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">        Axis along which the cumulative sum is computed. The default</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">        (None) is to compute the cumsum over the flattened array.</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 2536</span><span class="stringliteral">        Type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno"> 2537</span><span class="stringliteral">        elements are summed.  If `dtype` is not specified, it defaults</span></div>
<div class="line"><span class="lineno"> 2538</span><span class="stringliteral">        to the dtype of `a`, unless `a` has an integer dtype with a</span></div>
<div class="line"><span class="lineno"> 2539</span><span class="stringliteral">        precision less than that of the default platform integer.  In</span></div>
<div class="line"><span class="lineno"> 2540</span><span class="stringliteral">        that case, the default platform integer is used.</span></div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral">        have the same shape and buffer length as the expected output</span></div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">        but the type will be cast if necessary. See :ref:`ufuncs-output-type` for</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral">        more details.</span></div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral">    cumsum_along_axis : ndarray.</span></div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral">        A new array holding the result is returned unless `out` is</span></div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral">        specified, in which case a reference to `out` is returned. The</span></div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral">        result has the same size as `a`, and the same shape as `a` if</span></div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral">        `axis` is not None or `a` is a 1-d array.</span></div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2555</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2556</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2557</span><span class="stringliteral">    sum : Sum array elements.</span></div>
<div class="line"><span class="lineno"> 2558</span><span class="stringliteral">    trapz : Integration of array values using the composite trapezoidal rule.</span></div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral">    diff : Calculate the n-th discrete difference along given axis.</span></div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">    Arithmetic is modular when using integer types, and no error is</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">    raised on overflow.</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">    ``cumsum(a)[-1]`` may not be equal to ``sum(a)`` for floating-point</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">    values since ``sum`` may use a pairwise summation routine, reducing</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral">    the roundoff-error. See `sum` for more information.</span></div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])</span></div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral">           [4, 5, 6]])</span></div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral">    &gt;&gt;&gt; np.cumsum(a)</span></div>
<div class="line"><span class="lineno"> 2577</span><span class="stringliteral">    array([ 1,  3,  6, 10, 15, 21])</span></div>
<div class="line"><span class="lineno"> 2578</span><span class="stringliteral">    &gt;&gt;&gt; np.cumsum(a, dtype=float)     # specifies type of output value(s)</span></div>
<div class="line"><span class="lineno"> 2579</span><span class="stringliteral">    array([  1.,   3.,   6.,  10.,  15.,  21.])</span></div>
<div class="line"><span class="lineno"> 2580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2581</span><span class="stringliteral">    &gt;&gt;&gt; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns</span></div>
<div class="line"><span class="lineno"> 2582</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno"> 2583</span><span class="stringliteral">           [5, 7, 9]])</span></div>
<div class="line"><span class="lineno"> 2584</span><span class="stringliteral">    &gt;&gt;&gt; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows</span></div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral">    array([[ 1,  3,  6],</span></div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral">           [ 4,  9, 15]])</span></div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral">    ``cumsum(b)[-1]`` may not be equal to ``sum(b)``</span></div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 2e-9, 3e-9] * 1000000)</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral">    &gt;&gt;&gt; b.cumsum()[-1]</span></div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral">    1000000.0050045159</span></div>
<div class="line"><span class="lineno"> 2593</span><span class="stringliteral">    &gt;&gt;&gt; b.sum()</span></div>
<div class="line"><span class="lineno"> 2594</span><span class="stringliteral">    1000000.0050000029</span></div>
<div class="line"><span class="lineno"> 2595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2596</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2597</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;cumsum&#39;</span>, axis=axis, dtype=dtype, out=out)</div>
<div class="line"><span class="lineno"> 2598</span> </div>
<div class="line"><span class="lineno"> 2599</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ac85288109e6be95d222f77f560f78e" name="a0ac85288109e6be95d222f77f560f78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac85288109e6be95d222f77f560f78e">&#9670;&#160;</a></span>diagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.diagonal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return specified diagonals.

If `a` is 2-D, returns the diagonal of `a` with the given offset,
i.e., the collection of elements of the form ``a[i, i+offset]``.  If
`a` has more than two dimensions, then the axes specified by `axis1`
and `axis2` are used to determine the 2-D sub-array whose diagonal is
returned.  The shape of the resulting array can be determined by
removing `axis1` and `axis2` and appending an index to the right equal
to the size of the resulting diagonals.

In versions of NumPy prior to 1.7, this function always returned a new,
independent array containing a copy of the values in the diagonal.

In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
but depending on this fact is deprecated. Writing to the resulting
array continues to work as it used to, but a FutureWarning is issued.

Starting in NumPy 1.9 it returns a read-only view on the original array.
Attempting to write to the resulting array will produce an error.

In some future release, it will return a read/write view and writing to
the returned array will alter your original array.  The returned array
will have the same type as the input array.

If you don't write to the array returned by this function, then you can
just ignore all of the above.

If you depend on the current behavior, then we suggest copying the
returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead
of just ``np.diagonal(a)``. This will work with both past and future
versions of NumPy.

Parameters
----------
a : array_like
    Array from which the diagonals are taken.
offset : int, optional
    Offset of the diagonal from the main diagonal.  Can be positive or
    negative.  Defaults to main diagonal (0).
axis1 : int, optional
    Axis to be used as the first axis of the 2-D sub-arrays from which
    the diagonals should be taken.  Defaults to first axis (0).
axis2 : int, optional
    Axis to be used as the second axis of the 2-D sub-arrays from
    which the diagonals should be taken. Defaults to second axis (1).

Returns
-------
array_of_diagonals : ndarray
    If `a` is 2-D, then a 1-D array containing the diagonal and of the
    same type as `a` is returned unless `a` is a `matrix`, in which case
    a 1-D array rather than a (2-D) `matrix` is returned in order to
    maintain backward compatibility.

    If ``a.ndim &gt; 2``, then the dimensions specified by `axis1` and `axis2`
    are removed, and a new axis inserted at the end corresponding to the
    diagonal.

Raises
------
ValueError
    If the dimension of `a` is less than 2.

See Also
--------
diag : MATLAB work-a-like for 1-D and 2-D arrays.
diagflat : Create diagonal arrays.
trace : Sum along diagonals.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape(2,2)
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; a.diagonal()
array([0, 3])
&gt;&gt;&gt; a.diagonal(1)
array([1])

A 3-D example:

&gt;&gt;&gt; a = np.arange(8).reshape(2,2,2); a
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
&gt;&gt;&gt; a.diagonal(0,  # Main diagonals of two arrays created by skipping
...            0,  # across the outer(left)-most axis last and
...            1)  # the "middle" (row) axis first.
array([[0, 6],
       [1, 7]])

The sub-arrays whose main diagonals we just obtained; note that each
corresponds to fixing the right-most (column) axis, and that the
diagonals are "packed" in rows.

&gt;&gt;&gt; a[:,:,0]  # main diagonal is [0 6]
array([[0, 2],
       [4, 6]])
&gt;&gt;&gt; a[:,:,1]  # main diagonal is [1 7]
array([[1, 3],
       [5, 7]])

The anti-diagonal can be obtained by reversing the order of elements
using either `numpy.flipud` or `numpy.fliplr`.

&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)
&gt;&gt;&gt; a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; np.fliplr(a).diagonal()  # Horizontal flip
array([2, 4, 6])
&gt;&gt;&gt; np.flipud(a).diagonal()  # Vertical flip
array([6, 4, 2])

Note that the order in which the diagonal is retrieved varies depending
on the flip function.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1579</span><span class="keyword">def </span>diagonal(a, offset=0, axis1=0, axis2=1):</div>
<div class="line"><span class="lineno"> 1580</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">    Return specified diagonals.</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">    If `a` is 2-D, returns the diagonal of `a` with the given offset,</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    i.e., the collection of elements of the form ``a[i, i+offset]``.  If</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    `a` has more than two dimensions, then the axes specified by `axis1`</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">    and `axis2` are used to determine the 2-D sub-array whose diagonal is</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    returned.  The shape of the resulting array can be determined by</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    removing `axis1` and `axis2` and appending an index to the right equal</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    to the size of the resulting diagonals.</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    In versions of NumPy prior to 1.7, this function always returned a new,</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    independent array containing a copy of the values in the diagonal.</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    but depending on this fact is deprecated. Writing to the resulting</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    array continues to work as it used to, but a FutureWarning is issued.</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">    Starting in NumPy 1.9 it returns a read-only view on the original array.</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    Attempting to write to the resulting array will produce an error.</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    In some future release, it will return a read/write view and writing to</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    the returned array will alter your original array.  The returned array</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">    will have the same type as the input array.</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">    If you don&#39;t write to the array returned by this function, then you can</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">    just ignore all of the above.</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    If you depend on the current behavior, then we suggest copying the</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">    of just ``np.diagonal(a)``. This will work with both past and future</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">    versions of NumPy.</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        Array from which the diagonals are taken.</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">    offset : int, optional</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">        Offset of the diagonal from the main diagonal.  Can be positive or</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">        negative.  Defaults to main diagonal (0).</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">    axis1 : int, optional</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">        Axis to be used as the first axis of the 2-D sub-arrays from which</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">        the diagonals should be taken.  Defaults to first axis (0).</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    axis2 : int, optional</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">        Axis to be used as the second axis of the 2-D sub-arrays from</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">        which the diagonals should be taken. Defaults to second axis (1).</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    array_of_diagonals : ndarray</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">        If `a` is 2-D, then a 1-D array containing the diagonal and of the</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">        same type as `a` is returned unless `a` is a `matrix`, in which case</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">        a 1-D array rather than a (2-D) `matrix` is returned in order to</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">        maintain backward compatibility.</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">        If ``a.ndim &gt; 2``, then the dimensions specified by `axis1` and `axis2`</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">        are removed, and a new axis inserted at the end corresponding to the</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">        diagonal.</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">        If the dimension of `a` is less than 2.</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">    diag : MATLAB work-a-like for 1-D and 2-D arrays.</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">    diagflat : Create diagonal arrays.</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">    trace : Sum along diagonals.</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(4).reshape(2,2)</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">           [2, 3]])</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">    &gt;&gt;&gt; a.diagonal()</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">    array([0, 3])</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">    &gt;&gt;&gt; a.diagonal(1)</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">    array([1])</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">    A 3-D example:</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(8).reshape(2,2,2); a</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">    array([[[0, 1],</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">            [2, 3]],</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">           [[4, 5],</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">            [6, 7]]])</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    &gt;&gt;&gt; a.diagonal(0,  # Main diagonals of two arrays created by skipping</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    ...            0,  # across the outer(left)-most axis last and</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">    ...            1)  # the &quot;middle&quot; (row) axis first.</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    array([[0, 6],</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">           [1, 7]])</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">    The sub-arrays whose main diagonals we just obtained; note that each</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">    corresponds to fixing the right-most (column) axis, and that the</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    diagonals are &quot;packed&quot; in rows.</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    &gt;&gt;&gt; a[:,:,0]  # main diagonal is [0 6]</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">    array([[0, 2],</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">           [4, 6]])</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    &gt;&gt;&gt; a[:,:,1]  # main diagonal is [1 7]</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">    array([[1, 3],</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">           [5, 7]])</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">    The anti-diagonal can be obtained by reversing the order of elements</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">    using either `numpy.flipud` or `numpy.fliplr`.</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(9).reshape(3, 3)</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">           [3, 4, 5],</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">           [6, 7, 8]])</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">    &gt;&gt;&gt; np.fliplr(a).diagonal()  # Horizontal flip</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">    array([2, 4, 6])</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    &gt;&gt;&gt; np.flipud(a).diagonal()  # Vertical flip</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    array([6, 4, 2])</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">    Note that the order in which the diagonal is retrieved varies depending</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">    on the flip function.</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1701</span>    <span class="keywordflow">if</span> isinstance(a, np.matrix):</div>
<div class="line"><span class="lineno"> 1702</span>        <span class="comment"># Make diagonal of matrix 1-D to preserve backward compatibility.</span></div>
<div class="line"><span class="lineno"> 1703</span>        <span class="keywordflow">return</span> asarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)</div>
<div class="line"><span class="lineno"> 1704</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1705</span>        <span class="keywordflow">return</span> asanyarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)</div>
<div class="line"><span class="lineno"> 1706</span> </div>
<div class="line"><span class="lineno"> 1707</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a835aa0a6c668cb6abef119df90098029" name="a835aa0a6c668cb6abef119df90098029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835aa0a6c668cb6abef119df90098029">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the arithmetic mean along the specified axis.

Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
`float64` intermediate and return values are used for integer inputs.

Parameters
----------
a : array_like
    Array containing numbers whose mean is desired. If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the means are computed. The default is to
    compute the mean of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a mean is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the mean.  For integer inputs, the default
    is `float64`; for floating point inputs, it is the same as the
    input dtype.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.
    See :ref:`ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `mean` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

where : array_like of bool, optional
    Elements to include in the mean. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.20.0

Returns
-------
m : ndarray, see dtype parameter above
    If `out=None`, returns a new array containing the mean values,
    otherwise a reference to the output array is returned.

See Also
--------
average : Weighted average
std, var, nanmean, nanstd, nanvar

Notes
-----
The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.

Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for `float32` (see
example below).  Specifying a higher-precision accumulator using the
`dtype` keyword can alleviate this issue.

By default, `float16` results are computed using `float32` intermediates
for extra precision.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.mean(a)
2.5
&gt;&gt;&gt; np.mean(a, axis=0)
array([2., 3.])
&gt;&gt;&gt; np.mean(a, axis=1)
array([1.5, 3.5])

In single precision, `mean` can be inaccurate:

&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)
&gt;&gt;&gt; a[0, :] = 1.0
&gt;&gt;&gt; a[1, :] = 0.1
&gt;&gt;&gt; np.mean(a)
0.54999924

Computing the mean in float64 is more accurate:

&gt;&gt;&gt; np.mean(a, dtype=np.float64)
0.55000000074505806 # may vary

Specifying a where argument:

&gt;&gt;&gt; a = np.array([[5, 9, 13], [14, 10, 12], [11, 15, 19]])
&gt;&gt;&gt; np.mean(a)
12.0
&gt;&gt;&gt; np.mean(a, where=[[True], [False], [False]])
9.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 3347</span>         where=np._NoValue):</div>
<div class="line"><span class="lineno"> 3348</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3349</span><span class="stringliteral">    Compute the arithmetic mean along the specified axis.</span></div>
<div class="line"><span class="lineno"> 3350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3351</span><span class="stringliteral">    Returns the average of the array elements.  The average is taken over</span></div>
<div class="line"><span class="lineno"> 3352</span><span class="stringliteral">    the flattened array by default, otherwise over the specified axis.</span></div>
<div class="line"><span class="lineno"> 3353</span><span class="stringliteral">    `float64` intermediate and return values are used for integer inputs.</span></div>
<div class="line"><span class="lineno"> 3354</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3355</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3356</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3357</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3358</span><span class="stringliteral">        Array containing numbers whose mean is desired. If `a` is not an</span></div>
<div class="line"><span class="lineno"> 3359</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno"> 3360</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 3361</span><span class="stringliteral">        Axis or axes along which the means are computed. The default is to</span></div>
<div class="line"><span class="lineno"> 3362</span><span class="stringliteral">        compute the mean of the flattened array.</span></div>
<div class="line"><span class="lineno"> 3363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3364</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 3365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3366</span><span class="stringliteral">        If this is a tuple of ints, a mean is performed over multiple axes,</span></div>
<div class="line"><span class="lineno"> 3367</span><span class="stringliteral">        instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 3368</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno"> 3369</span><span class="stringliteral">        Type to use in computing the mean.  For integer inputs, the default</span></div>
<div class="line"><span class="lineno"> 3370</span><span class="stringliteral">        is `float64`; for floating point inputs, it is the same as the</span></div>
<div class="line"><span class="lineno"> 3371</span><span class="stringliteral">        input dtype.</span></div>
<div class="line"><span class="lineno"> 3372</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3373</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno"> 3374</span><span class="stringliteral">        is ``None``; if provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno"> 3375</span><span class="stringliteral">        expected output, but the type will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 3376</span><span class="stringliteral">        See :ref:`ufuncs-output-type` for more details.</span></div>
<div class="line"><span class="lineno"> 3377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3378</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 3379</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 3380</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 3381</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 3382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3383</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 3384</span><span class="stringliteral">        passed through to the `mean` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 3385</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 3386</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 3387</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 3388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3389</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 3390</span><span class="stringliteral">        Elements to include in the mean. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 3391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3392</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno"> 3393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3394</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3395</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3396</span><span class="stringliteral">    m : ndarray, see dtype parameter above</span></div>
<div class="line"><span class="lineno"> 3397</span><span class="stringliteral">        If `out=None`, returns a new array containing the mean values,</span></div>
<div class="line"><span class="lineno"> 3398</span><span class="stringliteral">        otherwise a reference to the output array is returned.</span></div>
<div class="line"><span class="lineno"> 3399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3400</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3401</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3402</span><span class="stringliteral">    average : Weighted average</span></div>
<div class="line"><span class="lineno"> 3403</span><span class="stringliteral">    std, var, nanmean, nanstd, nanvar</span></div>
<div class="line"><span class="lineno"> 3404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3405</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3406</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3407</span><span class="stringliteral">    The arithmetic mean is the sum of the elements along the axis divided</span></div>
<div class="line"><span class="lineno"> 3408</span><span class="stringliteral">    by the number of elements.</span></div>
<div class="line"><span class="lineno"> 3409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3410</span><span class="stringliteral">    Note that for floating-point input, the mean is computed using the</span></div>
<div class="line"><span class="lineno"> 3411</span><span class="stringliteral">    same precision the input has.  Depending on the input data, this can</span></div>
<div class="line"><span class="lineno"> 3412</span><span class="stringliteral">    cause the results to be inaccurate, especially for `float32` (see</span></div>
<div class="line"><span class="lineno"> 3413</span><span class="stringliteral">    example below).  Specifying a higher-precision accumulator using the</span></div>
<div class="line"><span class="lineno"> 3414</span><span class="stringliteral">    `dtype` keyword can alleviate this issue.</span></div>
<div class="line"><span class="lineno"> 3415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3416</span><span class="stringliteral">    By default, `float16` results are computed using `float32` intermediates</span></div>
<div class="line"><span class="lineno"> 3417</span><span class="stringliteral">    for extra precision.</span></div>
<div class="line"><span class="lineno"> 3418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3419</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3420</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3421</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 3422</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(a)</span></div>
<div class="line"><span class="lineno"> 3423</span><span class="stringliteral">    2.5</span></div>
<div class="line"><span class="lineno"> 3424</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 3425</span><span class="stringliteral">    array([2., 3.])</span></div>
<div class="line"><span class="lineno"> 3426</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 3427</span><span class="stringliteral">    array([1.5, 3.5])</span></div>
<div class="line"><span class="lineno"> 3428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3429</span><span class="stringliteral">    In single precision, `mean` can be inaccurate:</span></div>
<div class="line"><span class="lineno"> 3430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3431</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)</span></div>
<div class="line"><span class="lineno"> 3432</span><span class="stringliteral">    &gt;&gt;&gt; a[0, :] = 1.0</span></div>
<div class="line"><span class="lineno"> 3433</span><span class="stringliteral">    &gt;&gt;&gt; a[1, :] = 0.1</span></div>
<div class="line"><span class="lineno"> 3434</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(a)</span></div>
<div class="line"><span class="lineno"> 3435</span><span class="stringliteral">    0.54999924</span></div>
<div class="line"><span class="lineno"> 3436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3437</span><span class="stringliteral">    Computing the mean in float64 is more accurate:</span></div>
<div class="line"><span class="lineno"> 3438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3439</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(a, dtype=np.float64)</span></div>
<div class="line"><span class="lineno"> 3440</span><span class="stringliteral">    0.55000000074505806 # may vary</span></div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral">    Specifying a where argument:</span></div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[5, 9, 13], [14, 10, 12], [11, 15, 19]])</span></div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(a)</span></div>
<div class="line"><span class="lineno"> 3446</span><span class="stringliteral">    12.0</span></div>
<div class="line"><span class="lineno"> 3447</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(a, where=[[True], [False], [False]])</span></div>
<div class="line"><span class="lineno"> 3448</span><span class="stringliteral">    9.0</span></div>
<div class="line"><span class="lineno"> 3449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3450</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3451</span>    kwargs = {}</div>
<div class="line"><span class="lineno"> 3452</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 3453</span>        kwargs[<span class="stringliteral">&#39;keepdims&#39;</span>] = keepdims</div>
<div class="line"><span class="lineno"> 3454</span>    <span class="keywordflow">if</span> where <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 3455</span>        kwargs[<span class="stringliteral">&#39;where&#39;</span>] = where</div>
<div class="line"><span class="lineno"> 3456</span>    <span class="keywordflow">if</span> type(a) <span class="keywordflow">is</span> <span class="keywordflow">not</span> mu.ndarray:</div>
<div class="line"><span class="lineno"> 3457</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3458</span>            mean = a.mean</div>
<div class="line"><span class="lineno"> 3459</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 3460</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 3461</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3462</span>            <span class="keywordflow">return</span> mean(axis=axis, dtype=dtype, out=out, **kwargs)</div>
<div class="line"><span class="lineno"> 3463</span> </div>
<div class="line"><span class="lineno"> 3464</span>    <span class="keywordflow">return</span> _methods._mean(a, axis=axis, dtype=dtype,</div>
<div class="line"><span class="lineno"> 3465</span>                          out=out, **kwargs)</div>
<div class="line"><span class="lineno"> 3466</span> </div>
<div class="line"><span class="lineno"> 3467</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9dfc7f1d399bd7dbdd89ecb52594e20d" name="a9dfc7f1d399bd7dbdd89ecb52594e20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfc7f1d399bd7dbdd89ecb52594e20d">&#9670;&#160;</a></span>ndim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.ndim </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of dimensions of an array.

Parameters
----------
a : array_like
    Input array.  If it is not already an ndarray, a conversion is
    attempted.

Returns
-------
number_of_dimensions : int
    The number of dimensions in `a`.  Scalars are zero-dimensional.

See Also
--------
ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array

Examples
--------
&gt;&gt;&gt; np.ndim([[1,2,3],[4,5,6]])
2
&gt;&gt;&gt; np.ndim(np.array([[1,2,3],[4,5,6]]))
2
&gt;&gt;&gt; np.ndim(1)
0</pre> <div class="fragment"><div class="line"><span class="lineno"> 3153</span><span class="keyword">def </span>ndim(a):</div>
<div class="line"><span class="lineno"> 3154</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3155</span><span class="stringliteral">    Return the number of dimensions of an array.</span></div>
<div class="line"><span class="lineno"> 3156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3157</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3158</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3159</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3160</span><span class="stringliteral">        Input array.  If it is not already an ndarray, a conversion is</span></div>
<div class="line"><span class="lineno"> 3161</span><span class="stringliteral">        attempted.</span></div>
<div class="line"><span class="lineno"> 3162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3163</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3164</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3165</span><span class="stringliteral">    number_of_dimensions : int</span></div>
<div class="line"><span class="lineno"> 3166</span><span class="stringliteral">        The number of dimensions in `a`.  Scalars are zero-dimensional.</span></div>
<div class="line"><span class="lineno"> 3167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3168</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3169</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3170</span><span class="stringliteral">    ndarray.ndim : equivalent method</span></div>
<div class="line"><span class="lineno"> 3171</span><span class="stringliteral">    shape : dimensions of array</span></div>
<div class="line"><span class="lineno"> 3172</span><span class="stringliteral">    ndarray.shape : dimensions of array</span></div>
<div class="line"><span class="lineno"> 3173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3174</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3175</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3176</span><span class="stringliteral">    &gt;&gt;&gt; np.ndim([[1,2,3],[4,5,6]])</span></div>
<div class="line"><span class="lineno"> 3177</span><span class="stringliteral">    2</span></div>
<div class="line"><span class="lineno"> 3178</span><span class="stringliteral">    &gt;&gt;&gt; np.ndim(np.array([[1,2,3],[4,5,6]]))</span></div>
<div class="line"><span class="lineno"> 3179</span><span class="stringliteral">    2</span></div>
<div class="line"><span class="lineno"> 3180</span><span class="stringliteral">    &gt;&gt;&gt; np.ndim(1)</span></div>
<div class="line"><span class="lineno"> 3181</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno"> 3182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3183</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3184</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3185</span>        <span class="keywordflow">return</span> a.ndim</div>
<div class="line"><span class="lineno"> 3186</span>    <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 3187</span>        <span class="keywordflow">return</span> asarray(a).ndim</div>
<div class="line"><span class="lineno"> 3188</span> </div>
<div class="line"><span class="lineno"> 3189</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3462a97857a2f1b5199803686152858e" name="a3462a97857a2f1b5199803686152858e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3462a97857a2f1b5199803686152858e">&#9670;&#160;</a></span>nonzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.nonzero </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices of the elements that are non-zero.

Returns a tuple of arrays, one for each dimension of `a`,
containing the indices of the non-zero elements in that
dimension. The values in `a` are always tested and returned in
row-major, C-style order.

To group the indices by element, rather than dimension, use `argwhere`,
which returns a row for each non-zero element.

.. note::

   When called on a zero-d array or scalar, ``nonzero(a)`` is treated
   as ``nonzero(atleast_1d(a))``.

   .. deprecated:: 1.17.0

      Use `atleast_1d` explicitly if this behavior is deliberate.

Parameters
----------
a : array_like
    Input array.

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Notes
-----
While the nonzero values can be obtained with ``a[nonzero(a)]``, it is
recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which
will correctly handle 0-d arrays.

Examples
--------
&gt;&gt;&gt; x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
&gt;&gt;&gt; x
array([[3, 0, 0],
       [0, 4, 0],
       [5, 6, 0]])
&gt;&gt;&gt; np.nonzero(x)
(array([0, 1, 2, 2]), array([0, 1, 0, 1]))

&gt;&gt;&gt; x[np.nonzero(x)]
array([3, 4, 5, 6])
&gt;&gt;&gt; np.transpose(np.nonzero(x))
array([[0, 0],
       [1, 1],
       [2, 0],
       [2, 1]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the `a` where the condition is true.

&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; a &gt; 3
array([[False, False, False],
       [ True,  True,  True],
       [ True,  True,  True]])
&gt;&gt;&gt; np.nonzero(a &gt; 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

Using this result to index `a` is equivalent to using the mask directly:

&gt;&gt;&gt; a[np.nonzero(a &gt; 3)]
array([4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; a[a &gt; 3]  # prefer this spelling
array([4, 5, 6, 7, 8, 9])

``nonzero`` can also be called as a method of the array.

&gt;&gt;&gt; (a &gt; 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</pre> <div class="fragment"><div class="line"><span class="lineno"> 1893</span><span class="keyword">def </span>nonzero(a):</div>
<div class="line"><span class="lineno"> 1894</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    Return the indices of the elements that are non-zero.</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    Returns a tuple of arrays, one for each dimension of `a`,</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">    containing the indices of the non-zero elements in that</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">    dimension. The values in `a` are always tested and returned in</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    row-major, C-style order.</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">    To group the indices by element, rather than dimension, use `argwhere`,</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">    which returns a row for each non-zero element.</span></div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral">    .. note::</span></div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">       When called on a zero-d array or scalar, ``nonzero(a)`` is treated</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">       as ``nonzero(atleast_1d(a))``.</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">       .. deprecated:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">          Use `atleast_1d` explicitly if this behavior is deliberate.</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">    tuple_of_arrays : tuple</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral">        Indices of elements that are non-zero.</span></div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">    flatnonzero :</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral">        Return indices that are non-zero in the flattened version of the input</span></div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">        array.</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral">    ndarray.nonzero :</span></div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral">        Equivalent ndarray method.</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">    count_nonzero :</span></div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral">        Counts the number of non-zero elements in the input array.</span></div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral">    While the nonzero values can be obtained with ``a[nonzero(a)]``, it is</span></div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral">    recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which</span></div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral">    will correctly handle 0-d arrays.</span></div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">    array([[3, 0, 0],</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">           [0, 4, 0],</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">           [5, 6, 0]])</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">    &gt;&gt;&gt; np.nonzero(x)</span></div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral">    (array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span></div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1950</span><span class="stringliteral">    &gt;&gt;&gt; x[np.nonzero(x)]</span></div>
<div class="line"><span class="lineno"> 1951</span><span class="stringliteral">    array([3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 1952</span><span class="stringliteral">    &gt;&gt;&gt; np.transpose(np.nonzero(x))</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral">    array([[0, 0],</span></div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">           [1, 1],</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">           [2, 0],</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral">           [2, 1]])</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">    A common use for ``nonzero`` is to find the indices of an array, where</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">    a condition is True.  Given an array `a`, the condition `a` &gt; 3 is a</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">    boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">    yields the indices of the `a` where the condition is true.</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral">    &gt;&gt;&gt; a &gt; 3</span></div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">    array([[False, False, False],</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">           [ True,  True,  True],</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">           [ True,  True,  True]])</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">    &gt;&gt;&gt; np.nonzero(a &gt; 3)</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">    Using this result to index `a` is equivalent to using the mask directly:</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    &gt;&gt;&gt; a[np.nonzero(a &gt; 3)]</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    array([4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">    &gt;&gt;&gt; a[a &gt; 3]  # prefer this spelling</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">    array([4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">    ``nonzero`` can also be called as a method of the array.</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">    &gt;&gt;&gt; (a &gt; 3).nonzero()</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1984</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;nonzero&#39;</span>)</div>
<div class="line"><span class="lineno"> 1985</span> </div>
<div class="line"><span class="lineno"> 1986</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5fb8e6810a27d408fe67f541620bb1d8" name="a5fb8e6810a27d408fe67f541620bb1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb8e6810a27d408fe67f541620bb1d8">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.partition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>'introselect'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a partitioned copy of an array.

Creates a copy of the array with its elements rearranged in such a
way that the value of the element in k-th position is in the position
the value would be in a sorted array.  In the partitioned array, all
elements before the k-th element are less than or equal to that
element, and all the elements after the k-th element are greater than
or equal to that element.  The ordering of the elements in the two
partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array to be sorted.
kth : int or sequence of ints
    Element index to partition by. The k-th value of the element
    will be in its final sorted position and all smaller elements
    will be moved before it and all equal or greater elements behind
    it. The order of all elements in the partitions is undefined. If
    provided with a sequence of k-th it will partition all elements
    indexed by k-th  of them into their sorted position at once.

    .. deprecated:: 1.22.0
        Passing booleans as index is deprecated.
axis : int or None, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument
    specifies which fields to compare first, second, etc.  A single
    field can be specified as a string.  Not all fields need be
    specified, but unspecified fields will still be used, in the
    order in which they come up in the dtype, to break ties.

Returns
-------
partitioned_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
ndarray.partition : Method to sort an array in-place.
argpartition : Indirect partition.
sort : Full sorting

Notes
-----
The various selection algorithms are characterized by their average
speed, worst case performance, work space size, and whether they are
stable. A stable sort keeps items with the same key in the same
relative order. The available algorithms have the following
properties:

================= ======= ============= ============ =======
   kind            speed   worst case    work space  stable
================= ======= ============= ============ =======
'introselect'        1        O(n)           0         no
================= ======= ============= ============ =======

All the partition algorithms make temporary copies of the data when
partitioning along any but the last axis.  Consequently,
partitioning along the last axis is faster and uses less space than
partitioning along any other axis.

The sort order for complex numbers is lexicographic. If both the
real and imaginary parts are non-nan then the order is determined by
the real parts except when they are equal, in which case the order
is determined by the imaginary parts.

Examples
--------
&gt;&gt;&gt; a = np.array([7, 1, 7, 7, 1, 5, 7, 2, 3, 2, 6, 2, 3, 0])
&gt;&gt;&gt; p = np.partition(a, 4)
&gt;&gt;&gt; p
array([0, 1, 2, 1, 2, 5, 2, 3, 3, 6, 7, 7, 7, 7])

``p[4]`` is 2;  all elements in ``p[:4]`` are less than or equal
to ``p[4]``, and all elements in ``p[5:]`` are greater than or
equal to ``p[4]``.  The partition is::

    [0, 1, 2, 1], [2], [5, 2, 3, 3, 6, 7, 7, 7, 7]

The next example shows the use of multiple values passed to `kth`.

&gt;&gt;&gt; p2 = np.partition(a, (4, 8))
&gt;&gt;&gt; p2
array([0, 1, 2, 1, 2, 3, 3, 2, 5, 6, 7, 7, 7, 7])

``p2[4]`` is 2  and ``p2[8]`` is 5.  All elements in ``p2[:4]``
are less than or equal to ``p2[4]``, all elements in ``p2[5:8]``
are greater than or equal to ``p2[4]`` and less than or equal to
``p2[8]``, and all elements in ``p2[9:]`` are greater than or
equal to ``p2[8]``.  The partition is::

    [0, 1, 2, 1], [2], [3, 3, 2], [5], [6, 7, 7, 7, 7]
</pre> <div class="fragment"><div class="line"><span class="lineno">  676</span><span class="keyword">def </span>partition(a, kth, axis=-1, kind=&#39;introselect&#39;, order=None):</div>
<div class="line"><span class="lineno">  677</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    Return a partitioned copy of an array.</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    Creates a copy of the array with its elements rearranged in such a</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    way that the value of the element in k-th position is in the position</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    the value would be in a sorted array.  In the partitioned array, all</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    elements before the k-th element are less than or equal to that</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    element, and all the elements after the k-th element are greater than</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    or equal to that element.  The ordering of the elements in the two</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    partitions is undefined.</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        Array to be sorted.</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    kth : int or sequence of ints</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        Element index to partition by. The k-th value of the element</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">        will be in its final sorted position and all smaller elements</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        will be moved before it and all equal or greater elements behind</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        it. The order of all elements in the partitions is undefined. If</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        provided with a sequence of k-th it will partition all elements</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        indexed by k-th  of them into their sorted position at once.</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        .. deprecated:: 1.22.0</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">            Passing booleans as index is deprecated.</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">        Axis along which to sort. If None, the array is flattened before</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">        sorting. The default is -1, which sorts along the last axis.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    kind : {&#39;introselect&#39;}, optional</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        Selection algorithm. Default is &#39;introselect&#39;.</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    order : str or list of str, optional</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">        When `a` is an array with fields defined, this argument</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        specifies which fields to compare first, second, etc.  A single</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">        field can be specified as a string.  Not all fields need be</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        specified, but unspecified fields will still be used, in the</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        order in which they come up in the dtype, to break ties.</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    partitioned_array : ndarray</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        Array of the same type and shape as `a`.</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    ndarray.partition : Method to sort an array in-place.</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    argpartition : Indirect partition.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    sort : Full sorting</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    The various selection algorithms are characterized by their average</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    speed, worst case performance, work space size, and whether they are</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    stable. A stable sort keeps items with the same key in the same</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    relative order. The available algorithms have the following</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    properties:</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    ================= ======= ============= ============ =======</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">       kind            speed   worst case    work space  stable</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    ================= ======= ============= ============ =======</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    &#39;introselect&#39;        1        O(n)           0         no</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    ================= ======= ============= ============ =======</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    All the partition algorithms make temporary copies of the data when</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    partitioning along any but the last axis.  Consequently,</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    partitioning along the last axis is faster and uses less space than</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    partitioning along any other axis.</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    The sort order for complex numbers is lexicographic. If both the</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    real and imaginary parts are non-nan then the order is determined by</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    the real parts except when they are equal, in which case the order</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    is determined by the imaginary parts.</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([7, 1, 7, 7, 1, 5, 7, 2, 3, 2, 6, 2, 3, 0])</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    &gt;&gt;&gt; p = np.partition(a, 4)</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    array([0, 1, 2, 1, 2, 5, 2, 3, 3, 6, 7, 7, 7, 7])</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    ``p[4]`` is 2;  all elements in ``p[:4]`` are less than or equal</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    to ``p[4]``, and all elements in ``p[5:]`` are greater than or</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    equal to ``p[4]``.  The partition is::</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        [0, 1, 2, 1], [2], [5, 2, 3, 3, 6, 7, 7, 7, 7]</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    The next example shows the use of multiple values passed to `kth`.</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    &gt;&gt;&gt; p2 = np.partition(a, (4, 8))</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    &gt;&gt;&gt; p2</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    array([0, 1, 2, 1, 2, 3, 3, 2, 5, 6, 7, 7, 7, 7])</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    ``p2[4]`` is 2  and ``p2[8]`` is 5.  All elements in ``p2[:4]``</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    are less than or equal to ``p2[4]``, all elements in ``p2[5:8]``</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    are greater than or equal to ``p2[4]`` and less than or equal to</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    ``p2[8]``, and all elements in ``p2[9:]`` are greater than or</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    equal to ``p2[8]``.  The partition is::</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        [0, 1, 2, 1], [2], [3, 3, 2], [5], [6, 7, 7, 7, 7]</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  778</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  779</span>        <span class="comment"># flatten returns (1, N) for np.matrix, so always use the last axis</span></div>
<div class="line"><span class="lineno">  780</span>        a = asanyarray(a).flatten()</div>
<div class="line"><span class="lineno">  781</span>        axis = -1</div>
<div class="line"><span class="lineno">  782</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  783</span>        a = asanyarray(a).copy(order=<span class="stringliteral">&quot;K&quot;</span>)</div>
<div class="line"><span class="lineno">  784</span>    a.partition(kth, axis=axis, kind=kind, order=order)</div>
<div class="line"><span class="lineno">  785</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  786</span> </div>
<div class="line"><span class="lineno">  787</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2593c145d58708095d7c839abc405591" name="a2593c145d58708095d7c839abc405591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2593c145d58708095d7c839abc405591">&#9670;&#160;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.prod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the product of array elements over a given axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which a product is performed.  The default,
    axis=None, will calculate the product of all the elements in the
    input array. If axis is negative it counts from the last to the
    first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, a product is performed on all of the
    axes specified in the tuple instead of a single axis or all the
    axes as before.
dtype : dtype, optional
    The type of the returned array, as well as of the accumulator in
    which the elements are multiplied.  The dtype of `a` is used by
    default unless `a` has an integer dtype of less precision than the
    default platform integer.  In that case, if `a` is signed then the
    platform integer is used while if `a` is unsigned then an unsigned
    integer of the same precision as the platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in the
    result as dimensions with size one. With this option, the result
    will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `prod` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.
initial : scalar, optional
    The starting value for this product. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to include in the product. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.17.0

Returns
-------
product_along_axis : ndarray, see `dtype` parameter above.
    An array shaped as `a` but with the specified axis removed.
    Returns a reference to `out` if specified.

See Also
--------
ndarray.prod : equivalent method
:ref:`ufuncs-output-type`

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:

&gt;&gt;&gt; x = np.array([536870910, 536870910, 536870910, 536870910])
&gt;&gt;&gt; np.prod(x)
16 # may vary

The product of an empty array is the neutral element 1:

&gt;&gt;&gt; np.prod([])
1.0

Examples
--------
By default, calculate the product of all elements:

&gt;&gt;&gt; np.prod([1.,2.])
2.0

Even when the input array is two-dimensional:

&gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])
&gt;&gt;&gt; np.prod(a)
24.0

But we can also specify the axis over which to multiply:

&gt;&gt;&gt; np.prod(a, axis=1)
array([  2.,  12.])
&gt;&gt;&gt; np.prod(a, axis=0)
array([3., 8.])

Or select specific elements to include:

&gt;&gt;&gt; np.prod([1., np.nan, 3.], where=[True, False, True])
3.0

If the type of `x` is unsigned, then the output type is
the unsigned platform integer:

&gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.uint8)
&gt;&gt;&gt; np.prod(x).dtype == np.uint
True

If `x` is of a signed integer type, then the output type
is the default platform integer:

&gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.int8)
&gt;&gt;&gt; np.prod(x).dtype == int
True

You can also start the product with a value other than one:

&gt;&gt;&gt; np.prod([1, 2], initial=5)
10
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2957</span>         initial=np._NoValue, where=np._NoValue):</div>
<div class="line"><span class="lineno"> 2958</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2959</span><span class="stringliteral">    Return the product of array elements over a given axis.</span></div>
<div class="line"><span class="lineno"> 2960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2961</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2962</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2963</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2964</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 2965</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 2966</span><span class="stringliteral">        Axis or axes along which a product is performed.  The default,</span></div>
<div class="line"><span class="lineno"> 2967</span><span class="stringliteral">        axis=None, will calculate the product of all the elements in the</span></div>
<div class="line"><span class="lineno"> 2968</span><span class="stringliteral">        input array. If axis is negative it counts from the last to the</span></div>
<div class="line"><span class="lineno"> 2969</span><span class="stringliteral">        first axis.</span></div>
<div class="line"><span class="lineno"> 2970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2971</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2973</span><span class="stringliteral">        If axis is a tuple of ints, a product is performed on all of the</span></div>
<div class="line"><span class="lineno"> 2974</span><span class="stringliteral">        axes specified in the tuple instead of a single axis or all the</span></div>
<div class="line"><span class="lineno"> 2975</span><span class="stringliteral">        axes as before.</span></div>
<div class="line"><span class="lineno"> 2976</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 2977</span><span class="stringliteral">        The type of the returned array, as well as of the accumulator in</span></div>
<div class="line"><span class="lineno"> 2978</span><span class="stringliteral">        which the elements are multiplied.  The dtype of `a` is used by</span></div>
<div class="line"><span class="lineno"> 2979</span><span class="stringliteral">        default unless `a` has an integer dtype of less precision than the</span></div>
<div class="line"><span class="lineno"> 2980</span><span class="stringliteral">        default platform integer.  In that case, if `a` is signed then the</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral">        platform integer is used while if `a` is unsigned then an unsigned</span></div>
<div class="line"><span class="lineno"> 2982</span><span class="stringliteral">        integer of the same precision as the platform integer is used.</span></div>
<div class="line"><span class="lineno"> 2983</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2984</span><span class="stringliteral">        Alternative output array in which to place the result. It must have</span></div>
<div class="line"><span class="lineno"> 2985</span><span class="stringliteral">        the same shape as the expected output, but the type of the output</span></div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">        values will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left in the</span></div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral">        result as dimensions with size one. With this option, the result</span></div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral">        will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 2993</span><span class="stringliteral">        passed through to the `prod` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 2994</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 2995</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 2996</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 2997</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral">        The starting value for this product. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral">        .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno"> 3001</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3002</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 3003</span><span class="stringliteral">        Elements to include in the product. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 3004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3005</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 3006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3007</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3008</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3009</span><span class="stringliteral">    product_along_axis : ndarray, see `dtype` parameter above.</span></div>
<div class="line"><span class="lineno"> 3010</span><span class="stringliteral">        An array shaped as `a` but with the specified axis removed.</span></div>
<div class="line"><span class="lineno"> 3011</span><span class="stringliteral">        Returns a reference to `out` if specified.</span></div>
<div class="line"><span class="lineno"> 3012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3013</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3014</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3015</span><span class="stringliteral">    ndarray.prod : equivalent method</span></div>
<div class="line"><span class="lineno"> 3016</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 3017</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3018</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3019</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3020</span><span class="stringliteral">    Arithmetic is modular when using integer types, and no error is</span></div>
<div class="line"><span class="lineno"> 3021</span><span class="stringliteral">    raised on overflow.  That means that, on a 32-bit platform:</span></div>
<div class="line"><span class="lineno"> 3022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3023</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([536870910, 536870910, 536870910, 536870910])</span></div>
<div class="line"><span class="lineno"> 3024</span><span class="stringliteral">    &gt;&gt;&gt; np.prod(x)</span></div>
<div class="line"><span class="lineno"> 3025</span><span class="stringliteral">    16 # may vary</span></div>
<div class="line"><span class="lineno"> 3026</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3027</span><span class="stringliteral">    The product of an empty array is the neutral element 1:</span></div>
<div class="line"><span class="lineno"> 3028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral">    &gt;&gt;&gt; np.prod([])</span></div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno"> 3031</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3032</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3033</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3034</span><span class="stringliteral">    By default, calculate the product of all elements:</span></div>
<div class="line"><span class="lineno"> 3035</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3036</span><span class="stringliteral">    &gt;&gt;&gt; np.prod([1.,2.])</span></div>
<div class="line"><span class="lineno"> 3037</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 3038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3039</span><span class="stringliteral">    Even when the input array is two-dimensional:</span></div>
<div class="line"><span class="lineno"> 3040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3041</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])</span></div>
<div class="line"><span class="lineno"> 3042</span><span class="stringliteral">    &gt;&gt;&gt; np.prod(a)</span></div>
<div class="line"><span class="lineno"> 3043</span><span class="stringliteral">    24.0</span></div>
<div class="line"><span class="lineno"> 3044</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3045</span><span class="stringliteral">    But we can also specify the axis over which to multiply:</span></div>
<div class="line"><span class="lineno"> 3046</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3047</span><span class="stringliteral">    &gt;&gt;&gt; np.prod(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 3048</span><span class="stringliteral">    array([  2.,  12.])</span></div>
<div class="line"><span class="lineno"> 3049</span><span class="stringliteral">    &gt;&gt;&gt; np.prod(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 3050</span><span class="stringliteral">    array([3., 8.])</span></div>
<div class="line"><span class="lineno"> 3051</span><span class="stringliteral">    </span></div>
<div class="line"><span class="lineno"> 3052</span><span class="stringliteral">    Or select specific elements to include:</span></div>
<div class="line"><span class="lineno"> 3053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3054</span><span class="stringliteral">    &gt;&gt;&gt; np.prod([1., np.nan, 3.], where=[True, False, True])</span></div>
<div class="line"><span class="lineno"> 3055</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno"> 3056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3057</span><span class="stringliteral">    If the type of `x` is unsigned, then the output type is</span></div>
<div class="line"><span class="lineno"> 3058</span><span class="stringliteral">    the unsigned platform integer:</span></div>
<div class="line"><span class="lineno"> 3059</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3060</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.uint8)</span></div>
<div class="line"><span class="lineno"> 3061</span><span class="stringliteral">    &gt;&gt;&gt; np.prod(x).dtype == np.uint</span></div>
<div class="line"><span class="lineno"> 3062</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 3063</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3064</span><span class="stringliteral">    If `x` is of a signed integer type, then the output type</span></div>
<div class="line"><span class="lineno"> 3065</span><span class="stringliteral">    is the default platform integer:</span></div>
<div class="line"><span class="lineno"> 3066</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3067</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.int8)</span></div>
<div class="line"><span class="lineno"> 3068</span><span class="stringliteral">    &gt;&gt;&gt; np.prod(x).dtype == int</span></div>
<div class="line"><span class="lineno"> 3069</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 3070</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3071</span><span class="stringliteral">    You can also start the product with a value other than one:</span></div>
<div class="line"><span class="lineno"> 3072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3073</span><span class="stringliteral">    &gt;&gt;&gt; np.prod([1, 2], initial=5)</span></div>
<div class="line"><span class="lineno"> 3074</span><span class="stringliteral">    10</span></div>
<div class="line"><span class="lineno"> 3075</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3076</span>    <span class="keywordflow">return</span> _wrapreduction(a, np.multiply, <span class="stringliteral">&#39;prod&#39;</span>, axis, dtype, out,</div>
<div class="line"><span class="lineno"> 3077</span>                          keepdims=keepdims, initial=initial, where=where)</div>
<div class="line"><span class="lineno"> 3078</span> </div>
<div class="line"><span class="lineno"> 3079</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0abced3adc3b6a204a28cd07e54b7697" name="a0abced3adc3b6a204a28cd07e54b7697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abced3adc3b6a204a28cd07e54b7697">&#9670;&#160;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.product </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the product of array elements over a given axis.

See Also
--------
prod : equivalent function; see for details.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3767</span><span class="keyword">def </span>product(*args, **kwargs):</div>
<div class="line"><span class="lineno"> 3768</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3769</span><span class="stringliteral">    Return the product of array elements over a given axis.</span></div>
<div class="line"><span class="lineno"> 3770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3771</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3772</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3773</span><span class="stringliteral">    prod : equivalent function; see for details.</span></div>
<div class="line"><span class="lineno"> 3774</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3775</span>    <span class="keywordflow">return</span> prod(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 3776</span> </div>
<div class="line"><span class="lineno"> 3777</span> </div>
<div class="line"><span class="lineno"> 3778</span><span class="preprocessor">@array_function_dispatch(_cumprod_dispatcher, verify=False)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afb1063686650ab11f5deb2769ddac6ab" name="afb1063686650ab11f5deb2769ddac6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1063686650ab11f5deb2769ddac6ab">&#9670;&#160;</a></span>ptp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.ptp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Range of values (maximum - minimum) along an axis.

The name of the function comes from the acronym for 'peak to peak'.

.. warning::
    `ptp` preserves the data type of the array. This means the
    return value for an input of signed integers with n bits
    (e.g. `np.int8`, `np.int16`, etc) is also a signed integer
    with n bits.  In that case, peak-to-peak values greater than
    ``2**(n-1)-1`` will be returned as negative values. An example
    with a work-around is shown below.

Parameters
----------
a : array_like
    Input values.
axis : None or int or tuple of ints, optional
    Axis along which to find the peaks.  By default, flatten the
    array.  `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.15.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : array_like
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type of the output values will be cast if necessary.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `ptp` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
ptp : ndarray or scalar
    The range of a given array - `scalar` if array is one-dimensional
    or a new array holding the result along the given axis

Examples
--------
&gt;&gt;&gt; x = np.array([[4, 9, 2, 10],
...               [6, 9, 7, 12]])

&gt;&gt;&gt; np.ptp(x, axis=1)
array([8, 6])

&gt;&gt;&gt; np.ptp(x, axis=0)
array([2, 0, 5, 2])

&gt;&gt;&gt; np.ptp(x)
10

This example shows that a negative value can be returned when
the input is an array of signed integers.

&gt;&gt;&gt; y = np.array([[1, 127],
...               [0, 127],
...               [-1, 127],
...               [-2, 127]], dtype=np.int8)
&gt;&gt;&gt; np.ptp(y, axis=1)
array([ 126,  127, -128, -127], dtype=int8)

A work-around is to use the `view()` method to view the result as
unsigned integers with the same bit width:

&gt;&gt;&gt; np.ptp(y, axis=1).view(np.uint8)
array([126, 127, 128, 129], dtype=uint8)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2605</span><span class="keyword">def </span>ptp(a, axis=None, out=None, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno"> 2606</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2607</span><span class="stringliteral">    Range of values (maximum - minimum) along an axis.</span></div>
<div class="line"><span class="lineno"> 2608</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2609</span><span class="stringliteral">    The name of the function comes from the acronym for &#39;peak to peak&#39;.</span></div>
<div class="line"><span class="lineno"> 2610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2611</span><span class="stringliteral">    .. warning::</span></div>
<div class="line"><span class="lineno"> 2612</span><span class="stringliteral">        `ptp` preserves the data type of the array. This means the</span></div>
<div class="line"><span class="lineno"> 2613</span><span class="stringliteral">        return value for an input of signed integers with n bits</span></div>
<div class="line"><span class="lineno"> 2614</span><span class="stringliteral">        (e.g. `np.int8`, `np.int16`, etc) is also a signed integer</span></div>
<div class="line"><span class="lineno"> 2615</span><span class="stringliteral">        with n bits.  In that case, peak-to-peak values greater than</span></div>
<div class="line"><span class="lineno"> 2616</span><span class="stringliteral">        ``2**(n-1)-1`` will be returned as negative values. An example</span></div>
<div class="line"><span class="lineno"> 2617</span><span class="stringliteral">        with a work-around is shown below.</span></div>
<div class="line"><span class="lineno"> 2618</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2619</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2620</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2621</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2622</span><span class="stringliteral">        Input values.</span></div>
<div class="line"><span class="lineno"> 2623</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 2624</span><span class="stringliteral">        Axis along which to find the peaks.  By default, flatten the</span></div>
<div class="line"><span class="lineno"> 2625</span><span class="stringliteral">        array.  `axis` may be negative, in</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral">        which case it counts from the last to the first axis.</span></div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral">        .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2630</span><span class="stringliteral">        If this is a tuple of ints, a reduction is performed on multiple</span></div>
<div class="line"><span class="lineno"> 2631</span><span class="stringliteral">        axes, instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 2632</span><span class="stringliteral">    out : array_like</span></div>
<div class="line"><span class="lineno"> 2633</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno"> 2634</span><span class="stringliteral">        have the same shape and buffer length as the expected output,</span></div>
<div class="line"><span class="lineno"> 2635</span><span class="stringliteral">        but the type of the output values will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 2636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2637</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2638</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 2639</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 2640</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 2641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2642</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 2643</span><span class="stringliteral">        passed through to the `ptp` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 2644</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 2645</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 2646</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 2647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2648</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2649</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2650</span><span class="stringliteral">    ptp : ndarray or scalar</span></div>
<div class="line"><span class="lineno"> 2651</span><span class="stringliteral">        The range of a given array - `scalar` if array is one-dimensional</span></div>
<div class="line"><span class="lineno"> 2652</span><span class="stringliteral">        or a new array holding the result along the given axis</span></div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[4, 9, 2, 10],</span></div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral">    ...               [6, 9, 7, 12]])</span></div>
<div class="line"><span class="lineno"> 2658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2659</span><span class="stringliteral">    &gt;&gt;&gt; np.ptp(x, axis=1)</span></div>
<div class="line"><span class="lineno"> 2660</span><span class="stringliteral">    array([8, 6])</span></div>
<div class="line"><span class="lineno"> 2661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2662</span><span class="stringliteral">    &gt;&gt;&gt; np.ptp(x, axis=0)</span></div>
<div class="line"><span class="lineno"> 2663</span><span class="stringliteral">    array([2, 0, 5, 2])</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2665</span><span class="stringliteral">    &gt;&gt;&gt; np.ptp(x)</span></div>
<div class="line"><span class="lineno"> 2666</span><span class="stringliteral">    10</span></div>
<div class="line"><span class="lineno"> 2667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2668</span><span class="stringliteral">    This example shows that a negative value can be returned when</span></div>
<div class="line"><span class="lineno"> 2669</span><span class="stringliteral">    the input is an array of signed integers.</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([[1, 127],</span></div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">    ...               [0, 127],</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">    ...               [-1, 127],</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">    ...               [-2, 127]], dtype=np.int8)</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">    &gt;&gt;&gt; np.ptp(y, axis=1)</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral">    array([ 126,  127, -128, -127], dtype=int8)</span></div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral">    A work-around is to use the `view()` method to view the result as</span></div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral">    unsigned integers with the same bit width:</span></div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral">    &gt;&gt;&gt; np.ptp(y, axis=1).view(np.uint8)</span></div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral">    array([126, 127, 128, 129], dtype=uint8)</span></div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2685</span>    kwargs = {}</div>
<div class="line"><span class="lineno"> 2686</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 2687</span>        kwargs[<span class="stringliteral">&#39;keepdims&#39;</span>] = keepdims</div>
<div class="line"><span class="lineno"> 2688</span>    <span class="keywordflow">if</span> type(a) <span class="keywordflow">is</span> <span class="keywordflow">not</span> mu.ndarray:</div>
<div class="line"><span class="lineno"> 2689</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2690</span>            ptp = a.ptp</div>
<div class="line"><span class="lineno"> 2691</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 2692</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 2693</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2694</span>            <span class="keywordflow">return</span> ptp(axis=axis, out=out, **kwargs)</div>
<div class="line"><span class="lineno"> 2695</span>    <span class="keywordflow">return</span> _methods._ptp(a, axis=axis, out=out, **kwargs)</div>
<div class="line"><span class="lineno"> 2696</span> </div>
<div class="line"><span class="lineno"> 2697</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afc9a708522540311450a0c848c8e67fc" name="afc9a708522540311450a0c848c8e67fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9a708522540311450a0c848c8e67fc">&#9670;&#160;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.put </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'raise'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replaces specified elements of an array with given values.

The indexing works on the flattened target array. `put` is roughly
equivalent to:

::

    a.flat[ind] = v

Parameters
----------
a : ndarray
    Target array.
ind : array_like
    Target indices, interpreted as integers.
v : array_like
    Values to place in `a` at target indices. If `v` is shorter than
    `ind` it will be repeated as necessary.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' -- raise an error (default)
    * 'wrap' -- wrap around
    * 'clip' -- clip to the range

    'clip' mode means that all indices that are too large are replaced
    by the index that addresses the last element along that axis. Note
    that this disables indexing with negative numbers. In 'raise' mode,
    if an exception occurs the target array may still be modified.

See Also
--------
putmask, place
put_along_axis : Put elements by matching the array and the index arrays

Examples
--------
&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; np.put(a, [0, 2], [-44, -55])
&gt;&gt;&gt; a
array([-44,   1, -55,   3,   4])

&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; np.put(a, 22, -5, mode='clip')
&gt;&gt;&gt; a
array([ 0,  1,  2,  3, -5])</pre> <div class="fragment"><div class="line"><span class="lineno">  487</span><span class="keyword">def </span>put(a, ind, v, mode=&#39;raise&#39;):</div>
<div class="line"><span class="lineno">  488</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    Replaces specified elements of an array with given values.</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    The indexing works on the flattened target array. `put` is roughly</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    equivalent to:</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    ::</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        a.flat[ind] = v</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        Target array.</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    ind : array_like</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        Target indices, interpreted as integers.</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    v : array_like</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        Values to place in `a` at target indices. If `v` is shorter than</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        `ind` it will be repeated as necessary.</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        Specifies how out-of-bounds indices will behave.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        * &#39;raise&#39; -- raise an error (default)</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        * &#39;wrap&#39; -- wrap around</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        * &#39;clip&#39; -- clip to the range</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        &#39;clip&#39; mode means that all indices that are too large are replaced</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        by the index that addresses the last element along that axis. Note</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        that this disables indexing with negative numbers. In &#39;raise&#39; mode,</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        if an exception occurs the target array may still be modified.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    putmask, place</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    put_along_axis : Put elements by matching the array and the index arrays</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(5)</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    &gt;&gt;&gt; np.put(a, [0, 2], [-44, -55])</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    array([-44,   1, -55,   3,   4])</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(5)</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    &gt;&gt;&gt; np.put(a, 22, -5, mode=&#39;clip&#39;)</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    array([ 0,  1,  2,  3, -5])</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  537</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  538</span>        put = a.put</div>
<div class="line"><span class="lineno">  539</span>    <span class="keywordflow">except</span> AttributeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  540</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;argument 1 must be numpy.ndarray, &quot;</span></div>
<div class="line"><span class="lineno">  541</span>                        <span class="stringliteral">&quot;not {name}&quot;</span>.format(name=type(a).__name__)) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  542</span> </div>
<div class="line"><span class="lineno">  543</span>    <span class="keywordflow">return</span> put(ind, v, mode=mode)</div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a06908f65c1549031f1c4128d90bd4edc" name="a06908f65c1549031f1c4128d90bd4edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06908f65c1549031f1c4128d90bd4edc">&#9670;&#160;</a></span>ravel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.ravel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'C'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a contiguous flattened array.

A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.

As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)

Parameters
----------
a : array_like
    Input array.  The elements in `a` are read in the order specified by
    `order`, and packed as a 1-D array.
order : {'C','F', 'A', 'K'}, optional

    The elements of `a` are read using this index order. 'C' means
    to index the elements in row-major, C-style order,
    with the last axis index changing fastest, back to the first
    axis index changing slowest.  'F' means to index the elements
    in column-major, Fortran-style order, with the
    first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of
    the memory layout of the underlying array, and only refer to
    the order of axis indexing.  'A' means to read the elements in
    Fortran-like index order if `a` is Fortran *contiguous* in
    memory, C-like order otherwise.  'K' means to read the
    elements in the order they occur in memory, except for
    reversing the data when strides are negative.  By default, 'C'
    index order is used.

Returns
-------
y : array_like
    y is an array of the same subtype as `a`, with shape ``(a.size,)``.
    Note that matrices are special cased for backward compatibility, if `a`
    is a matrix, then y is a 1-D ndarray.

See Also
--------
ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array
                  in row-major order.
ndarray.reshape : Change the shape of an array without changing its data.

Notes
-----
In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.

When a view is desired in as many cases as possible, ``arr.reshape(-1)``
may be preferable.

Examples
--------
It is equivalent to ``reshape(-1, order=order)``.

&gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; np.ravel(x)
array([1, 2, 3, 4, 5, 6])

&gt;&gt;&gt; x.reshape(-1)
array([1, 2, 3, 4, 5, 6])

&gt;&gt;&gt; np.ravel(x, order='F')
array([1, 4, 2, 5, 3, 6])

When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:

&gt;&gt;&gt; np.ravel(x.T)
array([1, 4, 2, 5, 3, 6])
&gt;&gt;&gt; np.ravel(x.T, order='A')
array([1, 2, 3, 4, 5, 6])

When ``order`` is 'K', it will preserve orderings that are neither 'C'
nor 'F', but won't reverse axes:

&gt;&gt;&gt; a = np.arange(3)[::-1]; a
array([2, 1, 0])
&gt;&gt;&gt; a.ravel(order='C')
array([2, 1, 0])
&gt;&gt;&gt; a.ravel(order='K')
array([2, 1, 0])

&gt;&gt;&gt; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
array([[[ 0,  2,  4],
        [ 1,  3,  5]],
       [[ 6,  8, 10],
        [ 7,  9, 11]]])
&gt;&gt;&gt; a.ravel(order='C')
array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
&gt;&gt;&gt; a.ravel(order='K')
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1782</span><span class="keyword">def </span>ravel(a, order=&#39;C&#39;):</div>
<div class="line"><span class="lineno"> 1783</span>    <span class="stringliteral">&quot;&quot;&quot;Return a contiguous flattened array.</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">    A 1-D array, containing the elements of the input, is returned.  A copy is</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">    made only if needed.</span></div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">    As of NumPy 1.10, the returned array will have the same type as the input</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">    array. (for example, a masked array will be returned for a masked array</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">    input)</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">        Input array.  The elements in `a` are read in the order specified by</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">        `order`, and packed as a 1-D array.</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">    order : {&#39;C&#39;,&#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">        The elements of `a` are read using this index order. &#39;C&#39; means</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        to index the elements in row-major, C-style order,</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">        with the last axis index changing fastest, back to the first</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        axis index changing slowest.  &#39;F&#39; means to index the elements</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">        in column-major, Fortran-style order, with the</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">        first index changing fastest, and the last index changing</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">        slowest. Note that the &#39;C&#39; and &#39;F&#39; options take no account of</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">        the memory layout of the underlying array, and only refer to</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">        the order of axis indexing.  &#39;A&#39; means to read the elements in</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">        Fortran-like index order if `a` is Fortran *contiguous* in</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">        memory, C-like order otherwise.  &#39;K&#39; means to read the</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">        elements in the order they occur in memory, except for</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">        reversing the data when strides are negative.  By default, &#39;C&#39;</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">        index order is used.</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">        y is an array of the same subtype as `a`, with shape ``(a.size,)``.</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">        Note that matrices are special cased for backward compatibility, if `a`</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        is a matrix, then y is a 1-D ndarray.</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    ndarray.flat : 1-D iterator over an array.</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    ndarray.flatten : 1-D array copy of the elements of an array</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">                      in row-major order.</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    ndarray.reshape : Change the shape of an array without changing its data.</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    In row-major, C-style order, in two dimensions, the row index</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    varies the slowest, and the column index the quickest.  This can</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    be generalized to multiple dimensions, where row-major order</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    implies that the index along the first axis varies slowest, and</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    the index along the last quickest.  The opposite holds for</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    column-major, Fortran-style index ordering.</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">    When a view is desired in as many cases as possible, ``arr.reshape(-1)``</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    may be preferable.</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">    It is equivalent to ``reshape(-1, order=order)``.</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel(x)</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">    array([1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    &gt;&gt;&gt; x.reshape(-1)</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    array([1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel(x, order=&#39;F&#39;)</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">    array([1, 4, 2, 5, 3, 6])</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    When ``order`` is &#39;A&#39;, it will preserve the array&#39;s &#39;C&#39; or &#39;F&#39; ordering:</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel(x.T)</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    array([1, 4, 2, 5, 3, 6])</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral">    &gt;&gt;&gt; np.ravel(x.T, order=&#39;A&#39;)</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    array([1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">    When ``order`` is &#39;K&#39;, it will preserve orderings that are neither &#39;C&#39;</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">    nor &#39;F&#39;, but won&#39;t reverse axes:</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(3)[::-1]; a</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">    array([2, 1, 0])</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral">    &gt;&gt;&gt; a.ravel(order=&#39;C&#39;)</span></div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">    array([2, 1, 0])</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">    &gt;&gt;&gt; a.ravel(order=&#39;K&#39;)</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">    array([2, 1, 0])</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a</span></div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">    array([[[ 0,  2,  4],</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">            [ 1,  3,  5]],</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral">           [[ 6,  8, 10],</span></div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">            [ 7,  9, 11]]])</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">    &gt;&gt;&gt; a.ravel(order=&#39;C&#39;)</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">    &gt;&gt;&gt; a.ravel(order=&#39;K&#39;)</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span></div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1882</span>    <span class="keywordflow">if</span> isinstance(a, np.matrix):</div>
<div class="line"><span class="lineno"> 1883</span>        <span class="keywordflow">return</span> asarray(a).ravel(order=order)</div>
<div class="line"><span class="lineno"> 1884</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1885</span>        <span class="keywordflow">return</span> asanyarray(a).ravel(order=order)</div>
<div class="line"><span class="lineno"> 1886</span> </div>
<div class="line"><span class="lineno"> 1887</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a78fc1d180913aa6baf5197d59e54e507" name="a78fc1d180913aa6baf5197d59e54e507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fc1d180913aa6baf5197d59e54e507">&#9670;&#160;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.repeat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repeats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Repeat elements of an array.

Parameters
----------
a : array_like
    Input array.
repeats : int or array of ints
    The number of repetitions for each element.  `repeats` is broadcasted
    to fit the shape of the given axis.
axis : int, optional
    The axis along which to repeat values.  By default, use the
    flattened input array, and return a flat output array.

Returns
-------
repeated_array : ndarray
    Output array which has the same shape as `a`, except along
    the given axis.

See Also
--------
tile : Tile an array.
unique : Find the unique elements of an array.

Examples
--------
&gt;&gt;&gt; np.repeat(3, 4)
array([3, 3, 3, 3])
&gt;&gt;&gt; x = np.array([[1,2],[3,4]])
&gt;&gt;&gt; np.repeat(x, 2)
array([1, 1, 2, 2, 3, 3, 4, 4])
&gt;&gt;&gt; np.repeat(x, 3, axis=1)
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])
&gt;&gt;&gt; np.repeat(x, [1, 2], axis=0)
array([[1, 2],
       [3, 4],
       [3, 4]])</pre> <div class="fragment"><div class="line"><span class="lineno">  437</span><span class="keyword">def </span>repeat(a, repeats, axis=None):</div>
<div class="line"><span class="lineno">  438</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    Repeat elements of an array.</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    repeats : int or array of ints</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        The number of repetitions for each element.  `repeats` is broadcasted</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        to fit the shape of the given axis.</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        The axis along which to repeat values.  By default, use the</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        flattened input array, and return a flat output array.</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    repeated_array : ndarray</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">        Output array which has the same shape as `a`, except along</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">        the given axis.</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    tile : Tile an array.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    unique : Find the unique elements of an array.</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    &gt;&gt;&gt; np.repeat(3, 4)</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    array([3, 3, 3, 3])</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[1,2],[3,4]])</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    &gt;&gt;&gt; np.repeat(x, 2)</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    array([1, 1, 2, 2, 3, 3, 4, 4])</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    &gt;&gt;&gt; np.repeat(x, 3, axis=1)</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    array([[1, 1, 1, 2, 2, 2],</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">           [3, 3, 3, 4, 4, 4]])</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    &gt;&gt;&gt; np.repeat(x, [1, 2], axis=0)</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    array([[1, 2],</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">           [3, 4],</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">           [3, 4]])</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  479</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;repeat&#39;</span>, repeats, axis=axis)</div>
<div class="line"><span class="lineno">  480</span> </div>
<div class="line"><span class="lineno">  481</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a805221e91ab6019b13c120c9f6e2cc67" name="a805221e91ab6019b13c120c9f6e2cc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805221e91ab6019b13c120c9f6e2cc67">&#9670;&#160;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.reshape </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'C'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gives a new shape to an array without changing its data.

Parameters
----------
a : array_like
    Array to be reshaped.
newshape : int or tuple of ints
    The new shape should be compatible with the original shape. If
    an integer, then the result will be a 1-D array of that length.
    One shape dimension can be -1. In this case, the value is
    inferred from the length of the array and remaining dimensions.
order : {'C', 'F', 'A'}, optional
    Read the elements of `a` using this index order, and place the
    elements into the reshaped array using this index order.  'C'
    means to read / write the elements using C-like index order,
    with the last axis index changing fastest, back to the first
    axis index changing slowest. 'F' means to read / write the
    elements using Fortran-like index order, with the first index
    changing fastest, and the last index changing slowest. Note that
    the 'C' and 'F' options take no account of the memory layout of
    the underlying array, and only refer to the order of indexing.
    'A' means to read / write the elements in Fortran-like index
    order if `a` is Fortran *contiguous* in memory, C-like order
    otherwise.

Returns
-------
reshaped_array : ndarray
    This will be a new view object if possible; otherwise, it will
    be a copy.  Note there is no guarantee of the *memory layout* (C- or
    Fortran- contiguous) of the returned array.

See Also
--------
ndarray.reshape : Equivalent method.

Notes
-----
It is not always possible to change the shape of an array without
copying the data. If you want an error to be raised when the data is copied,
you should assign the new shape to the shape attribute of the array::

 &gt;&gt;&gt; a = np.zeros((10, 2))

 # A transpose makes the array non-contiguous
 &gt;&gt;&gt; b = a.T

 # Taking a view makes it possible to modify the shape without modifying
 # the initial object.
 &gt;&gt;&gt; c = b.view()
 &gt;&gt;&gt; c.shape = (20)
 Traceback (most recent call last):
    ...
 AttributeError: Incompatible shape for in-place modification. Use
 `.reshape()` to make a copy with the desired shape.

The `order` keyword gives the index ordering both for *fetching* the values
from `a`, and then *placing* the values into the output array.
For example, let's say you have an array:

&gt;&gt;&gt; a = np.arange(6).reshape((3, 2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3],
       [4, 5]])

You can think of reshaping as first raveling the array (using the given
index order), then inserting the elements from the raveled array into the
new array using the same kind of index ordering as was used for the
raveling.

&gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
array([[0, 4, 3],
       [2, 1, 5]])
&gt;&gt;&gt; np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
array([[0, 4, 3],
       [2, 1, 5]])

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; np.reshape(a, 6)
array([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; np.reshape(a, 6, order='F')
array([1, 4, 2, 5, 3, 6])

&gt;&gt;&gt; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
array([[1, 2],
       [3, 4],
       [5, 6]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  199</span><span class="keyword">def </span>reshape(a, newshape, order=&#39;C&#39;):</div>
<div class="line"><span class="lineno">  200</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    Gives a new shape to an array without changing its data.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        Array to be reshaped.</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    newshape : int or tuple of ints</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        The new shape should be compatible with the original shape. If</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        an integer, then the result will be a 1-D array of that length.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        One shape dimension can be -1. In this case, the value is</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        inferred from the length of the array and remaining dimensions.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        Read the elements of `a` using this index order, and place the</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        elements into the reshaped array using this index order.  &#39;C&#39;</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        means to read / write the elements using C-like index order,</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        with the last axis index changing fastest, back to the first</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        axis index changing slowest. &#39;F&#39; means to read / write the</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        elements using Fortran-like index order, with the first index</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        changing fastest, and the last index changing slowest. Note that</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        the &#39;C&#39; and &#39;F&#39; options take no account of the memory layout of</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">        the underlying array, and only refer to the order of indexing.</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        &#39;A&#39; means to read / write the elements in Fortran-like index</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">        order if `a` is Fortran *contiguous* in memory, C-like order</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">        otherwise.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    reshaped_array : ndarray</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        This will be a new view object if possible; otherwise, it will</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        be a copy.  Note there is no guarantee of the *memory layout* (C- or</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        Fortran- contiguous) of the returned array.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    ndarray.reshape : Equivalent method.</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    It is not always possible to change the shape of an array without</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    copying the data. If you want an error to be raised when the data is copied,</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    you should assign the new shape to the shape attribute of the array::</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">     &gt;&gt;&gt; a = np.zeros((10, 2))</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">     # A transpose makes the array non-contiguous</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">     &gt;&gt;&gt; b = a.T</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">     # Taking a view makes it possible to modify the shape without modifying</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">     # the initial object.</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">     &gt;&gt;&gt; c = b.view()</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">     &gt;&gt;&gt; c.shape = (20)</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">     Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">     AttributeError: Incompatible shape for in-place modification. Use</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">     `.reshape()` to make a copy with the desired shape.</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    The `order` keyword gives the index ordering both for *fetching* the values</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    from `a`, and then *placing* the values into the output array.</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    For example, let&#39;s say you have an array:</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(6).reshape((3, 2))</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">           [2, 3],</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">           [4, 5]])</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    You can think of reshaping as first raveling the array (using the given</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    index order), then inserting the elements from the raveled array into the</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    new array using the same kind of index ordering as was used for the</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    raveling.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    &gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">           [3, 4, 5]])</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    &gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">           [3, 4, 5]])</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    &gt;&gt;&gt; np.reshape(a, (2, 3), order=&#39;F&#39;) # Fortran-like index ordering</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    array([[0, 4, 3],</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">           [2, 1, 5]])</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    &gt;&gt;&gt; np.reshape(np.ravel(a, order=&#39;F&#39;), (2, 3), order=&#39;F&#39;)</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    array([[0, 4, 3],</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">           [2, 1, 5]])</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    &gt;&gt;&gt; np.reshape(a, 6)</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    array([1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    &gt;&gt;&gt; np.reshape(a, 6, order=&#39;F&#39;)</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    array([1, 4, 2, 5, 3, 6])</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    &gt;&gt;&gt; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    array([[1, 2],</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">           [3, 4],</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">           [5, 6]])</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  298</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;reshape&#39;</span>, newshape, order=order)</div>
<div class="line"><span class="lineno">  299</span> </div>
<div class="line"><span class="lineno">  300</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac74f9e7b5dc50af3f3fa0f30e755b323" name="ac74f9e7b5dc50af3f3fa0f30e755b323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74f9e7b5dc50af3f3fa0f30e755b323">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.resize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new array with the specified shape.

If the new array is larger than the original array, then the new
array is filled with repeated copies of `a`.  Note that this behavior
is different from a.resize(new_shape) which fills with zeros instead
of repeated copies of `a`.

Parameters
----------
a : array_like
    Array to be resized.

new_shape : int or tuple of int
    Shape of resized array.

Returns
-------
reshaped_array : ndarray
    The new array is formed from the data in the old array, repeated
    if necessary to fill out the required number of elements.  The
    data are repeated iterating over the array in C-order.

See Also
--------
numpy.reshape : Reshape an array without changing the total size.
numpy.pad : Enlarge and pad an array.
numpy.repeat : Repeat elements of an array.
ndarray.resize : resize an array in-place.

Notes
-----
When the total size of the array does not change `~numpy.reshape` should
be used.  In most other cases either indexing (to reduce the size)
or padding (to increase the size) may be a more appropriate solution.

Warning: This functionality does **not** consider axes separately,
i.e. it does not apply interpolation/extrapolation.
It fills the return array with the required number of elements, iterating
over `a` in C-order, disregarding axes (and cycling back from the start if
the new shape is larger).  This functionality is therefore not suitable to
resize images, or data where each axis represents a separate and distinct
entity.

Examples
--------
&gt;&gt;&gt; a=np.array([[0,1],[2,3]])
&gt;&gt;&gt; np.resize(a,(2,3))
array([[0, 1, 2],
       [3, 0, 1]])
&gt;&gt;&gt; np.resize(a,(1,4))
array([[0, 1, 2, 3]])
&gt;&gt;&gt; np.resize(a,(2,4))
array([[0, 1, 2, 3],
       [0, 1, 2, 3]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1421</span><span class="keyword">def </span>resize(a, new_shape):</div>
<div class="line"><span class="lineno"> 1422</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    Return a new array with the specified shape.</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    If the new array is larger than the original array, then the new</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    array is filled with repeated copies of `a`.  Note that this behavior</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    is different from a.resize(new_shape) which fills with zeros instead</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    of repeated copies of `a`.</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">        Array to be resized.</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    new_shape : int or tuple of int</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">        Shape of resized array.</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">    reshaped_array : ndarray</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">        The new array is formed from the data in the old array, repeated</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">        if necessary to fill out the required number of elements.  The</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">        data are repeated iterating over the array in C-order.</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">    numpy.reshape : Reshape an array without changing the total size.</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">    numpy.pad : Enlarge and pad an array.</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">    numpy.repeat : Repeat elements of an array.</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">    ndarray.resize : resize an array in-place.</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">    When the total size of the array does not change `~numpy.reshape` should</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">    be used.  In most other cases either indexing (to reduce the size)</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">    or padding (to increase the size) may be a more appropriate solution.</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">    Warning: This functionality does **not** consider axes separately,</span></div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">    i.e. it does not apply interpolation/extrapolation.</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">    It fills the return array with the required number of elements, iterating</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">    over `a` in C-order, disregarding axes (and cycling back from the start if</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">    the new shape is larger).  This functionality is therefore not suitable to</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">    resize images, or data where each axis represents a separate and distinct</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">    entity.</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">    &gt;&gt;&gt; a=np.array([[0,1],[2,3]])</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">    &gt;&gt;&gt; np.resize(a,(2,3))</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">    array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">           [3, 0, 1]])</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    &gt;&gt;&gt; np.resize(a,(1,4))</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">    array([[0, 1, 2, 3]])</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">    &gt;&gt;&gt; np.resize(a,(2,4))</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    array([[0, 1, 2, 3],</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">           [0, 1, 2, 3]])</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1479</span>    <span class="keywordflow">if</span> isinstance(new_shape, (int, nt.integer)):</div>
<div class="line"><span class="lineno"> 1480</span>        new_shape = (new_shape,)</div>
<div class="line"><span class="lineno"> 1481</span> </div>
<div class="line"><span class="lineno"> 1482</span>    a = ravel(a)</div>
<div class="line"><span class="lineno"> 1483</span> </div>
<div class="line"><span class="lineno"> 1484</span>    new_size = 1</div>
<div class="line"><span class="lineno"> 1485</span>    <span class="keywordflow">for</span> dim_length <span class="keywordflow">in</span> new_shape:</div>
<div class="line"><span class="lineno"> 1486</span>        new_size *= dim_length</div>
<div class="line"><span class="lineno"> 1487</span>        <span class="keywordflow">if</span> dim_length &lt; 0:</div>
<div class="line"><span class="lineno"> 1488</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;all elements of `new_shape` must be non-negative&#39;</span>)</div>
<div class="line"><span class="lineno"> 1489</span> </div>
<div class="line"><span class="lineno"> 1490</span>    <span class="keywordflow">if</span> a.size == 0 <span class="keywordflow">or</span> new_size == 0:</div>
<div class="line"><span class="lineno"> 1491</span>        <span class="comment"># First case must zero fill. The second would have repeats == 0.</span></div>
<div class="line"><span class="lineno"> 1492</span>        <span class="keywordflow">return</span> np.zeros_like(a, shape=new_shape)</div>
<div class="line"><span class="lineno"> 1493</span> </div>
<div class="line"><span class="lineno"> 1494</span>    repeats = -(-new_size // a.size)  <span class="comment"># ceil division</span></div>
<div class="line"><span class="lineno"> 1495</span>    a = concatenate((a,) * repeats)[:new_size]</div>
<div class="line"><span class="lineno"> 1496</span> </div>
<div class="line"><span class="lineno"> 1497</span>    <span class="keywordflow">return</span> reshape(a, new_shape)</div>
<div class="line"><span class="lineno"> 1498</span> </div>
<div class="line"><span class="lineno"> 1499</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a73b8ea6060ec94d63fafaddcbe139f4c" name="a73b8ea6060ec94d63fafaddcbe139f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b8ea6060ec94d63fafaddcbe139f4c">&#9670;&#160;</a></span>round_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.round_ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>decimals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Round an array to the given number of decimals.

See Also
--------
around : equivalent function; see for details.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3755</span><span class="keyword">def </span>round_(a, decimals=0, out=None):</div>
<div class="line"><span class="lineno"> 3756</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3757</span><span class="stringliteral">    Round an array to the given number of decimals.</span></div>
<div class="line"><span class="lineno"> 3758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3759</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3760</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3761</span><span class="stringliteral">    around : equivalent function; see for details.</span></div>
<div class="line"><span class="lineno"> 3762</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3763</span>    <span class="keywordflow">return</span> around(a, decimals=decimals, out=out)</div>
<div class="line"><span class="lineno"> 3764</span> </div>
<div class="line"><span class="lineno"> 3765</span> </div>
<div class="line"><span class="lineno"> 3766</span><span class="preprocessor">@array_function_dispatch(_prod_dispatcher, verify=False)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab22cfbbf9d1e32bb23d23824877c3026" name="ab22cfbbf9d1e32bb23d23824877c3026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22cfbbf9d1e32bb23d23824877c3026">&#9670;&#160;</a></span>searchsorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.searchsorted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>side</em> = <code>'left'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sorter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find indices where elements should be inserted to maintain order.

Find the indices into a sorted array `a` such that, if the
corresponding elements in `v` were inserted before the indices, the
order of `a` would be preserved.

Assuming that `a` is sorted:

======  ============================
`side`  returned index `i` satisfies
======  ============================
left    ``a[i-1] &lt; v &lt;= a[i]``
right   ``a[i-1] &lt;= v &lt; a[i]``
======  ============================

Parameters
----------
a : 1-D array_like
    Input array. If `sorter` is None, then it must be sorted in
    ascending order, otherwise `sorter` must be an array of indices
    that sort it.
v : array_like
    Values to insert into `a`.
side : {'left', 'right'}, optional
    If 'left', the index of the first suitable location found is given.
    If 'right', return the last such index.  If there is no suitable
    index, return either 0 or N (where N is the length of `a`).
sorter : 1-D array_like, optional
    Optional array of integer indices that sort array a into ascending
    order. They are typically the result of argsort.

    .. versionadded:: 1.7.0

Returns
-------
indices : int or array of ints
    Array of insertion points with the same shape as `v`,
    or an integer if `v` is a scalar.

See Also
--------
sort : Return a sorted copy of an array.
histogram : Produce histogram from 1-D data.

Notes
-----
Binary search is used to find the required insertion points.

As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing
`nan` values. The enhanced sort order is documented in `sort`.

This function uses the same algorithm as the builtin python `bisect.bisect_left`
(``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,
which is also vectorized in the `v` argument.

Examples
--------
&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3)
2
&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3, side='right')
3
&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
array([0, 5, 1, 2])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1346</span><span class="keyword">def </span>searchsorted(a, v, side=&#39;left&#39;, sorter=None):</div>
<div class="line"><span class="lineno"> 1347</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    Find indices where elements should be inserted to maintain order.</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    Find the indices into a sorted array `a` such that, if the</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    corresponding elements in `v` were inserted before the indices, the</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    order of `a` would be preserved.</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    Assuming that `a` is sorted:</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    ======  ============================</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    `side`  returned index `i` satisfies</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">    ======  ============================</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    left    ``a[i-1] &lt; v &lt;= a[i]``</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    right   ``a[i-1] &lt;= v &lt; a[i]``</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    ======  ============================</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    a : 1-D array_like</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">        Input array. If `sorter` is None, then it must be sorted in</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">        ascending order, otherwise `sorter` must be an array of indices</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">        that sort it.</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    v : array_like</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">        Values to insert into `a`.</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    side : {&#39;left&#39;, &#39;right&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">        If &#39;left&#39;, the index of the first suitable location found is given.</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">        If &#39;right&#39;, return the last such index.  If there is no suitable</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">        index, return either 0 or N (where N is the length of `a`).</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    sorter : 1-D array_like, optional</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">        Optional array of integer indices that sort array a into ascending</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">        order. They are typically the result of argsort.</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">    indices : int or array of ints</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">        Array of insertion points with the same shape as `v`,</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">        or an integer if `v` is a scalar.</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    sort : Return a sorted copy of an array.</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    histogram : Produce histogram from 1-D data.</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    Binary search is used to find the required insertion points.</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">    As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    `nan` values. The enhanced sort order is documented in `sort`.</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">    This function uses the same algorithm as the builtin python `bisect.bisect_left`</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    (``side=&#39;left&#39;``) and `bisect.bisect_right` (``side=&#39;right&#39;``) functions,</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">    which is also vectorized in the `v` argument.</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3)</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    2</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3, side=&#39;right&#39;)</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    3</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    array([0, 5, 1, 2])</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1413</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;searchsorted&#39;</span>, v, side=side, sorter=sorter)</div>
<div class="line"><span class="lineno"> 1414</span> </div>
<div class="line"><span class="lineno"> 1415</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa22b69964320c5aabb55d909c8780c9f" name="aa22b69964320c5aabb55d909c8780c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22b69964320c5aabb55d909c8780c9f">&#9670;&#160;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.shape </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the shape of an array.

Parameters
----------
a : array_like
    Input array.

Returns
-------
shape : tuple of ints
    The elements of the shape tuple give the lengths of the
    corresponding array dimensions.

See Also
--------
len : ``len(a)`` is equivalent to ``np.shape(a)[0]`` for N-D arrays with
      ``N&gt;=1``.
ndarray.shape : Equivalent array method.

Examples
--------
&gt;&gt;&gt; np.shape(np.eye(3))
(3, 3)
&gt;&gt;&gt; np.shape([[1, 3]])
(1, 2)
&gt;&gt;&gt; np.shape([0])
(1,)
&gt;&gt;&gt; np.shape(0)
()

&gt;&gt;&gt; a = np.array([(1, 2), (3, 4), (5, 6)],
...              dtype=[('x', 'i4'), ('y', 'i4')])
&gt;&gt;&gt; np.shape(a)
(3,)
&gt;&gt;&gt; a.shape
(3,)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1992</span><span class="keyword">def </span>shape(a):</div>
<div class="line"><span class="lineno"> 1993</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral">    Return the shape of an array.</span></div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral">    shape : tuple of ints</span></div>
<div class="line"><span class="lineno"> 2004</span><span class="stringliteral">        The elements of the shape tuple give the lengths of the</span></div>
<div class="line"><span class="lineno"> 2005</span><span class="stringliteral">        corresponding array dimensions.</span></div>
<div class="line"><span class="lineno"> 2006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2007</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2008</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">    len : ``len(a)`` is equivalent to ``np.shape(a)[0]`` for N-D arrays with</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral">          ``N&gt;=1``.</span></div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral">    ndarray.shape : Equivalent array method.</span></div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">    &gt;&gt;&gt; np.shape(np.eye(3))</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral">    (3, 3)</span></div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral">    &gt;&gt;&gt; np.shape([[1, 3]])</span></div>
<div class="line"><span class="lineno"> 2018</span><span class="stringliteral">    (1, 2)</span></div>
<div class="line"><span class="lineno"> 2019</span><span class="stringliteral">    &gt;&gt;&gt; np.shape([0])</span></div>
<div class="line"><span class="lineno"> 2020</span><span class="stringliteral">    (1,)</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral">    &gt;&gt;&gt; np.shape(0)</span></div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">    ()</span></div>
<div class="line"><span class="lineno"> 2023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2024</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([(1, 2), (3, 4), (5, 6)],</span></div>
<div class="line"><span class="lineno"> 2025</span><span class="stringliteral">    ...              dtype=[(&#39;x&#39;, &#39;i4&#39;), (&#39;y&#39;, &#39;i4&#39;)])</span></div>
<div class="line"><span class="lineno"> 2026</span><span class="stringliteral">    &gt;&gt;&gt; np.shape(a)</span></div>
<div class="line"><span class="lineno"> 2027</span><span class="stringliteral">    (3,)</span></div>
<div class="line"><span class="lineno"> 2028</span><span class="stringliteral">    &gt;&gt;&gt; a.shape</span></div>
<div class="line"><span class="lineno"> 2029</span><span class="stringliteral">    (3,)</span></div>
<div class="line"><span class="lineno"> 2030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2031</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2032</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2033</span>        result = a.shape</div>
<div class="line"><span class="lineno"> 2034</span>    <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 2035</span>        result = asarray(a).shape</div>
<div class="line"><span class="lineno"> 2036</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 2037</span> </div>
<div class="line"><span class="lineno"> 2038</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d731b579c770accbe47efa0d327b36e" name="a0d731b579c770accbe47efa0d327b36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d731b579c770accbe47efa0d327b36e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of elements along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which the elements are counted.  By default, give
    the total number of elements.

Returns
-------
element_count : int
    Number of elements along the specified axis.

See Also
--------
shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; np.size(a)
6
&gt;&gt;&gt; np.size(a,1)
3
&gt;&gt;&gt; np.size(a,0)
2</pre> <div class="fragment"><div class="line"><span class="lineno"> 3195</span><span class="keyword">def </span>size(a, axis=None):</div>
<div class="line"><span class="lineno"> 3196</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3197</span><span class="stringliteral">    Return the number of elements along a given axis.</span></div>
<div class="line"><span class="lineno"> 3198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3199</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3200</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral">        Axis along which the elements are counted.  By default, give</span></div>
<div class="line"><span class="lineno"> 3205</span><span class="stringliteral">        the total number of elements.</span></div>
<div class="line"><span class="lineno"> 3206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3207</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3208</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3209</span><span class="stringliteral">    element_count : int</span></div>
<div class="line"><span class="lineno"> 3210</span><span class="stringliteral">        Number of elements along the specified axis.</span></div>
<div class="line"><span class="lineno"> 3211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3212</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3213</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3214</span><span class="stringliteral">    shape : dimensions of array</span></div>
<div class="line"><span class="lineno"> 3215</span><span class="stringliteral">    ndarray.shape : dimensions of array</span></div>
<div class="line"><span class="lineno"> 3216</span><span class="stringliteral">    ndarray.size : number of elements in array</span></div>
<div class="line"><span class="lineno"> 3217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3218</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3219</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3220</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral">    &gt;&gt;&gt; np.size(a)</span></div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral">    6</span></div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral">    &gt;&gt;&gt; np.size(a,1)</span></div>
<div class="line"><span class="lineno"> 3224</span><span class="stringliteral">    3</span></div>
<div class="line"><span class="lineno"> 3225</span><span class="stringliteral">    &gt;&gt;&gt; np.size(a,0)</span></div>
<div class="line"><span class="lineno"> 3226</span><span class="stringliteral">    2</span></div>
<div class="line"><span class="lineno"> 3227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3228</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3229</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3230</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3231</span>            <span class="keywordflow">return</span> a.size</div>
<div class="line"><span class="lineno"> 3232</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 3233</span>            <span class="keywordflow">return</span> asarray(a).size</div>
<div class="line"><span class="lineno"> 3234</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3235</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3236</span>            <span class="keywordflow">return</span> a.shape[axis]</div>
<div class="line"><span class="lineno"> 3237</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 3238</span>            <span class="keywordflow">return</span> asarray(a).shape[axis]</div>
<div class="line"><span class="lineno"> 3239</span> </div>
<div class="line"><span class="lineno"> 3240</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a949b19d68c5a9c2b1e5d4bc8d4aee777" name="a949b19d68c5a9c2b1e5d4bc8d4aee777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949b19d68c5a9c2b1e5d4bc8d4aee777">&#9670;&#160;</a></span>sometrue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.sometrue </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether some values are true.

Refer to `any` for full documentation.

See Also
--------
any : equivalent function; see for details.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3791</span><span class="keyword">def </span>sometrue(*args, **kwargs):</div>
<div class="line"><span class="lineno"> 3792</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3793</span><span class="stringliteral">    Check whether some values are true.</span></div>
<div class="line"><span class="lineno"> 3794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3795</span><span class="stringliteral">    Refer to `any` for full documentation.</span></div>
<div class="line"><span class="lineno"> 3796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3797</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3798</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3799</span><span class="stringliteral">    any : equivalent function; see for details.</span></div>
<div class="line"><span class="lineno"> 3800</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3801</span>    <span class="keywordflow">return</span> any(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 3802</span> </div>
<div class="line"><span class="lineno"> 3803</span> </div>
<div class="line"><span class="lineno"> 3804</span><span class="preprocessor">@array_function_dispatch(_all_dispatcher, verify=False)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a158463af46fc865a8726ebc234601228" name="a158463af46fc865a8726ebc234601228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158463af46fc865a8726ebc234601228">&#9670;&#160;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sorted copy of an array.

Parameters
----------
a : array_like
    Array to be sorted.
axis : int or None, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort or radix sort under the covers and, in general,
    the actual implementation will vary with data type. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.

order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.
partition : Partial sort.

Notes
-----
The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The four algorithms implemented in NumPy have the following
properties:

=========== ======= ============= ============ ========
   kind      speed   worst case    work space   stable
=========== ======= ============= ============ ========
'quicksort'    1     O(n^2)            0          no
'heapsort'     3     O(n*log(n))       0          no
'mergesort'    2     O(n*log(n))      ~n/2        yes
'timsort'      2     O(n*log(n))      ~n/2        yes
=========== ======= ============= ============ ========

.. note:: The datatype determines which of 'mergesort' or 'timsort'
   is actually used, even if 'mergesort' is specified. User selection
   at a finer scale is not currently available.

All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.

The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.

Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
values are sorted to the end. The extended sort order is:

  * Real: [R, nan]
  * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]

where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.

.. versionadded:: 1.12.0

quicksort has been changed to `introsort &lt;https://en.wikipedia.org/wiki/Introsort&gt;`_.
When sorting does not make enough progress it switches to
`heapsort &lt;https://en.wikipedia.org/wiki/Heapsort&gt;`_.
This implementation makes quicksort O(n*log(n)) in the worst case.

'stable' automatically chooses the best stable sorting algorithm
for the data type being sorted.
It, along with 'mergesort' is currently mapped to
`timsort &lt;https://en.wikipedia.org/wiki/Timsort&gt;`_
or `radix sort &lt;https://en.wikipedia.org/wiki/Radix_sort&gt;`_
depending on the data type.
API forward compatibility currently limits the
ability to select the implementation and it is hardwired for the different
data types.

.. versionadded:: 1.17.0

Timsort is added for better performance on already or nearly
sorted data. On random data timsort is almost identical to
mergesort. It is now used for stable sort while quicksort is still the
default sort if none is chosen. For timsort details, refer to
`CPython listsort.txt &lt;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&gt;`_.
'mergesort' and 'stable' are mapped to radix sort for integer data types. Radix sort is an
O(n) sort instead of O(n log n).

.. versionchanged:: 1.18.0

NaT now sorts to the end of arrays for consistency with NaN.

Examples
--------
&gt;&gt;&gt; a = np.array([[1,4],[3,1]])
&gt;&gt;&gt; np.sort(a)                # sort along the last axis
array([[1, 4],
       [1, 3]])
&gt;&gt;&gt; np.sort(a, axis=None)     # sort the flattened array
array([1, 1, 3, 4])
&gt;&gt;&gt; np.sort(a, axis=0)        # sort along the first axis
array([[1, 1],
       [3, 4]])

Use the `order` keyword to specify a field to use when sorting a
structured array:

&gt;&gt;&gt; dtype = [('name', 'S10'), ('height', float), ('age', int)]
&gt;&gt;&gt; values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
...           ('Galahad', 1.7, 38)]
&gt;&gt;&gt; a = np.array(values, dtype=dtype)       # create a structured array
&gt;&gt;&gt; np.sort(a, order='height')                        # doctest: +SKIP
array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
       ('Lancelot', 1.8999999999999999, 38)],
      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])

Sort by age, then height if ages are equal:

&gt;&gt;&gt; np.sort(a, order=['age', 'height'])               # doctest: +SKIP
array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
       ('Arthur', 1.8, 41)],
      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])</pre> <div class="fragment"><div class="line"><span class="lineno">  879</span><span class="keyword">def </span>sort(a, axis=-1, kind=None, order=None):</div>
<div class="line"><span class="lineno">  880</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    Return a sorted copy of an array.</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">        Array to be sorted.</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        Axis along which to sort. If None, the array is flattened before</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        sorting. The default is -1, which sorts along the last axis.</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">        Sorting algorithm. The default is &#39;quicksort&#39;. Note that both &#39;stable&#39;</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">        and &#39;mergesort&#39; use timsort or radix sort under the covers and, in general,</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">        the actual implementation will vary with data type. The &#39;mergesort&#39; option</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">        is retained for backwards compatibility.</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">        .. versionchanged:: 1.15.0.</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">           The &#39;stable&#39; option was added.</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    order : str or list of str, optional</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">        When `a` is an array with fields defined, this argument specifies</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">        which fields to compare first, second, etc.  A single field can</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">        be specified as a string, and not all fields need be specified,</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">        but unspecified fields will still be used, in the order in which</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">        they come up in the dtype, to break ties.</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    sorted_array : ndarray</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        Array of the same type and shape as `a`.</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    ndarray.sort : Method to sort an array in-place.</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    argsort : Indirect sort.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    lexsort : Indirect stable sort on multiple keys.</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    searchsorted : Find elements in a sorted array.</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    partition : Partial sort.</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    The various sorting algorithms are characterized by their average speed,</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    worst case performance, work space size, and whether they are stable. A</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    stable sort keeps items with the same key in the same relative</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    order. The four algorithms implemented in NumPy have the following</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    properties:</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    =========== ======= ============= ============ ========</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">       kind      speed   worst case    work space   stable</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    =========== ======= ============= ============ ========</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    &#39;quicksort&#39;    1     O(n^2)            0          no</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    &#39;heapsort&#39;     3     O(n*log(n))       0          no</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    &#39;mergesort&#39;    2     O(n*log(n))      ~n/2        yes</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    &#39;timsort&#39;      2     O(n*log(n))      ~n/2        yes</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    =========== ======= ============= ============ ========</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    .. note:: The datatype determines which of &#39;mergesort&#39; or &#39;timsort&#39;</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">       is actually used, even if &#39;mergesort&#39; is specified. User selection</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">       at a finer scale is not currently available.</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    All the sort algorithms make temporary copies of the data when</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    sorting along any but the last axis.  Consequently, sorting along</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    the last axis is faster and uses less space than sorting along</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    any other axis.</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    The sort order for complex numbers is lexicographic. If both the real</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">    and imaginary parts are non-nan then the order is determined by the</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    real parts except when they are equal, in which case the order is</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    determined by the imaginary parts.</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    Previous to numpy 1.4.0 sorting real and complex arrays containing nan</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    values are sorted to the end. The extended sort order is:</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">      * Real: [R, nan]</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    where R is a non-nan real value. Complex values with the same nan</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">    placements are sorted according to the non-nan part if it exists.</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    Non-nan values are sorted as before.</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    .. versionadded:: 1.12.0</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    quicksort has been changed to `introsort &lt;https://en.wikipedia.org/wiki/Introsort&gt;`_.</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    When sorting does not make enough progress it switches to</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    `heapsort &lt;https://en.wikipedia.org/wiki/Heapsort&gt;`_.</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    This implementation makes quicksort O(n*log(n)) in the worst case.</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    &#39;stable&#39; automatically chooses the best stable sorting algorithm</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    for the data type being sorted.</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    It, along with &#39;mergesort&#39; is currently mapped to</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    `timsort &lt;https://en.wikipedia.org/wiki/Timsort&gt;`_</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">    or `radix sort &lt;https://en.wikipedia.org/wiki/Radix_sort&gt;`_</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    depending on the data type.</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">    API forward compatibility currently limits the</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    ability to select the implementation and it is hardwired for the different</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    data types.</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    Timsort is added for better performance on already or nearly</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    sorted data. On random data timsort is almost identical to</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    mergesort. It is now used for stable sort while quicksort is still the</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    default sort if none is chosen. For timsort details, refer to</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    `CPython listsort.txt &lt;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&gt;`_.</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    &#39;mergesort&#39; and &#39;stable&#39; are mapped to radix sort for integer data types. Radix sort is an</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    O(n) sort instead of O(n log n).</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">    .. versionchanged:: 1.18.0</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    NaT now sorts to the end of arrays for consistency with NaN.</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1,4],[3,1]])</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    &gt;&gt;&gt; np.sort(a)                # sort along the last axis</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    array([[1, 4],</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">           [1, 3]])</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    &gt;&gt;&gt; np.sort(a, axis=None)     # sort the flattened array</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    array([1, 1, 3, 4])</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    &gt;&gt;&gt; np.sort(a, axis=0)        # sort along the first axis</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    array([[1, 1],</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">           [3, 4]])</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    Use the `order` keyword to specify a field to use when sorting a</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    structured array:</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    &gt;&gt;&gt; dtype = [(&#39;name&#39;, &#39;S10&#39;), (&#39;height&#39;, float), (&#39;age&#39;, int)]</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    &gt;&gt;&gt; values = [(&#39;Arthur&#39;, 1.8, 41), (&#39;Lancelot&#39;, 1.9, 38),</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    ...           (&#39;Galahad&#39;, 1.7, 38)]</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array(values, dtype=dtype)       # create a structured array</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    &gt;&gt;&gt; np.sort(a, order=&#39;height&#39;)                        # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">           (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">          dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    Sort by age, then height if ages are equal:</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    &gt;&gt;&gt; np.sort(a, order=[&#39;age&#39;, &#39;height&#39;])               # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">           (&#39;Arthur&#39;, 1.8, 41)],</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">          dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1024</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1025</span>        <span class="comment"># flatten returns (1, N) for np.matrix, so always use the last axis</span></div>
<div class="line"><span class="lineno"> 1026</span>        a = asanyarray(a).flatten()</div>
<div class="line"><span class="lineno"> 1027</span>        axis = -1</div>
<div class="line"><span class="lineno"> 1028</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1029</span>        a = asanyarray(a).copy(order=<span class="stringliteral">&quot;K&quot;</span>)</div>
<div class="line"><span class="lineno"> 1030</span>    a.sort(axis=axis, kind=kind, order=order)</div>
<div class="line"><span class="lineno"> 1031</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno"> 1032</span> </div>
<div class="line"><span class="lineno"> 1033</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab6f8693d70065f98788a77d1bace3923" name="ab6f8693d70065f98788a77d1bace3923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f8693d70065f98788a77d1bace3923">&#9670;&#160;</a></span>squeeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.squeeze </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove axes of length one from `a`.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    .. versionadded:: 1.7.0

    Selects a subset of the entries of length one in the
    shape. If an axis is selected with shape entry greater than
    one, an error is raised.

Returns
-------
squeezed : ndarray
    The input array, but with all or a subset of the
    dimensions of length 1 removed. This is always `a` itself
    or a view into `a`. Note that if all axes are squeezed,
    the result is a 0d array and not a scalar.

Raises
------
ValueError
    If `axis` is not None, and an axis being squeezed is not of length 1

See Also
--------
expand_dims : The inverse operation, adding entries of length one
reshape : Insert, remove, and combine dimensions, and resize existing ones

Examples
--------
&gt;&gt;&gt; x = np.array([[[0], [1], [2]]])
&gt;&gt;&gt; x.shape
(1, 3, 1)
&gt;&gt;&gt; np.squeeze(x).shape
(3,)
&gt;&gt;&gt; np.squeeze(x, axis=0).shape
(3, 1)
&gt;&gt;&gt; np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size not equal to one
&gt;&gt;&gt; np.squeeze(x, axis=2).shape
(1, 3)
&gt;&gt;&gt; x = np.array([[1234]])
&gt;&gt;&gt; x.shape
(1, 1)
&gt;&gt;&gt; np.squeeze(x)
array(1234)  # 0d array
&gt;&gt;&gt; np.squeeze(x).shape
()
&gt;&gt;&gt; np.squeeze(x)[()]
1234</pre> <div class="fragment"><div class="line"><span class="lineno"> 1505</span><span class="keyword">def </span>squeeze(a, axis=None):</div>
<div class="line"><span class="lineno"> 1506</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    Remove axes of length one from `a`.</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        Selects a subset of the entries of length one in the</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">        shape. If an axis is selected with shape entry greater than</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">        one, an error is raised.</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    squeezed : ndarray</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        The input array, but with all or a subset of the</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">        dimensions of length 1 removed. This is always `a` itself</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">        or a view into `a`. Note that if all axes are squeezed,</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">        the result is a 0d array and not a scalar.</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">        If `axis` is not None, and an axis being squeezed is not of length 1</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">    expand_dims : The inverse operation, adding entries of length one</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">    reshape : Insert, remove, and combine dimensions, and resize existing ones</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[[0], [1], [2]]])</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    &gt;&gt;&gt; x.shape</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    (1, 3, 1)</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    &gt;&gt;&gt; np.squeeze(x).shape</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    (3,)</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    &gt;&gt;&gt; np.squeeze(x, axis=0).shape</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">    (3, 1)</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    &gt;&gt;&gt; np.squeeze(x, axis=1).shape</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    ValueError: cannot select an axis to squeeze out which has size not equal to one</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    &gt;&gt;&gt; np.squeeze(x, axis=2).shape</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    (1, 3)</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[1234]])</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    &gt;&gt;&gt; x.shape</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    (1, 1)</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    &gt;&gt;&gt; np.squeeze(x)</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    array(1234)  # 0d array</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    &gt;&gt;&gt; np.squeeze(x).shape</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    ()</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">    &gt;&gt;&gt; np.squeeze(x)[()]</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    1234</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1564</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1565</span>        squeeze = a.squeeze</div>
<div class="line"><span class="lineno"> 1566</span>    <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 1567</span>        <span class="keywordflow">return</span> _wrapit(a, <span class="stringliteral">&#39;squeeze&#39;</span>, axis=axis)</div>
<div class="line"><span class="lineno"> 1568</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1569</span>        <span class="keywordflow">return</span> squeeze()</div>
<div class="line"><span class="lineno"> 1570</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1571</span>        <span class="keywordflow">return</span> squeeze(axis=axis)</div>
<div class="line"><span class="lineno"> 1572</span> </div>
<div class="line"><span class="lineno"> 1573</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acd08ae9b4e902a5874d0e8b87501578f" name="acd08ae9b4e902a5874d0e8b87501578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd08ae9b4e902a5874d0e8b87501578f">&#9670;&#160;</a></span>std()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.std </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the standard deviation along the specified axis.

Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Calculate the standard deviation of these values.
axis : None or int or tuple of ints, optional
    Axis or axes along which the standard deviation is computed. The
    default is to compute the standard deviation of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a standard deviation is performed over
    multiple axes, instead of a single axis or all the axes as before.
dtype : dtype, optional
    Type to use in computing the standard deviation. For arrays of
    integer type the default is float64, for arrays of float types it is
    the same as the array type.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type (of the calculated
    values) will be cast if necessary.
ddof : int, optional
    Means Delta Degrees of Freedom.  The divisor used in calculations
    is ``N - ddof``, where ``N`` represents the number of elements.
    By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `std` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

where : array_like of bool, optional
    Elements to include in the standard deviation.
    See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.20.0

Returns
-------
standard_deviation : ndarray, see dtype parameter above.
    If `out` is None, return a new array containing the standard deviation,
    otherwise return a reference to the output array.

See Also
--------
var, mean, nanmean, nanstd, nanvar
:ref:`ufuncs-output-type`

Notes
-----
The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., ``std = sqrt(mean(x))``, where
``x = abs(a - a.mean())**2``.

The average squared deviation is typically calculated as ``x.sum() / N``,
where ``N = len(x)``. If, however, `ddof` is specified, the divisor
``N - ddof`` is used instead. In standard statistical practice, ``ddof=1``
provides an unbiased estimator of the variance of the infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables. The standard deviation computed in this
function is the square root of the estimated variance, so even with
``ddof=1``, it will not be an unbiased estimate of the standard deviation
per se.

Note that, for complex numbers, `std` takes the absolute
value before squaring, so that the result is always real and nonnegative.

For floating-point input, the *std* is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the `dtype` keyword can
alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.std(a)
1.1180339887498949 # may vary
&gt;&gt;&gt; np.std(a, axis=0)
array([1.,  1.])
&gt;&gt;&gt; np.std(a, axis=1)
array([0.5,  0.5])

In single precision, std() can be inaccurate:

&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)
&gt;&gt;&gt; a[0, :] = 1.0
&gt;&gt;&gt; a[1, :] = 0.1
&gt;&gt;&gt; np.std(a)
0.45000005

Computing the standard deviation in float64 is more accurate:

&gt;&gt;&gt; np.std(a, dtype=np.float64)
0.44999999925494177 # may vary

Specifying a where argument:

&gt;&gt;&gt; a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
&gt;&gt;&gt; np.std(a)
2.614064523559687 # may vary
&gt;&gt;&gt; np.std(a, where=[[True], [True], [False]])
2.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 3475</span>        where=np._NoValue):</div>
<div class="line"><span class="lineno"> 3476</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3477</span><span class="stringliteral">    Compute the standard deviation along the specified axis.</span></div>
<div class="line"><span class="lineno"> 3478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3479</span><span class="stringliteral">    Returns the standard deviation, a measure of the spread of a distribution,</span></div>
<div class="line"><span class="lineno"> 3480</span><span class="stringliteral">    of the array elements. The standard deviation is computed for the</span></div>
<div class="line"><span class="lineno"> 3481</span><span class="stringliteral">    flattened array by default, otherwise over the specified axis.</span></div>
<div class="line"><span class="lineno"> 3482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3483</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3484</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3485</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3486</span><span class="stringliteral">        Calculate the standard deviation of these values.</span></div>
<div class="line"><span class="lineno"> 3487</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 3488</span><span class="stringliteral">        Axis or axes along which the standard deviation is computed. The</span></div>
<div class="line"><span class="lineno"> 3489</span><span class="stringliteral">        default is to compute the standard deviation of the flattened array.</span></div>
<div class="line"><span class="lineno"> 3490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3491</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 3492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3493</span><span class="stringliteral">        If this is a tuple of ints, a standard deviation is performed over</span></div>
<div class="line"><span class="lineno"> 3494</span><span class="stringliteral">        multiple axes, instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 3495</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 3496</span><span class="stringliteral">        Type to use in computing the standard deviation. For arrays of</span></div>
<div class="line"><span class="lineno"> 3497</span><span class="stringliteral">        integer type the default is float64, for arrays of float types it is</span></div>
<div class="line"><span class="lineno"> 3498</span><span class="stringliteral">        the same as the array type.</span></div>
<div class="line"><span class="lineno"> 3499</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3500</span><span class="stringliteral">        Alternative output array in which to place the result. It must have</span></div>
<div class="line"><span class="lineno"> 3501</span><span class="stringliteral">        the same shape as the expected output but the type (of the calculated</span></div>
<div class="line"><span class="lineno"> 3502</span><span class="stringliteral">        values) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 3503</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 3504</span><span class="stringliteral">        Means Delta Degrees of Freedom.  The divisor used in calculations</span></div>
<div class="line"><span class="lineno"> 3505</span><span class="stringliteral">        is ``N - ddof``, where ``N`` represents the number of elements.</span></div>
<div class="line"><span class="lineno"> 3506</span><span class="stringliteral">        By default `ddof` is zero.</span></div>
<div class="line"><span class="lineno"> 3507</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 3508</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 3509</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 3510</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 3511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3512</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 3513</span><span class="stringliteral">        passed through to the `std` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 3514</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 3515</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 3516</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 3517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3518</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 3519</span><span class="stringliteral">        Elements to include in the standard deviation.</span></div>
<div class="line"><span class="lineno"> 3520</span><span class="stringliteral">        See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 3521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3522</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno"> 3523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3524</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3525</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3526</span><span class="stringliteral">    standard_deviation : ndarray, see dtype parameter above.</span></div>
<div class="line"><span class="lineno"> 3527</span><span class="stringliteral">        If `out` is None, return a new array containing the standard deviation,</span></div>
<div class="line"><span class="lineno"> 3528</span><span class="stringliteral">        otherwise return a reference to the output array.</span></div>
<div class="line"><span class="lineno"> 3529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3530</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3531</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3532</span><span class="stringliteral">    var, mean, nanmean, nanstd, nanvar</span></div>
<div class="line"><span class="lineno"> 3533</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 3534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3535</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3536</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3537</span><span class="stringliteral">    The standard deviation is the square root of the average of the squared</span></div>
<div class="line"><span class="lineno"> 3538</span><span class="stringliteral">    deviations from the mean, i.e., ``std = sqrt(mean(x))``, where</span></div>
<div class="line"><span class="lineno"> 3539</span><span class="stringliteral">    ``x = abs(a - a.mean())**2``.</span></div>
<div class="line"><span class="lineno"> 3540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3541</span><span class="stringliteral">    The average squared deviation is typically calculated as ``x.sum() / N``,</span></div>
<div class="line"><span class="lineno"> 3542</span><span class="stringliteral">    where ``N = len(x)``. If, however, `ddof` is specified, the divisor</span></div>
<div class="line"><span class="lineno"> 3543</span><span class="stringliteral">    ``N - ddof`` is used instead. In standard statistical practice, ``ddof=1``</span></div>
<div class="line"><span class="lineno"> 3544</span><span class="stringliteral">    provides an unbiased estimator of the variance of the infinite population.</span></div>
<div class="line"><span class="lineno"> 3545</span><span class="stringliteral">    ``ddof=0`` provides a maximum likelihood estimate of the variance for</span></div>
<div class="line"><span class="lineno"> 3546</span><span class="stringliteral">    normally distributed variables. The standard deviation computed in this</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral">    function is the square root of the estimated variance, so even with</span></div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral">    ``ddof=1``, it will not be an unbiased estimate of the standard deviation</span></div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">    per se.</span></div>
<div class="line"><span class="lineno"> 3550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3551</span><span class="stringliteral">    Note that, for complex numbers, `std` takes the absolute</span></div>
<div class="line"><span class="lineno"> 3552</span><span class="stringliteral">    value before squaring, so that the result is always real and nonnegative.</span></div>
<div class="line"><span class="lineno"> 3553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3554</span><span class="stringliteral">    For floating-point input, the *std* is computed using the same</span></div>
<div class="line"><span class="lineno"> 3555</span><span class="stringliteral">    precision the input has. Depending on the input data, this can cause</span></div>
<div class="line"><span class="lineno"> 3556</span><span class="stringliteral">    the results to be inaccurate, especially for float32 (see example below).</span></div>
<div class="line"><span class="lineno"> 3557</span><span class="stringliteral">    Specifying a higher-accuracy accumulator using the `dtype` keyword can</span></div>
<div class="line"><span class="lineno"> 3558</span><span class="stringliteral">    alleviate this issue.</span></div>
<div class="line"><span class="lineno"> 3559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3560</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3561</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3562</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 3563</span><span class="stringliteral">    &gt;&gt;&gt; np.std(a)</span></div>
<div class="line"><span class="lineno"> 3564</span><span class="stringliteral">    1.1180339887498949 # may vary</span></div>
<div class="line"><span class="lineno"> 3565</span><span class="stringliteral">    &gt;&gt;&gt; np.std(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral">    array([1.,  1.])</span></div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">    &gt;&gt;&gt; np.std(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 3568</span><span class="stringliteral">    array([0.5,  0.5])</span></div>
<div class="line"><span class="lineno"> 3569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3570</span><span class="stringliteral">    In single precision, std() can be inaccurate:</span></div>
<div class="line"><span class="lineno"> 3571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3572</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)</span></div>
<div class="line"><span class="lineno"> 3573</span><span class="stringliteral">    &gt;&gt;&gt; a[0, :] = 1.0</span></div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral">    &gt;&gt;&gt; a[1, :] = 0.1</span></div>
<div class="line"><span class="lineno"> 3575</span><span class="stringliteral">    &gt;&gt;&gt; np.std(a)</span></div>
<div class="line"><span class="lineno"> 3576</span><span class="stringliteral">    0.45000005</span></div>
<div class="line"><span class="lineno"> 3577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3578</span><span class="stringliteral">    Computing the standard deviation in float64 is more accurate:</span></div>
<div class="line"><span class="lineno"> 3579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3580</span><span class="stringliteral">    &gt;&gt;&gt; np.std(a, dtype=np.float64)</span></div>
<div class="line"><span class="lineno"> 3581</span><span class="stringliteral">    0.44999999925494177 # may vary</span></div>
<div class="line"><span class="lineno"> 3582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3583</span><span class="stringliteral">    Specifying a where argument:</span></div>
<div class="line"><span class="lineno"> 3584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3585</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])</span></div>
<div class="line"><span class="lineno"> 3586</span><span class="stringliteral">    &gt;&gt;&gt; np.std(a)</span></div>
<div class="line"><span class="lineno"> 3587</span><span class="stringliteral">    2.614064523559687 # may vary</span></div>
<div class="line"><span class="lineno"> 3588</span><span class="stringliteral">    &gt;&gt;&gt; np.std(a, where=[[True], [True], [False]])</span></div>
<div class="line"><span class="lineno"> 3589</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 3590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3591</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3592</span>    kwargs = {}</div>
<div class="line"><span class="lineno"> 3593</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 3594</span>        kwargs[<span class="stringliteral">&#39;keepdims&#39;</span>] = keepdims</div>
<div class="line"><span class="lineno"> 3595</span>    <span class="keywordflow">if</span> where <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 3596</span>        kwargs[<span class="stringliteral">&#39;where&#39;</span>] = where</div>
<div class="line"><span class="lineno"> 3597</span>    <span class="keywordflow">if</span> type(a) <span class="keywordflow">is</span> <span class="keywordflow">not</span> mu.ndarray:</div>
<div class="line"><span class="lineno"> 3598</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3599</span>            std = a.std</div>
<div class="line"><span class="lineno"> 3600</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 3601</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 3602</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3603</span>            <span class="keywordflow">return</span> std(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)</div>
<div class="line"><span class="lineno"> 3604</span> </div>
<div class="line"><span class="lineno"> 3605</span>    <span class="keywordflow">return</span> _methods._std(a, axis=axis, dtype=dtype, out=out, ddof=ddof,</div>
<div class="line"><span class="lineno"> 3606</span>                         **kwargs)</div>
<div class="line"><span class="lineno"> 3607</span> </div>
<div class="line"><span class="lineno"> 3608</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a51411b3b0c037cf12ac140486f46cfd9" name="a51411b3b0c037cf12ac140486f46cfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51411b3b0c037cf12ac140486f46cfd9">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.sum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sum of array elements over a given axis.

Parameters
----------
a : array_like
    Elements to sum.
axis : None or int or tuple of ints, optional
    Axis or axes along which a sum is performed.  The default,
    axis=None, will sum all of the elements of the input array.  If
    axis is negative it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, a sum is performed on all of the axes
    specified in the tuple instead of a single axis or all the axes as
    before.
dtype : dtype, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  The dtype of `a` is used by default unless `a`
    has an integer dtype of less precision than the default platform
    integer.  In that case, if `a` is signed then the platform integer
    is used while if `a` is unsigned then an unsigned integer of the
    same precision as the platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `sum` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.
initial : scalar, optional
    Starting value for the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to include in the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.17.0

Returns
-------
sum_along_axis : ndarray
    An array with the same shape as `a`, with the specified
    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
    is returned.  If an output array is specified, a reference to
    `out` is returned.

See Also
--------
ndarray.sum : Equivalent method.

add.reduce : Equivalent functionality of `add`.

cumsum : Cumulative sum of array elements.

trapz : Integration of array values using the composite trapezoidal rule.

mean, average

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

The sum of an empty array is the neutral element 0:

&gt;&gt;&gt; np.sum([])
0.0

For floating point numbers the numerical precision of sum (and
``np.add.reduce``) is in general limited by directly adding each number
individually to the result causing rounding errors in every step.
However, often numpy will use a  numerically better approach (partial
pairwise summation) leading to improved precision in many use-cases.
This improved precision is always provided when no ``axis`` is given.
When ``axis`` is given, it will depend on which axis is summed.
Technically, to provide the best speed possible, the improved precision
is only used when the summation is along the fast axis in memory.
Note that the exact precision may vary depending on other parameters.
In contrast to NumPy, Python's ``math.fsum`` function uses a slower but
more precise approach to summation.
Especially when summing a large number of lower precision floating point
numbers, such as ``float32``, numerical errors can become significant.
In such cases it can be advisable to use `dtype="float64"` to use a higher
precision for the output.

Examples
--------
&gt;&gt;&gt; np.sum([0.5, 1.5])
2.0
&gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
1
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]])
6
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)
array([0, 6])
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)
array([1, 5])
&gt;&gt;&gt; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)
array([1., 5.])

If the accumulator is too small, overflow occurs:

&gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)
-128

You can also start the sum with a value other than zero:

&gt;&gt;&gt; np.sum([10], initial=5)
15
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2190</span>        initial=np._NoValue, where=np._NoValue):</div>
<div class="line"><span class="lineno"> 2191</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2192</span><span class="stringliteral">    Sum of array elements over a given axis.</span></div>
<div class="line"><span class="lineno"> 2193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2194</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2195</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2196</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2197</span><span class="stringliteral">        Elements to sum.</span></div>
<div class="line"><span class="lineno"> 2198</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 2199</span><span class="stringliteral">        Axis or axes along which a sum is performed.  The default,</span></div>
<div class="line"><span class="lineno"> 2200</span><span class="stringliteral">        axis=None, will sum all of the elements of the input array.  If</span></div>
<div class="line"><span class="lineno"> 2201</span><span class="stringliteral">        axis is negative it counts from the last to the first axis.</span></div>
<div class="line"><span class="lineno"> 2202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2203</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral">        If axis is a tuple of ints, a sum is performed on all of the axes</span></div>
<div class="line"><span class="lineno"> 2206</span><span class="stringliteral">        specified in the tuple instead of a single axis or all the axes as</span></div>
<div class="line"><span class="lineno"> 2207</span><span class="stringliteral">        before.</span></div>
<div class="line"><span class="lineno"> 2208</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral">        The type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral">        elements are summed.  The dtype of `a` is used by default unless `a`</span></div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">        has an integer dtype of less precision than the default platform</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral">        integer.  In that case, if `a` is signed then the platform integer</span></div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral">        is used while if `a` is unsigned then an unsigned integer of the</span></div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">        same precision as the platform integer is used.</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">        Alternative output array in which to place the result. It must have</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral">        the same shape as the expected output, but the type of the output</span></div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">        values will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 2222</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral">        passed through to the `sum` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">        Starting value for the sum. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">        .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral">        Elements to include in the sum. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">    sum_along_axis : ndarray</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">        An array with the same shape as `a`, with the specified</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">        is returned.  If an output array is specified, a reference to</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral">        `out` is returned.</span></div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral">    ndarray.sum : Equivalent method.</span></div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral">    add.reduce : Equivalent functionality of `add`.</span></div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">    cumsum : Cumulative sum of array elements.</span></div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">    trapz : Integration of array values using the composite trapezoidal rule.</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral">    mean, average</span></div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral">    Arithmetic is modular when using integer types, and no error is</span></div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral">    raised on overflow.</span></div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral">    The sum of an empty array is the neutral element 0:</span></div>
<div class="line"><span class="lineno"> 2265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2266</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([])</span></div>
<div class="line"><span class="lineno"> 2267</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 2268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2269</span><span class="stringliteral">    For floating point numbers the numerical precision of sum (and</span></div>
<div class="line"><span class="lineno"> 2270</span><span class="stringliteral">    ``np.add.reduce``) is in general limited by directly adding each number</span></div>
<div class="line"><span class="lineno"> 2271</span><span class="stringliteral">    individually to the result causing rounding errors in every step.</span></div>
<div class="line"><span class="lineno"> 2272</span><span class="stringliteral">    However, often numpy will use a  numerically better approach (partial</span></div>
<div class="line"><span class="lineno"> 2273</span><span class="stringliteral">    pairwise summation) leading to improved precision in many use-cases.</span></div>
<div class="line"><span class="lineno"> 2274</span><span class="stringliteral">    This improved precision is always provided when no ``axis`` is given.</span></div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral">    When ``axis`` is given, it will depend on which axis is summed.</span></div>
<div class="line"><span class="lineno"> 2276</span><span class="stringliteral">    Technically, to provide the best speed possible, the improved precision</span></div>
<div class="line"><span class="lineno"> 2277</span><span class="stringliteral">    is only used when the summation is along the fast axis in memory.</span></div>
<div class="line"><span class="lineno"> 2278</span><span class="stringliteral">    Note that the exact precision may vary depending on other parameters.</span></div>
<div class="line"><span class="lineno"> 2279</span><span class="stringliteral">    In contrast to NumPy, Python&#39;s ``math.fsum`` function uses a slower but</span></div>
<div class="line"><span class="lineno"> 2280</span><span class="stringliteral">    more precise approach to summation.</span></div>
<div class="line"><span class="lineno"> 2281</span><span class="stringliteral">    Especially when summing a large number of lower precision floating point</span></div>
<div class="line"><span class="lineno"> 2282</span><span class="stringliteral">    numbers, such as ``float32``, numerical errors can become significant.</span></div>
<div class="line"><span class="lineno"> 2283</span><span class="stringliteral">    In such cases it can be advisable to use `dtype=&quot;float64&quot;` to use a higher</span></div>
<div class="line"><span class="lineno"> 2284</span><span class="stringliteral">    precision for the output.</span></div>
<div class="line"><span class="lineno"> 2285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2286</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2287</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2288</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([0.5, 1.5])</span></div>
<div class="line"><span class="lineno"> 2289</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 2290</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)</span></div>
<div class="line"><span class="lineno"> 2291</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno"> 2292</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]])</span></div>
<div class="line"><span class="lineno"> 2293</span><span class="stringliteral">    6</span></div>
<div class="line"><span class="lineno"> 2294</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)</span></div>
<div class="line"><span class="lineno"> 2295</span><span class="stringliteral">    array([0, 6])</span></div>
<div class="line"><span class="lineno"> 2296</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)</span></div>
<div class="line"><span class="lineno"> 2297</span><span class="stringliteral">    array([1, 5])</span></div>
<div class="line"><span class="lineno"> 2298</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)</span></div>
<div class="line"><span class="lineno"> 2299</span><span class="stringliteral">    array([1., 5.])</span></div>
<div class="line"><span class="lineno"> 2300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2301</span><span class="stringliteral">    If the accumulator is too small, overflow occurs:</span></div>
<div class="line"><span class="lineno"> 2302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2303</span><span class="stringliteral">    &gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)</span></div>
<div class="line"><span class="lineno"> 2304</span><span class="stringliteral">    -128</span></div>
<div class="line"><span class="lineno"> 2305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2306</span><span class="stringliteral">    You can also start the sum with a value other than zero:</span></div>
<div class="line"><span class="lineno"> 2307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2308</span><span class="stringliteral">    &gt;&gt;&gt; np.sum([10], initial=5)</span></div>
<div class="line"><span class="lineno"> 2309</span><span class="stringliteral">    15</span></div>
<div class="line"><span class="lineno"> 2310</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2311</span>    <span class="keywordflow">if</span> isinstance(a, _gentype):</div>
<div class="line"><span class="lineno"> 2312</span>        <span class="comment"># 2018-02-25, 1.15.0</span></div>
<div class="line"><span class="lineno"> 2313</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 2314</span>            <span class="stringliteral">&quot;Calling np.sum(generator) is deprecated, and in the future will give a different result. &quot;</span></div>
<div class="line"><span class="lineno"> 2315</span>            <span class="stringliteral">&quot;Use np.sum(np.fromiter(generator)) or the python sum builtin instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2316</span>            DeprecationWarning, stacklevel=3)</div>
<div class="line"><span class="lineno"> 2317</span> </div>
<div class="line"><span class="lineno"> 2318</span>        res = _sum_(a)</div>
<div class="line"><span class="lineno"> 2319</span>        <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2320</span>            out[...] = res</div>
<div class="line"><span class="lineno"> 2321</span>            <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 2322</span>        <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 2323</span> </div>
<div class="line"><span class="lineno"> 2324</span>    <span class="keywordflow">return</span> _wrapreduction(a, np.add, <span class="stringliteral">&#39;sum&#39;</span>, axis, dtype, out, keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 2325</span>                          initial=initial, where=where)</div>
<div class="line"><span class="lineno"> 2326</span> </div>
<div class="line"><span class="lineno"> 2327</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6fc6945fa57fb7f804b191a97952b05a" name="a6fc6945fa57fb7f804b191a97952b05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc6945fa57fb7f804b191a97952b05a">&#9670;&#160;</a></span>swapaxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.swapaxes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Interchange two axes of an array.

Parameters
----------
a : array_like
    Input array.
axis1 : int
    First axis.
axis2 : int
    Second axis.

Returns
-------
a_swapped : ndarray
    For NumPy &gt;= 1.10.0, if `a` is an ndarray, then a view of `a` is
    returned; otherwise a new array is created. For earlier NumPy
    versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

Examples
--------
&gt;&gt;&gt; x = np.array([[1,2,3]])
&gt;&gt;&gt; np.swapaxes(x,0,1)
array([[1],
       [2],
       [3]])

&gt;&gt;&gt; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
&gt;&gt;&gt; x
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])

&gt;&gt;&gt; np.swapaxes(x,0,2)
array([[[0, 4],
        [2, 6]],
       [[1, 5],
        [3, 7]]])</pre> <div class="fragment"><div class="line"><span class="lineno">  551</span><span class="keyword">def </span>swapaxes(a, axis1, axis2):</div>
<div class="line"><span class="lineno">  552</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    Interchange two axes of an array.</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    axis1 : int</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">        First axis.</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    axis2 : int</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">        Second axis.</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    a_swapped : ndarray</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        For NumPy &gt;= 1.10.0, if `a` is an ndarray, then a view of `a` is</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">        returned; otherwise a new array is created. For earlier NumPy</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        versions a view of `a` is returned only if the order of the</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        axes is changed, otherwise the input array is returned.</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[1,2,3]])</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    &gt;&gt;&gt; np.swapaxes(x,0,1)</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    array([[1],</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">           [2],</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">           [3]])</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    array([[[0, 1],</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">            [2, 3]],</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">           [[4, 5],</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">            [6, 7]]])</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    &gt;&gt;&gt; np.swapaxes(x,0,2)</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    array([[[0, 4],</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">            [2, 6]],</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">           [[1, 5],</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">            [3, 7]]])</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  594</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;swapaxes&#39;</span>, axis1, axis2)</div>
<div class="line"><span class="lineno">  595</span> </div>
<div class="line"><span class="lineno">  596</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1a26fc629bbaceb4c36bec114e80711" name="ac1a26fc629bbaceb4c36bec114e80711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a26fc629bbaceb4c36bec114e80711">&#9670;&#160;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.take </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'raise'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take elements from an array along an axis.

When axis is not None, this function does the same thing as "fancy"
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
``np.take(arr, indices, axis=3)`` is equivalent to
``arr[:,:,:,indices,...]``.

Explained without fancy indexing, this is equivalent to the following use
of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of
indices::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    Nj = indices.shape
    for ii in ndindex(Ni):
        for jj in ndindex(Nj):
            for kk in ndindex(Nk):
                out[ii + jj + kk] = a[ii + (indices[jj],) + kk]

Parameters
----------
a : array_like (Ni..., M, Nk...)
    The source array.
indices : array_like (Nj...)
    The indices of the values to extract.

    .. versionadded:: 1.8.0

    Also allow scalars for indices.
axis : int, optional
    The axis over which to select values. By default, the flattened
    input array is used.
out : ndarray, optional (Ni..., Nj..., Nk...)
    If provided, the result will be placed in this array. It should
    be of the appropriate shape and dtype. Note that `out` is always
    buffered if `mode='raise'`; use other modes for better performance.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' -- raise an error (default)
    * 'wrap' -- wrap around
    * 'clip' -- clip to the range

    'clip' mode means that all indices that are too large are replaced
    by the index that addresses the last element along that axis. Note
    that this disables indexing with negative numbers.

Returns
-------
out : ndarray (Ni..., Nj..., Nk...)
    The returned array has the same type as `a`.

See Also
--------
compress : Take elements using a boolean mask
ndarray.take : equivalent method
take_along_axis : Take elements by matching the array and the index arrays

Notes
-----

By eliminating the inner loop in the description above, and using `s_` to
build simple slice objects, `take` can be expressed  in terms of applying
fancy indexing to each 1-d slice::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nj):
            out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]

For this reason, it is equivalent to (but faster than) the following use
of `apply_along_axis`::

    out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)

Examples
--------
&gt;&gt;&gt; a = [4, 3, 5, 7, 6, 8]
&gt;&gt;&gt; indices = [0, 1, 4]
&gt;&gt;&gt; np.take(a, indices)
array([4, 3, 6])

In this example if `a` is an ndarray, "fancy" indexing can be used.

&gt;&gt;&gt; a = np.array(a)
&gt;&gt;&gt; a[indices]
array([4, 3, 6])

If `indices` is not one dimensional, the output also has these dimensions.

&gt;&gt;&gt; np.take(a, [[0, 1], [2, 3]])
array([[4, 3],
       [5, 7]])
</pre> <div class="fragment"><div class="line"><span class="lineno">   94</span><span class="keyword">def </span>take(a, indices, axis=None, out=None, mode=&#39;raise&#39;):</div>
<div class="line"><span class="lineno">   95</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    Take elements from an array along an axis.</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    When axis is not None, this function does the same thing as &quot;fancy&quot;</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    indexing (indexing arrays using arrays); however, it can be easier to use</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    if you need elements along a given axis. A call such as</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    ``np.take(arr, indices, axis=3)`` is equivalent to</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    ``arr[:,:,:,indices,...]``.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    Explained without fancy indexing, this is equivalent to the following use</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    indices::</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        Ni, Nk = a.shape[:axis], a.shape[axis+1:]</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        Nj = indices.shape</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        for ii in ndindex(Ni):</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">            for jj in ndindex(Nj):</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">                for kk in ndindex(Nk):</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    a : array_like (Ni..., M, Nk...)</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        The source array.</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    indices : array_like (Nj...)</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        The indices of the values to extract.</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">        Also allow scalars for indices.</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        The axis over which to select values. By default, the flattened</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        input array is used.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    out : ndarray, optional (Ni..., Nj..., Nk...)</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">        If provided, the result will be placed in this array. It should</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">        be of the appropriate shape and dtype. Note that `out` is always</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        buffered if `mode=&#39;raise&#39;`; use other modes for better performance.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">        Specifies how out-of-bounds indices will behave.</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">        * &#39;raise&#39; -- raise an error (default)</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        * &#39;wrap&#39; -- wrap around</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        * &#39;clip&#39; -- clip to the range</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        &#39;clip&#39; mode means that all indices that are too large are replaced</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        by the index that addresses the last element along that axis. Note</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        that this disables indexing with negative numbers.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    out : ndarray (Ni..., Nj..., Nk...)</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">        The returned array has the same type as `a`.</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    compress : Take elements using a boolean mask</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    ndarray.take : equivalent method</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    take_along_axis : Take elements by matching the array and the index arrays</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    By eliminating the inner loop in the description above, and using `s_` to</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    build simple slice objects, `take` can be expressed  in terms of applying</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    fancy indexing to each 1-d slice::</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        Ni, Nk = a.shape[:axis], a.shape[axis+1:]</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        for ii in ndindex(Ni):</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">            for kk in ndindex(Nj):</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">                out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    For this reason, it is equivalent to (but faster than) the following use</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    of `apply_along_axis`::</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    &gt;&gt;&gt; a = [4, 3, 5, 7, 6, 8]</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    &gt;&gt;&gt; indices = [0, 1, 4]</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    &gt;&gt;&gt; np.take(a, indices)</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    array([4, 3, 6])</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    In this example if `a` is an ndarray, &quot;fancy&quot; indexing can be used.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array(a)</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    &gt;&gt;&gt; a[indices]</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    array([4, 3, 6])</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    If `indices` is not one dimensional, the output also has these dimensions.</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    &gt;&gt;&gt; np.take(a, [[0, 1], [2, 3]])</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    array([[4, 3],</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">           [5, 7]])</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;take&#39;</span>, indices, axis=axis, out=out, mode=mode)</div>
<div class="line"><span class="lineno">  191</span> </div>
<div class="line"><span class="lineno">  192</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae50b452c4b243c01ffc5aca1f8301580" name="ae50b452c4b243c01ffc5aca1f8301580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50b452c4b243c01ffc5aca1f8301580">&#9670;&#160;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.trace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the sum along diagonals of the array.

If `a` is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.

If `a` has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of `a` with `axis1`
and `axis2` removed.

Parameters
----------
a : array_like
    Input array, from which the diagonals are taken.
offset : int, optional
    Offset of the diagonal from the main diagonal. Can be both positive
    and negative. Defaults to 0.
axis1, axis2 : int, optional
    Axes to be used as the first and second axis of the 2-D sub-arrays
    from which the diagonals should be taken. Defaults are the first two
    axes of `a`.
dtype : dtype, optional
    Determines the data-type of the returned array and of the accumulator
    where the elements are summed. If dtype has the value None and `a` is
    of integer type of precision less than the default integer
    precision, then the default integer precision is used. Otherwise,
    the precision is the same as that of `a`.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and
    it must be of the right shape to hold the output.

Returns
-------
sum_along_diagonals : ndarray
    If `a` is 2-D, the sum along the diagonal is returned.  If `a` has
    larger dimensions, then an array of sums along diagonals is returned.

See Also
--------
diag, diagonal, diagflat

Examples
--------
&gt;&gt;&gt; np.trace(np.eye(3))
3.0
&gt;&gt;&gt; a = np.arange(8).reshape((2,2,2))
&gt;&gt;&gt; np.trace(a)
array([6, 8])

&gt;&gt;&gt; a = np.arange(24).reshape((2,2,2,3))
&gt;&gt;&gt; np.trace(a).shape
(2, 3)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1714</span><span class="keyword">def </span>trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):</div>
<div class="line"><span class="lineno"> 1715</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">    Return the sum along diagonals of the array.</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    If `a` is 2-D, the sum along its diagonal with the given offset</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">    If `a` has more than two dimensions, then the axes specified by axis1 and</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">    axis2 are used to determine the 2-D sub-arrays whose traces are returned.</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">    The shape of the resulting array is the same as that of `a` with `axis1`</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">    and `axis2` removed.</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">        Input array, from which the diagonals are taken.</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">    offset : int, optional</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">        Offset of the diagonal from the main diagonal. Can be both positive</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral">        and negative. Defaults to 0.</span></div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">    axis1, axis2 : int, optional</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">        Axes to be used as the first and second axis of the 2-D sub-arrays</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">        from which the diagonals should be taken. Defaults are the first two</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral">        axes of `a`.</span></div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">        Determines the data-type of the returned array and of the accumulator</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">        where the elements are summed. If dtype has the value None and `a` is</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">        of integer type of precision less than the default integer</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">        precision, then the default integer precision is used. Otherwise,</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">        the precision is the same as that of `a`.</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral">        Array into which the output is placed. Its type is preserved and</span></div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">        it must be of the right shape to hold the output.</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral">    sum_along_diagonals : ndarray</span></div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral">        larger dimensions, then an array of sums along diagonals is returned.</span></div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">    diag, diagonal, diagflat</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">    &gt;&gt;&gt; np.trace(np.eye(3))</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(8).reshape((2,2,2))</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">    &gt;&gt;&gt; np.trace(a)</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">    array([6, 8])</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(24).reshape((2,2,2,3))</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">    &gt;&gt;&gt; np.trace(a).shape</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">    (2, 3)</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1770</span>    <span class="keywordflow">if</span> isinstance(a, np.matrix):</div>
<div class="line"><span class="lineno"> 1771</span>        <span class="comment"># Get trace of matrix via an array to preserve backward compatibility.</span></div>
<div class="line"><span class="lineno"> 1772</span>        <span class="keywordflow">return</span> asarray(a).trace(offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out)</div>
<div class="line"><span class="lineno"> 1773</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1774</span>        <span class="keywordflow">return</span> asanyarray(a).trace(offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out)</div>
<div class="line"><span class="lineno"> 1775</span> </div>
<div class="line"><span class="lineno"> 1776</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a841d0800caffc28ceef9afb4731e6ed5" name="a841d0800caffc28ceef9afb4731e6ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841d0800caffc28ceef9afb4731e6ed5">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.transpose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an array with axes transposed.

For a 1-D array, this returns an unchanged view of the original array, as a
transposed vector is simply the same vector.
To convert a 1-D array into a 2-D column vector, an additional dimension
must be added, e.g., ``np.atleast2d(a).T`` achieves this, as does
``a[:, np.newaxis]``.
For a 2-D array, this is the standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided, then
``transpose(a).shape == a.shape[::-1]``.

Parameters
----------
a : array_like
    Input array.
axes : tuple or list of ints, optional
    If specified, it must be a tuple or list which contains a permutation
    of [0,1,...,N-1] where N is the number of axes of `a`. The `i`'th axis
    of the returned array will correspond to the axis numbered ``axes[i]``
    of the input. If not specified, defaults to ``range(a.ndim)[::-1]``,
    which reverses the order of the axes.

Returns
-------
p : ndarray
    `a` with its axes permuted. A view is returned whenever possible.

See Also
--------
ndarray.transpose : Equivalent method.
moveaxis : Move axes of an array to new positions.
argsort : Return the indices that would sort an array.

Notes
-----
Use ``transpose(a, argsort(axes))`` to invert the transposition of tensors
when using the `axes` keyword argument.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; a
array([[1, 2],
       [3, 4]])
&gt;&gt;&gt; np.transpose(a)
array([[1, 3],
       [2, 4]])

&gt;&gt;&gt; a = np.array([1, 2, 3, 4])
&gt;&gt;&gt; a
array([1, 2, 3, 4])
&gt;&gt;&gt; np.transpose(a)
array([1, 2, 3, 4])

&gt;&gt;&gt; a = np.ones((1, 2, 3))
&gt;&gt;&gt; np.transpose(a, (1, 0, 2)).shape
(2, 1, 3)

&gt;&gt;&gt; a = np.ones((2, 3, 4, 5))
&gt;&gt;&gt; np.transpose(a).shape
(5, 4, 3, 2)</pre> <div class="fragment"><div class="line"><span class="lineno">  602</span><span class="keyword">def </span>transpose(a, axes=None):</div>
<div class="line"><span class="lineno">  603</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    Returns an array with axes transposed.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    For a 1-D array, this returns an unchanged view of the original array, as a</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    transposed vector is simply the same vector.</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    To convert a 1-D array into a 2-D column vector, an additional dimension</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    must be added, e.g., ``np.atleast2d(a).T`` achieves this, as does</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    ``a[:, np.newaxis]``.</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    For a 2-D array, this is the standard matrix transpose.</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    For an n-D array, if axes are given, their order indicates how the</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    axes are permuted (see Examples). If axes are not provided, then</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    ``transpose(a).shape == a.shape[::-1]``.</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    axes : tuple or list of ints, optional</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        If specified, it must be a tuple or list which contains a permutation</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">        of [0,1,...,N-1] where N is the number of axes of `a`. The `i`&#39;th axis</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">        of the returned array will correspond to the axis numbered ``axes[i]``</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        of the input. If not specified, defaults to ``range(a.ndim)[::-1]``,</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        which reverses the order of the axes.</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    p : ndarray</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        `a` with its axes permuted. A view is returned whenever possible.</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    ndarray.transpose : Equivalent method.</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    moveaxis : Move axes of an array to new positions.</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    argsort : Return the indices that would sort an array.</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    Use ``transpose(a, argsort(axes))`` to invert the transposition of tensors</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    when using the `axes` keyword argument.</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    array([[1, 2],</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">           [3, 4]])</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    &gt;&gt;&gt; np.transpose(a)</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    array([[1, 3],</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">           [2, 4]])</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    array([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    &gt;&gt;&gt; np.transpose(a)</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    array([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    &gt;&gt;&gt; a = np.ones((1, 2, 3))</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    &gt;&gt;&gt; np.transpose(a, (1, 0, 2)).shape</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    (2, 1, 3)</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    &gt;&gt;&gt; a = np.ones((2, 3, 4, 5))</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    &gt;&gt;&gt; np.transpose(a).shape</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    (5, 4, 3, 2)</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  668</span>    <span class="keywordflow">return</span> _wrapfunc(a, <span class="stringliteral">&#39;transpose&#39;</span>, axes)</div>
<div class="line"><span class="lineno">  669</span> </div>
<div class="line"><span class="lineno">  670</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acb2e33cf9ae838c69941ea5b4a446257" name="acb2e33cf9ae838c69941ea5b4a446257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2e33cf9ae838c69941ea5b4a446257">&#9670;&#160;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.var </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    "Delta Degrees of Freedom": the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `var` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

where : array_like of bool, optional
    Elements to include in the variance. See `~numpy.ufunc.reduce` for
    details.

    .. versionadded:: 1.20.0

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std, mean, nanmean, nanstd, nanvar
:ref:`ufuncs-output-type`

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.

The mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.var(a)
1.25
&gt;&gt;&gt; np.var(a, axis=0)
array([1.,  1.])
&gt;&gt;&gt; np.var(a, axis=1)
array([0.25,  0.25])

In single precision, var() can be inaccurate:

&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)
&gt;&gt;&gt; a[0, :] = 1.0
&gt;&gt;&gt; a[1, :] = 0.1
&gt;&gt;&gt; np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

&gt;&gt;&gt; np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
&gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025

Specifying a where argument:

&gt;&gt;&gt; a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
&gt;&gt;&gt; np.var(a)
6.833333333333333 # may vary
&gt;&gt;&gt; np.var(a, where=[[True], [True], [False]])
4.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 3616</span>        where=np._NoValue):</div>
<div class="line"><span class="lineno"> 3617</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3618</span><span class="stringliteral">    Compute the variance along the specified axis.</span></div>
<div class="line"><span class="lineno"> 3619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3620</span><span class="stringliteral">    Returns the variance of the array elements, a measure of the spread of a</span></div>
<div class="line"><span class="lineno"> 3621</span><span class="stringliteral">    distribution.  The variance is computed for the flattened array by</span></div>
<div class="line"><span class="lineno"> 3622</span><span class="stringliteral">    default, otherwise over the specified axis.</span></div>
<div class="line"><span class="lineno"> 3623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3624</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3625</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3626</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3627</span><span class="stringliteral">        Array containing numbers whose variance is desired.  If `a` is not an</span></div>
<div class="line"><span class="lineno"> 3628</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno"> 3629</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 3630</span><span class="stringliteral">        Axis or axes along which the variance is computed.  The default is to</span></div>
<div class="line"><span class="lineno"> 3631</span><span class="stringliteral">        compute the variance of the flattened array.</span></div>
<div class="line"><span class="lineno"> 3632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3633</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 3634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3635</span><span class="stringliteral">        If this is a tuple of ints, a variance is performed over multiple axes,</span></div>
<div class="line"><span class="lineno"> 3636</span><span class="stringliteral">        instead of a single axis or all the axes as before.</span></div>
<div class="line"><span class="lineno"> 3637</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno"> 3638</span><span class="stringliteral">        Type to use in computing the variance.  For arrays of integer type</span></div>
<div class="line"><span class="lineno"> 3639</span><span class="stringliteral">        the default is `float64`; for arrays of float types it is the same as</span></div>
<div class="line"><span class="lineno"> 3640</span><span class="stringliteral">        the array type.</span></div>
<div class="line"><span class="lineno"> 3641</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3642</span><span class="stringliteral">        Alternate output array in which to place the result.  It must have</span></div>
<div class="line"><span class="lineno"> 3643</span><span class="stringliteral">        the same shape as the expected output, but the type is cast if</span></div>
<div class="line"><span class="lineno"> 3644</span><span class="stringliteral">        necessary.</span></div>
<div class="line"><span class="lineno"> 3645</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 3646</span><span class="stringliteral">        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span></div>
<div class="line"><span class="lineno"> 3647</span><span class="stringliteral">        ``N - ddof``, where ``N`` represents the number of elements. By</span></div>
<div class="line"><span class="lineno"> 3648</span><span class="stringliteral">        default `ddof` is zero.</span></div>
<div class="line"><span class="lineno"> 3649</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 3650</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 3651</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 3652</span><span class="stringliteral">        the result will broadcast correctly against the input array.</span></div>
<div class="line"><span class="lineno"> 3653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3654</span><span class="stringliteral">        If the default value is passed, then `keepdims` will not be</span></div>
<div class="line"><span class="lineno"> 3655</span><span class="stringliteral">        passed through to the `var` method of sub-classes of</span></div>
<div class="line"><span class="lineno"> 3656</span><span class="stringliteral">        `ndarray`, however any non-default value will be.  If the</span></div>
<div class="line"><span class="lineno"> 3657</span><span class="stringliteral">        sub-class&#39; method does not implement `keepdims` any</span></div>
<div class="line"><span class="lineno"> 3658</span><span class="stringliteral">        exceptions will be raised.</span></div>
<div class="line"><span class="lineno"> 3659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3660</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 3661</span><span class="stringliteral">        Elements to include in the variance. See `~numpy.ufunc.reduce` for</span></div>
<div class="line"><span class="lineno"> 3662</span><span class="stringliteral">        details.</span></div>
<div class="line"><span class="lineno"> 3663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3664</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno"> 3665</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3666</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3667</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3668</span><span class="stringliteral">    variance : ndarray, see dtype parameter above</span></div>
<div class="line"><span class="lineno"> 3669</span><span class="stringliteral">        If ``out=None``, returns a new array containing the variance;</span></div>
<div class="line"><span class="lineno"> 3670</span><span class="stringliteral">        otherwise, a reference to the output array is returned.</span></div>
<div class="line"><span class="lineno"> 3671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3672</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3673</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3674</span><span class="stringliteral">    std, mean, nanmean, nanstd, nanvar</span></div>
<div class="line"><span class="lineno"> 3675</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 3676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3677</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3678</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3679</span><span class="stringliteral">    The variance is the average of the squared deviations from the mean,</span></div>
<div class="line"><span class="lineno"> 3680</span><span class="stringliteral">    i.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.</span></div>
<div class="line"><span class="lineno"> 3681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3682</span><span class="stringliteral">    The mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.</span></div>
<div class="line"><span class="lineno"> 3683</span><span class="stringliteral">    If, however, `ddof` is specified, the divisor ``N - ddof`` is used</span></div>
<div class="line"><span class="lineno"> 3684</span><span class="stringliteral">    instead.  In standard statistical practice, ``ddof=1`` provides an</span></div>
<div class="line"><span class="lineno"> 3685</span><span class="stringliteral">    unbiased estimator of the variance of a hypothetical infinite population.</span></div>
<div class="line"><span class="lineno"> 3686</span><span class="stringliteral">    ``ddof=0`` provides a maximum likelihood estimate of the variance for</span></div>
<div class="line"><span class="lineno"> 3687</span><span class="stringliteral">    normally distributed variables.</span></div>
<div class="line"><span class="lineno"> 3688</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3689</span><span class="stringliteral">    Note that for complex numbers, the absolute value is taken before</span></div>
<div class="line"><span class="lineno"> 3690</span><span class="stringliteral">    squaring, so that the result is always real and nonnegative.</span></div>
<div class="line"><span class="lineno"> 3691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3692</span><span class="stringliteral">    For floating-point input, the variance is computed using the same</span></div>
<div class="line"><span class="lineno"> 3693</span><span class="stringliteral">    precision the input has.  Depending on the input data, this can cause</span></div>
<div class="line"><span class="lineno"> 3694</span><span class="stringliteral">    the results to be inaccurate, especially for `float32` (see example</span></div>
<div class="line"><span class="lineno"> 3695</span><span class="stringliteral">    below).  Specifying a higher-accuracy accumulator using the ``dtype``</span></div>
<div class="line"><span class="lineno"> 3696</span><span class="stringliteral">    keyword can alleviate this issue.</span></div>
<div class="line"><span class="lineno"> 3697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3698</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3699</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3700</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 3701</span><span class="stringliteral">    &gt;&gt;&gt; np.var(a)</span></div>
<div class="line"><span class="lineno"> 3702</span><span class="stringliteral">    1.25</span></div>
<div class="line"><span class="lineno"> 3703</span><span class="stringliteral">    &gt;&gt;&gt; np.var(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 3704</span><span class="stringliteral">    array([1.,  1.])</span></div>
<div class="line"><span class="lineno"> 3705</span><span class="stringliteral">    &gt;&gt;&gt; np.var(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 3706</span><span class="stringliteral">    array([0.25,  0.25])</span></div>
<div class="line"><span class="lineno"> 3707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3708</span><span class="stringliteral">    In single precision, var() can be inaccurate:</span></div>
<div class="line"><span class="lineno"> 3709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3710</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)</span></div>
<div class="line"><span class="lineno"> 3711</span><span class="stringliteral">    &gt;&gt;&gt; a[0, :] = 1.0</span></div>
<div class="line"><span class="lineno"> 3712</span><span class="stringliteral">    &gt;&gt;&gt; a[1, :] = 0.1</span></div>
<div class="line"><span class="lineno"> 3713</span><span class="stringliteral">    &gt;&gt;&gt; np.var(a)</span></div>
<div class="line"><span class="lineno"> 3714</span><span class="stringliteral">    0.20250003</span></div>
<div class="line"><span class="lineno"> 3715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3716</span><span class="stringliteral">    Computing the variance in float64 is more accurate:</span></div>
<div class="line"><span class="lineno"> 3717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3718</span><span class="stringliteral">    &gt;&gt;&gt; np.var(a, dtype=np.float64)</span></div>
<div class="line"><span class="lineno"> 3719</span><span class="stringliteral">    0.20249999932944759 # may vary</span></div>
<div class="line"><span class="lineno"> 3720</span><span class="stringliteral">    &gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2</span></div>
<div class="line"><span class="lineno"> 3721</span><span class="stringliteral">    0.2025</span></div>
<div class="line"><span class="lineno"> 3722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3723</span><span class="stringliteral">    Specifying a where argument:</span></div>
<div class="line"><span class="lineno"> 3724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3725</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])</span></div>
<div class="line"><span class="lineno"> 3726</span><span class="stringliteral">    &gt;&gt;&gt; np.var(a)</span></div>
<div class="line"><span class="lineno"> 3727</span><span class="stringliteral">    6.833333333333333 # may vary</span></div>
<div class="line"><span class="lineno"> 3728</span><span class="stringliteral">    &gt;&gt;&gt; np.var(a, where=[[True], [True], [False]])</span></div>
<div class="line"><span class="lineno"> 3729</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno"> 3730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3731</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3732</span>    kwargs = {}</div>
<div class="line"><span class="lineno"> 3733</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 3734</span>        kwargs[<span class="stringliteral">&#39;keepdims&#39;</span>] = keepdims</div>
<div class="line"><span class="lineno"> 3735</span>    <span class="keywordflow">if</span> where <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 3736</span>        kwargs[<span class="stringliteral">&#39;where&#39;</span>] = where</div>
<div class="line"><span class="lineno"> 3737</span> </div>
<div class="line"><span class="lineno"> 3738</span>    <span class="keywordflow">if</span> type(a) <span class="keywordflow">is</span> <span class="keywordflow">not</span> mu.ndarray:</div>
<div class="line"><span class="lineno"> 3739</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3740</span>            var = a.var</div>
<div class="line"><span class="lineno"> 3741</span> </div>
<div class="line"><span class="lineno"> 3742</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 3743</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 3744</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3745</span>            <span class="keywordflow">return</span> var(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)</div>
<div class="line"><span class="lineno"> 3746</span> </div>
<div class="line"><span class="lineno"> 3747</span>    <span class="keywordflow">return</span> _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,</div>
<div class="line"><span class="lineno"> 3748</span>                         **kwargs)</div>
<div class="line"><span class="lineno"> 3749</span> </div>
<div class="line"><span class="lineno"> 3750</span> </div>
<div class="line"><span class="lineno"> 3751</span><span class="comment"># Aliases of other functions. These have their own definitions only so that</span></div>
<div class="line"><span class="lineno"> 3752</span><span class="comment"># they can have unique docstrings.</span></div>
<div class="line"><span class="lineno"> 3753</span> </div>
<div class="line"><span class="lineno"> 3754</span><span class="preprocessor">@array_function_dispatch(_around_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a28ff1fc58b4c23bee779e6518321a21e" name="a28ff1fc58b4c23bee779e6518321a21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ff1fc58b4c23bee779e6518321a21e">&#9670;&#160;</a></span>_dt_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._dt_ = nt.sctype2char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a802bc641cf3109c8939c281c8dbfdc21" name="a802bc641cf3109c8939c281c8dbfdc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802bc641cf3109c8939c281c8dbfdc21">&#9670;&#160;</a></span>_gentype</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._gentype = types.GeneratorType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a887577fe59519966e7b6a3bbf1198a7a" name="a887577fe59519966e7b6a3bbf1198a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887577fe59519966e7b6a3bbf1198a7a">&#9670;&#160;</a></span>_sum_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric._sum_ = <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a51411b3b0c037cf12ac140486f46cfd9">sum</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2d6e3b11669e7f56523052edd3f88f6" name="ab2d6e3b11669e7f56523052edd3f88f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d6e3b11669e7f56523052edd3f88f6">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.fromnumeric.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
