<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.tests.test_triangulation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1tests.html">tests</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html">test_triangulation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.tests.test_triangulation Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1tests_1_1test__triangulation_1_1_test_triangulation_params.html">TestTriangulationParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a172d237ff3f67292fbe7393328c75ebc" id="r_a172d237ff3f67292fbe7393328c75ebc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a172d237ff3f67292fbe7393328c75ebc">test_extract_triangulation_positional_mask</a> ()</td></tr>
<tr class="separator:a172d237ff3f67292fbe7393328c75ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef4a3194eea4375fa68673797a4f472" id="r_acef4a3194eea4375fa68673797a4f472"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#acef4a3194eea4375fa68673797a4f472">test_triangulation_init</a> ()</td></tr>
<tr class="separator:acef4a3194eea4375fa68673797a4f472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e61536bb300c5c8e0f4424d4e07717b" id="r_a1e61536bb300c5c8e0f4424d4e07717b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a1e61536bb300c5c8e0f4424d4e07717b">test_delaunay</a> ()</td></tr>
<tr class="separator:a1e61536bb300c5c8e0f4424d4e07717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c9f2ab1f39074ab20315084778ac30" id="r_a79c9f2ab1f39074ab20315084778ac30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a79c9f2ab1f39074ab20315084778ac30">test_delaunay_duplicate_points</a> ()</td></tr>
<tr class="separator:a79c9f2ab1f39074ab20315084778ac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bebbb88c8ea7bfcdfb58d08f7c9f8" id="r_acd5bebbb88c8ea7bfcdfb58d08f7c9f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#acd5bebbb88c8ea7bfcdfb58d08f7c9f8">test_delaunay_points_in_line</a> ()</td></tr>
<tr class="separator:acd5bebbb88c8ea7bfcdfb58d08f7c9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d8903c71ce258dfd3817cd55e1f315" id="r_a09d8903c71ce258dfd3817cd55e1f315"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a09d8903c71ce258dfd3817cd55e1f315">test_delaunay_insufficient_points</a> (x, y)</td></tr>
<tr class="separator:a09d8903c71ce258dfd3817cd55e1f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4656d449b378e586e6db7cf43d8c6f79" id="r_a4656d449b378e586e6db7cf43d8c6f79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a4656d449b378e586e6db7cf43d8c6f79">test_delaunay_robust</a> ()</td></tr>
<tr class="separator:a4656d449b378e586e6db7cf43d8c6f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb85521cf5ed26cf608cd7603a051cd6" id="r_afb85521cf5ed26cf608cd7603a051cd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#afb85521cf5ed26cf608cd7603a051cd6">test_tripcolor</a> ()</td></tr>
<tr class="separator:afb85521cf5ed26cf608cd7603a051cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add25a12f8a6a950052746020a2f1100b" id="r_add25a12f8a6a950052746020a2f1100b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#add25a12f8a6a950052746020a2f1100b">test_tripcolor_color</a> ()</td></tr>
<tr class="separator:add25a12f8a6a950052746020a2f1100b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ae23318b1c5d563aecbcc7e2188465" id="r_a25ae23318b1c5d563aecbcc7e2188465"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a25ae23318b1c5d563aecbcc7e2188465">test_tripcolor_clim</a> ()</td></tr>
<tr class="separator:a25ae23318b1c5d563aecbcc7e2188465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642d1ae576401c63e3daca1057023bca" id="r_a642d1ae576401c63e3daca1057023bca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a642d1ae576401c63e3daca1057023bca">test_tripcolor_warnings</a> ()</td></tr>
<tr class="separator:a642d1ae576401c63e3daca1057023bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49058b64fb22bdba3801540f6df5e4c8" id="r_a49058b64fb22bdba3801540f6df5e4c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a49058b64fb22bdba3801540f6df5e4c8">test_no_modify</a> ()</td></tr>
<tr class="separator:a49058b64fb22bdba3801540f6df5e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7425909451069cb623a6154206a93f97" id="r_a7425909451069cb623a6154206a93f97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a7425909451069cb623a6154206a93f97">test_trifinder</a> ()</td></tr>
<tr class="separator:a7425909451069cb623a6154206a93f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16394f1732e10442067d5ebbfd544d9b" id="r_a16394f1732e10442067d5ebbfd544d9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a16394f1732e10442067d5ebbfd544d9b">test_triinterp</a> ()</td></tr>
<tr class="separator:a16394f1732e10442067d5ebbfd544d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc8d32f1b06152141bb56802553fa8a" id="r_aefc8d32f1b06152141bb56802553fa8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#aefc8d32f1b06152141bb56802553fa8a">test_triinterpcubic_C1_continuity</a> ()</td></tr>
<tr class="separator:aefc8d32f1b06152141bb56802553fa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fcd8dd832b7bfe3a58979e59299917" id="r_ac0fcd8dd832b7bfe3a58979e59299917"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#ac0fcd8dd832b7bfe3a58979e59299917">test_triinterpcubic_cg_solver</a> ()</td></tr>
<tr class="separator:ac0fcd8dd832b7bfe3a58979e59299917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab888fafa0e1b64137fb1af963b9a4bb" id="r_aab888fafa0e1b64137fb1af963b9a4bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#aab888fafa0e1b64137fb1af963b9a4bb">test_triinterpcubic_geom_weights</a> ()</td></tr>
<tr class="separator:aab888fafa0e1b64137fb1af963b9a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae801ccc15d8b97505c36f7ebda5fee4" id="r_aae801ccc15d8b97505c36f7ebda5fee4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#aae801ccc15d8b97505c36f7ebda5fee4">test_triinterp_colinear</a> ()</td></tr>
<tr class="separator:aae801ccc15d8b97505c36f7ebda5fee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb79e8d3207870b2f4fd2f313111a8c" id="r_a6cb79e8d3207870b2f4fd2f313111a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a6cb79e8d3207870b2f4fd2f313111a8c">test_triinterp_transformations</a> ()</td></tr>
<tr class="separator:a6cb79e8d3207870b2f4fd2f313111a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa003bdc4970b5ea65eaad02937b3cec2" id="r_aa003bdc4970b5ea65eaad02937b3cec2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#aa003bdc4970b5ea65eaad02937b3cec2">test_tri_smooth_contouring</a> ()</td></tr>
<tr class="separator:aa003bdc4970b5ea65eaad02937b3cec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb79c46e648261cdf1af0f8ed23bfbf" id="r_a5eb79c46e648261cdf1af0f8ed23bfbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a5eb79c46e648261cdf1af0f8ed23bfbf">test_tri_smooth_gradient</a> ()</td></tr>
<tr class="separator:a5eb79c46e648261cdf1af0f8ed23bfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a157b25cc8564a282b5dac07e6fdad" id="r_af7a157b25cc8564a282b5dac07e6fdad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#af7a157b25cc8564a282b5dac07e6fdad">test_tritools</a> ()</td></tr>
<tr class="separator:af7a157b25cc8564a282b5dac07e6fdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c96f077577733dd9f3bf3d8c72e39f" id="r_a48c96f077577733dd9f3bf3d8c72e39f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a48c96f077577733dd9f3bf3d8c72e39f">test_trirefine</a> ()</td></tr>
<tr class="separator:a48c96f077577733dd9f3bf3d8c72e39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7cad6831d1583f7b06f96f13cc235c" id="r_add7cad6831d1583f7b06f96f13cc235c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#add7cad6831d1583f7b06f96f13cc235c">test_trirefine_masked</a> (interpolator)</td></tr>
<tr class="separator:add7cad6831d1583f7b06f96f13cc235c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1bfb5b10fdb187ad308e63541a89ff" id="r_a8a1bfb5b10fdb187ad308e63541a89ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a8a1bfb5b10fdb187ad308e63541a89ff">meshgrid_triangles</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a8a1bfb5b10fdb187ad308e63541a89ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a86006903bf5fb9d226cdf48c65636" id="r_a06a86006903bf5fb9d226cdf48c65636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a06a86006903bf5fb9d226cdf48c65636">test_triplot_return</a> ()</td></tr>
<tr class="separator:a06a86006903bf5fb9d226cdf48c65636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce0a0d47d0a93d2c538eb3c2cbd052" id="r_a07ce0a0d47d0a93d2c538eb3c2cbd052"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a07ce0a0d47d0a93d2c538eb3c2cbd052">test_trirefiner_fortran_contiguous_triangles</a> ()</td></tr>
<tr class="separator:a07ce0a0d47d0a93d2c538eb3c2cbd052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed90f6e8f0e833ea1d0e25948145674" id="r_abed90f6e8f0e833ea1d0e25948145674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#abed90f6e8f0e833ea1d0e25948145674">test_qhull_triangle_orientation</a> ()</td></tr>
<tr class="separator:abed90f6e8f0e833ea1d0e25948145674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a68a4afe6e4d2b275f34d83b652ec14" id="r_a0a68a4afe6e4d2b275f34d83b652ec14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a0a68a4afe6e4d2b275f34d83b652ec14">test_trianalyzer_mismatched_indices</a> ()</td></tr>
<tr class="separator:a0a68a4afe6e4d2b275f34d83b652ec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b36ce11821cc77850a3aaaf03e5e4ee" id="r_a9b36ce11821cc77850a3aaaf03e5e4ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a9b36ce11821cc77850a3aaaf03e5e4ee">test_tricontourf_decreasing_levels</a> ()</td></tr>
<tr class="separator:a9b36ce11821cc77850a3aaaf03e5e4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f78bd5157d9032ec1cae13c84787381" id="r_a3f78bd5157d9032ec1cae13c84787381"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a3f78bd5157d9032ec1cae13c84787381">test_internal_cpp_api</a> ()</td></tr>
<tr class="separator:a3f78bd5157d9032ec1cae13c84787381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8b2ece7e1852d66b3febf83448c95f" id="r_a5e8b2ece7e1852d66b3febf83448c95f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a5e8b2ece7e1852d66b3febf83448c95f">test_qhull_large_offset</a> ()</td></tr>
<tr class="separator:a5e8b2ece7e1852d66b3febf83448c95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa19e7fb9d38d53b8f5e9bac3ff4126" id="r_a8aa19e7fb9d38d53b8f5e9bac3ff4126"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a8aa19e7fb9d38d53b8f5e9bac3ff4126">test_tricontour_non_finite_z</a> ()</td></tr>
<tr class="separator:a8aa19e7fb9d38d53b8f5e9bac3ff4126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d9dda3e9c951b38971c9d4fa7d2f14" id="r_af1d9dda3e9c951b38971c9d4fa7d2f14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#af1d9dda3e9c951b38971c9d4fa7d2f14">test_tricontourset_reuse</a> ()</td></tr>
<tr class="separator:af1d9dda3e9c951b38971c9d4fa7d2f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c758b230a6355dea4a68f479a045e13" id="r_a8c758b230a6355dea4a68f479a045e13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a8c758b230a6355dea4a68f479a045e13">test_triplot_with_ls</a> (fig_test, fig_ref)</td></tr>
<tr class="separator:a8c758b230a6355dea4a68f479a045e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04273048a7549b71952ba8e019085b35" id="r_a04273048a7549b71952ba8e019085b35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1tests_1_1test__triangulation.html#a04273048a7549b71952ba8e019085b35">test_triplot_label</a> ()</td></tr>
<tr class="separator:a04273048a7549b71952ba8e019085b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8a1bfb5b10fdb187ad308e63541a89ff" name="a8a1bfb5b10fdb187ad308e63541a89ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1bfb5b10fdb187ad308e63541a89ff">&#9670;&#160;</a></span>meshgrid_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.meshgrid_triangles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (2*(N-1)**2, 3) array of triangles to mesh (N, N)-point np.meshgrid.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1069</span><span class="keyword">def </span>meshgrid_triangles(n):</div>
<div class="line"><span class="lineno"> 1070</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    Return (2*(N-1)**2, 3) array of triangles to mesh (N, N)-point np.meshgrid.</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1073</span>    tri = []</div>
<div class="line"><span class="lineno"> 1074</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n-1):</div>
<div class="line"><span class="lineno"> 1075</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(n-1):</div>
<div class="line"><span class="lineno"> 1076</span>            a = i + j*n</div>
<div class="line"><span class="lineno"> 1077</span>            b = (i+1) + j*n</div>
<div class="line"><span class="lineno"> 1078</span>            c = i + (j+1)*n</div>
<div class="line"><span class="lineno"> 1079</span>            d = (i+1) + (j+1)*n</div>
<div class="line"><span class="lineno"> 1080</span>            tri += [[a, b, d], [a, d, c]]</div>
<div class="line"><span class="lineno"> 1081</span>    <span class="keywordflow">return</span> np.array(tri, dtype=np.int32)</div>
<div class="line"><span class="lineno"> 1082</span> </div>
<div class="line"><span class="lineno"> 1083</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e61536bb300c5c8e0f4424d4e07717b" name="a1e61536bb300c5c8e0f4424d4e07717b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e61536bb300c5c8e0f4424d4e07717b">&#9670;&#160;</a></span>test_delaunay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_delaunay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   75</span><span class="keyword">def </span>test_delaunay():</div>
<div class="line"><span class="lineno">   76</span>    <span class="comment"># No duplicate points, regular grid.</span></div>
<div class="line"><span class="lineno">   77</span>    nx = 5</div>
<div class="line"><span class="lineno">   78</span>    ny = 4</div>
<div class="line"><span class="lineno">   79</span>    x, y = np.meshgrid(np.linspace(0.0, 1.0, nx), np.linspace(0.0, 1.0, ny))</div>
<div class="line"><span class="lineno">   80</span>    x = x.ravel()</div>
<div class="line"><span class="lineno">   81</span>    y = y.ravel()</div>
<div class="line"><span class="lineno">   82</span>    npoints = nx*ny</div>
<div class="line"><span class="lineno">   83</span>    ntriangles = 2 * (nx-1) * (ny-1)</div>
<div class="line"><span class="lineno">   84</span>    nedges = 3*nx*ny - 2*nx - 2*ny + 1</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>    <span class="comment"># Create delaunay triangulation.</span></div>
<div class="line"><span class="lineno">   87</span>    triang = mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno">   88</span> </div>
<div class="line"><span class="lineno">   89</span>    <span class="comment"># The tests in the remainder of this function should be passed by any</span></div>
<div class="line"><span class="lineno">   90</span>    <span class="comment"># triangulation that does not contain duplicate points.</span></div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>    <span class="comment"># Points - floating point.</span></div>
<div class="line"><span class="lineno">   93</span>    assert_array_almost_equal(triang.x, x)</div>
<div class="line"><span class="lineno">   94</span>    assert_array_almost_equal(triang.y, y)</div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="line"><span class="lineno">   96</span>    <span class="comment"># Triangles - integers.</span></div>
<div class="line"><span class="lineno">   97</span>    <span class="keyword">assert</span> len(triang.triangles) == ntriangles</div>
<div class="line"><span class="lineno">   98</span>    <span class="keyword">assert</span> np.min(triang.triangles) == 0</div>
<div class="line"><span class="lineno">   99</span>    <span class="keyword">assert</span> np.max(triang.triangles) == npoints-1</div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>    <span class="comment"># Edges - integers.</span></div>
<div class="line"><span class="lineno">  102</span>    <span class="keyword">assert</span> len(triang.edges) == nedges</div>
<div class="line"><span class="lineno">  103</span>    <span class="keyword">assert</span> np.min(triang.edges) == 0</div>
<div class="line"><span class="lineno">  104</span>    <span class="keyword">assert</span> np.max(triang.edges) == npoints-1</div>
<div class="line"><span class="lineno">  105</span> </div>
<div class="line"><span class="lineno">  106</span>    <span class="comment"># Neighbors - integers.</span></div>
<div class="line"><span class="lineno">  107</span>    <span class="comment"># Check that neighbors calculated by C++ triangulation class are the same</span></div>
<div class="line"><span class="lineno">  108</span>    <span class="comment"># as those returned from delaunay routine.</span></div>
<div class="line"><span class="lineno">  109</span>    neighbors = triang.neighbors</div>
<div class="line"><span class="lineno">  110</span>    triang._neighbors = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  111</span>    assert_array_equal(triang.neighbors, neighbors)</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>    <span class="comment"># Is each point used in at least one triangle?</span></div>
<div class="line"><span class="lineno">  114</span>    assert_array_equal(np.unique(triang.triangles), np.arange(npoints))</div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a79c9f2ab1f39074ab20315084778ac30" name="a79c9f2ab1f39074ab20315084778ac30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c9f2ab1f39074ab20315084778ac30">&#9670;&#160;</a></span>test_delaunay_duplicate_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_delaunay_duplicate_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  117</span><span class="keyword">def </span>test_delaunay_duplicate_points():</div>
<div class="line"><span class="lineno">  118</span>    npoints = 10</div>
<div class="line"><span class="lineno">  119</span>    duplicate = 7</div>
<div class="line"><span class="lineno">  120</span>    duplicate_of = 3</div>
<div class="line"><span class="lineno">  121</span> </div>
<div class="line"><span class="lineno">  122</span>    np.random.seed(23)</div>
<div class="line"><span class="lineno">  123</span>    x = np.random.random(npoints)</div>
<div class="line"><span class="lineno">  124</span>    y = np.random.random(npoints)</div>
<div class="line"><span class="lineno">  125</span>    x[duplicate] = x[duplicate_of]</div>
<div class="line"><span class="lineno">  126</span>    y[duplicate] = y[duplicate_of]</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>    <span class="comment"># Create delaunay triangulation.</span></div>
<div class="line"><span class="lineno">  129</span>    triang = mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno">  130</span> </div>
<div class="line"><span class="lineno">  131</span>    <span class="comment"># Duplicate points should be ignored, so the index of the duplicate points</span></div>
<div class="line"><span class="lineno">  132</span>    <span class="comment"># should not appear in any triangle.</span></div>
<div class="line"><span class="lineno">  133</span>    assert_array_equal(np.unique(triang.triangles),</div>
<div class="line"><span class="lineno">  134</span>                       np.delete(np.arange(npoints), duplicate))</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a09d8903c71ce258dfd3817cd55e1f315" name="a09d8903c71ce258dfd3817cd55e1f315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d8903c71ce258dfd3817cd55e1f315">&#9670;&#160;</a></span>test_delaunay_insufficient_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_delaunay_insufficient_points </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  162</span><span class="keyword">def </span>test_delaunay_insufficient_points(x, y):</div>
<div class="line"><span class="lineno">  163</span>    <span class="keyword">with</span> pytest.raises(ValueError):</div>
<div class="line"><span class="lineno">  164</span>        mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno">  165</span> </div>
<div class="line"><span class="lineno">  166</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acd5bebbb88c8ea7bfcdfb58d08f7c9f8" name="acd5bebbb88c8ea7bfcdfb58d08f7c9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5bebbb88c8ea7bfcdfb58d08f7c9f8">&#9670;&#160;</a></span>test_delaunay_points_in_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_delaunay_points_in_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  137</span><span class="keyword">def </span>test_delaunay_points_in_line():</div>
<div class="line"><span class="lineno">  138</span>    <span class="comment"># Cannot triangulate points that are all in a straight line, but check</span></div>
<div class="line"><span class="lineno">  139</span>    <span class="comment"># that delaunay code fails gracefully.</span></div>
<div class="line"><span class="lineno">  140</span>    x = np.linspace(0.0, 10.0, 11)</div>
<div class="line"><span class="lineno">  141</span>    y = np.linspace(0.0, 10.0, 11)</div>
<div class="line"><span class="lineno">  142</span>    <span class="keyword">with</span> pytest.raises(RuntimeError):</div>
<div class="line"><span class="lineno">  143</span>        mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>    <span class="comment"># Add an extra point not on the line and the triangulation is OK.</span></div>
<div class="line"><span class="lineno">  146</span>    x = np.append(x, 2.0)</div>
<div class="line"><span class="lineno">  147</span>    y = np.append(y, 8.0)</div>
<div class="line"><span class="lineno">  148</span>    mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span><span class="preprocessor">@pytest.mark.parametrize</span>(<span class="stringliteral">&#39;x, y&#39;</span>, [</div>
<div class="line"><span class="lineno">  152</span>    <span class="comment"># Triangulation should raise a ValueError if passed less than 3 points.</span></div>
<div class="line"><span class="lineno">  153</span>    ([], []),</div>
<div class="line"><span class="lineno">  154</span>    ([1], [5]),</div>
<div class="line"><span class="lineno">  155</span>    ([1, 2], [5, 6]),</div>
<div class="line"><span class="lineno">  156</span>    <span class="comment"># Triangulation should also raise a ValueError if passed duplicate points</span></div>
<div class="line"><span class="lineno">  157</span>    <span class="comment"># such that there are less than 3 unique points.</span></div>
<div class="line"><span class="lineno">  158</span>    ([1, 2, 1], [5, 6, 5]),</div>
<div class="line"><span class="lineno">  159</span>    ([1, 2, 2], [5, 6, 6]),</div>
<div class="line"><span class="lineno">  160</span>    ([1, 1, 1, 2, 1, 2], [5, 5, 5, 6, 5, 6]),</div>
<div class="line"><span class="lineno">  161</span>])</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4656d449b378e586e6db7cf43d8c6f79" name="a4656d449b378e586e6db7cf43d8c6f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4656d449b378e586e6db7cf43d8c6f79">&#9670;&#160;</a></span>test_delaunay_robust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_delaunay_robust </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  167</span><span class="keyword">def </span>test_delaunay_robust():</div>
<div class="line"><span class="lineno">  168</span>    <span class="comment"># Fails when mtri.Triangulation uses matplotlib.delaunay, works when using</span></div>
<div class="line"><span class="lineno">  169</span>    <span class="comment"># qhull.</span></div>
<div class="line"><span class="lineno">  170</span>    tri_points = np.array([</div>
<div class="line"><span class="lineno">  171</span>        [0.8660254037844384, -0.5000000000000004],</div>
<div class="line"><span class="lineno">  172</span>        [0.7577722283113836, -0.5000000000000004],</div>
<div class="line"><span class="lineno">  173</span>        [0.6495190528383288, -0.5000000000000003],</div>
<div class="line"><span class="lineno">  174</span>        [0.5412658773652739, -0.5000000000000003],</div>
<div class="line"><span class="lineno">  175</span>        [0.811898816047911, -0.40625000000000044],</div>
<div class="line"><span class="lineno">  176</span>        [0.7036456405748561, -0.4062500000000004],</div>
<div class="line"><span class="lineno">  177</span>        [0.5953924651018013, -0.40625000000000033]])</div>
<div class="line"><span class="lineno">  178</span>    test_points = np.asarray([</div>
<div class="line"><span class="lineno">  179</span>        [0.58, -0.46],</div>
<div class="line"><span class="lineno">  180</span>        [0.65, -0.46],</div>
<div class="line"><span class="lineno">  181</span>        [0.65, -0.42],</div>
<div class="line"><span class="lineno">  182</span>        [0.7, -0.48],</div>
<div class="line"><span class="lineno">  183</span>        [0.7, -0.44],</div>
<div class="line"><span class="lineno">  184</span>        [0.75, -0.44],</div>
<div class="line"><span class="lineno">  185</span>        [0.8, -0.48]])</div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span>    <span class="comment"># Utility function that indicates if a triangle defined by 3 points</span></div>
<div class="line"><span class="lineno">  188</span>    <span class="comment"># (xtri, ytri) contains the test point xy.  Avoid calling with a point that</span></div>
<div class="line"><span class="lineno">  189</span>    <span class="comment"># lies on or very near to an edge of the triangle.</span></div>
<div class="line"><span class="lineno">  190</span>    <span class="keyword">def </span>tri_contains_point(xtri, ytri, xy):</div>
<div class="line"><span class="lineno">  191</span>        tri_points = np.vstack((xtri, ytri)).T</div>
<div class="line"><span class="lineno">  192</span>        <span class="keywordflow">return</span> Path(tri_points).contains_point(xy)</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>    <span class="comment"># Utility function that returns how many triangles of the specified</span></div>
<div class="line"><span class="lineno">  195</span>    <span class="comment"># triangulation contain the test point xy.  Avoid calling with a point that</span></div>
<div class="line"><span class="lineno">  196</span>    <span class="comment"># lies on or very near to an edge of any triangle in the triangulation.</span></div>
<div class="line"><span class="lineno">  197</span>    <span class="keyword">def </span>tris_contain_point(triang, xy):</div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">return</span> sum(tri_contains_point(triang.x[tri], triang.y[tri], xy)</div>
<div class="line"><span class="lineno">  199</span>                   <span class="keywordflow">for</span> tri <span class="keywordflow">in</span> triang.triangles)</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span>    <span class="comment"># Using matplotlib.delaunay, an invalid triangulation is created with</span></div>
<div class="line"><span class="lineno">  202</span>    <span class="comment"># overlapping triangles; qhull is OK.</span></div>
<div class="line"><span class="lineno">  203</span>    triang = mtri.Triangulation(tri_points[:, 0], tri_points[:, 1])</div>
<div class="line"><span class="lineno">  204</span>    <span class="keywordflow">for</span> test_point <span class="keywordflow">in</span> test_points:</div>
<div class="line"><span class="lineno">  205</span>        <span class="keyword">assert</span> tris_contain_point(triang, test_point) == 1</div>
<div class="line"><span class="lineno">  206</span> </div>
<div class="line"><span class="lineno">  207</span>    <span class="comment"># If ignore the first point of tri_points, matplotlib.delaunay throws a</span></div>
<div class="line"><span class="lineno">  208</span>    <span class="comment"># KeyError when calculating the convex hull; qhull is OK.</span></div>
<div class="line"><span class="lineno">  209</span>    triang = mtri.Triangulation(tri_points[1:, 0], tri_points[1:, 1])</div>
<div class="line"><span class="lineno">  210</span> </div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span><span class="preprocessor">@image_comparison([&#39;tripcolor1.png&#39;])</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a172d237ff3f67292fbe7393328c75ebc" name="a172d237ff3f67292fbe7393328c75ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172d237ff3f67292fbe7393328c75ebc">&#9670;&#160;</a></span>test_extract_triangulation_positional_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_extract_triangulation_positional_mask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   43</span><span class="keyword">def </span>test_extract_triangulation_positional_mask():</div>
<div class="line"><span class="lineno">   44</span>    <span class="comment"># mask cannot be passed positionally</span></div>
<div class="line"><span class="lineno">   45</span>    mask = [<span class="keyword">True</span>]</div>
<div class="line"><span class="lineno">   46</span>    args = [[0, 2, 1], [0, 0, 1], [[0, 1, 2]], mask]</div>
<div class="line"><span class="lineno">   47</span>    x_, y_, triangles_, mask_, args_, kwargs_ = \</div>
<div class="line"><span class="lineno">   48</span>        mtri.Triangulation._extract_triangulation_params(args, {})</div>
<div class="line"><span class="lineno">   49</span>    <span class="keyword">assert</span> mask_ <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">   50</span>    <span class="keyword">assert</span> args_ == [mask]</div>
<div class="line"><span class="lineno">   51</span>    <span class="comment"># the positional mask must be caught downstream because this must pass</span></div>
<div class="line"><span class="lineno">   52</span>    <span class="comment"># unknown args through</span></div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f78bd5157d9032ec1cae13c84787381" name="a3f78bd5157d9032ec1cae13c84787381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f78bd5157d9032ec1cae13c84787381">&#9670;&#160;</a></span>test_internal_cpp_api()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_internal_cpp_api </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1163</span><span class="keyword">def </span>test_internal_cpp_api():</div>
<div class="line"><span class="lineno"> 1164</span>    <span class="comment"># Following github issue 8197.</span></div>
<div class="line"><span class="lineno"> 1165</span>    <span class="keyword">from</span> matplotlib <span class="keyword">import</span> _tri  <span class="comment"># noqa: ensure lazy-loaded module *is* loaded.</span></div>
<div class="line"><span class="lineno"> 1166</span> </div>
<div class="line"><span class="lineno"> 1167</span>    <span class="comment"># C++ Triangulation.</span></div>
<div class="line"><span class="lineno"> 1168</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1169</span>            TypeError,</div>
<div class="line"><span class="lineno"> 1170</span>            match=<span class="stringliteral">r&#39;function takes exactly 7 arguments \&zwj;(0 given\&zwj;)&#39;</span>):</div>
<div class="line"><span class="lineno"> 1171</span>        mpl._tri.Triangulation()</div>
<div class="line"><span class="lineno"> 1172</span> </div>
<div class="line"><span class="lineno"> 1173</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1174</span>            ValueError, match=<span class="stringliteral">r&#39;x and y must be 1D arrays of the same length&#39;</span>):</div>
<div class="line"><span class="lineno"> 1175</span>        mpl._tri.Triangulation([], [1], [[]], <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1176</span> </div>
<div class="line"><span class="lineno"> 1177</span>    x = [0, 1, 1]</div>
<div class="line"><span class="lineno"> 1178</span>    y = [0, 0, 1]</div>
<div class="line"><span class="lineno"> 1179</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1180</span>            ValueError,</div>
<div class="line"><span class="lineno"> 1181</span>            match=<span class="stringliteral">r&#39;triangles must be a 2D array of shape \&zwj;(\?,3\&zwj;)&#39;</span>):</div>
<div class="line"><span class="lineno"> 1182</span>        mpl._tri.Triangulation(x, y, [[0, 1]], <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1183</span> </div>
<div class="line"><span class="lineno"> 1184</span>    tris = [[0, 1, 2]]</div>
<div class="line"><span class="lineno"> 1185</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1186</span>            ValueError,</div>
<div class="line"><span class="lineno"> 1187</span>            match=<span class="stringliteral">r&#39;mask must be a 1D array with the same length as the &#39;</span></div>
<div class="line"><span class="lineno"> 1188</span>                  <span class="stringliteral">r&#39;triangles array&#39;</span>):</div>
<div class="line"><span class="lineno"> 1189</span>        mpl._tri.Triangulation(x, y, tris, [0, 1], <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1190</span> </div>
<div class="line"><span class="lineno"> 1191</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1192</span>            ValueError, match=<span class="stringliteral">r&#39;edges must be a 2D array with shape \&zwj;(\?,2\&zwj;)&#39;</span>):</div>
<div class="line"><span class="lineno"> 1193</span>        mpl._tri.Triangulation(x, y, tris, <span class="keywordtype">None</span>, [[1]], <span class="keywordtype">None</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1194</span> </div>
<div class="line"><span class="lineno"> 1195</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1196</span>            ValueError,</div>
<div class="line"><span class="lineno"> 1197</span>            match=<span class="stringliteral">r&#39;neighbors must be a 2D array with the same shape as the &#39;</span></div>
<div class="line"><span class="lineno"> 1198</span>                  <span class="stringliteral">r&#39;triangles array&#39;</span>):</div>
<div class="line"><span class="lineno"> 1199</span>        mpl._tri.Triangulation(x, y, tris, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, [[-1]], <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1200</span> </div>
<div class="line"><span class="lineno"> 1201</span>    triang = mpl._tri.Triangulation(x, y, tris, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1202</span> </div>
<div class="line"><span class="lineno"> 1203</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1204</span>            ValueError,</div>
<div class="line"><span class="lineno"> 1205</span>            match=<span class="stringliteral">r&#39;z array must have same length as triangulation x and y &#39;</span></div>
<div class="line"><span class="lineno"> 1206</span>                  <span class="stringliteral">r&#39;array&#39;</span>):</div>
<div class="line"><span class="lineno"> 1207</span>        triang.calculate_plane_coefficients([])</div>
<div class="line"><span class="lineno"> 1208</span> </div>
<div class="line"><span class="lineno"> 1209</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1210</span>            ValueError,</div>
<div class="line"><span class="lineno"> 1211</span>            match=<span class="stringliteral">r&#39;mask must be a 1D array with the same length as the &#39;</span></div>
<div class="line"><span class="lineno"> 1212</span>                  <span class="stringliteral">r&#39;triangles array&#39;</span>):</div>
<div class="line"><span class="lineno"> 1213</span>        triang.set_mask([0, 1])</div>
<div class="line"><span class="lineno"> 1214</span> </div>
<div class="line"><span class="lineno"> 1215</span>    <span class="comment"># C++ TriContourGenerator.</span></div>
<div class="line"><span class="lineno"> 1216</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1217</span>            TypeError,</div>
<div class="line"><span class="lineno"> 1218</span>            match=<span class="stringliteral">r&#39;function takes exactly 2 arguments \&zwj;(0 given\&zwj;)&#39;</span>):</div>
<div class="line"><span class="lineno"> 1219</span>        mpl._tri.TriContourGenerator()</div>
<div class="line"><span class="lineno"> 1220</span> </div>
<div class="line"><span class="lineno"> 1221</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1222</span>            ValueError,</div>
<div class="line"><span class="lineno"> 1223</span>            match=<span class="stringliteral">r&#39;z must be a 1D array with the same length as the x and y &#39;</span></div>
<div class="line"><span class="lineno"> 1224</span>                  <span class="stringliteral">r&#39;arrays&#39;</span>):</div>
<div class="line"><span class="lineno"> 1225</span>        mpl._tri.TriContourGenerator(triang, [1])</div>
<div class="line"><span class="lineno"> 1226</span> </div>
<div class="line"><span class="lineno"> 1227</span>    z = [0, 1, 2]</div>
<div class="line"><span class="lineno"> 1228</span>    tcg = mpl._tri.TriContourGenerator(triang, z)</div>
<div class="line"><span class="lineno"> 1229</span> </div>
<div class="line"><span class="lineno"> 1230</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1231</span>            ValueError, match=<span class="stringliteral">r&#39;filled contour levels must be increasing&#39;</span>):</div>
<div class="line"><span class="lineno"> 1232</span>        tcg.create_filled_contour(1, 0)</div>
<div class="line"><span class="lineno"> 1233</span> </div>
<div class="line"><span class="lineno"> 1234</span>    <span class="comment"># C++ TrapezoidMapTriFinder.</span></div>
<div class="line"><span class="lineno"> 1235</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1236</span>            TypeError, match=<span class="stringliteral">r&#39;function takes exactly 1 argument \&zwj;(0 given\&zwj;)&#39;</span>):</div>
<div class="line"><span class="lineno"> 1237</span>        mpl._tri.TrapezoidMapTriFinder()</div>
<div class="line"><span class="lineno"> 1238</span> </div>
<div class="line"><span class="lineno"> 1239</span>    trifinder = mpl._tri.TrapezoidMapTriFinder(triang)</div>
<div class="line"><span class="lineno"> 1240</span> </div>
<div class="line"><span class="lineno"> 1241</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno"> 1242</span>            ValueError, match=<span class="stringliteral">r&#39;x and y must be array-like with same shape&#39;</span>):</div>
<div class="line"><span class="lineno"> 1243</span>        trifinder.find_many([0], [0, 1])</div>
<div class="line"><span class="lineno"> 1244</span> </div>
<div class="line"><span class="lineno"> 1245</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a49058b64fb22bdba3801540f6df5e4c8" name="a49058b64fb22bdba3801540f6df5e4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49058b64fb22bdba3801540f6df5e4c8">&#9670;&#160;</a></span>test_no_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_no_modify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  293</span><span class="keyword">def </span>test_no_modify():</div>
<div class="line"><span class="lineno">  294</span>    <span class="comment"># Test that Triangulation does not modify triangles array passed to it.</span></div>
<div class="line"><span class="lineno">  295</span>    triangles = np.array([[3, 2, 0], [3, 1, 0]], dtype=np.int32)</div>
<div class="line"><span class="lineno">  296</span>    points = np.array([(0, 0), (0, 1.1), (1, 0), (1, 1)])</div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span>    old_triangles = triangles.copy()</div>
<div class="line"><span class="lineno">  299</span>    mtri.Triangulation(points[:, 0], points[:, 1], triangles).edges</div>
<div class="line"><span class="lineno">  300</span>    assert_array_equal(old_triangles, triangles)</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e8b2ece7e1852d66b3febf83448c95f" name="a5e8b2ece7e1852d66b3febf83448c95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8b2ece7e1852d66b3febf83448c95f">&#9670;&#160;</a></span>test_qhull_large_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_qhull_large_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1246</span><span class="keyword">def </span>test_qhull_large_offset():</div>
<div class="line"><span class="lineno"> 1247</span>    <span class="comment"># github issue 8682.</span></div>
<div class="line"><span class="lineno"> 1248</span>    x = np.asarray([0, 1, 0, 1, 0.5])</div>
<div class="line"><span class="lineno"> 1249</span>    y = np.asarray([0, 0, 1, 1, 0.5])</div>
<div class="line"><span class="lineno"> 1250</span> </div>
<div class="line"><span class="lineno"> 1251</span>    offset = 1e10</div>
<div class="line"><span class="lineno"> 1252</span>    triang = mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno"> 1253</span>    triang_offset = mtri.Triangulation(x + offset, y + offset)</div>
<div class="line"><span class="lineno"> 1254</span>    <span class="keyword">assert</span> len(triang.triangles) == len(triang_offset.triangles)</div>
<div class="line"><span class="lineno"> 1255</span> </div>
<div class="line"><span class="lineno"> 1256</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abed90f6e8f0e833ea1d0e25948145674" name="abed90f6e8f0e833ea1d0e25948145674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed90f6e8f0e833ea1d0e25948145674">&#9670;&#160;</a></span>test_qhull_triangle_orientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_qhull_triangle_orientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1117</span><span class="keyword">def </span>test_qhull_triangle_orientation():</div>
<div class="line"><span class="lineno"> 1118</span>    <span class="comment"># github issue 4437.</span></div>
<div class="line"><span class="lineno"> 1119</span>    xi = np.linspace(-2, 2, 100)</div>
<div class="line"><span class="lineno"> 1120</span>    x, y = map(np.ravel, np.meshgrid(xi, xi))</div>
<div class="line"><span class="lineno"> 1121</span>    w = (x &gt; y - 1) &amp; (x &lt; -1.95) &amp; (y &gt; -1.2)</div>
<div class="line"><span class="lineno"> 1122</span>    x, y = x[w], y[w]</div>
<div class="line"><span class="lineno"> 1123</span>    theta = np.radians(25)</div>
<div class="line"><span class="lineno"> 1124</span>    x1 = x*np.cos(theta) - y*np.sin(theta)</div>
<div class="line"><span class="lineno"> 1125</span>    y1 = x*np.sin(theta) + y*np.cos(theta)</div>
<div class="line"><span class="lineno"> 1126</span> </div>
<div class="line"><span class="lineno"> 1127</span>    <span class="comment"># Calculate Delaunay triangulation using Qhull.</span></div>
<div class="line"><span class="lineno"> 1128</span>    triang = mtri.Triangulation(x1, y1)</div>
<div class="line"><span class="lineno"> 1129</span> </div>
<div class="line"><span class="lineno"> 1130</span>    <span class="comment"># Neighbors returned by Qhull.</span></div>
<div class="line"><span class="lineno"> 1131</span>    qhull_neighbors = triang.neighbors</div>
<div class="line"><span class="lineno"> 1132</span> </div>
<div class="line"><span class="lineno"> 1133</span>    <span class="comment"># Obtain neighbors using own C++ calculation.</span></div>
<div class="line"><span class="lineno"> 1134</span>    triang._neighbors = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1135</span>    own_neighbors = triang.neighbors</div>
<div class="line"><span class="lineno"> 1136</span> </div>
<div class="line"><span class="lineno"> 1137</span>    assert_array_equal(qhull_neighbors, own_neighbors)</div>
<div class="line"><span class="lineno"> 1138</span> </div>
<div class="line"><span class="lineno"> 1139</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa003bdc4970b5ea65eaad02937b3cec2" name="aa003bdc4970b5ea65eaad02937b3cec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa003bdc4970b5ea65eaad02937b3cec2">&#9670;&#160;</a></span>test_tri_smooth_contouring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tri_smooth_contouring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  847</span><span class="keyword">def </span>test_tri_smooth_contouring():</div>
<div class="line"><span class="lineno">  848</span>    <span class="comment"># Image comparison based on example tricontour_smooth_user.</span></div>
<div class="line"><span class="lineno">  849</span>    n_angles = 20</div>
<div class="line"><span class="lineno">  850</span>    n_radii = 10</div>
<div class="line"><span class="lineno">  851</span>    min_radius = 0.15</div>
<div class="line"><span class="lineno">  852</span> </div>
<div class="line"><span class="lineno">  853</span>    <span class="keyword">def </span><a class="code hl_variable" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>(x, y):</div>
<div class="line"><span class="lineno">  854</span>        r1 = np.hypot(0.5 - x, 0.5 - y)</div>
<div class="line"><span class="lineno">  855</span>        theta1 = np.arctan2(0.5 - x, 0.5 - y)</div>
<div class="line"><span class="lineno">  856</span>        r2 = np.hypot(-x - 0.2, -y - 0.2)</div>
<div class="line"><span class="lineno">  857</span>        theta2 = np.arctan2(-x - 0.2, -y - 0.2)</div>
<div class="line"><span class="lineno">  858</span>        z = -(2*(np.exp((r1/10)**2)-1)*30. * np.cos(7.*theta1) +</div>
<div class="line"><span class="lineno">  859</span>              (np.exp((r2/10)**2)-1)*30. * np.cos(11.*theta2) +</div>
<div class="line"><span class="lineno">  860</span>              0.7*(x**2 + y**2))</div>
<div class="line"><span class="lineno">  861</span>        <span class="keywordflow">return</span> (np.max(z)-z)/(np.max(z)-np.min(z))</div>
<div class="line"><span class="lineno">  862</span> </div>
<div class="line"><span class="lineno">  863</span>    <span class="comment"># First create the x and y coordinates of the points.</span></div>
<div class="line"><span class="lineno">  864</span>    radii = np.linspace(min_radius, 0.95, n_radii)</div>
<div class="line"><span class="lineno">  865</span>    angles = np.linspace(0 + n_angles, 2*np.pi + n_angles,</div>
<div class="line"><span class="lineno">  866</span>                         n_angles, endpoint=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  867</span>    angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)</div>
<div class="line"><span class="lineno">  868</span>    angles[:, 1::2] += np.pi/n_angles</div>
<div class="line"><span class="lineno">  869</span>    x0 = (radii*np.cos(angles)).flatten()</div>
<div class="line"><span class="lineno">  870</span>    y0 = (radii*np.sin(angles)).flatten()</div>
<div class="line"><span class="lineno">  871</span>    triang0 = mtri.Triangulation(x0, y0)  <span class="comment"># Delaunay triangulation</span></div>
<div class="line"><span class="lineno">  872</span>    z0 = <a class="code hl_variable" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>(x0, y0)</div>
<div class="line"><span class="lineno">  873</span>    triang0.set_mask(np.hypot(x0[triang0.triangles].mean(axis=1),</div>
<div class="line"><span class="lineno">  874</span>                              y0[triang0.triangles].mean(axis=1))</div>
<div class="line"><span class="lineno">  875</span>                     &lt; min_radius)</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span>    <span class="comment"># Then the plot</span></div>
<div class="line"><span class="lineno">  878</span>    refiner = mtri.UniformTriRefiner(triang0)</div>
<div class="line"><span class="lineno">  879</span>    tri_refi, z_test_refi = refiner.refine_field(z0, subdiv=4)</div>
<div class="line"><span class="lineno">  880</span>    levels = np.arange(0., 1., 0.025)</div>
<div class="line"><span class="lineno">  881</span>    plt.triplot(triang0, lw=0.5, color=<span class="stringliteral">&#39;0.5&#39;</span>)</div>
<div class="line"><span class="lineno">  882</span>    plt.tricontour(tri_refi, z_test_refi, levels=levels, colors=<span class="stringliteral">&quot;black&quot;</span>)</div>
<div class="line"><span class="lineno">  883</span> </div>
<div class="line"><span class="lineno">  884</span> </div>
<div class="line"><span class="lineno">  885</span><span class="preprocessor">@image_comparison([&#39;tri_smooth_gradient.png&#39;], remove_text=True, tol=0.092)</span></div>
<div class="ttc" id="a__blas__subroutines_8h_html_a97fad269e85497afbd382321b3079d38"><div class="ttname"><a href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a></div><div class="ttdeci">void npy_complex128 * z</div><div class="ttdef"><b>Definition</b> _blas_subroutines.h:16</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5eb79c46e648261cdf1af0f8ed23bfbf" name="a5eb79c46e648261cdf1af0f8ed23bfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb79c46e648261cdf1af0f8ed23bfbf">&#9670;&#160;</a></span>test_tri_smooth_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tri_smooth_gradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  886</span><span class="keyword">def </span>test_tri_smooth_gradient():</div>
<div class="line"><span class="lineno">  887</span>    <span class="comment"># Image comparison based on example trigradient_demo.</span></div>
<div class="line"><span class="lineno">  888</span> </div>
<div class="line"><span class="lineno">  889</span>    <span class="keyword">def </span>dipole_potential(x, y):</div>
<div class="line"><span class="lineno">  890</span>        <span class="stringliteral">&quot;&quot;&quot;An electric dipole potential V.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  891</span>        r_sq = x**2 + y**2</div>
<div class="line"><span class="lineno">  892</span>        theta = np.arctan2(y, x)</div>
<div class="line"><span class="lineno">  893</span>        z = np.cos(theta)/r_sq</div>
<div class="line"><span class="lineno">  894</span>        <span class="keywordflow">return</span> (np.max(z)-z) / (np.max(z)-np.min(z))</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span>    <span class="comment"># Creating a Triangulation</span></div>
<div class="line"><span class="lineno">  897</span>    n_angles = 30</div>
<div class="line"><span class="lineno">  898</span>    n_radii = 10</div>
<div class="line"><span class="lineno">  899</span>    min_radius = 0.2</div>
<div class="line"><span class="lineno">  900</span>    radii = np.linspace(min_radius, 0.95, n_radii)</div>
<div class="line"><span class="lineno">  901</span>    angles = np.linspace(0, 2*np.pi, n_angles, endpoint=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  902</span>    angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)</div>
<div class="line"><span class="lineno">  903</span>    angles[:, 1::2] += np.pi/n_angles</div>
<div class="line"><span class="lineno">  904</span>    x = (radii*np.cos(angles)).flatten()</div>
<div class="line"><span class="lineno">  905</span>    y = (radii*np.sin(angles)).flatten()</div>
<div class="line"><span class="lineno">  906</span>    V = dipole_potential(x, y)</div>
<div class="line"><span class="lineno">  907</span>    triang = mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno">  908</span>    triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),</div>
<div class="line"><span class="lineno">  909</span>                             y[triang.triangles].mean(axis=1))</div>
<div class="line"><span class="lineno">  910</span>                    &lt; min_radius)</div>
<div class="line"><span class="lineno">  911</span> </div>
<div class="line"><span class="lineno">  912</span>    <span class="comment"># Refine data - interpolates the electrical potential V</span></div>
<div class="line"><span class="lineno">  913</span>    refiner = mtri.UniformTriRefiner(triang)</div>
<div class="line"><span class="lineno">  914</span>    tri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)</div>
<div class="line"><span class="lineno">  915</span> </div>
<div class="line"><span class="lineno">  916</span>    <span class="comment"># Computes the electrical field (Ex, Ey) as gradient of -V</span></div>
<div class="line"><span class="lineno">  917</span>    tci = mtri.CubicTriInterpolator(triang, -V)</div>
<div class="line"><span class="lineno">  918</span>    Ex, Ey = tci.gradient(triang.x, triang.y)</div>
<div class="line"><span class="lineno">  919</span>    E_norm = np.hypot(Ex, Ey)</div>
<div class="line"><span class="lineno">  920</span> </div>
<div class="line"><span class="lineno">  921</span>    <span class="comment"># Plot the triangulation, the potential iso-contours and the vector field</span></div>
<div class="line"><span class="lineno">  922</span>    plt.figure()</div>
<div class="line"><span class="lineno">  923</span>    plt.gca().set_aspect(<span class="stringliteral">&#39;equal&#39;</span>)</div>
<div class="line"><span class="lineno">  924</span>    plt.triplot(triang, color=<span class="stringliteral">&#39;0.8&#39;</span>)</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span>    levels = np.arange(0., 1., 0.01)</div>
<div class="line"><span class="lineno">  927</span>    cmap = mpl.colormaps[<span class="stringliteral">&#39;hot&#39;</span>]</div>
<div class="line"><span class="lineno">  928</span>    plt.tricontour(tri_refi, z_test_refi, levels=levels, cmap=cmap,</div>
<div class="line"><span class="lineno">  929</span>                   linewidths=[2.0, 1.0, 1.0, 1.0])</div>
<div class="line"><span class="lineno">  930</span>    <span class="comment"># Plots direction of the electrical vector field</span></div>
<div class="line"><span class="lineno">  931</span>    plt.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,</div>
<div class="line"><span class="lineno">  932</span>               units=<span class="stringliteral">&#39;xy&#39;</span>, scale=10., zorder=3, color=<span class="stringliteral">&#39;blue&#39;</span>,</div>
<div class="line"><span class="lineno">  933</span>               width=0.007, headwidth=3., headlength=4.)</div>
<div class="line"><span class="lineno">  934</span>    <span class="comment"># We are leaving ax.use_sticky_margins as True, so the</span></div>
<div class="line"><span class="lineno">  935</span>    <span class="comment"># view limits are the contour data limits.</span></div>
<div class="line"><span class="lineno">  936</span> </div>
<div class="line"><span class="lineno">  937</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a68a4afe6e4d2b275f34d83b652ec14" name="a0a68a4afe6e4d2b275f34d83b652ec14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a68a4afe6e4d2b275f34d83b652ec14">&#9670;&#160;</a></span>test_trianalyzer_mismatched_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_trianalyzer_mismatched_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1140</span><span class="keyword">def </span>test_trianalyzer_mismatched_indices():</div>
<div class="line"><span class="lineno"> 1141</span>    <span class="comment"># github issue 4999.</span></div>
<div class="line"><span class="lineno"> 1142</span>    x = np.array([0., 1., 0.5, 0., 2.])</div>
<div class="line"><span class="lineno"> 1143</span>    y = np.array([0., 0., 0.5*np.sqrt(3.), -1., 1.])</div>
<div class="line"><span class="lineno"> 1144</span>    triangles = np.array([[0, 1, 2], [0, 1, 3], [1, 2, 4]], dtype=np.int32)</div>
<div class="line"><span class="lineno"> 1145</span>    mask = np.array([<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>], dtype=bool)</div>
<div class="line"><span class="lineno"> 1146</span>    triang = mtri.Triangulation(x, y, triangles, mask=mask)</div>
<div class="line"><span class="lineno"> 1147</span>    analyser = mtri.TriAnalyzer(triang)</div>
<div class="line"><span class="lineno"> 1148</span>    <span class="comment"># numpy &gt;= 1.10 raises a VisibleDeprecationWarning in the following line</span></div>
<div class="line"><span class="lineno"> 1149</span>    <span class="comment"># prior to the fix.</span></div>
<div class="line"><span class="lineno"> 1150</span>    analyser._get_compressed_triangulation()</div>
<div class="line"><span class="lineno"> 1151</span> </div>
<div class="line"><span class="lineno"> 1152</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acef4a3194eea4375fa68673797a4f472" name="acef4a3194eea4375fa68673797a4f472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef4a3194eea4375fa68673797a4f472">&#9670;&#160;</a></span>test_triangulation_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triangulation_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   55</span><span class="keyword">def </span>test_triangulation_init():</div>
<div class="line"><span class="lineno">   56</span>    x = [-1, 0, 1, 0]</div>
<div class="line"><span class="lineno">   57</span>    y = [0, -1, 0, 1]</div>
<div class="line"><span class="lineno">   58</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&quot;x and y must be equal-length&quot;</span>):</div>
<div class="line"><span class="lineno">   59</span>        mtri.Triangulation(x, [1, 2])</div>
<div class="line"><span class="lineno">   60</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno">   61</span>            ValueError,</div>
<div class="line"><span class="lineno">   62</span>            match=<span class="stringliteral">r&quot;triangles must be a \&zwj;(N, 3\&zwj;) int array, but found shape &quot;</span></div>
<div class="line"><span class="lineno">   63</span>                  <span class="stringliteral">r&quot;\&zwj;(3,\&zwj;)&quot;</span>):</div>
<div class="line"><span class="lineno">   64</span>        mtri.Triangulation(x, y, [0, 1, 2])</div>
<div class="line"><span class="lineno">   65</span>    <span class="keyword">with</span> pytest.raises(</div>
<div class="line"><span class="lineno">   66</span>            ValueError,</div>
<div class="line"><span class="lineno">   67</span>            match=<span class="stringliteral">r&quot;triangles must be a \&zwj;(N, 3\&zwj;) int array, not &#39;other&#39;&quot;</span>):</div>
<div class="line"><span class="lineno">   68</span>        mtri.Triangulation(x, y, <span class="stringliteral">&#39;other&#39;</span>)</div>
<div class="line"><span class="lineno">   69</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&quot;found value 99&quot;</span>):</div>
<div class="line"><span class="lineno">   70</span>        mtri.Triangulation(x, y, [[0, 1, 99]])</div>
<div class="line"><span class="lineno">   71</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&quot;found value -1&quot;</span>):</div>
<div class="line"><span class="lineno">   72</span>        mtri.Triangulation(x, y, [[0, 1, -1]])</div>
<div class="line"><span class="lineno">   73</span> </div>
<div class="line"><span class="lineno">   74</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8aa19e7fb9d38d53b8f5e9bac3ff4126" name="a8aa19e7fb9d38d53b8f5e9bac3ff4126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa19e7fb9d38d53b8f5e9bac3ff4126">&#9670;&#160;</a></span>test_tricontour_non_finite_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tricontour_non_finite_z </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1257</span><span class="keyword">def </span>test_tricontour_non_finite_z():</div>
<div class="line"><span class="lineno"> 1258</span>    <span class="comment"># github issue 10167.</span></div>
<div class="line"><span class="lineno"> 1259</span>    x = [0, 1, 0, 1]</div>
<div class="line"><span class="lineno"> 1260</span>    y = [0, 0, 1, 1]</div>
<div class="line"><span class="lineno"> 1261</span>    triang = mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno"> 1262</span>    plt.figure()</div>
<div class="line"><span class="lineno"> 1263</span> </div>
<div class="line"><span class="lineno"> 1264</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&#39;z array must not contain non-finite &#39;</span></div>
<div class="line"><span class="lineno"> 1265</span>                                         <span class="stringliteral">&#39;values within the triangulation&#39;</span>):</div>
<div class="line"><span class="lineno"> 1266</span>        plt.tricontourf(triang, [0, 1, 2, np.inf])</div>
<div class="line"><span class="lineno"> 1267</span> </div>
<div class="line"><span class="lineno"> 1268</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&#39;z array must not contain non-finite &#39;</span></div>
<div class="line"><span class="lineno"> 1269</span>                                         <span class="stringliteral">&#39;values within the triangulation&#39;</span>):</div>
<div class="line"><span class="lineno"> 1270</span>        plt.tricontourf(triang, [0, 1, 2, -np.inf])</div>
<div class="line"><span class="lineno"> 1271</span> </div>
<div class="line"><span class="lineno"> 1272</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&#39;z array must not contain non-finite &#39;</span></div>
<div class="line"><span class="lineno"> 1273</span>                                         <span class="stringliteral">&#39;values within the triangulation&#39;</span>):</div>
<div class="line"><span class="lineno"> 1274</span>        plt.tricontourf(triang, [0, 1, 2, np.nan])</div>
<div class="line"><span class="lineno"> 1275</span> </div>
<div class="line"><span class="lineno"> 1276</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&#39;z must not contain masked points &#39;</span></div>
<div class="line"><span class="lineno"> 1277</span>                                         <span class="stringliteral">&#39;within the triangulation&#39;</span>):</div>
<div class="line"><span class="lineno"> 1278</span>        plt.tricontourf(triang, np.ma.array([0, 1, 2, 3], mask=[1, 0, 0, 0]))</div>
<div class="line"><span class="lineno"> 1279</span> </div>
<div class="line"><span class="lineno"> 1280</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b36ce11821cc77850a3aaaf03e5e4ee" name="a9b36ce11821cc77850a3aaaf03e5e4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b36ce11821cc77850a3aaaf03e5e4ee">&#9670;&#160;</a></span>test_tricontourf_decreasing_levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tricontourf_decreasing_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1153</span><span class="keyword">def </span>test_tricontourf_decreasing_levels():</div>
<div class="line"><span class="lineno"> 1154</span>    <span class="comment"># github issue 5477.</span></div>
<div class="line"><span class="lineno"> 1155</span>    x = [0.0, 1.0, 1.0]</div>
<div class="line"><span class="lineno"> 1156</span>    y = [0.0, 0.0, 1.0]</div>
<div class="line"><span class="lineno"> 1157</span>    z = [0.2, 0.4, 0.6]</div>
<div class="line"><span class="lineno"> 1158</span>    plt.figure()</div>
<div class="line"><span class="lineno"> 1159</span>    <span class="keyword">with</span> pytest.raises(ValueError):</div>
<div class="line"><span class="lineno"> 1160</span>        plt.tricontourf(x, y, z, [1.0, 0.0])</div>
<div class="line"><span class="lineno"> 1161</span> </div>
<div class="line"><span class="lineno"> 1162</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af1d9dda3e9c951b38971c9d4fa7d2f14" name="af1d9dda3e9c951b38971c9d4fa7d2f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d9dda3e9c951b38971c9d4fa7d2f14">&#9670;&#160;</a></span>test_tricontourset_reuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tricontourset_reuse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1281</span><span class="keyword">def </span>test_tricontourset_reuse():</div>
<div class="line"><span class="lineno"> 1282</span>    <span class="comment"># If TriContourSet returned from one tricontour(f) call is passed as first</span></div>
<div class="line"><span class="lineno"> 1283</span>    <span class="comment"># argument to another the underlying C++ contour generator will be reused.</span></div>
<div class="line"><span class="lineno"> 1284</span>    x = [0.0, 0.5, 1.0]</div>
<div class="line"><span class="lineno"> 1285</span>    y = [0.0, 1.0, 0.0]</div>
<div class="line"><span class="lineno"> 1286</span>    z = [1.0, 2.0, 3.0]</div>
<div class="line"><span class="lineno"> 1287</span>    fig, ax = plt.subplots()</div>
<div class="line"><span class="lineno"> 1288</span>    tcs1 = ax.tricontourf(x, y, z)</div>
<div class="line"><span class="lineno"> 1289</span>    tcs2 = ax.tricontour(x, y, z)</div>
<div class="line"><span class="lineno"> 1290</span>    <span class="keyword">assert</span> tcs2._contour_generator != tcs1._contour_generator</div>
<div class="line"><span class="lineno"> 1291</span>    tcs3 = ax.tricontour(tcs1, z)</div>
<div class="line"><span class="lineno"> 1292</span>    <span class="keyword">assert</span> tcs3._contour_generator == tcs1._contour_generator</div>
<div class="line"><span class="lineno"> 1293</span> </div>
<div class="line"><span class="lineno"> 1294</span> </div>
<div class="line"><span class="lineno"> 1295</span><span class="preprocessor">@check_figures_equal()</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7425909451069cb623a6154206a93f97" name="a7425909451069cb623a6154206a93f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7425909451069cb623a6154206a93f97">&#9670;&#160;</a></span>test_trifinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_trifinder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  303</span><span class="keyword">def </span>test_trifinder():</div>
<div class="line"><span class="lineno">  304</span>    <span class="comment"># Test points within triangles of masked triangulation.</span></div>
<div class="line"><span class="lineno">  305</span>    x, y = np.meshgrid(np.arange(4), np.arange(4))</div>
<div class="line"><span class="lineno">  306</span>    x = x.ravel()</div>
<div class="line"><span class="lineno">  307</span>    y = y.ravel()</div>
<div class="line"><span class="lineno">  308</span>    triangles = [[0, 1, 4], [1, 5, 4], [1, 2, 5], [2, 6, 5], [2, 3, 6],</div>
<div class="line"><span class="lineno">  309</span>                 [3, 7, 6], [4, 5, 8], [5, 9, 8], [5, 6, 9], [6, 10, 9],</div>
<div class="line"><span class="lineno">  310</span>                 [6, 7, 10], [7, 11, 10], [8, 9, 12], [9, 13, 12], [9, 10, 13],</div>
<div class="line"><span class="lineno">  311</span>                 [10, 14, 13], [10, 11, 14], [11, 15, 14]]</div>
<div class="line"><span class="lineno">  312</span>    mask = np.zeros(len(triangles))</div>
<div class="line"><span class="lineno">  313</span>    mask[8:10] = 1</div>
<div class="line"><span class="lineno">  314</span>    triang = mtri.Triangulation(x, y, triangles, mask)</div>
<div class="line"><span class="lineno">  315</span>    trifinder = triang.get_trifinder()</div>
<div class="line"><span class="lineno">  316</span> </div>
<div class="line"><span class="lineno">  317</span>    xs = [0.25, 1.25, 2.25, 3.25]</div>
<div class="line"><span class="lineno">  318</span>    ys = [0.25, 1.25, 2.25, 3.25]</div>
<div class="line"><span class="lineno">  319</span>    xs, ys = np.meshgrid(xs, ys)</div>
<div class="line"><span class="lineno">  320</span>    xs = xs.ravel()</div>
<div class="line"><span class="lineno">  321</span>    ys = ys.ravel()</div>
<div class="line"><span class="lineno">  322</span>    tris = trifinder(xs, ys)</div>
<div class="line"><span class="lineno">  323</span>    assert_array_equal(tris, [0, 2, 4, -1, 6, -1, 10, -1,</div>
<div class="line"><span class="lineno">  324</span>                              12, 14, 16, -1, -1, -1, -1, -1])</div>
<div class="line"><span class="lineno">  325</span>    tris = trifinder(xs-0.5, ys-0.5)</div>
<div class="line"><span class="lineno">  326</span>    assert_array_equal(tris, [-1, -1, -1, -1, -1, 1, 3, 5,</div>
<div class="line"><span class="lineno">  327</span>                              -1, 7, -1, 11, -1, 13, 15, 17])</div>
<div class="line"><span class="lineno">  328</span> </div>
<div class="line"><span class="lineno">  329</span>    <span class="comment"># Test points exactly on boundary edges of masked triangulation.</span></div>
<div class="line"><span class="lineno">  330</span>    xs = [0.5, 1.5, 2.5, 0.5, 1.5, 2.5, 1.5, 1.5, 0.0, 1.0, 2.0, 3.0]</div>
<div class="line"><span class="lineno">  331</span>    ys = [0.0, 0.0, 0.0, 3.0, 3.0, 3.0, 1.0, 2.0, 1.5, 1.5, 1.5, 1.5]</div>
<div class="line"><span class="lineno">  332</span>    tris = trifinder(xs, ys)</div>
<div class="line"><span class="lineno">  333</span>    assert_array_equal(tris, [0, 2, 4, 13, 15, 17, 3, 14, 6, 7, 10, 11])</div>
<div class="line"><span class="lineno">  334</span> </div>
<div class="line"><span class="lineno">  335</span>    <span class="comment"># Test points exactly on boundary corners of masked triangulation.</span></div>
<div class="line"><span class="lineno">  336</span>    xs = [0.0, 3.0]</div>
<div class="line"><span class="lineno">  337</span>    ys = [0.0, 3.0]</div>
<div class="line"><span class="lineno">  338</span>    tris = trifinder(xs, ys)</div>
<div class="line"><span class="lineno">  339</span>    assert_array_equal(tris, [0, 17])</div>
<div class="line"><span class="lineno">  340</span> </div>
<div class="line"><span class="lineno">  341</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  342</span>    <span class="comment"># Test triangles with horizontal colinear points.  These are not valid</span></div>
<div class="line"><span class="lineno">  343</span>    <span class="comment"># triangulations, but we try to deal with the simplest violations.</span></div>
<div class="line"><span class="lineno">  344</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>    <span class="comment"># If +ve, triangulation is OK, if -ve triangulation invalid,</span></div>
<div class="line"><span class="lineno">  347</span>    <span class="comment"># if zero have colinear points but should pass tests anyway.</span></div>
<div class="line"><span class="lineno">  348</span>    delta = 0.0</div>
<div class="line"><span class="lineno">  349</span> </div>
<div class="line"><span class="lineno">  350</span>    x = [1.5, 0,  1,  2, 3, 1.5,   1.5]</div>
<div class="line"><span class="lineno">  351</span>    y = [-1,  0,  0,  0, 0, delta, 1]</div>
<div class="line"><span class="lineno">  352</span>    triangles = [[0, 2, 1], [0, 3, 2], [0, 4, 3], [1, 2, 5], [2, 3, 5],</div>
<div class="line"><span class="lineno">  353</span>                 [3, 4, 5], [1, 5, 6], [4, 6, 5]]</div>
<div class="line"><span class="lineno">  354</span>    triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  355</span>    trifinder = triang.get_trifinder()</div>
<div class="line"><span class="lineno">  356</span> </div>
<div class="line"><span class="lineno">  357</span>    xs = [-0.1, 0.4, 0.9, 1.4, 1.9, 2.4, 2.9]</div>
<div class="line"><span class="lineno">  358</span>    ys = [-0.1, 0.1]</div>
<div class="line"><span class="lineno">  359</span>    xs, ys = np.meshgrid(xs, ys)</div>
<div class="line"><span class="lineno">  360</span>    tris = trifinder(xs, ys)</div>
<div class="line"><span class="lineno">  361</span>    assert_array_equal(tris, [[-1, 0, 0, 1, 1, 2, -1],</div>
<div class="line"><span class="lineno">  362</span>                              [-1, 6, 6, 6, 7, 7, -1]])</div>
<div class="line"><span class="lineno">  363</span> </div>
<div class="line"><span class="lineno">  364</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  365</span>    <span class="comment"># Test triangles with vertical colinear points.  These are not valid</span></div>
<div class="line"><span class="lineno">  366</span>    <span class="comment"># triangulations, but we try to deal with the simplest violations.</span></div>
<div class="line"><span class="lineno">  367</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span>    <span class="comment"># If +ve, triangulation is OK, if -ve triangulation invalid,</span></div>
<div class="line"><span class="lineno">  370</span>    <span class="comment"># if zero have colinear points but should pass tests anyway.</span></div>
<div class="line"><span class="lineno">  371</span>    delta = 0.0</div>
<div class="line"><span class="lineno">  372</span> </div>
<div class="line"><span class="lineno">  373</span>    x = [-1, -delta, 0,  0,  0, 0, 1]</div>
<div class="line"><span class="lineno">  374</span>    y = [1.5, 1.5,   0,  1,  2, 3, 1.5]</div>
<div class="line"><span class="lineno">  375</span>    triangles = [[0, 1, 2], [0, 1, 5], [1, 2, 3], [1, 3, 4], [1, 4, 5],</div>
<div class="line"><span class="lineno">  376</span>                 [2, 6, 3], [3, 6, 4], [4, 6, 5]]</div>
<div class="line"><span class="lineno">  377</span>    triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  378</span>    trifinder = triang.get_trifinder()</div>
<div class="line"><span class="lineno">  379</span> </div>
<div class="line"><span class="lineno">  380</span>    xs = [-0.1, 0.1]</div>
<div class="line"><span class="lineno">  381</span>    ys = [-0.1, 0.4, 0.9, 1.4, 1.9, 2.4, 2.9]</div>
<div class="line"><span class="lineno">  382</span>    xs, ys = np.meshgrid(xs, ys)</div>
<div class="line"><span class="lineno">  383</span>    tris = trifinder(xs, ys)</div>
<div class="line"><span class="lineno">  384</span>    assert_array_equal(tris, [[-1, -1], [0, 5], [0, 5], [0, 6], [1, 6], [1, 7],</div>
<div class="line"><span class="lineno">  385</span>                              [-1, -1]])</div>
<div class="line"><span class="lineno">  386</span> </div>
<div class="line"><span class="lineno">  387</span>    <span class="comment"># Test that changing triangulation by setting a mask causes the trifinder</span></div>
<div class="line"><span class="lineno">  388</span>    <span class="comment"># to be reinitialised.</span></div>
<div class="line"><span class="lineno">  389</span>    x = [0, 1, 0, 1]</div>
<div class="line"><span class="lineno">  390</span>    y = [0, 0, 1, 1]</div>
<div class="line"><span class="lineno">  391</span>    triangles = [[0, 1, 2], [1, 3, 2]]</div>
<div class="line"><span class="lineno">  392</span>    triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  393</span>    trifinder = triang.get_trifinder()</div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span>    xs = [-0.2, 0.2, 0.8, 1.2]</div>
<div class="line"><span class="lineno">  396</span>    ys = [0.5, 0.5, 0.5, 0.5]</div>
<div class="line"><span class="lineno">  397</span>    tris = trifinder(xs, ys)</div>
<div class="line"><span class="lineno">  398</span>    assert_array_equal(tris, [-1, 0, 1, -1])</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>    triang.set_mask([1, 0])</div>
<div class="line"><span class="lineno">  401</span>    <span class="keyword">assert</span> trifinder == triang.get_trifinder()</div>
<div class="line"><span class="lineno">  402</span>    tris = trifinder(xs, ys)</div>
<div class="line"><span class="lineno">  403</span>    assert_array_equal(tris, [-1, -1, 1, -1])</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a16394f1732e10442067d5ebbfd544d9b" name="a16394f1732e10442067d5ebbfd544d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16394f1732e10442067d5ebbfd544d9b">&#9670;&#160;</a></span>test_triinterp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triinterp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  406</span><span class="keyword">def </span>test_triinterp():</div>
<div class="line"><span class="lineno">  407</span>    <span class="comment"># Test points within triangles of masked triangulation.</span></div>
<div class="line"><span class="lineno">  408</span>    x, y = np.meshgrid(np.arange(4), np.arange(4))</div>
<div class="line"><span class="lineno">  409</span>    x = x.ravel()</div>
<div class="line"><span class="lineno">  410</span>    y = y.ravel()</div>
<div class="line"><span class="lineno">  411</span>    z = 1.23*x - 4.79*y</div>
<div class="line"><span class="lineno">  412</span>    triangles = [[0, 1, 4], [1, 5, 4], [1, 2, 5], [2, 6, 5], [2, 3, 6],</div>
<div class="line"><span class="lineno">  413</span>                 [3, 7, 6], [4, 5, 8], [5, 9, 8], [5, 6, 9], [6, 10, 9],</div>
<div class="line"><span class="lineno">  414</span>                 [6, 7, 10], [7, 11, 10], [8, 9, 12], [9, 13, 12], [9, 10, 13],</div>
<div class="line"><span class="lineno">  415</span>                 [10, 14, 13], [10, 11, 14], [11, 15, 14]]</div>
<div class="line"><span class="lineno">  416</span>    mask = np.zeros(len(triangles))</div>
<div class="line"><span class="lineno">  417</span>    mask[8:10] = 1</div>
<div class="line"><span class="lineno">  418</span>    triang = mtri.Triangulation(x, y, triangles, mask)</div>
<div class="line"><span class="lineno">  419</span>    linear_interp = mtri.LinearTriInterpolator(triang, z)</div>
<div class="line"><span class="lineno">  420</span>    cubic_min_E = mtri.CubicTriInterpolator(triang, z)</div>
<div class="line"><span class="lineno">  421</span>    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind=<span class="stringliteral">&#39;geom&#39;</span>)</div>
<div class="line"><span class="lineno">  422</span> </div>
<div class="line"><span class="lineno">  423</span>    xs = np.linspace(0.25, 2.75, 6)</div>
<div class="line"><span class="lineno">  424</span>    ys = [0.25, 0.75, 2.25, 2.75]</div>
<div class="line"><span class="lineno">  425</span>    xs, ys = np.meshgrid(xs, ys)  <span class="comment"># Testing arrays with array.ndim = 2</span></div>
<div class="line"><span class="lineno">  426</span>    <span class="keywordflow">for</span> interp <span class="keywordflow">in</span> (linear_interp, cubic_min_E, cubic_geom):</div>
<div class="line"><span class="lineno">  427</span>        zs = interp(xs, ys)</div>
<div class="line"><span class="lineno">  428</span>        assert_array_almost_equal(zs, (1.23*xs - 4.79*ys))</div>
<div class="line"><span class="lineno">  429</span> </div>
<div class="line"><span class="lineno">  430</span>    <span class="comment"># Test points outside triangulation.</span></div>
<div class="line"><span class="lineno">  431</span>    xs = [-0.25, 1.25, 1.75, 3.25]</div>
<div class="line"><span class="lineno">  432</span>    ys = xs</div>
<div class="line"><span class="lineno">  433</span>    xs, ys = np.meshgrid(xs, ys)</div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">for</span> interp <span class="keywordflow">in</span> (linear_interp, cubic_min_E, cubic_geom):</div>
<div class="line"><span class="lineno">  435</span>        zs = linear_interp(xs, ys)</div>
<div class="line"><span class="lineno">  436</span>        assert_array_equal(zs.mask, [[<span class="keyword">True</span>]*4]*4)</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span>    <span class="comment"># Test mixed configuration (outside / inside).</span></div>
<div class="line"><span class="lineno">  439</span>    xs = np.linspace(0.25, 1.75, 6)</div>
<div class="line"><span class="lineno">  440</span>    ys = [0.25, 0.75, 1.25, 1.75]</div>
<div class="line"><span class="lineno">  441</span>    xs, ys = np.meshgrid(xs, ys)</div>
<div class="line"><span class="lineno">  442</span>    <span class="keywordflow">for</span> interp <span class="keywordflow">in</span> (linear_interp, cubic_min_E, cubic_geom):</div>
<div class="line"><span class="lineno">  443</span>        zs = interp(xs, ys)</div>
<div class="line"><span class="lineno">  444</span>        matest.assert_array_almost_equal(zs, (1.23*xs - 4.79*ys))</div>
<div class="line"><span class="lineno">  445</span>        mask = (xs &gt;= 1) * (xs &lt;= 2) * (ys &gt;= 1) * (ys &lt;= 2)</div>
<div class="line"><span class="lineno">  446</span>        assert_array_equal(zs.mask, mask)</div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span>    <span class="comment"># 2nd order patch test: on a grid with an &#39;arbitrary shaped&#39; triangle,</span></div>
<div class="line"><span class="lineno">  449</span>    <span class="comment"># patch test shall be exact for quadratic functions and cubic</span></div>
<div class="line"><span class="lineno">  450</span>    <span class="comment"># interpolator if *kind* = user</span></div>
<div class="line"><span class="lineno">  451</span>    (a, b, c) = (1.23, -4.79, 0.6)</div>
<div class="line"><span class="lineno">  452</span> </div>
<div class="line"><span class="lineno">  453</span>    <span class="keyword">def </span>quad(x, y):</div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">return</span> a*(x-0.5)**2 + b*(y-0.5)**2 + c*x*y</div>
<div class="line"><span class="lineno">  455</span> </div>
<div class="line"><span class="lineno">  456</span>    <span class="keyword">def </span>gradient_quad(x, y):</div>
<div class="line"><span class="lineno">  457</span>        <span class="keywordflow">return</span> (2*a*(x-0.5) + c*y, 2*b*(y-0.5) + c*x)</div>
<div class="line"><span class="lineno">  458</span> </div>
<div class="line"><span class="lineno">  459</span>    x = np.array([0.2, 0.33367, 0.669, 0., 1., 1., 0.])</div>
<div class="line"><span class="lineno">  460</span>    y = np.array([0.3, 0.80755, 0.4335, 0., 0., 1., 1.])</div>
<div class="line"><span class="lineno">  461</span>    triangles = np.array([[0, 1, 2], [3, 0, 4], [4, 0, 2], [4, 2, 5],</div>
<div class="line"><span class="lineno">  462</span>                          [1, 5, 2], [6, 5, 1], [6, 1, 0], [6, 0, 3]])</div>
<div class="line"><span class="lineno">  463</span>    triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  464</span>    z = quad(x, y)</div>
<div class="line"><span class="lineno">  465</span>    dz = gradient_quad(x, y)</div>
<div class="line"><span class="lineno">  466</span>    <span class="comment"># test points for 2nd order patch test</span></div>
<div class="line"><span class="lineno">  467</span>    xs = np.linspace(0., 1., 5)</div>
<div class="line"><span class="lineno">  468</span>    ys = np.linspace(0., 1., 5)</div>
<div class="line"><span class="lineno">  469</span>    xs, ys = np.meshgrid(xs, ys)</div>
<div class="line"><span class="lineno">  470</span>    cubic_user = mtri.CubicTriInterpolator(triang, z, kind=<span class="stringliteral">&#39;user&#39;</span>, dz=dz)</div>
<div class="line"><span class="lineno">  471</span>    interp_zs = cubic_user(xs, ys)</div>
<div class="line"><span class="lineno">  472</span>    assert_array_almost_equal(interp_zs, quad(xs, ys))</div>
<div class="line"><span class="lineno">  473</span>    (interp_dzsdx, interp_dzsdy) = cubic_user.gradient(x, y)</div>
<div class="line"><span class="lineno">  474</span>    (dzsdx, dzsdy) = gradient_quad(x, y)</div>
<div class="line"><span class="lineno">  475</span>    assert_array_almost_equal(interp_dzsdx, dzsdx)</div>
<div class="line"><span class="lineno">  476</span>    assert_array_almost_equal(interp_dzsdy, dzsdy)</div>
<div class="line"><span class="lineno">  477</span> </div>
<div class="line"><span class="lineno">  478</span>    <span class="comment"># Cubic improvement: cubic interpolation shall perform better than linear</span></div>
<div class="line"><span class="lineno">  479</span>    <span class="comment"># on a sufficiently dense mesh for a quadratic function.</span></div>
<div class="line"><span class="lineno">  480</span>    n = 11</div>
<div class="line"><span class="lineno">  481</span>    x, y = np.meshgrid(np.linspace(0., 1., n+1), np.linspace(0., 1., n+1))</div>
<div class="line"><span class="lineno">  482</span>    x = x.ravel()</div>
<div class="line"><span class="lineno">  483</span>    y = y.ravel()</div>
<div class="line"><span class="lineno">  484</span>    z = quad(x, y)</div>
<div class="line"><span class="lineno">  485</span>    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n+1))</div>
<div class="line"><span class="lineno">  486</span>    xs, ys = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))</div>
<div class="line"><span class="lineno">  487</span>    xs = xs.ravel()</div>
<div class="line"><span class="lineno">  488</span>    ys = ys.ravel()</div>
<div class="line"><span class="lineno">  489</span>    linear_interp = mtri.LinearTriInterpolator(triang, z)</div>
<div class="line"><span class="lineno">  490</span>    cubic_min_E = mtri.CubicTriInterpolator(triang, z)</div>
<div class="line"><span class="lineno">  491</span>    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind=<span class="stringliteral">&#39;geom&#39;</span>)</div>
<div class="line"><span class="lineno">  492</span>    zs = quad(xs, ys)</div>
<div class="line"><span class="lineno">  493</span>    diff_lin = np.abs(linear_interp(xs, ys) - zs)</div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">for</span> interp <span class="keywordflow">in</span> (cubic_min_E, cubic_geom):</div>
<div class="line"><span class="lineno">  495</span>        diff_cubic = np.abs(interp(xs, ys) - zs)</div>
<div class="line"><span class="lineno">  496</span>        <span class="keyword">assert</span> np.max(diff_lin) &gt;= 10 * np.max(diff_cubic)</div>
<div class="line"><span class="lineno">  497</span>        <span class="keyword">assert</span> (np.dot(diff_lin, diff_lin) &gt;=</div>
<div class="line"><span class="lineno">  498</span>                100 * np.dot(diff_cubic, diff_cubic))</div>
<div class="line"><span class="lineno">  499</span> </div>
<div class="line"><span class="lineno">  500</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae801ccc15d8b97505c36f7ebda5fee4" name="aae801ccc15d8b97505c36f7ebda5fee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae801ccc15d8b97505c36f7ebda5fee4">&#9670;&#160;</a></span>test_triinterp_colinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triinterp_colinear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  691</span><span class="keyword">def </span>test_triinterp_colinear():</div>
<div class="line"><span class="lineno">  692</span>    <span class="comment"># Tests interpolating inside a triangulation with horizontal colinear</span></div>
<div class="line"><span class="lineno">  693</span>    <span class="comment"># points (refer also to the tests :func:`test_trifinder` ).</span></div>
<div class="line"><span class="lineno">  694</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  695</span>    <span class="comment"># These are not valid triangulations, but we try to deal with the</span></div>
<div class="line"><span class="lineno">  696</span>    <span class="comment"># simplest violations (i. e. those handled by default TriFinder).</span></div>
<div class="line"><span class="lineno">  697</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  698</span>    <span class="comment"># Note that the LinearTriInterpolator and the CubicTriInterpolator with</span></div>
<div class="line"><span class="lineno">  699</span>    <span class="comment"># kind=&#39;min_E&#39; or &#39;geom&#39; still pass a linear patch test.</span></div>
<div class="line"><span class="lineno">  700</span>    <span class="comment"># We also test interpolation inside a flat triangle, by forcing</span></div>
<div class="line"><span class="lineno">  701</span>    <span class="comment"># *tri_index* in a call to :meth:`_interpolate_multikeys`.</span></div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <span class="comment"># If +ve, triangulation is OK, if -ve triangulation invalid,</span></div>
<div class="line"><span class="lineno">  704</span>    <span class="comment"># if zero have colinear points but should pass tests anyway.</span></div>
<div class="line"><span class="lineno">  705</span>    delta = 0.</div>
<div class="line"><span class="lineno">  706</span> </div>
<div class="line"><span class="lineno">  707</span>    x0 = np.array([1.5, 0,  1,  2, 3, 1.5,   1.5])</div>
<div class="line"><span class="lineno">  708</span>    y0 = np.array([-1,  0,  0,  0, 0, delta, 1])</div>
<div class="line"><span class="lineno">  709</span> </div>
<div class="line"><span class="lineno">  710</span>    <span class="comment"># We test different affine transformations of the initial figure; to</span></div>
<div class="line"><span class="lineno">  711</span>    <span class="comment"># avoid issues related to round-off errors we only use integer</span></div>
<div class="line"><span class="lineno">  712</span>    <span class="comment"># coefficients (otherwise the Triangulation might become invalid even with</span></div>
<div class="line"><span class="lineno">  713</span>    <span class="comment"># delta == 0).</span></div>
<div class="line"><span class="lineno">  714</span>    transformations = [[1, 0], [0, 1], [1, 1], [1, 2], [-2, -1], [-2, 1]]</div>
<div class="line"><span class="lineno">  715</span>    <span class="keywordflow">for</span> transformation <span class="keywordflow">in</span> transformations:</div>
<div class="line"><span class="lineno">  716</span>        x_rot = transformation[0]*x0 + transformation[1]*y0</div>
<div class="line"><span class="lineno">  717</span>        y_rot = -transformation[1]*x0 + transformation[0]*y0</div>
<div class="line"><span class="lineno">  718</span>        (x, y) = (x_rot, y_rot)</div>
<div class="line"><span class="lineno">  719</span>        z = 1.23*x - 4.79*y</div>
<div class="line"><span class="lineno">  720</span>        triangles = [[0, 2, 1], [0, 3, 2], [0, 4, 3], [1, 2, 5], [2, 3, 5],</div>
<div class="line"><span class="lineno">  721</span>                     [3, 4, 5], [1, 5, 6], [4, 6, 5]]</div>
<div class="line"><span class="lineno">  722</span>        triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  723</span>        xs = np.linspace(np.min(triang.x), np.max(triang.x), 20)</div>
<div class="line"><span class="lineno">  724</span>        ys = np.linspace(np.min(triang.y), np.max(triang.y), 20)</div>
<div class="line"><span class="lineno">  725</span>        xs, ys = np.meshgrid(xs, ys)</div>
<div class="line"><span class="lineno">  726</span>        xs = xs.ravel()</div>
<div class="line"><span class="lineno">  727</span>        ys = ys.ravel()</div>
<div class="line"><span class="lineno">  728</span>        mask_out = (triang.get_trifinder()(xs, ys) == -1)</div>
<div class="line"><span class="lineno">  729</span>        zs_target = np.ma.array(1.23*xs - 4.79*ys, mask=mask_out)</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span>        linear_interp = mtri.LinearTriInterpolator(triang, z)</div>
<div class="line"><span class="lineno">  732</span>        cubic_min_E = mtri.CubicTriInterpolator(triang, z)</div>
<div class="line"><span class="lineno">  733</span>        cubic_geom = mtri.CubicTriInterpolator(triang, z, kind=<span class="stringliteral">&#39;geom&#39;</span>)</div>
<div class="line"><span class="lineno">  734</span> </div>
<div class="line"><span class="lineno">  735</span>        <span class="keywordflow">for</span> interp <span class="keywordflow">in</span> (linear_interp, cubic_min_E, cubic_geom):</div>
<div class="line"><span class="lineno">  736</span>            zs = interp(xs, ys)</div>
<div class="line"><span class="lineno">  737</span>            assert_array_almost_equal(zs_target, zs)</div>
<div class="line"><span class="lineno">  738</span> </div>
<div class="line"><span class="lineno">  739</span>        <span class="comment"># Testing interpolation inside the flat triangle number 4: [2, 3, 5]</span></div>
<div class="line"><span class="lineno">  740</span>        <span class="comment"># by imposing *tri_index* in a call to :meth:`_interpolate_multikeys`</span></div>
<div class="line"><span class="lineno">  741</span>        itri = 4</div>
<div class="line"><span class="lineno">  742</span>        pt1 = triang.triangles[itri, 0]</div>
<div class="line"><span class="lineno">  743</span>        pt2 = triang.triangles[itri, 1]</div>
<div class="line"><span class="lineno">  744</span>        xs = np.linspace(triang.x[pt1], triang.x[pt2], 10)</div>
<div class="line"><span class="lineno">  745</span>        ys = np.linspace(triang.y[pt1], triang.y[pt2], 10)</div>
<div class="line"><span class="lineno">  746</span>        zs_target = 1.23*xs - 4.79*ys</div>
<div class="line"><span class="lineno">  747</span>        <span class="keywordflow">for</span> interp <span class="keywordflow">in</span> (linear_interp, cubic_min_E, cubic_geom):</div>
<div class="line"><span class="lineno">  748</span>            zs, = interp._interpolate_multikeys(</div>
<div class="line"><span class="lineno">  749</span>                xs, ys, tri_index=itri*np.ones(10, dtype=np.int32))</div>
<div class="line"><span class="lineno">  750</span>            assert_array_almost_equal(zs_target, zs)</div>
<div class="line"><span class="lineno">  751</span> </div>
<div class="line"><span class="lineno">  752</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cb79e8d3207870b2f4fd2f313111a8c" name="a6cb79e8d3207870b2f4fd2f313111a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb79e8d3207870b2f4fd2f313111a8c">&#9670;&#160;</a></span>test_triinterp_transformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triinterp_transformations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  753</span><span class="keyword">def </span>test_triinterp_transformations():</div>
<div class="line"><span class="lineno">  754</span>    <span class="comment"># 1) Testing that the interpolation scheme is invariant by rotation of the</span></div>
<div class="line"><span class="lineno">  755</span>    <span class="comment"># whole figure.</span></div>
<div class="line"><span class="lineno">  756</span>    <span class="comment"># Note: This test is non-trivial for a CubicTriInterpolator with</span></div>
<div class="line"><span class="lineno">  757</span>    <span class="comment"># kind=&#39;min_E&#39;. It does fail for a non-isotropic stiffness matrix E of</span></div>
<div class="line"><span class="lineno">  758</span>    <span class="comment"># :class:`_ReducedHCT_Element` (tested with E=np.diag([1., 1., 1.])), and</span></div>
<div class="line"><span class="lineno">  759</span>    <span class="comment"># provides a good test for :meth:`get_Kff_and_Ff`of the same class.</span></div>
<div class="line"><span class="lineno">  760</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  761</span>    <span class="comment"># 2) Also testing that the interpolation scheme is invariant by expansion</span></div>
<div class="line"><span class="lineno">  762</span>    <span class="comment"># of the whole figure along one axis.</span></div>
<div class="line"><span class="lineno">  763</span>    n_angles = 20</div>
<div class="line"><span class="lineno">  764</span>    n_radii = 10</div>
<div class="line"><span class="lineno">  765</span>    min_radius = 0.15</div>
<div class="line"><span class="lineno">  766</span> </div>
<div class="line"><span class="lineno">  767</span>    <span class="keyword">def </span><a class="code hl_variable" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>(x, y):</div>
<div class="line"><span class="lineno">  768</span>        r1 = np.hypot(0.5 - x, 0.5 - y)</div>
<div class="line"><span class="lineno">  769</span>        theta1 = np.arctan2(0.5 - x, 0.5 - y)</div>
<div class="line"><span class="lineno">  770</span>        r2 = np.hypot(-x - 0.2, -y - 0.2)</div>
<div class="line"><span class="lineno">  771</span>        theta2 = np.arctan2(-x - 0.2, -y - 0.2)</div>
<div class="line"><span class="lineno">  772</span>        z = -(2*(np.exp((r1/10)**2)-1)*30. * np.cos(7.*theta1) +</div>
<div class="line"><span class="lineno">  773</span>              (np.exp((r2/10)**2)-1)*30. * np.cos(11.*theta2) +</div>
<div class="line"><span class="lineno">  774</span>              0.7*(x**2 + y**2))</div>
<div class="line"><span class="lineno">  775</span>        <span class="keywordflow">return</span> (np.max(z)-z)/(np.max(z)-np.min(z))</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span>    <span class="comment"># First create the x and y coordinates of the points.</span></div>
<div class="line"><span class="lineno">  778</span>    radii = np.linspace(min_radius, 0.95, n_radii)</div>
<div class="line"><span class="lineno">  779</span>    angles = np.linspace(0 + n_angles, 2*np.pi + n_angles,</div>
<div class="line"><span class="lineno">  780</span>                         n_angles, endpoint=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  781</span>    angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)</div>
<div class="line"><span class="lineno">  782</span>    angles[:, 1::2] += np.pi/n_angles</div>
<div class="line"><span class="lineno">  783</span>    x0 = (radii*np.cos(angles)).flatten()</div>
<div class="line"><span class="lineno">  784</span>    y0 = (radii*np.sin(angles)).flatten()</div>
<div class="line"><span class="lineno">  785</span>    triang0 = mtri.Triangulation(x0, y0)  <span class="comment"># Delaunay triangulation</span></div>
<div class="line"><span class="lineno">  786</span>    z0 = <a class="code hl_variable" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>(x0, y0)</div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    <span class="comment"># Then create the test points</span></div>
<div class="line"><span class="lineno">  789</span>    xs0 = np.linspace(-1., 1., 23)</div>
<div class="line"><span class="lineno">  790</span>    ys0 = np.linspace(-1., 1., 23)</div>
<div class="line"><span class="lineno">  791</span>    xs0, ys0 = np.meshgrid(xs0, ys0)</div>
<div class="line"><span class="lineno">  792</span>    xs0 = xs0.ravel()</div>
<div class="line"><span class="lineno">  793</span>    ys0 = ys0.ravel()</div>
<div class="line"><span class="lineno">  794</span> </div>
<div class="line"><span class="lineno">  795</span>    interp_z0 = {}</div>
<div class="line"><span class="lineno">  796</span>    <span class="keywordflow">for</span> i_angle <span class="keywordflow">in</span> range(2):</div>
<div class="line"><span class="lineno">  797</span>        <span class="comment"># Rotating everything</span></div>
<div class="line"><span class="lineno">  798</span>        theta = 2*np.pi / n_angles * i_angle</div>
<div class="line"><span class="lineno">  799</span>        x = np.cos(theta)*x0 + np.sin(theta)*y0</div>
<div class="line"><span class="lineno">  800</span>        y = -np.sin(theta)*x0 + np.cos(theta)*y0</div>
<div class="line"><span class="lineno">  801</span>        xs = np.cos(theta)*xs0 + np.sin(theta)*ys0</div>
<div class="line"><span class="lineno">  802</span>        ys = -np.sin(theta)*xs0 + np.cos(theta)*ys0</div>
<div class="line"><span class="lineno">  803</span>        triang = mtri.Triangulation(x, y, triang0.triangles)</div>
<div class="line"><span class="lineno">  804</span>        linear_interp = mtri.LinearTriInterpolator(triang, z0)</div>
<div class="line"><span class="lineno">  805</span>        cubic_min_E = mtri.CubicTriInterpolator(triang, z0)</div>
<div class="line"><span class="lineno">  806</span>        cubic_geom = mtri.CubicTriInterpolator(triang, z0, kind=<span class="stringliteral">&#39;geom&#39;</span>)</div>
<div class="line"><span class="lineno">  807</span>        dic_interp = {<span class="stringliteral">&#39;lin&#39;</span>: linear_interp,</div>
<div class="line"><span class="lineno">  808</span>                      <span class="stringliteral">&#39;min_E&#39;</span>: cubic_min_E,</div>
<div class="line"><span class="lineno">  809</span>                      <span class="stringliteral">&#39;geom&#39;</span>: cubic_geom}</div>
<div class="line"><span class="lineno">  810</span>        <span class="comment"># Testing that the interpolation is invariant by rotation...</span></div>
<div class="line"><span class="lineno">  811</span>        <span class="keywordflow">for</span> interp_key <span class="keywordflow">in</span> [<span class="stringliteral">&#39;lin&#39;</span>, <span class="stringliteral">&#39;min_E&#39;</span>, <span class="stringliteral">&#39;geom&#39;</span>]:</div>
<div class="line"><span class="lineno">  812</span>            interp = dic_interp[interp_key]</div>
<div class="line"><span class="lineno">  813</span>            <span class="keywordflow">if</span> i_angle == 0:</div>
<div class="line"><span class="lineno">  814</span>                interp_z0[interp_key] = interp(xs0, ys0)  <span class="comment"># storage</span></div>
<div class="line"><span class="lineno">  815</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  816</span>                interpz = interp(xs, ys)</div>
<div class="line"><span class="lineno">  817</span>                matest.assert_array_almost_equal(interpz,</div>
<div class="line"><span class="lineno">  818</span>                                                 interp_z0[interp_key])</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>    scale_factor = 987654.3210</div>
<div class="line"><span class="lineno">  821</span>    <span class="keywordflow">for</span> scaled_axis <span class="keywordflow">in</span> (<span class="stringliteral">&#39;x&#39;</span>, <span class="stringliteral">&#39;y&#39;</span>):</div>
<div class="line"><span class="lineno">  822</span>        <span class="comment"># Scaling everything (expansion along scaled_axis)</span></div>
<div class="line"><span class="lineno">  823</span>        <span class="keywordflow">if</span> scaled_axis == <span class="stringliteral">&#39;x&#39;</span>:</div>
<div class="line"><span class="lineno">  824</span>            x = scale_factor * x0</div>
<div class="line"><span class="lineno">  825</span>            y = y0</div>
<div class="line"><span class="lineno">  826</span>            xs = scale_factor * xs0</div>
<div class="line"><span class="lineno">  827</span>            ys = ys0</div>
<div class="line"><span class="lineno">  828</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  829</span>            x = x0</div>
<div class="line"><span class="lineno">  830</span>            y = scale_factor * y0</div>
<div class="line"><span class="lineno">  831</span>            xs = xs0</div>
<div class="line"><span class="lineno">  832</span>            ys = scale_factor * ys0</div>
<div class="line"><span class="lineno">  833</span>        triang = mtri.Triangulation(x, y, triang0.triangles)</div>
<div class="line"><span class="lineno">  834</span>        linear_interp = mtri.LinearTriInterpolator(triang, z0)</div>
<div class="line"><span class="lineno">  835</span>        cubic_min_E = mtri.CubicTriInterpolator(triang, z0)</div>
<div class="line"><span class="lineno">  836</span>        cubic_geom = mtri.CubicTriInterpolator(triang, z0, kind=<span class="stringliteral">&#39;geom&#39;</span>)</div>
<div class="line"><span class="lineno">  837</span>        dic_interp = {<span class="stringliteral">&#39;lin&#39;</span>: linear_interp,</div>
<div class="line"><span class="lineno">  838</span>                      <span class="stringliteral">&#39;min_E&#39;</span>: cubic_min_E,</div>
<div class="line"><span class="lineno">  839</span>                      <span class="stringliteral">&#39;geom&#39;</span>: cubic_geom}</div>
<div class="line"><span class="lineno">  840</span>        <span class="comment"># Test that the interpolation is invariant by expansion along 1 axis...</span></div>
<div class="line"><span class="lineno">  841</span>        <span class="keywordflow">for</span> interp_key <span class="keywordflow">in</span> [<span class="stringliteral">&#39;lin&#39;</span>, <span class="stringliteral">&#39;min_E&#39;</span>, <span class="stringliteral">&#39;geom&#39;</span>]:</div>
<div class="line"><span class="lineno">  842</span>            interpz = dic_interp[interp_key](xs, ys)</div>
<div class="line"><span class="lineno">  843</span>            matest.assert_array_almost_equal(interpz, interp_z0[interp_key])</div>
<div class="line"><span class="lineno">  844</span> </div>
<div class="line"><span class="lineno">  845</span> </div>
<div class="line"><span class="lineno">  846</span><span class="preprocessor">@image_comparison([&#39;tri_smooth_contouring.png&#39;], remove_text=True, tol=0.072)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aefc8d32f1b06152141bb56802553fa8a" name="aefc8d32f1b06152141bb56802553fa8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc8d32f1b06152141bb56802553fa8a">&#9670;&#160;</a></span>test_triinterpcubic_C1_continuity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triinterpcubic_C1_continuity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  501</span><span class="keyword">def </span>test_triinterpcubic_C1_continuity():</div>
<div class="line"><span class="lineno">  502</span>    <span class="comment"># Below the 4 tests which demonstrate C1 continuity of the</span></div>
<div class="line"><span class="lineno">  503</span>    <span class="comment"># TriCubicInterpolator (testing the cubic shape functions on arbitrary</span></div>
<div class="line"><span class="lineno">  504</span>    <span class="comment"># triangle):</span></div>
<div class="line"><span class="lineno">  505</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  506</span>    <span class="comment"># 1) Testing continuity of function &amp; derivatives at corner for all 9</span></div>
<div class="line"><span class="lineno">  507</span>    <span class="comment">#    shape functions. Testing also function values at same location.</span></div>
<div class="line"><span class="lineno">  508</span>    <span class="comment"># 2) Testing C1 continuity along each edge (as gradient is polynomial of</span></div>
<div class="line"><span class="lineno">  509</span>    <span class="comment">#    2nd order, it is sufficient to test at the middle).</span></div>
<div class="line"><span class="lineno">  510</span>    <span class="comment"># 3) Testing C1 continuity at triangle barycenter (where the 3 subtriangles</span></div>
<div class="line"><span class="lineno">  511</span>    <span class="comment">#    meet)</span></div>
<div class="line"><span class="lineno">  512</span>    <span class="comment"># 4) Testing C1 continuity at median 1/3 points (midside between 2</span></div>
<div class="line"><span class="lineno">  513</span>    <span class="comment">#    subtriangles)</span></div>
<div class="line"><span class="lineno">  514</span> </div>
<div class="line"><span class="lineno">  515</span>    <span class="comment"># Utility test function check_continuity</span></div>
<div class="line"><span class="lineno">  516</span>    <span class="keyword">def </span>check_continuity(interpolator, loc, values=None):</div>
<div class="line"><span class="lineno">  517</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">        Checks the continuity of interpolator (and its derivatives) near</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        location loc. Can check the value at loc itself if *values* is</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        provided.</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        *interpolator* TriInterpolator</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        *loc* location to test (x0, y0)</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        *values* (optional) array [z0, dzx0, dzy0] to check the value at *loc*</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  526</span>        n_star = 24       <span class="comment"># Number of continuity points in a boundary of loc</span></div>
<div class="line"><span class="lineno">  527</span>        epsilon = 1.e-10  <span class="comment"># Distance for loc boundary</span></div>
<div class="line"><span class="lineno">  528</span>        k = 100.          <span class="comment"># Continuity coefficient</span></div>
<div class="line"><span class="lineno">  529</span>        (loc_x, loc_y) = loc</div>
<div class="line"><span class="lineno">  530</span>        star_x = loc_x + epsilon*np.cos(np.linspace(0., 2*np.pi, n_star))</div>
<div class="line"><span class="lineno">  531</span>        star_y = loc_y + epsilon*np.sin(np.linspace(0., 2*np.pi, n_star))</div>
<div class="line"><span class="lineno">  532</span>        z = interpolator([loc_x], [loc_y])[0]</div>
<div class="line"><span class="lineno">  533</span>        (dzx, dzy) = interpolator.gradient([loc_x], [loc_y])</div>
<div class="line"><span class="lineno">  534</span>        <span class="keywordflow">if</span> values <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  535</span>            assert_array_almost_equal(z, values[0])</div>
<div class="line"><span class="lineno">  536</span>            assert_array_almost_equal(dzx[0], values[1])</div>
<div class="line"><span class="lineno">  537</span>            assert_array_almost_equal(dzy[0], values[2])</div>
<div class="line"><span class="lineno">  538</span>        diff_z = interpolator(star_x, star_y) - z</div>
<div class="line"><span class="lineno">  539</span>        (tab_dzx, tab_dzy) = interpolator.gradient(star_x, star_y)</div>
<div class="line"><span class="lineno">  540</span>        diff_dzx = tab_dzx - dzx</div>
<div class="line"><span class="lineno">  541</span>        diff_dzy = tab_dzy - dzy</div>
<div class="line"><span class="lineno">  542</span>        assert_array_less(diff_z, epsilon*k)</div>
<div class="line"><span class="lineno">  543</span>        assert_array_less(diff_dzx, epsilon*k)</div>
<div class="line"><span class="lineno">  544</span>        assert_array_less(diff_dzy, epsilon*k)</div>
<div class="line"><span class="lineno">  545</span> </div>
<div class="line"><span class="lineno">  546</span>    <span class="comment"># Drawing arbitrary triangle (a, b, c) inside a unit square.</span></div>
<div class="line"><span class="lineno">  547</span>    (ax, ay) = (0.2, 0.3)</div>
<div class="line"><span class="lineno">  548</span>    (bx, by) = (0.33367, 0.80755)</div>
<div class="line"><span class="lineno">  549</span>    (cx, cy) = (0.669, 0.4335)</div>
<div class="line"><span class="lineno">  550</span>    x = np.array([ax, bx, cx, 0., 1., 1., 0.])</div>
<div class="line"><span class="lineno">  551</span>    y = np.array([ay, by, cy, 0., 0., 1., 1.])</div>
<div class="line"><span class="lineno">  552</span>    triangles = np.array([[0, 1, 2], [3, 0, 4], [4, 0, 2], [4, 2, 5],</div>
<div class="line"><span class="lineno">  553</span>                          [1, 5, 2], [6, 5, 1], [6, 1, 0], [6, 0, 3]])</div>
<div class="line"><span class="lineno">  554</span>    triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  555</span> </div>
<div class="line"><span class="lineno">  556</span>    <span class="keywordflow">for</span> idof <span class="keywordflow">in</span> range(9):</div>
<div class="line"><span class="lineno">  557</span>        z = np.zeros(7, dtype=np.float64)</div>
<div class="line"><span class="lineno">  558</span>        dzx = np.zeros(7, dtype=np.float64)</div>
<div class="line"><span class="lineno">  559</span>        dzy = np.zeros(7, dtype=np.float64)</div>
<div class="line"><span class="lineno">  560</span>        values = np.zeros([3, 3], dtype=np.float64)</div>
<div class="line"><span class="lineno">  561</span>        case = idof//3</div>
<div class="line"><span class="lineno">  562</span>        values[case, idof % 3] = 1.0</div>
<div class="line"><span class="lineno">  563</span>        <span class="keywordflow">if</span> case == 0:</div>
<div class="line"><span class="lineno">  564</span>            z[idof] = 1.0</div>
<div class="line"><span class="lineno">  565</span>        <span class="keywordflow">elif</span> case == 1:</div>
<div class="line"><span class="lineno">  566</span>            dzx[idof % 3] = 1.0</div>
<div class="line"><span class="lineno">  567</span>        <span class="keywordflow">elif</span> case == 2:</div>
<div class="line"><span class="lineno">  568</span>            dzy[idof % 3] = 1.0</div>
<div class="line"><span class="lineno">  569</span>        interp = mtri.CubicTriInterpolator(triang, z, kind=<span class="stringliteral">&#39;user&#39;</span>,</div>
<div class="line"><span class="lineno">  570</span>                                           dz=(dzx, dzy))</div>
<div class="line"><span class="lineno">  571</span>        <span class="comment"># Test 1) Checking values and continuity at nodes</span></div>
<div class="line"><span class="lineno">  572</span>        check_continuity(interp, (ax, ay), values[:, 0])</div>
<div class="line"><span class="lineno">  573</span>        check_continuity(interp, (bx, by), values[:, 1])</div>
<div class="line"><span class="lineno">  574</span>        check_continuity(interp, (cx, cy), values[:, 2])</div>
<div class="line"><span class="lineno">  575</span>        <span class="comment"># Test 2) Checking continuity at midside nodes</span></div>
<div class="line"><span class="lineno">  576</span>        check_continuity(interp, ((ax+bx)*0.5, (ay+by)*0.5))</div>
<div class="line"><span class="lineno">  577</span>        check_continuity(interp, ((ax+cx)*0.5, (ay+cy)*0.5))</div>
<div class="line"><span class="lineno">  578</span>        check_continuity(interp, ((cx+bx)*0.5, (cy+by)*0.5))</div>
<div class="line"><span class="lineno">  579</span>        <span class="comment"># Test 3) Checking continuity at barycenter</span></div>
<div class="line"><span class="lineno">  580</span>        check_continuity(interp, ((ax+bx+cx)/3., (ay+by+cy)/3.))</div>
<div class="line"><span class="lineno">  581</span>        <span class="comment"># Test 4) Checking continuity at median 1/3-point</span></div>
<div class="line"><span class="lineno">  582</span>        check_continuity(interp, ((4.*ax+bx+cx)/6., (4.*ay+by+cy)/6.))</div>
<div class="line"><span class="lineno">  583</span>        check_continuity(interp, ((ax+4.*bx+cx)/6., (ay+4.*by+cy)/6.))</div>
<div class="line"><span class="lineno">  584</span>        check_continuity(interp, ((ax+bx+4.*cx)/6., (ay+by+4.*cy)/6.))</div>
<div class="line"><span class="lineno">  585</span> </div>
<div class="line"><span class="lineno">  586</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0fcd8dd832b7bfe3a58979e59299917" name="ac0fcd8dd832b7bfe3a58979e59299917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fcd8dd832b7bfe3a58979e59299917">&#9670;&#160;</a></span>test_triinterpcubic_cg_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triinterpcubic_cg_solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  587</span><span class="keyword">def </span>test_triinterpcubic_cg_solver():</div>
<div class="line"><span class="lineno">  588</span>    <span class="comment"># Now 3 basic tests of the Sparse CG solver, used for</span></div>
<div class="line"><span class="lineno">  589</span>    <span class="comment"># TriCubicInterpolator with *kind* = &#39;min_E&#39;</span></div>
<div class="line"><span class="lineno">  590</span>    <span class="comment"># 1) A commonly used test involves a 2d Poisson matrix.</span></div>
<div class="line"><span class="lineno">  591</span>    <span class="keyword">def </span>poisson_sparse_matrix(n, m):</div>
<div class="line"><span class="lineno">  592</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        Return the sparse, (n*m, n*m) matrix in coo format resulting from the</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        discretisation of the 2-dimensional Poisson equation according to a</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        finite difference numerical scheme on a uniform (n, m) grid.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  597</span>        l = m*n</div>
<div class="line"><span class="lineno">  598</span>        rows = np.concatenate([</div>
<div class="line"><span class="lineno">  599</span>            np.arange(l, dtype=np.int32),</div>
<div class="line"><span class="lineno">  600</span>            np.arange(l-1, dtype=np.int32), np.arange(1, l, dtype=np.int32),</div>
<div class="line"><span class="lineno">  601</span>            np.arange(l-n, dtype=np.int32), np.arange(n, l, dtype=np.int32)])</div>
<div class="line"><span class="lineno">  602</span>        cols = np.concatenate([</div>
<div class="line"><span class="lineno">  603</span>            np.arange(l, dtype=np.int32),</div>
<div class="line"><span class="lineno">  604</span>            np.arange(1, l, dtype=np.int32), np.arange(l-1, dtype=np.int32),</div>
<div class="line"><span class="lineno">  605</span>            np.arange(n, l, dtype=np.int32), np.arange(l-n, dtype=np.int32)])</div>
<div class="line"><span class="lineno">  606</span>        vals = np.concatenate([</div>
<div class="line"><span class="lineno">  607</span>            4*np.ones(l, dtype=np.float64),</div>
<div class="line"><span class="lineno">  608</span>            -np.ones(l-1, dtype=np.float64), -np.ones(l-1, dtype=np.float64),</div>
<div class="line"><span class="lineno">  609</span>            -np.ones(l-n, dtype=np.float64), -np.ones(l-n, dtype=np.float64)])</div>
<div class="line"><span class="lineno">  610</span>        <span class="comment"># In fact +1 and -1 diags have some zeros</span></div>
<div class="line"><span class="lineno">  611</span>        vals[l:2*l-1][m-1::m] = 0.</div>
<div class="line"><span class="lineno">  612</span>        vals[2*l-1:3*l-2][m-1::m] = 0.</div>
<div class="line"><span class="lineno">  613</span>        <span class="keywordflow">return</span> vals, rows, cols, (n*m, n*m)</div>
<div class="line"><span class="lineno">  614</span> </div>
<div class="line"><span class="lineno">  615</span>    <span class="comment"># Instantiating a sparse Poisson matrix of size 48 x 48:</span></div>
<div class="line"><span class="lineno">  616</span>    (n, m) = (12, 4)</div>
<div class="line"><span class="lineno">  617</span>    mat = mtri.triinterpolate._Sparse_Matrix_coo(*poisson_sparse_matrix(n, m))</div>
<div class="line"><span class="lineno">  618</span>    mat.compress_csc()</div>
<div class="line"><span class="lineno">  619</span>    mat_dense = mat.to_dense()</div>
<div class="line"><span class="lineno">  620</span>    <span class="comment"># Testing a sparse solve for all 48 basis vector</span></div>
<div class="line"><span class="lineno">  621</span>    <span class="keywordflow">for</span> itest <span class="keywordflow">in</span> range(n*m):</div>
<div class="line"><span class="lineno">  622</span>        b = np.zeros(n*m, dtype=np.float64)</div>
<div class="line"><span class="lineno">  623</span>        b[itest] = 1.</div>
<div class="line"><span class="lineno">  624</span>        x, _ = mtri.triinterpolate._cg(A=mat, b=b, x0=np.zeros(n*m),</div>
<div class="line"><span class="lineno">  625</span>                                       tol=1.e-10)</div>
<div class="line"><span class="lineno">  626</span>        assert_array_almost_equal(np.dot(mat_dense, x), b)</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>    <span class="comment"># 2) Same matrix with inserting 2 rows - cols with null diag terms</span></div>
<div class="line"><span class="lineno">  629</span>    <span class="comment"># (but still linked with the rest of the matrix by extra-diag terms)</span></div>
<div class="line"><span class="lineno">  630</span>    (i_zero, j_zero) = (12, 49)</div>
<div class="line"><span class="lineno">  631</span>    vals, rows, cols, _ = poisson_sparse_matrix(n, m)</div>
<div class="line"><span class="lineno">  632</span>    rows = rows + 1*(rows &gt;= i_zero) + 1*(rows &gt;= j_zero)</div>
<div class="line"><span class="lineno">  633</span>    cols = cols + 1*(cols &gt;= i_zero) + 1*(cols &gt;= j_zero)</div>
<div class="line"><span class="lineno">  634</span>    <span class="comment"># adding extra-diag terms</span></div>
<div class="line"><span class="lineno">  635</span>    rows = np.concatenate([rows, [i_zero, i_zero-1, j_zero, j_zero-1]])</div>
<div class="line"><span class="lineno">  636</span>    cols = np.concatenate([cols, [i_zero-1, i_zero, j_zero-1, j_zero]])</div>
<div class="line"><span class="lineno">  637</span>    vals = np.concatenate([vals, [1., 1., 1., 1.]])</div>
<div class="line"><span class="lineno">  638</span>    mat = mtri.triinterpolate._Sparse_Matrix_coo(vals, rows, cols,</div>
<div class="line"><span class="lineno">  639</span>                                                 (n*m + 2, n*m + 2))</div>
<div class="line"><span class="lineno">  640</span>    mat.compress_csc()</div>
<div class="line"><span class="lineno">  641</span>    mat_dense = mat.to_dense()</div>
<div class="line"><span class="lineno">  642</span>    <span class="comment"># Testing a sparse solve for all 50 basis vec</span></div>
<div class="line"><span class="lineno">  643</span>    <span class="keywordflow">for</span> itest <span class="keywordflow">in</span> range(n*m + 2):</div>
<div class="line"><span class="lineno">  644</span>        b = np.zeros(n*m + 2, dtype=np.float64)</div>
<div class="line"><span class="lineno">  645</span>        b[itest] = 1.</div>
<div class="line"><span class="lineno">  646</span>        x, _ = mtri.triinterpolate._cg(A=mat, b=b, x0=np.ones(n*m + 2),</div>
<div class="line"><span class="lineno">  647</span>                                       tol=1.e-10)</div>
<div class="line"><span class="lineno">  648</span>        assert_array_almost_equal(np.dot(mat_dense, x), b)</div>
<div class="line"><span class="lineno">  649</span> </div>
<div class="line"><span class="lineno">  650</span>    <span class="comment"># 3) Now a simple test that summation of duplicate (i.e. with same rows,</span></div>
<div class="line"><span class="lineno">  651</span>    <span class="comment"># same cols) entries occurs when compressed.</span></div>
<div class="line"><span class="lineno">  652</span>    vals = np.ones(17, dtype=np.float64)</div>
<div class="line"><span class="lineno">  653</span>    rows = np.array([0, 1, 2, 0, 0, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1],</div>
<div class="line"><span class="lineno">  654</span>                    dtype=np.int32)</div>
<div class="line"><span class="lineno">  655</span>    cols = np.array([0, 1, 2, 1, 1, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],</div>
<div class="line"><span class="lineno">  656</span>                    dtype=np.int32)</div>
<div class="line"><span class="lineno">  657</span>    dim = (3, 3)</div>
<div class="line"><span class="lineno">  658</span>    mat = mtri.triinterpolate._Sparse_Matrix_coo(vals, rows, cols, dim)</div>
<div class="line"><span class="lineno">  659</span>    mat.compress_csc()</div>
<div class="line"><span class="lineno">  660</span>    mat_dense = mat.to_dense()</div>
<div class="line"><span class="lineno">  661</span>    assert_array_almost_equal(mat_dense, np.array([</div>
<div class="line"><span class="lineno">  662</span>        [1., 2., 0.], [2., 1., 5.], [0., 5., 1.]], dtype=np.float64))</div>
<div class="line"><span class="lineno">  663</span> </div>
<div class="line"><span class="lineno">  664</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aab888fafa0e1b64137fb1af963b9a4bb" name="aab888fafa0e1b64137fb1af963b9a4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab888fafa0e1b64137fb1af963b9a4bb">&#9670;&#160;</a></span>test_triinterpcubic_geom_weights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triinterpcubic_geom_weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  665</span><span class="keyword">def </span>test_triinterpcubic_geom_weights():</div>
<div class="line"><span class="lineno">  666</span>    <span class="comment"># Tests to check computation of weights for _DOF_estimator_geom:</span></div>
<div class="line"><span class="lineno">  667</span>    <span class="comment"># The weight sum per triangle can be 1. (in case all angles &lt; 90 degrees)</span></div>
<div class="line"><span class="lineno">  668</span>    <span class="comment"># or (2*w_i) where w_i = 1-alpha_i/np.pi is the weight of apex i; alpha_i</span></div>
<div class="line"><span class="lineno">  669</span>    <span class="comment"># is the apex angle &gt; 90 degrees.</span></div>
<div class="line"><span class="lineno">  670</span>    (ax, ay) = (0., 1.687)</div>
<div class="line"><span class="lineno">  671</span>    x = np.array([ax, 0.5*ax, 0., 1.])</div>
<div class="line"><span class="lineno">  672</span>    y = np.array([ay, -ay, 0., 0.])</div>
<div class="line"><span class="lineno">  673</span>    z = np.zeros(4, dtype=np.float64)</div>
<div class="line"><span class="lineno">  674</span>    triangles = [[0, 2, 3], [1, 3, 2]]</div>
<div class="line"><span class="lineno">  675</span>    sum_w = np.zeros([4, 2])  <span class="comment"># 4 possibilities; 2 triangles</span></div>
<div class="line"><span class="lineno">  676</span>    <span class="keywordflow">for</span> theta <span class="keywordflow">in</span> np.linspace(0., 2*np.pi, 14):  <span class="comment"># rotating the figure...</span></div>
<div class="line"><span class="lineno">  677</span>        x_rot = np.cos(theta)*x + np.sin(theta)*y</div>
<div class="line"><span class="lineno">  678</span>        y_rot = -np.sin(theta)*x + np.cos(theta)*y</div>
<div class="line"><span class="lineno">  679</span>        triang = mtri.Triangulation(x_rot, y_rot, triangles)</div>
<div class="line"><span class="lineno">  680</span>        cubic_geom = mtri.CubicTriInterpolator(triang, z, kind=<span class="stringliteral">&#39;geom&#39;</span>)</div>
<div class="line"><span class="lineno">  681</span>        dof_estimator = mtri.triinterpolate._DOF_estimator_geom(cubic_geom)</div>
<div class="line"><span class="lineno">  682</span>        weights = dof_estimator.compute_geom_weights()</div>
<div class="line"><span class="lineno">  683</span>        <span class="comment"># Testing for the 4 possibilities...</span></div>
<div class="line"><span class="lineno">  684</span>        sum_w[0, :] = np.sum(weights, 1) - 1</div>
<div class="line"><span class="lineno">  685</span>        <span class="keywordflow">for</span> itri <span class="keywordflow">in</span> range(3):</div>
<div class="line"><span class="lineno">  686</span>            sum_w[itri+1, :] = np.sum(weights, 1) - 2*weights[:, itri]</div>
<div class="line"><span class="lineno">  687</span>        assert_array_almost_equal(np.min(np.abs(sum_w), axis=0),</div>
<div class="line"><span class="lineno">  688</span>                                  np.array([0., 0.], dtype=np.float64))</div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afb85521cf5ed26cf608cd7603a051cd6" name="afb85521cf5ed26cf608cd7603a051cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb85521cf5ed26cf608cd7603a051cd6">&#9670;&#160;</a></span>test_tripcolor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tripcolor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  213</span><span class="keyword">def </span>test_tripcolor():</div>
<div class="line"><span class="lineno">  214</span>    x = np.asarray([0, 0.5, 1, 0,   0.5, 1,   0, 0.5, 1, 0.75])</div>
<div class="line"><span class="lineno">  215</span>    y = np.asarray([0, 0,   0, 0.5, 0.5, 0.5, 1, 1,   1, 0.75])</div>
<div class="line"><span class="lineno">  216</span>    triangles = np.asarray([</div>
<div class="line"><span class="lineno">  217</span>        [0, 1, 3], [1, 4, 3],</div>
<div class="line"><span class="lineno">  218</span>        [1, 2, 4], [2, 5, 4],</div>
<div class="line"><span class="lineno">  219</span>        [3, 4, 6], [4, 7, 6],</div>
<div class="line"><span class="lineno">  220</span>        [4, 5, 9], [7, 4, 9], [8, 7, 9], [5, 8, 9]])</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span>    <span class="comment"># Triangulation with same number of points and triangles.</span></div>
<div class="line"><span class="lineno">  223</span>    triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  224</span> </div>
<div class="line"><span class="lineno">  225</span>    Cpoints = x + 0.5*y</div>
<div class="line"><span class="lineno">  226</span> </div>
<div class="line"><span class="lineno">  227</span>    xmid = x[triang.triangles].mean(axis=1)</div>
<div class="line"><span class="lineno">  228</span>    ymid = y[triang.triangles].mean(axis=1)</div>
<div class="line"><span class="lineno">  229</span>    Cfaces = 0.5*xmid + ymid</div>
<div class="line"><span class="lineno">  230</span> </div>
<div class="line"><span class="lineno">  231</span>    plt.subplot(121)</div>
<div class="line"><span class="lineno">  232</span>    plt.tripcolor(triang, Cpoints, edgecolors=<span class="stringliteral">&#39;k&#39;</span>)</div>
<div class="line"><span class="lineno">  233</span>    plt.title(<span class="stringliteral">&#39;point colors&#39;</span>)</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span>    plt.subplot(122)</div>
<div class="line"><span class="lineno">  236</span>    plt.tripcolor(triang, facecolors=Cfaces, edgecolors=<span class="stringliteral">&#39;k&#39;</span>)</div>
<div class="line"><span class="lineno">  237</span>    plt.title(<span class="stringliteral">&#39;facecolors&#39;</span>)</div>
<div class="line"><span class="lineno">  238</span> </div>
<div class="line"><span class="lineno">  239</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a25ae23318b1c5d563aecbcc7e2188465" name="a25ae23318b1c5d563aecbcc7e2188465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ae23318b1c5d563aecbcc7e2188465">&#9670;&#160;</a></span>test_tripcolor_clim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tripcolor_clim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  268</span><span class="keyword">def </span>test_tripcolor_clim():</div>
<div class="line"><span class="lineno">  269</span>    np.random.seed(19680801)</div>
<div class="line"><span class="lineno">  270</span>    a, b, c = np.random.rand(10), np.random.rand(10), np.random.rand(10)</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span>    ax = plt.figure().add_subplot()</div>
<div class="line"><span class="lineno">  273</span>    clim = (0.25, 0.75)</div>
<div class="line"><span class="lineno">  274</span>    norm = ax.tripcolor(a, b, c, clim=clim).norm</div>
<div class="line"><span class="lineno">  275</span>    <span class="keyword">assert</span> (norm.vmin, norm.vmax) == clim</div>
<div class="line"><span class="lineno">  276</span> </div>
<div class="line"><span class="lineno">  277</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="add25a12f8a6a950052746020a2f1100b" name="add25a12f8a6a950052746020a2f1100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add25a12f8a6a950052746020a2f1100b">&#9670;&#160;</a></span>test_tripcolor_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tripcolor_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  240</span><span class="keyword">def </span>test_tripcolor_color():</div>
<div class="line"><span class="lineno">  241</span>    x = [-1, 0, 1, 0]</div>
<div class="line"><span class="lineno">  242</span>    y = [0, -1, 0, 1]</div>
<div class="line"><span class="lineno">  243</span>    fig, ax = plt.subplots()</div>
<div class="line"><span class="lineno">  244</span>    <span class="keyword">with</span> pytest.raises(TypeError, match=<span class="stringliteral">r&quot;tripcolor\&zwj;(\&zwj;) missing 1 required &quot;</span>):</div>
<div class="line"><span class="lineno">  245</span>        ax.tripcolor(x, y)</div>
<div class="line"><span class="lineno">  246</span>    <span class="keyword">with</span> pytest.raises(ValueError, match=<span class="stringliteral">&quot;The length of c must match either&quot;</span>):</div>
<div class="line"><span class="lineno">  247</span>        ax.tripcolor(x, y, [1, 2, 3])</div>
<div class="line"><span class="lineno">  248</span>    <span class="keyword">with</span> pytest.raises(ValueError,</div>
<div class="line"><span class="lineno">  249</span>                       match=<span class="stringliteral">&quot;length of facecolors must match .* triangles&quot;</span>):</div>
<div class="line"><span class="lineno">  250</span>        ax.tripcolor(x, y, facecolors=[1, 2, 3, 4])</div>
<div class="line"><span class="lineno">  251</span>    <span class="keyword">with</span> pytest.raises(ValueError,</div>
<div class="line"><span class="lineno">  252</span>                       match=<span class="stringliteral">&quot;&#39;gouraud&#39; .* at the points.* not at the faces&quot;</span>):</div>
<div class="line"><span class="lineno">  253</span>        ax.tripcolor(x, y, facecolors=[1, 2], shading=<span class="stringliteral">&#39;gouraud&#39;</span>)</div>
<div class="line"><span class="lineno">  254</span>    <span class="keyword">with</span> pytest.raises(ValueError,</div>
<div class="line"><span class="lineno">  255</span>                       match=<span class="stringliteral">&quot;&#39;gouraud&#39; .* at the points.* not at the faces&quot;</span>):</div>
<div class="line"><span class="lineno">  256</span>        ax.tripcolor(x, y, [1, 2], shading=<span class="stringliteral">&#39;gouraud&#39;</span>)  <span class="comment"># faces</span></div>
<div class="line"><span class="lineno">  257</span>    <span class="keyword">with</span> pytest.raises(TypeError,</div>
<div class="line"><span class="lineno">  258</span>                       match=<span class="stringliteral">&quot;positional.*&#39;c&#39;.*keyword-only.*&#39;facecolors&#39;&quot;</span>):</div>
<div class="line"><span class="lineno">  259</span>        ax.tripcolor(x, y, C=[1, 2, 3, 4])</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span>    <span class="comment"># smoke test for valid color specifications (via C or facecolors)</span></div>
<div class="line"><span class="lineno">  262</span>    ax.tripcolor(x, y, [1, 2, 3, 4])  <span class="comment"># edges</span></div>
<div class="line"><span class="lineno">  263</span>    ax.tripcolor(x, y, [1, 2, 3, 4], shading=<span class="stringliteral">&#39;gouraud&#39;</span>)  <span class="comment"># edges</span></div>
<div class="line"><span class="lineno">  264</span>    ax.tripcolor(x, y, [1, 2])  <span class="comment"># faces</span></div>
<div class="line"><span class="lineno">  265</span>    ax.tripcolor(x, y, facecolors=[1, 2])  <span class="comment"># faces</span></div>
<div class="line"><span class="lineno">  266</span> </div>
<div class="line"><span class="lineno">  267</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a642d1ae576401c63e3daca1057023bca" name="a642d1ae576401c63e3daca1057023bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642d1ae576401c63e3daca1057023bca">&#9670;&#160;</a></span>test_tripcolor_warnings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tripcolor_warnings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  278</span><span class="keyword">def </span>test_tripcolor_warnings():</div>
<div class="line"><span class="lineno">  279</span>    x = [-1, 0, 1, 0]</div>
<div class="line"><span class="lineno">  280</span>    y = [0, -1, 0, 1]</div>
<div class="line"><span class="lineno">  281</span>    c = [0.4, 0.5]</div>
<div class="line"><span class="lineno">  282</span>    fig, ax = plt.subplots()</div>
<div class="line"><span class="lineno">  283</span>    <span class="comment"># additional parameters</span></div>
<div class="line"><span class="lineno">  284</span>    <span class="keyword">with</span> pytest.warns(DeprecationWarning, match=<span class="stringliteral">&quot;Additional positional param&quot;</span>):</div>
<div class="line"><span class="lineno">  285</span>        ax.tripcolor(x, y, c, <span class="stringliteral">&#39;unused_positional&#39;</span>)</div>
<div class="line"><span class="lineno">  286</span>    <span class="comment"># facecolors takes precedence over c</span></div>
<div class="line"><span class="lineno">  287</span>    <span class="keyword">with</span> pytest.warns(UserWarning, match=<span class="stringliteral">&quot;Positional parameter c .*no effect&quot;</span>):</div>
<div class="line"><span class="lineno">  288</span>        ax.tripcolor(x, y, c, facecolors=c)</div>
<div class="line"><span class="lineno">  289</span>    <span class="keyword">with</span> pytest.warns(UserWarning, match=<span class="stringliteral">&quot;Positional parameter c .*no effect&quot;</span>):</div>
<div class="line"><span class="lineno">  290</span>        ax.tripcolor(x, y, <span class="stringliteral">&#39;interpreted as c&#39;</span>, facecolors=c)</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a04273048a7549b71952ba8e019085b35" name="a04273048a7549b71952ba8e019085b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04273048a7549b71952ba8e019085b35">&#9670;&#160;</a></span>test_triplot_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triplot_label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1304</span><span class="keyword">def </span>test_triplot_label():</div>
<div class="line"><span class="lineno"> 1305</span>    x = [0, 2, 1]</div>
<div class="line"><span class="lineno"> 1306</span>    y = [0, 0, 1]</div>
<div class="line"><span class="lineno"> 1307</span>    data = [[0, 1, 2]]</div>
<div class="line"><span class="lineno"> 1308</span>    fig, ax = plt.subplots()</div>
<div class="line"><span class="lineno"> 1309</span>    lines, markers = ax.triplot(x, y, data, label=<span class="stringliteral">&#39;label&#39;</span>)</div>
<div class="line"><span class="lineno"> 1310</span>    handles, labels = ax.get_legend_handles_labels()</div>
<div class="line"><span class="lineno"> 1311</span>    <span class="keyword">assert</span> labels == [<span class="stringliteral">&#39;label&#39;</span>]</div>
<div class="line"><span class="lineno"> 1312</span>    <span class="keyword">assert</span> len(handles) == 1</div>
<div class="line"><span class="lineno"> 1313</span>    <span class="keyword">assert</span> handles[0] <span class="keywordflow">is</span> lines</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06a86006903bf5fb9d226cdf48c65636" name="a06a86006903bf5fb9d226cdf48c65636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a86006903bf5fb9d226cdf48c65636">&#9670;&#160;</a></span>test_triplot_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triplot_return </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1084</span><span class="keyword">def </span>test_triplot_return():</div>
<div class="line"><span class="lineno"> 1085</span>    <span class="comment"># Check that triplot returns the artists it adds</span></div>
<div class="line"><span class="lineno"> 1086</span>    ax = plt.figure().add_subplot()</div>
<div class="line"><span class="lineno"> 1087</span>    triang = mtri.Triangulation(</div>
<div class="line"><span class="lineno"> 1088</span>        [0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 1.0, 1.0],</div>
<div class="line"><span class="lineno"> 1089</span>        triangles=[[0, 1, 3], [3, 2, 0]])</div>
<div class="line"><span class="lineno"> 1090</span>    <span class="keyword">assert</span> ax.triplot(triang, <span class="stringliteral">&quot;b-&quot;</span>) <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>, \</div>
<div class="line"><span class="lineno"> 1091</span>        <span class="stringliteral">&#39;triplot should return the artist it adds&#39;</span></div>
<div class="line"><span class="lineno"> 1092</span> </div>
<div class="line"><span class="lineno"> 1093</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c758b230a6355dea4a68f479a045e13" name="a8c758b230a6355dea4a68f479a045e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c758b230a6355dea4a68f479a045e13">&#9670;&#160;</a></span>test_triplot_with_ls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_triplot_with_ls </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fig_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fig_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1296</span><span class="keyword">def </span>test_triplot_with_ls(fig_test, fig_ref):</div>
<div class="line"><span class="lineno"> 1297</span>    x = [0, 2, 1]</div>
<div class="line"><span class="lineno"> 1298</span>    y = [0, 0, 1]</div>
<div class="line"><span class="lineno"> 1299</span>    data = [[0, 1, 2]]</div>
<div class="line"><span class="lineno"> 1300</span>    fig_test.subplots().triplot(x, y, data, ls=<span class="stringliteral">&#39;--&#39;</span>)</div>
<div class="line"><span class="lineno"> 1301</span>    fig_ref.subplots().triplot(x, y, data, linestyle=<span class="stringliteral">&#39;--&#39;</span>)</div>
<div class="line"><span class="lineno"> 1302</span> </div>
<div class="line"><span class="lineno"> 1303</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a48c96f077577733dd9f3bf3d8c72e39f" name="a48c96f077577733dd9f3bf3d8c72e39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c96f077577733dd9f3bf3d8c72e39f">&#9670;&#160;</a></span>test_trirefine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_trirefine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  995</span><span class="keyword">def </span>test_trirefine():</div>
<div class="line"><span class="lineno">  996</span>    <span class="comment"># Testing subdiv=2 refinement</span></div>
<div class="line"><span class="lineno">  997</span>    n = 3</div>
<div class="line"><span class="lineno">  998</span>    subdiv = 2</div>
<div class="line"><span class="lineno">  999</span>    x = np.linspace(-1., 1., n+1)</div>
<div class="line"><span class="lineno"> 1000</span>    x, y = np.meshgrid(x, x)</div>
<div class="line"><span class="lineno"> 1001</span>    x = x.ravel()</div>
<div class="line"><span class="lineno"> 1002</span>    y = y.ravel()</div>
<div class="line"><span class="lineno"> 1003</span>    mask = np.zeros(2*n**2, dtype=bool)</div>
<div class="line"><span class="lineno"> 1004</span>    mask[n**2:] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1005</span>    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n+1),</div>
<div class="line"><span class="lineno"> 1006</span>                                mask=mask)</div>
<div class="line"><span class="lineno"> 1007</span>    refiner = mtri.UniformTriRefiner(triang)</div>
<div class="line"><span class="lineno"> 1008</span>    refi_triang = refiner.refine_triangulation(subdiv=subdiv)</div>
<div class="line"><span class="lineno"> 1009</span>    x_refi = refi_triang.x</div>
<div class="line"><span class="lineno"> 1010</span>    y_refi = refi_triang.y</div>
<div class="line"><span class="lineno"> 1011</span> </div>
<div class="line"><span class="lineno"> 1012</span>    n_refi = n * subdiv**2</div>
<div class="line"><span class="lineno"> 1013</span>    x_verif = np.linspace(-1., 1., n_refi+1)</div>
<div class="line"><span class="lineno"> 1014</span>    x_verif, y_verif = np.meshgrid(x_verif, x_verif)</div>
<div class="line"><span class="lineno"> 1015</span>    x_verif = x_verif.ravel()</div>
<div class="line"><span class="lineno"> 1016</span>    y_verif = y_verif.ravel()</div>
<div class="line"><span class="lineno"> 1017</span>    ind1d = np.in1d(np.around(x_verif*(2.5+y_verif), 8),</div>
<div class="line"><span class="lineno"> 1018</span>                    np.around(x_refi*(2.5+y_refi), 8))</div>
<div class="line"><span class="lineno"> 1019</span>    assert_array_equal(ind1d, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1020</span> </div>
<div class="line"><span class="lineno"> 1021</span>    <span class="comment"># Testing the mask of the refined triangulation</span></div>
<div class="line"><span class="lineno"> 1022</span>    refi_mask = refi_triang.mask</div>
<div class="line"><span class="lineno"> 1023</span>    refi_tri_barycenter_x = np.sum(refi_triang.x[refi_triang.triangles],</div>
<div class="line"><span class="lineno"> 1024</span>                                   axis=1) / 3.</div>
<div class="line"><span class="lineno"> 1025</span>    refi_tri_barycenter_y = np.sum(refi_triang.y[refi_triang.triangles],</div>
<div class="line"><span class="lineno"> 1026</span>                                   axis=1) / 3.</div>
<div class="line"><span class="lineno"> 1027</span>    tri_finder = triang.get_trifinder()</div>
<div class="line"><span class="lineno"> 1028</span>    refi_tri_indices = tri_finder(refi_tri_barycenter_x,</div>
<div class="line"><span class="lineno"> 1029</span>                                  refi_tri_barycenter_y)</div>
<div class="line"><span class="lineno"> 1030</span>    refi_tri_mask = triang.mask[refi_tri_indices]</div>
<div class="line"><span class="lineno"> 1031</span>    assert_array_equal(refi_mask, refi_tri_mask)</div>
<div class="line"><span class="lineno"> 1032</span> </div>
<div class="line"><span class="lineno"> 1033</span>    <span class="comment"># Testing that the numbering of triangles does not change the</span></div>
<div class="line"><span class="lineno"> 1034</span>    <span class="comment"># interpolation result.</span></div>
<div class="line"><span class="lineno"> 1035</span>    x = np.asarray([0.0, 1.0, 0.0, 1.0])</div>
<div class="line"><span class="lineno"> 1036</span>    y = np.asarray([0.0, 0.0, 1.0, 1.0])</div>
<div class="line"><span class="lineno"> 1037</span>    triang = [mtri.Triangulation(x, y, [[0, 1, 3], [3, 2, 0]]),</div>
<div class="line"><span class="lineno"> 1038</span>              mtri.Triangulation(x, y, [[0, 1, 3], [2, 0, 3]])]</div>
<div class="line"><span class="lineno"> 1039</span>    z = np.hypot(x - 0.3, y - 0.4)</div>
<div class="line"><span class="lineno"> 1040</span>    <span class="comment"># Refining the 2 triangulations and reordering the points</span></div>
<div class="line"><span class="lineno"> 1041</span>    xyz_data = []</div>
<div class="line"><span class="lineno"> 1042</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(2):</div>
<div class="line"><span class="lineno"> 1043</span>        refiner = mtri.UniformTriRefiner(triang[i])</div>
<div class="line"><span class="lineno"> 1044</span>        refined_triang, refined_z = refiner.refine_field(z, subdiv=1)</div>
<div class="line"><span class="lineno"> 1045</span>        xyz = np.dstack((refined_triang.x, refined_triang.y, refined_z))[0]</div>
<div class="line"><span class="lineno"> 1046</span>        xyz = xyz[np.lexsort((xyz[:, 1], xyz[:, 0]))]</div>
<div class="line"><span class="lineno"> 1047</span>        xyz_data += [xyz]</div>
<div class="line"><span class="lineno"> 1048</span>    assert_array_almost_equal(xyz_data[0], xyz_data[1])</div>
<div class="line"><span class="lineno"> 1049</span> </div>
<div class="line"><span class="lineno"> 1050</span> </div>
<div class="line"><span class="lineno"> 1051</span><span class="preprocessor">@pytest.mark.parametrize</span>(<span class="stringliteral">&#39;interpolator&#39;</span>,</div>
<div class="line"><span class="lineno"> 1052</span>                         [mtri.LinearTriInterpolator,</div>
<div class="line"><span class="lineno"> 1053</span>                          mtri.CubicTriInterpolator],</div>
<div class="line"><span class="lineno"> 1054</span>                         ids=[<span class="stringliteral">&#39;linear&#39;</span>, <span class="stringliteral">&#39;cubic&#39;</span>])</div>
</div><!-- fragment -->
</div>
</div>
<a id="add7cad6831d1583f7b06f96f13cc235c" name="add7cad6831d1583f7b06f96f13cc235c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7cad6831d1583f7b06f96f13cc235c">&#9670;&#160;</a></span>test_trirefine_masked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_trirefine_masked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1055</span><span class="keyword">def </span>test_trirefine_masked(interpolator):</div>
<div class="line"><span class="lineno"> 1056</span>    <span class="comment"># Repeated points means we will have fewer triangles than points, and thus</span></div>
<div class="line"><span class="lineno"> 1057</span>    <span class="comment"># get masking.</span></div>
<div class="line"><span class="lineno"> 1058</span>    x, y = np.mgrid[:2, :2]</div>
<div class="line"><span class="lineno"> 1059</span>    x = np.repeat(x.flatten(), 2)</div>
<div class="line"><span class="lineno"> 1060</span>    y = np.repeat(y.flatten(), 2)</div>
<div class="line"><span class="lineno"> 1061</span> </div>
<div class="line"><span class="lineno"> 1062</span>    z = np.zeros_like(x)</div>
<div class="line"><span class="lineno"> 1063</span>    tri = mtri.Triangulation(x, y)</div>
<div class="line"><span class="lineno"> 1064</span>    refiner = mtri.UniformTriRefiner(tri)</div>
<div class="line"><span class="lineno"> 1065</span>    interp = interpolator(tri, z)</div>
<div class="line"><span class="lineno"> 1066</span>    refiner.refine_field(z, triinterpolator=interp, subdiv=2)</div>
<div class="line"><span class="lineno"> 1067</span> </div>
<div class="line"><span class="lineno"> 1068</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a07ce0a0d47d0a93d2c538eb3c2cbd052" name="a07ce0a0d47d0a93d2c538eb3c2cbd052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce0a0d47d0a93d2c538eb3c2cbd052">&#9670;&#160;</a></span>test_trirefiner_fortran_contiguous_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_trirefiner_fortran_contiguous_triangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1094</span><span class="keyword">def </span>test_trirefiner_fortran_contiguous_triangles():</div>
<div class="line"><span class="lineno"> 1095</span>    <span class="comment"># github issue 4180.  Test requires two arrays of triangles that are</span></div>
<div class="line"><span class="lineno"> 1096</span>    <span class="comment"># identical except that one is C-contiguous and one is fortran-contiguous.</span></div>
<div class="line"><span class="lineno"> 1097</span>    triangles1 = np.array([[2, 0, 3], [2, 1, 0]])</div>
<div class="line"><span class="lineno"> 1098</span>    <span class="keyword">assert</span> <span class="keywordflow">not</span> np.isfortran(triangles1)</div>
<div class="line"><span class="lineno"> 1099</span> </div>
<div class="line"><span class="lineno"> 1100</span>    triangles2 = np.array(triangles1, copy=<span class="keyword">True</span>, order=<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno"> 1101</span>    <span class="keyword">assert</span> np.isfortran(triangles2)</div>
<div class="line"><span class="lineno"> 1102</span> </div>
<div class="line"><span class="lineno"> 1103</span>    x = np.array([0.39, 0.59, 0.43, 0.32])</div>
<div class="line"><span class="lineno"> 1104</span>    y = np.array([33.99, 34.01, 34.19, 34.18])</div>
<div class="line"><span class="lineno"> 1105</span>    triang1 = mtri.Triangulation(x, y, triangles1)</div>
<div class="line"><span class="lineno"> 1106</span>    triang2 = mtri.Triangulation(x, y, triangles2)</div>
<div class="line"><span class="lineno"> 1107</span> </div>
<div class="line"><span class="lineno"> 1108</span>    refiner1 = mtri.UniformTriRefiner(triang1)</div>
<div class="line"><span class="lineno"> 1109</span>    refiner2 = mtri.UniformTriRefiner(triang2)</div>
<div class="line"><span class="lineno"> 1110</span> </div>
<div class="line"><span class="lineno"> 1111</span>    fine_triang1 = refiner1.refine_triangulation(subdiv=1)</div>
<div class="line"><span class="lineno"> 1112</span>    fine_triang2 = refiner2.refine_triangulation(subdiv=1)</div>
<div class="line"><span class="lineno"> 1113</span> </div>
<div class="line"><span class="lineno"> 1114</span>    assert_array_equal(fine_triang1.triangles, fine_triang2.triangles)</div>
<div class="line"><span class="lineno"> 1115</span> </div>
<div class="line"><span class="lineno"> 1116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af7a157b25cc8564a282b5dac07e6fdad" name="af7a157b25cc8564a282b5dac07e6fdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a157b25cc8564a282b5dac07e6fdad">&#9670;&#160;</a></span>test_tritools()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.tests.test_triangulation.test_tritools </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  938</span><span class="keyword">def </span>test_tritools():</div>
<div class="line"><span class="lineno">  939</span>    <span class="comment"># Tests TriAnalyzer.scale_factors on masked triangulation</span></div>
<div class="line"><span class="lineno">  940</span>    <span class="comment"># Tests circle_ratios on equilateral and right-angled triangle.</span></div>
<div class="line"><span class="lineno">  941</span>    x = np.array([0., 1., 0.5, 0., 2.])</div>
<div class="line"><span class="lineno">  942</span>    y = np.array([0., 0., 0.5*np.sqrt(3.), -1., 1.])</div>
<div class="line"><span class="lineno">  943</span>    triangles = np.array([[0, 1, 2], [0, 1, 3], [1, 2, 4]], dtype=np.int32)</div>
<div class="line"><span class="lineno">  944</span>    mask = np.array([<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>], dtype=bool)</div>
<div class="line"><span class="lineno">  945</span>    triang = mtri.Triangulation(x, y, triangles, mask=mask)</div>
<div class="line"><span class="lineno">  946</span>    analyser = mtri.TriAnalyzer(triang)</div>
<div class="line"><span class="lineno">  947</span>    assert_array_almost_equal(analyser.scale_factors,</div>
<div class="line"><span class="lineno">  948</span>                              np.array([1., 1./(1.+0.5*np.sqrt(3.))]))</div>
<div class="line"><span class="lineno">  949</span>    assert_array_almost_equal(</div>
<div class="line"><span class="lineno">  950</span>        analyser.circle_ratios(rescale=<span class="keyword">False</span>),</div>
<div class="line"><span class="lineno">  951</span>        np.ma.masked_array([0.5, 1./(1.+np.sqrt(2.)), np.nan], mask))</div>
<div class="line"><span class="lineno">  952</span> </div>
<div class="line"><span class="lineno">  953</span>    <span class="comment"># Tests circle ratio of a flat triangle</span></div>
<div class="line"><span class="lineno">  954</span>    x = np.array([0., 1., 2.])</div>
<div class="line"><span class="lineno">  955</span>    y = np.array([1., 1.+3., 1.+6.])</div>
<div class="line"><span class="lineno">  956</span>    triangles = np.array([[0, 1, 2]], dtype=np.int32)</div>
<div class="line"><span class="lineno">  957</span>    triang = mtri.Triangulation(x, y, triangles)</div>
<div class="line"><span class="lineno">  958</span>    analyser = mtri.TriAnalyzer(triang)</div>
<div class="line"><span class="lineno">  959</span>    assert_array_almost_equal(analyser.circle_ratios(), np.array([0.]))</div>
<div class="line"><span class="lineno">  960</span> </div>
<div class="line"><span class="lineno">  961</span>    <span class="comment"># Tests TriAnalyzer.get_flat_tri_mask</span></div>
<div class="line"><span class="lineno">  962</span>    <span class="comment"># Creates a triangulation of [-1, 1] x [-1, 1] with contiguous groups of</span></div>
<div class="line"><span class="lineno">  963</span>    <span class="comment"># &#39;flat&#39; triangles at the 4 corners and at the center. Checks that only</span></div>
<div class="line"><span class="lineno">  964</span>    <span class="comment"># those at the borders are eliminated by TriAnalyzer.get_flat_tri_mask</span></div>
<div class="line"><span class="lineno">  965</span>    n = 9</div>
<div class="line"><span class="lineno">  966</span> </div>
<div class="line"><span class="lineno">  967</span>    <span class="keyword">def </span>power(x, a):</div>
<div class="line"><span class="lineno">  968</span>        <span class="keywordflow">return</span> np.abs(x)**a*np.sign(x)</div>
<div class="line"><span class="lineno">  969</span> </div>
<div class="line"><span class="lineno">  970</span>    x = np.linspace(-1., 1., n+1)</div>
<div class="line"><span class="lineno">  971</span>    x, y = np.meshgrid(power(x, 2.), power(x, 0.25))</div>
<div class="line"><span class="lineno">  972</span>    x = x.ravel()</div>
<div class="line"><span class="lineno">  973</span>    y = y.ravel()</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n+1))</div>
<div class="line"><span class="lineno">  976</span>    analyser = mtri.TriAnalyzer(triang)</div>
<div class="line"><span class="lineno">  977</span>    mask_flat = analyser.get_flat_tri_mask(0.2)</div>
<div class="line"><span class="lineno">  978</span>    verif_mask = np.zeros(162, dtype=bool)</div>
<div class="line"><span class="lineno">  979</span>    corners_index = [0, 1, 2, 3, 14, 15, 16, 17, 18, 19, 34, 35, 126, 127,</div>
<div class="line"><span class="lineno">  980</span>                     142, 143, 144, 145, 146, 147, 158, 159, 160, 161]</div>
<div class="line"><span class="lineno">  981</span>    verif_mask[corners_index] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  982</span>    assert_array_equal(mask_flat, verif_mask)</div>
<div class="line"><span class="lineno">  983</span> </div>
<div class="line"><span class="lineno">  984</span>    <span class="comment"># Now including a hole (masked triangle) at the center. The center also</span></div>
<div class="line"><span class="lineno">  985</span>    <span class="comment"># shall be eliminated by get_flat_tri_mask.</span></div>
<div class="line"><span class="lineno">  986</span>    mask = np.zeros(162, dtype=bool)</div>
<div class="line"><span class="lineno">  987</span>    mask[80] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  988</span>    triang.set_mask(mask)</div>
<div class="line"><span class="lineno">  989</span>    mask_flat = analyser.get_flat_tri_mask(0.2)</div>
<div class="line"><span class="lineno">  990</span>    center_index = [44, 45, 62, 63, 78, 79, 80, 81, 82, 83, 98, 99, 116, 117]</div>
<div class="line"><span class="lineno">  991</span>    verif_mask[center_index] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  992</span>    assert_array_equal(mask_flat, verif_mask)</div>
<div class="line"><span class="lineno">  993</span> </div>
<div class="line"><span class="lineno">  994</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
