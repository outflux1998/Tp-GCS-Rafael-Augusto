<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.signal._spectral_py Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal.html">signal</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html">_spectral_py</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.signal._spectral_py Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04de21aa2a099fd07b3a8079f68af846" id="r_a04de21aa2a099fd07b3a8079f68af846"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a04de21aa2a099fd07b3a8079f68af846">lombscargle</a> (x, y, freqs, precenter=False, normalize=False)</td></tr>
<tr class="separator:a04de21aa2a099fd07b3a8079f68af846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef921c6ed4361b59839b02dad2f958e" id="r_a1ef921c6ed4361b59839b02dad2f958e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a1ef921c6ed4361b59839b02dad2f958e">periodogram</a> (x, fs=1.0, window='boxcar', nfft=None, <a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=True, scaling='density', axis=-1)</td></tr>
<tr class="separator:a1ef921c6ed4361b59839b02dad2f958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad045f3f43aa8846446af595a5b66bfd7" id="r_ad045f3f43aa8846446af595a5b66bfd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#ad045f3f43aa8846446af595a5b66bfd7">welch</a> (x, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=True, scaling='density', axis=-1, average='mean')</td></tr>
<tr class="separator:ad045f3f43aa8846446af595a5b66bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b32e812473c8c8b467b5539edf825b" id="r_ab0b32e812473c8c8b467b5539edf825b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#ab0b32e812473c8c8b467b5539edf825b">csd</a> (x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=True, scaling='density', axis=-1, average='mean')</td></tr>
<tr class="separator:ab0b32e812473c8c8b467b5539edf825b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aca9fb32af690767509d2a98b0d211f" id="r_a4aca9fb32af690767509d2a98b0d211f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a4aca9fb32af690767509d2a98b0d211f">spectrogram</a> (x, fs=1.0, window=('tukey',.25), nperseg=None, noverlap=None, nfft=None, <a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=True, scaling='density', axis=-1, mode='psd')</td></tr>
<tr class="separator:a4aca9fb32af690767509d2a98b0d211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f9eee97f27719960a111d57f4ddb9a" id="r_a31f9eee97f27719960a111d57f4ddb9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a31f9eee97f27719960a111d57f4ddb9a">check_COLA</a> (window, nperseg, noverlap, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-10)</td></tr>
<tr class="separator:a31f9eee97f27719960a111d57f4ddb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c94a26fc7ac4ef34316519b1d52e49" id="r_a13c94a26fc7ac4ef34316519b1d52e49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a13c94a26fc7ac4ef34316519b1d52e49">check_NOLA</a> (window, nperseg, noverlap, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-10)</td></tr>
<tr class="separator:a13c94a26fc7ac4ef34316519b1d52e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eee5a94f5128e159f80bbf7be61d2f" id="r_ad0eee5a94f5128e159f80bbf7be61d2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#ad0eee5a94f5128e159f80bbf7be61d2f">stft</a> (x, fs=1.0, window='hann', nperseg=256, noverlap=None, nfft=None, <a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>=False, return_onesided=True, boundary='zeros', padded=True, axis=-1, scaling='spectrum')</td></tr>
<tr class="separator:ad0eee5a94f5128e159f80bbf7be61d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b39dcdf416fb9d891d16cdeb8633f4" id="r_a19b39dcdf416fb9d891d16cdeb8633f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a19b39dcdf416fb9d891d16cdeb8633f4">istft</a> (Zxx, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, input_onesided=True, boundary=True, time_axis=-1, freq_axis=-2, scaling='spectrum')</td></tr>
<tr class="separator:a19b39dcdf416fb9d891d16cdeb8633f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f334cd2cbf48712f19204fa6e62d68" id="r_a24f334cd2cbf48712f19204fa6e62d68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a24f334cd2cbf48712f19204fa6e62d68">coherence</a> (x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', axis=-1)</td></tr>
<tr class="separator:a24f334cd2cbf48712f19204fa6e62d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d45d15e0d240790fe33574479be2b" id="r_a2f0d45d15e0d240790fe33574479be2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a2f0d45d15e0d240790fe33574479be2b">_spectral_helper</a> (x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=True, scaling='density', axis=-1, mode='psd', boundary=None, padded=False)</td></tr>
<tr class="separator:a2f0d45d15e0d240790fe33574479be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42777904c2943e2e8c7a62d0c3a639f" id="r_ab42777904c2943e2e8c7a62d0c3a639f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#ab42777904c2943e2e8c7a62d0c3a639f">_fft_helper</a> (x, win, detrend_func, nperseg, noverlap, nfft, sides)</td></tr>
<tr class="separator:ab42777904c2943e2e8c7a62d0c3a639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82dde67c5d61334ca7d9c078be6a6ce" id="r_ac82dde67c5d61334ca7d9c078be6a6ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#ac82dde67c5d61334ca7d9c078be6a6ce">_triage_segments</a> (window, nperseg, input_length)</td></tr>
<tr class="separator:ac82dde67c5d61334ca7d9c078be6a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f182108e5535b53bc8adf0394c51548" id="r_a4f182108e5535b53bc8adf0394c51548"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__spectral__py.html#a4f182108e5535b53bc8adf0394c51548">_median_bias</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a4f182108e5535b53bc8adf0394c51548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Tools for spectral analysis.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ab42777904c2943e2e8c7a62d0c3a639f" name="ab42777904c2943e2e8c7a62d0c3a639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42777904c2943e2e8c7a62d0c3a639f">&#9670;&#160;</a></span>_fft_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._fft_helper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate windowed FFT, for internal use by
`scipy.signal._spectral_helper`.

This is a helper function that does the main FFT calculation for
`_spectral helper`. All input validation is performed there, and the
data axis is assumed to be the last axis of x. It is not designed to
be called externally. The windows are not averaged over; the result
from each window is returned.

Returns
-------
result : ndarray
    Array of FFT data

Notes
-----
Adapted from matplotlib.mlab

.. versionadded:: 0.16.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1910</span><span class="keyword">def </span>_fft_helper(x, win, detrend_func, nperseg, noverlap, nfft, sides):</div>
<div class="line"><span class="lineno"> 1911</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">    Calculate windowed FFT, for internal use by</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">    `scipy.signal._spectral_helper`.</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">    This is a helper function that does the main FFT calculation for</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    `_spectral helper`. All input validation is performed there, and the</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">    data axis is assumed to be the last axis of x. It is not designed to</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral">    be called externally. The windows are not averaged over; the result</span></div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">    from each window is returned.</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">    result : ndarray</span></div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral">        Array of FFT data</span></div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">    Adapted from matplotlib.mlab</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1932</span>    <span class="comment"># Created strided array of data segments</span></div>
<div class="line"><span class="lineno"> 1933</span>    <span class="keywordflow">if</span> nperseg == 1 <span class="keywordflow">and</span> noverlap == 0:</div>
<div class="line"><span class="lineno"> 1934</span>        result = x[..., np.newaxis]</div>
<div class="line"><span class="lineno"> 1935</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1936</span>        <span class="comment"># https://stackoverflow.com/a/5568169</span></div>
<div class="line"><span class="lineno"> 1937</span>        step = nperseg - noverlap</div>
<div class="line"><span class="lineno"> 1938</span>        shape = x.shape[:-1]+((x.shape[-1]-noverlap)//step, nperseg)</div>
<div class="line"><span class="lineno"> 1939</span>        strides = x.strides[:-1]+(step*x.strides[-1], x.strides[-1])</div>
<div class="line"><span class="lineno"> 1940</span>        result = np.lib.stride_tricks.as_strided(x, shape=shape,</div>
<div class="line"><span class="lineno"> 1941</span>                                                 strides=strides)</div>
<div class="line"><span class="lineno"> 1942</span> </div>
<div class="line"><span class="lineno"> 1943</span>    <span class="comment"># Detrend each data segment individually</span></div>
<div class="line"><span class="lineno"> 1944</span>    result = detrend_func(result)</div>
<div class="line"><span class="lineno"> 1945</span> </div>
<div class="line"><span class="lineno"> 1946</span>    <span class="comment"># Apply window by multiplication</span></div>
<div class="line"><span class="lineno"> 1947</span>    result = win * result</div>
<div class="line"><span class="lineno"> 1948</span> </div>
<div class="line"><span class="lineno"> 1949</span>    <span class="comment"># Perform the fft. Acts on last axis by default. Zero-pads automatically</span></div>
<div class="line"><span class="lineno"> 1950</span>    <span class="keywordflow">if</span> sides == <span class="stringliteral">&#39;twosided&#39;</span>:</div>
<div class="line"><span class="lineno"> 1951</span>        func = sp_fft.fft</div>
<div class="line"><span class="lineno"> 1952</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1953</span>        result = result.real</div>
<div class="line"><span class="lineno"> 1954</span>        func = sp_fft.rfft</div>
<div class="line"><span class="lineno"> 1955</span>    result = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(result, n=nfft)</div>
<div class="line"><span class="lineno"> 1956</span> </div>
<div class="line"><span class="lineno"> 1957</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1958</span> </div>
<div class="line"><span class="lineno"> 1959</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f182108e5535b53bc8adf0394c51548" name="a4f182108e5535b53bc8adf0394c51548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f182108e5535b53bc8adf0394c51548">&#9670;&#160;</a></span>_median_bias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._median_bias </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the bias of the median of a set of periodograms relative to
the mean.

See Appendix B from [1]_ for details.

Parameters
----------
n : int
    Numbers of periodograms being averaged.

Returns
-------
bias : float
    Calculated bias.

References
----------
.. [1] B. Allen, W.G. Anderson, P.R. Brady, D.A. Brown, J.D.E. Creighton.
       "FINDCHIRP: an algorithm for detection of gravitational waves from
       inspiraling compact binaries", Physical Review D 85, 2012,
       :arxiv:`gr-qc/0509116`
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2019</span><span class="keyword">def </span>_median_bias(n):</div>
<div class="line"><span class="lineno"> 2020</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral">    Returns the bias of the median of a set of periodograms relative to</span></div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">    the mean.</span></div>
<div class="line"><span class="lineno"> 2023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2024</span><span class="stringliteral">    See Appendix B from [1]_ for details.</span></div>
<div class="line"><span class="lineno"> 2025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2026</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2027</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2028</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno"> 2029</span><span class="stringliteral">        Numbers of periodograms being averaged.</span></div>
<div class="line"><span class="lineno"> 2030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2031</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2032</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2033</span><span class="stringliteral">    bias : float</span></div>
<div class="line"><span class="lineno"> 2034</span><span class="stringliteral">        Calculated bias.</span></div>
<div class="line"><span class="lineno"> 2035</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2036</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral">    .. [1] B. Allen, W.G. Anderson, P.R. Brady, D.A. Brown, J.D.E. Creighton.</span></div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">           &quot;FINDCHIRP: an algorithm for detection of gravitational waves from</span></div>
<div class="line"><span class="lineno"> 2040</span><span class="stringliteral">           inspiraling compact binaries&quot;, Physical Review D 85, 2012,</span></div>
<div class="line"><span class="lineno"> 2041</span><span class="stringliteral">           :arxiv:`gr-qc/0509116`</span></div>
<div class="line"><span class="lineno"> 2042</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2043</span>    ii_2 = 2 * np.arange(1., (n-1) // 2 + 1)</div>
<div class="line"><span class="lineno"> 2044</span>    <span class="keywordflow">return</span> 1 + np.sum(1. / (ii_2 + 1) - 1. / ii_2)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f0d45d15e0d240790fe33574479be2b" name="a2f0d45d15e0d240790fe33574479be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0d45d15e0d240790fe33574479be2b">&#9670;&#160;</a></span>_spectral_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._spectral_helper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hann'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_onesided</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>'density'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'psd'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>boundary</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate various forms of windowed FFTs for PSD, CSD, etc.

This is a helper function that implements the commonality between
the stft, psd, csd, and spectrogram functions. It is not designed to
be called externally. The windows are not averaged over; the result
from each window is returned.

Parameters
----------
x : array_like
    Array or sequence containing the data to be analyzed.
y : array_like
    Array or sequence containing the data to be analyzed. If this is
    the same object in memory as `x` (i.e. ``_spectral_helper(x,
    x, ...)``), the extra computations are spared.
fs : float, optional
    Sampling frequency of the time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg. Defaults
    to a Hann window.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap : int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the cross spectral density ('density')
    where `Pxy` has units of V**2/Hz and computing the cross
    spectrum ('spectrum') where `Pxy` has units of V**2, if `x`
    and `y` are measured in V and `fs` is measured in Hz.
    Defaults to 'density'
axis : int, optional
    Axis along which the FFTs are computed; the default is over the
    last axis (i.e. ``axis=-1``).
mode: str {'psd', 'stft'}, optional
    Defines what kind of return values are expected. Defaults to
    'psd'.
boundary : str or None, optional
    Specifies whether the input signal is extended at both ends, and
    how to generate the new values, in order to center the first
    windowed segment on the first input point. This has the benefit
    of enabling reconstruction of the first input point when the
    employed window function starts at zero. Valid options are
    ``['even', 'odd', 'constant', 'zeros', None]``. Defaults to
    `None`.
padded : bool, optional
    Specifies whether the input signal is zero-padded at the end to
    make the signal fit exactly into an integer number of window
    segments, so that all of the signal is included in the output.
    Defaults to `False`. Padding occurs after boundary extension, if
    `boundary` is not `None`, and `padded` is `True`.

Returns
-------
freqs : ndarray
    Array of sample frequencies.
t : ndarray
    Array of times corresponding to each data segment
result : ndarray
    Array of output data, contents dependent on *mode* kwarg.

Notes
-----
Adapted from matplotlib.mlab

.. versionadded:: 0.16.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1619</span>                     padded=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 1620</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate various forms of windowed FFTs for PSD, CSD, etc.</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    This is a helper function that implements the commonality between</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    the stft, psd, csd, and spectrogram functions. It is not designed to</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    be called externally. The windows are not averaged over; the result</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    from each window is returned.</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">        Array or sequence containing the data to be analyzed.</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">        Array or sequence containing the data to be analyzed. If this is</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">        the same object in memory as `x` (i.e. ``_spectral_helper(x,</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">        x, ...)``), the extra computations are spared.</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">        Sampling frequency of the time series. Defaults to 1.0.</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">        directly as the window and its length must be nperseg. Defaults</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">        to a Hann window.</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">    nperseg : int, optional</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">        Length of each segment. Defaults to None, but if window is str or</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">        tuple, is set to 256, and if window is array_like, is set to the</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">        length of the window.</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">    noverlap : int, optional</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">        Number of points to overlap between segments. If `None`,</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">        ``noverlap = nperseg // 2``. Defaults to `None`.</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral">        Length of the FFT used, if a zero padded FFT is desired. If</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">        `None`, the FFT length is `nperseg`. Defaults to `None`.</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral">    detrend : str or function or `False`, optional</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">        Specifies how to detrend each segment. If `detrend` is a</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">        string, it is passed as the `type` argument to the `detrend`</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">        function. If it is a function, it takes a segment and returns a</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">        detrended segment. If `detrend` is `False`, no detrending is</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">        done. Defaults to &#39;constant&#39;.</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">    return_onesided : bool, optional</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">        If `True`, return a one-sided spectrum for real data. If</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">        `False` return a two-sided spectrum. Defaults to `True`, but for</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">        complex data, a two-sided spectrum is always returned.</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">    scaling : { &#39;density&#39;, &#39;spectrum&#39; }, optional</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">        Selects between computing the cross spectral density (&#39;density&#39;)</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">        where `Pxy` has units of V**2/Hz and computing the cross</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">        spectrum (&#39;spectrum&#39;) where `Pxy` has units of V**2, if `x`</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">        and `y` are measured in V and `fs` is measured in Hz.</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">        Defaults to &#39;density&#39;</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">        Axis along which the FFTs are computed; the default is over the</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">        last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    mode: str {&#39;psd&#39;, &#39;stft&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">        Defines what kind of return values are expected. Defaults to</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">        &#39;psd&#39;.</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    boundary : str or None, optional</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">        Specifies whether the input signal is extended at both ends, and</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">        how to generate the new values, in order to center the first</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">        windowed segment on the first input point. This has the benefit</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">        of enabling reconstruction of the first input point when the</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">        employed window function starts at zero. Valid options are</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">        ``[&#39;even&#39;, &#39;odd&#39;, &#39;constant&#39;, &#39;zeros&#39;, None]``. Defaults to</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">        `None`.</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    padded : bool, optional</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">        Specifies whether the input signal is zero-padded at the end to</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        make the signal fit exactly into an integer number of window</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">        segments, so that all of the signal is included in the output.</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">        Defaults to `False`. Padding occurs after boundary extension, if</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">        `boundary` is not `None`, and `padded` is `True`.</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">    freqs : ndarray</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">        Array of sample frequencies.</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    t : ndarray</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">        Array of times corresponding to each data segment</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">    result : ndarray</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">        Array of output data, contents dependent on *mode* kwarg.</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    Adapted from matplotlib.mlab</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1706</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;psd&#39;</span>, <span class="stringliteral">&#39;stft&#39;</span>]:</div>
<div class="line"><span class="lineno"> 1707</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unknown value for mode %s, must be one of: &quot;</span></div>
<div class="line"><span class="lineno"> 1708</span>                         <span class="stringliteral">&quot;{&#39;psd&#39;, &#39;stft&#39;}&quot;</span> % mode)</div>
<div class="line"><span class="lineno"> 1709</span> </div>
<div class="line"><span class="lineno"> 1710</span>    boundary_funcs = {<span class="stringliteral">&#39;even&#39;</span>: even_ext,</div>
<div class="line"><span class="lineno"> 1711</span>                      <span class="stringliteral">&#39;odd&#39;</span>: odd_ext,</div>
<div class="line"><span class="lineno"> 1712</span>                      <span class="stringliteral">&#39;constant&#39;</span>: const_ext,</div>
<div class="line"><span class="lineno"> 1713</span>                      <span class="stringliteral">&#39;zeros&#39;</span>: zero_ext,</div>
<div class="line"><span class="lineno"> 1714</span>                      <span class="keywordtype">None</span>: <span class="keywordtype">None</span>}</div>
<div class="line"><span class="lineno"> 1715</span> </div>
<div class="line"><span class="lineno"> 1716</span>    <span class="keywordflow">if</span> boundary <span class="keywordflow">not</span> <span class="keywordflow">in</span> boundary_funcs:</div>
<div class="line"><span class="lineno"> 1717</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unknown boundary option &#39;{0}&#39;, must be one of: {1}&quot;</span></div>
<div class="line"><span class="lineno"> 1718</span>                         .format(boundary, list(boundary_funcs.keys())))</div>
<div class="line"><span class="lineno"> 1719</span> </div>
<div class="line"><span class="lineno"> 1720</span>    <span class="comment"># If x and y are the same object we can save ourselves some computation.</span></div>
<div class="line"><span class="lineno"> 1721</span>    same_data = y <span class="keywordflow">is</span> x</div>
<div class="line"><span class="lineno"> 1722</span> </div>
<div class="line"><span class="lineno"> 1723</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data <span class="keywordflow">and</span> mode != <span class="stringliteral">&#39;psd&#39;</span>:</div>
<div class="line"><span class="lineno"> 1724</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;x and y must be equal if mode is &#39;stft&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1725</span> </div>
<div class="line"><span class="lineno"> 1726</span>    axis = int(axis)</div>
<div class="line"><span class="lineno"> 1727</span> </div>
<div class="line"><span class="lineno"> 1728</span>    <span class="comment"># Ensure we have np.arrays, get outdtype</span></div>
<div class="line"><span class="lineno"> 1729</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 1730</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data:</div>
<div class="line"><span class="lineno"> 1731</span>        y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 1732</span>        outdtype = np.result_type(x, y, np.complex64)</div>
<div class="line"><span class="lineno"> 1733</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1734</span>        outdtype = np.result_type(x, np.complex64)</div>
<div class="line"><span class="lineno"> 1735</span> </div>
<div class="line"><span class="lineno"> 1736</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data:</div>
<div class="line"><span class="lineno"> 1737</span>        <span class="comment"># Check if we can broadcast the outer axes together</span></div>
<div class="line"><span class="lineno"> 1738</span>        xouter = list(x.shape)</div>
<div class="line"><span class="lineno"> 1739</span>        youter = list(y.shape)</div>
<div class="line"><span class="lineno"> 1740</span>        xouter.pop(axis)</div>
<div class="line"><span class="lineno"> 1741</span>        youter.pop(axis)</div>
<div class="line"><span class="lineno"> 1742</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1743</span>            outershape = np.broadcast(np.empty(xouter), np.empty(youter)).shape</div>
<div class="line"><span class="lineno"> 1744</span>        <span class="keywordflow">except</span> ValueError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 1745</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;x and y cannot be broadcast together.&#39;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 1746</span> </div>
<div class="line"><span class="lineno"> 1747</span>    <span class="keywordflow">if</span> same_data:</div>
<div class="line"><span class="lineno"> 1748</span>        <span class="keywordflow">if</span> x.size == 0:</div>
<div class="line"><span class="lineno"> 1749</span>            <span class="keywordflow">return</span> np.empty(x.shape), np.empty(x.shape), np.empty(x.shape)</div>
<div class="line"><span class="lineno"> 1750</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1751</span>        <span class="keywordflow">if</span> x.size == 0 <span class="keywordflow">or</span> y.size == 0:</div>
<div class="line"><span class="lineno"> 1752</span>            outshape = outershape + (min([x.shape[axis], y.shape[axis]]),)</div>
<div class="line"><span class="lineno"> 1753</span>            emptyout = np.moveaxis(np.empty(outshape), -1, axis)</div>
<div class="line"><span class="lineno"> 1754</span>            <span class="keywordflow">return</span> emptyout, emptyout, emptyout</div>
<div class="line"><span class="lineno"> 1755</span> </div>
<div class="line"><span class="lineno"> 1756</span>    <span class="keywordflow">if</span> x.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 1757</span>        <span class="keywordflow">if</span> axis != -1:</div>
<div class="line"><span class="lineno"> 1758</span>            x = np.moveaxis(x, axis, -1)</div>
<div class="line"><span class="lineno"> 1759</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data <span class="keywordflow">and</span> y.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 1760</span>                y = np.moveaxis(y, axis, -1)</div>
<div class="line"><span class="lineno"> 1761</span> </div>
<div class="line"><span class="lineno"> 1762</span>    <span class="comment"># Check if x and y are the same length, zero-pad if necessary</span></div>
<div class="line"><span class="lineno"> 1763</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data:</div>
<div class="line"><span class="lineno"> 1764</span>        <span class="keywordflow">if</span> x.shape[-1] != y.shape[-1]:</div>
<div class="line"><span class="lineno"> 1765</span>            <span class="keywordflow">if</span> x.shape[-1] &lt; y.shape[-1]:</div>
<div class="line"><span class="lineno"> 1766</span>                pad_shape = list(x.shape)</div>
<div class="line"><span class="lineno"> 1767</span>                pad_shape[-1] = y.shape[-1] - x.shape[-1]</div>
<div class="line"><span class="lineno"> 1768</span>                x = np.concatenate((x, np.zeros(pad_shape)), -1)</div>
<div class="line"><span class="lineno"> 1769</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1770</span>                pad_shape = list(y.shape)</div>
<div class="line"><span class="lineno"> 1771</span>                pad_shape[-1] = x.shape[-1] - y.shape[-1]</div>
<div class="line"><span class="lineno"> 1772</span>                y = np.concatenate((y, np.zeros(pad_shape)), -1)</div>
<div class="line"><span class="lineno"> 1773</span> </div>
<div class="line"><span class="lineno"> 1774</span>    <span class="keywordflow">if</span> nperseg <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:  <span class="comment"># if specified by user</span></div>
<div class="line"><span class="lineno"> 1775</span>        nperseg = int(nperseg)</div>
<div class="line"><span class="lineno"> 1776</span>        <span class="keywordflow">if</span> nperseg &lt; 1:</div>
<div class="line"><span class="lineno"> 1777</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;nperseg must be a positive integer&#39;</span>)</div>
<div class="line"><span class="lineno"> 1778</span> </div>
<div class="line"><span class="lineno"> 1779</span>    <span class="comment"># parse window; if array like, then set nperseg = win.shape</span></div>
<div class="line"><span class="lineno"> 1780</span>    win, nperseg = _triage_segments(window, nperseg, input_length=x.shape[-1])</div>
<div class="line"><span class="lineno"> 1781</span> </div>
<div class="line"><span class="lineno"> 1782</span>    <span class="keywordflow">if</span> nfft <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1783</span>        nfft = nperseg</div>
<div class="line"><span class="lineno"> 1784</span>    <span class="keywordflow">elif</span> nfft &lt; nperseg:</div>
<div class="line"><span class="lineno"> 1785</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;nfft must be greater than or equal to nperseg.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1786</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1787</span>        nfft = int(nfft)</div>
<div class="line"><span class="lineno"> 1788</span> </div>
<div class="line"><span class="lineno"> 1789</span>    <span class="keywordflow">if</span> noverlap <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1790</span>        noverlap = nperseg//2</div>
<div class="line"><span class="lineno"> 1791</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1792</span>        noverlap = int(noverlap)</div>
<div class="line"><span class="lineno"> 1793</span>    <span class="keywordflow">if</span> noverlap &gt;= nperseg:</div>
<div class="line"><span class="lineno"> 1794</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;noverlap must be less than nperseg.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1795</span>    nstep = nperseg - noverlap</div>
<div class="line"><span class="lineno"> 1796</span> </div>
<div class="line"><span class="lineno"> 1797</span>    <span class="comment"># Padding occurs after boundary extension, so that the extended signal ends</span></div>
<div class="line"><span class="lineno"> 1798</span>    <span class="comment"># in zeros, instead of introducing an impulse at the end.</span></div>
<div class="line"><span class="lineno"> 1799</span>    <span class="comment"># I.e. if x = [..., 3, 2]</span></div>
<div class="line"><span class="lineno"> 1800</span>    <span class="comment"># extend then pad -&gt; [..., 3, 2, 2, 3, 0, 0, 0]</span></div>
<div class="line"><span class="lineno"> 1801</span>    <span class="comment"># pad then extend -&gt; [..., 3, 2, 0, 0, 0, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1802</span> </div>
<div class="line"><span class="lineno"> 1803</span>    <span class="keywordflow">if</span> boundary <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1804</span>        ext_func = boundary_funcs[boundary]</div>
<div class="line"><span class="lineno"> 1805</span>        x = ext_func(x, nperseg//2, axis=-1)</div>
<div class="line"><span class="lineno"> 1806</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data:</div>
<div class="line"><span class="lineno"> 1807</span>            y = ext_func(y, nperseg//2, axis=-1)</div>
<div class="line"><span class="lineno"> 1808</span> </div>
<div class="line"><span class="lineno"> 1809</span>    <span class="keywordflow">if</span> padded:</div>
<div class="line"><span class="lineno"> 1810</span>        <span class="comment"># Pad to integer number of windowed segments</span></div>
<div class="line"><span class="lineno"> 1811</span>        <span class="comment"># I.e make x.shape[-1] = nperseg + (nseg-1)*nstep, with integer nseg</span></div>
<div class="line"><span class="lineno"> 1812</span>        nadd = (-(x.shape[-1]-nperseg) % nstep) % nperseg</div>
<div class="line"><span class="lineno"> 1813</span>        zeros_shape = list(x.shape[:-1]) + [nadd]</div>
<div class="line"><span class="lineno"> 1814</span>        x = np.concatenate((x, np.zeros(zeros_shape)), axis=-1)</div>
<div class="line"><span class="lineno"> 1815</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data:</div>
<div class="line"><span class="lineno"> 1816</span>            zeros_shape = list(y.shape[:-1]) + [nadd]</div>
<div class="line"><span class="lineno"> 1817</span>            y = np.concatenate((y, np.zeros(zeros_shape)), axis=-1)</div>
<div class="line"><span class="lineno"> 1818</span> </div>
<div class="line"><span class="lineno"> 1819</span>    <span class="comment"># Handle detrending and window functions</span></div>
<div class="line"><span class="lineno"> 1820</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> detrend:</div>
<div class="line"><span class="lineno"> 1821</span>        <span class="keyword">def </span>detrend_func(d):</div>
<div class="line"><span class="lineno"> 1822</span>            <span class="keywordflow">return</span> d</div>
<div class="line"><span class="lineno"> 1823</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> hasattr(detrend, <span class="stringliteral">&#39;__call__&#39;</span>):</div>
<div class="line"><span class="lineno"> 1824</span>        <span class="keyword">def </span>detrend_func(d):</div>
<div class="line"><span class="lineno"> 1825</span>            <span class="keywordflow">return</span> _signaltools.detrend(d, type=detrend, axis=-1)</div>
<div class="line"><span class="lineno"> 1826</span>    <span class="keywordflow">elif</span> axis != -1:</div>
<div class="line"><span class="lineno"> 1827</span>        <span class="comment"># Wrap this function so that it receives a shape that it could</span></div>
<div class="line"><span class="lineno"> 1828</span>        <span class="comment"># reasonably expect to receive.</span></div>
<div class="line"><span class="lineno"> 1829</span>        <span class="keyword">def </span>detrend_func(d):</div>
<div class="line"><span class="lineno"> 1830</span>            d = np.moveaxis(d, -1, axis)</div>
<div class="line"><span class="lineno"> 1831</span>            d = detrend(d)</div>
<div class="line"><span class="lineno"> 1832</span>            <span class="keywordflow">return</span> np.moveaxis(d, axis, -1)</div>
<div class="line"><span class="lineno"> 1833</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1834</span>        detrend_func = detrend</div>
<div class="line"><span class="lineno"> 1835</span> </div>
<div class="line"><span class="lineno"> 1836</span>    <span class="keywordflow">if</span> np.result_type(win, np.complex64) != outdtype:</div>
<div class="line"><span class="lineno"> 1837</span>        win = win.astype(outdtype)</div>
<div class="line"><span class="lineno"> 1838</span> </div>
<div class="line"><span class="lineno"> 1839</span>    <span class="keywordflow">if</span> scaling == <span class="stringliteral">&#39;density&#39;</span>:</div>
<div class="line"><span class="lineno"> 1840</span>        scale = 1.0 / (fs * (win*win).sum())</div>
<div class="line"><span class="lineno"> 1841</span>    <span class="keywordflow">elif</span> scaling == <span class="stringliteral">&#39;spectrum&#39;</span>:</div>
<div class="line"><span class="lineno"> 1842</span>        scale = 1.0 / win.sum()**2</div>
<div class="line"><span class="lineno"> 1843</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1844</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Unknown scaling: %r&#39;</span> % scaling)</div>
<div class="line"><span class="lineno"> 1845</span> </div>
<div class="line"><span class="lineno"> 1846</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;stft&#39;</span>:</div>
<div class="line"><span class="lineno"> 1847</span>        scale = np.sqrt(scale)</div>
<div class="line"><span class="lineno"> 1848</span> </div>
<div class="line"><span class="lineno"> 1849</span>    <span class="keywordflow">if</span> return_onesided:</div>
<div class="line"><span class="lineno"> 1850</span>        <span class="keywordflow">if</span> np.iscomplexobj(x):</div>
<div class="line"><span class="lineno"> 1851</span>            sides = <span class="stringliteral">&#39;twosided&#39;</span></div>
<div class="line"><span class="lineno"> 1852</span>            warnings.warn(<span class="stringliteral">&#39;Input data is complex, switching to &#39;</span></div>
<div class="line"><span class="lineno"> 1853</span>                          <span class="stringliteral">&#39;return_onesided=False&#39;</span>)</div>
<div class="line"><span class="lineno"> 1854</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1855</span>            sides = <span class="stringliteral">&#39;onesided&#39;</span></div>
<div class="line"><span class="lineno"> 1856</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data:</div>
<div class="line"><span class="lineno"> 1857</span>                <span class="keywordflow">if</span> np.iscomplexobj(y):</div>
<div class="line"><span class="lineno"> 1858</span>                    sides = <span class="stringliteral">&#39;twosided&#39;</span></div>
<div class="line"><span class="lineno"> 1859</span>                    warnings.warn(<span class="stringliteral">&#39;Input data is complex, switching to &#39;</span></div>
<div class="line"><span class="lineno"> 1860</span>                                  <span class="stringliteral">&#39;return_onesided=False&#39;</span>)</div>
<div class="line"><span class="lineno"> 1861</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1862</span>        sides = <span class="stringliteral">&#39;twosided&#39;</span></div>
<div class="line"><span class="lineno"> 1863</span> </div>
<div class="line"><span class="lineno"> 1864</span>    <span class="keywordflow">if</span> sides == <span class="stringliteral">&#39;twosided&#39;</span>:</div>
<div class="line"><span class="lineno"> 1865</span>        freqs = sp_fft.fftfreq(nfft, 1/fs)</div>
<div class="line"><span class="lineno"> 1866</span>    <span class="keywordflow">elif</span> sides == <span class="stringliteral">&#39;onesided&#39;</span>:</div>
<div class="line"><span class="lineno"> 1867</span>        freqs = sp_fft.rfftfreq(nfft, 1/fs)</div>
<div class="line"><span class="lineno"> 1868</span> </div>
<div class="line"><span class="lineno"> 1869</span>    <span class="comment"># Perform the windowed FFTs</span></div>
<div class="line"><span class="lineno"> 1870</span>    result = _fft_helper(x, win, detrend_func, nperseg, noverlap, nfft, sides)</div>
<div class="line"><span class="lineno"> 1871</span> </div>
<div class="line"><span class="lineno"> 1872</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> same_data:</div>
<div class="line"><span class="lineno"> 1873</span>        <span class="comment"># All the same operations on the y data</span></div>
<div class="line"><span class="lineno"> 1874</span>        result_y = _fft_helper(y, win, detrend_func, nperseg, noverlap, nfft,</div>
<div class="line"><span class="lineno"> 1875</span>                               sides)</div>
<div class="line"><span class="lineno"> 1876</span>        result = np.conjugate(result) * result_y</div>
<div class="line"><span class="lineno"> 1877</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&#39;psd&#39;</span>:</div>
<div class="line"><span class="lineno"> 1878</span>        result = np.conjugate(result) * result</div>
<div class="line"><span class="lineno"> 1879</span> </div>
<div class="line"><span class="lineno"> 1880</span>    result *= scale</div>
<div class="line"><span class="lineno"> 1881</span>    <span class="keywordflow">if</span> sides == <span class="stringliteral">&#39;onesided&#39;</span> <span class="keywordflow">and</span> mode == <span class="stringliteral">&#39;psd&#39;</span>:</div>
<div class="line"><span class="lineno"> 1882</span>        <span class="keywordflow">if</span> nfft % 2:</div>
<div class="line"><span class="lineno"> 1883</span>            result[..., 1:] *= 2</div>
<div class="line"><span class="lineno"> 1884</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1885</span>            <span class="comment"># Last point is unpaired Nyquist freq point, don&#39;t double</span></div>
<div class="line"><span class="lineno"> 1886</span>            result[..., 1:-1] *= 2</div>
<div class="line"><span class="lineno"> 1887</span> </div>
<div class="line"><span class="lineno"> 1888</span>    time = np.arange(nperseg/2, x.shape[-1] - nperseg/2 + 1,</div>
<div class="line"><span class="lineno"> 1889</span>                     nperseg - noverlap)/float(fs)</div>
<div class="line"><span class="lineno"> 1890</span>    <span class="keywordflow">if</span> boundary <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1891</span>        time -= (nperseg/2) / fs</div>
<div class="line"><span class="lineno"> 1892</span> </div>
<div class="line"><span class="lineno"> 1893</span>    result = result.astype(outdtype)</div>
<div class="line"><span class="lineno"> 1894</span> </div>
<div class="line"><span class="lineno"> 1895</span>    <span class="comment"># All imaginary parts are zero anyways</span></div>
<div class="line"><span class="lineno"> 1896</span>    <span class="keywordflow">if</span> same_data <span class="keywordflow">and</span> mode != <span class="stringliteral">&#39;stft&#39;</span>:</div>
<div class="line"><span class="lineno"> 1897</span>        result = result.real</div>
<div class="line"><span class="lineno"> 1898</span> </div>
<div class="line"><span class="lineno"> 1899</span>    <span class="comment"># Output is going to have new last axis for time/window index, so a</span></div>
<div class="line"><span class="lineno"> 1900</span>    <span class="comment"># negative axis index shifts down one</span></div>
<div class="line"><span class="lineno"> 1901</span>    <span class="keywordflow">if</span> axis &lt; 0:</div>
<div class="line"><span class="lineno"> 1902</span>        axis -= 1</div>
<div class="line"><span class="lineno"> 1903</span> </div>
<div class="line"><span class="lineno"> 1904</span>    <span class="comment"># Roll frequency axis back to axis where the data came from</span></div>
<div class="line"><span class="lineno"> 1905</span>    result = np.moveaxis(result, -1, axis)</div>
<div class="line"><span class="lineno"> 1906</span> </div>
<div class="line"><span class="lineno"> 1907</span>    <span class="keywordflow">return</span> freqs, time, result</div>
<div class="line"><span class="lineno"> 1908</span> </div>
<div class="line"><span class="lineno"> 1909</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac82dde67c5d61334ca7d9c078be6a6ce" name="ac82dde67c5d61334ca7d9c078be6a6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82dde67c5d61334ca7d9c078be6a6ce">&#9670;&#160;</a></span>_triage_segments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._triage_segments </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parses window and nperseg arguments for spectrogram and _spectral_helper.
This is a helper function, not meant to be called externally.

Parameters
----------
window : string, tuple, or ndarray
    If window is specified by a string or tuple and nperseg is not
    specified, nperseg is set to the default of 256 and returns a window of
    that length.
    If instead the window is array_like and nperseg is not specified, then
    nperseg is set to the length of the window. A ValueError is raised if
    the user supplies both an array_like window and a value for nperseg but
    nperseg does not equal the length of the window.

nperseg : int
    Length of each segment

input_length: int
    Length of input signal, i.e. x.shape[-1]. Used to test for errors.

Returns
-------
win : ndarray
    window. If function was called with string or tuple than this will hold
    the actual array used as a window.

nperseg : int
    Length of each segment. If window is str or tuple, nperseg is set to
    256. If window is array_like, nperseg is set to the length of the
    window.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1960</span><span class="keyword">def </span>_triage_segments(window, nperseg, input_length):</div>
<div class="line"><span class="lineno"> 1961</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">    Parses window and nperseg arguments for spectrogram and _spectral_helper.</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">    This is a helper function, not meant to be called externally.</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">    window : string, tuple, or ndarray</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">        If window is specified by a string or tuple and nperseg is not</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">        specified, nperseg is set to the default of 256 and returns a window of</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">        that length.</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">        If instead the window is array_like and nperseg is not specified, then</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">        nperseg is set to the length of the window. A ValueError is raised if</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">        the user supplies both an array_like window and a value for nperseg but</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">        nperseg does not equal the length of the window.</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">    nperseg : int</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">        Length of each segment</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral">    input_length: int</span></div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">        Length of input signal, i.e. x.shape[-1]. Used to test for errors.</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    win : ndarray</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">        window. If function was called with string or tuple than this will hold</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">        the actual array used as a window.</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    nperseg : int</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral">        Length of each segment. If window is str or tuple, nperseg is set to</span></div>
<div class="line"><span class="lineno"> 1990</span><span class="stringliteral">        256. If window is array_like, nperseg is set to the length of the</span></div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral">        window.</span></div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1993</span>    <span class="comment"># parse window; if array like, then set nperseg = win.shape</span></div>
<div class="line"><span class="lineno"> 1994</span>    <span class="keywordflow">if</span> isinstance(window, str) <span class="keywordflow">or</span> isinstance(window, tuple):</div>
<div class="line"><span class="lineno"> 1995</span>        <span class="comment"># if nperseg not specified</span></div>
<div class="line"><span class="lineno"> 1996</span>        <span class="keywordflow">if</span> nperseg <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1997</span>            nperseg = 256  <span class="comment"># then change to default</span></div>
<div class="line"><span class="lineno"> 1998</span>        <span class="keywordflow">if</span> nperseg &gt; input_length:</div>
<div class="line"><span class="lineno"> 1999</span>            warnings.warn(<span class="stringliteral">&#39;nperseg = {0:d} is greater than input length &#39;</span></div>
<div class="line"><span class="lineno"> 2000</span>                          <span class="stringliteral">&#39; = {1:d}, using nperseg = {1:d}&#39;</span></div>
<div class="line"><span class="lineno"> 2001</span>                          .format(nperseg, input_length))</div>
<div class="line"><span class="lineno"> 2002</span>            nperseg = input_length</div>
<div class="line"><span class="lineno"> 2003</span>        win = get_window(window, nperseg)</div>
<div class="line"><span class="lineno"> 2004</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2005</span>        win = np.asarray(window)</div>
<div class="line"><span class="lineno"> 2006</span>        <span class="keywordflow">if</span> len(win.shape) != 1:</div>
<div class="line"><span class="lineno"> 2007</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must be 1-D&#39;</span>)</div>
<div class="line"><span class="lineno"> 2008</span>        <span class="keywordflow">if</span> input_length &lt; win.shape[-1]:</div>
<div class="line"><span class="lineno"> 2009</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window is longer than input signal&#39;</span>)</div>
<div class="line"><span class="lineno"> 2010</span>        <span class="keywordflow">if</span> nperseg <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2011</span>            nperseg = win.shape[0]</div>
<div class="line"><span class="lineno"> 2012</span>        <span class="keywordflow">elif</span> nperseg <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2013</span>            <span class="keywordflow">if</span> nperseg != win.shape[0]:</div>
<div class="line"><span class="lineno"> 2014</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;value specified for nperseg is different&quot;</span></div>
<div class="line"><span class="lineno"> 2015</span>                                 <span class="stringliteral">&quot; from length of window&quot;</span>)</div>
<div class="line"><span class="lineno"> 2016</span>    <span class="keywordflow">return</span> win, nperseg</div>
<div class="line"><span class="lineno"> 2017</span> </div>
<div class="line"><span class="lineno"> 2018</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a31f9eee97f27719960a111d57f4ddb9a" name="a31f9eee97f27719960a111d57f4ddb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f9eee97f27719960a111d57f4ddb9a">&#9670;&#160;</a></span>check_COLA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.check_COLA </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether the Constant OverLap Add (COLA) constraint is met.

Parameters
----------
window : str or tuple or array_like
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.

Returns
-------
verdict : bool
`True` if chosen combination satisfies COLA within `tol`,
`False` otherwise

See Also
--------
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform

Notes
-----
In order to enable inversion of an STFT via the inverse STFT in
`istft`, it is sufficient that the signal windowing obeys the constraint of
"Constant OverLap Add" (COLA). This ensures that every point in the input
data is equally weighted, thereby avoiding aliasing and allowing full
reconstruction.

Some examples of windows that satisfy COLA:
- Rectangular window at overlap of 0, 1/2, 2/3, 3/4, ...
- Bartlett window at overlap of 1/2, 3/4, 5/6, ...
- Hann window at 1/2, 2/3, 3/4, ...
- Any Blackman family window at 2/3 overlap
- Any window with ``noverlap = nperseg-1``

A very comprehensive list of other windows may be found in [2]_,
wherein the COLA condition is satisfied when the "Amplitude
Flatness" is unity.

.. versionadded:: 0.19.0

References
----------
.. [1] Julius O. Smith III, "Spectral Audio Signal Processing", W3K
   Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, "Spectrum and
   spectral density estimation by the Discrete Fourier transform
   (DFT), including a comprehensive list of window functions and
   some new at-top windows", 2002,
   http://hdl.handle.net/11858/00-001M-0000-0013-557A-5

Examples
--------
&gt;&gt;&gt; from scipy import signal

Confirm COLA condition for rectangular window of 75% (3/4) overlap:

&gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 75)
True

COLA is not true for 25% (1/4) overlap, though:

&gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 25)
False

"Symmetrical" Hann window (for filter design) is not COLA:

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=True), 120, 60)
False

"Periodic" or "DFT-even" Hann window (for FFT analysis) is COLA for
overlap of 1/2, 2/3, 3/4, etc.:

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 60)
True

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 80)
True

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 90)
True</pre> <div class="fragment"><div class="line"><span class="lineno">  778</span><span class="keyword">def </span>check_COLA(window, nperseg, noverlap, tol=1e-10):</div>
<div class="line"><span class="lineno">  779</span>    <span class="stringliteral">r&quot;&quot;&quot;Check whether the Constant OverLap Add (COLA) constraint is met.</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    window : str or tuple or array_like</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        directly as the window and its length must be nperseg.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    nperseg : int</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">        Length of each segment.</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    noverlap : int</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        Number of points to overlap between segments.</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        The allowed variance of a bin&#39;s weighted sum from the median bin</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        sum.</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    verdict : bool</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">        `True` if chosen combination satisfies COLA within `tol`,</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">        `False` otherwise</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    stft: Short Time Fourier Transform</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    istft: Inverse Short Time Fourier Transform</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    In order to enable inversion of an STFT via the inverse STFT in</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    `istft`, it is sufficient that the signal windowing obeys the constraint of</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    &quot;Constant OverLap Add&quot; (COLA). This ensures that every point in the input</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    data is equally weighted, thereby avoiding aliasing and allowing full</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    reconstruction.</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    Some examples of windows that satisfy COLA:</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">        - Rectangular window at overlap of 0, 1/2, 2/3, 3/4, ...</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        - Bartlett window at overlap of 1/2, 3/4, 5/6, ...</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">        - Hann window at 1/2, 2/3, 3/4, ...</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        - Any Blackman family window at 2/3 overlap</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        - Any window with ``noverlap = nperseg-1``</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    A very comprehensive list of other windows may be found in [2]_,</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    wherein the COLA condition is satisfied when the &quot;Amplitude</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    Flatness&quot; is unity.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    .. versionadded:: 0.19.0</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    .. [1] Julius O. Smith III, &quot;Spectral Audio Signal Processing&quot;, W3K</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">           Publishing, 2011,ISBN 978-0-9745607-3-1.</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    .. [2] G. Heinzel, A. Ruediger and R. Schilling, &quot;Spectrum and</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">           spectral density estimation by the Discrete Fourier transform</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">           (DFT), including a comprehensive list of window functions and</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">           some new at-top windows&quot;, 2002,</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">           http://hdl.handle.net/11858/00-001M-0000-0013-557A-5</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Confirm COLA condition for rectangular window of 75% (3/4) overlap:</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 75)</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    COLA is not true for 25% (1/4) overlap, though:</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 25)</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    &quot;Symmetrical&quot; Hann window (for filter design) is not COLA:</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=True), 120, 60)</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    &quot;Periodic&quot; or &quot;DFT-even&quot; Hann window (for FFT analysis) is COLA for</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    overlap of 1/2, 2/3, 3/4, etc.:</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 60)</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 80)</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 90)</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  872</span>    nperseg = int(nperseg)</div>
<div class="line"><span class="lineno">  873</span> </div>
<div class="line"><span class="lineno">  874</span>    <span class="keywordflow">if</span> nperseg &lt; 1:</div>
<div class="line"><span class="lineno">  875</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;nperseg must be a positive integer&#39;</span>)</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span>    <span class="keywordflow">if</span> noverlap &gt;= nperseg:</div>
<div class="line"><span class="lineno">  878</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;noverlap must be less than nperseg.&#39;</span>)</div>
<div class="line"><span class="lineno">  879</span>    noverlap = int(noverlap)</div>
<div class="line"><span class="lineno">  880</span> </div>
<div class="line"><span class="lineno">  881</span>    <span class="keywordflow">if</span> isinstance(window, str) <span class="keywordflow">or</span> type(window) <span class="keywordflow">is</span> tuple:</div>
<div class="line"><span class="lineno">  882</span>        win = get_window(window, nperseg)</div>
<div class="line"><span class="lineno">  883</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  884</span>        win = np.asarray(window)</div>
<div class="line"><span class="lineno">  885</span>        <span class="keywordflow">if</span> len(win.shape) != 1:</div>
<div class="line"><span class="lineno">  886</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must be 1-D&#39;</span>)</div>
<div class="line"><span class="lineno">  887</span>        <span class="keywordflow">if</span> win.shape[0] != nperseg:</div>
<div class="line"><span class="lineno">  888</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must have length of nperseg&#39;</span>)</div>
<div class="line"><span class="lineno">  889</span> </div>
<div class="line"><span class="lineno">  890</span>    step = nperseg - noverlap</div>
<div class="line"><span class="lineno">  891</span>    binsums = sum(win[ii*step:(ii+1)*step] <span class="keywordflow">for</span> ii <span class="keywordflow">in</span> range(nperseg//step))</div>
<div class="line"><span class="lineno">  892</span> </div>
<div class="line"><span class="lineno">  893</span>    <span class="keywordflow">if</span> nperseg % step != 0:</div>
<div class="line"><span class="lineno">  894</span>        binsums[:nperseg % step] += win[-(nperseg % step):]</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span>    deviation = binsums - np.median(binsums)</div>
<div class="line"><span class="lineno">  897</span>    <span class="keywordflow">return</span> np.max(np.abs(deviation)) &lt; tol</div>
<div class="line"><span class="lineno">  898</span> </div>
<div class="line"><span class="lineno">  899</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a13c94a26fc7ac4ef34316519b1d52e49" name="a13c94a26fc7ac4ef34316519b1d52e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c94a26fc7ac4ef34316519b1d52e49">&#9670;&#160;</a></span>check_NOLA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.check_NOLA </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether the Nonzero Overlap Add (NOLA) constraint is met.

Parameters
----------
window : str or tuple or array_like
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.

Returns
-------
verdict : bool
`True` if chosen combination satisfies the NOLA constraint within
`tol`, `False` otherwise

See Also
--------
check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform

Notes
-----
In order to enable inversion of an STFT via the inverse STFT in
`istft`, the signal windowing must obey the constraint of "nonzero
overlap add" (NOLA):

.. math:: \sum_{t}w^{2}[n-tH] \ne 0

for all :math:`n`, where :math:`w` is the window function, :math:`t` is the
frame index, and :math:`H` is the hop size (:math:`H` = `nperseg` -
`noverlap`).

This ensures that the normalization factors in the denominator of the
overlap-add inversion equation are not zero. Only very pathological windows
will fail the NOLA constraint.

.. versionadded:: 1.2.0

References
----------
.. [1] Julius O. Smith III, "Spectral Audio Signal Processing", W3K
   Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, "Spectrum and
   spectral density estimation by the Discrete Fourier transform
   (DFT), including a comprehensive list of window functions and
   some new at-top windows", 2002,
   http://hdl.handle.net/11858/00-001M-0000-0013-557A-5

Examples
--------
&gt;&gt;&gt; from scipy import signal

Confirm NOLA condition for rectangular window of 75% (3/4) overlap:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 75)
True

NOLA is also true for 25% (1/4) overlap:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 25)
True

"Symmetrical" Hann window (for filter design) is also NOLA:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(120, sym=True), 120, 60)
True

As long as there is overlap, it takes quite a pathological window to fail
NOLA:

&gt;&gt;&gt; w = np.ones(64, dtype="float")
&gt;&gt;&gt; w[::2] = 0
&gt;&gt;&gt; signal.check_NOLA(w, 64, 32)
False

If there is not enough overlap, a window with zeros at the ends will not
work:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 0)
False
&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 1)
False
&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 2)
True</pre> <div class="fragment"><div class="line"><span class="lineno">  900</span><span class="keyword">def </span>check_NOLA(window, nperseg, noverlap, tol=1e-10):</div>
<div class="line"><span class="lineno">  901</span>    <span class="stringliteral">r&quot;&quot;&quot;Check whether the Nonzero Overlap Add (NOLA) constraint is met.</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    window : str or tuple or array_like</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        directly as the window and its length must be nperseg.</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    nperseg : int</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        Length of each segment.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    noverlap : int</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        Number of points to overlap between segments.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">        The allowed variance of a bin&#39;s weighted sum from the median bin</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">        sum.</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    verdict : bool</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">        `True` if chosen combination satisfies the NOLA constraint within</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">        `tol`, `False` otherwise</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    stft: Short Time Fourier Transform</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    istft: Inverse Short Time Fourier Transform</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    In order to enable inversion of an STFT via the inverse STFT in</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    `istft`, the signal windowing must obey the constraint of &quot;nonzero</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    overlap add&quot; (NOLA):</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    .. math:: \sum_{t}w^{2}[n-tH] \ne 0</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    for all :math:`n`, where :math:`w` is the window function, :math:`t` is the</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    frame index, and :math:`H` is the hop size (:math:`H` = `nperseg` -</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    `noverlap`).</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    This ensures that the normalization factors in the denominator of the</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">    overlap-add inversion equation are not zero. Only very pathological windows</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    will fail the NOLA constraint.</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    .. [1] Julius O. Smith III, &quot;Spectral Audio Signal Processing&quot;, W3K</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">           Publishing, 2011,ISBN 978-0-9745607-3-1.</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    .. [2] G. Heinzel, A. Ruediger and R. Schilling, &quot;Spectrum and</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">           spectral density estimation by the Discrete Fourier transform</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">           (DFT), including a comprehensive list of window functions and</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">           some new at-top windows&quot;, 2002,</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">           http://hdl.handle.net/11858/00-001M-0000-0013-557A-5</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    Confirm NOLA condition for rectangular window of 75% (3/4) overlap:</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 75)</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    NOLA is also true for 25% (1/4) overlap:</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 25)</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    &quot;Symmetrical&quot; Hann window (for filter design) is also NOLA:</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(120, sym=True), 120, 60)</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    As long as there is overlap, it takes quite a pathological window to fail</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    NOLA:</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    &gt;&gt;&gt; w = np.ones(64, dtype=&quot;float&quot;)</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    &gt;&gt;&gt; w[::2] = 0</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_NOLA(w, 64, 32)</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    If there is not enough overlap, a window with zeros at the ends will not</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">    work:</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 0)</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 1)</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 2)</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  997</span>    nperseg = int(nperseg)</div>
<div class="line"><span class="lineno">  998</span> </div>
<div class="line"><span class="lineno">  999</span>    <span class="keywordflow">if</span> nperseg &lt; 1:</div>
<div class="line"><span class="lineno"> 1000</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;nperseg must be a positive integer&#39;</span>)</div>
<div class="line"><span class="lineno"> 1001</span> </div>
<div class="line"><span class="lineno"> 1002</span>    <span class="keywordflow">if</span> noverlap &gt;= nperseg:</div>
<div class="line"><span class="lineno"> 1003</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;noverlap must be less than nperseg&#39;</span>)</div>
<div class="line"><span class="lineno"> 1004</span>    <span class="keywordflow">if</span> noverlap &lt; 0:</div>
<div class="line"><span class="lineno"> 1005</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;noverlap must be a nonnegative integer&#39;</span>)</div>
<div class="line"><span class="lineno"> 1006</span>    noverlap = int(noverlap)</div>
<div class="line"><span class="lineno"> 1007</span> </div>
<div class="line"><span class="lineno"> 1008</span>    <span class="keywordflow">if</span> isinstance(window, str) <span class="keywordflow">or</span> type(window) <span class="keywordflow">is</span> tuple:</div>
<div class="line"><span class="lineno"> 1009</span>        win = get_window(window, nperseg)</div>
<div class="line"><span class="lineno"> 1010</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1011</span>        win = np.asarray(window)</div>
<div class="line"><span class="lineno"> 1012</span>        <span class="keywordflow">if</span> len(win.shape) != 1:</div>
<div class="line"><span class="lineno"> 1013</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must be 1-D&#39;</span>)</div>
<div class="line"><span class="lineno"> 1014</span>        <span class="keywordflow">if</span> win.shape[0] != nperseg:</div>
<div class="line"><span class="lineno"> 1015</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must have length of nperseg&#39;</span>)</div>
<div class="line"><span class="lineno"> 1016</span> </div>
<div class="line"><span class="lineno"> 1017</span>    step = nperseg - noverlap</div>
<div class="line"><span class="lineno"> 1018</span>    binsums = sum(win[ii*step:(ii+1)*step]**2 <span class="keywordflow">for</span> ii <span class="keywordflow">in</span> range(nperseg//step))</div>
<div class="line"><span class="lineno"> 1019</span> </div>
<div class="line"><span class="lineno"> 1020</span>    <span class="keywordflow">if</span> nperseg % step != 0:</div>
<div class="line"><span class="lineno"> 1021</span>        binsums[:nperseg % step] += win[-(nperseg % step):]**2</div>
<div class="line"><span class="lineno"> 1022</span> </div>
<div class="line"><span class="lineno"> 1023</span>    <span class="keywordflow">return</span> np.min(binsums) &gt; tol</div>
<div class="line"><span class="lineno"> 1024</span> </div>
<div class="line"><span class="lineno"> 1025</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a24f334cd2cbf48712f19204fa6e62d68" name="a24f334cd2cbf48712f19204fa6e62d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f334cd2cbf48712f19204fa6e62d68">&#9670;&#160;</a></span>coherence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.coherence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hann'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate the magnitude squared coherence estimate, Cxy, of
discrete-time signals X and Y using Welch's method.

``Cxy = abs(Pxy)**2/(Pxx*Pyy)``, where `Pxx` and `Pyy` are power
spectral density estimates of X and Y, and `Pxy` is the cross
spectral density estimate of X and Y.

Parameters
----------
x : array_like
    Time series of measurement values
y : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` and `y` time series. Defaults
    to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg. Defaults
    to a Hann window.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap: int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
axis : int, optional
    Axis along which the coherence is computed for both inputs; the
    default is over the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Cxy : ndarray
    Magnitude squared coherence of x and y.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.

.. versionadded:: 0.16.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
       estimation of power spectra: A method based on time averaging
       over short, modified periodograms", IEEE Trans. Audio
       Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Stoica, Petre, and Randolph Moses, "Spectral Analysis of
       Signals" Prentice Hall, 2005

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate two test signals with some common features.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 20
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low')
&gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; y = signal.lfilter(b, a, x)
&gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)

Compute and plot the coherence.

&gt;&gt;&gt; f, Cxy = signal.coherence(x, y, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, Cxy)
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Coherence')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1496</span>              nfft=<span class="keywordtype">None</span>, detrend=<span class="stringliteral">&#39;constant&#39;</span>, axis=-1):</div>
<div class="line"><span class="lineno"> 1497</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">    Estimate the magnitude squared coherence estimate, Cxy, of</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    discrete-time signals X and Y using Welch&#39;s method.</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    ``Cxy = abs(Pxy)**2/(Pxx*Pyy)``, where `Pxx` and `Pyy` are power</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">    spectral density estimates of X and Y, and `Pxy` is the cross</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    spectral density estimate of X and Y.</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        Sampling frequency of the `x` and `y` time series. Defaults</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">        to 1.0.</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">        directly as the window and its length must be nperseg. Defaults</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">        to a Hann window.</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    nperseg : int, optional</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">        Length of each segment. Defaults to None, but if window is str or</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        tuple, is set to 256, and if window is array_like, is set to the</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">        length of the window.</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    noverlap: int, optional</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">        Number of points to overlap between segments. If `None`,</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">        ``noverlap = nperseg // 2``. Defaults to `None`.</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">        Length of the FFT used, if a zero padded FFT is desired. If</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">        `None`, the FFT length is `nperseg`. Defaults to `None`.</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    detrend : str or function or `False`, optional</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">        Specifies how to detrend each segment. If `detrend` is a</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">        string, it is passed as the `type` argument to the `detrend`</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">        function. If it is a function, it takes a segment and returns a</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">        detrended segment. If `detrend` is `False`, no detrending is</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">        done. Defaults to &#39;constant&#39;.</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">        Axis along which the coherence is computed for both inputs; the</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">        default is over the last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    f : ndarray</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">        Array of sample frequencies.</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    Cxy : ndarray</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">        Magnitude squared coherence of x and y.</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    periodogram: Simple, optionally modified periodogram</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    lombscargle: Lomb-Scargle periodogram for unevenly sampled data</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    welch: Power spectral density by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    csd: Cross spectral density by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    An appropriate amount of overlap will depend on the choice of window</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    and on your requirements. For the default Hann window an overlap of</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    50% is a reasonable trade off between accurately estimating the</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">    signal power, while not over counting any of the data. Narrower</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    windows may require a larger overlap.</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">    .. [1] P. Welch, &quot;The use of the fast Fourier transform for the</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral">           estimation of power spectra: A method based on time averaging</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">           over short, modified periodograms&quot;, IEEE Trans. Audio</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">           Electroacoust. vol. 15, pp. 70-73, 1967.</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">    .. [2] Stoica, Petre, and Randolph Moses, &quot;Spectral Analysis of</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">           Signals&quot; Prentice Hall, 2005</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">    Generate two test signals with some common features.</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">    &gt;&gt;&gt; fs = 10e3</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">    &gt;&gt;&gt; N = 1e5</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    &gt;&gt;&gt; amp = 20</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    &gt;&gt;&gt; freq = 1234.0</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">    &gt;&gt;&gt; noise_power = 0.001 * fs / 2</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    &gt;&gt;&gt; time = np.arange(N) / fs</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    &gt;&gt;&gt; b, a = signal.butter(2, 0.25, &#39;low&#39;)</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape)</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">    &gt;&gt;&gt; y = signal.lfilter(b, a, x)</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    &gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    &gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    Compute and plot the coherence.</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    &gt;&gt;&gt; f, Cxy = signal.coherence(x, y, fs, nperseg=1024)</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f, Cxy)</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Coherence&#39;)</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1603</span>    freqs, Pxx = welch(x, fs=fs, window=window, nperseg=nperseg,</div>
<div class="line"><span class="lineno"> 1604</span>                       noverlap=noverlap, nfft=nfft, detrend=detrend,</div>
<div class="line"><span class="lineno"> 1605</span>                       axis=axis)</div>
<div class="line"><span class="lineno"> 1606</span>    _, Pyy = welch(y, fs=fs, window=window, nperseg=nperseg, noverlap=noverlap,</div>
<div class="line"><span class="lineno"> 1607</span>                   nfft=nfft, detrend=detrend, axis=axis)</div>
<div class="line"><span class="lineno"> 1608</span>    _, Pxy = csd(x, y, fs=fs, window=window, nperseg=nperseg,</div>
<div class="line"><span class="lineno"> 1609</span>                 noverlap=noverlap, nfft=nfft, detrend=detrend, axis=axis)</div>
<div class="line"><span class="lineno"> 1610</span> </div>
<div class="line"><span class="lineno"> 1611</span>    Cxy = np.abs(Pxy)**2 / Pxx / Pyy</div>
<div class="line"><span class="lineno"> 1612</span> </div>
<div class="line"><span class="lineno"> 1613</span>    <span class="keywordflow">return</span> freqs, Cxy</div>
<div class="line"><span class="lineno"> 1614</span> </div>
<div class="line"><span class="lineno"> 1615</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0b32e812473c8c8b467b5539edf825b" name="ab0b32e812473c8c8b467b5539edf825b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b32e812473c8c8b467b5539edf825b">&#9670;&#160;</a></span>csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.csd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hann'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_onesided</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>'density'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>average</em> = <code>'mean'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate the cross power spectral density, Pxy, using Welch's method.

Parameters
----------
x : array_like
    Time series of measurement values
y : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` and `y` time series. Defaults
    to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg. Defaults
    to a Hann window.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap: int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the cross spectral density ('density')
    where `Pxy` has units of V**2/Hz and computing the cross spectrum
    ('spectrum') where `Pxy` has units of V**2, if `x` and `y` are
    measured in V and `fs` is measured in Hz. Defaults to 'density'
axis : int, optional
    Axis along which the CSD is computed for both inputs; the
    default is over the last axis (i.e. ``axis=-1``).
average : { 'mean', 'median' }, optional
    Method to use when averaging periodograms. If the spectrum is
    complex, the average is computed separately for the real and
    imaginary parts. Defaults to 'mean'.

    .. versionadded:: 1.2.0

Returns
-------
f : ndarray
    Array of sample frequencies.
Pxy : ndarray
    Cross spectral density or cross power spectrum of x,y.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method. [Equivalent to
       csd(x,x)]
coherence: Magnitude squared coherence by Welch's method.

Notes
-----
By convention, Pxy is computed with the conjugate FFT of X
multiplied by the FFT of Y.

If the input series differ in length, the shorter series will be
zero-padded to match.

An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.

.. versionadded:: 0.16.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
       estimation of power spectra: A method based on time averaging
       over short, modified periodograms", IEEE Trans. Audio
       Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Rabiner, Lawrence R., and B. Gold. "Theory and Application of
       Digital Signal Processing" Prentice-Hall, pp. 414-419, 1975

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate two test signals with some common features.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 20
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low')
&gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; y = signal.lfilter(b, a, x)
&gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)

Compute and plot the magnitude of the cross spectral density.

&gt;&gt;&gt; f, Pxy = signal.csd(x, y, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, np.abs(Pxy))
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('CSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  456</span>        axis=-1, average=<span class="stringliteral">&#39;mean&#39;</span>):</div>
<div class="line"><span class="lineno">  457</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    Estimate the cross power spectral density, Pxy, using Welch&#39;s method.</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        Sampling frequency of the `x` and `y` time series. Defaults</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        to 1.0.</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        directly as the window and its length must be nperseg. Defaults</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        to a Hann window.</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    nperseg : int, optional</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        Length of each segment. Defaults to None, but if window is str or</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        tuple, is set to 256, and if window is array_like, is set to the</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        length of the window.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    noverlap: int, optional</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        Number of points to overlap between segments. If `None`,</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        ``noverlap = nperseg // 2``. Defaults to `None`.</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        Length of the FFT used, if a zero padded FFT is desired. If</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        `None`, the FFT length is `nperseg`. Defaults to `None`.</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    detrend : str or function or `False`, optional</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        Specifies how to detrend each segment. If `detrend` is a</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        string, it is passed as the `type` argument to the `detrend`</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        function. If it is a function, it takes a segment and returns a</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        detrended segment. If `detrend` is `False`, no detrending is</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        done. Defaults to &#39;constant&#39;.</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    return_onesided : bool, optional</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        If `True`, return a one-sided spectrum for real data. If</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        `False` return a two-sided spectrum. Defaults to `True`, but for</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">        complex data, a two-sided spectrum is always returned.</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    scaling : { &#39;density&#39;, &#39;spectrum&#39; }, optional</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">        Selects between computing the cross spectral density (&#39;density&#39;)</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">        where `Pxy` has units of V**2/Hz and computing the cross spectrum</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        (&#39;spectrum&#39;) where `Pxy` has units of V**2, if `x` and `y` are</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        measured in V and `fs` is measured in Hz. Defaults to &#39;density&#39;</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        Axis along which the CSD is computed for both inputs; the</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        default is over the last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    average : { &#39;mean&#39;, &#39;median&#39; }, optional</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        Method to use when averaging periodograms. If the spectrum is</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        complex, the average is computed separately for the real and</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        imaginary parts. Defaults to &#39;mean&#39;.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    f : ndarray</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        Array of sample frequencies.</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    Pxy : ndarray</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        Cross spectral density or cross power spectrum of x,y.</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    periodogram: Simple, optionally modified periodogram</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    lombscargle: Lomb-Scargle periodogram for unevenly sampled data</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    welch: Power spectral density by Welch&#39;s method. [Equivalent to</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">           csd(x,x)]</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    coherence: Magnitude squared coherence by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    By convention, Pxy is computed with the conjugate FFT of X</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    multiplied by the FFT of Y.</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    If the input series differ in length, the shorter series will be</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    zero-padded to match.</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    An appropriate amount of overlap will depend on the choice of window</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    and on your requirements. For the default Hann window an overlap of</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    50% is a reasonable trade off between accurately estimating the</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    signal power, while not over counting any of the data. Narrower</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    windows may require a larger overlap.</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    .. [1] P. Welch, &quot;The use of the fast Fourier transform for the</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">           estimation of power spectra: A method based on time averaging</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">           over short, modified periodograms&quot;, IEEE Trans. Audio</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">           Electroacoust. vol. 15, pp. 70-73, 1967.</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    .. [2] Rabiner, Lawrence R., and B. Gold. &quot;Theory and Application of</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">           Digital Signal Processing&quot; Prentice-Hall, pp. 414-419, 1975</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    Generate two test signals with some common features.</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    &gt;&gt;&gt; fs = 10e3</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    &gt;&gt;&gt; N = 1e5</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    &gt;&gt;&gt; amp = 20</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    &gt;&gt;&gt; freq = 1234.0</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    &gt;&gt;&gt; noise_power = 0.001 * fs / 2</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    &gt;&gt;&gt; time = np.arange(N) / fs</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    &gt;&gt;&gt; b, a = signal.butter(2, 0.25, &#39;low&#39;)</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape)</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    &gt;&gt;&gt; y = signal.lfilter(b, a, x)</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    &gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    &gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    Compute and plot the magnitude of the cross spectral density.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    &gt;&gt;&gt; f, Pxy = signal.csd(x, y, fs, nperseg=1024)</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f, np.abs(Pxy))</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;CSD [V**2/Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  580</span>    freqs, _, Pxy = _spectral_helper(x, y, fs, window, nperseg, noverlap, nfft,</div>
<div class="line"><span class="lineno">  581</span>                                     detrend, return_onesided, scaling, axis,</div>
<div class="line"><span class="lineno">  582</span>                                     mode=<span class="stringliteral">&#39;psd&#39;</span>)</div>
<div class="line"><span class="lineno">  583</span> </div>
<div class="line"><span class="lineno">  584</span>    <span class="comment"># Average over windows.</span></div>
<div class="line"><span class="lineno">  585</span>    <span class="keywordflow">if</span> len(Pxy.shape) &gt;= 2 <span class="keywordflow">and</span> Pxy.size &gt; 0:</div>
<div class="line"><span class="lineno">  586</span>        <span class="keywordflow">if</span> Pxy.shape[-1] &gt; 1:</div>
<div class="line"><span class="lineno">  587</span>            <span class="keywordflow">if</span> average == <span class="stringliteral">&#39;median&#39;</span>:</div>
<div class="line"><span class="lineno">  588</span>                <span class="comment"># np.median must be passed real arrays for the desired result</span></div>
<div class="line"><span class="lineno">  589</span>                bias = _median_bias(Pxy.shape[-1])</div>
<div class="line"><span class="lineno">  590</span>                <span class="keywordflow">if</span> np.iscomplexobj(Pxy):</div>
<div class="line"><span class="lineno">  591</span>                    Pxy = (np.median(np.real(Pxy), axis=-1)</div>
<div class="line"><span class="lineno">  592</span>                           + 1j * np.median(np.imag(Pxy), axis=-1))</div>
<div class="line"><span class="lineno">  593</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  594</span>                    Pxy = np.median(Pxy, axis=-1)</div>
<div class="line"><span class="lineno">  595</span>                Pxy /= bias</div>
<div class="line"><span class="lineno">  596</span>            <span class="keywordflow">elif</span> average == <span class="stringliteral">&#39;mean&#39;</span>:</div>
<div class="line"><span class="lineno">  597</span>                Pxy = Pxy.mean(axis=-1)</div>
<div class="line"><span class="lineno">  598</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  599</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;average must be &quot;median&quot; or &quot;mean&quot;, got %s&#39;</span></div>
<div class="line"><span class="lineno">  600</span>                                 % (average,))</div>
<div class="line"><span class="lineno">  601</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  602</span>            Pxy = np.reshape(Pxy, Pxy.shape[:-1])</div>
<div class="line"><span class="lineno">  603</span> </div>
<div class="line"><span class="lineno">  604</span>    <span class="keywordflow">return</span> freqs, Pxy</div>
<div class="line"><span class="lineno">  605</span> </div>
<div class="line"><span class="lineno">  606</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a19b39dcdf416fb9d891d16cdeb8633f4" name="a19b39dcdf416fb9d891d16cdeb8633f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b39dcdf416fb9d891d16cdeb8633f4">&#9670;&#160;</a></span>istft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.istft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Zxx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hann'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_onesided</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>boundary</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time_axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>freq_axis</em> = <code>-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>'spectrum'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the inverse Short Time Fourier transform (iSTFT).

Parameters
----------
Zxx : array_like
STFT of the signal to be reconstructed. If a purely real array
is passed, it will be cast to a complex data type.
fs : float, optional
Sampling frequency of the time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window. Must match the window used to generate the
STFT for faithful inversion.
nperseg : int, optional
Number of data points corresponding to each STFT segment. This
parameter must be specified if the number of data points per
segment is odd, or if the STFT was padded via ``nfft &gt;
nperseg``. If `None`, the value depends on the shape of
`Zxx` and `input_onesided`. If `input_onesided` is `True`,
``nperseg=2*(Zxx.shape[freq_axis] - 1)``. Otherwise,
``nperseg=Zxx.shape[freq_axis]``. Defaults to `None`.
noverlap : int, optional
Number of points to overlap between segments. If `None`, half
of the segment length. Defaults to `None`. When specified, the
COLA constraint must be met (see Notes below), and should match
the parameter used to generate the STFT. Defaults to `None`.
nfft : int, optional
Number of FFT points corresponding to each STFT segment. This
parameter must be specified if the STFT was padded via ``nfft &gt;
nperseg``. If `None`, the default values are the same as for
`nperseg`, detailed above, with one exception: if
`input_onesided` is True and
``nperseg==2*Zxx.shape[freq_axis] - 1``, `nfft` also takes on
that value. This case allows the proper inversion of an
odd-length unpadded STFT using ``nfft=None``. Defaults to
`None`.
input_onesided : bool, optional
If `True`, interpret the input array as one-sided FFTs, such
as is returned by `stft` with ``return_onesided=True`` and
`numpy.fft.rfft`. If `False`, interpret the input as a a
two-sided FFT. Defaults to `True`.
boundary : bool, optional
Specifies whether the input signal was extended at its
boundaries by supplying a non-`None` ``boundary`` argument to
`stft`. Defaults to `True`.
time_axis : int, optional
Where the time segments of the STFT is located; the default is
the last axis (i.e. ``axis=-1``).
freq_axis : int, optional
Where the frequency axis of the STFT is located; the default is
the penultimate axis (i.e. ``axis=-2``).
scaling: {'spectrum', 'psd'}
The default 'spectrum' scaling allows each frequency line of `Zxx` to
be interpreted as a magnitude spectrum. The 'psd' option scales each
line to a power spectral density - it allows to calculate the signal's
energy by numerically integrating over ``abs(Zxx)**2``.

Returns
-------
t : ndarray
Array of output data times.
x : ndarray
iSTFT of `Zxx`.

See Also
--------
stft: Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
        is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met

Notes
-----
In order to enable inversion of an STFT via the inverse STFT with
`istft`, the signal windowing must obey the constraint of "nonzero
overlap add" (NOLA):

.. math:: \sum_{t}w^{2}[n-tH] \ne 0

This ensures that the normalization factors that appear in the denominator
of the overlap-add reconstruction equation

.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}

are not zero. The NOLA constraint can be checked with the `check_NOLA`
function.

An STFT which has been modified (via masking or otherwise) is not
guaranteed to correspond to a exactly realizible signal. This
function implements the iSTFT via the least-squares estimation
algorithm detailed in [2]_, which produces a signal that minimizes
the mean squared error between the STFT of the returned signal and
the modified STFT.

.. versionadded:: 0.19.0

References
----------
.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
   "Discrete-Time Signal Processing", Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim "Signal Estimation from
   Modified Short-Time Fourier Transform", IEEE 1984,
   10.1109/TASSP.1984.1164317

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by
0.001 V**2/Hz of white noise sampled at 1024 Hz.

&gt;&gt;&gt; fs = 1024
&gt;&gt;&gt; N = 10*fs
&gt;&gt;&gt; nperseg = 512
&gt;&gt;&gt; amp = 2 * np.sqrt(2)
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / float(fs)
&gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*50*time)
&gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power),
...                    size=time.shape)
&gt;&gt;&gt; x = carrier + noise

Compute the STFT, and plot its magnitude

&gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs=fs, nperseg=nperseg)
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud')
&gt;&gt;&gt; plt.ylim([f[1], f[-1]])
&gt;&gt;&gt; plt.title('STFT Magnitude')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.yscale('log')
&gt;&gt;&gt; plt.show()

Zero the components that are 10% or less of the carrier magnitude,
then convert back to a time series via inverse STFT

&gt;&gt;&gt; Zxx = np.where(np.abs(Zxx) &gt;= amp/10, Zxx, 0)
&gt;&gt;&gt; _, xrec = signal.istft(Zxx, fs)

Compare the cleaned signal with the original and true carrier signals.

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier)
&gt;&gt;&gt; plt.xlim([2, 2.1])
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.ylabel('Signal')
&gt;&gt;&gt; plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
&gt;&gt;&gt; plt.show()

Note that the cleaned signal does not start as abruptly as the original,
since some of the coefficients of the transient were also removed:

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier)
&gt;&gt;&gt; plt.xlim([0, 0.1])
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.ylabel('Signal')
&gt;&gt;&gt; plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1209</span>          scaling=<span class="stringliteral">&#39;spectrum&#39;</span>):</div>
<div class="line"><span class="lineno"> 1210</span>    <span class="stringliteral">r&quot;&quot;&quot;Perform the inverse Short Time Fourier transform (iSTFT).</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">    Zxx : array_like</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">        STFT of the signal to be reconstructed. If a purely real array</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">        is passed, it will be cast to a complex data type.</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">        Sampling frequency of the time series. Defaults to 1.0.</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">        directly as the window and its length must be nperseg. Defaults</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">        to a Hann window. Must match the window used to generate the</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">        STFT for faithful inversion.</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    nperseg : int, optional</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">        Number of data points corresponding to each STFT segment. This</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">        parameter must be specified if the number of data points per</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">        segment is odd, or if the STFT was padded via ``nfft &gt;</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">        nperseg``. If `None`, the value depends on the shape of</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">        `Zxx` and `input_onesided`. If `input_onesided` is `True`,</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">        ``nperseg=2*(Zxx.shape[freq_axis] - 1)``. Otherwise,</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">        ``nperseg=Zxx.shape[freq_axis]``. Defaults to `None`.</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    noverlap : int, optional</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">        Number of points to overlap between segments. If `None`, half</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">        of the segment length. Defaults to `None`. When specified, the</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">        COLA constraint must be met (see Notes below), and should match</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">        the parameter used to generate the STFT. Defaults to `None`.</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">        Number of FFT points corresponding to each STFT segment. This</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">        parameter must be specified if the STFT was padded via ``nfft &gt;</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">        nperseg``. If `None`, the default values are the same as for</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">        `nperseg`, detailed above, with one exception: if</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">        `input_onesided` is True and</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">        ``nperseg==2*Zxx.shape[freq_axis] - 1``, `nfft` also takes on</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">        that value. This case allows the proper inversion of an</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">        odd-length unpadded STFT using ``nfft=None``. Defaults to</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">        `None`.</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">    input_onesided : bool, optional</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">        If `True`, interpret the input array as one-sided FFTs, such</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">        as is returned by `stft` with ``return_onesided=True`` and</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">        `numpy.fft.rfft`. If `False`, interpret the input as a a</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">        two-sided FFT. Defaults to `True`.</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    boundary : bool, optional</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">        Specifies whether the input signal was extended at its</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">        boundaries by supplying a non-`None` ``boundary`` argument to</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">        `stft`. Defaults to `True`.</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    time_axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">        Where the time segments of the STFT is located; the default is</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">        the last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">    freq_axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">        Where the frequency axis of the STFT is located; the default is</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">        the penultimate axis (i.e. ``axis=-2``).</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">    scaling: {&#39;spectrum&#39;, &#39;psd&#39;}</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        The default &#39;spectrum&#39; scaling allows each frequency line of `Zxx` to</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        be interpreted as a magnitude spectrum. The &#39;psd&#39; option scales each</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        line to a power spectral density - it allows to calculate the signal&#39;s</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">        energy by numerically integrating over ``abs(Zxx)**2``.</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    t : ndarray</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">        Array of output data times.</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">        iSTFT of `Zxx`.</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    stft: Short Time Fourier Transform</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    check_COLA: Check whether the Constant OverLap Add (COLA) constraint</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">                is met</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">    check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    In order to enable inversion of an STFT via the inverse STFT with</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    `istft`, the signal windowing must obey the constraint of &quot;nonzero</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    overlap add&quot; (NOLA):</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    .. math:: \sum_{t}w^{2}[n-tH] \ne 0</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    This ensures that the normalization factors that appear in the denominator</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    of the overlap-add reconstruction equation</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    .. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    are not zero. The NOLA constraint can be checked with the `check_NOLA`</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    function.</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    An STFT which has been modified (via masking or otherwise) is not</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    guaranteed to correspond to a exactly realizible signal. This</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    function implements the iSTFT via the least-squares estimation</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">    algorithm detailed in [2]_, which produces a signal that minimizes</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    the mean squared error between the STFT of the returned signal and</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">    the modified STFT.</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">    .. versionadded:: 0.19.0</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral">    .. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck</span></div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">           &quot;Discrete-Time Signal Processing&quot;, Prentice Hall, 1999.</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">    .. [2] Daniel W. Griffin, Jae S. Lim &quot;Signal Estimation from</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">           Modified Short-Time Fourier Transform&quot;, IEEE 1984,</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">           10.1109/TASSP.1984.1164317</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    0.001 V**2/Hz of white noise sampled at 1024 Hz.</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    &gt;&gt;&gt; fs = 1024</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    &gt;&gt;&gt; N = 10*fs</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">    &gt;&gt;&gt; nperseg = 512</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    &gt;&gt;&gt; amp = 2 * np.sqrt(2)</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    &gt;&gt;&gt; noise_power = 0.001 * fs / 2</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    &gt;&gt;&gt; time = np.arange(N) / float(fs)</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    &gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*50*time)</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    &gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power),</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">    ...                    size=time.shape)</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    &gt;&gt;&gt; x = carrier + noise</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    Compute the STFT, and plot its magnitude</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    &gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs=fs, nperseg=nperseg)</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    &gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading=&#39;gouraud&#39;)</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylim([f[1], f[-1]])</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&#39;STFT Magnitude&#39;)</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [sec]&#39;)</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &gt;&gt;&gt; plt.yscale(&#39;log&#39;)</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    Zero the components that are 10% or less of the carrier magnitude,</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    then convert back to a time series via inverse STFT</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    &gt;&gt;&gt; Zxx = np.where(np.abs(Zxx) &gt;= amp/10, Zxx, 0)</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    &gt;&gt;&gt; _, xrec = signal.istft(Zxx, fs)</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    Compare the cleaned signal with the original and true carrier signals.</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier)</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlim([2, 2.1])</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [sec]&#39;)</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Signal&#39;)</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend([&#39;Carrier + Noise&#39;, &#39;Filtered via STFT&#39;, &#39;True Carrier&#39;])</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">    Note that the cleaned signal does not start as abruptly as the original,</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    since some of the coefficients of the transient were also removed:</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier)</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlim([0, 0.1])</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [sec]&#39;)</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Signal&#39;)</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend([&#39;Carrier + Noise&#39;, &#39;Filtered via STFT&#39;, &#39;True Carrier&#39;])</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1378</span>    <span class="comment"># Make sure input is an ndarray of appropriate complex dtype</span></div>
<div class="line"><span class="lineno"> 1379</span>    Zxx = np.asarray(Zxx) + 0j</div>
<div class="line"><span class="lineno"> 1380</span>    freq_axis = int(freq_axis)</div>
<div class="line"><span class="lineno"> 1381</span>    time_axis = int(time_axis)</div>
<div class="line"><span class="lineno"> 1382</span> </div>
<div class="line"><span class="lineno"> 1383</span>    <span class="keywordflow">if</span> Zxx.ndim &lt; 2:</div>
<div class="line"><span class="lineno"> 1384</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Input stft must be at least 2d!&#39;</span>)</div>
<div class="line"><span class="lineno"> 1385</span> </div>
<div class="line"><span class="lineno"> 1386</span>    <span class="keywordflow">if</span> freq_axis == time_axis:</div>
<div class="line"><span class="lineno"> 1387</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Must specify differing time and frequency axes!&#39;</span>)</div>
<div class="line"><span class="lineno"> 1388</span> </div>
<div class="line"><span class="lineno"> 1389</span>    nseg = Zxx.shape[time_axis]</div>
<div class="line"><span class="lineno"> 1390</span> </div>
<div class="line"><span class="lineno"> 1391</span>    <span class="keywordflow">if</span> input_onesided:</div>
<div class="line"><span class="lineno"> 1392</span>        <span class="comment"># Assume even segment length</span></div>
<div class="line"><span class="lineno"> 1393</span>        n_default = 2*(Zxx.shape[freq_axis] - 1)</div>
<div class="line"><span class="lineno"> 1394</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1395</span>        n_default = Zxx.shape[freq_axis]</div>
<div class="line"><span class="lineno"> 1396</span> </div>
<div class="line"><span class="lineno"> 1397</span>    <span class="comment"># Check windowing parameters</span></div>
<div class="line"><span class="lineno"> 1398</span>    <span class="keywordflow">if</span> nperseg <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1399</span>        nperseg = n_default</div>
<div class="line"><span class="lineno"> 1400</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1401</span>        nperseg = int(nperseg)</div>
<div class="line"><span class="lineno"> 1402</span>        <span class="keywordflow">if</span> nperseg &lt; 1:</div>
<div class="line"><span class="lineno"> 1403</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;nperseg must be a positive integer&#39;</span>)</div>
<div class="line"><span class="lineno"> 1404</span> </div>
<div class="line"><span class="lineno"> 1405</span>    <span class="keywordflow">if</span> nfft <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1406</span>        <span class="keywordflow">if</span> (input_onesided) <span class="keywordflow">and</span> (nperseg == n_default + 1):</div>
<div class="line"><span class="lineno"> 1407</span>            <span class="comment"># Odd nperseg, no FFT padding</span></div>
<div class="line"><span class="lineno"> 1408</span>            nfft = nperseg</div>
<div class="line"><span class="lineno"> 1409</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1410</span>            nfft = n_default</div>
<div class="line"><span class="lineno"> 1411</span>    <span class="keywordflow">elif</span> nfft &lt; nperseg:</div>
<div class="line"><span class="lineno"> 1412</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;nfft must be greater than or equal to nperseg.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1413</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1414</span>        nfft = int(nfft)</div>
<div class="line"><span class="lineno"> 1415</span> </div>
<div class="line"><span class="lineno"> 1416</span>    <span class="keywordflow">if</span> noverlap <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1417</span>        noverlap = nperseg//2</div>
<div class="line"><span class="lineno"> 1418</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1419</span>        noverlap = int(noverlap)</div>
<div class="line"><span class="lineno"> 1420</span>    <span class="keywordflow">if</span> noverlap &gt;= nperseg:</div>
<div class="line"><span class="lineno"> 1421</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;noverlap must be less than nperseg.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1422</span>    nstep = nperseg - noverlap</div>
<div class="line"><span class="lineno"> 1423</span> </div>
<div class="line"><span class="lineno"> 1424</span>    <span class="comment"># Rearrange axes if necessary</span></div>
<div class="line"><span class="lineno"> 1425</span>    <span class="keywordflow">if</span> time_axis != Zxx.ndim-1 <span class="keywordflow">or</span> freq_axis != Zxx.ndim-2:</div>
<div class="line"><span class="lineno"> 1426</span>        <span class="comment"># Turn negative indices to positive for the call to transpose</span></div>
<div class="line"><span class="lineno"> 1427</span>        <span class="keywordflow">if</span> freq_axis &lt; 0:</div>
<div class="line"><span class="lineno"> 1428</span>            freq_axis = Zxx.ndim + freq_axis</div>
<div class="line"><span class="lineno"> 1429</span>        <span class="keywordflow">if</span> time_axis &lt; 0:</div>
<div class="line"><span class="lineno"> 1430</span>            time_axis = Zxx.ndim + time_axis</div>
<div class="line"><span class="lineno"> 1431</span>        zouter = list(range(Zxx.ndim))</div>
<div class="line"><span class="lineno"> 1432</span>        <span class="keywordflow">for</span> ax <span class="keywordflow">in</span> sorted([time_axis, freq_axis], reverse=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 1433</span>            zouter.pop(ax)</div>
<div class="line"><span class="lineno"> 1434</span>        Zxx = np.transpose(Zxx, zouter+[freq_axis, time_axis])</div>
<div class="line"><span class="lineno"> 1435</span> </div>
<div class="line"><span class="lineno"> 1436</span>    <span class="comment"># Get window as array</span></div>
<div class="line"><span class="lineno"> 1437</span>    <span class="keywordflow">if</span> isinstance(window, str) <span class="keywordflow">or</span> type(window) <span class="keywordflow">is</span> tuple:</div>
<div class="line"><span class="lineno"> 1438</span>        win = get_window(window, nperseg)</div>
<div class="line"><span class="lineno"> 1439</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1440</span>        win = np.asarray(window)</div>
<div class="line"><span class="lineno"> 1441</span>        <span class="keywordflow">if</span> len(win.shape) != 1:</div>
<div class="line"><span class="lineno"> 1442</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must be 1-D&#39;</span>)</div>
<div class="line"><span class="lineno"> 1443</span>        <span class="keywordflow">if</span> win.shape[0] != nperseg:</div>
<div class="line"><span class="lineno"> 1444</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must have length of {0}&#39;</span>.format(nperseg))</div>
<div class="line"><span class="lineno"> 1445</span> </div>
<div class="line"><span class="lineno"> 1446</span>    ifunc = sp_fft.irfft <span class="keywordflow">if</span> input_onesided <span class="keywordflow">else</span> sp_fft.ifft</div>
<div class="line"><span class="lineno"> 1447</span>    xsubs = ifunc(Zxx, axis=-2, n=nfft)[..., :nperseg, :]</div>
<div class="line"><span class="lineno"> 1448</span> </div>
<div class="line"><span class="lineno"> 1449</span>    <span class="comment"># Initialize output and normalization arrays</span></div>
<div class="line"><span class="lineno"> 1450</span>    outputlength = nperseg + (nseg-1)*nstep</div>
<div class="line"><span class="lineno"> 1451</span>    x = np.zeros(list(Zxx.shape[:-2])+[outputlength], dtype=xsubs.dtype)</div>
<div class="line"><span class="lineno"> 1452</span>    norm = np.zeros(outputlength, dtype=xsubs.dtype)</div>
<div class="line"><span class="lineno"> 1453</span> </div>
<div class="line"><span class="lineno"> 1454</span>    <span class="keywordflow">if</span> np.result_type(win, xsubs) != xsubs.dtype:</div>
<div class="line"><span class="lineno"> 1455</span>        win = win.astype(xsubs.dtype)</div>
<div class="line"><span class="lineno"> 1456</span> </div>
<div class="line"><span class="lineno"> 1457</span>    <span class="keywordflow">if</span> scaling == <span class="stringliteral">&#39;spectrum&#39;</span>:</div>
<div class="line"><span class="lineno"> 1458</span>        xsubs *= win.sum()</div>
<div class="line"><span class="lineno"> 1459</span>    <span class="keywordflow">elif</span> scaling == <span class="stringliteral">&#39;psd&#39;</span>:</div>
<div class="line"><span class="lineno"> 1460</span>        xsubs *= np.sqrt(fs * sum(win**2))</div>
<div class="line"><span class="lineno"> 1461</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1462</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Parameter {scaling=} not in [&#39;spectrum&#39;, &#39;psd&#39;]!&quot;</span>)</div>
<div class="line"><span class="lineno"> 1463</span> </div>
<div class="line"><span class="lineno"> 1464</span>    <span class="comment"># Construct the output from the ifft segments</span></div>
<div class="line"><span class="lineno"> 1465</span>    <span class="comment"># This loop could perhaps be vectorized/strided somehow...</span></div>
<div class="line"><span class="lineno"> 1466</span>    <span class="keywordflow">for</span> ii <span class="keywordflow">in</span> range(nseg):</div>
<div class="line"><span class="lineno"> 1467</span>        <span class="comment"># Window the ifft</span></div>
<div class="line"><span class="lineno"> 1468</span>        x[..., ii*nstep:ii*nstep+nperseg] += xsubs[..., ii] * win</div>
<div class="line"><span class="lineno"> 1469</span>        norm[..., ii*nstep:ii*nstep+nperseg] += win**2</div>
<div class="line"><span class="lineno"> 1470</span> </div>
<div class="line"><span class="lineno"> 1471</span>    <span class="comment"># Remove extension points</span></div>
<div class="line"><span class="lineno"> 1472</span>    <span class="keywordflow">if</span> boundary:</div>
<div class="line"><span class="lineno"> 1473</span>        x = x[..., nperseg//2:-(nperseg//2)]</div>
<div class="line"><span class="lineno"> 1474</span>        norm = norm[..., nperseg//2:-(nperseg//2)]</div>
<div class="line"><span class="lineno"> 1475</span> </div>
<div class="line"><span class="lineno"> 1476</span>    <span class="comment"># Divide out normalization where non-tiny</span></div>
<div class="line"><span class="lineno"> 1477</span>    <span class="keywordflow">if</span> np.sum(norm &gt; 1e-10) != len(norm):</div>
<div class="line"><span class="lineno"> 1478</span>        warnings.warn(<span class="stringliteral">&quot;NOLA condition failed, STFT may not be invertible&quot;</span>)</div>
<div class="line"><span class="lineno"> 1479</span>    x /= np.where(norm &gt; 1e-10, norm, 1.0)</div>
<div class="line"><span class="lineno"> 1480</span> </div>
<div class="line"><span class="lineno"> 1481</span>    <span class="keywordflow">if</span> input_onesided:</div>
<div class="line"><span class="lineno"> 1482</span>        x = x.real</div>
<div class="line"><span class="lineno"> 1483</span> </div>
<div class="line"><span class="lineno"> 1484</span>    <span class="comment"># Put axes back</span></div>
<div class="line"><span class="lineno"> 1485</span>    <span class="keywordflow">if</span> x.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 1486</span>        <span class="keywordflow">if</span> time_axis != Zxx.ndim-1:</div>
<div class="line"><span class="lineno"> 1487</span>            <span class="keywordflow">if</span> freq_axis &lt; time_axis:</div>
<div class="line"><span class="lineno"> 1488</span>                time_axis -= 1</div>
<div class="line"><span class="lineno"> 1489</span>            x = np.moveaxis(x, -1, time_axis)</div>
<div class="line"><span class="lineno"> 1490</span> </div>
<div class="line"><span class="lineno"> 1491</span>    time = np.arange(x.shape[0])/float(fs)</div>
<div class="line"><span class="lineno"> 1492</span>    <span class="keywordflow">return</span> time, x</div>
<div class="line"><span class="lineno"> 1493</span> </div>
<div class="line"><span class="lineno"> 1494</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a04de21aa2a099fd07b3a8079f68af846" name="a04de21aa2a099fd07b3a8079f68af846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04de21aa2a099fd07b3a8079f68af846">&#9670;&#160;</a></span>lombscargle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.lombscargle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>freqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>precenter</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">lombscargle(x, y, freqs)

Computes the Lomb-Scargle periodogram.

The Lomb-Scargle periodogram was developed by Lomb [1]_ and further
extended by Scargle [2]_ to find, and test the significance of weak
periodic signals with uneven temporal sampling.

When *normalize* is False (default) the computed periodogram
is unnormalized, it takes the value ``(A**2) * N/4`` for a harmonic
signal with amplitude A for sufficiently large N.

When *normalize* is True the computed periodogram is normalized by
the residuals of the data around a constant reference model (at zero).

Input arrays should be 1-D and will be cast to float64.

Parameters
----------
x : array_like
    Sample times.
y : array_like
    Measurement values.
freqs : array_like
    Angular frequencies for output periodogram.
precenter : bool, optional
    Pre-center measurement values by subtracting the mean.
normalize : bool, optional
    Compute normalized periodogram.

Returns
-------
pgram : array_like
    Lomb-Scargle periodogram.

Raises
------
ValueError
    If the input arrays `x` and `y` do not have the same shape.

Notes
-----
This subroutine calculates the periodogram using a slightly
modified algorithm due to Townsend [3]_ which allows the
periodogram to be calculated using only a single pass through
the input arrays for each frequency.

The algorithm running time scales roughly as O(x * freqs) or O(N^2)
for a large number of samples and frequencies.

References
----------
.. [1] N.R. Lomb "Least-squares frequency analysis of unequally spaced
       data", Astrophysics and Space Science, vol 39, pp. 447-462, 1976

.. [2] J.D. Scargle "Studies in astronomical time series analysis. II -
       Statistical aspects of spectral analysis of unevenly spaced data",
       The Astrophysical Journal, vol 263, pp. 835-853, 1982

.. [3] R.H.D. Townsend, "Fast calculation of the Lomb-Scargle
       periodogram using graphics processing units.", The Astrophysical
       Journal Supplement Series, vol 191, pp. 247-253, 2010

See Also
--------
istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
welch: Power spectral density by Welch's method
spectrogram: Spectrogram by Welch's method
csd: Cross spectral density by Welch's method

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

First define some input parameters for the signal:

&gt;&gt;&gt; A = 2.
&gt;&gt;&gt; w0 = 1.  # rad/sec
&gt;&gt;&gt; nin = 150
&gt;&gt;&gt; nout = 100000

Randomly generate sample times:

&gt;&gt;&gt; x = rng.uniform(0, 10*np.pi, nin)

Plot a sine wave for the selected times:

&gt;&gt;&gt; y = A * np.cos(w0*x)

Define the array of frequencies for which to compute the periodogram:

&gt;&gt;&gt; w = np.linspace(0.01, 10, nout)

Calculate Lomb-Scargle periodogram:

&gt;&gt;&gt; import scipy.signal as signal
&gt;&gt;&gt; pgram = signal.lombscargle(x, y, w, normalize=True)

Now make a plot of the input data:

&gt;&gt;&gt; fig, (ax_t, ax_w) = plt.subplots(2, 1, constrained_layout=True)
&gt;&gt;&gt; ax_t.plot(x, y, 'b+')
&gt;&gt;&gt; ax_t.set_xlabel('Time [s]')

Then plot the normalized periodogram:

&gt;&gt;&gt; ax_w.plot(w, pgram)
&gt;&gt;&gt; ax_w.set_xlabel('Angular frequency [rad/s]')
&gt;&gt;&gt; ax_w.set_ylabel('Normalized amplitude')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">   21</span>                normalize=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">   22</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    lombscargle(x, y, freqs)</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">    Computes the Lomb-Scargle periodogram.</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    The Lomb-Scargle periodogram was developed by Lomb [1]_ and further</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    extended by Scargle [2]_ to find, and test the significance of weak</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">    periodic signals with uneven temporal sampling.</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">    When *normalize* is False (default) the computed periodogram</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    is unnormalized, it takes the value ``(A**2) * N/4`` for a harmonic</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    signal with amplitude A for sufficiently large N.</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    When *normalize* is True the computed periodogram is normalized by</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    the residuals of the data around a constant reference model (at zero).</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    Input arrays should be 1-D and will be cast to float64.</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        Sample times.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        Measurement values.</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    freqs : array_like</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">        Angular frequencies for output periodogram.</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    precenter : bool, optional</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        Pre-center measurement values by subtracting the mean.</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    normalize : bool, optional</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        Compute normalized periodogram.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    pgram : array_like</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">        Lomb-Scargle periodogram.</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        If the input arrays `x` and `y` do not have the same shape.</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    This subroutine calculates the periodogram using a slightly</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    modified algorithm due to Townsend [3]_ which allows the</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    periodogram to be calculated using only a single pass through</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    the input arrays for each frequency.</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    The algorithm running time scales roughly as O(x * freqs) or O(N^2)</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    for a large number of samples and frequencies.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    .. [1] N.R. Lomb &quot;Least-squares frequency analysis of unequally spaced</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">           data&quot;, Astrophysics and Space Science, vol 39, pp. 447-462, 1976</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    .. [2] J.D. Scargle &quot;Studies in astronomical time series analysis. II -</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">           Statistical aspects of spectral analysis of unevenly spaced data&quot;,</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">           The Astrophysical Journal, vol 263, pp. 835-853, 1982</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    .. [3] R.H.D. Townsend, &quot;Fast calculation of the Lomb-Scargle</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">           periodogram using graphics processing units.&quot;, The Astrophysical</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">           Journal Supplement Series, vol 191, pp. 247-253, 2010</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    istft: Inverse Short Time Fourier Transform</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    welch: Power spectral density by Welch&#39;s method</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    spectrogram: Spectrogram by Welch&#39;s method</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    csd: Cross spectral density by Welch&#39;s method</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    First define some input parameters for the signal:</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    &gt;&gt;&gt; A = 2.</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    &gt;&gt;&gt; w0 = 1.  # rad/sec</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    &gt;&gt;&gt; nin = 150</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    &gt;&gt;&gt; nout = 100000</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    Randomly generate sample times:</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.uniform(0, 10*np.pi, nin)</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    Plot a sine wave for the selected times:</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    &gt;&gt;&gt; y = A * np.cos(w0*x)</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    Define the array of frequencies for which to compute the periodogram:</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    &gt;&gt;&gt; w = np.linspace(0.01, 10, nout)</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    Calculate Lomb-Scargle periodogram:</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; import scipy.signal as signal</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    &gt;&gt;&gt; pgram = signal.lombscargle(x, y, w, normalize=True)</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    Now make a plot of the input data:</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_t, ax_w) = plt.subplots(2, 1, constrained_layout=True)</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    &gt;&gt;&gt; ax_t.plot(x, y, &#39;b+&#39;)</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &gt;&gt;&gt; ax_t.set_xlabel(&#39;Time [s]&#39;)</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    Then plot the normalized periodogram:</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    &gt;&gt;&gt; ax_w.plot(w, pgram)</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    &gt;&gt;&gt; ax_w.set_xlabel(&#39;Angular frequency [rad/s]&#39;)</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    &gt;&gt;&gt; ax_w.set_ylabel(&#39;Normalized amplitude&#39;)</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  137</span>    x = np.ascontiguousarray(x, dtype=np.float64)</div>
<div class="line"><span class="lineno">  138</span>    y = np.ascontiguousarray(y, dtype=np.float64)</div>
<div class="line"><span class="lineno">  139</span>    freqs = np.ascontiguousarray(freqs, dtype=np.float64)</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>    <span class="keyword">assert</span> x.ndim == 1</div>
<div class="line"><span class="lineno">  142</span>    <span class="keyword">assert</span> y.ndim == 1</div>
<div class="line"><span class="lineno">  143</span>    <span class="keyword">assert</span> freqs.ndim == 1</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">if</span> precenter:</div>
<div class="line"><span class="lineno">  146</span>        pgram = _lombscargle(x, y - y.mean(), freqs)</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  148</span>        pgram = _lombscargle(x, y, freqs)</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span>    <span class="keywordflow">if</span> normalize:</div>
<div class="line"><span class="lineno">  151</span>        pgram *= 2 / np.dot(y, y)</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    <span class="keywordflow">return</span> pgram</div>
<div class="line"><span class="lineno">  154</span> </div>
<div class="line"><span class="lineno">  155</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ef921c6ed4361b59839b02dad2f958e" name="a1ef921c6ed4361b59839b02dad2f958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef921c6ed4361b59839b02dad2f958e">&#9670;&#160;</a></span>periodogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.periodogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'boxcar'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_onesided</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>'density'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate power spectral density using a periodogram.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg. Defaults
    to 'boxcar'.
nfft : int, optional
    Length of the FFT used. If `None` the length of `x` will be
    used.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Pxx` has units of V**2/Hz and computing the power
    spectrum ('spectrum') where `Pxx` has units of V**2, if `x`
    is measured in V and `fs` is measured in Hz. Defaults to
    'density'
axis : int, optional
    Axis along which the periodogram is computed; the default is
    over the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Pxx : ndarray
    Power spectral density or power spectrum of `x`.

Notes
-----
.. versionadded:: 0.12.0

See Also
--------
welch: Estimate power spectral density using Welch's method
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2*np.sqrt(2)
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape)

Compute and plot the power spectral density.

&gt;&gt;&gt; f, Pxx_den = signal.periodogram(x, fs)
&gt;&gt;&gt; plt.semilogy(f, Pxx_den)
&gt;&gt;&gt; plt.ylim([1e-7, 1e2])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()

If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.

&gt;&gt;&gt; np.mean(Pxx_den[25000:])
0.000985320699252543

Now compute and plot the power spectrum.

&gt;&gt;&gt; f, Pxx_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum')
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))
&gt;&gt;&gt; plt.ylim([1e-4, 1e1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]')
&gt;&gt;&gt; plt.show()

The peak height in the power spectrum is an estimate of the RMS
amplitude.

&gt;&gt;&gt; np.sqrt(Pxx_spec.max())
2.0077340678640727</pre> <div class="fragment"><div class="line"><span class="lineno">  157</span>                return_onesided=<span class="keyword">True</span>, scaling=<span class="stringliteral">&#39;density&#39;</span>, axis=-1):</div>
<div class="line"><span class="lineno">  158</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    Estimate power spectral density using a periodogram.</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">        Sampling frequency of the `x` time series. Defaults to 1.0.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        directly as the window and its length must be nperseg. Defaults</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        to &#39;boxcar&#39;.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        Length of the FFT used. If `None` the length of `x` will be</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        used.</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    detrend : str or function or `False`, optional</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">        Specifies how to detrend each segment. If `detrend` is a</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">        string, it is passed as the `type` argument to the `detrend`</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        function. If it is a function, it takes a segment and returns a</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        detrended segment. If `detrend` is `False`, no detrending is</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        done. Defaults to &#39;constant&#39;.</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    return_onesided : bool, optional</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        If `True`, return a one-sided spectrum for real data. If</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        `False` return a two-sided spectrum. Defaults to `True`, but for</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        complex data, a two-sided spectrum is always returned.</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    scaling : { &#39;density&#39;, &#39;spectrum&#39; }, optional</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        Selects between computing the power spectral density (&#39;density&#39;)</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">        where `Pxx` has units of V**2/Hz and computing the power</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">        spectrum (&#39;spectrum&#39;) where `Pxx` has units of V**2, if `x`</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">        is measured in V and `fs` is measured in Hz. Defaults to</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        &#39;density&#39;</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">        Axis along which the periodogram is computed; the default is</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        over the last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    f : ndarray</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        Array of sample frequencies.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    Pxx : ndarray</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        Power spectral density or power spectrum of `x`.</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    .. versionadded:: 0.12.0</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    welch: Estimate power spectral density using Welch&#39;s method</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    lombscargle: Lomb-Scargle periodogram for unevenly sampled data</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    0.001 V**2/Hz of white noise sampled at 10 kHz.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &gt;&gt;&gt; fs = 10e3</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    &gt;&gt;&gt; N = 1e5</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    &gt;&gt;&gt; amp = 2*np.sqrt(2)</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    &gt;&gt;&gt; freq = 1234.0</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    &gt;&gt;&gt; noise_power = 0.001 * fs / 2</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    &gt;&gt;&gt; time = np.arange(N) / fs</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    &gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape)</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Compute and plot the power spectral density.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    &gt;&gt;&gt; f, Pxx_den = signal.periodogram(x, fs)</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f, Pxx_den)</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylim([1e-7, 1e2])</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;PSD [V**2/Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    If we average the last half of the spectral density, to exclude the</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    peak, we can recover the noise power on the signal.</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(Pxx_den[25000:])</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    0.000985320699252543</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    Now compute and plot the power spectrum.</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    &gt;&gt;&gt; f, Pxx_spec = signal.periodogram(x, fs, &#39;flattop&#39;, scaling=&#39;spectrum&#39;)</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylim([1e-4, 1e1])</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Linear spectrum [V RMS]&#39;)</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    The peak height in the power spectrum is an estimate of the RMS</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    amplitude.</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    &gt;&gt;&gt; np.sqrt(Pxx_spec.max())</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    2.0077340678640727</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  263</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno">  264</span> </div>
<div class="line"><span class="lineno">  265</span>    <span class="keywordflow">if</span> x.size == 0:</div>
<div class="line"><span class="lineno">  266</span>        <span class="keywordflow">return</span> np.empty(x.shape), np.empty(x.shape)</div>
<div class="line"><span class="lineno">  267</span> </div>
<div class="line"><span class="lineno">  268</span>    <span class="keywordflow">if</span> window <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  269</span>        window = <span class="stringliteral">&#39;boxcar&#39;</span></div>
<div class="line"><span class="lineno">  270</span> </div>
<div class="line"><span class="lineno">  271</span>    <span class="keywordflow">if</span> nfft <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  272</span>        nperseg = x.shape[axis]</div>
<div class="line"><span class="lineno">  273</span>    <span class="keywordflow">elif</span> nfft == x.shape[axis]:</div>
<div class="line"><span class="lineno">  274</span>        nperseg = nfft</div>
<div class="line"><span class="lineno">  275</span>    <span class="keywordflow">elif</span> nfft &gt; x.shape[axis]:</div>
<div class="line"><span class="lineno">  276</span>        nperseg = x.shape[axis]</div>
<div class="line"><span class="lineno">  277</span>    <span class="keywordflow">elif</span> nfft &lt; x.shape[axis]:</div>
<div class="line"><span class="lineno">  278</span>        s = [np.s_[:]]*len(x.shape)</div>
<div class="line"><span class="lineno">  279</span>        s[axis] = np.s_[:nfft]</div>
<div class="line"><span class="lineno">  280</span>        x = x[tuple(s)]</div>
<div class="line"><span class="lineno">  281</span>        nperseg = nfft</div>
<div class="line"><span class="lineno">  282</span>        nfft = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">return</span> welch(x, fs=fs, window=window, nperseg=nperseg, noverlap=0,</div>
<div class="line"><span class="lineno">  285</span>                 nfft=nfft, detrend=detrend, return_onesided=return_onesided,</div>
<div class="line"><span class="lineno">  286</span>                 scaling=scaling, axis=axis)</div>
<div class="line"><span class="lineno">  287</span> </div>
<div class="line"><span class="lineno">  288</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4aca9fb32af690767509d2a98b0d211f" name="a4aca9fb32af690767509d2a98b0d211f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aca9fb32af690767509d2a98b0d211f">&#9670;&#160;</a></span>spectrogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.spectrogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>('tukey',&#160;.25)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_onesided</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>'density'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'psd'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a spectrogram with consecutive Fourier transforms.

Spectrograms can be used as a way of visualizing the change of a
nonstationary signal's frequency content over time.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg.
    Defaults to a Tukey window with shape parameter of 0.25.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap : int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 8``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Sxx` has units of V**2/Hz and computing the power
    spectrum ('spectrum') where `Sxx` has units of V**2, if `x`
    is measured in V and `fs` is measured in Hz. Defaults to
    'density'.
axis : int, optional
    Axis along which the spectrogram is computed; the default is over
    the last axis (i.e. ``axis=-1``).
mode : str, optional
    Defines what kind of return values are expected. Options are
    ['psd', 'complex', 'magnitude', 'angle', 'phase']. 'complex' is
    equivalent to the output of `stft` with no padding or boundary
    extension. 'magnitude' returns the absolute magnitude of the
    STFT. 'angle' and 'phase' return the complex angle of the STFT,
    with and without unwrapping, respectively.

Returns
-------
f : ndarray
    Array of sample frequencies.
t : ndarray
    Array of segment times.
Sxx : ndarray
    Spectrogram of x. By default, the last axis of Sxx corresponds
    to the segment times.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements. In contrast to welch's method, where the
entire data stream is averaged over, one may wish to use a smaller
overlap (or perhaps none at all) when computing a spectrogram, to
maintain some statistical independence between individual segments.
It is for this reason that the default window is a Tukey window with
1/8th of a window's length overlap at each end.

.. versionadded:: 0.16.0

References
----------
.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
       "Discrete-Time Signal Processing", Prentice Hall, 1999.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fft import fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2 * np.sqrt(2)
&gt;&gt;&gt; noise_power = 0.01 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / float(fs)
&gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time)
&gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod)
&gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; noise *= np.exp(-time/5)
&gt;&gt;&gt; x = carrier + noise

Compute and plot the spectrogram.

&gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs)
&gt;&gt;&gt; plt.pcolormesh(t, f, Sxx, shading='gouraud')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.show()

Note, if using output that is not one sided, then use the following:

&gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs, return_onesided=False)
&gt;&gt;&gt; plt.pcolormesh(t, fftshift(f), fftshift(Sxx, axes=0), shading='gouraud')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  609</span>                scaling=<span class="stringliteral">&#39;density&#39;</span>, axis=-1, mode=<span class="stringliteral">&#39;psd&#39;</span>):</div>
<div class="line"><span class="lineno">  610</span>    <span class="stringliteral">&quot;&quot;&quot;Compute a spectrogram with consecutive Fourier transforms.</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    Spectrograms can be used as a way of visualizing the change of a</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    nonstationary signal&#39;s frequency content over time.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">        Sampling frequency of the `x` time series. Defaults to 1.0.</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">        directly as the window and its length must be nperseg.</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">        Defaults to a Tukey window with shape parameter of 0.25.</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    nperseg : int, optional</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">        Length of each segment. Defaults to None, but if window is str or</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        tuple, is set to 256, and if window is array_like, is set to the</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        length of the window.</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    noverlap : int, optional</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">        Number of points to overlap between segments. If `None`,</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">        ``noverlap = nperseg // 8``. Defaults to `None`.</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">        Length of the FFT used, if a zero padded FFT is desired. If</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        `None`, the FFT length is `nperseg`. Defaults to `None`.</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    detrend : str or function or `False`, optional</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">        Specifies how to detrend each segment. If `detrend` is a</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">        string, it is passed as the `type` argument to the `detrend`</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">        function. If it is a function, it takes a segment and returns a</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        detrended segment. If `detrend` is `False`, no detrending is</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">        done. Defaults to &#39;constant&#39;.</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    return_onesided : bool, optional</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        If `True`, return a one-sided spectrum for real data. If</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">        `False` return a two-sided spectrum. Defaults to `True`, but for</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        complex data, a two-sided spectrum is always returned.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    scaling : { &#39;density&#39;, &#39;spectrum&#39; }, optional</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        Selects between computing the power spectral density (&#39;density&#39;)</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">        where `Sxx` has units of V**2/Hz and computing the power</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">        spectrum (&#39;spectrum&#39;) where `Sxx` has units of V**2, if `x`</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        is measured in V and `fs` is measured in Hz. Defaults to</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        &#39;density&#39;.</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        Axis along which the spectrogram is computed; the default is over</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        the last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    mode : str, optional</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        Defines what kind of return values are expected. Options are</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        [&#39;psd&#39;, &#39;complex&#39;, &#39;magnitude&#39;, &#39;angle&#39;, &#39;phase&#39;]. &#39;complex&#39; is</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        equivalent to the output of `stft` with no padding or boundary</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">        extension. &#39;magnitude&#39; returns the absolute magnitude of the</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        STFT. &#39;angle&#39; and &#39;phase&#39; return the complex angle of the STFT,</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">        with and without unwrapping, respectively.</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    f : ndarray</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">        Array of sample frequencies.</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    t : ndarray</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        Array of segment times.</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    Sxx : ndarray</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        Spectrogram of x. By default, the last axis of Sxx corresponds</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">        to the segment times.</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    periodogram: Simple, optionally modified periodogram</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    lombscargle: Lomb-Scargle periodogram for unevenly sampled data</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    welch: Power spectral density by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    csd: Cross spectral density by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    An appropriate amount of overlap will depend on the choice of window</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    and on your requirements. In contrast to welch&#39;s method, where the</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    entire data stream is averaged over, one may wish to use a smaller</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    overlap (or perhaps none at all) when computing a spectrogram, to</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    maintain some statistical independence between individual segments.</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    It is for this reason that the default window is a Tukey window with</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    1/8th of a window&#39;s length overlap at each end.</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    .. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">           &quot;Discrete-Time Signal Processing&quot;, Prentice Hall, 1999.</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.fft import fftshift</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    Generate a test signal, a 2 Vrms sine wave whose frequency is slowly</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    modulated around 3kHz, corrupted by white noise of exponentially</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    decreasing magnitude sampled at 10 kHz.</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    &gt;&gt;&gt; fs = 10e3</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    &gt;&gt;&gt; N = 1e5</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    &gt;&gt;&gt; amp = 2 * np.sqrt(2)</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    &gt;&gt;&gt; noise_power = 0.01 * fs / 2</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    &gt;&gt;&gt; time = np.arange(N) / float(fs)</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    &gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time)</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    &gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod)</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    &gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power), size=time.shape)</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    &gt;&gt;&gt; noise *= np.exp(-time/5)</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    &gt;&gt;&gt; x = carrier + noise</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    Compute and plot the spectrogram.</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    &gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs)</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    &gt;&gt;&gt; plt.pcolormesh(t, f, Sxx, shading=&#39;gouraud&#39;)</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [sec]&#39;)</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    Note, if using output that is not one sided, then use the following:</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    &gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs, return_onesided=False)</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    &gt;&gt;&gt; plt.pcolormesh(t, fftshift(f), fftshift(Sxx, axes=0), shading=&#39;gouraud&#39;)</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [sec]&#39;)</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  738</span>    modelist = [<span class="stringliteral">&#39;psd&#39;</span>, <span class="stringliteral">&#39;complex&#39;</span>, <span class="stringliteral">&#39;magnitude&#39;</span>, <span class="stringliteral">&#39;angle&#39;</span>, <span class="stringliteral">&#39;phase&#39;</span>]</div>
<div class="line"><span class="lineno">  739</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">not</span> <span class="keywordflow">in</span> modelist:</div>
<div class="line"><span class="lineno">  740</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;unknown value for mode {}, must be one of {}&#39;</span></div>
<div class="line"><span class="lineno">  741</span>                         .format(mode, modelist))</div>
<div class="line"><span class="lineno">  742</span> </div>
<div class="line"><span class="lineno">  743</span>    <span class="comment"># need to set default for nperseg before setting default for noverlap below</span></div>
<div class="line"><span class="lineno">  744</span>    window, nperseg = _triage_segments(window, nperseg,</div>
<div class="line"><span class="lineno">  745</span>                                       input_length=x.shape[axis])</div>
<div class="line"><span class="lineno">  746</span> </div>
<div class="line"><span class="lineno">  747</span>    <span class="comment"># Less overlap than welch, so samples are more statisically independent</span></div>
<div class="line"><span class="lineno">  748</span>    <span class="keywordflow">if</span> noverlap <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  749</span>        noverlap = nperseg // 8</div>
<div class="line"><span class="lineno">  750</span> </div>
<div class="line"><span class="lineno">  751</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;psd&#39;</span>:</div>
<div class="line"><span class="lineno">  752</span>        freqs, time, Sxx = _spectral_helper(x, x, fs, window, nperseg,</div>
<div class="line"><span class="lineno">  753</span>                                            noverlap, nfft, detrend,</div>
<div class="line"><span class="lineno">  754</span>                                            return_onesided, scaling, axis,</div>
<div class="line"><span class="lineno">  755</span>                                            mode=<span class="stringliteral">&#39;psd&#39;</span>)</div>
<div class="line"><span class="lineno">  756</span> </div>
<div class="line"><span class="lineno">  757</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  758</span>        freqs, time, Sxx = _spectral_helper(x, x, fs, window, nperseg,</div>
<div class="line"><span class="lineno">  759</span>                                            noverlap, nfft, detrend,</div>
<div class="line"><span class="lineno">  760</span>                                            return_onesided, scaling, axis,</div>
<div class="line"><span class="lineno">  761</span>                                            mode=<span class="stringliteral">&#39;stft&#39;</span>)</div>
<div class="line"><span class="lineno">  762</span> </div>
<div class="line"><span class="lineno">  763</span>        <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;magnitude&#39;</span>:</div>
<div class="line"><span class="lineno">  764</span>            Sxx = np.abs(Sxx)</div>
<div class="line"><span class="lineno">  765</span>        <span class="keywordflow">elif</span> mode <span class="keywordflow">in</span> [<span class="stringliteral">&#39;angle&#39;</span>, <span class="stringliteral">&#39;phase&#39;</span>]:</div>
<div class="line"><span class="lineno">  766</span>            Sxx = np.angle(Sxx)</div>
<div class="line"><span class="lineno">  767</span>            <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;phase&#39;</span>:</div>
<div class="line"><span class="lineno">  768</span>                <span class="comment"># Sxx has one additional dimension for time strides</span></div>
<div class="line"><span class="lineno">  769</span>                <span class="keywordflow">if</span> axis &lt; 0:</div>
<div class="line"><span class="lineno">  770</span>                    axis -= 1</div>
<div class="line"><span class="lineno">  771</span>                Sxx = np.unwrap(Sxx, axis=axis)</div>
<div class="line"><span class="lineno">  772</span> </div>
<div class="line"><span class="lineno">  773</span>        <span class="comment"># mode ==&#39;complex&#39; is same as `stft`, doesn&#39;t need modification</span></div>
<div class="line"><span class="lineno">  774</span> </div>
<div class="line"><span class="lineno">  775</span>    <span class="keywordflow">return</span> freqs, time, Sxx</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0eee5a94f5128e159f80bbf7be61d2f" name="ad0eee5a94f5128e159f80bbf7be61d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0eee5a94f5128e159f80bbf7be61d2f">&#9670;&#160;</a></span>stft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.stft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hann'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_onesided</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>boundary</em> = <code>'zeros'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>'spectrum'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Short Time Fourier Transform (STFT).

STFTs can be used as a way of quantifying the change of a
nonstationary signal's frequency and phase content over time.

Parameters
----------
x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to 256.
noverlap : int, optional
Number of points to overlap between segments. If `None`,
``noverlap = nperseg // 2``. Defaults to `None`. When
specified, the COLA constraint must be met (see Notes below).
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
`None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
Specifies how to detrend each segment. If `detrend` is a
string, it is passed as the `type` argument to the `detrend`
function. If it is a function, it takes a segment and returns a
detrended segment. If `detrend` is `False`, no detrending is
done. Defaults to `False`.
return_onesided : bool, optional
If `True`, return a one-sided spectrum for real data. If
`False` return a two-sided spectrum. Defaults to `True`, but for
complex data, a two-sided spectrum is always returned.
boundary : str or None, optional
Specifies whether the input signal is extended at both ends, and
how to generate the new values, in order to center the first
windowed segment on the first input point. This has the benefit
of enabling reconstruction of the first input point when the
employed window function starts at zero. Valid options are
``['even', 'odd', 'constant', 'zeros', None]``. Defaults to
'zeros', for zero padding extension. I.e. ``[1, 2, 3, 4]`` is
extended to ``[0, 1, 2, 3, 4, 0]`` for ``nperseg=3``.
padded : bool, optional
Specifies whether the input signal is zero-padded at the end to
make the signal fit exactly into an integer number of window
segments, so that all of the signal is included in the output.
Defaults to `True`. Padding occurs after boundary extension, if
`boundary` is not `None`, and `padded` is `True`, as is the
default.
axis : int, optional
Axis along which the STFT is computed; the default is over the
last axis (i.e. ``axis=-1``).
scaling: {'spectrum', 'psd'}
The default 'spectrum' scaling allows each frequency line of `Zxx` to
be interpreted as a magnitude spectrum. The 'psd' option scales each
line to a power spectral density - it allows to calculate the signal's
energy by numerically integrating over ``abs(Zxx)**2``.

.. versionadded:: 1.9.0

Returns
-------
f : ndarray
Array of sample frequencies.
t : ndarray
Array of segment times.
Zxx : ndarray
STFT of `x`. By default, the last axis of `Zxx` corresponds
to the segment times.

See Also
--------
istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
        is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
welch: Power spectral density by Welch's method.
spectrogram: Spectrogram by Welch's method.
csd: Cross spectral density by Welch's method.
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Notes
-----
In order to enable inversion of an STFT via the inverse STFT in
`istft`, the signal windowing must obey the constraint of "Nonzero
OverLap Add" (NOLA), and the input signal must have complete
windowing coverage (i.e. ``(x.shape[axis] - nperseg) %
(nperseg-noverlap) == 0``). The `padded` argument may be used to
accomplish this.

Given a time-domain signal :math:`x[n]`, a window :math:`w[n]`, and a hop
size :math:`H` = `nperseg - noverlap`, the windowed frame at time index
:math:`t` is given by

.. math:: x_{t}[n]=x[n]w[n-tH]

The overlap-add (OLA) reconstruction equation is given by

.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}

The NOLA constraint ensures that every normalization term that appears
in the denomimator of the OLA reconstruction equation is nonzero. Whether a
choice of `window`, `nperseg`, and `noverlap` satisfy this constraint can
be tested with `check_NOLA`.

.. versionadded:: 0.19.0

References
----------
.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
   "Discrete-Time Signal Processing", Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim "Signal Estimation from
   Modified Short-Time Fourier Transform", IEEE 1984,
   10.1109/TASSP.1984.1164317

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2 * np.sqrt(2)
&gt;&gt;&gt; noise_power = 0.01 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / float(fs)
&gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time)
&gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod)
&gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power),
...                    size=time.shape)
&gt;&gt;&gt; noise *= np.exp(-time/5)
&gt;&gt;&gt; x = carrier + noise

Compute and plot the STFT's magnitude.

&gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000)
&gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud')
&gt;&gt;&gt; plt.title('STFT Magnitude')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.show()

Compare the energy of the signal `x` with the energy of its STFT:

&gt;&gt;&gt; E_x = sum(x**2) / fs  # Energy of x
&gt;&gt;&gt; # Calculate a two-sided STFT with PSD scaling:
&gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000, return_onesided=False,
...                         scaling='psd')
&gt;&gt;&gt; # Integrate numerically over abs(Zxx)**2:
&gt;&gt;&gt; df, dt = f[1] - f[0], t[1] - t[0]
&gt;&gt;&gt; E_Zxx = sum(np.sum(Zxx.real**2 + Zxx.imag**2, axis=0) * df) * dt
&gt;&gt;&gt; # The energy is the same, but the numerical errors are quite large:
&gt;&gt;&gt; np.isclose(E_x, E_Zxx, rtol=1e-2)
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1028</span>         axis=-1, scaling=<span class="stringliteral">&#39;spectrum&#39;</span>):</div>
<div class="line"><span class="lineno"> 1029</span>    <span class="stringliteral">r&quot;&quot;&quot;Compute the Short Time Fourier Transform (STFT).</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    STFTs can be used as a way of quantifying the change of a</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    nonstationary signal&#39;s frequency and phase content over time.</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">        Sampling frequency of the `x` time series. Defaults to 1.0.</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">        directly as the window and its length must be nperseg. Defaults</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        to a Hann window.</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    nperseg : int, optional</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">        Length of each segment. Defaults to 256.</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    noverlap : int, optional</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">        Number of points to overlap between segments. If `None`,</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">        ``noverlap = nperseg // 2``. Defaults to `None`. When</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">        specified, the COLA constraint must be met (see Notes below).</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">        Length of the FFT used, if a zero padded FFT is desired. If</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">        `None`, the FFT length is `nperseg`. Defaults to `None`.</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">    detrend : str or function or `False`, optional</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">        Specifies how to detrend each segment. If `detrend` is a</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">        string, it is passed as the `type` argument to the `detrend`</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">        function. If it is a function, it takes a segment and returns a</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">        detrended segment. If `detrend` is `False`, no detrending is</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">        done. Defaults to `False`.</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    return_onesided : bool, optional</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">        If `True`, return a one-sided spectrum for real data. If</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        `False` return a two-sided spectrum. Defaults to `True`, but for</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">        complex data, a two-sided spectrum is always returned.</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    boundary : str or None, optional</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">        Specifies whether the input signal is extended at both ends, and</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">        how to generate the new values, in order to center the first</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">        windowed segment on the first input point. This has the benefit</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">        of enabling reconstruction of the first input point when the</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">        employed window function starts at zero. Valid options are</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">        ``[&#39;even&#39;, &#39;odd&#39;, &#39;constant&#39;, &#39;zeros&#39;, None]``. Defaults to</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">        &#39;zeros&#39;, for zero padding extension. I.e. ``[1, 2, 3, 4]`` is</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">        extended to ``[0, 1, 2, 3, 4, 0]`` for ``nperseg=3``.</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    padded : bool, optional</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        Specifies whether the input signal is zero-padded at the end to</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">        make the signal fit exactly into an integer number of window</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">        segments, so that all of the signal is included in the output.</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">        Defaults to `True`. Padding occurs after boundary extension, if</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">        `boundary` is not `None`, and `padded` is `True`, as is the</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">        default.</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">        Axis along which the STFT is computed; the default is over the</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">        last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">    scaling: {&#39;spectrum&#39;, &#39;psd&#39;}</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">        The default &#39;spectrum&#39; scaling allows each frequency line of `Zxx` to</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">        be interpreted as a magnitude spectrum. The &#39;psd&#39; option scales each</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">        line to a power spectral density - it allows to calculate the signal&#39;s</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">        energy by numerically integrating over ``abs(Zxx)**2``.</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">        .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">    f : ndarray</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">        Array of sample frequencies.</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    t : ndarray</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">        Array of segment times.</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    Zxx : ndarray</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">        STFT of `x`. By default, the last axis of `Zxx` corresponds</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">        to the segment times.</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">    istft: Inverse Short Time Fourier Transform</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    check_COLA: Check whether the Constant OverLap Add (COLA) constraint</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">                is met</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">    welch: Power spectral density by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    spectrogram: Spectrogram by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    csd: Cross spectral density by Welch&#39;s method.</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">    lombscargle: Lomb-Scargle periodogram for unevenly sampled data</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    In order to enable inversion of an STFT via the inverse STFT in</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    `istft`, the signal windowing must obey the constraint of &quot;Nonzero</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    OverLap Add&quot; (NOLA), and the input signal must have complete</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    windowing coverage (i.e. ``(x.shape[axis] - nperseg) %</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    (nperseg-noverlap) == 0``). The `padded` argument may be used to</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    accomplish this.</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    Given a time-domain signal :math:`x[n]`, a window :math:`w[n]`, and a hop</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    size :math:`H` = `nperseg - noverlap`, the windowed frame at time index</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    :math:`t` is given by</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    .. math:: x_{t}[n]=x[n]w[n-tH]</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    The overlap-add (OLA) reconstruction equation is given by</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    .. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    The NOLA constraint ensures that every normalization term that appears</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    in the denomimator of the OLA reconstruction equation is nonzero. Whether a</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    choice of `window`, `nperseg`, and `noverlap` satisfy this constraint can</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    be tested with `check_NOLA`.</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">    .. versionadded:: 0.19.0</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    .. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">           &quot;Discrete-Time Signal Processing&quot;, Prentice Hall, 1999.</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">    .. [2] Daniel W. Griffin, Jae S. Lim &quot;Signal Estimation from</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">           Modified Short-Time Fourier Transform&quot;, IEEE 1984,</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">           10.1109/TASSP.1984.1164317</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    Generate a test signal, a 2 Vrms sine wave whose frequency is slowly</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    modulated around 3kHz, corrupted by white noise of exponentially</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    decreasing magnitude sampled at 10 kHz.</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    &gt;&gt;&gt; fs = 10e3</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    &gt;&gt;&gt; N = 1e5</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    &gt;&gt;&gt; amp = 2 * np.sqrt(2)</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    &gt;&gt;&gt; noise_power = 0.01 * fs / 2</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    &gt;&gt;&gt; time = np.arange(N) / float(fs)</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    &gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time)</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    &gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod)</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    &gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power),</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    ...                    size=time.shape)</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    &gt;&gt;&gt; noise *= np.exp(-time/5)</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    &gt;&gt;&gt; x = carrier + noise</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">    Compute and plot the STFT&#39;s magnitude.</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    &gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000)</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    &gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading=&#39;gouraud&#39;)</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&#39;STFT Magnitude&#39;)</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [sec]&#39;)</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    Compare the energy of the signal `x` with the energy of its STFT:</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">    &gt;&gt;&gt; E_x = sum(x**2) / fs  # Energy of x</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    &gt;&gt;&gt; # Calculate a two-sided STFT with PSD scaling:</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    &gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000, return_onesided=False,</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    ...                         scaling=&#39;psd&#39;)</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    &gt;&gt;&gt; # Integrate numerically over abs(Zxx)**2:</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    &gt;&gt;&gt; df, dt = f[1] - f[0], t[1] - t[0]</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    &gt;&gt;&gt; E_Zxx = sum(np.sum(Zxx.real**2 + Zxx.imag**2, axis=0) * df) * dt</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    &gt;&gt;&gt; # The energy is the same, but the numerical errors are quite large:</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    &gt;&gt;&gt; np.isclose(E_x, E_Zxx, rtol=1e-2)</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1193</span>    <span class="keywordflow">if</span> scaling == <span class="stringliteral">&#39;psd&#39;</span>:</div>
<div class="line"><span class="lineno"> 1194</span>        scaling = <span class="stringliteral">&#39;density&#39;</span></div>
<div class="line"><span class="lineno"> 1195</span>    <span class="keywordflow">elif</span> scaling != <span class="stringliteral">&#39;spectrum&#39;</span>:</div>
<div class="line"><span class="lineno"> 1196</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Parameter {scaling=} not in [&#39;spectrum&#39;, &#39;psd&#39;]!&quot;</span>)</div>
<div class="line"><span class="lineno"> 1197</span> </div>
<div class="line"><span class="lineno"> 1198</span>    freqs, time, Zxx = _spectral_helper(x, x, fs, window, nperseg, noverlap,</div>
<div class="line"><span class="lineno"> 1199</span>                                        nfft, detrend, return_onesided,</div>
<div class="line"><span class="lineno"> 1200</span>                                        scaling=scaling, axis=axis,</div>
<div class="line"><span class="lineno"> 1201</span>                                        mode=<span class="stringliteral">&#39;stft&#39;</span>, boundary=boundary,</div>
<div class="line"><span class="lineno"> 1202</span>                                        padded=padded)</div>
<div class="line"><span class="lineno"> 1203</span> </div>
<div class="line"><span class="lineno"> 1204</span>    <span class="keywordflow">return</span> freqs, time, Zxx</div>
<div class="line"><span class="lineno"> 1205</span> </div>
<div class="line"><span class="lineno"> 1206</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad045f3f43aa8846446af595a5b66bfd7" name="ad045f3f43aa8846446af595a5b66bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad045f3f43aa8846446af595a5b66bfd7">&#9670;&#160;</a></span>welch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.welch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hann'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nperseg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfft</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_onesided</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>'density'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>average</em> = <code>'mean'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate power spectral density using Welch's method.

Welch's method [1]_ computes an estimate of the power spectral
density by dividing the data into overlapping segments, computing a
modified periodogram for each segment and averaging the
periodograms.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg. Defaults
    to a Hann window.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap : int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Pxx` has units of V**2/Hz and computing the power
    spectrum ('spectrum') where `Pxx` has units of V**2, if `x`
    is measured in V and `fs` is measured in Hz. Defaults to
    'density'
axis : int, optional
    Axis along which the periodogram is computed; the default is
    over the last axis (i.e. ``axis=-1``).
average : { 'mean', 'median' }, optional
    Method to use when averaging periodograms. Defaults to 'mean'.

    .. versionadded:: 1.2.0

Returns
-------
f : ndarray
    Array of sample frequencies.
Pxx : ndarray
    Power spectral density or power spectrum of x.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.

If `noverlap` is 0, this method is equivalent to Bartlett's method
[2]_.

.. versionadded:: 0.12.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
       estimation of power spectra: A method based on time averaging
       over short, modified periodograms", IEEE Trans. Audio
       Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
       Biometrika, vol. 37, pp. 1-16, 1950.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2*np.sqrt(2)
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape)

Compute and plot the power spectral density.

&gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, Pxx_den)
&gt;&gt;&gt; plt.ylim([0.5e-3, 1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()

If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.

&gt;&gt;&gt; np.mean(Pxx_den[256:])
0.0009924865443739191

Now compute and plot the power spectrum.

&gt;&gt;&gt; f, Pxx_spec = signal.welch(x, fs, 'flattop', 1024, scaling='spectrum')
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]')
&gt;&gt;&gt; plt.show()

The peak height in the power spectrum is an estimate of the RMS
amplitude.

&gt;&gt;&gt; np.sqrt(Pxx_spec.max())
2.0077340678640727

If we now introduce a discontinuity in the signal, by increasing the
amplitude of a small portion of the signal by 50, we can see the
corruption of the mean average power spectral density, but using a
median average better estimates the normal behaviour.

&gt;&gt;&gt; x[int(N//2):int(N//2)+10] *= 50.
&gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024)
&gt;&gt;&gt; f_med, Pxx_den_med = signal.welch(x, fs, nperseg=1024, average='median')
&gt;&gt;&gt; plt.semilogy(f, Pxx_den, label='mean')
&gt;&gt;&gt; plt.semilogy(f_med, Pxx_den_med, label='median')
&gt;&gt;&gt; plt.ylim([0.5e-3, 1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.legend()
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  291</span>          axis=-1, average=<span class="stringliteral">&#39;mean&#39;</span>):</div>
<div class="line"><span class="lineno">  292</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    Estimate power spectral density using Welch&#39;s method.</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    Welch&#39;s method [1]_ computes an estimate of the power spectral</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    density by dividing the data into overlapping segments, computing a</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    modified periodogram for each segment and averaging the</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    periodograms.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        Time series of measurement values</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        Sampling frequency of the `x` time series. Defaults to 1.0.</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    window : str or tuple or array_like, optional</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        Desired window to use. If `window` is a string or tuple, it is</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">        passed to `get_window` to generate the window values, which are</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">        DFT-even by default. See `get_window` for a list of windows and</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        required parameters. If `window` is array_like it will be used</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        directly as the window and its length must be nperseg. Defaults</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        to a Hann window.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    nperseg : int, optional</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">        Length of each segment. Defaults to None, but if window is str or</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        tuple, is set to 256, and if window is array_like, is set to the</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">        length of the window.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    noverlap : int, optional</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        Number of points to overlap between segments. If `None`,</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        ``noverlap = nperseg // 2``. Defaults to `None`.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    nfft : int, optional</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        Length of the FFT used, if a zero padded FFT is desired. If</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">        `None`, the FFT length is `nperseg`. Defaults to `None`.</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    detrend : str or function or `False`, optional</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        Specifies how to detrend each segment. If `detrend` is a</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        string, it is passed as the `type` argument to the `detrend`</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">        function. If it is a function, it takes a segment and returns a</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        detrended segment. If `detrend` is `False`, no detrending is</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">        done. Defaults to &#39;constant&#39;.</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    return_onesided : bool, optional</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">        If `True`, return a one-sided spectrum for real data. If</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        `False` return a two-sided spectrum. Defaults to `True`, but for</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        complex data, a two-sided spectrum is always returned.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    scaling : { &#39;density&#39;, &#39;spectrum&#39; }, optional</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        Selects between computing the power spectral density (&#39;density&#39;)</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">        where `Pxx` has units of V**2/Hz and computing the power</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        spectrum (&#39;spectrum&#39;) where `Pxx` has units of V**2, if `x`</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">        is measured in V and `fs` is measured in Hz. Defaults to</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        &#39;density&#39;</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">        Axis along which the periodogram is computed; the default is</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">        over the last axis (i.e. ``axis=-1``).</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    average : { &#39;mean&#39;, &#39;median&#39; }, optional</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">        Method to use when averaging periodograms. Defaults to &#39;mean&#39;.</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">        .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    f : ndarray</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        Array of sample frequencies.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    Pxx : ndarray</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        Power spectral density or power spectrum of x.</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    periodogram: Simple, optionally modified periodogram</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    lombscargle: Lomb-Scargle periodogram for unevenly sampled data</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    An appropriate amount of overlap will depend on the choice of window</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    and on your requirements. For the default Hann window an overlap of</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    50% is a reasonable trade off between accurately estimating the</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    signal power, while not over counting any of the data. Narrower</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    windows may require a larger overlap.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    If `noverlap` is 0, this method is equivalent to Bartlett&#39;s method</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    [2]_.</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    .. versionadded:: 0.12.0</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    .. [1] P. Welch, &quot;The use of the fast Fourier transform for the</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">           estimation of power spectra: A method based on time averaging</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">           over short, modified periodograms&quot;, IEEE Trans. Audio</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">           Electroacoust. vol. 15, pp. 70-73, 1967.</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    .. [2] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;,</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">           Biometrika, vol. 37, pp. 1-16, 1950.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    0.001 V**2/Hz of white noise sampled at 10 kHz.</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    &gt;&gt;&gt; fs = 10e3</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    &gt;&gt;&gt; N = 1e5</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    &gt;&gt;&gt; amp = 2*np.sqrt(2)</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    &gt;&gt;&gt; freq = 1234.0</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    &gt;&gt;&gt; noise_power = 0.001 * fs / 2</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    &gt;&gt;&gt; time = np.arange(N) / fs</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    &gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    &gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape)</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    Compute and plot the power spectral density.</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    &gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024)</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f, Pxx_den)</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylim([0.5e-3, 1])</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;PSD [V**2/Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    If we average the last half of the spectral density, to exclude the</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    peak, we can recover the noise power on the signal.</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(Pxx_den[256:])</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    0.0009924865443739191</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    Now compute and plot the power spectrum.</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    &gt;&gt;&gt; f, Pxx_spec = signal.welch(x, fs, &#39;flattop&#39;, 1024, scaling=&#39;spectrum&#39;)</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Linear spectrum [V RMS]&#39;)</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    The peak height in the power spectrum is an estimate of the RMS</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    amplitude.</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    &gt;&gt;&gt; np.sqrt(Pxx_spec.max())</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    2.0077340678640727</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    If we now introduce a discontinuity in the signal, by increasing the</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    amplitude of a small portion of the signal by 50, we can see the</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    corruption of the mean average power spectral density, but using a</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    median average better estimates the normal behaviour.</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    &gt;&gt;&gt; x[int(N//2):int(N//2)+10] *= 50.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    &gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024)</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    &gt;&gt;&gt; f_med, Pxx_den_med = signal.welch(x, fs, nperseg=1024, average=&#39;median&#39;)</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f, Pxx_den, label=&#39;mean&#39;)</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogy(f_med, Pxx_den_med, label=&#39;median&#39;)</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylim([0.5e-3, 1])</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;frequency [Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;PSD [V**2/Hz]&#39;)</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend()</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  446</span>    freqs, Pxx = csd(x, x, fs=fs, window=window, nperseg=nperseg,</div>
<div class="line"><span class="lineno">  447</span>                     noverlap=noverlap, nfft=nfft, detrend=detrend,</div>
<div class="line"><span class="lineno">  448</span>                     return_onesided=return_onesided, scaling=scaling,</div>
<div class="line"><span class="lineno">  449</span>                     axis=axis, average=average)</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">return</span> freqs, Pxx.real</div>
<div class="line"><span class="lineno">  452</span> </div>
<div class="line"><span class="lineno">  453</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
