<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.sparse.linalg._isolve.lgmres Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse.html">sparse</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__isolve.html">_isolve</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1lgmres.html">lgmres</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.sparse.linalg._isolve.lgmres Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a07043995b613b47ea77f38511f9eab71" id="r_a07043995b613b47ea77f38511f9eab71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1lgmres.html#a07043995b613b47ea77f38511f9eab71">lgmres</a> (A, b, x0=None, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-5, maxiter=1000, M=None, callback=None, inner_m=30, outer_k=3, outer_v=None, store_outer_Av=True, prepend_outer_v=False, atol=None)</td></tr>
<tr class="separator:a07043995b613b47ea77f38511f9eab71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a07043995b613b47ea77f38511f9eab71" name="a07043995b613b47ea77f38511f9eab71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07043995b613b47ea77f38511f9eab71">&#9670;&#160;</a></span>lgmres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._isolve.lgmres.lgmres </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inner_m</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outer_k</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outer_v</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>store_outer_Av</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prepend_outer_v</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a matrix equation using the LGMRES algorithm.

The LGMRES algorithm [1]_ [2]_ is designed to avoid some problems
in the convergence in restarted GMRES, and often converges in fewer
iterations.

Parameters
----------
A : {sparse matrix, ndarray, LinearOperator}
    The real or complex N-by-N matrix of the linear system.
    Alternatively, ``A`` can be a linear operator which can
    produce ``Ax`` using, e.g.,
    ``scipy.sparse.linalg.LinearOperator``.
b : ndarray
    Right hand side of the linear system. Has shape (N,) or (N,1).
x0 : ndarray
    Starting guess for the solution.
tol, atol : float, optional
    Tolerances for convergence, ``norm(residual) &lt;= max(tol*norm(b), atol)``.
    The default for ``atol`` is `tol`.

    .. warning::

       The default value for `atol` will be changed in a future release.
       For future compatibility, specify `atol` explicitly.
maxiter : int, optional
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, ndarray, LinearOperator}, optional
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function, optional
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
inner_m : int, optional
    Number of inner GMRES iterations per each outer iteration.
outer_k : int, optional
    Number of vectors to carry between inner GMRES iterations.
    According to [1]_, good values are in the range of 1...3.
    However, note that if you want to use the additional vectors to
    accelerate solving multiple similar problems, larger values may
    be beneficial.
outer_v : list of tuples, optional
    List containing tuples ``(v, Av)`` of vectors and corresponding
    matrix-vector products, used to augment the Krylov subspace, and
    carried between inner GMRES iterations. The element ``Av`` can
    be `None` if the matrix-vector product should be re-evaluated.
    This parameter is modified in-place by `lgmres`, and can be used
    to pass "guess" vectors in and out of the algorithm when solving
    similar problems.
store_outer_Av : bool, optional
    Whether LGMRES should store also A@v in addition to vectors `v`
    in the `outer_v` list. Default is True.
prepend_outer_v : bool, optional
    Whether to put outer_v augmentation vectors before Krylov iterates.
    In standard LGMRES, prepend_outer_v=False.

Returns
-------
x : ndarray
    The converged solution.
info : int
    Provides convergence information:

        - 0  : successful exit
        - &gt;0 : convergence to tolerance not achieved, number of iterations
        - &lt;0 : illegal input or breakdown

Notes
-----
The LGMRES algorithm [1]_ [2]_ is designed to avoid the
slowing of convergence in restarted GMRES, due to alternating
residual vectors. Typically, it often outperforms GMRES(m) of
comparable memory requirements by some measure, or at least is not
much worse.

Another advantage in this algorithm is that you can supply it with
'guess' vectors in the `outer_v` argument that augment the Krylov
subspace. If the solution lies close to the span of these vectors,
the algorithm converges faster. This can be useful if several very
similar matrices need to be inverted one after another, such as in
Newton-Krylov iteration where the Jacobian matrix often changes
little in the nonlinear steps.

References
----------
.. [1] A.H. Baker and E.R. Jessup and T. Manteuffel, "A Technique for
         Accelerating the Convergence of Restarted GMRES", SIAM J. Matrix
         Anal. Appl. 26, 962 (2005).
.. [2] A.H. Baker, "On Improving the Performance of the Linear Solver
         restarted GMRES", PhD thesis, University of Colorado (2003).

Examples
--------
&gt;&gt;&gt; from scipy.sparse import csc_matrix
&gt;&gt;&gt; from scipy.sparse.linalg import lgmres
&gt;&gt;&gt; A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
&gt;&gt;&gt; b = np.array([2, 4, -1], dtype=float)
&gt;&gt;&gt; x, exitCode = lgmres(A, b)
&gt;&gt;&gt; print(exitCode)            # 0 indicates successful convergence
0
&gt;&gt;&gt; np.allclose(A.dot(x), b)
True
</pre> <div class="fragment"><div class="line"><span class="lineno">   17</span>           prepend_outer_v=<span class="keyword">False</span>, atol=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">   18</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral">    Solve a matrix equation using the LGMRES algorithm.</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral">    The LGMRES algorithm [1]_ [2]_ is designed to avoid some problems</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">    in the convergence in restarted GMRES, and often converges in fewer</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    iterations.</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    A : {sparse matrix, ndarray, LinearOperator}</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">        The real or complex N-by-N matrix of the linear system.</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">        Alternatively, ``A`` can be a linear operator which can</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">        produce ``Ax`` using, e.g.,</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">        ``scipy.sparse.linalg.LinearOperator``.</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    b : ndarray</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">        Right hand side of the linear system. Has shape (N,) or (N,1).</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    x0 : ndarray</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">        Starting guess for the solution.</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    tol, atol : float, optional</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        Tolerances for convergence, ``norm(residual) &lt;= max(tol*norm(b), atol)``.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">        The default for ``atol`` is `tol`.</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        .. warning::</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">           The default value for `atol` will be changed in a future release.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">           For future compatibility, specify `atol` explicitly.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        Maximum number of iterations.  Iteration will stop after maxiter</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        steps even if the specified tolerance has not been achieved.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    M : {sparse matrix, ndarray, LinearOperator}, optional</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">        Preconditioner for A.  The preconditioner should approximate the</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        inverse of A.  Effective preconditioning dramatically improves the</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        rate of convergence, which implies that fewer iterations are needed</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        to reach a given error tolerance.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    callback : function, optional</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        User-supplied function to call after each iteration.  It is called</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        as callback(xk), where xk is the current solution vector.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    inner_m : int, optional</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">        Number of inner GMRES iterations per each outer iteration.</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    outer_k : int, optional</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        Number of vectors to carry between inner GMRES iterations.</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        According to [1]_, good values are in the range of 1...3.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        However, note that if you want to use the additional vectors to</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        accelerate solving multiple similar problems, larger values may</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        be beneficial.</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    outer_v : list of tuples, optional</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">        List containing tuples ``(v, Av)`` of vectors and corresponding</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        matrix-vector products, used to augment the Krylov subspace, and</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        carried between inner GMRES iterations. The element ``Av`` can</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">        be `None` if the matrix-vector product should be re-evaluated.</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">        This parameter is modified in-place by `lgmres`, and can be used</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">        to pass &quot;guess&quot; vectors in and out of the algorithm when solving</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">        similar problems.</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    store_outer_Av : bool, optional</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">        Whether LGMRES should store also A@v in addition to vectors `v`</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">        in the `outer_v` list. Default is True.</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    prepend_outer_v : bool, optional</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        Whether to put outer_v augmentation vectors before Krylov iterates.</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">        In standard LGMRES, prepend_outer_v=False.</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">        The converged solution.</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    info : int</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">        Provides convergence information:</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">            - 0  : successful exit</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">            - &gt;0 : convergence to tolerance not achieved, number of iterations</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">            - &lt;0 : illegal input or breakdown</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    The LGMRES algorithm [1]_ [2]_ is designed to avoid the</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    slowing of convergence in restarted GMRES, due to alternating</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    residual vectors. Typically, it often outperforms GMRES(m) of</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    comparable memory requirements by some measure, or at least is not</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    much worse.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    Another advantage in this algorithm is that you can supply it with</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    &#39;guess&#39; vectors in the `outer_v` argument that augment the Krylov</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    subspace. If the solution lies close to the span of these vectors,</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    the algorithm converges faster. This can be useful if several very</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    similar matrices need to be inverted one after another, such as in</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    Newton-Krylov iteration where the Jacobian matrix often changes</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    little in the nonlinear steps.</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    .. [1] A.H. Baker and E.R. Jessup and T. Manteuffel, &quot;A Technique for</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">             Accelerating the Convergence of Restarted GMRES&quot;, SIAM J. Matrix</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">             Anal. Appl. 26, 962 (2005).</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    .. [2] A.H. Baker, &quot;On Improving the Performance of the Linear Solver</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">             restarted GMRES&quot;, PhD thesis, University of Colorado (2003).</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import csc_matrix</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse.linalg import lgmres</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &gt;&gt;&gt; A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([2, 4, -1], dtype=float)</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    &gt;&gt;&gt; x, exitCode = lgmres(A, b)</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; print(exitCode)            # 0 indicates successful convergence</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(A.dot(x), b)</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  125</span>    A,M,x,b,postprocess = make_system(A,M,x0,b)</div>
<div class="line"><span class="lineno">  126</span> </div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(b).all():</div>
<div class="line"><span class="lineno">  128</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;RHS must contain only finite numbers&quot;</span>)</div>
<div class="line"><span class="lineno">  129</span> </div>
<div class="line"><span class="lineno">  130</span>    <span class="keywordflow">if</span> atol <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  131</span>        warnings.warn(<span class="stringliteral">&quot;scipy.sparse.linalg.lgmres called without specifying `atol`. &quot;</span></div>
<div class="line"><span class="lineno">  132</span>                      <span class="stringliteral">&quot;The default value will change in the future. To preserve &quot;</span></div>
<div class="line"><span class="lineno">  133</span>                      <span class="stringliteral">&quot;current behavior, set ``atol=tol``.&quot;</span>,</div>
<div class="line"><span class="lineno">  134</span>                      category=DeprecationWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  135</span>        atol = tol</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span>    matvec = A.matvec</div>
<div class="line"><span class="lineno">  138</span>    psolve = M.matvec</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">if</span> outer_v <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  141</span>        outer_v = []</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    axpy, dot, scal = <span class="keywordtype">None</span>, <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  144</span>    nrm2 = get_blas_funcs(<span class="stringliteral">&#39;nrm2&#39;</span>, [b])</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>    b_norm = nrm2(b)</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">if</span> b_norm == 0:</div>
<div class="line"><span class="lineno">  148</span>        x = b</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">return</span> (postprocess(x), 0)</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>    ptol_max_factor = 1.0</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    <span class="keywordflow">for</span> k_outer <span class="keywordflow">in</span> range(maxiter):</div>
<div class="line"><span class="lineno">  154</span>        r_outer = matvec(x) - b</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>        <span class="comment"># -- callback</span></div>
<div class="line"><span class="lineno">  157</span>        <span class="keywordflow">if</span> callback <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  158</span>            callback(x)</div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>        <span class="comment"># -- determine input type routines</span></div>
<div class="line"><span class="lineno">  161</span>        <span class="keywordflow">if</span> axpy <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  162</span>            <span class="keywordflow">if</span> np.iscomplexobj(r_outer) <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.iscomplexobj(x):</div>
<div class="line"><span class="lineno">  163</span>                x = x.astype(r_outer.dtype)</div>
<div class="line"><span class="lineno">  164</span>            axpy, dot, scal, nrm2 = get_blas_funcs([<span class="stringliteral">&#39;axpy&#39;</span>, <span class="stringliteral">&#39;dot&#39;</span>, <span class="stringliteral">&#39;scal&#39;</span>, <span class="stringliteral">&#39;nrm2&#39;</span>],</div>
<div class="line"><span class="lineno">  165</span>                                                   (x, r_outer))</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>        <span class="comment"># -- check stopping condition</span></div>
<div class="line"><span class="lineno">  168</span>        r_norm = nrm2(r_outer)</div>
<div class="line"><span class="lineno">  169</span>        <span class="keywordflow">if</span> r_norm &lt;= max(atol, tol * b_norm):</div>
<div class="line"><span class="lineno">  170</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>        <span class="comment"># -- inner LGMRES iteration</span></div>
<div class="line"><span class="lineno">  173</span>        v0 = -psolve(r_outer)</div>
<div class="line"><span class="lineno">  174</span>        inner_res_0 = nrm2(v0)</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>        <span class="keywordflow">if</span> inner_res_0 == 0:</div>
<div class="line"><span class="lineno">  177</span>            rnorm = nrm2(r_outer)</div>
<div class="line"><span class="lineno">  178</span>            <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;Preconditioner returned a zero vector; &quot;</span></div>
<div class="line"><span class="lineno">  179</span>                               <span class="stringliteral">&quot;|v| ~ %.1g, |M v| = 0&quot;</span> % rnorm)</div>
<div class="line"><span class="lineno">  180</span> </div>
<div class="line"><span class="lineno">  181</span>        v0 = scal(1.0/inner_res_0, v0)</div>
<div class="line"><span class="lineno">  182</span> </div>
<div class="line"><span class="lineno">  183</span>        ptol = min(ptol_max_factor, max(atol, tol*b_norm)/r_norm)</div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  186</span>            Q, R, B, vs, zs, y, pres = _fgmres(matvec,</div>
<div class="line"><span class="lineno">  187</span>                                               v0,</div>
<div class="line"><span class="lineno">  188</span>                                               inner_m,</div>
<div class="line"><span class="lineno">  189</span>                                               lpsolve=psolve,</div>
<div class="line"><span class="lineno">  190</span>                                               atol=ptol,</div>
<div class="line"><span class="lineno">  191</span>                                               outer_v=outer_v,</div>
<div class="line"><span class="lineno">  192</span>                                               prepend_outer_v=prepend_outer_v)</div>
<div class="line"><span class="lineno">  193</span>            y *= inner_res_0</div>
<div class="line"><span class="lineno">  194</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(y).all():</div>
<div class="line"><span class="lineno">  195</span>                <span class="comment"># Overflow etc. in computation. There&#39;s no way to</span></div>
<div class="line"><span class="lineno">  196</span>                <span class="comment"># recover from this, so we have to bail out.</span></div>
<div class="line"><span class="lineno">  197</span>                <span class="keywordflow">raise</span> LinAlgError()</div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">except</span> LinAlgError:</div>
<div class="line"><span class="lineno">  199</span>            <span class="comment"># Floating point over/underflow, non-finite result from</span></div>
<div class="line"><span class="lineno">  200</span>            <span class="comment"># matmul etc. -- report failure.</span></div>
<div class="line"><span class="lineno">  201</span>            <span class="keywordflow">return</span> postprocess(x), k_outer + 1</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>        <span class="comment"># Inner loop tolerance control</span></div>
<div class="line"><span class="lineno">  204</span>        <span class="keywordflow">if</span> pres &gt; ptol:</div>
<div class="line"><span class="lineno">  205</span>            ptol_max_factor = min(1.0, 1.5 * ptol_max_factor)</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  207</span>            ptol_max_factor = max(1e-16, 0.25 * ptol_max_factor)</div>
<div class="line"><span class="lineno">  208</span> </div>
<div class="line"><span class="lineno">  209</span>        <span class="comment"># -- GMRES terminated: eval solution</span></div>
<div class="line"><span class="lineno">  210</span>        dx = zs[0]*y[0]</div>
<div class="line"><span class="lineno">  211</span>        <span class="keywordflow">for</span> w, yc <span class="keywordflow">in</span> zip(zs[1:], y[1:]):</div>
<div class="line"><span class="lineno">  212</span>            dx = axpy(w, dx, dx.shape[0], yc)  <span class="comment"># dx += w*yc</span></div>
<div class="line"><span class="lineno">  213</span> </div>
<div class="line"><span class="lineno">  214</span>        <span class="comment"># -- Store LGMRES augmentation vectors</span></div>
<div class="line"><span class="lineno">  215</span>        nx = nrm2(dx)</div>
<div class="line"><span class="lineno">  216</span>        <span class="keywordflow">if</span> nx &gt; 0:</div>
<div class="line"><span class="lineno">  217</span>            <span class="keywordflow">if</span> store_outer_Av:</div>
<div class="line"><span class="lineno">  218</span>                q = Q.dot(R.dot(y))</div>
<div class="line"><span class="lineno">  219</span>                ax = vs[0]*q[0]</div>
<div class="line"><span class="lineno">  220</span>                <span class="keywordflow">for</span> v, qc <span class="keywordflow">in</span> zip(vs[1:], q[1:]):</div>
<div class="line"><span class="lineno">  221</span>                    ax = axpy(v, ax, ax.shape[0], qc)</div>
<div class="line"><span class="lineno">  222</span>                outer_v.append((dx/nx, ax/nx))</div>
<div class="line"><span class="lineno">  223</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  224</span>                outer_v.append((dx/nx, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  225</span> </div>
<div class="line"><span class="lineno">  226</span>        <span class="comment"># -- Retain only a finite number of augmentation vectors</span></div>
<div class="line"><span class="lineno">  227</span>        <span class="keywordflow">while</span> len(outer_v) &gt; outer_k:</div>
<div class="line"><span class="lineno">  228</span>            del outer_v[0]</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>        <span class="comment"># -- Apply step</span></div>
<div class="line"><span class="lineno">  231</span>        x += dx</div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  233</span>        <span class="comment"># didn&#39;t converge ...</span></div>
<div class="line"><span class="lineno">  234</span>        <span class="keywordflow">return</span> postprocess(x), maxiter</div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span>    <span class="keywordflow">return</span> postprocess(x), 0</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
