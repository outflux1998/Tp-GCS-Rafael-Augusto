<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.recfunctions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html">recfunctions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.recfunctions Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a387aec6d8d871ef7478aa8ba8a9759c2" id="r_a387aec6d8d871ef7478aa8ba8a9759c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a387aec6d8d871ef7478aa8ba8a9759c2">_recursive_fill_fields_dispatcher</a> (input, output)</td></tr>
<tr class="separator:a387aec6d8d871ef7478aa8ba8a9759c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbd28e28bf50bb6237b530b9a306359" id="r_afbbd28e28bf50bb6237b530b9a306359"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#afbbd28e28bf50bb6237b530b9a306359">recursive_fill_fields</a> (input, output)</td></tr>
<tr class="separator:afbbd28e28bf50bb6237b530b9a306359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac632b638fcbd14723e3962e76bd6c27f" id="r_ac632b638fcbd14723e3962e76bd6c27f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ac632b638fcbd14723e3962e76bd6c27f">_get_fieldspec</a> (dtype)</td></tr>
<tr class="separator:ac632b638fcbd14723e3962e76bd6c27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc07457ddc639c4f60e1625582a6df2f" id="r_adc07457ddc639c4f60e1625582a6df2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#adc07457ddc639c4f60e1625582a6df2f">get_names</a> (adtype)</td></tr>
<tr class="separator:adc07457ddc639c4f60e1625582a6df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592f880c5cab6a2b538aed975092f14d" id="r_a592f880c5cab6a2b538aed975092f14d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a592f880c5cab6a2b538aed975092f14d">get_names_flat</a> (adtype)</td></tr>
<tr class="separator:a592f880c5cab6a2b538aed975092f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99815b0b69df567b202aeb68723e796c" id="r_a99815b0b69df567b202aeb68723e796c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a99815b0b69df567b202aeb68723e796c">flatten_descr</a> (ndtype)</td></tr>
<tr class="separator:a99815b0b69df567b202aeb68723e796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29807207fc39e52d912f9f5a861197e5" id="r_a29807207fc39e52d912f9f5a861197e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a29807207fc39e52d912f9f5a861197e5">_zip_dtype</a> (seqarrays, flatten=False)</td></tr>
<tr class="separator:a29807207fc39e52d912f9f5a861197e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfbf613083ebc6e045ee1b3b9658d80" id="r_a7cfbf613083ebc6e045ee1b3b9658d80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a7cfbf613083ebc6e045ee1b3b9658d80">_zip_descr</a> (seqarrays, flatten=False)</td></tr>
<tr class="separator:a7cfbf613083ebc6e045ee1b3b9658d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcda6778d6440c8d4d9450f04ea77c6" id="r_aabcda6778d6440c8d4d9450f04ea77c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aabcda6778d6440c8d4d9450f04ea77c6">get_fieldstructure</a> (adtype, lastname=None, parents=None)</td></tr>
<tr class="separator:aabcda6778d6440c8d4d9450f04ea77c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af955b146bc8f587c27a7d89f8bf708eb" id="r_af955b146bc8f587c27a7d89f8bf708eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#af955b146bc8f587c27a7d89f8bf708eb">_izip_fields_flat</a> (<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a531c572a52ebfaba6055e1d1b7c88ba2">iterable</a>)</td></tr>
<tr class="separator:af955b146bc8f587c27a7d89f8bf708eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3565d617fddd191bbf428bd3bf7d8d7" id="r_aa3565d617fddd191bbf428bd3bf7d8d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aa3565d617fddd191bbf428bd3bf7d8d7">_izip_fields</a> (<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a531c572a52ebfaba6055e1d1b7c88ba2">iterable</a>)</td></tr>
<tr class="separator:aa3565d617fddd191bbf428bd3bf7d8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a93912b2501cc4320150ece67c590" id="r_a672a93912b2501cc4320150ece67c590"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a672a93912b2501cc4320150ece67c590">_izip_records</a> (seqarrays, fill_value=None, flatten=True)</td></tr>
<tr class="separator:a672a93912b2501cc4320150ece67c590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705ae9723b06ff0f26305e06243274f4" id="r_a705ae9723b06ff0f26305e06243274f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a705ae9723b06ff0f26305e06243274f4">_fix_output</a> (output, usemask=True, asrecarray=False)</td></tr>
<tr class="separator:a705ae9723b06ff0f26305e06243274f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d314789058f8da7c460f26653b1a17" id="r_ad9d314789058f8da7c460f26653b1a17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ad9d314789058f8da7c460f26653b1a17">_fix_defaults</a> (output, defaults=None)</td></tr>
<tr class="separator:ad9d314789058f8da7c460f26653b1a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85950f01d74892c545b7d78fc350cc2" id="r_af85950f01d74892c545b7d78fc350cc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#af85950f01d74892c545b7d78fc350cc2">_merge_arrays_dispatcher</a> (seqarrays, fill_value=None, flatten=None, usemask=None, asrecarray=None)</td></tr>
<tr class="separator:af85950f01d74892c545b7d78fc350cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad640d3ad74ad4c34a34c1e2c159618f6" id="r_ad640d3ad74ad4c34a34c1e2c159618f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ad640d3ad74ad4c34a34c1e2c159618f6">merge_arrays</a> (seqarrays, fill_value=-1, flatten=False, usemask=False, asrecarray=False)</td></tr>
<tr class="separator:ad640d3ad74ad4c34a34c1e2c159618f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8ddc9908595c93898a5e64c077fb6e" id="r_aea8ddc9908595c93898a5e64c077fb6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aea8ddc9908595c93898a5e64c077fb6e">_drop_fields_dispatcher</a> (base, drop_names, usemask=None, asrecarray=None)</td></tr>
<tr class="separator:aea8ddc9908595c93898a5e64c077fb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab71eaa6a3e94dfe27511c1ede12c5e" id="r_a1ab71eaa6a3e94dfe27511c1ede12c5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a1ab71eaa6a3e94dfe27511c1ede12c5e">drop_fields</a> (base, drop_names, usemask=True, asrecarray=False)</td></tr>
<tr class="separator:a1ab71eaa6a3e94dfe27511c1ede12c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17af78095e14793c53770ed1b69efcde" id="r_a17af78095e14793c53770ed1b69efcde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a17af78095e14793c53770ed1b69efcde">_keep_fields</a> (base, keep_names, usemask=True, asrecarray=False)</td></tr>
<tr class="separator:a17af78095e14793c53770ed1b69efcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c1bee8534e569cda45d4ea8a001000" id="r_a14c1bee8534e569cda45d4ea8a001000"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a14c1bee8534e569cda45d4ea8a001000">_rec_drop_fields_dispatcher</a> (base, drop_names)</td></tr>
<tr class="separator:a14c1bee8534e569cda45d4ea8a001000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbf9d4bad57a582f7af8533c1cc3f69" id="r_a8cbf9d4bad57a582f7af8533c1cc3f69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a8cbf9d4bad57a582f7af8533c1cc3f69">rec_drop_fields</a> (base, drop_names)</td></tr>
<tr class="separator:a8cbf9d4bad57a582f7af8533c1cc3f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebb945a72674f265a47b5a01e7a3598" id="r_a4ebb945a72674f265a47b5a01e7a3598"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a4ebb945a72674f265a47b5a01e7a3598">_rename_fields_dispatcher</a> (base, namemapper)</td></tr>
<tr class="separator:a4ebb945a72674f265a47b5a01e7a3598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8d41c05a7084dd2e8f17ffd2c50e97" id="r_aba8d41c05a7084dd2e8f17ffd2c50e97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aba8d41c05a7084dd2e8f17ffd2c50e97">rename_fields</a> (base, namemapper)</td></tr>
<tr class="separator:aba8d41c05a7084dd2e8f17ffd2c50e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134f8f24e53203b15fce06ae38ef8f3c" id="r_a134f8f24e53203b15fce06ae38ef8f3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a134f8f24e53203b15fce06ae38ef8f3c">_append_fields_dispatcher</a> (base, names, data, dtypes=None, fill_value=None, usemask=None, asrecarray=None)</td></tr>
<tr class="separator:a134f8f24e53203b15fce06ae38ef8f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae732743ba095cb0a97350329d62fa733" id="r_ae732743ba095cb0a97350329d62fa733"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ae732743ba095cb0a97350329d62fa733">append_fields</a> (base, names, data, dtypes=None, fill_value=-1, usemask=True, asrecarray=False)</td></tr>
<tr class="separator:ae732743ba095cb0a97350329d62fa733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c84aaa1aebef93f54bb265ca852b55" id="r_ae8c84aaa1aebef93f54bb265ca852b55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ae8c84aaa1aebef93f54bb265ca852b55">_rec_append_fields_dispatcher</a> (base, names, data, dtypes=None)</td></tr>
<tr class="separator:ae8c84aaa1aebef93f54bb265ca852b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b78ddf8e53ebbd142c0963c2e87a8c" id="r_a61b78ddf8e53ebbd142c0963c2e87a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a61b78ddf8e53ebbd142c0963c2e87a8c">rec_append_fields</a> (base, names, data, dtypes=None)</td></tr>
<tr class="separator:a61b78ddf8e53ebbd142c0963c2e87a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd69ddd198154001fdc5985a001131" id="r_ae2cd69ddd198154001fdc5985a001131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ae2cd69ddd198154001fdc5985a001131">_repack_fields_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, align=None, recurse=None)</td></tr>
<tr class="separator:ae2cd69ddd198154001fdc5985a001131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ab7ba8f60627be51d62477cf0450b6" id="r_a23ab7ba8f60627be51d62477cf0450b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a23ab7ba8f60627be51d62477cf0450b6">repack_fields</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, align=False, recurse=False)</td></tr>
<tr class="separator:a23ab7ba8f60627be51d62477cf0450b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69b410790ad26c938bf3fcba99a47c8" id="r_aa69b410790ad26c938bf3fcba99a47c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aa69b410790ad26c938bf3fcba99a47c8">_get_fields_and_offsets</a> (dt, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0)</td></tr>
<tr class="separator:aa69b410790ad26c938bf3fcba99a47c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d165ecbeec06144021e0c80c0ce61c" id="r_a20d165ecbeec06144021e0c80c0ce61c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a20d165ecbeec06144021e0c80c0ce61c">_structured_to_unstructured_dispatcher</a> (arr, dtype=None, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afb1a45e10c0c1606be5642979696590c">copy</a>=None, casting=None)</td></tr>
<tr class="separator:a20d165ecbeec06144021e0c80c0ce61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37149618be7d8f4aab3e18db4b08743f" id="r_a37149618be7d8f4aab3e18db4b08743f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a37149618be7d8f4aab3e18db4b08743f">structured_to_unstructured</a> (arr, dtype=None, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afb1a45e10c0c1606be5642979696590c">copy</a>=False, casting='unsafe')</td></tr>
<tr class="separator:a37149618be7d8f4aab3e18db4b08743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b5bb969fa1032bfb29a2fc8f721d72" id="r_ab2b5bb969fa1032bfb29a2fc8f721d72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ab2b5bb969fa1032bfb29a2fc8f721d72">_unstructured_to_structured_dispatcher</a> (arr, dtype=None, names=None, align=None, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afb1a45e10c0c1606be5642979696590c">copy</a>=None, casting=None)</td></tr>
<tr class="separator:ab2b5bb969fa1032bfb29a2fc8f721d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa73ee9d38458b5687a92938d264119b" id="r_aaa73ee9d38458b5687a92938d264119b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aaa73ee9d38458b5687a92938d264119b">unstructured_to_structured</a> (arr, dtype=None, names=None, align=False, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afb1a45e10c0c1606be5642979696590c">copy</a>=False, casting='unsafe')</td></tr>
<tr class="separator:aaa73ee9d38458b5687a92938d264119b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa751e10710b1296f69650079c00844e" id="r_afa751e10710b1296f69650079c00844e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#afa751e10710b1296f69650079c00844e">_apply_along_fields_dispatcher</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, arr)</td></tr>
<tr class="separator:afa751e10710b1296f69650079c00844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1007358718aaef87542737ba47ec1ecd" id="r_a1007358718aaef87542737ba47ec1ecd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a1007358718aaef87542737ba47ec1ecd">apply_along_fields</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, arr)</td></tr>
<tr class="separator:a1007358718aaef87542737ba47ec1ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0657d839440aed110bf62299d519b23" id="r_ad0657d839440aed110bf62299d519b23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ad0657d839440aed110bf62299d519b23">_assign_fields_by_name_dispatcher</a> (dst, src, zero_unassigned=None)</td></tr>
<tr class="separator:ad0657d839440aed110bf62299d519b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2409ada76e5f1822177649010235d734" id="r_a2409ada76e5f1822177649010235d734"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a2409ada76e5f1822177649010235d734">assign_fields_by_name</a> (dst, src, zero_unassigned=True)</td></tr>
<tr class="separator:a2409ada76e5f1822177649010235d734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb4c33e435e345787ce9ea6f7a10001" id="r_a7cb4c33e435e345787ce9ea6f7a10001"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a7cb4c33e435e345787ce9ea6f7a10001">_require_fields_dispatcher</a> (array, required_dtype)</td></tr>
<tr class="separator:a7cb4c33e435e345787ce9ea6f7a10001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee30508fb48b1e388eea45d89e44d8e2" id="r_aee30508fb48b1e388eea45d89e44d8e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aee30508fb48b1e388eea45d89e44d8e2">require_fields</a> (array, required_dtype)</td></tr>
<tr class="separator:aee30508fb48b1e388eea45d89e44d8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1b5261a2dca09adc653821de027bcd" id="r_a1c1b5261a2dca09adc653821de027bcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a1c1b5261a2dca09adc653821de027bcd">_stack_arrays_dispatcher</a> (arrays, defaults=None, usemask=None, asrecarray=None, autoconvert=None)</td></tr>
<tr class="separator:a1c1b5261a2dca09adc653821de027bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891f814bc1fd2810a0a845a44a6f8f51" id="r_a891f814bc1fd2810a0a845a44a6f8f51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a891f814bc1fd2810a0a845a44a6f8f51">stack_arrays</a> (arrays, defaults=None, usemask=True, asrecarray=False, autoconvert=False)</td></tr>
<tr class="separator:a891f814bc1fd2810a0a845a44a6f8f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdbd479cca5afbc90d57b93c97ef98a" id="r_a6cdbd479cca5afbc90d57b93c97ef98a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a6cdbd479cca5afbc90d57b93c97ef98a">_find_duplicates_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a4debd884e6bb24f280edd8eb1efa9fba">key</a>=None, ignoremask=None, return_index=None)</td></tr>
<tr class="separator:a6cdbd479cca5afbc90d57b93c97ef98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56865e10b7543760aa15f9e28644ba33" id="r_a56865e10b7543760aa15f9e28644ba33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a56865e10b7543760aa15f9e28644ba33">find_duplicates</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a4debd884e6bb24f280edd8eb1efa9fba">key</a>=None, ignoremask=True, return_index=False)</td></tr>
<tr class="separator:a56865e10b7543760aa15f9e28644ba33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479e159dabfc332ee0ad1729ff68120a" id="r_a479e159dabfc332ee0ad1729ff68120a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a479e159dabfc332ee0ad1729ff68120a">_join_by_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a4debd884e6bb24f280edd8eb1efa9fba">key</a>, r1, r2, jointype=None, r1postfix=None, r2postfix=None, defaults=None, usemask=None, asrecarray=None)</td></tr>
<tr class="separator:a479e159dabfc332ee0ad1729ff68120a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018486f6c13170fb4c26809fff5409d8" id="r_a018486f6c13170fb4c26809fff5409d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a018486f6c13170fb4c26809fff5409d8">join_by</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a4debd884e6bb24f280edd8eb1efa9fba">key</a>, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None, usemask=True, asrecarray=False)</td></tr>
<tr class="separator:a018486f6c13170fb4c26809fff5409d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd1ba0a811167779549e7dd1bdf4ae0" id="r_adfd1ba0a811167779549e7dd1bdf4ae0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#adfd1ba0a811167779549e7dd1bdf4ae0">_rec_join_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a4debd884e6bb24f280edd8eb1efa9fba">key</a>, r1, r2, jointype=None, r1postfix=None, r2postfix=None, defaults=None)</td></tr>
<tr class="separator:adfd1ba0a811167779549e7dd1bdf4ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0037374c7c15329c232f5880d143829e" id="r_a0037374c7c15329c232f5880d143829e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a0037374c7c15329c232f5880d143829e">rec_join</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a4debd884e6bb24f280edd8eb1efa9fba">key</a>, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None)</td></tr>
<tr class="separator:a0037374c7c15329c232f5880d143829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a27198198789b1c59344e1bc612310f5f" id="r_a27198198789b1c59344e1bc612310f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a27198198789b1c59344e1bc612310f5f">_check_fill_value</a> = np.ma.core._check_fill_value</td></tr>
<tr class="separator:a27198198789b1c59344e1bc612310f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Collection of utilities to manipulate structured arrays.

Most of these functions were initially implemented by John Hunter for
matplotlib.  They have been rewritten and extended for convenience.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a134f8f24e53203b15fce06ae38ef8f3c" name="a134f8f24e53203b15fce06ae38ef8f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134f8f24e53203b15fce06ae38ef8f3c">&#9670;&#160;</a></span>_append_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._append_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtypes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  648</span>                              fill_value=<span class="keywordtype">None</span>, usemask=<span class="keywordtype">None</span>, asrecarray=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  649</span>    <span class="keywordflow">yield</span> base</div>
<div class="line"><span class="lineno">  650</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> data</div>
<div class="line"><span class="lineno">  651</span> </div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span><span class="preprocessor">@array_function_dispatch(_append_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afa751e10710b1296f69650079c00844e" name="afa751e10710b1296f69650079c00844e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa751e10710b1296f69650079c00844e">&#9670;&#160;</a></span>_apply_along_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._apply_along_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1095</span><span class="keyword">def </span>_apply_along_fields_dispatcher(func, arr):</div>
<div class="line"><span class="lineno"> 1096</span>    <span class="keywordflow">return</span> (arr,)</div>
<div class="line"><span class="lineno"> 1097</span> </div>
<div class="line"><span class="lineno"> 1098</span><span class="preprocessor">@array_function_dispatch(_apply_along_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0657d839440aed110bf62299d519b23" name="ad0657d839440aed110bf62299d519b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0657d839440aed110bf62299d519b23">&#9670;&#160;</a></span>_assign_fields_by_name_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._assign_fields_by_name_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zero_unassigned</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1141</span><span class="keyword">def </span>_assign_fields_by_name_dispatcher(dst, src, zero_unassigned=None):</div>
<div class="line"><span class="lineno"> 1142</span>    <span class="keywordflow">return</span> dst, src</div>
<div class="line"><span class="lineno"> 1143</span> </div>
<div class="line"><span class="lineno"> 1144</span><span class="preprocessor">@array_function_dispatch(_assign_fields_by_name_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea8ddc9908595c93898a5e64c077fb6e" name="aea8ddc9908595c93898a5e64c077fb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8ddc9908595c93898a5e64c077fb6e">&#9670;&#160;</a></span>_drop_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._drop_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  497</span><span class="keyword">def </span>_drop_fields_dispatcher(base, drop_names, usemask=None, asrecarray=None):</div>
<div class="line"><span class="lineno">  498</span>    <span class="keywordflow">return</span> (base,)</div>
<div class="line"><span class="lineno">  499</span> </div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span><span class="preprocessor">@array_function_dispatch(_drop_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cdbd479cca5afbc90d57b93c97ef98a" name="a6cdbd479cca5afbc90d57b93c97ef98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdbd479cca5afbc90d57b93c97ef98a">&#9670;&#160;</a></span>_find_duplicates_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._find_duplicates_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ignoremask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1323</span>        a, key=<span class="keywordtype">None</span>, ignoremask=<span class="keywordtype">None</span>, return_index=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1324</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1325</span> </div>
<div class="line"><span class="lineno"> 1326</span> </div>
<div class="line"><span class="lineno"> 1327</span><span class="preprocessor">@array_function_dispatch(_find_duplicates_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9d314789058f8da7c460f26653b1a17" name="ad9d314789058f8da7c460f26653b1a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d314789058f8da7c460f26653b1a17">&#9670;&#160;</a></span>_fix_defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._fix_defaults </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Update the fill_value and masked data of `output`
from the default given in a dictionary defaults.
</pre> <div class="fragment"><div class="line"><span class="lineno">  342</span><span class="keyword">def </span>_fix_defaults(output, defaults=None):</div>
<div class="line"><span class="lineno">  343</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    Update the fill_value and masked data of `output`</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    from the default given in a dictionary defaults.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  347</span>    names = output.dtype.names</div>
<div class="line"><span class="lineno">  348</span>    (data, mask, fill_value) = (output.data, output.mask, output.fill_value)</div>
<div class="line"><span class="lineno">  349</span>    <span class="keywordflow">for</span> (k, v) <span class="keywordflow">in</span> (defaults <span class="keywordflow">or</span> {}).items():</div>
<div class="line"><span class="lineno">  350</span>        <span class="keywordflow">if</span> k <span class="keywordflow">in</span> names:</div>
<div class="line"><span class="lineno">  351</span>            fill_value[k] = v</div>
<div class="line"><span class="lineno">  352</span>            data[k][mask[k]] = v</div>
<div class="line"><span class="lineno">  353</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a705ae9723b06ff0f26305e06243274f4" name="a705ae9723b06ff0f26305e06243274f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705ae9723b06ff0f26305e06243274f4">&#9670;&#160;</a></span>_fix_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._fix_output </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function: return a recarray, a ndarray, a MaskedArray
or a MaskedRecords depending on the input parameters
</pre> <div class="fragment"><div class="line"><span class="lineno">  325</span><span class="keyword">def </span>_fix_output(output, usemask=True, asrecarray=False):</div>
<div class="line"><span class="lineno">  326</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    Private function: return a recarray, a ndarray, a MaskedArray</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    or a MaskedRecords depending on the input parameters</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(output, MaskedArray):</div>
<div class="line"><span class="lineno">  331</span>        usemask = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  332</span>    <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno">  333</span>        <span class="keywordflow">if</span> asrecarray:</div>
<div class="line"><span class="lineno">  334</span>            output = output.view(MaskedRecords)</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  336</span>        output = ma.filled(output)</div>
<div class="line"><span class="lineno">  337</span>        <span class="keywordflow">if</span> asrecarray:</div>
<div class="line"><span class="lineno">  338</span>            output = output.view(recarray)</div>
<div class="line"><span class="lineno">  339</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  340</span> </div>
<div class="line"><span class="lineno">  341</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa69b410790ad26c938bf3fcba99a47c8" name="aa69b410790ad26c938bf3fcba99a47c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69b410790ad26c938bf3fcba99a47c8">&#9670;&#160;</a></span>_get_fields_and_offsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._get_fields_and_offsets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns a flat list of (dtype, count, offset) tuples of all the
scalar fields in the dtype "dt", including nested fields, in left
to right order.
</pre> <div class="fragment"><div class="line"><span class="lineno">  851</span><span class="keyword">def </span>_get_fields_and_offsets(dt, offset=0):</div>
<div class="line"><span class="lineno">  852</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    Returns a flat list of (dtype, count, offset) tuples of all the</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    scalar fields in the dtype &quot;dt&quot;, including nested fields, in left</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    to right order.</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  857</span> </div>
<div class="line"><span class="lineno">  858</span>    <span class="comment"># counts up elements in subarrays, including nested subarrays, and returns</span></div>
<div class="line"><span class="lineno">  859</span>    <span class="comment"># base dtype and count</span></div>
<div class="line"><span class="lineno">  860</span>    <span class="keyword">def </span>count_elem(dt):</div>
<div class="line"><span class="lineno">  861</span>        count = 1</div>
<div class="line"><span class="lineno">  862</span>        <span class="keywordflow">while</span> dt.shape != ():</div>
<div class="line"><span class="lineno">  863</span>            <span class="keywordflow">for</span> size <span class="keywordflow">in</span> dt.shape:</div>
<div class="line"><span class="lineno">  864</span>                count *= size</div>
<div class="line"><span class="lineno">  865</span>            dt = dt.base</div>
<div class="line"><span class="lineno">  866</span>        <span class="keywordflow">return</span> dt, count</div>
<div class="line"><span class="lineno">  867</span> </div>
<div class="line"><span class="lineno">  868</span>    fields = []</div>
<div class="line"><span class="lineno">  869</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> dt.names:</div>
<div class="line"><span class="lineno">  870</span>        field = dt.fields[name]</div>
<div class="line"><span class="lineno">  871</span>        f_dt, f_offset = field[0], field[1]</div>
<div class="line"><span class="lineno">  872</span>        f_dt, n = count_elem(f_dt)</div>
<div class="line"><span class="lineno">  873</span> </div>
<div class="line"><span class="lineno">  874</span>        <span class="keywordflow">if</span> f_dt.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  875</span>            fields.append((np.dtype((f_dt, (n,))), n, f_offset + offset))</div>
<div class="line"><span class="lineno">  876</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  877</span>            subfields = _get_fields_and_offsets(f_dt, f_offset + offset)</div>
<div class="line"><span class="lineno">  878</span>            size = f_dt.itemsize</div>
<div class="line"><span class="lineno">  879</span> </div>
<div class="line"><span class="lineno">  880</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">  881</span>                <span class="keywordflow">if</span> i == 0:</div>
<div class="line"><span class="lineno">  882</span>                    <span class="comment"># optimization: avoid list comprehension if no subarray</span></div>
<div class="line"><span class="lineno">  883</span>                    fields.extend(subfields)</div>
<div class="line"><span class="lineno">  884</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  885</span>                    fields.extend([(d, c, o + i*size) <span class="keywordflow">for</span> d, c, o <span class="keywordflow">in</span> subfields])</div>
<div class="line"><span class="lineno">  886</span>    <span class="keywordflow">return</span> fields</div>
<div class="line"><span class="lineno">  887</span> </div>
<div class="line"><span class="lineno">  888</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac632b638fcbd14723e3962e76bd6c27f" name="ac632b638fcbd14723e3962e76bd6c27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac632b638fcbd14723e3962e76bd6c27f">&#9670;&#160;</a></span>_get_fieldspec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._get_fieldspec </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Produce a list of name/dtype pairs corresponding to the dtype fields

Similar to dtype.descr, but the second item of each tuple is a dtype, not a
string. As a result, this handles subarray dtypes

Can be passed to the dtype constructor to reconstruct the dtype, noting that
this (deliberately) discards field offsets.

Examples
--------
&gt;&gt;&gt; dt = np.dtype([(('a', 'A'), np.int64), ('b', np.double, 3)])
&gt;&gt;&gt; dt.descr
[(('a', 'A'), '&lt;i8'), ('b', '&lt;f8', (3,))]
&gt;&gt;&gt; _get_fieldspec(dt)
[(('a', 'A'), dtype('int64')), ('b', dtype(('&lt;f8', (3,))))]</pre> <div class="fragment"><div class="line"><span class="lineno">   74</span><span class="keyword">def </span>_get_fieldspec(dtype):</div>
<div class="line"><span class="lineno">   75</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    Produce a list of name/dtype pairs corresponding to the dtype fields</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    Similar to dtype.descr, but the second item of each tuple is a dtype, not a</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    string. As a result, this handles subarray dtypes</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    Can be passed to the dtype constructor to reconstruct the dtype, noting that</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    this (deliberately) discards field offsets.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    &gt;&gt;&gt; dt = np.dtype([((&#39;a&#39;, &#39;A&#39;), np.int64), (&#39;b&#39;, np.double, 3)])</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    &gt;&gt;&gt; dt.descr</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    [((&#39;a&#39;, &#39;A&#39;), &#39;&lt;i8&#39;), (&#39;b&#39;, &#39;&lt;f8&#39;, (3,))]</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    &gt;&gt;&gt; _get_fieldspec(dt)</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    [((&#39;a&#39;, &#39;A&#39;), dtype(&#39;int64&#39;)), (&#39;b&#39;, dtype((&#39;&lt;f8&#39;, (3,))))]</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">if</span> dtype.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   94</span>        <span class="comment"># .descr returns a nameless field, so we should too</span></div>
<div class="line"><span class="lineno">   95</span>        <span class="keywordflow">return</span> [(<span class="stringliteral">&#39;&#39;</span>, dtype)]</div>
<div class="line"><span class="lineno">   96</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   97</span>        fields = ((name, dtype.fields[name]) <span class="keywordflow">for</span> name <span class="keywordflow">in</span> dtype.names)</div>
<div class="line"><span class="lineno">   98</span>        <span class="comment"># keep any titles, if present</span></div>
<div class="line"><span class="lineno">   99</span>        <span class="keywordflow">return</span> [</div>
<div class="line"><span class="lineno">  100</span>            (name <span class="keywordflow">if</span> len(f) == 2 <span class="keywordflow">else</span> (f[2], name), f[0])</div>
<div class="line"><span class="lineno">  101</span>            <span class="keywordflow">for</span> name, f <span class="keywordflow">in</span> fields</div>
<div class="line"><span class="lineno">  102</span>        ]</div>
<div class="line"><span class="lineno">  103</span> </div>
<div class="line"><span class="lineno">  104</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3565d617fddd191bbf428bd3bf7d8d7" name="aa3565d617fddd191bbf428bd3bf7d8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3565d617fddd191bbf428bd3bf7d8d7">&#9670;&#160;</a></span>_izip_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._izip_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator of concatenated fields from a sequence of arrays.</pre> <div class="fragment"><div class="line"><span class="lineno">  285</span><span class="keyword">def </span>_izip_fields(iterable):</div>
<div class="line"><span class="lineno">  286</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    Returns an iterator of concatenated fields from a sequence of arrays.</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  290</span>    <span class="keywordflow">for</span> element <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno">  291</span>        <span class="keywordflow">if</span> (hasattr(element, <span class="stringliteral">&#39;__iter__&#39;</span>) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  292</span>                <span class="keywordflow">not</span> isinstance(element, str)):</div>
<div class="line"><span class="lineno">  293</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> _izip_fields(element)</div>
<div class="line"><span class="lineno">  294</span>        <span class="keywordflow">elif</span> isinstance(element, np.void) <span class="keywordflow">and</span> len(tuple(element)) == 1:</div>
<div class="line"><span class="lineno">  295</span>            <span class="comment"># this statement is the same from the previous expression</span></div>
<div class="line"><span class="lineno">  296</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> _izip_fields(element)</div>
<div class="line"><span class="lineno">  297</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  298</span>            <span class="keywordflow">yield</span> element</div>
<div class="line"><span class="lineno">  299</span> </div>
<div class="line"><span class="lineno">  300</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af955b146bc8f587c27a7d89f8bf708eb" name="af955b146bc8f587c27a7d89f8bf708eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af955b146bc8f587c27a7d89f8bf708eb">&#9670;&#160;</a></span>_izip_fields_flat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._izip_fields_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator of concatenated fields from a sequence of arrays,
collapsing any nested structure.</pre> <div class="fragment"><div class="line"><span class="lineno">  272</span><span class="keyword">def </span>_izip_fields_flat(iterable):</div>
<div class="line"><span class="lineno">  273</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    Returns an iterator of concatenated fields from a sequence of arrays,</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    collapsing any nested structure.</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  278</span>    <span class="keywordflow">for</span> element <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno">  279</span>        <span class="keywordflow">if</span> isinstance(element, np.void):</div>
<div class="line"><span class="lineno">  280</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> _izip_fields_flat(tuple(element))</div>
<div class="line"><span class="lineno">  281</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  282</span>            <span class="keywordflow">yield</span> element</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a672a93912b2501cc4320150ece67c590" name="a672a93912b2501cc4320150ece67c590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672a93912b2501cc4320150ece67c590">&#9670;&#160;</a></span>_izip_records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._izip_records </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator of concatenated items from a sequence of arrays.

Parameters
----------
seqarrays : sequence of arrays
    Sequence of arrays.
fill_value : {None, integer}
    Value used to pad shorter iterables.
flatten : {True, False},
    Whether to
</pre> <div class="fragment"><div class="line"><span class="lineno">  301</span><span class="keyword">def </span>_izip_records(seqarrays, fill_value=None, flatten=True):</div>
<div class="line"><span class="lineno">  302</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    Returns an iterator of concatenated items from a sequence of arrays.</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    seqarrays : sequence of arrays</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">        Sequence of arrays.</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    fill_value : {None, integer}</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        Value used to pad shorter iterables.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    flatten : {True, False},</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        Whether to</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>    <span class="comment"># Should we flatten the items, or just use a nested approach</span></div>
<div class="line"><span class="lineno">  316</span>    <span class="keywordflow">if</span> flatten:</div>
<div class="line"><span class="lineno">  317</span>        zipfunc = _izip_fields_flat</div>
<div class="line"><span class="lineno">  318</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  319</span>        zipfunc = _izip_fields</div>
<div class="line"><span class="lineno">  320</span> </div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">for</span> tup <span class="keywordflow">in</span> itertools.zip_longest(*seqarrays, fillvalue=fill_value):</div>
<div class="line"><span class="lineno">  322</span>        <span class="keywordflow">yield</span> tuple(zipfunc(tup))</div>
<div class="line"><span class="lineno">  323</span> </div>
<div class="line"><span class="lineno">  324</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a479e159dabfc332ee0ad1729ff68120a" name="a479e159dabfc332ee0ad1729ff68120a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479e159dabfc332ee0ad1729ff68120a">&#9670;&#160;</a></span>_join_by_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._join_by_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jointype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1postfix</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2postfix</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1387</span>        defaults=<span class="keywordtype">None</span>, usemask=<span class="keywordtype">None</span>, asrecarray=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1388</span>    <span class="keywordflow">return</span> (r1, r2)</div>
<div class="line"><span class="lineno"> 1389</span> </div>
<div class="line"><span class="lineno"> 1390</span> </div>
<div class="line"><span class="lineno"> 1391</span><span class="preprocessor">@array_function_dispatch(_join_by_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a17af78095e14793c53770ed1b69efcde" name="a17af78095e14793c53770ed1b69efcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17af78095e14793c53770ed1b69efcde">&#9670;&#160;</a></span>_keep_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._keep_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a new array keeping only the fields in `keep_names`,
and preserving the order of those fields.

Parameters
----------
base : array
    Input array
keep_names : string or sequence
    String or sequence of strings corresponding to the names of the
    fields to keep. Order of the names will be preserved.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : string or sequence, optional
    Whether to return a recarray or a mrecarray (`asrecarray=True`) or
    a plain ndarray or masked array with flexible dtype. The default
    is False.
</pre> <div class="fragment"><div class="line"><span class="lineno">  566</span><span class="keyword">def </span>_keep_fields(base, keep_names, usemask=True, asrecarray=False):</div>
<div class="line"><span class="lineno">  567</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    Return a new array keeping only the fields in `keep_names`,</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    and preserving the order of those fields.</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    base : array</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    keep_names : string or sequence</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        String or sequence of strings corresponding to the names of the</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        fields to keep. Order of the names will be preserved.</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    usemask : {False, True}, optional</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        Whether to return a masked array or not.</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    asrecarray : string or sequence, optional</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        Whether to return a recarray or a mrecarray (`asrecarray=True`) or</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        a plain ndarray or masked array with flexible dtype. The default</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        is False.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  585</span>    newdtype = [(n, base.dtype[n]) <span class="keywordflow">for</span> n <span class="keywordflow">in</span> keep_names]</div>
<div class="line"><span class="lineno">  586</span>    output = np.empty(base.shape, dtype=newdtype)</div>
<div class="line"><span class="lineno">  587</span>    output = recursive_fill_fields(base, output)</div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">return</span> _fix_output(output, usemask=usemask, asrecarray=asrecarray)</div>
<div class="line"><span class="lineno">  589</span> </div>
<div class="line"><span class="lineno">  590</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af85950f01d74892c545b7d78fc350cc2" name="af85950f01d74892c545b7d78fc350cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85950f01d74892c545b7d78fc350cc2">&#9670;&#160;</a></span>_merge_arrays_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._merge_arrays_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  357</span>                             usemask=<span class="keywordtype">None</span>, asrecarray=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  358</span>    <span class="keywordflow">return</span> seqarrays</div>
<div class="line"><span class="lineno">  359</span> </div>
<div class="line"><span class="lineno">  360</span> </div>
<div class="line"><span class="lineno">  361</span><span class="preprocessor">@array_function_dispatch(_merge_arrays_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8c84aaa1aebef93f54bb265ca852b55" name="ae8c84aaa1aebef93f54bb265ca852b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c84aaa1aebef93f54bb265ca852b55">&#9670;&#160;</a></span>_rec_append_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._rec_append_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtypes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  724</span><span class="keyword">def </span>_rec_append_fields_dispatcher(base, names, data, dtypes=None):</div>
<div class="line"><span class="lineno">  725</span>    <span class="keywordflow">yield</span> base</div>
<div class="line"><span class="lineno">  726</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> data</div>
<div class="line"><span class="lineno">  727</span> </div>
<div class="line"><span class="lineno">  728</span> </div>
<div class="line"><span class="lineno">  729</span><span class="preprocessor">@array_function_dispatch(_rec_append_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a14c1bee8534e569cda45d4ea8a001000" name="a14c1bee8534e569cda45d4ea8a001000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c1bee8534e569cda45d4ea8a001000">&#9670;&#160;</a></span>_rec_drop_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._rec_drop_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  591</span><span class="keyword">def </span>_rec_drop_fields_dispatcher(base, drop_names):</div>
<div class="line"><span class="lineno">  592</span>    <span class="keywordflow">return</span> (base,)</div>
<div class="line"><span class="lineno">  593</span> </div>
<div class="line"><span class="lineno">  594</span> </div>
<div class="line"><span class="lineno">  595</span><span class="preprocessor">@array_function_dispatch(_rec_drop_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="adfd1ba0a811167779549e7dd1bdf4ae0" name="adfd1ba0a811167779549e7dd1bdf4ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd1ba0a811167779549e7dd1bdf4ae0">&#9670;&#160;</a></span>_rec_join_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._rec_join_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jointype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1postfix</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2postfix</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1573</span>        defaults=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1574</span>    <span class="keywordflow">return</span> (r1, r2)</div>
<div class="line"><span class="lineno"> 1575</span> </div>
<div class="line"><span class="lineno"> 1576</span> </div>
<div class="line"><span class="lineno"> 1577</span><span class="preprocessor">@array_function_dispatch(_rec_join_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a387aec6d8d871ef7478aa8ba8a9759c2" name="a387aec6d8d871ef7478aa8ba8a9759c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387aec6d8d871ef7478aa8ba8a9759c2">&#9670;&#160;</a></span>_recursive_fill_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._recursive_fill_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   31</span><span class="keyword">def </span>_recursive_fill_fields_dispatcher(input, output):</div>
<div class="line"><span class="lineno">   32</span>    <span class="keywordflow">return</span> (input, output)</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span> </div>
<div class="line"><span class="lineno">   35</span><span class="preprocessor">@array_function_dispatch(_recursive_fill_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ebb945a72674f265a47b5a01e7a3598" name="a4ebb945a72674f265a47b5a01e7a3598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebb945a72674f265a47b5a01e7a3598">&#9670;&#160;</a></span>_rename_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._rename_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namemapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  603</span><span class="keyword">def </span>_rename_fields_dispatcher(base, namemapper):</div>
<div class="line"><span class="lineno">  604</span>    <span class="keywordflow">return</span> (base,)</div>
<div class="line"><span class="lineno">  605</span> </div>
<div class="line"><span class="lineno">  606</span> </div>
<div class="line"><span class="lineno">  607</span><span class="preprocessor">@array_function_dispatch(_rename_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae2cd69ddd198154001fdc5985a001131" name="ae2cd69ddd198154001fdc5985a001131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cd69ddd198154001fdc5985a001131">&#9670;&#160;</a></span>_repack_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._repack_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  764</span><span class="keyword">def </span>_repack_fields_dispatcher(a, align=None, recurse=None):</div>
<div class="line"><span class="lineno">  765</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  766</span> </div>
<div class="line"><span class="lineno">  767</span> </div>
<div class="line"><span class="lineno">  768</span><span class="preprocessor">@array_function_dispatch(_repack_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cb4c33e435e345787ce9ea6f7a10001" name="a7cb4c33e435e345787ce9ea6f7a10001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb4c33e435e345787ce9ea6f7a10001">&#9670;&#160;</a></span>_require_fields_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._require_fields_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>required_dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1182</span><span class="keyword">def </span>_require_fields_dispatcher(array, required_dtype):</div>
<div class="line"><span class="lineno"> 1183</span>    <span class="keywordflow">return</span> (array,)</div>
<div class="line"><span class="lineno"> 1184</span> </div>
<div class="line"><span class="lineno"> 1185</span><span class="preprocessor">@array_function_dispatch(_require_fields_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c1b5261a2dca09adc653821de027bcd" name="a1c1b5261a2dca09adc653821de027bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1b5261a2dca09adc653821de027bcd">&#9670;&#160;</a></span>_stack_arrays_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._stack_arrays_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>autoconvert</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1230</span>                             asrecarray=<span class="keywordtype">None</span>, autoconvert=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1231</span>    <span class="keywordflow">return</span> arrays</div>
<div class="line"><span class="lineno"> 1232</span> </div>
<div class="line"><span class="lineno"> 1233</span> </div>
<div class="line"><span class="lineno"> 1234</span><span class="preprocessor">@array_function_dispatch(_stack_arrays_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a20d165ecbeec06144021e0c80c0ce61c" name="a20d165ecbeec06144021e0c80c0ce61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d165ecbeec06144021e0c80c0ce61c">&#9670;&#160;</a></span>_structured_to_unstructured_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._structured_to_unstructured_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  890</span>                                           casting=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  891</span>    <span class="keywordflow">return</span> (arr,)</div>
<div class="line"><span class="lineno">  892</span> </div>
<div class="line"><span class="lineno">  893</span><span class="preprocessor">@array_function_dispatch(_structured_to_unstructured_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2b5bb969fa1032bfb29a2fc8f721d72" name="ab2b5bb969fa1032bfb29a2fc8f721d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b5bb969fa1032bfb29a2fc8f721d72">&#9670;&#160;</a></span>_unstructured_to_structured_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._unstructured_to_structured_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  985</span>                                           align=<span class="keywordtype">None</span>, copy=<span class="keywordtype">None</span>, casting=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  986</span>    <span class="keywordflow">return</span> (arr,)</div>
<div class="line"><span class="lineno">  987</span> </div>
<div class="line"><span class="lineno">  988</span><span class="preprocessor">@array_function_dispatch(_unstructured_to_structured_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cfbf613083ebc6e045ee1b3b9658d80" name="a7cfbf613083ebc6e045ee1b3b9658d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfbf613083ebc6e045ee1b3b9658d80">&#9670;&#160;</a></span>_zip_descr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._zip_descr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Combine the dtype description of a series of arrays.

Parameters
----------
seqarrays : sequence of arrays
    Sequence of arrays
flatten : {boolean}, optional
    Whether to collapse nested descriptions.
</pre> <div class="fragment"><div class="line"><span class="lineno">  211</span><span class="keyword">def </span>_zip_descr(seqarrays, flatten=False):</div>
<div class="line"><span class="lineno">  212</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Combine the dtype description of a series of arrays.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    seqarrays : sequence of arrays</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        Sequence of arrays</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    flatten : {boolean}, optional</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        Whether to collapse nested descriptions.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">return</span> _zip_dtype(seqarrays, flatten=flatten).descr</div>
<div class="line"><span class="lineno">  223</span> </div>
<div class="line"><span class="lineno">  224</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a29807207fc39e52d912f9f5a861197e5" name="a29807207fc39e52d912f9f5a861197e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29807207fc39e52d912f9f5a861197e5">&#9670;&#160;</a></span>_zip_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._zip_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  195</span><span class="keyword">def </span>_zip_dtype(seqarrays, flatten=False):</div>
<div class="line"><span class="lineno">  196</span>    newdtype = []</div>
<div class="line"><span class="lineno">  197</span>    <span class="keywordflow">if</span> flatten:</div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">for</span> a <span class="keywordflow">in</span> seqarrays:</div>
<div class="line"><span class="lineno">  199</span>            newdtype.extend(flatten_descr(a.dtype))</div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  201</span>        <span class="keywordflow">for</span> a <span class="keywordflow">in</span> seqarrays:</div>
<div class="line"><span class="lineno">  202</span>            current = a.dtype</div>
<div class="line"><span class="lineno">  203</span>            <span class="keywordflow">if</span> current.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> len(current.names) == 1:</div>
<div class="line"><span class="lineno">  204</span>                <span class="comment"># special case - dtypes of 1 field are flattened</span></div>
<div class="line"><span class="lineno">  205</span>                newdtype.extend(_get_fieldspec(current))</div>
<div class="line"><span class="lineno">  206</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  207</span>                newdtype.append((<span class="stringliteral">&#39;&#39;</span>, current))</div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordflow">return</span> np.dtype(newdtype)</div>
<div class="line"><span class="lineno">  209</span> </div>
<div class="line"><span class="lineno">  210</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae732743ba095cb0a97350329d62fa733" name="ae732743ba095cb0a97350329d62fa733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae732743ba095cb0a97350329d62fa733">&#9670;&#160;</a></span>append_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.append_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtypes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add new fields to an existing array.

The names of the fields are given with the `names` arguments,
the corresponding values with the `data` arguments.
If a single field is appended, `names`, `data` and `dtypes` do not have
to be lists but just values.

Parameters
----------
base : array
    Input array to extend.
names : string, sequence
    String or sequence of strings corresponding to the names
    of the new fields.
data : array or sequence of arrays
    Array or sequence of arrays storing the fields to add to the base.
dtypes : sequence of datatypes, optional
    Datatype or sequence of datatypes.
    If None, the datatypes are estimated from the `data`.
fill_value : {float}, optional
    Filling value used to pad missing data on the shorter arrays.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : {False, True}, optional
    Whether to return a recarray (MaskedRecords) or not.</pre> <div class="fragment"><div class="line"><span class="lineno">  655</span>                  fill_value=-1, usemask=<span class="keyword">True</span>, asrecarray=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  656</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    Add new fields to an existing array.</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    The names of the fields are given with the `names` arguments,</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    the corresponding values with the `data` arguments.</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    If a single field is appended, `names`, `data` and `dtypes` do not have</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    to be lists but just values.</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    base : array</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">        Input array to extend.</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    names : string, sequence</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">        String or sequence of strings corresponding to the names</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        of the new fields.</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    data : array or sequence of arrays</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        Array or sequence of arrays storing the fields to add to the base.</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    dtypes : sequence of datatypes, optional</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">        Datatype or sequence of datatypes.</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">        If None, the datatypes are estimated from the `data`.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    fill_value : {float}, optional</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        Filling value used to pad missing data on the shorter arrays.</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    usemask : {False, True}, optional</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">        Whether to return a masked array or not.</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    asrecarray : {False, True}, optional</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">        Whether to return a recarray (MaskedRecords) or not.</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  684</span>    <span class="comment"># Check the names</span></div>
<div class="line"><span class="lineno">  685</span>    <span class="keywordflow">if</span> isinstance(names, (tuple, list)):</div>
<div class="line"><span class="lineno">  686</span>        <span class="keywordflow">if</span> len(names) != len(data):</div>
<div class="line"><span class="lineno">  687</span>            msg = <span class="stringliteral">&quot;The number of arrays does not match the number of names&quot;</span></div>
<div class="line"><span class="lineno">  688</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  689</span>    <span class="keywordflow">elif</span> isinstance(names, str):</div>
<div class="line"><span class="lineno">  690</span>        names = [names, ]</div>
<div class="line"><span class="lineno">  691</span>        data = [data, ]</div>
<div class="line"><span class="lineno">  692</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  693</span>    <span class="keywordflow">if</span> dtypes <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  694</span>        data = [np.array(a, copy=<span class="keyword">False</span>, subok=<span class="keyword">True</span>) <span class="keywordflow">for</span> a <span class="keywordflow">in</span> data]</div>
<div class="line"><span class="lineno">  695</span>        data = [a.view([(name, a.dtype)]) <span class="keywordflow">for</span> (name, a) <span class="keywordflow">in</span> zip(names, data)]</div>
<div class="line"><span class="lineno">  696</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  697</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtypes, (tuple, list)):</div>
<div class="line"><span class="lineno">  698</span>            dtypes = [dtypes, ]</div>
<div class="line"><span class="lineno">  699</span>        <span class="keywordflow">if</span> len(data) != len(dtypes):</div>
<div class="line"><span class="lineno">  700</span>            <span class="keywordflow">if</span> len(dtypes) == 1:</div>
<div class="line"><span class="lineno">  701</span>                dtypes = dtypes * len(data)</div>
<div class="line"><span class="lineno">  702</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  703</span>                msg = <span class="stringliteral">&quot;The dtypes argument must be None, a dtype, or a list.&quot;</span></div>
<div class="line"><span class="lineno">  704</span>                <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  705</span>        data = [np.array(a, copy=<span class="keyword">False</span>, subok=<span class="keyword">True</span>, dtype=d).view([(n, d)])</div>
<div class="line"><span class="lineno">  706</span>                <span class="keywordflow">for</span> (a, n, d) <span class="keywordflow">in</span> zip(data, names, dtypes)]</div>
<div class="line"><span class="lineno">  707</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  708</span>    base = merge_arrays(base, usemask=usemask, fill_value=fill_value)</div>
<div class="line"><span class="lineno">  709</span>    <span class="keywordflow">if</span> len(data) &gt; 1:</div>
<div class="line"><span class="lineno">  710</span>        data = merge_arrays(data, flatten=<span class="keyword">True</span>, usemask=usemask,</div>
<div class="line"><span class="lineno">  711</span>                            fill_value=fill_value)</div>
<div class="line"><span class="lineno">  712</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  713</span>        data = data.pop()</div>
<div class="line"><span class="lineno">  714</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  715</span>    output = ma.masked_all(</div>
<div class="line"><span class="lineno">  716</span>        max(len(base), len(data)),</div>
<div class="line"><span class="lineno">  717</span>        dtype=_get_fieldspec(base.dtype) + _get_fieldspec(data.dtype))</div>
<div class="line"><span class="lineno">  718</span>    output = recursive_fill_fields(base, output)</div>
<div class="line"><span class="lineno">  719</span>    output = recursive_fill_fields(data, output)</div>
<div class="line"><span class="lineno">  720</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  721</span>    <span class="keywordflow">return</span> _fix_output(output, usemask=usemask, asrecarray=asrecarray)</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1007358718aaef87542737ba47ec1ecd" name="a1007358718aaef87542737ba47ec1ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1007358718aaef87542737ba47ec1ecd">&#9670;&#160;</a></span>apply_along_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.apply_along_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply function 'func' as a reduction across fields of a structured array.

This is similar to `apply_along_axis`, but treats the fields of a
structured array as an extra axis. The fields are all first cast to a
common type following the type-promotion rules from `numpy.result_type`
applied to the field's dtypes.

Parameters
----------
func : function
   Function to apply on the "field" dimension. This function must
   support an `axis` argument, like np.mean, np.sum, etc.
arr : ndarray
   Structured array for which to apply func.

Returns
-------
out : ndarray
   Result of the recution operation

Examples
--------

&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],
...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])
&gt;&gt;&gt; rfn.apply_along_fields(np.mean, b)
array([ 2.66666667,  5.33333333,  8.66666667, 11.        ])
&gt;&gt;&gt; rfn.apply_along_fields(np.mean, b[['x', 'z']])
array([ 3. ,  5.5,  9. , 11. ])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1099</span><span class="keyword">def </span>apply_along_fields(func, arr):</div>
<div class="line"><span class="lineno"> 1100</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    Apply function &#39;func&#39; as a reduction across fields of a structured array.</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    This is similar to `apply_along_axis`, but treats the fields of a</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    structured array as an extra axis. The fields are all first cast to a</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">    common type following the type-promotion rules from `numpy.result_type`</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    applied to the field&#39;s dtypes.</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    func : function</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">       Function to apply on the &quot;field&quot; dimension. This function must</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">       support an `axis` argument, like np.mean, np.sum, etc.</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">    arr : ndarray</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">       Structured array for which to apply func.</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">       Result of the recution operation</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    ...              dtype=[(&#39;x&#39;, &#39;i4&#39;), (&#39;y&#39;, &#39;f4&#39;), (&#39;z&#39;, &#39;f8&#39;)])</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    &gt;&gt;&gt; rfn.apply_along_fields(np.mean, b)</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    array([ 2.66666667,  5.33333333,  8.66666667, 11.        ])</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    &gt;&gt;&gt; rfn.apply_along_fields(np.mean, b[[&#39;x&#39;, &#39;z&#39;]])</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    array([ 3. ,  5.5,  9. , 11. ])</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1133</span>    <span class="keywordflow">if</span> arr.dtype.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1134</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;arr must be a structured array&#39;</span>)</div>
<div class="line"><span class="lineno"> 1135</span> </div>
<div class="line"><span class="lineno"> 1136</span>    uarr = structured_to_unstructured(arr)</div>
<div class="line"><span class="lineno"> 1137</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(uarr, axis=-1)</div>
<div class="line"><span class="lineno"> 1138</span>    <span class="comment"># works and avoids axis requirement, but very, very slow:</span></div>
<div class="line"><span class="lineno"> 1139</span>    <span class="comment">#return np.apply_along_axis(func, -1, uarr)</span></div>
<div class="line"><span class="lineno"> 1140</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2409ada76e5f1822177649010235d734" name="a2409ada76e5f1822177649010235d734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2409ada76e5f1822177649010235d734">&#9670;&#160;</a></span>assign_fields_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.assign_fields_by_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zero_unassigned</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assigns values from one structured array to another by field name.

Normally in numpy &gt;= 1.14, assignment of one structured array to another
copies fields "by position", meaning that the first field from the src is
copied to the first field of the dst, and so on, regardless of field name.

This function instead copies "by field name", such that fields in the dst
are assigned from the identically named field in the src. This applies
recursively for nested structures. This is how structure assignment worked
in numpy &gt;= 1.6 to &lt;= 1.13.

Parameters
----------
dst : ndarray
src : ndarray
    The source and destination arrays during assignment.
zero_unassigned : bool, optional
    If True, fields in the dst for which there was no matching
    field in the src are filled with the value 0 (zero). This
    was the behavior of numpy &lt;= 1.13. If False, those fields
    are not modified.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1145</span><span class="keyword">def </span>assign_fields_by_name(dst, src, zero_unassigned=True):</div>
<div class="line"><span class="lineno"> 1146</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">    Assigns values from one structured array to another by field name.</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    Normally in numpy &gt;= 1.14, assignment of one structured array to another</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    copies fields &quot;by position&quot;, meaning that the first field from the src is</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    copied to the first field of the dst, and so on, regardless of field name.</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    This function instead copies &quot;by field name&quot;, such that fields in the dst</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    are assigned from the identically named field in the src. This applies</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    recursively for nested structures. This is how structure assignment worked</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    in numpy &gt;= 1.6 to &lt;= 1.13.</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    dst : ndarray</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    src : ndarray</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">        The source and destination arrays during assignment.</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    zero_unassigned : bool, optional</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">        If True, fields in the dst for which there was no matching</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">        field in the src are filled with the value 0 (zero). This</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">        was the behavior of numpy &lt;= 1.13. If False, those fields</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">        are not modified.</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1169</span> </div>
<div class="line"><span class="lineno"> 1170</span>    <span class="keywordflow">if</span> dst.dtype.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1171</span>        dst[...] = src</div>
<div class="line"><span class="lineno"> 1172</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1173</span> </div>
<div class="line"><span class="lineno"> 1174</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> dst.dtype.names:</div>
<div class="line"><span class="lineno"> 1175</span>        <span class="keywordflow">if</span> name <span class="keywordflow">not</span> <span class="keywordflow">in</span> src.dtype.names:</div>
<div class="line"><span class="lineno"> 1176</span>            <span class="keywordflow">if</span> zero_unassigned:</div>
<div class="line"><span class="lineno"> 1177</span>                dst[name] = 0</div>
<div class="line"><span class="lineno"> 1178</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1179</span>            assign_fields_by_name(dst[name], src[name],</div>
<div class="line"><span class="lineno"> 1180</span>                                  zero_unassigned)</div>
<div class="line"><span class="lineno"> 1181</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ab71eaa6a3e94dfe27511c1ede12c5e" name="a1ab71eaa6a3e94dfe27511c1ede12c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab71eaa6a3e94dfe27511c1ede12c5e">&#9670;&#160;</a></span>drop_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.drop_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new array with fields in `drop_names` dropped.

Nested fields are supported.

.. versionchanged:: 1.18.0
    `drop_fields` returns an array with 0 fields if all fields are dropped,
    rather than returning ``None`` as it did previously.

Parameters
----------
base : array
    Input array
drop_names : string or sequence
    String or sequence of strings corresponding to the names of the
    fields to drop.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : string or sequence, optional
    Whether to return a recarray or a mrecarray (`asrecarray=True`) or
    a plain ndarray or masked array with flexible dtype. The default
    is False.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.array([(1, (2, 3.0)), (4, (5, 6.0))],
...   dtype=[('a', np.int64), ('b', [('ba', np.double), ('bb', np.int64)])])
&gt;&gt;&gt; rfn.drop_fields(a, 'a')
array([((2., 3),), ((5., 6),)],
      dtype=[('b', [('ba', '&lt;f8'), ('bb', '&lt;i8')])])
&gt;&gt;&gt; rfn.drop_fields(a, 'ba')
array([(1, (3,)), (4, (6,))], dtype=[('a', '&lt;i8'), ('b', [('bb', '&lt;i8')])])
&gt;&gt;&gt; rfn.drop_fields(a, ['ba', 'bb'])
array([(1,), (4,)], dtype=[('a', '&lt;i8')])
</pre> <div class="fragment"><div class="line"><span class="lineno">  502</span><span class="keyword">def </span>drop_fields(base, drop_names, usemask=True, asrecarray=False):</div>
<div class="line"><span class="lineno">  503</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    Return a new array with fields in `drop_names` dropped.</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    Nested fields are supported.</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    .. versionchanged:: 1.18.0</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        `drop_fields` returns an array with 0 fields if all fields are dropped,</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        rather than returning ``None`` as it did previously.</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    base : array</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    drop_names : string or sequence</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        String or sequence of strings corresponding to the names of the</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">        fields to drop.</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    usemask : {False, True}, optional</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        Whether to return a masked array or not.</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    asrecarray : string or sequence, optional</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        Whether to return a recarray or a mrecarray (`asrecarray=True`) or</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        a plain ndarray or masked array with flexible dtype. The default</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        is False.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([(1, (2, 3.0)), (4, (5, 6.0))],</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    ...   dtype=[(&#39;a&#39;, np.int64), (&#39;b&#39;, [(&#39;ba&#39;, np.double), (&#39;bb&#39;, np.int64)])])</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    &gt;&gt;&gt; rfn.drop_fields(a, &#39;a&#39;)</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    array([((2., 3),), ((5., 6),)],</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">          dtype=[(&#39;b&#39;, [(&#39;ba&#39;, &#39;&lt;f8&#39;), (&#39;bb&#39;, &#39;&lt;i8&#39;)])])</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    &gt;&gt;&gt; rfn.drop_fields(a, &#39;ba&#39;)</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    array([(1, (3,)), (4, (6,))], dtype=[(&#39;a&#39;, &#39;&lt;i8&#39;), (&#39;b&#39;, [(&#39;bb&#39;, &#39;&lt;i8&#39;)])])</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    &gt;&gt;&gt; rfn.drop_fields(a, [&#39;ba&#39;, &#39;bb&#39;])</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    array([(1,), (4,)], dtype=[(&#39;a&#39;, &#39;&lt;i8&#39;)])</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  539</span>    <span class="keywordflow">if</span> _is_string_like(drop_names):</div>
<div class="line"><span class="lineno">  540</span>        drop_names = [drop_names]</div>
<div class="line"><span class="lineno">  541</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  542</span>        drop_names = set(drop_names)</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  544</span>    <span class="keyword">def </span>_drop_descr(ndtype, drop_names):</div>
<div class="line"><span class="lineno">  545</span>        names = ndtype.names</div>
<div class="line"><span class="lineno">  546</span>        newdtype = []</div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">for</span> name <span class="keywordflow">in</span> names:</div>
<div class="line"><span class="lineno">  548</span>            current = ndtype[name]</div>
<div class="line"><span class="lineno">  549</span>            <span class="keywordflow">if</span> name <span class="keywordflow">in</span> drop_names:</div>
<div class="line"><span class="lineno">  550</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  551</span>            <span class="keywordflow">if</span> current.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  552</span>                descr = _drop_descr(current, drop_names)</div>
<div class="line"><span class="lineno">  553</span>                <span class="keywordflow">if</span> descr:</div>
<div class="line"><span class="lineno">  554</span>                    newdtype.append((name, descr))</div>
<div class="line"><span class="lineno">  555</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  556</span>                newdtype.append((name, current))</div>
<div class="line"><span class="lineno">  557</span>        <span class="keywordflow">return</span> newdtype</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>    newdtype = _drop_descr(base.dtype, drop_names)</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>    output = np.empty(base.shape, dtype=newdtype)</div>
<div class="line"><span class="lineno">  562</span>    output = recursive_fill_fields(base, output)</div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">return</span> _fix_output(output, usemask=usemask, asrecarray=asrecarray)</div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a56865e10b7543760aa15f9e28644ba33" name="a56865e10b7543760aa15f9e28644ba33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56865e10b7543760aa15f9e28644ba33">&#9670;&#160;</a></span>find_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.find_duplicates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ignoremask</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_index</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the duplicates in a structured array along a given key

Parameters
----------
a : array-like
    Input array
key : {string, None}, optional
    Name of the fields along which to check the duplicates.
    If None, the search is performed by records
ignoremask : {True, False}, optional
    Whether masked data should be discarded or considered as duplicates.
return_index : {False, True}, optional
    Whether to return the indices of the duplicated values.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; ndtype = [('a', int)]
&gt;&gt;&gt; a = np.ma.array([1, 1, 1, 2, 2, 3, 3],
...         mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype)
&gt;&gt;&gt; rfn.find_duplicates(a, ignoremask=True, return_index=True)
(masked_array(data=[(1,), (1,), (2,), (2,)],
             mask=[(False,), (False,), (False,), (False,)],
       fill_value=(999999,),
            dtype=[('a', '&lt;i8')]), array([0, 1, 3, 4]))
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1328</span><span class="keyword">def </span>find_duplicates(a, key=None, ignoremask=True, return_index=False):</div>
<div class="line"><span class="lineno"> 1329</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    Find the duplicates in a structured array along a given key</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    a : array-like</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    key : {string, None}, optional</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">        Name of the fields along which to check the duplicates.</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">        If None, the search is performed by records</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">    ignoremask : {True, False}, optional</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">        Whether masked data should be discarded or considered as duplicates.</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    return_index : {False, True}, optional</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">        Whether to return the indices of the duplicated values.</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &gt;&gt;&gt; ndtype = [(&#39;a&#39;, int)]</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    &gt;&gt;&gt; a = np.ma.array([1, 1, 1, 2, 2, 3, 3],</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    ...         mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype)</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    &gt;&gt;&gt; rfn.find_duplicates(a, ignoremask=True, return_index=True)</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    (masked_array(data=[(1,), (1,), (2,), (2,)],</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">                 mask=[(False,), (False,), (False,), (False,)],</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">           fill_value=(999999,),</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">                dtype=[(&#39;a&#39;, &#39;&lt;i8&#39;)]), array([0, 1, 3, 4]))</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1356</span>    a = np.asanyarray(a).ravel()</div>
<div class="line"><span class="lineno"> 1357</span>    <span class="comment"># Get a dictionary of fields</span></div>
<div class="line"><span class="lineno"> 1358</span>    fields = get_fieldstructure(a.dtype)</div>
<div class="line"><span class="lineno"> 1359</span>    <span class="comment"># Get the sorting data (by selecting the corresponding field)</span></div>
<div class="line"><span class="lineno"> 1360</span>    base = a</div>
<div class="line"><span class="lineno"> 1361</span>    <span class="keywordflow">if</span> key:</div>
<div class="line"><span class="lineno"> 1362</span>        <span class="keywordflow">for</span> f <span class="keywordflow">in</span> fields[key]:</div>
<div class="line"><span class="lineno"> 1363</span>            base = base[f]</div>
<div class="line"><span class="lineno"> 1364</span>        base = base[key]</div>
<div class="line"><span class="lineno"> 1365</span>    <span class="comment"># Get the sorting indices and the sorted data</span></div>
<div class="line"><span class="lineno"> 1366</span>    sortidx = base.argsort()</div>
<div class="line"><span class="lineno"> 1367</span>    sortedbase = base[sortidx]</div>
<div class="line"><span class="lineno"> 1368</span>    sorteddata = sortedbase.filled()</div>
<div class="line"><span class="lineno"> 1369</span>    <span class="comment"># Compare the sorting data</span></div>
<div class="line"><span class="lineno"> 1370</span>    flag = (sorteddata[:-1] == sorteddata[1:])</div>
<div class="line"><span class="lineno"> 1371</span>    <span class="comment"># If masked data must be ignored, set the flag to false where needed</span></div>
<div class="line"><span class="lineno"> 1372</span>    <span class="keywordflow">if</span> ignoremask:</div>
<div class="line"><span class="lineno"> 1373</span>        sortedmask = sortedbase.recordmask</div>
<div class="line"><span class="lineno"> 1374</span>        flag[sortedmask[1:]] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1375</span>    flag = np.concatenate(([<span class="keyword">False</span>], flag))</div>
<div class="line"><span class="lineno"> 1376</span>    <span class="comment"># We need to take the point on the left as well (else we&#39;re missing it)</span></div>
<div class="line"><span class="lineno"> 1377</span>    flag[:-1] = flag[:-1] + flag[1:]</div>
<div class="line"><span class="lineno"> 1378</span>    duplicates = a[sortidx][flag]</div>
<div class="line"><span class="lineno"> 1379</span>    <span class="keywordflow">if</span> return_index:</div>
<div class="line"><span class="lineno"> 1380</span>        <span class="keywordflow">return</span> (duplicates, sortidx[flag])</div>
<div class="line"><span class="lineno"> 1381</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1382</span>        <span class="keywordflow">return</span> duplicates</div>
<div class="line"><span class="lineno"> 1383</span> </div>
<div class="line"><span class="lineno"> 1384</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a99815b0b69df567b202aeb68723e796c" name="a99815b0b69df567b202aeb68723e796c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99815b0b69df567b202aeb68723e796c">&#9670;&#160;</a></span>flatten_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.flatten_descr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flatten a structured data-type description.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; ndtype = np.dtype([('a', '&lt;i4'), ('b', [('ba', '&lt;f8'), ('bb', '&lt;i4')])])
&gt;&gt;&gt; rfn.flatten_descr(ndtype)
(('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32')))</pre> <div class="fragment"><div class="line"><span class="lineno">  169</span><span class="keyword">def </span>flatten_descr(ndtype):</div>
<div class="line"><span class="lineno">  170</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    Flatten a structured data-type description.</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    &gt;&gt;&gt; ndtype = np.dtype([(&#39;a&#39;, &#39;&lt;i4&#39;), (&#39;b&#39;, [(&#39;ba&#39;, &#39;&lt;f8&#39;), (&#39;bb&#39;, &#39;&lt;i4&#39;)])])</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    &gt;&gt;&gt; rfn.flatten_descr(ndtype)</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    ((&#39;a&#39;, dtype(&#39;int32&#39;)), (&#39;ba&#39;, dtype(&#39;float64&#39;)), (&#39;bb&#39;, dtype(&#39;int32&#39;)))</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  181</span>    names = ndtype.names</div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  183</span>        <span class="keywordflow">return</span> ((<span class="stringliteral">&#39;&#39;</span>, ndtype),)</div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  185</span>        descr = []</div>
<div class="line"><span class="lineno">  186</span>        <span class="keywordflow">for</span> field <span class="keywordflow">in</span> names:</div>
<div class="line"><span class="lineno">  187</span>            (typ, _) = ndtype.fields[field]</div>
<div class="line"><span class="lineno">  188</span>            <span class="keywordflow">if</span> typ.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  189</span>                descr.extend(flatten_descr(typ))</div>
<div class="line"><span class="lineno">  190</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  191</span>                descr.append((field, typ))</div>
<div class="line"><span class="lineno">  192</span>        <span class="keywordflow">return</span> tuple(descr)</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aabcda6778d6440c8d4d9450f04ea77c6" name="aabcda6778d6440c8d4d9450f04ea77c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcda6778d6440c8d4d9450f04ea77c6">&#9670;&#160;</a></span>get_fieldstructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.get_fieldstructure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lastname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parents</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a dictionary with fields indexing lists of their parent fields.

This function is used to simplify access to fields nested in other fields.

Parameters
----------
adtype : np.dtype
    Input datatype
lastname : optional
    Last processed field name (used internally during recursion).
parents : dictionary
    Dictionary of parent fields (used interbally during recursion).

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; ndtype =  np.dtype([('A', int),
...                     ('B', [('BA', int),
...                            ('BB', [('BBA', int), ('BBB', int)])])])
&gt;&gt;&gt; rfn.get_fieldstructure(ndtype)
... # XXX: possible regression, order of BBA and BBB is swapped
{'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']}</pre> <div class="fragment"><div class="line"><span class="lineno">  225</span><span class="keyword">def </span>get_fieldstructure(adtype, lastname=None, parents=None,):</div>
<div class="line"><span class="lineno">  226</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    Returns a dictionary with fields indexing lists of their parent fields.</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    This function is used to simplify access to fields nested in other fields.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    adtype : np.dtype</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        Input datatype</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    lastname : optional</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        Last processed field name (used internally during recursion).</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    parents : dictionary</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        Dictionary of parent fields (used interbally during recursion).</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    &gt;&gt;&gt; ndtype =  np.dtype([(&#39;A&#39;, int),</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    ...                     (&#39;B&#39;, [(&#39;BA&#39;, int),</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    ...                            (&#39;BB&#39;, [(&#39;BBA&#39;, int), (&#39;BBB&#39;, int)])])])</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    &gt;&gt;&gt; rfn.get_fieldstructure(ndtype)</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    ... # XXX: possible regression, order of BBA and BBB is swapped</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    {&#39;A&#39;: [], &#39;B&#39;: [], &#39;BA&#39;: [&#39;B&#39;], &#39;BB&#39;: [&#39;B&#39;], &#39;BBA&#39;: [&#39;B&#39;, &#39;BB&#39;], &#39;BBB&#39;: [&#39;B&#39;, &#39;BB&#39;]}</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  251</span>    <span class="keywordflow">if</span> parents <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  252</span>        parents = {}</div>
<div class="line"><span class="lineno">  253</span>    names = adtype.names</div>
<div class="line"><span class="lineno">  254</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> names:</div>
<div class="line"><span class="lineno">  255</span>        current = adtype[name]</div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordflow">if</span> current.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  257</span>            <span class="keywordflow">if</span> lastname:</div>
<div class="line"><span class="lineno">  258</span>                parents[name] = [lastname, ]</div>
<div class="line"><span class="lineno">  259</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  260</span>                parents[name] = []</div>
<div class="line"><span class="lineno">  261</span>            parents.update(get_fieldstructure(current, name, parents))</div>
<div class="line"><span class="lineno">  262</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  263</span>            lastparent = [_ <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> (parents.get(lastname, []) <span class="keywordflow">or</span> [])]</div>
<div class="line"><span class="lineno">  264</span>            <span class="keywordflow">if</span> lastparent:</div>
<div class="line"><span class="lineno">  265</span>                lastparent.append(lastname)</div>
<div class="line"><span class="lineno">  266</span>            <span class="keywordflow">elif</span> lastname:</div>
<div class="line"><span class="lineno">  267</span>                lastparent = [lastname, ]</div>
<div class="line"><span class="lineno">  268</span>            parents[name] = lastparent <span class="keywordflow">or</span> []</div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordflow">return</span> parents</div>
<div class="line"><span class="lineno">  270</span> </div>
<div class="line"><span class="lineno">  271</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adc07457ddc639c4f60e1625582a6df2f" name="adc07457ddc639c4f60e1625582a6df2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc07457ddc639c4f60e1625582a6df2f">&#9670;&#160;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.get_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the field names of the input datatype as a tuple. Input datatype
must have fields otherwise error is raised.

Parameters
----------
adtype : dtype
    Input datatype

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=[('A', int)]).dtype)
('A',)
&gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=[('A',int), ('B', float)]).dtype)
('A', 'B')
&gt;&gt;&gt; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])
&gt;&gt;&gt; rfn.get_names(adtype)
('a', ('b', ('ba', 'bb')))
</pre> <div class="fragment"><div class="line"><span class="lineno">  105</span><span class="keyword">def </span>get_names(adtype):</div>
<div class="line"><span class="lineno">  106</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    Returns the field names of the input datatype as a tuple. Input datatype</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    must have fields otherwise error is raised.</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    adtype : dtype</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        Input datatype</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=[(&#39;A&#39;, int)]).dtype)</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    (&#39;A&#39;,)</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=[(&#39;A&#39;,int), (&#39;B&#39;, float)]).dtype)</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    (&#39;A&#39;, &#39;B&#39;)</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    &gt;&gt;&gt; adtype = np.dtype([(&#39;a&#39;, int), (&#39;b&#39;, [(&#39;ba&#39;, int), (&#39;bb&#39;, int)])])</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    &gt;&gt;&gt; rfn.get_names(adtype)</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    (&#39;a&#39;, (&#39;b&#39;, (&#39;ba&#39;, &#39;bb&#39;)))</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  126</span>    listnames = []</div>
<div class="line"><span class="lineno">  127</span>    names = adtype.names</div>
<div class="line"><span class="lineno">  128</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> names:</div>
<div class="line"><span class="lineno">  129</span>        current = adtype[name]</div>
<div class="line"><span class="lineno">  130</span>        <span class="keywordflow">if</span> current.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  131</span>            listnames.append((name, tuple(get_names(current))))</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  133</span>            listnames.append(name)</div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordflow">return</span> tuple(listnames)</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a592f880c5cab6a2b538aed975092f14d" name="a592f880c5cab6a2b538aed975092f14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592f880c5cab6a2b538aed975092f14d">&#9670;&#160;</a></span>get_names_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.get_names_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the field names of the input datatype as a tuple. Input datatype
must have fields otherwise error is raised.
Nested structure are flattened beforehand.

Parameters
----------
adtype : dtype
    Input datatype

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=[('A', int)]).dtype) is None
False
&gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=[('A',int), ('B', str)]).dtype)
('A', 'B')
&gt;&gt;&gt; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])
&gt;&gt;&gt; rfn.get_names_flat(adtype)
('a', 'b', 'ba', 'bb')
</pre> <div class="fragment"><div class="line"><span class="lineno">  137</span><span class="keyword">def </span>get_names_flat(adtype):</div>
<div class="line"><span class="lineno">  138</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    Returns the field names of the input datatype as a tuple. Input datatype</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    must have fields otherwise error is raised.</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    Nested structure are flattened beforehand.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    adtype : dtype</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">        Input datatype</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    &gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=[(&#39;A&#39;, int)]).dtype) is None</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    &gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=[(&#39;A&#39;,int), (&#39;B&#39;, str)]).dtype)</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    (&#39;A&#39;, &#39;B&#39;)</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    &gt;&gt;&gt; adtype = np.dtype([(&#39;a&#39;, int), (&#39;b&#39;, [(&#39;ba&#39;, int), (&#39;bb&#39;, int)])])</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    &gt;&gt;&gt; rfn.get_names_flat(adtype)</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    (&#39;a&#39;, &#39;b&#39;, &#39;ba&#39;, &#39;bb&#39;)</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  159</span>    listnames = []</div>
<div class="line"><span class="lineno">  160</span>    names = adtype.names</div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> names:</div>
<div class="line"><span class="lineno">  162</span>        listnames.append(name)</div>
<div class="line"><span class="lineno">  163</span>        current = adtype[name]</div>
<div class="line"><span class="lineno">  164</span>        <span class="keywordflow">if</span> current.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  165</span>            listnames.extend(get_names_flat(current))</div>
<div class="line"><span class="lineno">  166</span>    <span class="keywordflow">return</span> tuple(listnames)</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a018486f6c13170fb4c26809fff5409d8" name="a018486f6c13170fb4c26809fff5409d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018486f6c13170fb4c26809fff5409d8">&#9670;&#160;</a></span>join_by()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.join_by </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jointype</em> = <code>'inner'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1postfix</em> = <code>'1'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2postfix</em> = <code>'2'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Join arrays `r1` and `r2` on key `key`.

The key should be either a string or a sequence of string corresponding
to the fields used to join the array.  An exception is raised if the
`key` field cannot be found in the two input arrays.  Neither `r1` nor
`r2` should have any duplicates along `key`: the presence of duplicates
will make the output quite unreliable. Note that duplicates are not
looked for by the algorithm.

Parameters
----------
key : {string, sequence}
    A string or a sequence of strings corresponding to the fields used
    for comparison.
r1, r2 : arrays
    Structured arrays.
jointype : {'inner', 'outer', 'leftouter'}, optional
    If 'inner', returns the elements common to both r1 and r2.
    If 'outer', returns the common elements as well as the elements of
    r1 not in r2 and the elements of not in r2.
    If 'leftouter', returns the common elements and the elements of r1
    not in r2.
r1postfix : string, optional
    String appended to the names of the fields of r1 that are present
    in r2 but absent of the key.
r2postfix : string, optional
    String appended to the names of the fields of r2 that are present
    in r1 but absent of the key.
defaults : {dictionary}, optional
    Dictionary mapping field names to the corresponding default values.
usemask : {True, False}, optional
    Whether to return a MaskedArray (or MaskedRecords is
    `asrecarray==True`) or a ndarray.
asrecarray : {False, True}, optional
    Whether to return a recarray (or MaskedRecords if `usemask==True`)
    or just a flexible-type ndarray.

Notes
-----
* The output is sorted along the key.
* A temporary array is formed by dropping the fields not in the key for
  the two arrays and concatenating the result. This array is then
  sorted, and the common entries selected. The output is constructed by
  filling the fields with the selected entries. Matching is not
  preserved if there are some duplicates...</pre> <div class="fragment"><div class="line"><span class="lineno"> 1393</span>            defaults=<span class="keywordtype">None</span>, usemask=<span class="keyword">True</span>, asrecarray=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 1394</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    Join arrays `r1` and `r2` on key `key`.</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    The key should be either a string or a sequence of string corresponding</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">    to the fields used to join the array.  An exception is raised if the</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">    `key` field cannot be found in the two input arrays.  Neither `r1` nor</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    `r2` should have any duplicates along `key`: the presence of duplicates</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">    will make the output quite unreliable. Note that duplicates are not</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    looked for by the algorithm.</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    key : {string, sequence}</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">        A string or a sequence of strings corresponding to the fields used</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">        for comparison.</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    r1, r2 : arrays</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">        Structured arrays.</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    jointype : {&#39;inner&#39;, &#39;outer&#39;, &#39;leftouter&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">        If &#39;inner&#39;, returns the elements common to both r1 and r2.</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">        If &#39;outer&#39;, returns the common elements as well as the elements of</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">        r1 not in r2 and the elements of not in r2.</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">        If &#39;leftouter&#39;, returns the common elements and the elements of r1</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">        not in r2.</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    r1postfix : string, optional</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">        String appended to the names of the fields of r1 that are present</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">        in r2 but absent of the key.</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">    r2postfix : string, optional</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">        String appended to the names of the fields of r2 that are present</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">        in r1 but absent of the key.</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    defaults : {dictionary}, optional</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">        Dictionary mapping field names to the corresponding default values.</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    usemask : {True, False}, optional</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">        Whether to return a MaskedArray (or MaskedRecords is</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">        `asrecarray==True`) or a ndarray.</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    asrecarray : {False, True}, optional</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">        Whether to return a recarray (or MaskedRecords if `usemask==True`)</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">        or just a flexible-type ndarray.</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    * The output is sorted along the key.</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    * A temporary array is formed by dropping the fields not in the key for</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">      the two arrays and concatenating the result. This array is then</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">      sorted, and the common entries selected. The output is constructed by</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">      filling the fields with the selected entries. Matching is not</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">      preserved if there are some duplicates...</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1442</span>    <span class="comment"># Check jointype</span></div>
<div class="line"><span class="lineno"> 1443</span>    <span class="keywordflow">if</span> jointype <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;inner&#39;</span>, <span class="stringliteral">&#39;outer&#39;</span>, <span class="stringliteral">&#39;leftouter&#39;</span>):</div>
<div class="line"><span class="lineno"> 1444</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1445</span>                <span class="stringliteral">&quot;The &#39;jointype&#39; argument should be in &#39;inner&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 1446</span>                <span class="stringliteral">&quot;&#39;outer&#39; or &#39;leftouter&#39; (got &#39;%s&#39; instead)&quot;</span> % jointype</div>
<div class="line"><span class="lineno"> 1447</span>                )</div>
<div class="line"><span class="lineno"> 1448</span>    <span class="comment"># If we have a single key, put it in a tuple</span></div>
<div class="line"><span class="lineno"> 1449</span>    <span class="keywordflow">if</span> isinstance(key, str):</div>
<div class="line"><span class="lineno"> 1450</span>        key = (key,)</div>
<div class="line"><span class="lineno"> 1451</span> </div>
<div class="line"><span class="lineno"> 1452</span>    <span class="comment"># Check the keys</span></div>
<div class="line"><span class="lineno"> 1453</span>    <span class="keywordflow">if</span> len(set(key)) != len(key):</div>
<div class="line"><span class="lineno"> 1454</span>        dup = next(x <span class="keywordflow">for</span> n,x <span class="keywordflow">in</span> enumerate(key) <span class="keywordflow">if</span> x <span class="keywordflow">in</span> key[n+1:])</div>
<div class="line"><span class="lineno"> 1455</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;duplicate join key %r&quot;</span> % dup)</div>
<div class="line"><span class="lineno"> 1456</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> key:</div>
<div class="line"><span class="lineno"> 1457</span>        <span class="keywordflow">if</span> name <span class="keywordflow">not</span> <span class="keywordflow">in</span> r1.dtype.names:</div>
<div class="line"><span class="lineno"> 1458</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;r1 does not have key field %r&#39;</span> % name)</div>
<div class="line"><span class="lineno"> 1459</span>        <span class="keywordflow">if</span> name <span class="keywordflow">not</span> <span class="keywordflow">in</span> r2.dtype.names:</div>
<div class="line"><span class="lineno"> 1460</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;r2 does not have key field %r&#39;</span> % name)</div>
<div class="line"><span class="lineno"> 1461</span> </div>
<div class="line"><span class="lineno"> 1462</span>    <span class="comment"># Make sure we work with ravelled arrays</span></div>
<div class="line"><span class="lineno"> 1463</span>    r1 = r1.ravel()</div>
<div class="line"><span class="lineno"> 1464</span>    r2 = r2.ravel()</div>
<div class="line"><span class="lineno"> 1465</span>    <span class="comment"># Fixme: nb2 below is never used. Commenting out for pyflakes.</span></div>
<div class="line"><span class="lineno"> 1466</span>    <span class="comment"># (nb1, nb2) = (len(r1), len(r2))</span></div>
<div class="line"><span class="lineno"> 1467</span>    nb1 = len(r1)</div>
<div class="line"><span class="lineno"> 1468</span>    (r1names, r2names) = (r1.dtype.names, r2.dtype.names)</div>
<div class="line"><span class="lineno"> 1469</span> </div>
<div class="line"><span class="lineno"> 1470</span>    <span class="comment"># Check the names for collision</span></div>
<div class="line"><span class="lineno"> 1471</span>    collisions = (set(r1names) &amp; set(r2names)) - set(key)</div>
<div class="line"><span class="lineno"> 1472</span>    <span class="keywordflow">if</span> collisions <span class="keywordflow">and</span> <span class="keywordflow">not</span> (r1postfix <span class="keywordflow">or</span> r2postfix):</div>
<div class="line"><span class="lineno"> 1473</span>        msg = <span class="stringliteral">&quot;r1 and r2 contain common names, r1postfix and r2postfix &quot;</span></div>
<div class="line"><span class="lineno"> 1474</span>        msg += <span class="stringliteral">&quot;can&#39;t both be empty&quot;</span></div>
<div class="line"><span class="lineno"> 1475</span>        <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 1476</span> </div>
<div class="line"><span class="lineno"> 1477</span>    <span class="comment"># Make temporary arrays of just the keys</span></div>
<div class="line"><span class="lineno"> 1478</span>    <span class="comment">#  (use order of keys in `r1` for back-compatibility)</span></div>
<div class="line"><span class="lineno"> 1479</span>    key1 = [ n <span class="keywordflow">for</span> n <span class="keywordflow">in</span> r1names <span class="keywordflow">if</span> n <span class="keywordflow">in</span> key ]</div>
<div class="line"><span class="lineno"> 1480</span>    r1k = _keep_fields(r1, key1)</div>
<div class="line"><span class="lineno"> 1481</span>    r2k = _keep_fields(r2, key1)</div>
<div class="line"><span class="lineno"> 1482</span> </div>
<div class="line"><span class="lineno"> 1483</span>    <span class="comment"># Concatenate the two arrays for comparison</span></div>
<div class="line"><span class="lineno"> 1484</span>    aux = ma.concatenate((r1k, r2k))</div>
<div class="line"><span class="lineno"> 1485</span>    idx_sort = aux.argsort(order=key)</div>
<div class="line"><span class="lineno"> 1486</span>    aux = aux[idx_sort]</div>
<div class="line"><span class="lineno"> 1487</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1488</span>    <span class="comment"># Get the common keys</span></div>
<div class="line"><span class="lineno"> 1489</span>    flag_in = ma.concatenate(([<span class="keyword">False</span>], aux[1:] == aux[:-1]))</div>
<div class="line"><span class="lineno"> 1490</span>    flag_in[:-1] = flag_in[1:] + flag_in[:-1]</div>
<div class="line"><span class="lineno"> 1491</span>    idx_in = idx_sort[flag_in]</div>
<div class="line"><span class="lineno"> 1492</span>    idx_1 = idx_in[(idx_in &lt; nb1)]</div>
<div class="line"><span class="lineno"> 1493</span>    idx_2 = idx_in[(idx_in &gt;= nb1)] - nb1</div>
<div class="line"><span class="lineno"> 1494</span>    (r1cmn, r2cmn) = (len(idx_1), len(idx_2))</div>
<div class="line"><span class="lineno"> 1495</span>    <span class="keywordflow">if</span> jointype == <span class="stringliteral">&#39;inner&#39;</span>:</div>
<div class="line"><span class="lineno"> 1496</span>        (r1spc, r2spc) = (0, 0)</div>
<div class="line"><span class="lineno"> 1497</span>    <span class="keywordflow">elif</span> jointype == <span class="stringliteral">&#39;outer&#39;</span>:</div>
<div class="line"><span class="lineno"> 1498</span>        idx_out = idx_sort[~flag_in]</div>
<div class="line"><span class="lineno"> 1499</span>        idx_1 = np.concatenate((idx_1, idx_out[(idx_out &lt; nb1)]))</div>
<div class="line"><span class="lineno"> 1500</span>        idx_2 = np.concatenate((idx_2, idx_out[(idx_out &gt;= nb1)] - nb1))</div>
<div class="line"><span class="lineno"> 1501</span>        (r1spc, r2spc) = (len(idx_1) - r1cmn, len(idx_2) - r2cmn)</div>
<div class="line"><span class="lineno"> 1502</span>    <span class="keywordflow">elif</span> jointype == <span class="stringliteral">&#39;leftouter&#39;</span>:</div>
<div class="line"><span class="lineno"> 1503</span>        idx_out = idx_sort[~flag_in]</div>
<div class="line"><span class="lineno"> 1504</span>        idx_1 = np.concatenate((idx_1, idx_out[(idx_out &lt; nb1)]))</div>
<div class="line"><span class="lineno"> 1505</span>        (r1spc, r2spc) = (len(idx_1) - r1cmn, 0)</div>
<div class="line"><span class="lineno"> 1506</span>    <span class="comment"># Select the entries from each input</span></div>
<div class="line"><span class="lineno"> 1507</span>    (s1, s2) = (r1[idx_1], r2[idx_2])</div>
<div class="line"><span class="lineno"> 1508</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1509</span>    <span class="comment"># Build the new description of the output array .......</span></div>
<div class="line"><span class="lineno"> 1510</span>    <span class="comment"># Start with the key fields</span></div>
<div class="line"><span class="lineno"> 1511</span>    ndtype = _get_fieldspec(r1k.dtype)</div>
<div class="line"><span class="lineno"> 1512</span> </div>
<div class="line"><span class="lineno"> 1513</span>    <span class="comment"># Add the fields from r1</span></div>
<div class="line"><span class="lineno"> 1514</span>    <span class="keywordflow">for</span> fname, fdtype <span class="keywordflow">in</span> _get_fieldspec(r1.dtype):</div>
<div class="line"><span class="lineno"> 1515</span>        <span class="keywordflow">if</span> fname <span class="keywordflow">not</span> <span class="keywordflow">in</span> key:</div>
<div class="line"><span class="lineno"> 1516</span>            ndtype.append((fname, fdtype))</div>
<div class="line"><span class="lineno"> 1517</span> </div>
<div class="line"><span class="lineno"> 1518</span>    <span class="comment"># Add the fields from r2</span></div>
<div class="line"><span class="lineno"> 1519</span>    <span class="keywordflow">for</span> fname, fdtype <span class="keywordflow">in</span> _get_fieldspec(r2.dtype):</div>
<div class="line"><span class="lineno"> 1520</span>        <span class="comment"># Have we seen the current name already ?</span></div>
<div class="line"><span class="lineno"> 1521</span>        <span class="comment"># we need to rebuild this list every time</span></div>
<div class="line"><span class="lineno"> 1522</span>        names = list(name <span class="keywordflow">for</span> name, dtype <span class="keywordflow">in</span> ndtype)</div>
<div class="line"><span class="lineno"> 1523</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1524</span>            nameidx = names.index(fname)</div>
<div class="line"><span class="lineno"> 1525</span>        <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 1526</span>            <span class="comment">#... we haven&#39;t: just add the description to the current list</span></div>
<div class="line"><span class="lineno"> 1527</span>            ndtype.append((fname, fdtype))</div>
<div class="line"><span class="lineno"> 1528</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1529</span>            <span class="comment"># collision</span></div>
<div class="line"><span class="lineno"> 1530</span>            _, cdtype = ndtype[nameidx]</div>
<div class="line"><span class="lineno"> 1531</span>            <span class="keywordflow">if</span> fname <span class="keywordflow">in</span> key:</div>
<div class="line"><span class="lineno"> 1532</span>                <span class="comment"># The current field is part of the key: take the largest dtype</span></div>
<div class="line"><span class="lineno"> 1533</span>                ndtype[nameidx] = (fname, max(fdtype, cdtype))</div>
<div class="line"><span class="lineno"> 1534</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1535</span>                <span class="comment"># The current field is not part of the key: add the suffixes,</span></div>
<div class="line"><span class="lineno"> 1536</span>                <span class="comment"># and place the new field adjacent to the old one</span></div>
<div class="line"><span class="lineno"> 1537</span>                ndtype[nameidx:nameidx + 1] = [</div>
<div class="line"><span class="lineno"> 1538</span>                    (fname + r1postfix, cdtype),</div>
<div class="line"><span class="lineno"> 1539</span>                    (fname + r2postfix, fdtype)</div>
<div class="line"><span class="lineno"> 1540</span>                ]</div>
<div class="line"><span class="lineno"> 1541</span>    <span class="comment"># Rebuild a dtype from the new fields</span></div>
<div class="line"><span class="lineno"> 1542</span>    ndtype = np.dtype(ndtype)</div>
<div class="line"><span class="lineno"> 1543</span>    <span class="comment"># Find the largest nb of common fields :</span></div>
<div class="line"><span class="lineno"> 1544</span>    <span class="comment"># r1cmn and r2cmn should be equal, but...</span></div>
<div class="line"><span class="lineno"> 1545</span>    cmn = max(r1cmn, r2cmn)</div>
<div class="line"><span class="lineno"> 1546</span>    <span class="comment"># Construct an empty array</span></div>
<div class="line"><span class="lineno"> 1547</span>    output = ma.masked_all((cmn + r1spc + r2spc,), dtype=ndtype)</div>
<div class="line"><span class="lineno"> 1548</span>    names = output.dtype.names</div>
<div class="line"><span class="lineno"> 1549</span>    <span class="keywordflow">for</span> f <span class="keywordflow">in</span> r1names:</div>
<div class="line"><span class="lineno"> 1550</span>        selected = s1[f]</div>
<div class="line"><span class="lineno"> 1551</span>        <span class="keywordflow">if</span> f <span class="keywordflow">not</span> <span class="keywordflow">in</span> names <span class="keywordflow">or</span> (f <span class="keywordflow">in</span> r2names <span class="keywordflow">and</span> <span class="keywordflow">not</span> r2postfix <span class="keywordflow">and</span> f <span class="keywordflow">not</span> <span class="keywordflow">in</span> key):</div>
<div class="line"><span class="lineno"> 1552</span>            f += r1postfix</div>
<div class="line"><span class="lineno"> 1553</span>        current = output[f]</div>
<div class="line"><span class="lineno"> 1554</span>        current[:r1cmn] = selected[:r1cmn]</div>
<div class="line"><span class="lineno"> 1555</span>        <span class="keywordflow">if</span> jointype <span class="keywordflow">in</span> (<span class="stringliteral">&#39;outer&#39;</span>, <span class="stringliteral">&#39;leftouter&#39;</span>):</div>
<div class="line"><span class="lineno"> 1556</span>            current[cmn:cmn + r1spc] = selected[r1cmn:]</div>
<div class="line"><span class="lineno"> 1557</span>    <span class="keywordflow">for</span> f <span class="keywordflow">in</span> r2names:</div>
<div class="line"><span class="lineno"> 1558</span>        selected = s2[f]</div>
<div class="line"><span class="lineno"> 1559</span>        <span class="keywordflow">if</span> f <span class="keywordflow">not</span> <span class="keywordflow">in</span> names <span class="keywordflow">or</span> (f <span class="keywordflow">in</span> r1names <span class="keywordflow">and</span> <span class="keywordflow">not</span> r1postfix <span class="keywordflow">and</span> f <span class="keywordflow">not</span> <span class="keywordflow">in</span> key):</div>
<div class="line"><span class="lineno"> 1560</span>            f += r2postfix</div>
<div class="line"><span class="lineno"> 1561</span>        current = output[f]</div>
<div class="line"><span class="lineno"> 1562</span>        current[:r2cmn] = selected[:r2cmn]</div>
<div class="line"><span class="lineno"> 1563</span>        <span class="keywordflow">if</span> (jointype == <span class="stringliteral">&#39;outer&#39;</span>) <span class="keywordflow">and</span> r2spc:</div>
<div class="line"><span class="lineno"> 1564</span>            current[-r2spc:] = selected[r2cmn:]</div>
<div class="line"><span class="lineno"> 1565</span>    <span class="comment"># Sort and finalize the output</span></div>
<div class="line"><span class="lineno"> 1566</span>    output.sort(order=key)</div>
<div class="line"><span class="lineno"> 1567</span>    kwargs = dict(usemask=usemask, asrecarray=asrecarray)</div>
<div class="line"><span class="lineno"> 1568</span>    <span class="keywordflow">return</span> _fix_output(_fix_defaults(output, defaults), **kwargs)</div>
<div class="line"><span class="lineno"> 1569</span> </div>
<div class="line"><span class="lineno"> 1570</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad640d3ad74ad4c34a34c1e2c159618f6" name="ad640d3ad74ad4c34a34c1e2c159618f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad640d3ad74ad4c34a34c1e2c159618f6">&#9670;&#160;</a></span>merge_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.merge_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Merge arrays field by field.

Parameters
----------
seqarrays : sequence of ndarrays
    Sequence of arrays
fill_value : {float}, optional
    Filling value used to pad missing data on the shorter arrays.
flatten : {False, True}, optional
    Whether to collapse nested fields.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : {False, True}, optional
    Whether to return a recarray (MaskedRecords) or not.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.])))
array([( 1, 10.), ( 2, 20.), (-1, 30.)],
      dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')])

&gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2], dtype=np.int64),
...         np.array([10., 20., 30.])), usemask=False)
 array([(1, 10.0), (2, 20.0), (-1, 30.0)],
         dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')])
&gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]).view([('a', np.int64)]),
...               np.array([10., 20., 30.])),
...              usemask=False, asrecarray=True)
rec.array([( 1, 10.), ( 2, 20.), (-1, 30.)],
          dtype=[('a', '&lt;i8'), ('f1', '&lt;f8')])

Notes
-----
* Without a mask, the missing value will be filled with something,
  depending on what its corresponding type:

  * ``-1``      for integers
  * ``-1.0``    for floating point numbers
  * ``'-'``     for characters
  * ``'-1'``    for strings
  * ``True``    for boolean values
* XXX: I just obtained these values empirically
</pre> <div class="fragment"><div class="line"><span class="lineno">  363</span>                 usemask=<span class="keyword">False</span>, asrecarray=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  364</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    Merge arrays field by field.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    seqarrays : sequence of ndarrays</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">        Sequence of arrays</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    fill_value : {float}, optional</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">        Filling value used to pad missing data on the shorter arrays.</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    flatten : {False, True}, optional</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        Whether to collapse nested fields.</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    usemask : {False, True}, optional</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        Whether to return a masked array or not.</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    asrecarray : {False, True}, optional</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        Whether to return a recarray (MaskedRecords) or not.</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    &gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.])))</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    array([( 1, 10.), ( 2, 20.), (-1, 30.)],</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">          dtype=[(&#39;f0&#39;, &#39;&lt;i8&#39;), (&#39;f1&#39;, &#39;&lt;f8&#39;)])</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    &gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2], dtype=np.int64),</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    ...         np.array([10., 20., 30.])), usemask=False)</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">     array([(1, 10.0), (2, 20.0), (-1, 30.0)],</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">             dtype=[(&#39;f0&#39;, &#39;&lt;i8&#39;), (&#39;f1&#39;, &#39;&lt;f8&#39;)])</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    &gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]).view([(&#39;a&#39;, np.int64)]),</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    ...               np.array([10., 20., 30.])),</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    ...              usemask=False, asrecarray=True)</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    rec.array([( 1, 10.), ( 2, 20.), (-1, 30.)],</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">              dtype=[(&#39;a&#39;, &#39;&lt;i8&#39;), (&#39;f1&#39;, &#39;&lt;f8&#39;)])</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    * Without a mask, the missing value will be filled with something,</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">      depending on what its corresponding type:</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">      * ``-1``      for integers</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">      * ``-1.0``    for floating point numbers</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">      * ``&#39;-&#39;``     for characters</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">      * ``&#39;-1&#39;``    for strings</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">      * ``True``    for boolean values</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    * XXX: I just obtained these values empirically</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  409</span>    <span class="comment"># Only one item in the input sequence ?</span></div>
<div class="line"><span class="lineno">  410</span>    <span class="keywordflow">if</span> (len(seqarrays) == 1):</div>
<div class="line"><span class="lineno">  411</span>        seqarrays = np.asanyarray(seqarrays[0])</div>
<div class="line"><span class="lineno">  412</span>    <span class="comment"># Do we have a single ndarray as input ?</span></div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">if</span> isinstance(seqarrays, (ndarray, np.void)):</div>
<div class="line"><span class="lineno">  414</span>        seqdtype = seqarrays.dtype</div>
<div class="line"><span class="lineno">  415</span>        <span class="comment"># Make sure we have named fields</span></div>
<div class="line"><span class="lineno">  416</span>        <span class="keywordflow">if</span> seqdtype.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  417</span>            seqdtype = np.dtype([(<span class="stringliteral">&#39;&#39;</span>, seqdtype)])</div>
<div class="line"><span class="lineno">  418</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> flatten <span class="keywordflow">or</span> _zip_dtype((seqarrays,), flatten=<span class="keyword">True</span>) == seqdtype:</div>
<div class="line"><span class="lineno">  419</span>            <span class="comment"># Minimal processing needed: just make sure everything&#39;s a-ok</span></div>
<div class="line"><span class="lineno">  420</span>            seqarrays = seqarrays.ravel()</div>
<div class="line"><span class="lineno">  421</span>            <span class="comment"># Find what type of array we must return</span></div>
<div class="line"><span class="lineno">  422</span>            <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno">  423</span>                <span class="keywordflow">if</span> asrecarray:</div>
<div class="line"><span class="lineno">  424</span>                    seqtype = MaskedRecords</div>
<div class="line"><span class="lineno">  425</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  426</span>                    seqtype = MaskedArray</div>
<div class="line"><span class="lineno">  427</span>            <span class="keywordflow">elif</span> asrecarray:</div>
<div class="line"><span class="lineno">  428</span>                seqtype = recarray</div>
<div class="line"><span class="lineno">  429</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  430</span>                seqtype = ndarray</div>
<div class="line"><span class="lineno">  431</span>            <span class="keywordflow">return</span> seqarrays.view(dtype=seqdtype, type=seqtype)</div>
<div class="line"><span class="lineno">  432</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  433</span>            seqarrays = (seqarrays,)</div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  435</span>        <span class="comment"># Make sure we have arrays in the input sequence</span></div>
<div class="line"><span class="lineno">  436</span>        seqarrays = [np.asanyarray(_m) <span class="keywordflow">for</span> _m <span class="keywordflow">in</span> seqarrays]</div>
<div class="line"><span class="lineno">  437</span>    <span class="comment"># Find the sizes of the inputs and their maximum</span></div>
<div class="line"><span class="lineno">  438</span>    sizes = tuple(a.size <span class="keywordflow">for</span> a <span class="keywordflow">in</span> seqarrays)</div>
<div class="line"><span class="lineno">  439</span>    maxlength = max(sizes)</div>
<div class="line"><span class="lineno">  440</span>    <span class="comment"># Get the dtype of the output (flattening if needed)</span></div>
<div class="line"><span class="lineno">  441</span>    newdtype = _zip_dtype(seqarrays, flatten=flatten)</div>
<div class="line"><span class="lineno">  442</span>    <span class="comment"># Initialize the sequences for data and mask</span></div>
<div class="line"><span class="lineno">  443</span>    seqdata = []</div>
<div class="line"><span class="lineno">  444</span>    seqmask = []</div>
<div class="line"><span class="lineno">  445</span>    <span class="comment"># If we expect some kind of MaskedArray, make a special loop.</span></div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno">  447</span>        <span class="keywordflow">for</span> (a, n) <span class="keywordflow">in</span> zip(seqarrays, sizes):</div>
<div class="line"><span class="lineno">  448</span>            nbmissing = (maxlength - n)</div>
<div class="line"><span class="lineno">  449</span>            <span class="comment"># Get the data and mask</span></div>
<div class="line"><span class="lineno">  450</span>            data = a.ravel().__array__()</div>
<div class="line"><span class="lineno">  451</span>            mask = ma.getmaskarray(a).ravel()</div>
<div class="line"><span class="lineno">  452</span>            <span class="comment"># Get the filling value (if needed)</span></div>
<div class="line"><span class="lineno">  453</span>            <span class="keywordflow">if</span> nbmissing:</div>
<div class="line"><span class="lineno">  454</span>                fval = _check_fill_value(fill_value, a.dtype)</div>
<div class="line"><span class="lineno">  455</span>                <span class="keywordflow">if</span> isinstance(fval, (ndarray, np.void)):</div>
<div class="line"><span class="lineno">  456</span>                    <span class="keywordflow">if</span> len(fval.dtype) == 1:</div>
<div class="line"><span class="lineno">  457</span>                        fval = fval.item()[0]</div>
<div class="line"><span class="lineno">  458</span>                        fmsk = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  459</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  460</span>                        fval = np.array(fval, dtype=a.dtype, ndmin=1)</div>
<div class="line"><span class="lineno">  461</span>                        fmsk = np.ones((1,), dtype=mask.dtype)</div>
<div class="line"><span class="lineno">  462</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  463</span>                fval = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  464</span>                fmsk = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  465</span>            <span class="comment"># Store an iterator padding the input to the expected length</span></div>
<div class="line"><span class="lineno">  466</span>            seqdata.append(itertools.chain(data, [fval] * nbmissing))</div>
<div class="line"><span class="lineno">  467</span>            seqmask.append(itertools.chain(mask, [fmsk] * nbmissing))</div>
<div class="line"><span class="lineno">  468</span>        <span class="comment"># Create an iterator for the data</span></div>
<div class="line"><span class="lineno">  469</span>        data = tuple(_izip_records(seqdata, flatten=flatten))</div>
<div class="line"><span class="lineno">  470</span>        output = ma.array(np.fromiter(data, dtype=newdtype, count=maxlength),</div>
<div class="line"><span class="lineno">  471</span>                          mask=list(_izip_records(seqmask, flatten=flatten)))</div>
<div class="line"><span class="lineno">  472</span>        <span class="keywordflow">if</span> asrecarray:</div>
<div class="line"><span class="lineno">  473</span>            output = output.view(MaskedRecords)</div>
<div class="line"><span class="lineno">  474</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  475</span>        <span class="comment"># Same as before, without the mask we don&#39;t need...</span></div>
<div class="line"><span class="lineno">  476</span>        <span class="keywordflow">for</span> (a, n) <span class="keywordflow">in</span> zip(seqarrays, sizes):</div>
<div class="line"><span class="lineno">  477</span>            nbmissing = (maxlength - n)</div>
<div class="line"><span class="lineno">  478</span>            data = a.ravel().__array__()</div>
<div class="line"><span class="lineno">  479</span>            <span class="keywordflow">if</span> nbmissing:</div>
<div class="line"><span class="lineno">  480</span>                fval = _check_fill_value(fill_value, a.dtype)</div>
<div class="line"><span class="lineno">  481</span>                <span class="keywordflow">if</span> isinstance(fval, (ndarray, np.void)):</div>
<div class="line"><span class="lineno">  482</span>                    <span class="keywordflow">if</span> len(fval.dtype) == 1:</div>
<div class="line"><span class="lineno">  483</span>                        fval = fval.item()[0]</div>
<div class="line"><span class="lineno">  484</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  485</span>                        fval = np.array(fval, dtype=a.dtype, ndmin=1)</div>
<div class="line"><span class="lineno">  486</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  487</span>                fval = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  488</span>            seqdata.append(itertools.chain(data, [fval] * nbmissing))</div>
<div class="line"><span class="lineno">  489</span>        output = np.fromiter(tuple(_izip_records(seqdata, flatten=flatten)),</div>
<div class="line"><span class="lineno">  490</span>                             dtype=newdtype, count=maxlength)</div>
<div class="line"><span class="lineno">  491</span>        <span class="keywordflow">if</span> asrecarray:</div>
<div class="line"><span class="lineno">  492</span>            output = output.view(recarray)</div>
<div class="line"><span class="lineno">  493</span>    <span class="comment"># And we&#39;re done...</span></div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a61b78ddf8e53ebbd142c0963c2e87a8c" name="a61b78ddf8e53ebbd142c0963c2e87a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b78ddf8e53ebbd142c0963c2e87a8c">&#9670;&#160;</a></span>rec_append_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.rec_append_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtypes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add new fields to an existing array.

The names of the fields are given with the `names` arguments,
the corresponding values with the `data` arguments.
If a single field is appended, `names`, `data` and `dtypes` do not have
to be lists but just values.

Parameters
----------
base : array
    Input array to extend.
names : string, sequence
    String or sequence of strings corresponding to the names
    of the new fields.
data : array or sequence of arrays
    Array or sequence of arrays storing the fields to add to the base.
dtypes : sequence of datatypes, optional
    Datatype or sequence of datatypes.
    If None, the datatypes are estimated from the `data`.

See Also
--------
append_fields

Returns
-------
appended_array : np.recarray
</pre> <div class="fragment"><div class="line"><span class="lineno">  730</span><span class="keyword">def </span>rec_append_fields(base, names, data, dtypes=None):</div>
<div class="line"><span class="lineno">  731</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    Add new fields to an existing array.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    The names of the fields are given with the `names` arguments,</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    the corresponding values with the `data` arguments.</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    If a single field is appended, `names`, `data` and `dtypes` do not have</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    to be lists but just values.</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    base : array</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">        Input array to extend.</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    names : string, sequence</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        String or sequence of strings corresponding to the names</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        of the new fields.</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    data : array or sequence of arrays</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        Array or sequence of arrays storing the fields to add to the base.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    dtypes : sequence of datatypes, optional</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        Datatype or sequence of datatypes.</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        If None, the datatypes are estimated from the `data`.</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    append_fields</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    appended_array : np.recarray</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  760</span>    <span class="keywordflow">return</span> append_fields(base, names, data=data, dtypes=dtypes,</div>
<div class="line"><span class="lineno">  761</span>                         asrecarray=<span class="keyword">True</span>, usemask=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  762</span> </div>
<div class="line"><span class="lineno">  763</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cbf9d4bad57a582f7af8533c1cc3f69" name="a8cbf9d4bad57a582f7af8533c1cc3f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbf9d4bad57a582f7af8533c1cc3f69">&#9670;&#160;</a></span>rec_drop_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.rec_drop_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a new numpy.recarray with fields in `drop_names` dropped.
</pre> <div class="fragment"><div class="line"><span class="lineno">  596</span><span class="keyword">def </span>rec_drop_fields(base, drop_names):</div>
<div class="line"><span class="lineno">  597</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    Returns a new numpy.recarray with fields in `drop_names` dropped.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  600</span>    <span class="keywordflow">return</span> drop_fields(base, drop_names, usemask=<span class="keyword">False</span>, asrecarray=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  601</span> </div>
<div class="line"><span class="lineno">  602</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0037374c7c15329c232f5880d143829e" name="a0037374c7c15329c232f5880d143829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0037374c7c15329c232f5880d143829e">&#9670;&#160;</a></span>rec_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.rec_join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jointype</em> = <code>'inner'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1postfix</em> = <code>'1'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2postfix</em> = <code>'2'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Join arrays `r1` and `r2` on keys.
Alternative to join_by, that always returns a np.recarray.

See Also
--------
join_by : equivalent function
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1579</span>             defaults=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1580</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">    Join arrays `r1` and `r2` on keys.</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">    Alternative to join_by, that always returns a np.recarray.</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">    join_by : equivalent function</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1588</span>    kwargs = dict(jointype=jointype, r1postfix=r1postfix, r2postfix=r2postfix,</div>
<div class="line"><span class="lineno"> 1589</span>                  defaults=defaults, usemask=<span class="keyword">False</span>, asrecarray=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1590</span>    <span class="keywordflow">return</span> join_by(key, r1, r2, **kwargs)</div>
</div><!-- fragment -->
</div>
</div>
<a id="afbbd28e28bf50bb6237b530b9a306359" name="afbbd28e28bf50bb6237b530b9a306359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbd28e28bf50bb6237b530b9a306359">&#9670;&#160;</a></span>recursive_fill_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.recursive_fill_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fills fields from output with fields from input,
with support for nested structures.

Parameters
----------
input : ndarray
    Input array.
output : ndarray
    Output array.

Notes
-----
* `output` should be at least the same size as `input`

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.array([(1, 10.), (2, 20.)], dtype=[('A', np.int64), ('B', np.float64)])
&gt;&gt;&gt; b = np.zeros((3,), dtype=a.dtype)
&gt;&gt;&gt; rfn.recursive_fill_fields(a, b)
array([(1, 10.), (2, 20.), (0,  0.)], dtype=[('A', '&lt;i8'), ('B', '&lt;f8')])</pre> <div class="fragment"><div class="line"><span class="lineno">   36</span><span class="keyword">def </span>recursive_fill_fields(input, output):</div>
<div class="line"><span class="lineno">   37</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    Fills fields from output with fields from input,</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    with support for nested structures.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    input : ndarray</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        Output array.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    * `output` should be at least the same size as `input`</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([(1, 10.), (2, 20.)], dtype=[(&#39;A&#39;, np.int64), (&#39;B&#39;, np.float64)])</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    &gt;&gt;&gt; b = np.zeros((3,), dtype=a.dtype)</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    &gt;&gt;&gt; rfn.recursive_fill_fields(a, b)</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    array([(1, 10.), (2, 20.), (0,  0.)], dtype=[(&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   61</span>    newdtype = output.dtype</div>
<div class="line"><span class="lineno">   62</span>    <span class="keywordflow">for</span> field <span class="keywordflow">in</span> newdtype.names:</div>
<div class="line"><span class="lineno">   63</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   64</span>            current = input[field]</div>
<div class="line"><span class="lineno">   65</span>        <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">   66</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">   67</span>        <span class="keywordflow">if</span> current.dtype.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   68</span>            recursive_fill_fields(current, output[field])</div>
<div class="line"><span class="lineno">   69</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   70</span>            output[field][:len(current)] = current</div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aba8d41c05a7084dd2e8f17ffd2c50e97" name="aba8d41c05a7084dd2e8f17ffd2c50e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8d41c05a7084dd2e8f17ffd2c50e97">&#9670;&#160;</a></span>rename_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.rename_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namemapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rename the fields from a flexible-datatype ndarray or recarray.

Nested fields are supported.

Parameters
----------
base : ndarray
    Input array whose fields must be modified.
namemapper : dictionary
    Dictionary mapping old field names to their new version.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))],
...   dtype=[('a', int),('b', [('ba', float), ('bb', (float, 2))])])
&gt;&gt;&gt; rfn.rename_fields(a, {'a':'A', 'bb':'BB'})
array([(1, (2., [ 3., 30.])), (4, (5., [ 6., 60.]))],
      dtype=[('A', '&lt;i8'), ('b', [('ba', '&lt;f8'), ('BB', '&lt;f8', (2,))])])</pre> <div class="fragment"><div class="line"><span class="lineno">  608</span><span class="keyword">def </span>rename_fields(base, namemapper):</div>
<div class="line"><span class="lineno">  609</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    Rename the fields from a flexible-datatype ndarray or recarray.</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    Nested fields are supported.</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    base : ndarray</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">        Input array whose fields must be modified.</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    namemapper : dictionary</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">        Dictionary mapping old field names to their new version.</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))],</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    ...   dtype=[(&#39;a&#39;, int),(&#39;b&#39;, [(&#39;ba&#39;, float), (&#39;bb&#39;, (float, 2))])])</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    &gt;&gt;&gt; rfn.rename_fields(a, {&#39;a&#39;:&#39;A&#39;, &#39;bb&#39;:&#39;BB&#39;})</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    array([(1, (2., [ 3., 30.])), (4, (5., [ 6., 60.]))],</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">          dtype=[(&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;b&#39;, [(&#39;ba&#39;, &#39;&lt;f8&#39;), (&#39;BB&#39;, &#39;&lt;f8&#39;, (2,))])])</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  631</span>    <span class="keyword">def </span>_recursive_rename_fields(ndtype, namemapper):</div>
<div class="line"><span class="lineno">  632</span>        newdtype = []</div>
<div class="line"><span class="lineno">  633</span>        <span class="keywordflow">for</span> name <span class="keywordflow">in</span> ndtype.names:</div>
<div class="line"><span class="lineno">  634</span>            newname = namemapper.get(name, name)</div>
<div class="line"><span class="lineno">  635</span>            current = ndtype[name]</div>
<div class="line"><span class="lineno">  636</span>            <span class="keywordflow">if</span> current.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  637</span>                newdtype.append(</div>
<div class="line"><span class="lineno">  638</span>                    (newname, _recursive_rename_fields(current, namemapper))</div>
<div class="line"><span class="lineno">  639</span>                    )</div>
<div class="line"><span class="lineno">  640</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  641</span>                newdtype.append((newname, current))</div>
<div class="line"><span class="lineno">  642</span>        <span class="keywordflow">return</span> newdtype</div>
<div class="line"><span class="lineno">  643</span>    newdtype = _recursive_rename_fields(base.dtype, namemapper)</div>
<div class="line"><span class="lineno">  644</span>    <span class="keywordflow">return</span> base.view(newdtype)</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a23ab7ba8f60627be51d62477cf0450b6" name="a23ab7ba8f60627be51d62477cf0450b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ab7ba8f60627be51d62477cf0450b6">&#9670;&#160;</a></span>repack_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.repack_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Re-pack the fields of a structured array or dtype in memory.

The memory layout of structured datatypes allows fields at arbitrary
byte offsets. This means the fields can be separated by padding bytes,
their offsets can be non-monotonically increasing, and they can overlap.

This method removes any overlaps and reorders the fields in memory so they
have increasing byte offsets, and adds or removes padding bytes depending
on the `align` option, which behaves like the `align` option to
`numpy.dtype`.

If `align=False`, this method produces a "packed" memory layout in which
each field starts at the byte the previous field ended, and any padding
bytes are removed.

If `align=True`, this methods produces an "aligned" memory layout in which
each field's offset is a multiple of its alignment, and the total itemsize
is a multiple of the largest alignment, by adding padding bytes as needed.

Parameters
----------
a : ndarray or dtype
   array or dtype for which to repack the fields.
align : boolean
   If true, use an "aligned" memory layout, otherwise use a "packed" layout.
recurse : boolean
   If True, also repack nested structures.

Returns
-------
repacked : ndarray or dtype
   Copy of `a` with fields repacked, or `a` itself if no repacking was
   needed.

Examples
--------

&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; def print_offsets(d):
...     print("offsets:", [d.fields[name][1] for name in d.names])
...     print("itemsize:", d.itemsize)
...
&gt;&gt;&gt; dt = np.dtype('u1, &lt;i8, &lt;f8', align=True)
&gt;&gt;&gt; dt
dtype({'names': ['f0', 'f1', 'f2'], 'formats': ['u1', '&lt;i8', '&lt;f8'], \
'offsets': [0, 8, 16], 'itemsize': 24}, align=True)
&gt;&gt;&gt; print_offsets(dt)
offsets: [0, 8, 16]
itemsize: 24
&gt;&gt;&gt; packed_dt = rfn.repack_fields(dt)
&gt;&gt;&gt; packed_dt
dtype([('f0', 'u1'), ('f1', '&lt;i8'), ('f2', '&lt;f8')])
&gt;&gt;&gt; print_offsets(packed_dt)
offsets: [0, 1, 9]
itemsize: 17</pre> <div class="fragment"><div class="line"><span class="lineno">  769</span><span class="keyword">def </span>repack_fields(a, align=False, recurse=False):</div>
<div class="line"><span class="lineno">  770</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    Re-pack the fields of a structured array or dtype in memory.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    The memory layout of structured datatypes allows fields at arbitrary</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    byte offsets. This means the fields can be separated by padding bytes,</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    their offsets can be non-monotonically increasing, and they can overlap.</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    This method removes any overlaps and reorders the fields in memory so they</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    have increasing byte offsets, and adds or removes padding bytes depending</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    on the `align` option, which behaves like the `align` option to</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    `numpy.dtype`.</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    If `align=False`, this method produces a &quot;packed&quot; memory layout in which</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    each field starts at the byte the previous field ended, and any padding</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    bytes are removed.</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    If `align=True`, this methods produces an &quot;aligned&quot; memory layout in which</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    each field&#39;s offset is a multiple of its alignment, and the total itemsize</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">    is a multiple of the largest alignment, by adding padding bytes as needed.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    a : ndarray or dtype</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">       array or dtype for which to repack the fields.</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    align : boolean</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">       If true, use an &quot;aligned&quot; memory layout, otherwise use a &quot;packed&quot; layout.</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    recurse : boolean</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">       If True, also repack nested structures.</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    repacked : ndarray or dtype</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">       Copy of `a` with fields repacked, or `a` itself if no repacking was</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">       needed.</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    &gt;&gt;&gt; def print_offsets(d):</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    ...     print(&quot;offsets:&quot;, [d.fields[name][1] for name in d.names])</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    ...     print(&quot;itemsize:&quot;, d.itemsize)</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    &gt;&gt;&gt; dt = np.dtype(&#39;u1, &lt;i8, &lt;f8&#39;, align=True)</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    &gt;&gt;&gt; dt</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    dtype({&#39;names&#39;: [&#39;f0&#39;, &#39;f1&#39;, &#39;f2&#39;], &#39;formats&#39;: [&#39;u1&#39;, &#39;&lt;i8&#39;, &#39;&lt;f8&#39;], \</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">&#39;offsets&#39;: [0, 8, 16], &#39;itemsize&#39;: 24}, align=True)</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    &gt;&gt;&gt; print_offsets(dt)</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    offsets: [0, 8, 16]</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    itemsize: 24</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    &gt;&gt;&gt; packed_dt = rfn.repack_fields(dt)</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    &gt;&gt;&gt; packed_dt</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    dtype([(&#39;f0&#39;, &#39;u1&#39;), (&#39;f1&#39;, &#39;&lt;i8&#39;), (&#39;f2&#39;, &#39;&lt;f8&#39;)])</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    &gt;&gt;&gt; print_offsets(packed_dt)</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    offsets: [0, 1, 9]</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    itemsize: 17</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  828</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(a, np.dtype):</div>
<div class="line"><span class="lineno">  829</span>        dt = repack_fields(a.dtype, align=align, recurse=recurse)</div>
<div class="line"><span class="lineno">  830</span>        <span class="keywordflow">return</span> a.astype(dt, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span>    <span class="keywordflow">if</span> a.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  833</span>        <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span>    fieldinfo = []</div>
<div class="line"><span class="lineno">  836</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> a.names:</div>
<div class="line"><span class="lineno">  837</span>        tup = a.fields[name]</div>
<div class="line"><span class="lineno">  838</span>        <span class="keywordflow">if</span> recurse:</div>
<div class="line"><span class="lineno">  839</span>            fmt = repack_fields(tup[0], align=align, recurse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  840</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  841</span>            fmt = tup[0]</div>
<div class="line"><span class="lineno">  842</span> </div>
<div class="line"><span class="lineno">  843</span>        <span class="keywordflow">if</span> len(tup) == 3:</div>
<div class="line"><span class="lineno">  844</span>            name = (tup[2], name)</div>
<div class="line"><span class="lineno">  845</span> </div>
<div class="line"><span class="lineno">  846</span>        fieldinfo.append((name, fmt))</div>
<div class="line"><span class="lineno">  847</span> </div>
<div class="line"><span class="lineno">  848</span>    dt = np.dtype(fieldinfo, align=align)</div>
<div class="line"><span class="lineno">  849</span>    <span class="keywordflow">return</span> np.dtype((a.type, dt))</div>
<div class="line"><span class="lineno">  850</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aee30508fb48b1e388eea45d89e44d8e2" name="aee30508fb48b1e388eea45d89e44d8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee30508fb48b1e388eea45d89e44d8e2">&#9670;&#160;</a></span>require_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.require_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>required_dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Casts a structured array to a new dtype using assignment by field-name.

This function assigns from the old to the new array by name, so the
value of a field in the output array is the value of the field with the
same name in the source array. This has the effect of creating a new
ndarray containing only the fields "required" by the required_dtype.

If a field name in the required_dtype does not exist in the
input array, that field is created and set to 0 in the output array.

Parameters
----------
a : ndarray
   array to cast
required_dtype : dtype
   datatype for output array

Returns
-------
out : ndarray
    array with the new dtype, with field values copied from the fields in
    the input array with the same name

Examples
--------

&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.ones(4, dtype=[('a', 'i4'), ('b', 'f8'), ('c', 'u1')])
&gt;&gt;&gt; rfn.require_fields(a, [('b', 'f4'), ('c', 'u1')])
array([(1., 1), (1., 1), (1., 1), (1., 1)],
  dtype=[('b', '&lt;f4'), ('c', 'u1')])
&gt;&gt;&gt; rfn.require_fields(a, [('b', 'f4'), ('newf', 'u1')])
array([(1., 0), (1., 0), (1., 0), (1., 0)],
  dtype=[('b', '&lt;f4'), ('newf', 'u1')])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1186</span><span class="keyword">def </span>require_fields(array, required_dtype):</div>
<div class="line"><span class="lineno"> 1187</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    Casts a structured array to a new dtype using assignment by field-name.</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    This function assigns from the old to the new array by name, so the</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    value of a field in the output array is the value of the field with the</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    same name in the source array. This has the effect of creating a new</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    ndarray containing only the fields &quot;required&quot; by the required_dtype.</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    If a field name in the required_dtype does not exist in the</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    input array, that field is created and set to 0 in the output array.</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">       array to cast</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    required_dtype : dtype</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">       datatype for output array</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">        array with the new dtype, with field values copied from the fields in</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">        the input array with the same name</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    &gt;&gt;&gt; a = np.ones(4, dtype=[(&#39;a&#39;, &#39;i4&#39;), (&#39;b&#39;, &#39;f8&#39;), (&#39;c&#39;, &#39;u1&#39;)])</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    &gt;&gt;&gt; rfn.require_fields(a, [(&#39;b&#39;, &#39;f4&#39;), (&#39;c&#39;, &#39;u1&#39;)])</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    array([(1., 1), (1., 1), (1., 1), (1., 1)],</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">      dtype=[(&#39;b&#39;, &#39;&lt;f4&#39;), (&#39;c&#39;, &#39;u1&#39;)])</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    &gt;&gt;&gt; rfn.require_fields(a, [(&#39;b&#39;, &#39;f4&#39;), (&#39;newf&#39;, &#39;u1&#39;)])</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    array([(1., 0), (1., 0), (1., 0), (1., 0)],</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">      dtype=[(&#39;b&#39;, &#39;&lt;f4&#39;), (&#39;newf&#39;, &#39;u1&#39;)])</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1224</span>    out = np.empty(array.shape, dtype=required_dtype)</div>
<div class="line"><span class="lineno"> 1225</span>    assign_fields_by_name(out, array)</div>
<div class="line"><span class="lineno"> 1226</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1227</span> </div>
<div class="line"><span class="lineno"> 1228</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a891f814bc1fd2810a0a845a44a6f8f51" name="a891f814bc1fd2810a0a845a44a6f8f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891f814bc1fd2810a0a845a44a6f8f51">&#9670;&#160;</a></span>stack_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.stack_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>autoconvert</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Superposes arrays fields by fields

Parameters
----------
arrays : array or sequence
    Sequence of input arrays.
defaults : dictionary, optional
    Dictionary mapping field names to the corresponding default values.
usemask : {True, False}, optional
    Whether to return a MaskedArray (or MaskedRecords is
    `asrecarray==True`) or a ndarray.
asrecarray : {False, True}, optional
    Whether to return a recarray (or MaskedRecords if `usemask==True`)
    or just a flexible-type ndarray.
autoconvert : {False, True}, optional
    Whether automatically cast the type of the field to the maximum.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; x = np.array([1, 2,])
&gt;&gt;&gt; rfn.stack_arrays(x) is x
True
&gt;&gt;&gt; z = np.array([('A', 1), ('B', 2)], dtype=[('A', '|S3'), ('B', float)])
&gt;&gt;&gt; zz = np.array([('a', 10., 100.), ('b', 20., 200.), ('c', 30., 300.)],
...   dtype=[('A', '|S3'), ('B', np.double), ('C', np.double)])
&gt;&gt;&gt; test = rfn.stack_arrays((z,zz))
&gt;&gt;&gt; test
masked_array(data=[(b'A', 1.0, --), (b'B', 2.0, --), (b'a', 10.0, 100.0),
                   (b'b', 20.0, 200.0), (b'c', 30.0, 300.0)],
             mask=[(False, False,  True), (False, False,  True),
                   (False, False, False), (False, False, False),
                   (False, False, False)],
       fill_value=(b'N/A', 1.e+20, 1.e+20),
            dtype=[('A', 'S3'), ('B', '&lt;f8'), ('C', '&lt;f8')])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1236</span>                 autoconvert=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 1237</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    Superposes arrays fields by fields</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">    arrays : array or sequence</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">        Sequence of input arrays.</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    defaults : dictionary, optional</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">        Dictionary mapping field names to the corresponding default values.</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    usemask : {True, False}, optional</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">        Whether to return a MaskedArray (or MaskedRecords is</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">        `asrecarray==True`) or a ndarray.</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    asrecarray : {False, True}, optional</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">        Whether to return a recarray (or MaskedRecords if `usemask==True`)</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">        or just a flexible-type ndarray.</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    autoconvert : {False, True}, optional</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">        Whether automatically cast the type of the field to the maximum.</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2,])</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    &gt;&gt;&gt; rfn.stack_arrays(x) is x</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    &gt;&gt;&gt; z = np.array([(&#39;A&#39;, 1), (&#39;B&#39;, 2)], dtype=[(&#39;A&#39;, &#39;|S3&#39;), (&#39;B&#39;, float)])</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">    &gt;&gt;&gt; zz = np.array([(&#39;a&#39;, 10., 100.), (&#39;b&#39;, 20., 200.), (&#39;c&#39;, 30., 300.)],</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    ...   dtype=[(&#39;A&#39;, &#39;|S3&#39;), (&#39;B&#39;, np.double), (&#39;C&#39;, np.double)])</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    &gt;&gt;&gt; test = rfn.stack_arrays((z,zz))</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">    &gt;&gt;&gt; test</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">    masked_array(data=[(b&#39;A&#39;, 1.0, --), (b&#39;B&#39;, 2.0, --), (b&#39;a&#39;, 10.0, 100.0),</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">                       (b&#39;b&#39;, 20.0, 200.0), (b&#39;c&#39;, 30.0, 300.0)],</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">                 mask=[(False, False,  True), (False, False,  True),</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">                       (False, False, False), (False, False, False),</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">                       (False, False, False)],</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">           fill_value=(b&#39;N/A&#39;, 1.e+20, 1.e+20),</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">                dtype=[(&#39;A&#39;, &#39;S3&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;), (&#39;C&#39;, &#39;&lt;f8&#39;)])</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1275</span>    <span class="keywordflow">if</span> isinstance(arrays, ndarray):</div>
<div class="line"><span class="lineno"> 1276</span>        <span class="keywordflow">return</span> arrays</div>
<div class="line"><span class="lineno"> 1277</span>    <span class="keywordflow">elif</span> len(arrays) == 1:</div>
<div class="line"><span class="lineno"> 1278</span>        <span class="keywordflow">return</span> arrays[0]</div>
<div class="line"><span class="lineno"> 1279</span>    seqarrays = [np.asanyarray(a).ravel() <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays]</div>
<div class="line"><span class="lineno"> 1280</span>    nrecords = [len(a) <span class="keywordflow">for</span> a <span class="keywordflow">in</span> seqarrays]</div>
<div class="line"><span class="lineno"> 1281</span>    ndtype = [a.dtype <span class="keywordflow">for</span> a <span class="keywordflow">in</span> seqarrays]</div>
<div class="line"><span class="lineno"> 1282</span>    fldnames = [d.names <span class="keywordflow">for</span> d <span class="keywordflow">in</span> ndtype]</div>
<div class="line"><span class="lineno"> 1283</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1284</span>    dtype_l = ndtype[0]</div>
<div class="line"><span class="lineno"> 1285</span>    newdescr = _get_fieldspec(dtype_l)</div>
<div class="line"><span class="lineno"> 1286</span>    names = [n <span class="keywordflow">for</span> n, d <span class="keywordflow">in</span> newdescr]</div>
<div class="line"><span class="lineno"> 1287</span>    <span class="keywordflow">for</span> dtype_n <span class="keywordflow">in</span> ndtype[1:]:</div>
<div class="line"><span class="lineno"> 1288</span>        <span class="keywordflow">for</span> fname, fdtype <span class="keywordflow">in</span> _get_fieldspec(dtype_n):</div>
<div class="line"><span class="lineno"> 1289</span>            <span class="keywordflow">if</span> fname <span class="keywordflow">not</span> <span class="keywordflow">in</span> names:</div>
<div class="line"><span class="lineno"> 1290</span>                newdescr.append((fname, fdtype))</div>
<div class="line"><span class="lineno"> 1291</span>                names.append(fname)</div>
<div class="line"><span class="lineno"> 1292</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1293</span>                nameidx = names.index(fname)</div>
<div class="line"><span class="lineno"> 1294</span>                _, cdtype = newdescr[nameidx]</div>
<div class="line"><span class="lineno"> 1295</span>                <span class="keywordflow">if</span> autoconvert:</div>
<div class="line"><span class="lineno"> 1296</span>                    newdescr[nameidx] = (fname, max(fdtype, cdtype))</div>
<div class="line"><span class="lineno"> 1297</span>                <span class="keywordflow">elif</span> fdtype != cdtype:</div>
<div class="line"><span class="lineno"> 1298</span>                    <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Incompatible type &#39;%s&#39; &lt;&gt; &#39;%s&#39;&quot;</span> %</div>
<div class="line"><span class="lineno"> 1299</span>                                    (cdtype, fdtype))</div>
<div class="line"><span class="lineno"> 1300</span>    <span class="comment"># Only one field: use concatenate</span></div>
<div class="line"><span class="lineno"> 1301</span>    <span class="keywordflow">if</span> len(newdescr) == 1:</div>
<div class="line"><span class="lineno"> 1302</span>        output = ma.concatenate(seqarrays)</div>
<div class="line"><span class="lineno"> 1303</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1304</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1305</span>        output = ma.masked_all((np.sum(nrecords),), newdescr)</div>
<div class="line"><span class="lineno"> 1306</span>        offset = np.cumsum(np.r_[0, nrecords])</div>
<div class="line"><span class="lineno"> 1307</span>        seen = []</div>
<div class="line"><span class="lineno"> 1308</span>        <span class="keywordflow">for</span> (a, n, i, j) <span class="keywordflow">in</span> zip(seqarrays, fldnames, offset[:-1], offset[1:]):</div>
<div class="line"><span class="lineno"> 1309</span>            names = a.dtype.names</div>
<div class="line"><span class="lineno"> 1310</span>            <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1311</span>                output[<span class="stringliteral">&#39;f%i&#39;</span> % len(seen)][i:j] = a</div>
<div class="line"><span class="lineno"> 1312</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1313</span>                <span class="keywordflow">for</span> name <span class="keywordflow">in</span> n:</div>
<div class="line"><span class="lineno"> 1314</span>                    output[name][i:j] = a[name]</div>
<div class="line"><span class="lineno"> 1315</span>                    <span class="keywordflow">if</span> name <span class="keywordflow">not</span> <span class="keywordflow">in</span> seen:</div>
<div class="line"><span class="lineno"> 1316</span>                        seen.append(name)</div>
<div class="line"><span class="lineno"> 1317</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1318</span>    <span class="keywordflow">return</span> _fix_output(_fix_defaults(output, defaults),</div>
<div class="line"><span class="lineno"> 1319</span>                       usemask=usemask, asrecarray=asrecarray)</div>
<div class="line"><span class="lineno"> 1320</span> </div>
<div class="line"><span class="lineno"> 1321</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a37149618be7d8f4aab3e18db4b08743f" name="a37149618be7d8f4aab3e18db4b08743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37149618be7d8f4aab3e18db4b08743f">&#9670;&#160;</a></span>structured_to_unstructured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.structured_to_unstructured </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>'unsafe'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts an n-D structured array into an (n+1)-D unstructured array.

The new array will have a new last dimension equal in size to the
number of field-elements of the input array. If not supplied, the output
datatype is determined from the numpy type promotion rules applied to all
the field datatypes.

Nested fields, as well as each element of any subarray fields, all count
as a single field-elements.

Parameters
----------
arr : ndarray
   Structured array or dtype to convert. Cannot contain object datatype.
dtype : dtype, optional
   The dtype of the output unstructured array.
copy : bool, optional
    See copy argument to `numpy.ndarray.astype`. If true, always return a
    copy. If false, and `dtype` requirements are satisfied, a view is
    returned.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    See casting argument of `numpy.ndarray.astype`. Controls what kind of
    data casting may occur.

Returns
-------
unstructured : ndarray
   Unstructured array with one more dimension.

Examples
--------

&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.zeros(4, dtype=[('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])
&gt;&gt;&gt; a
array([(0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.]),
       (0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.])],
      dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))])
&gt;&gt;&gt; rfn.structured_to_unstructured(a)
array([[0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.]])

&gt;&gt;&gt; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],
...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])
&gt;&gt;&gt; np.mean(rfn.structured_to_unstructured(b[['x', 'z']]), axis=-1)
array([ 3. ,  5.5,  9. , 11. ])</pre> <div class="fragment"><div class="line"><span class="lineno">  894</span><span class="keyword">def </span>structured_to_unstructured(arr, dtype=None, copy=False, casting=&#39;unsafe&#39;):</div>
<div class="line"><span class="lineno">  895</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    Converts an n-D structured array into an (n+1)-D unstructured array.</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    The new array will have a new last dimension equal in size to the</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    number of field-elements of the input array. If not supplied, the output</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    datatype is determined from the numpy type promotion rules applied to all</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    the field datatypes.</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Nested fields, as well as each element of any subarray fields, all count</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    as a single field-elements.</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    arr : ndarray</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">       Structured array or dtype to convert. Cannot contain object datatype.</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">       The dtype of the output unstructured array.</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    copy : bool, optional</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        See copy argument to `numpy.ndarray.astype`. If true, always return a</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        copy. If false, and `dtype` requirements are satisfied, a view is</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">        returned.</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">        See casting argument of `numpy.ndarray.astype`. Controls what kind of</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">        data casting may occur.</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    unstructured : ndarray</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">       Unstructured array with one more dimension.</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros(4, dtype=[(&#39;a&#39;, &#39;i4&#39;), (&#39;b&#39;, &#39;f4,u2&#39;), (&#39;c&#39;, &#39;f4&#39;, 2)])</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    array([(0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.]),</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">           (0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.])],</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">          dtype=[(&#39;a&#39;, &#39;&lt;i4&#39;), (&#39;b&#39;, [(&#39;f0&#39;, &#39;&lt;f4&#39;), (&#39;f1&#39;, &#39;&lt;u2&#39;)]), (&#39;c&#39;, &#39;&lt;f4&#39;, (2,))])</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    &gt;&gt;&gt; rfn.structured_to_unstructured(a)</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    array([[0., 0., 0., 0., 0.],</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">           [0., 0., 0., 0., 0.],</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">           [0., 0., 0., 0., 0.],</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">           [0., 0., 0., 0., 0.]])</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    ...              dtype=[(&#39;x&#39;, &#39;i4&#39;), (&#39;y&#39;, &#39;f4&#39;), (&#39;z&#39;, &#39;f8&#39;)])</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    &gt;&gt;&gt; np.mean(rfn.structured_to_unstructured(b[[&#39;x&#39;, &#39;z&#39;]]), axis=-1)</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    array([ 3. ,  5.5,  9. , 11. ])</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  946</span>    <span class="keywordflow">if</span> arr.dtype.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  947</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;arr must be a structured array&#39;</span>)</div>
<div class="line"><span class="lineno">  948</span> </div>
<div class="line"><span class="lineno">  949</span>    fields = _get_fields_and_offsets(arr.dtype)</div>
<div class="line"><span class="lineno">  950</span>    n_fields = len(fields)</div>
<div class="line"><span class="lineno">  951</span>    <span class="keywordflow">if</span> n_fields == 0 <span class="keywordflow">and</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  952</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;arr has no fields. Unable to guess dtype&quot;</span>)</div>
<div class="line"><span class="lineno">  953</span>    <span class="keywordflow">elif</span> n_fields == 0:</div>
<div class="line"><span class="lineno">  954</span>        <span class="comment"># too many bugs elsewhere for this to work now</span></div>
<div class="line"><span class="lineno">  955</span>        <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;arr with no fields is not supported&quot;</span>)</div>
<div class="line"><span class="lineno">  956</span> </div>
<div class="line"><span class="lineno">  957</span>    dts, counts, offsets = zip(*fields)</div>
<div class="line"><span class="lineno">  958</span>    names = [<span class="stringliteral">&#39;f{}&#39;</span>.format(n) <span class="keywordflow">for</span> n <span class="keywordflow">in</span> range(n_fields)]</div>
<div class="line"><span class="lineno">  959</span> </div>
<div class="line"><span class="lineno">  960</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  961</span>        out_dtype = np.result_type(*[dt.base <span class="keywordflow">for</span> dt <span class="keywordflow">in</span> dts])</div>
<div class="line"><span class="lineno">  962</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  963</span>        out_dtype = dtype</div>
<div class="line"><span class="lineno">  964</span> </div>
<div class="line"><span class="lineno">  965</span>    <span class="comment"># Use a series of views and casts to convert to an unstructured array:</span></div>
<div class="line"><span class="lineno">  966</span> </div>
<div class="line"><span class="lineno">  967</span>    <span class="comment"># first view using flattened fields (doesn&#39;t work for object arrays)</span></div>
<div class="line"><span class="lineno">  968</span>    <span class="comment"># Note: dts may include a shape for subarrays</span></div>
<div class="line"><span class="lineno">  969</span>    flattened_fields = np.dtype({<span class="stringliteral">&#39;names&#39;</span>: names,</div>
<div class="line"><span class="lineno">  970</span>                                 <span class="stringliteral">&#39;formats&#39;</span>: dts,</div>
<div class="line"><span class="lineno">  971</span>                                 <span class="stringliteral">&#39;offsets&#39;</span>: offsets,</div>
<div class="line"><span class="lineno">  972</span>                                 <span class="stringliteral">&#39;itemsize&#39;</span>: arr.dtype.itemsize})</div>
<div class="line"><span class="lineno">  973</span>    arr = arr.view(flattened_fields)</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>    <span class="comment"># next cast to a packed format with all fields converted to new dtype</span></div>
<div class="line"><span class="lineno">  976</span>    packed_fields = np.dtype({<span class="stringliteral">&#39;names&#39;</span>: names,</div>
<div class="line"><span class="lineno">  977</span>                              <span class="stringliteral">&#39;formats&#39;</span>: [(out_dtype, dt.shape) <span class="keywordflow">for</span> dt <span class="keywordflow">in</span> dts]})</div>
<div class="line"><span class="lineno">  978</span>    arr = arr.astype(packed_fields, copy=copy, casting=casting)</div>
<div class="line"><span class="lineno">  979</span> </div>
<div class="line"><span class="lineno">  980</span>    <span class="comment"># finally is it safe to view the packed fields as the unstructured type</span></div>
<div class="line"><span class="lineno">  981</span>    <span class="keywordflow">return</span> arr.view((out_dtype, (sum(counts),)))</div>
<div class="line"><span class="lineno">  982</span> </div>
<div class="line"><span class="lineno">  983</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa73ee9d38458b5687a92938d264119b" name="aaa73ee9d38458b5687a92938d264119b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa73ee9d38458b5687a92938d264119b">&#9670;&#160;</a></span>unstructured_to_structured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions.unstructured_to_structured </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>'unsafe'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts an n-D unstructured array into an (n-1)-D structured array.

The last dimension of the input array is converted into a structure, with
number of field-elements equal to the size of the last dimension of the
input array. By default all output fields have the input array's dtype, but
an output structured dtype with an equal number of fields-elements can be
supplied instead.

Nested fields, as well as each element of any subarray fields, all count
towards the number of field-elements.

Parameters
----------
arr : ndarray
   Unstructured array or dtype to convert.
dtype : dtype, optional
   The structured dtype of the output array
names : list of strings, optional
   If dtype is not supplied, this specifies the field names for the output
   dtype, in order. The field dtypes will be the same as the input array.
align : boolean, optional
   Whether to create an aligned memory layout.
copy : bool, optional
    See copy argument to `numpy.ndarray.astype`. If true, always return a
    copy. If false, and `dtype` requirements are satisfied, a view is
    returned.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    See casting argument of `numpy.ndarray.astype`. Controls what kind of
    data casting may occur.

Returns
-------
structured : ndarray
   Structured array with fewer dimensions.

Examples
--------

&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; dt = np.dtype([('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])
&gt;&gt;&gt; a = np.arange(20).reshape((4,5))
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19]])
&gt;&gt;&gt; rfn.unstructured_to_structured(a, dt)
array([( 0, ( 1.,  2), [ 3.,  4.]), ( 5, ( 6.,  7), [ 8.,  9.]),
       (10, (11., 12), [13., 14.]), (15, (16., 17), [18., 19.])],
      dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))])</pre> <div class="fragment"><div class="line"><span class="lineno">  990</span>                               copy=<span class="keyword">False</span>, casting=<span class="stringliteral">&#39;unsafe&#39;</span>):</div>
<div class="line"><span class="lineno">  991</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    Converts an n-D unstructured array into an (n-1)-D structured array.</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    The last dimension of the input array is converted into a structure, with</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    number of field-elements equal to the size of the last dimension of the</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    input array. By default all output fields have the input array&#39;s dtype, but</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    an output structured dtype with an equal number of fields-elements can be</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    supplied instead.</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    Nested fields, as well as each element of any subarray fields, all count</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    towards the number of field-elements.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    arr : ndarray</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">       Unstructured array or dtype to convert.</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">       The structured dtype of the output array</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    names : list of strings, optional</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">       If dtype is not supplied, this specifies the field names for the output</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">       dtype, in order. The field dtypes will be the same as the input array.</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    align : boolean, optional</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">       Whether to create an aligned memory layout.</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    copy : bool, optional</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">        See copy argument to `numpy.ndarray.astype`. If true, always return a</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">        copy. If false, and `dtype` requirements are satisfied, a view is</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        returned.</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">        See casting argument of `numpy.ndarray.astype`. Controls what kind of</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">        data casting may occur.</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    structured : ndarray</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">       Structured array with fewer dimensions.</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    &gt;&gt;&gt; dt = np.dtype([(&#39;a&#39;, &#39;i4&#39;), (&#39;b&#39;, &#39;f4,u2&#39;), (&#39;c&#39;, &#39;f4&#39;, 2)])</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(20).reshape((4,5))</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    array([[ 0,  1,  2,  3,  4],</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">           [ 5,  6,  7,  8,  9],</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">           [10, 11, 12, 13, 14],</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">           [15, 16, 17, 18, 19]])</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    &gt;&gt;&gt; rfn.unstructured_to_structured(a, dt)</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    array([( 0, ( 1.,  2), [ 3.,  4.]), ( 5, ( 6.,  7), [ 8.,  9.]),</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">           (10, (11., 12), [13., 14.]), (15, (16., 17), [18., 19.])],</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">          dtype=[(&#39;a&#39;, &#39;&lt;i4&#39;), (&#39;b&#39;, [(&#39;f0&#39;, &#39;&lt;f4&#39;), (&#39;f1&#39;, &#39;&lt;u2&#39;)]), (&#39;c&#39;, &#39;&lt;f4&#39;, (2,))])</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1044</span>    <span class="keywordflow">if</span> arr.shape == ():</div>
<div class="line"><span class="lineno"> 1045</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;arr must have at least one dimension&#39;</span>)</div>
<div class="line"><span class="lineno"> 1046</span>    n_elem = arr.shape[-1]</div>
<div class="line"><span class="lineno"> 1047</span>    <span class="keywordflow">if</span> n_elem == 0:</div>
<div class="line"><span class="lineno"> 1048</span>        <span class="comment"># too many bugs elsewhere for this to work now</span></div>
<div class="line"><span class="lineno"> 1049</span>        <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;last axis with size 0 is not supported&quot;</span>)</div>
<div class="line"><span class="lineno"> 1050</span> </div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1052</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1053</span>            names = [<span class="stringliteral">&#39;f{}&#39;</span>.format(n) <span class="keywordflow">for</span> n <span class="keywordflow">in</span> range(n_elem)]</div>
<div class="line"><span class="lineno"> 1054</span>        out_dtype = np.dtype([(n, arr.dtype) <span class="keywordflow">for</span> n <span class="keywordflow">in</span> names], align=align)</div>
<div class="line"><span class="lineno"> 1055</span>        fields = _get_fields_and_offsets(out_dtype)</div>
<div class="line"><span class="lineno"> 1056</span>        dts, counts, offsets = zip(*fields)</div>
<div class="line"><span class="lineno"> 1057</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1058</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1059</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;don&#39;t supply both dtype and names&quot;</span>)</div>
<div class="line"><span class="lineno"> 1060</span>        <span class="comment"># if dtype is the args of np.dtype, construct it</span></div>
<div class="line"><span class="lineno"> 1061</span>        dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno"> 1062</span>        <span class="comment"># sanity check of the input dtype</span></div>
<div class="line"><span class="lineno"> 1063</span>        fields = _get_fields_and_offsets(dtype)</div>
<div class="line"><span class="lineno"> 1064</span>        <span class="keywordflow">if</span> len(fields) == 0:</div>
<div class="line"><span class="lineno"> 1065</span>            dts, counts, offsets = [], [], []</div>
<div class="line"><span class="lineno"> 1066</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1067</span>            dts, counts, offsets = zip(*fields)</div>
<div class="line"><span class="lineno"> 1068</span> </div>
<div class="line"><span class="lineno"> 1069</span>        <span class="keywordflow">if</span> n_elem != sum(counts):</div>
<div class="line"><span class="lineno"> 1070</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The length of the last dimension of arr must &#39;</span></div>
<div class="line"><span class="lineno"> 1071</span>                             <span class="stringliteral">&#39;be equal to the number of fields in dtype&#39;</span>)</div>
<div class="line"><span class="lineno"> 1072</span>        out_dtype = dtype</div>
<div class="line"><span class="lineno"> 1073</span>        <span class="keywordflow">if</span> align <span class="keywordflow">and</span> <span class="keywordflow">not</span> out_dtype.isalignedstruct:</div>
<div class="line"><span class="lineno"> 1074</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;align was True but dtype is not aligned&quot;</span>)</div>
<div class="line"><span class="lineno"> 1075</span> </div>
<div class="line"><span class="lineno"> 1076</span>    names = [<span class="stringliteral">&#39;f{}&#39;</span>.format(n) <span class="keywordflow">for</span> n <span class="keywordflow">in</span> range(len(fields))]</div>
<div class="line"><span class="lineno"> 1077</span> </div>
<div class="line"><span class="lineno"> 1078</span>    <span class="comment"># Use a series of views and casts to convert to a structured array:</span></div>
<div class="line"><span class="lineno"> 1079</span> </div>
<div class="line"><span class="lineno"> 1080</span>    <span class="comment"># first view as a packed structured array of one dtype</span></div>
<div class="line"><span class="lineno"> 1081</span>    packed_fields = np.dtype({<span class="stringliteral">&#39;names&#39;</span>: names,</div>
<div class="line"><span class="lineno"> 1082</span>                              <span class="stringliteral">&#39;formats&#39;</span>: [(arr.dtype, dt.shape) <span class="keywordflow">for</span> dt <span class="keywordflow">in</span> dts]})</div>
<div class="line"><span class="lineno"> 1083</span>    arr = np.ascontiguousarray(arr).view(packed_fields)</div>
<div class="line"><span class="lineno"> 1084</span> </div>
<div class="line"><span class="lineno"> 1085</span>    <span class="comment"># next cast to an unpacked but flattened format with varied dtypes</span></div>
<div class="line"><span class="lineno"> 1086</span>    flattened_fields = np.dtype({<span class="stringliteral">&#39;names&#39;</span>: names,</div>
<div class="line"><span class="lineno"> 1087</span>                                 <span class="stringliteral">&#39;formats&#39;</span>: dts,</div>
<div class="line"><span class="lineno"> 1088</span>                                 <span class="stringliteral">&#39;offsets&#39;</span>: offsets,</div>
<div class="line"><span class="lineno"> 1089</span>                                 <span class="stringliteral">&#39;itemsize&#39;</span>: out_dtype.itemsize})</div>
<div class="line"><span class="lineno"> 1090</span>    arr = arr.astype(flattened_fields, copy=copy, casting=casting)</div>
<div class="line"><span class="lineno"> 1091</span> </div>
<div class="line"><span class="lineno"> 1092</span>    <span class="comment"># finally view as the final nested dtype and remove the last axis</span></div>
<div class="line"><span class="lineno"> 1093</span>    <span class="keywordflow">return</span> arr.view(out_dtype)[..., 0]</div>
<div class="line"><span class="lineno"> 1094</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a27198198789b1c59344e1bc612310f5f" name="a27198198789b1c59344e1bc612310f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27198198789b1c59344e1bc612310f5f">&#9670;&#160;</a></span>_check_fill_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.recfunctions._check_fill_value = np.ma.core._check_fill_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
