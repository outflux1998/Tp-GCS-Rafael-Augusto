<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.nanfunctions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html">nanfunctions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.nanfunctions Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d510245a1787487f5cbfa5d9ca7a1af" id="r_a6d510245a1787487f5cbfa5d9ca7a1af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a6d510245a1787487f5cbfa5d9ca7a1af">_nan_mask</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, out=None)</td></tr>
<tr class="separator:a6d510245a1787487f5cbfa5d9ca7a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8213190b114ca822a33c2e4c1079fd35" id="r_a8213190b114ca822a33c2e4c1079fd35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a8213190b114ca822a33c2e4c1079fd35">_replace_nan</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, val)</td></tr>
<tr class="separator:a8213190b114ca822a33c2e4c1079fd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e2451daffe81289ebe9bcae1044ee4" id="r_af1e2451daffe81289ebe9bcae1044ee4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#af1e2451daffe81289ebe9bcae1044ee4">_copyto</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, val, mask)</td></tr>
<tr class="separator:af1e2451daffe81289ebe9bcae1044ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974efb81de64a4fe552134efafe878c8" id="r_a974efb81de64a4fe552134efafe878c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a974efb81de64a4fe552134efafe878c8">_remove_nan_1d</a> (arr1d, overwrite_input=False)</td></tr>
<tr class="separator:a974efb81de64a4fe552134efafe878c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4523a32b1014d37e34b29c60ca2f30b" id="r_ad4523a32b1014d37e34b29c60ca2f30b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#ad4523a32b1014d37e34b29c60ca2f30b">_divide_by_count</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, out=None)</td></tr>
<tr class="separator:ad4523a32b1014d37e34b29c60ca2f30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edb97735505a066a20989efc963d582" id="r_a5edb97735505a066a20989efc963d582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a5edb97735505a066a20989efc963d582">_nanmin_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:a5edb97735505a066a20989efc963d582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622a8d29d82d09d7bf06dccb942526e5" id="r_a622a8d29d82d09d7bf06dccb942526e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a622a8d29d82d09d7bf06dccb942526e5">nanmin</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:a622a8d29d82d09d7bf06dccb942526e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c45e5508e4e57e740ba2a0e1677734d" id="r_a0c45e5508e4e57e740ba2a0e1677734d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a0c45e5508e4e57e740ba2a0e1677734d">_nanmax_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:a0c45e5508e4e57e740ba2a0e1677734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d33ee14bafd4171305074df869a502" id="r_a07d33ee14bafd4171305074df869a502"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a07d33ee14bafd4171305074df869a502">nanmax</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:a07d33ee14bafd4171305074df869a502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12331fa9483c6c8545516fa507a12509" id="r_a12331fa9483c6c8545516fa507a12509"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a12331fa9483c6c8545516fa507a12509">_nanargmin_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=None)</td></tr>
<tr class="separator:a12331fa9483c6c8545516fa507a12509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d0ec8fca610478c34982392115ebb" id="r_af92d0ec8fca610478c34982392115ebb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#af92d0ec8fca610478c34982392115ebb">nanargmin</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=np._NoValue)</td></tr>
<tr class="separator:af92d0ec8fca610478c34982392115ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6f6ebfb469216c7de1588cd39df66a" id="r_abb6f6ebfb469216c7de1588cd39df66a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#abb6f6ebfb469216c7de1588cd39df66a">_nanargmax_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=None)</td></tr>
<tr class="separator:abb6f6ebfb469216c7de1588cd39df66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4c384a41e8da1e0727a30db67a688f" id="r_aff4c384a41e8da1e0727a30db67a688f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#aff4c384a41e8da1e0727a30db67a688f">nanargmax</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, *keepdims=np._NoValue)</td></tr>
<tr class="separator:aff4c384a41e8da1e0727a30db67a688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aedee7c67d57ea38cee56324d6e2891" id="r_a6aedee7c67d57ea38cee56324d6e2891"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a6aedee7c67d57ea38cee56324d6e2891">_nansum_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:a6aedee7c67d57ea38cee56324d6e2891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd31c1b8a284fbcd994e473c6672048" id="r_abfd31c1b8a284fbcd994e473c6672048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#abfd31c1b8a284fbcd994e473c6672048">nansum</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:abfd31c1b8a284fbcd994e473c6672048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0915719319200c5de44ec99426f4821" id="r_af0915719319200c5de44ec99426f4821"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#af0915719319200c5de44ec99426f4821">_nanprod_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:af0915719319200c5de44ec99426f4821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50471a3a92bdbb41a9bd4e8733c5ef6c" id="r_a50471a3a92bdbb41a9bd4e8733c5ef6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a50471a3a92bdbb41a9bd4e8733c5ef6c">nanprod</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=np._NoValue, initial=np._NoValue, where=np._NoValue)</td></tr>
<tr class="separator:a50471a3a92bdbb41a9bd4e8733c5ef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462955f0dd854834a6b55f1857c9d2df" id="r_a462955f0dd854834a6b55f1857c9d2df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a462955f0dd854834a6b55f1857c9d2df">_nancumsum_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:a462955f0dd854834a6b55f1857c9d2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e327046571f8722c2eca5c8210c975" id="r_ad8e327046571f8722c2eca5c8210c975"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#ad8e327046571f8722c2eca5c8210c975">nancumsum</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:ad8e327046571f8722c2eca5c8210c975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e9e6ac15558d3cab14a35d9ce69574" id="r_ac2e9e6ac15558d3cab14a35d9ce69574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#ac2e9e6ac15558d3cab14a35d9ce69574">_nancumprod_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:ac2e9e6ac15558d3cab14a35d9ce69574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80c1525377406324144425eef7881f6" id="r_ab80c1525377406324144425eef7881f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#ab80c1525377406324144425eef7881f6">nancumprod</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:ab80c1525377406324144425eef7881f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643eefd2e3569996d12eef40351a0b1a" id="r_a643eefd2e3569996d12eef40351a0b1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a643eefd2e3569996d12eef40351a0b1a">_nanmean_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=None, *where=None)</td></tr>
<tr class="separator:a643eefd2e3569996d12eef40351a0b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc95c78e139c56d3190eef1c253c6ca" id="r_a3dc95c78e139c56d3190eef1c253c6ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a3dc95c78e139c56d3190eef1c253c6ca">nanmean</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:a3dc95c78e139c56d3190eef1c253c6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33708b8dd5ed6cb6484b484caa8ff57" id="r_aa33708b8dd5ed6cb6484b484caa8ff57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#aa33708b8dd5ed6cb6484b484caa8ff57">_nanmedian1d</a> (arr1d, overwrite_input=False)</td></tr>
<tr class="separator:aa33708b8dd5ed6cb6484b484caa8ff57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa72a8ef38dc1226c1b13043ad41835f" id="r_aaa72a8ef38dc1226c1b13043ad41835f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#aaa72a8ef38dc1226c1b13043ad41835f">_nanmedian</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, overwrite_input=False)</td></tr>
<tr class="separator:aaa72a8ef38dc1226c1b13043ad41835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec3450a13ac6ad57995b1f2ddb5b7ab" id="r_a8ec3450a13ac6ad57995b1f2ddb5b7ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a8ec3450a13ac6ad57995b1f2ddb5b7ab">_nanmedian_small</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, overwrite_input=False)</td></tr>
<tr class="separator:a8ec3450a13ac6ad57995b1f2ddb5b7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f3194c29aee4e2de7eedc272f19318" id="r_a20f3194c29aee4e2de7eedc272f19318"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a20f3194c29aee4e2de7eedc272f19318">_nanmedian_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, overwrite_input=None, keepdims=None)</td></tr>
<tr class="separator:a20f3194c29aee4e2de7eedc272f19318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1f2fa26bee9157714e5029ee68f8ee" id="r_a3b1f2fa26bee9157714e5029ee68f8ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a3b1f2fa26bee9157714e5029ee68f8ee">nanmedian</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, overwrite_input=False, keepdims=np._NoValue)</td></tr>
<tr class="separator:a3b1f2fa26bee9157714e5029ee68f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682454b8fd256f03a815ceb6a09ec65f" id="r_a682454b8fd256f03a815ceb6a09ec65f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a682454b8fd256f03a815ceb6a09ec65f">_nanpercentile_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=None, method=None, keepdims=None, *interpolation=None)</td></tr>
<tr class="separator:a682454b8fd256f03a815ceb6a09ec65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976a8bb7f27b4bc79b057ad332339635" id="r_a976a8bb7f27b4bc79b057ad332339635"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a976a8bb7f27b4bc79b057ad332339635">nanpercentile</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=False, method=&quot;linear&quot;, keepdims=np._NoValue, *interpolation=None)</td></tr>
<tr class="separator:a976a8bb7f27b4bc79b057ad332339635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4357933022152c7a9dc6d5eed7b0b6" id="r_a7e4357933022152c7a9dc6d5eed7b0b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a7e4357933022152c7a9dc6d5eed7b0b6">_nanquantile_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=None, method=None, keepdims=None, *interpolation=None)</td></tr>
<tr class="separator:a7e4357933022152c7a9dc6d5eed7b0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6391c2e655b930a0ec53f1fc51893c" id="r_aeb6391c2e655b930a0ec53f1fc51893c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#aeb6391c2e655b930a0ec53f1fc51893c">nanquantile</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=False, method=&quot;linear&quot;, keepdims=np._NoValue, *interpolation=None)</td></tr>
<tr class="separator:aeb6391c2e655b930a0ec53f1fc51893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be18385bcb80ed0da9fb56172f01581" id="r_a0be18385bcb80ed0da9fb56172f01581"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a0be18385bcb80ed0da9fb56172f01581">_nanquantile_unchecked</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=False, method=&quot;linear&quot;, keepdims=np._NoValue)</td></tr>
<tr class="separator:a0be18385bcb80ed0da9fb56172f01581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a72906d758170b7961a0275971930c0" id="r_a9a72906d758170b7961a0275971930c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a9a72906d758170b7961a0275971930c0">_nanquantile_ureduce_func</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=False, method=&quot;linear&quot;)</td></tr>
<tr class="separator:a9a72906d758170b7961a0275971930c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd93ae8bfafef4f8032f5b5e2a93b23" id="r_afdd93ae8bfafef4f8032f5b5e2a93b23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#afdd93ae8bfafef4f8032f5b5e2a93b23">_nanquantile_1d</a> (arr1d, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, overwrite_input=False, method=&quot;linear&quot;)</td></tr>
<tr class="separator:afdd93ae8bfafef4f8032f5b5e2a93b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f7856e59418753f2cdbf9a938e9770" id="r_a64f7856e59418753f2cdbf9a938e9770"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a64f7856e59418753f2cdbf9a938e9770">_nanvar_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=None, keepdims=None, *where=None)</td></tr>
<tr class="separator:a64f7856e59418753f2cdbf9a938e9770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4169784e618dc4d646c2be35efb7cd" id="r_a2f4169784e618dc4d646c2be35efb7cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a2f4169784e618dc4d646c2be35efb7cd">nanvar</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:a2f4169784e618dc4d646c2be35efb7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f742760a74676e961a3235f5058e51" id="r_a37f742760a74676e961a3235f5058e51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a37f742760a74676e961a3235f5058e51">_nanstd_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=None, keepdims=None, *where=None)</td></tr>
<tr class="separator:a37f742760a74676e961a3235f5058e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73682f653bf46927e2386511e7cb190e" id="r_a73682f653bf46927e2386511e7cb190e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a73682f653bf46927e2386511e7cb190e">nanstd</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *where=np._NoValue)</td></tr>
<tr class="separator:a73682f653bf46927e2386511e7cb190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5d66ace42e50dfe8f961bdaad0c9ff6e" id="r_a5d66ace42e50dfe8f961bdaad0c9ff6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a5d66ace42e50dfe8f961bdaad0c9ff6e">array_function_dispatch</a></td></tr>
<tr class="separator:a5d66ace42e50dfe8f961bdaad0c9ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions that ignore NaN.

Functions
---------

- `nanmin` -- minimum non-NaN value
- `nanmax` -- maximum non-NaN value
- `nanargmin` -- index of minimum non-NaN value
- `nanargmax` -- index of maximum non-NaN value
- `nansum` -- sum of non-NaN values
- `nanprod` -- product of non-NaN values
- `nancumsum` -- cumulative sum of non-NaN values
- `nancumprod` -- cumulative product of non-NaN values
- `nanmean` -- mean of non-NaN values
- `nanvar` -- variance of non-NaN values
- `nanstd` -- standard deviation of non-NaN values
- `nanmedian` -- median of non-NaN values
- `nanquantile` -- qth quantile of non-NaN values
- `nanpercentile` -- qth percentile of non-NaN values</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="af1e2451daffe81289ebe9bcae1044ee4" name="af1e2451daffe81289ebe9bcae1044ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e2451daffe81289ebe9bcae1044ee4">&#9670;&#160;</a></span>_copyto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._copyto </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Replace values in `a` with NaN where `mask` is True.  This differs from
copyto in that it will deal with the case where `a` is a numpy scalar.

Parameters
----------
a : ndarray or numpy scalar
    Array or numpy scalar some of whose values are to be replaced
    by val.
val : numpy scalar
    Value used a replacement.
mask : ndarray, scalar
    Boolean array. Where True the corresponding element of `a` is
    replaced by `val`. Broadcasts.

Returns
-------
res : ndarray, scalar
    Array with elements replaced or scalar `val`.</pre> <div class="fragment"><div class="line"><span class="lineno">  113</span><span class="keyword">def </span>_copyto(a, val, mask):</div>
<div class="line"><span class="lineno">  114</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    Replace values in `a` with NaN where `mask` is True.  This differs from</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    copyto in that it will deal with the case where `a` is a numpy scalar.</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    a : ndarray or numpy scalar</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        Array or numpy scalar some of whose values are to be replaced</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        by val.</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    val : numpy scalar</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">        Value used a replacement.</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    mask : ndarray, scalar</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        Boolean array. Where True the corresponding element of `a` is</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        replaced by `val`. Broadcasts.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    res : ndarray, scalar</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">        Array with elements replaced or scalar `val`.</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  135</span>    <span class="keywordflow">if</span> isinstance(a, np.ndarray):</div>
<div class="line"><span class="lineno">  136</span>        np.copyto(a, val, where=mask, casting=<span class="stringliteral">&#39;unsafe&#39;</span>)</div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  138</span>        a = a.dtype.type(val)</div>
<div class="line"><span class="lineno">  139</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4523a32b1014d37e34b29c60ca2f30b" name="ad4523a32b1014d37e34b29c60ca2f30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4523a32b1014d37e34b29c60ca2f30b">&#9670;&#160;</a></span>_divide_by_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._divide_by_count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a/b ignoring invalid results. If `a` is an array the division
is done in place. If `a` is a scalar, then its type is preserved in the
output. If out is None, then a is used instead so that the division
is in place. Note that this is only called with `a` an inexact type.

Parameters
----------
a : {ndarray, numpy scalar}
    Numerator. Expected to be of inexact type but not checked.
b : {ndarray, numpy scalar}
    Denominator.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.

Returns
-------
ret : {ndarray, numpy scalar}
    The return value is a/b. If `a` was an ndarray the division is done
    in place. If `a` is a numpy scalar, the division preserves its type.</pre> <div class="fragment"><div class="line"><span class="lineno">  187</span><span class="keyword">def </span>_divide_by_count(a, b, out=None):</div>
<div class="line"><span class="lineno">  188</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    Compute a/b ignoring invalid results. If `a` is an array the division</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    is done in place. If `a` is a scalar, then its type is preserved in the</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    output. If out is None, then a is used instead so that the division</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    is in place. Note that this is only called with `a` an inexact type.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    a : {ndarray, numpy scalar}</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        Numerator. Expected to be of inexact type but not checked.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    b : {ndarray, numpy scalar}</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">        Denominator.</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        is ``None``; if provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        expected output, but the type will be cast if necessary.</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    ret : {ndarray, numpy scalar}</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        The return value is a/b. If `a` was an ndarray the division is done</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        in place. If `a` is a numpy scalar, the division preserves its type.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  212</span>    <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>, divide=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno">  213</span>        <span class="keywordflow">if</span> isinstance(a, np.ndarray):</div>
<div class="line"><span class="lineno">  214</span>            <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  215</span>                <span class="keywordflow">return</span> np.divide(a, b, out=a, casting=<span class="stringliteral">&#39;unsafe&#39;</span>)</div>
<div class="line"><span class="lineno">  216</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  217</span>                <span class="keywordflow">return</span> np.divide(a, b, out=out, casting=<span class="stringliteral">&#39;unsafe&#39;</span>)</div>
<div class="line"><span class="lineno">  218</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  219</span>            <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  220</span>                <span class="comment"># Precaution against reduced object arrays</span></div>
<div class="line"><span class="lineno">  221</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  222</span>                    <span class="keywordflow">return</span> a.dtype.type(a / b)</div>
<div class="line"><span class="lineno">  223</span>                <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno">  224</span>                    <span class="keywordflow">return</span> a / b</div>
<div class="line"><span class="lineno">  225</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  226</span>                <span class="comment"># This is questionable, but currently a numpy scalar can</span></div>
<div class="line"><span class="lineno">  227</span>                <span class="comment"># be output to a zero dimensional array.</span></div>
<div class="line"><span class="lineno">  228</span>                <span class="keywordflow">return</span> np.divide(a, b, out=out, casting=<span class="stringliteral">&#39;unsafe&#39;</span>)</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d510245a1787487f5cbfa5d9ca7a1af" name="a6d510245a1787487f5cbfa5d9ca7a1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d510245a1787487f5cbfa5d9ca7a1af">&#9670;&#160;</a></span>_nan_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nan_mask </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
a : array-like
    Input array with at least 1 dimension.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output and will prevent the allocation of a new array.

Returns
-------
y : bool ndarray or True
    A bool array where ``np.nan`` positions are marked with ``False``
    and other positions are marked with ``True``. If the type of ``a``
    is such that it can't possibly contain ``np.nan``, returns ``True``.
</pre> <div class="fragment"><div class="line"><span class="lineno">   41</span><span class="keyword">def </span>_nan_mask(a, out=None):</div>
<div class="line"><span class="lineno">   42</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    a : array-like</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        Input array with at least 1 dimension.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        is ``None``; if provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        expected output and will prevent the allocation of a new array.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    y : bool ndarray or True</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">        A bool array where ``np.nan`` positions are marked with ``False``</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">        and other positions are marked with ``True``. If the type of ``a``</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">        is such that it can&#39;t possibly contain ``np.nan``, returns ``True``.</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   59</span>    <span class="comment"># we assume that a is an array for this private function</span></div>
<div class="line"><span class="lineno">   60</span> </div>
<div class="line"><span class="lineno">   61</span>    <span class="keywordflow">if</span> a.dtype.kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> <span class="stringliteral">&#39;fc&#39;</span>:</div>
<div class="line"><span class="lineno">   62</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">   63</span> </div>
<div class="line"><span class="lineno">   64</span>    y = np.isnan(a, out=out)</div>
<div class="line"><span class="lineno">   65</span>    y = np.invert(y, out=y)</div>
<div class="line"><span class="lineno">   66</span>    <span class="keywordflow">return</span> y</div>
<div class="line"><span class="lineno">   67</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abb6f6ebfb469216c7de1588cd39df66a" name="abb6f6ebfb469216c7de1588cd39df66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6f6ebfb469216c7de1588cd39df66a">&#9670;&#160;</a></span>_nanargmax_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanargmax_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  557</span><span class="keyword">def </span>_nanargmax_dispatcher(a, axis=None, out=None, *, keepdims=None):</div>
<div class="line"><span class="lineno">  558</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  559</span> </div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span><span class="preprocessor">@array_function_dispatch(_nanargmax_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a12331fa9483c6c8545516fa507a12509" name="a12331fa9483c6c8545516fa507a12509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12331fa9483c6c8545516fa507a12509">&#9670;&#160;</a></span>_nanargmin_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanargmin_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  497</span><span class="keyword">def </span>_nanargmin_dispatcher(a, axis=None, out=None, *, keepdims=None):</div>
<div class="line"><span class="lineno">  498</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  499</span> </div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span><span class="preprocessor">@array_function_dispatch(_nanargmin_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2e9e6ac15558d3cab14a35d9ce69574" name="ac2e9e6ac15558d3cab14a35d9ce69574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e9e6ac15558d3cab14a35d9ce69574">&#9670;&#160;</a></span>_nancumprod_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nancumprod_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  880</span><span class="keyword">def </span>_nancumprod_dispatcher(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno">  881</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">  882</span> </div>
<div class="line"><span class="lineno">  883</span> </div>
<div class="line"><span class="lineno">  884</span><span class="preprocessor">@array_function_dispatch(_nancumprod_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a462955f0dd854834a6b55f1857c9d2df" name="a462955f0dd854834a6b55f1857c9d2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462955f0dd854834a6b55f1857c9d2df">&#9670;&#160;</a></span>_nancumsum_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nancumsum_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  810</span><span class="keyword">def </span>_nancumsum_dispatcher(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno">  811</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">  812</span> </div>
<div class="line"><span class="lineno">  813</span> </div>
<div class="line"><span class="lineno">  814</span><span class="preprocessor">@array_function_dispatch(_nancumsum_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c45e5508e4e57e740ba2a0e1677734d" name="a0c45e5508e4e57e740ba2a0e1677734d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c45e5508e4e57e740ba2a0e1677734d">&#9670;&#160;</a></span>_nanmax_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanmax_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  365</span>                       initial=<span class="keywordtype">None</span>, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  366</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">  367</span> </div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span><span class="preprocessor">@array_function_dispatch(_nanmax_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a643eefd2e3569996d12eef40351a0b1a" name="a643eefd2e3569996d12eef40351a0b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643eefd2e3569996d12eef40351a0b1a">&#9670;&#160;</a></span>_nanmean_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanmean_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  948</span>                        *, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  949</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">  950</span> </div>
<div class="line"><span class="lineno">  951</span> </div>
<div class="line"><span class="lineno">  952</span><span class="preprocessor">@array_function_dispatch(_nanmean_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa72a8ef38dc1226c1b13043ad41835f" name="aaa72a8ef38dc1226c1b13043ad41835f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa72a8ef38dc1226c1b13043ad41835f">&#9670;&#160;</a></span>_nanmedian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanmedian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function that doesn't support extended axis or keepdims.
These methods are extended to this function using _ureduce
See nanmedian for parameter usage</pre> <div class="fragment"><div class="line"><span class="lineno"> 1075</span><span class="keyword">def </span>_nanmedian(a, axis=None, out=None, overwrite_input=False):</div>
<div class="line"><span class="lineno"> 1076</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    Private function that doesn&#39;t support extended axis or keepdims.</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    These methods are extended to this function using _ureduce</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    See nanmedian for parameter usage</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1082</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> a.ndim == 1:</div>
<div class="line"><span class="lineno"> 1083</span>        part = a.ravel()</div>
<div class="line"><span class="lineno"> 1084</span>        <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1085</span>            <span class="keywordflow">return</span> _nanmedian1d(part, overwrite_input)</div>
<div class="line"><span class="lineno"> 1086</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1087</span>            out[...] = _nanmedian1d(part, overwrite_input)</div>
<div class="line"><span class="lineno"> 1088</span>            <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1089</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1090</span>        <span class="comment"># for small medians use sort + indexing which is still faster than</span></div>
<div class="line"><span class="lineno"> 1091</span>        <span class="comment"># apply_along_axis</span></div>
<div class="line"><span class="lineno"> 1092</span>        <span class="comment"># benchmarked with shuffled (50, 50, x) containing a few NaN</span></div>
<div class="line"><span class="lineno"> 1093</span>        <span class="keywordflow">if</span> a.shape[axis] &lt; 600:</div>
<div class="line"><span class="lineno"> 1094</span>            <span class="keywordflow">return</span> _nanmedian_small(a, axis, out, overwrite_input)</div>
<div class="line"><span class="lineno"> 1095</span>        result = np.apply_along_axis(_nanmedian1d, axis, a, overwrite_input)</div>
<div class="line"><span class="lineno"> 1096</span>        <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1097</span>            out[...] = result</div>
<div class="line"><span class="lineno"> 1098</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1099</span> </div>
<div class="line"><span class="lineno"> 1100</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa33708b8dd5ed6cb6484b484caa8ff57" name="aa33708b8dd5ed6cb6484b484caa8ff57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33708b8dd5ed6cb6484b484caa8ff57">&#9670;&#160;</a></span>_nanmedian1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanmedian1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function for rank 1 arrays. Compute the median ignoring NaNs.
See nanmedian for parameter usage
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1058</span><span class="keyword">def </span>_nanmedian1d(arr1d, overwrite_input=False):</div>
<div class="line"><span class="lineno"> 1059</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    Private function for rank 1 arrays. Compute the median ignoring NaNs.</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    See nanmedian for parameter usage</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1063</span>    arr1d_parsed, overwrite_input = _remove_nan_1d(</div>
<div class="line"><span class="lineno"> 1064</span>        arr1d, overwrite_input=overwrite_input,</div>
<div class="line"><span class="lineno"> 1065</span>    )</div>
<div class="line"><span class="lineno"> 1066</span> </div>
<div class="line"><span class="lineno"> 1067</span>    <span class="keywordflow">if</span> arr1d_parsed.size == 0:</div>
<div class="line"><span class="lineno"> 1068</span>        <span class="comment"># Ensure that a nan-esque scalar of the appropriate type (and unit)</span></div>
<div class="line"><span class="lineno"> 1069</span>        <span class="comment"># is returned for `timedelta64` and `complexfloating`</span></div>
<div class="line"><span class="lineno"> 1070</span>        <span class="keywordflow">return</span> arr1d[-1]</div>
<div class="line"><span class="lineno"> 1071</span> </div>
<div class="line"><span class="lineno"> 1072</span>    <span class="keywordflow">return</span> np.median(arr1d_parsed, overwrite_input=overwrite_input)</div>
<div class="line"><span class="lineno"> 1073</span> </div>
<div class="line"><span class="lineno"> 1074</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a20f3194c29aee4e2de7eedc272f19318" name="a20f3194c29aee4e2de7eedc272f19318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f3194c29aee4e2de7eedc272f19318">&#9670;&#160;</a></span>_nanmedian_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanmedian_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1122</span>        a, axis=<span class="keywordtype">None</span>, out=<span class="keywordtype">None</span>, overwrite_input=<span class="keywordtype">None</span>, keepdims=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1123</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 1124</span> </div>
<div class="line"><span class="lineno"> 1125</span> </div>
<div class="line"><span class="lineno"> 1126</span><span class="preprocessor">@array_function_dispatch(_nanmedian_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ec3450a13ac6ad57995b1f2ddb5b7ab" name="a8ec3450a13ac6ad57995b1f2ddb5b7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec3450a13ac6ad57995b1f2ddb5b7ab">&#9670;&#160;</a></span>_nanmedian_small()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanmedian_small </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">sort + indexing median, faster for small medians along multiple
dimensions due to the high overhead of apply_along_axis

see nanmedian for parameter usage
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1101</span><span class="keyword">def </span>_nanmedian_small(a, axis=None, out=None, overwrite_input=False):</div>
<div class="line"><span class="lineno"> 1102</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    sort + indexing median, faster for small medians along multiple</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    dimensions due to the high overhead of apply_along_axis</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    see nanmedian for parameter usage</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1108</span>    a = np.ma.masked_array(a, np.isnan(a))</div>
<div class="line"><span class="lineno"> 1109</span>    m = np.ma.median(a, axis=axis, overwrite_input=overwrite_input)</div>
<div class="line"><span class="lineno"> 1110</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(np.count_nonzero(m.mask.ravel())):</div>
<div class="line"><span class="lineno"> 1111</span>        warnings.warn(<span class="stringliteral">&quot;All-NaN slice encountered&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno"> 1112</span>                      stacklevel=4)</div>
<div class="line"><span class="lineno"> 1113</span> </div>
<div class="line"><span class="lineno"> 1114</span>    fill_value = np.timedelta64(<span class="stringliteral">&quot;NaT&quot;</span>) <span class="keywordflow">if</span> m.dtype.kind == <span class="stringliteral">&quot;m&quot;</span> <span class="keywordflow">else</span> np.nan</div>
<div class="line"><span class="lineno"> 1115</span>    <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1116</span>        out[...] = m.filled(fill_value)</div>
<div class="line"><span class="lineno"> 1117</span>        <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1118</span>    <span class="keywordflow">return</span> m.filled(fill_value)</div>
<div class="line"><span class="lineno"> 1119</span> </div>
<div class="line"><span class="lineno"> 1120</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5edb97735505a066a20989efc963d582" name="a5edb97735505a066a20989efc963d582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edb97735505a066a20989efc963d582">&#9670;&#160;</a></span>_nanmin_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanmin_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  232</span>                       initial=<span class="keywordtype">None</span>, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  233</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span><span class="preprocessor">@array_function_dispatch(_nanmin_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a682454b8fd256f03a815ceb6a09ec65f" name="a682454b8fd256f03a815ceb6a09ec65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682454b8fd256f03a815ceb6a09ec65f">&#9670;&#160;</a></span>_nanpercentile_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanpercentile_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1224</span>        method=<span class="keywordtype">None</span>, keepdims=<span class="keywordtype">None</span>, *, interpolation=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1225</span>    <span class="keywordflow">return</span> (a, q, out)</div>
<div class="line"><span class="lineno"> 1226</span> </div>
<div class="line"><span class="lineno"> 1227</span> </div>
<div class="line"><span class="lineno"> 1228</span><span class="preprocessor">@array_function_dispatch(_nanpercentile_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af0915719319200c5de44ec99426f4821" name="af0915719319200c5de44ec99426f4821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0915719319200c5de44ec99426f4821">&#9670;&#160;</a></span>_nanprod_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanprod_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  728</span>                        initial=<span class="keywordtype">None</span>, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  729</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span> </div>
<div class="line"><span class="lineno">  732</span><span class="preprocessor">@array_function_dispatch(_nanprod_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afdd93ae8bfafef4f8032f5b5e2a93b23" name="afdd93ae8bfafef4f8032f5b5e2a93b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd93ae8bfafef4f8032f5b5e2a93b23">&#9670;&#160;</a></span>_nanquantile_1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanquantile_1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function for rank 1 arrays. Compute quantile ignoring NaNs.
See nanpercentile for parameter usage
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1590</span><span class="keyword">def </span>_nanquantile_1d(arr1d, q, overwrite_input=False, method=&quot;linear&quot;):</div>
<div class="line"><span class="lineno"> 1591</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    Private function for rank 1 arrays. Compute quantile ignoring NaNs.</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    See nanpercentile for parameter usage</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1595</span>    arr1d, overwrite_input = _remove_nan_1d(arr1d,</div>
<div class="line"><span class="lineno"> 1596</span>        overwrite_input=overwrite_input)</div>
<div class="line"><span class="lineno"> 1597</span>    <span class="keywordflow">if</span> arr1d.size == 0:</div>
<div class="line"><span class="lineno"> 1598</span>        <span class="comment"># convert to scalar</span></div>
<div class="line"><span class="lineno"> 1599</span>        <span class="keywordflow">return</span> np.full(q.shape, np.nan, dtype=arr1d.dtype)[()]</div>
<div class="line"><span class="lineno"> 1600</span> </div>
<div class="line"><span class="lineno"> 1601</span>    <span class="keywordflow">return</span> function_base._quantile_unchecked(</div>
<div class="line"><span class="lineno"> 1602</span>        arr1d, q, overwrite_input=overwrite_input, method=method)</div>
<div class="line"><span class="lineno"> 1603</span> </div>
<div class="line"><span class="lineno"> 1604</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e4357933022152c7a9dc6d5eed7b0b6" name="a7e4357933022152c7a9dc6d5eed7b0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4357933022152c7a9dc6d5eed7b0b6">&#9670;&#160;</a></span>_nanquantile_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanquantile_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1386</span>                            method=<span class="keywordtype">None</span>, keepdims=<span class="keywordtype">None</span>, *, interpolation=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1387</span>    <span class="keywordflow">return</span> (a, q, out)</div>
<div class="line"><span class="lineno"> 1388</span> </div>
<div class="line"><span class="lineno"> 1389</span> </div>
<div class="line"><span class="lineno"> 1390</span><span class="preprocessor">@array_function_dispatch(_nanquantile_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0be18385bcb80ed0da9fb56172f01581" name="a0be18385bcb80ed0da9fb56172f01581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be18385bcb80ed0da9fb56172f01581">&#9670;&#160;</a></span>_nanquantile_unchecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanquantile_unchecked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Assumes that q is in [0, 1], and is an ndarray</pre> <div class="fragment"><div class="line"><span class="lineno"> 1550</span>):</div>
<div class="line"><span class="lineno"> 1551</span>    <span class="stringliteral">&quot;&quot;&quot;Assumes that q is in [0, 1], and is an ndarray&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1552</span>    <span class="comment"># apply_along_axis in _nanpercentile doesn&#39;t handle empty arrays well,</span></div>
<div class="line"><span class="lineno"> 1553</span>    <span class="comment"># so deal them upfront</span></div>
<div class="line"><span class="lineno"> 1554</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 1555</span>        <span class="keywordflow">return</span> np.nanmean(a, axis, out=out, keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 1556</span>    <span class="keywordflow">return</span> function_base._ureduce(a,</div>
<div class="line"><span class="lineno"> 1557</span>                                  func=_nanquantile_ureduce_func,</div>
<div class="line"><span class="lineno"> 1558</span>                                  q=q,</div>
<div class="line"><span class="lineno"> 1559</span>                                  keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 1560</span>                                  axis=axis,</div>
<div class="line"><span class="lineno"> 1561</span>                                  out=out,</div>
<div class="line"><span class="lineno"> 1562</span>                                  overwrite_input=overwrite_input,</div>
<div class="line"><span class="lineno"> 1563</span>                                  method=method)</div>
<div class="line"><span class="lineno"> 1564</span> </div>
<div class="line"><span class="lineno"> 1565</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a72906d758170b7961a0275971930c0" name="a9a72906d758170b7961a0275971930c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a72906d758170b7961a0275971930c0">&#9670;&#160;</a></span>_nanquantile_ureduce_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanquantile_ureduce_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function that doesn't support extended axis or keepdims.
These methods are extended to this function using _ureduce
See nanpercentile for parameter usage
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1567</span>                              method=<span class="stringliteral">&quot;linear&quot;</span>):</div>
<div class="line"><span class="lineno"> 1568</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">    Private function that doesn&#39;t support extended axis or keepdims.</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">    These methods are extended to this function using _ureduce</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">    See nanpercentile for parameter usage</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1573</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> a.ndim == 1:</div>
<div class="line"><span class="lineno"> 1574</span>        part = a.ravel()</div>
<div class="line"><span class="lineno"> 1575</span>        result = _nanquantile_1d(part, q, overwrite_input, method)</div>
<div class="line"><span class="lineno"> 1576</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1577</span>        result = np.apply_along_axis(_nanquantile_1d, axis, a, q,</div>
<div class="line"><span class="lineno"> 1578</span>                                     overwrite_input, method)</div>
<div class="line"><span class="lineno"> 1579</span>        <span class="comment"># apply_along_axis fills in collapsed axis with results.</span></div>
<div class="line"><span class="lineno"> 1580</span>        <span class="comment"># Move that axis to the beginning to match percentile&#39;s</span></div>
<div class="line"><span class="lineno"> 1581</span>        <span class="comment"># convention.</span></div>
<div class="line"><span class="lineno"> 1582</span>        <span class="keywordflow">if</span> q.ndim != 0:</div>
<div class="line"><span class="lineno"> 1583</span>            result = np.moveaxis(result, axis, 0)</div>
<div class="line"><span class="lineno"> 1584</span> </div>
<div class="line"><span class="lineno"> 1585</span>    <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1586</span>        out[...] = result</div>
<div class="line"><span class="lineno"> 1587</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1588</span> </div>
<div class="line"><span class="lineno"> 1589</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a37f742760a74676e961a3235f5058e51" name="a37f742760a74676e961a3235f5058e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f742760a74676e961a3235f5058e51">&#9670;&#160;</a></span>_nanstd_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanstd_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1767</span>                       keepdims=<span class="keywordtype">None</span>, *, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1768</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 1769</span> </div>
<div class="line"><span class="lineno"> 1770</span> </div>
<div class="line"><span class="lineno"> 1771</span><span class="preprocessor">@array_function_dispatch(_nanstd_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6aedee7c67d57ea38cee56324d6e2891" name="a6aedee7c67d57ea38cee56324d6e2891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aedee7c67d57ea38cee56324d6e2891">&#9670;&#160;</a></span>_nansum_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nansum_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  619</span>                       initial=<span class="keywordtype">None</span>, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  620</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno">  621</span> </div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span><span class="preprocessor">@array_function_dispatch(_nansum_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a64f7856e59418753f2cdbf9a938e9770" name="a64f7856e59418753f2cdbf9a938e9770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f7856e59418753f2cdbf9a938e9770">&#9670;&#160;</a></span>_nanvar_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._nanvar_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1606</span>                       keepdims=<span class="keywordtype">None</span>, *, where=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1607</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 1608</span> </div>
<div class="line"><span class="lineno"> 1609</span> </div>
<div class="line"><span class="lineno"> 1610</span><span class="preprocessor">@array_function_dispatch(_nanvar_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a974efb81de64a4fe552134efafe878c8" name="a974efb81de64a4fe552134efafe878c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974efb81de64a4fe552134efafe878c8">&#9670;&#160;</a></span>_remove_nan_1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._remove_nan_1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to arr1d[~arr1d.isnan()], but in a different order

Presumably faster as it incurs fewer copies

Parameters
----------
arr1d : ndarray
    Array to remove nans from
overwrite_input : bool
    True if `arr1d` can be modified in place

Returns
-------
res : ndarray
    Array with nan elements removed
overwrite_input : bool
    True if `res` can be modified in place, given the constraint on the
    input
</pre> <div class="fragment"><div class="line"><span class="lineno">  142</span><span class="keyword">def </span>_remove_nan_1d(arr1d, overwrite_input=False):</div>
<div class="line"><span class="lineno">  143</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    Equivalent to arr1d[~arr1d.isnan()], but in a different order</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    Presumably faster as it incurs fewer copies</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    arr1d : ndarray</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        Array to remove nans from</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    overwrite_input : bool</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        True if `arr1d` can be modified in place</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    res : ndarray</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        Array with nan elements removed</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    overwrite_input : bool</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        True if `res` can be modified in place, given the constraint on the</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        input</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  163</span>    <span class="keywordflow">if</span> arr1d.dtype == object:</div>
<div class="line"><span class="lineno">  164</span>        <span class="comment"># object arrays do not support `isnan` (gh-9009), so make a guess</span></div>
<div class="line"><span class="lineno">  165</span>        c = np.not_equal(arr1d, arr1d, dtype=bool)</div>
<div class="line"><span class="lineno">  166</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  167</span>        c = np.isnan(arr1d)</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>    s = np.nonzero(c)[0]</div>
<div class="line"><span class="lineno">  170</span>    <span class="keywordflow">if</span> s.size == arr1d.size:</div>
<div class="line"><span class="lineno">  171</span>        warnings.warn(<span class="stringliteral">&quot;All-NaN slice encountered&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno">  172</span>                      stacklevel=5)</div>
<div class="line"><span class="lineno">  173</span>        <span class="keywordflow">return</span> arr1d[:0], <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  174</span>    <span class="keywordflow">elif</span> s.size == 0:</div>
<div class="line"><span class="lineno">  175</span>        <span class="keywordflow">return</span> arr1d, overwrite_input</div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> overwrite_input:</div>
<div class="line"><span class="lineno">  178</span>            arr1d = arr1d.copy()</div>
<div class="line"><span class="lineno">  179</span>        <span class="comment"># select non-nans at end of array</span></div>
<div class="line"><span class="lineno">  180</span>        enonan = arr1d[-s.size:][~c[-s.size:]]</div>
<div class="line"><span class="lineno">  181</span>        <span class="comment"># fill nans in beginning of array with non-nans of end</span></div>
<div class="line"><span class="lineno">  182</span>        arr1d[s[:enonan.size]] = enonan</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>        <span class="keywordflow">return</span> arr1d[:-s.size], <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8213190b114ca822a33c2e4c1079fd35" name="a8213190b114ca822a33c2e4c1079fd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8213190b114ca822a33c2e4c1079fd35">&#9670;&#160;</a></span>_replace_nan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions._replace_nan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">If `a` is of inexact type, make a copy of `a`, replace NaNs with
the `val` value, and return the copy together with a boolean mask
marking the locations where NaNs were present. If `a` is not of
inexact type, do nothing and return `a` together with a mask of None.

Note that scalars will end up as array scalars, which is important
for using the result as the value of the out argument in some
operations.

Parameters
----------
a : array-like
    Input array.
val : float
    NaN values are set to val before doing the operation.

Returns
-------
y : ndarray
    If `a` is of inexact type, return a copy of `a` with the NaNs
    replaced by the fill value, otherwise return `a`.
mask: {bool, None}
    If `a` is of inexact type, return a boolean mask marking locations of
    NaNs, otherwise return None.</pre> <div class="fragment"><div class="line"><span class="lineno">   68</span><span class="keyword">def </span>_replace_nan(a, val):</div>
<div class="line"><span class="lineno">   69</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    If `a` is of inexact type, make a copy of `a`, replace NaNs with</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    the `val` value, and return the copy together with a boolean mask</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    marking the locations where NaNs were present. If `a` is not of</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    inexact type, do nothing and return `a` together with a mask of None.</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    Note that scalars will end up as array scalars, which is important</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    for using the result as the value of the out argument in some</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    operations.</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    a : array-like</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    val : float</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        NaN values are set to val before doing the operation.</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        If `a` is of inexact type, return a copy of `a` with the NaNs</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        replaced by the fill value, otherwise return `a`.</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    mask: {bool, None}</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        If `a` is of inexact type, return a boolean mask marking locations of</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        NaNs, otherwise return None.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   96</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno">   97</span> </div>
<div class="line"><span class="lineno">   98</span>    <span class="keywordflow">if</span> a.dtype == np.object_:</div>
<div class="line"><span class="lineno">   99</span>        <span class="comment"># object arrays do not support `isnan` (gh-9009), so make a guess</span></div>
<div class="line"><span class="lineno">  100</span>        mask = np.not_equal(a, a, dtype=bool)</div>
<div class="line"><span class="lineno">  101</span>    <span class="keywordflow">elif</span> issubclass(a.dtype.type, np.inexact):</div>
<div class="line"><span class="lineno">  102</span>        mask = np.isnan(a)</div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  104</span>        mask = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  105</span> </div>
<div class="line"><span class="lineno">  106</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  107</span>        a = np.array(a, subok=<span class="keyword">True</span>, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  108</span>        np.copyto(a, val, where=mask)</div>
<div class="line"><span class="lineno">  109</span> </div>
<div class="line"><span class="lineno">  110</span>    <span class="keywordflow">return</span> a, mask</div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aff4c384a41e8da1e0727a30db67a688f" name="aff4c384a41e8da1e0727a30db67a688f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4c384a41e8da1e0727a30db67a688f">&#9670;&#160;</a></span>nanargmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanargmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices of the maximum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the
results cannot be trusted if a slice contains only NaNs and -Infs.


Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.

    .. versionadded:: 1.22.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

    .. versionadded:: 1.22.0

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmax, nanargmin

Examples
--------
&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])
&gt;&gt;&gt; np.argmax(a)
0
&gt;&gt;&gt; np.nanargmax(a)
1
&gt;&gt;&gt; np.nanargmax(a, axis=0)
array([1, 0])
&gt;&gt;&gt; np.nanargmax(a, axis=1)
array([1, 1])</pre> <div class="fragment"><div class="line"><span class="lineno">  562</span><span class="keyword">def </span>nanargmax(a, axis=None, out=None, *, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno">  563</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    Return the indices of the maximum values in the specified axis ignoring</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    results cannot be trusted if a slice contains only NaNs and -Infs.</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        Axis along which to operate.  By default flattened input is used.</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    out : array, optional</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        If provided, the result will be inserted into this array. It should</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        be of the appropriate shape and dtype.</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        the result will broadcast correctly against the array.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    index_array : ndarray</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">        An array of indices or a single index value.</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    argmax, nanargmin</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    &gt;&gt;&gt; np.argmax(a)</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    &gt;&gt;&gt; np.nanargmax(a)</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    &gt;&gt;&gt; np.nanargmax(a, axis=0)</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    array([1, 0])</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    &gt;&gt;&gt; np.nanargmax(a, axis=1)</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    array([1, 1])</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  609</span>    a, mask = _replace_nan(a, -np.inf)</div>
<div class="line"><span class="lineno">  610</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  611</span>        mask = np.all(mask, axis=axis)</div>
<div class="line"><span class="lineno">  612</span>        <span class="keywordflow">if</span> np.any(mask):</div>
<div class="line"><span class="lineno">  613</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All-NaN slice encountered&quot;</span>)</div>
<div class="line"><span class="lineno">  614</span>    res = np.argmax(a, axis=axis, out=out, keepdims=keepdims)</div>
<div class="line"><span class="lineno">  615</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af92d0ec8fca610478c34982392115ebb" name="af92d0ec8fca610478c34982392115ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92d0ec8fca610478c34982392115ebb">&#9670;&#160;</a></span>nanargmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanargmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices of the minimum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results
cannot be trusted if a slice contains only NaNs and Infs.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.

    .. versionadded:: 1.22.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

    .. versionadded:: 1.22.0

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmin, nanargmax

Examples
--------
&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])
&gt;&gt;&gt; np.argmin(a)
0
&gt;&gt;&gt; np.nanargmin(a)
2
&gt;&gt;&gt; np.nanargmin(a, axis=0)
array([1, 1])
&gt;&gt;&gt; np.nanargmin(a, axis=1)
array([1, 0])</pre> <div class="fragment"><div class="line"><span class="lineno">  502</span><span class="keyword">def </span>nanargmin(a, axis=None, out=None, *, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno">  503</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    Return the indices of the minimum values in the specified axis ignoring</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    cannot be trusted if a slice contains only NaNs and Infs.</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        Axis along which to operate.  By default flattened input is used.</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    out : array, optional</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        If provided, the result will be inserted into this array. It should</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        be of the appropriate shape and dtype.</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        the result will broadcast correctly against the array.</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    index_array : ndarray</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        An array of indices or a single index value.</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    argmin, nanargmax</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    &gt;&gt;&gt; np.argmin(a)</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    &gt;&gt;&gt; np.nanargmin(a)</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    2</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    &gt;&gt;&gt; np.nanargmin(a, axis=0)</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    array([1, 1])</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    &gt;&gt;&gt; np.nanargmin(a, axis=1)</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    array([1, 0])</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  548</span>    a, mask = _replace_nan(a, np.inf)</div>
<div class="line"><span class="lineno">  549</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  550</span>        mask = np.all(mask, axis=axis)</div>
<div class="line"><span class="lineno">  551</span>        <span class="keywordflow">if</span> np.any(mask):</div>
<div class="line"><span class="lineno">  552</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All-NaN slice encountered&quot;</span>)</div>
<div class="line"><span class="lineno">  553</span>    res = np.argmin(a, axis=axis, out=out, keepdims=keepdims)</div>
<div class="line"><span class="lineno">  554</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  555</span> </div>
<div class="line"><span class="lineno">  556</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab80c1525377406324144425eef7881f6" name="ab80c1525377406324144425eef7881f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80c1525377406324144425eef7881f6">&#9670;&#160;</a></span>nancumprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nancumprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cumulative product of array elements over a given axis treating Not a
Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.

Ones are returned for slices that are all-NaN or empty.

.. versionadded:: 1.12.0

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative product is computed.  By default
    the input is flattened.
dtype : dtype, optional
    Type of the returned array, as well as of the accumulator in which
    the elements are multiplied.  If *dtype* is not specified, it
    defaults to the dtype of `a`, unless `a` has an integer dtype with
    a precision less than that of the default platform integer.  In
    that case, the default platform integer is used instead.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type of the resulting values will be cast if necessary.

Returns
-------
nancumprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case it is returned.

See Also
--------
numpy.cumprod : Cumulative product across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
&gt;&gt;&gt; np.nancumprod(1)
array([1])
&gt;&gt;&gt; np.nancumprod([1])
array([1])
&gt;&gt;&gt; np.nancumprod([1, np.nan])
array([1.,  1.])
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nancumprod(a)
array([1.,  2.,  6.,  6.])
&gt;&gt;&gt; np.nancumprod(a, axis=0)
array([[1.,  2.],
       [3.,  2.]])
&gt;&gt;&gt; np.nancumprod(a, axis=1)
array([[1.,  2.],
       [3.,  3.]])</pre> <div class="fragment"><div class="line"><span class="lineno">  885</span><span class="keyword">def </span>nancumprod(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno">  886</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    Return the cumulative product of array elements over a given axis treating Not a</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    Numbers (NaNs) as one.  The cumulative product does not change when NaNs are</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    encountered and leading NaNs are replaced by ones.</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    Ones are returned for slices that are all-NaN or empty.</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    .. versionadded:: 1.12.0</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">        Axis along which the cumulative product is computed.  By default</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">        the input is flattened.</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">        Type of the returned array, as well as of the accumulator in which</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">        the elements are multiplied.  If *dtype* is not specified, it</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">        defaults to the dtype of `a`, unless `a` has an integer dtype with</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">        a precision less than that of the default platform integer.  In</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        that case, the default platform integer is used instead.</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        have the same shape and buffer length as the expected output</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        but the type of the resulting values will be cast if necessary.</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    nancumprod : ndarray</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">        A new array holding the result is returned unless `out` is</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">        specified, in which case it is returned.</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    numpy.cumprod : Cumulative product across array propagating NaNs.</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    isnan : Show which elements are NaN.</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumprod(1)</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    array([1])</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumprod([1])</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    array([1])</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumprod([1, np.nan])</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    array([1.,  1.])</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumprod(a)</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    array([1.,  2.,  6.,  6.])</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumprod(a, axis=0)</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    array([[1.,  2.],</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">           [3.,  2.]])</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumprod(a, axis=1)</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    array([[1.,  2.],</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">           [3.,  3.]])</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  943</span>    a, mask = _replace_nan(a, 1)</div>
<div class="line"><span class="lineno">  944</span>    <span class="keywordflow">return</span> np.cumprod(a, axis=axis, dtype=dtype, out=out)</div>
<div class="line"><span class="lineno">  945</span> </div>
<div class="line"><span class="lineno">  946</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8e327046571f8722c2eca5c8210c975" name="ad8e327046571f8722c2eca5c8210c975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e327046571f8722c2eca5c8210c975">&#9670;&#160;</a></span>nancumsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nancumsum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cumulative sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.

Zeros are returned for slices that are all-NaN or empty.

.. versionadded:: 1.12.0

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative sum is computed. The default
    (None) is to compute the cumsum over the flattened array.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed.  If `dtype` is not specified, it defaults
    to the dtype of `a`, unless `a` has an integer dtype with a
    precision less than that of the default platform integer.  In
    that case, the default platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary. See :ref:`ufuncs-output-type` for
    more details.

Returns
-------
nancumsum : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which it is returned. The result has the same
    size as `a`, and the same shape as `a` if `axis` is not None
    or `a` is a 1-d array.

See Also
--------
numpy.cumsum : Cumulative sum across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
&gt;&gt;&gt; np.nancumsum(1)
array([1])
&gt;&gt;&gt; np.nancumsum([1])
array([1])
&gt;&gt;&gt; np.nancumsum([1, np.nan])
array([1.,  1.])
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nancumsum(a)
array([1.,  3.,  6.,  6.])
&gt;&gt;&gt; np.nancumsum(a, axis=0)
array([[1.,  2.],
       [4.,  2.]])
&gt;&gt;&gt; np.nancumsum(a, axis=1)
array([[1.,  3.],
       [3.,  3.]])</pre> <div class="fragment"><div class="line"><span class="lineno">  815</span><span class="keyword">def </span>nancumsum(a, axis=None, dtype=None, out=None):</div>
<div class="line"><span class="lineno">  816</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    Return the cumulative sum of array elements over a given axis treating Not a</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    encountered and leading NaNs are replaced by zeros.</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    Zeros are returned for slices that are all-NaN or empty.</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    .. versionadded:: 1.12.0</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">        Axis along which the cumulative sum is computed. The default</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">        (None) is to compute the cumsum over the flattened array.</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">        Type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        elements are summed.  If `dtype` is not specified, it defaults</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">        to the dtype of `a`, unless `a` has an integer dtype with a</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">        precision less than that of the default platform integer.  In</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">        that case, the default platform integer is used.</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        have the same shape and buffer length as the expected output</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">        but the type will be cast if necessary. See :ref:`ufuncs-output-type` for</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">        more details.</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    nancumsum : ndarray.</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        A new array holding the result is returned unless `out` is</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">        specified, in which it is returned. The result has the same</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">        size as `a`, and the same shape as `a` if `axis` is not None</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">        or `a` is a 1-d array.</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    numpy.cumsum : Cumulative sum across array propagating NaNs.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    isnan : Show which elements are NaN.</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumsum(1)</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    array([1])</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumsum([1])</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    array([1])</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumsum([1, np.nan])</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    array([1.,  1.])</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumsum(a)</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    array([1.,  3.,  6.,  6.])</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumsum(a, axis=0)</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    array([[1.,  2.],</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">           [4.,  2.]])</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    &gt;&gt;&gt; np.nancumsum(a, axis=1)</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    array([[1.,  3.],</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">           [3.,  3.]])</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  876</span>    a, mask = _replace_nan(a, 0)</div>
<div class="line"><span class="lineno">  877</span>    <span class="keywordflow">return</span> np.cumsum(a, axis=axis, dtype=dtype, out=out)</div>
<div class="line"><span class="lineno">  878</span> </div>
<div class="line"><span class="lineno">  879</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a07d33ee14bafd4171305074df869a502" name="a07d33ee14bafd4171305074df869a502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d33ee14bafd4171305074df869a502">&#9670;&#160;</a></span>nanmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is
raised and NaN is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose maximum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the maximum is computed. The default is to compute
    the maximum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `max` method
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0
initial : scalar, optional
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.22.0
where : array_like of bool, optional
    Elements to compare for the maximum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.22.0

Returns
-------
nanmax : ndarray
    An array with the same shape as `a`, with the specified axis removed.
    If `a` is a 0-d array, or if axis is None, an ndarray scalar is
    returned.  The same dtype as `a` is returned.

See Also
--------
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amin, fmin, minimum

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.max.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmax(a)
3.0
&gt;&gt;&gt; np.nanmax(a, axis=0)
array([3.,  2.])
&gt;&gt;&gt; np.nanmax(a, axis=1)
array([2.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.NINF])
2.0
&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.inf])
inf</pre> <div class="fragment"><div class="line"><span class="lineno">  371</span>           where=np._NoValue):</div>
<div class="line"><span class="lineno">  372</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    Return the maximum of an array or maximum along an axis, ignoring any</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    raised and NaN is returned for that slice.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        Array containing numbers whose maximum is desired. If `a` is not an</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        Axis or axes along which the maximum is computed. The default is to compute</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">        the maximum of the flattened array.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        is ``None``; if provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        expected output, but the type will be cast if necessary. See</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">        :ref:`ufuncs-output-type` for more details.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">        If the value is anything but the default, then</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        `keepdims` will be passed through to the `max` method</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        of sub-classes of `ndarray`.  If the sub-classes methods</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        does not implement `keepdims` any exceptions will be raised.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">        The minimum value of an output element. Must be present to allow</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        computation on empty slice. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        Elements to compare for the maximum. See `~numpy.ufunc.reduce`</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        for details.</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    nanmax : ndarray</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        An array with the same shape as `a`, with the specified axis removed.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">        If `a` is a 0-d array, or if axis is None, an ndarray scalar is</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        returned.  The same dtype as `a` is returned.</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    nanmin :</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        The minimum value of an array along a given axis, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    amax :</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        The maximum value of an array along a given axis, propagating any NaNs.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    fmax :</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">        Element-wise maximum of two arrays, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    maximum :</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        Element-wise maximum of two arrays, propagating any NaNs.</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    isnan :</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        Shows which elements are Not a Number (NaN).</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    isfinite:</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        Shows which elements are neither NaN nor infinity.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    amin, fmin, minimum</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    Positive infinity is treated as a very large number and negative</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    infinity is treated as a very small (i.e. negative) number.</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    If the input has a integer type the function is equivalent to np.max.</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmax(a)</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmax(a, axis=0)</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    array([3.,  2.])</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmax(a, axis=1)</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    array([2.,  3.])</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    When positive infinity and negative infinity are present:</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.NINF])</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.inf])</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    inf</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  465</span>    kwargs = {}</div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno">  467</span>        kwargs[<span class="stringliteral">&#39;keepdims&#39;</span>] = keepdims</div>
<div class="line"><span class="lineno">  468</span>    <span class="keywordflow">if</span> initial <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno">  469</span>        kwargs[<span class="stringliteral">&#39;initial&#39;</span>] = initial</div>
<div class="line"><span class="lineno">  470</span>    <span class="keywordflow">if</span> where <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno">  471</span>        kwargs[<span class="stringliteral">&#39;where&#39;</span>] = where</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordflow">if</span> type(a) <span class="keywordflow">is</span> np.ndarray <span class="keywordflow">and</span> a.dtype != np.object_:</div>
<div class="line"><span class="lineno">  474</span>        <span class="comment"># Fast, but not safe for subclasses of ndarray, or object arrays,</span></div>
<div class="line"><span class="lineno">  475</span>        <span class="comment"># which do not implement isnan (gh-9009), or fmax correctly (gh-8975)</span></div>
<div class="line"><span class="lineno">  476</span>        res = np.fmax.reduce(a, axis=axis, out=out, **kwargs)</div>
<div class="line"><span class="lineno">  477</span>        <span class="keywordflow">if</span> np.isnan(res).any():</div>
<div class="line"><span class="lineno">  478</span>            warnings.warn(<span class="stringliteral">&quot;All-NaN slice encountered&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno">  479</span>                          stacklevel=3)</div>
<div class="line"><span class="lineno">  480</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  481</span>        <span class="comment"># Slow, but safe for subclasses of ndarray</span></div>
<div class="line"><span class="lineno">  482</span>        a, mask = _replace_nan(a, -np.inf)</div>
<div class="line"><span class="lineno">  483</span>        res = np.amax(a, axis=axis, out=out, **kwargs)</div>
<div class="line"><span class="lineno">  484</span>        <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  485</span>            <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  486</span> </div>
<div class="line"><span class="lineno">  487</span>        <span class="comment"># Check for all-NaN axis</span></div>
<div class="line"><span class="lineno">  488</span>        kwargs.pop(<span class="stringliteral">&quot;initial&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  489</span>        mask = np.all(mask, axis=axis, **kwargs)</div>
<div class="line"><span class="lineno">  490</span>        <span class="keywordflow">if</span> np.any(mask):</div>
<div class="line"><span class="lineno">  491</span>            res = _copyto(res, np.nan, mask)</div>
<div class="line"><span class="lineno">  492</span>            warnings.warn(<span class="stringliteral">&quot;All-NaN axis encountered&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno">  493</span>                          stacklevel=3)</div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3dc95c78e139c56d3190eef1c253c6ca" name="a3dc95c78e139c56d3190eef1c253c6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc95c78e139c56d3190eef1c253c6ca">&#9670;&#160;</a></span>nanmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the arithmetic mean along the specified axis, ignoring NaNs.

Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
`float64` intermediate and return values are used for integer inputs.

For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose mean is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the means are computed. The default is to compute
    the mean of the flattened array.
dtype : data-type, optional
    Type to use in computing the mean.  For integer inputs, the default
    is `float64`; for inexact inputs, it is the same as the input
    dtype.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `mean` or `sum` methods
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.
where : array_like of bool, optional
    Elements to include in the mean. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.22.0

Returns
-------
m : ndarray, see dtype parameter above
    If `out=None`, returns a new array containing the mean values,
    otherwise a reference to the output array is returned. Nan is
    returned for slices that contain only NaNs.

See Also
--------
average : Weighted average
mean : Arithmetic mean taken while not ignoring NaNs
var, nanvar

Notes
-----
The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.

Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32`.  Specifying a
higher-precision accumulator using the `dtype` keyword can alleviate
this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanmean(a)
2.6666666666666665
&gt;&gt;&gt; np.nanmean(a, axis=0)
array([2.,  4.])
&gt;&gt;&gt; np.nanmean(a, axis=1)
array([1.,  3.5]) # may vary</pre> <div class="fragment"><div class="line"><span class="lineno">  954</span>            *, where=np._NoValue):</div>
<div class="line"><span class="lineno">  955</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    Compute the arithmetic mean along the specified axis, ignoring NaNs.</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">    Returns the average of the array elements.  The average is taken over</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    the flattened array by default, otherwise over the specified axis.</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    `float64` intermediate and return values are used for integer inputs.</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">        Array containing numbers whose mean is desired. If `a` is not an</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">        Axis or axes along which the means are computed. The default is to compute</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">        the mean of the flattened array.</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">        Type to use in computing the mean.  For integer inputs, the default</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">        is `float64`; for inexact inputs, it is the same as the input</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">        dtype.</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">        is ``None``; if provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">        expected output, but the type will be cast if necessary. See</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">        :ref:`ufuncs-output-type` for more details.</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">        If the value is anything but the default, then</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">        `keepdims` will be passed through to the `mean` or `sum` methods</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">        of sub-classes of `ndarray`.  If the sub-classes methods</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">        does not implement `keepdims` any exceptions will be raised.</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">        Elements to include in the mean. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    m : ndarray, see dtype parameter above</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        If `out=None`, returns a new array containing the mean values,</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">        otherwise a reference to the output array is returned. Nan is</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">        returned for slices that contain only NaNs.</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    average : Weighted average</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    mean : Arithmetic mean taken while not ignoring NaNs</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    var, nanvar</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    The arithmetic mean is the sum of the non-NaN elements along the axis</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    divided by the number of non-NaN elements.</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    Note that for floating-point input, the mean is computed using the same</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    precision the input has.  Depending on the input data, this can cause</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    the results to be inaccurate, especially for `float32`.  Specifying a</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    higher-precision accumulator using the `dtype` keyword can alleviate</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    this issue.</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmean(a)</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    2.6666666666666665</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmean(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    array([2.,  4.])</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmean(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    array([1.,  3.5]) # may vary</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1032</span>    arr, mask = _replace_nan(a, 0)</div>
<div class="line"><span class="lineno"> 1033</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1034</span>        <span class="keywordflow">return</span> np.mean(arr, axis=axis, dtype=dtype, out=out, keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 1035</span>                       where=where)</div>
<div class="line"><span class="lineno"> 1036</span> </div>
<div class="line"><span class="lineno"> 1037</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1038</span>        dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno"> 1039</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> issubclass(dtype.type, np.inexact):</div>
<div class="line"><span class="lineno"> 1040</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;If a is inexact, then dtype must be inexact&quot;</span>)</div>
<div class="line"><span class="lineno"> 1041</span>    <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> issubclass(out.dtype.type, np.inexact):</div>
<div class="line"><span class="lineno"> 1042</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;If a is inexact, then out must be inexact&quot;</span>)</div>
<div class="line"><span class="lineno"> 1043</span> </div>
<div class="line"><span class="lineno"> 1044</span>    cnt = np.sum(~mask, axis=axis, dtype=np.intp, keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 1045</span>                 where=where)</div>
<div class="line"><span class="lineno"> 1046</span>    tot = np.sum(arr, axis=axis, dtype=dtype, out=out, keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 1047</span>                 where=where)</div>
<div class="line"><span class="lineno"> 1048</span>    avg = _divide_by_count(tot, cnt, out=out)</div>
<div class="line"><span class="lineno"> 1049</span> </div>
<div class="line"><span class="lineno"> 1050</span>    isbad = (cnt == 0)</div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">if</span> isbad.any():</div>
<div class="line"><span class="lineno"> 1052</span>        warnings.warn(<span class="stringliteral">&quot;Mean of empty slice&quot;</span>, RuntimeWarning, stacklevel=3)</div>
<div class="line"><span class="lineno"> 1053</span>        <span class="comment"># NaN is the only possible bad value, so no further</span></div>
<div class="line"><span class="lineno"> 1054</span>        <span class="comment"># action is needed to handle bad results.</span></div>
<div class="line"><span class="lineno"> 1055</span>    <span class="keywordflow">return</span> avg</div>
<div class="line"><span class="lineno"> 1056</span> </div>
<div class="line"><span class="lineno"> 1057</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b1f2fa26bee9157714e5029ee68f8ee" name="a3b1f2fa26bee9157714e5029ee68f8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1f2fa26bee9157714e5029ee68f8ee">&#9670;&#160;</a></span>nanmedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanmedian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the median along the specified axis, while ignoring NaNs.

Returns the median of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : {int, sequence of int, None}, optional
    Axis or axes along which the medians are computed. The default
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array `a` for
   calculations. The input array will be modified by the call to
   `median`. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. If `overwrite_input` is ``True`` and `a` is not already an
   `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

Returns
-------
median : ndarray
    A new array holding the result. If the input contains integers
    or floats smaller than ``float64``, then the output data-type is
    ``np.float64``.  Otherwise, the data-type of the output is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean, median, percentile

Notes
-----
Given a vector ``V`` of length ``N``, the median of ``V`` is the
middle value of a sorted copy of ``V``, ``V_sorted`` - i.e.,
``V_sorted[(N-1)/2]``, when ``N`` is odd and the average of the two
middle values of ``V_sorted`` when ``N`` is even.

Examples
--------
&gt;&gt;&gt; a = np.array([[10.0, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a[0, 1] = np.nan
&gt;&gt;&gt; a
array([[10., nan,  4.],
       [ 3.,  2.,  1.]])
&gt;&gt;&gt; np.median(a)
nan
&gt;&gt;&gt; np.nanmedian(a)
3.0
&gt;&gt;&gt; np.nanmedian(a, axis=0)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; np.median(a, axis=1)
array([nan,  2.])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanmedian(b, axis=1, overwrite_input=True)
array([7.,  2.])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanmedian(b, axis=None, overwrite_input=True)
3.0
&gt;&gt;&gt; assert not np.all(a==b)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1127</span><span class="keyword">def </span>nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=np._NoValue):</div>
<div class="line"><span class="lineno"> 1128</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    Compute the median along the specified axis, while ignoring NaNs.</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    Returns the median of the array elements.</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    axis : {int, sequence of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">        Axis or axes along which the medians are computed. The default</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">        is to compute the median along a flattened version of the array.</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">        A sequence of axes is supported since version 1.9.0.</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">        have the same shape and buffer length as the expected output,</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">        but the type (of the output) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">    overwrite_input : bool, optional</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">       If True, then allow use of memory of input array `a` for</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">       calculations. The input array will be modified by the call to</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">       `median`. This will save memory when you do not need to preserve</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">       the contents of the input array. Treat the input as undefined,</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">       but it will probably be fully or partially sorted. Default is</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">       False. If `overwrite_input` is ``True`` and `a` is not already an</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">       `ndarray`, an error will be raised.</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">        If this is anything but the default value it will be passed</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">        through (in the special case of an empty array) to the</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">        `mean` function of the underlying array.  If the array is</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">        a sub-class and `mean` does not have the kwarg `keepdims` this</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">        will raise a RuntimeError.</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    median : ndarray</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">        A new array holding the result. If the input contains integers</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">        or floats smaller than ``float64``, then the output data-type is</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">        ``np.float64``.  Otherwise, the data-type of the output is the</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">        same as that of the input. If `out` is specified, that array is</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">        returned instead.</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    mean, median, percentile</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">    Given a vector ``V`` of length ``N``, the median of ``V`` is the</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    middle value of a sorted copy of ``V``, ``V_sorted`` - i.e.,</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    ``V_sorted[(N-1)/2]``, when ``N`` is odd and the average of the two</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    middle values of ``V_sorted`` when ``N`` is even.</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[10.0, 7, 4], [3, 2, 1]])</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    &gt;&gt;&gt; a[0, 1] = np.nan</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    array([[10., nan,  4.],</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">           [ 3.,  2.,  1.]])</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    &gt;&gt;&gt; np.median(a)</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    nan</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmedian(a)</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmedian(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    array([6.5, 2. , 2.5])</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    &gt;&gt;&gt; np.median(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    array([nan,  2.])</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmedian(b, axis=1, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    array([7.,  2.])</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a==b)</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmedian(b, axis=None, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a==b)</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1211</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 1212</span>    <span class="comment"># apply_along_axis in _nanmedian doesn&#39;t handle empty arrays well,</span></div>
<div class="line"><span class="lineno"> 1213</span>    <span class="comment"># so deal them upfront</span></div>
<div class="line"><span class="lineno"> 1214</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 1215</span>        <span class="keywordflow">return</span> np.nanmean(a, axis, out=out, keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 1216</span> </div>
<div class="line"><span class="lineno"> 1217</span>    <span class="keywordflow">return</span> function_base._ureduce(a, func=_nanmedian, keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 1218</span>                                  axis=axis, out=out,</div>
<div class="line"><span class="lineno"> 1219</span>                                  overwrite_input=overwrite_input)</div>
<div class="line"><span class="lineno"> 1220</span> </div>
<div class="line"><span class="lineno"> 1221</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a622a8d29d82d09d7bf06dccb942526e5" name="a622a8d29d82d09d7bf06dccb942526e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622a8d29d82d09d7bf06dccb942526e5">&#9670;&#160;</a></span>nanmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a ``RuntimeWarning`` is raised and
Nan is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose minimum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the minimum is computed. The default is to compute
    the minimum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `min` method
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0
initial : scalar, optional
    The maximum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.22.0
where : array_like of bool, optional
    Elements to compare for the minimum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.22.0

Returns
-------
nanmin : ndarray
    An array with the same shape as `a`, with the specified axis
    removed.  If `a` is a 0-d array, or if axis is None, an ndarray
    scalar is returned.  The same dtype as `a` is returned.

See Also
--------
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amax, fmax, maximum

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.min.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmin(a)
1.0
&gt;&gt;&gt; np.nanmin(a, axis=0)
array([1.,  2.])
&gt;&gt;&gt; np.nanmin(a, axis=1)
array([1.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.inf])
1.0
&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.NINF])
-inf</pre> <div class="fragment"><div class="line"><span class="lineno">  238</span>           where=np._NoValue):</div>
<div class="line"><span class="lineno">  239</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    Return minimum of an array or minimum along an axis, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    When all-NaN slices are encountered a ``RuntimeWarning`` is raised and</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    Nan is returned for that slice.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        Array containing numbers whose minimum is desired. If `a` is not an</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">        Axis or axes along which the minimum is computed. The default is to compute</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        the minimum of the flattened array.</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">        is ``None``; if provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">        expected output, but the type will be cast if necessary. See</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        :ref:`ufuncs-output-type` for more details.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">        If the value is anything but the default, then</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">        `keepdims` will be passed through to the `min` method</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">        of sub-classes of `ndarray`.  If the sub-classes methods</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">        does not implement `keepdims` any exceptions will be raised.</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        The maximum value of an output element. Must be present to allow</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        computation on empty slice. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        Elements to compare for the minimum. See `~numpy.ufunc.reduce`</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        for details.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    nanmin : ndarray</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        An array with the same shape as `a`, with the specified axis</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        removed.  If `a` is a 0-d array, or if axis is None, an ndarray</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        scalar is returned.  The same dtype as `a` is returned.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    nanmax :</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        The maximum value of an array along a given axis, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    amin :</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        The minimum value of an array along a given axis, propagating any NaNs.</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    fmin :</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        Element-wise minimum of two arrays, ignoring any NaNs.</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    minimum :</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        Element-wise minimum of two arrays, propagating any NaNs.</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    isnan :</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        Shows which elements are Not a Number (NaN).</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    isfinite:</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        Shows which elements are neither NaN nor infinity.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    amax, fmax, maximum</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    Positive infinity is treated as a very large number and negative</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    infinity is treated as a very small (i.e. negative) number.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    If the input has a integer type the function is equivalent to np.min.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmin(a)</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmin(a, axis=0)</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    array([1.,  2.])</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmin(a, axis=1)</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    array([1.,  3.])</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    When positive infinity and negative infinity are present:</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.inf])</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    &gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.NINF])</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    -inf</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  332</span>    kwargs = {}</div>
<div class="line"><span class="lineno">  333</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno">  334</span>        kwargs[<span class="stringliteral">&#39;keepdims&#39;</span>] = keepdims</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">if</span> initial <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno">  336</span>        kwargs[<span class="stringliteral">&#39;initial&#39;</span>] = initial</div>
<div class="line"><span class="lineno">  337</span>    <span class="keywordflow">if</span> where <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno">  338</span>        kwargs[<span class="stringliteral">&#39;where&#39;</span>] = where</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordflow">if</span> type(a) <span class="keywordflow">is</span> np.ndarray <span class="keywordflow">and</span> a.dtype != np.object_:</div>
<div class="line"><span class="lineno">  341</span>        <span class="comment"># Fast, but not safe for subclasses of ndarray, or object arrays,</span></div>
<div class="line"><span class="lineno">  342</span>        <span class="comment"># which do not implement isnan (gh-9009), or fmin correctly (gh-8975)</span></div>
<div class="line"><span class="lineno">  343</span>        res = np.fmin.reduce(a, axis=axis, out=out, **kwargs)</div>
<div class="line"><span class="lineno">  344</span>        <span class="keywordflow">if</span> np.isnan(res).any():</div>
<div class="line"><span class="lineno">  345</span>            warnings.warn(<span class="stringliteral">&quot;All-NaN slice encountered&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno">  346</span>                          stacklevel=3)</div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  348</span>        <span class="comment"># Slow, but safe for subclasses of ndarray</span></div>
<div class="line"><span class="lineno">  349</span>        a, mask = _replace_nan(a, +np.inf)</div>
<div class="line"><span class="lineno">  350</span>        res = np.amin(a, axis=axis, out=out, **kwargs)</div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  352</span>            <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  353</span> </div>
<div class="line"><span class="lineno">  354</span>        <span class="comment"># Check for all-NaN axis</span></div>
<div class="line"><span class="lineno">  355</span>        kwargs.pop(<span class="stringliteral">&quot;initial&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  356</span>        mask = np.all(mask, axis=axis, **kwargs)</div>
<div class="line"><span class="lineno">  357</span>        <span class="keywordflow">if</span> np.any(mask):</div>
<div class="line"><span class="lineno">  358</span>            res = _copyto(res, np.nan, mask)</div>
<div class="line"><span class="lineno">  359</span>            warnings.warn(<span class="stringliteral">&quot;All-NaN axis encountered&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno">  360</span>                          stacklevel=3)</div>
<div class="line"><span class="lineno">  361</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  362</span> </div>
<div class="line"><span class="lineno">  363</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a976a8bb7f27b4bc79b057ad332339635" name="a976a8bb7f27b4bc79b057ad332339635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976a8bb7f27b4bc79b057ad332339635">&#9670;&#160;</a></span>nanpercentile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanpercentile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the qth percentile of the data along the specified axis,
while ignoring nan values.

Returns the qth percentile(s) of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array, containing
    nan values to be ignored.
q : array_like of float
    Percentile or sequence of percentiles to compute, which must be
    between 0 and 100 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the percentiles are computed. The default
    is to compute the percentile(s) along a flattened version of the
    array.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape and buffer length as the expected output, but the
    type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by
    intermediate calculations, to save memory. In this case, the
    contents of the input `a` after this function completes is
    undefined.
method : str, optional
    This parameter specifies the method to use for estimating the
    percentile.  There are many different methods, some unique to NumPy.
    See the notes for explanation.  The options sorted by their R type
    as summarized in the H&amp;F paper [1]_ are:

    1. 'inverted_cdf'
    2. 'averaged_inverted_cdf'
    3. 'closest_observation'
    4. 'interpolated_inverted_cdf'
    5. 'hazen'
    6. 'weibull'
    7. 'linear'  (default)
    8. 'median_unbiased'
    9. 'normal_unbiased'

    The first three methods are discontinuous.  NumPy further defines the
    following discontinuous variations of the default 'linear' (7.) option:

    * 'lower'
    * 'higher',
    * 'midpoint'
    * 'nearest'

    .. versionchanged:: 1.22.0
        This argument was previously called "interpolation" and only
        offered the "linear" default and last four options.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

interpolation : str, optional
    Deprecated name for the method keyword argument.

    .. deprecated:: 1.22.0

Returns
-------
percentile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple percentiles are given, first axis of
    the result corresponds to the percentiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
nanmean
nanmedian : equivalent to ``nanpercentile(..., 50)``
percentile, median, mean
nanquantile : equivalent to nanpercentile, except q in range [0, 1].

Notes
-----
For more information please see `numpy.percentile`

Examples
--------
&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])
&gt;&gt;&gt; a[0][1] = np.nan
&gt;&gt;&gt; a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
&gt;&gt;&gt; np.percentile(a, 50)
nan
&gt;&gt;&gt; np.nanpercentile(a, 50)
3.0
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])
&gt;&gt;&gt; m = np.nanpercentile(a, 50, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0, out=out)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; m
array([6.5,  2. ,  2.5])

&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanpercentile(b, 50, axis=1, overwrite_input=True)
array([7., 2.])
&gt;&gt;&gt; assert not np.all(a==b)

References
----------
.. [1] R. J. Hyndman and Y. Fan,
   "Sample quantiles in statistical packages,"
   The American Statistician, 50(4), pp. 361-365, 1996</pre> <div class="fragment"><div class="line"><span class="lineno"> 1239</span>):</div>
<div class="line"><span class="lineno"> 1240</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    Compute the qth percentile of the data along the specified axis,</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">    while ignoring nan values.</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    Returns the qth percentile(s) of the array elements.</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">        Input array or object that can be converted to an array, containing</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">        nan values to be ignored.</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">    q : array_like of float</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">        Percentile or sequence of percentiles to compute, which must be</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">        between 0 and 100 inclusive.</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">        Axis or axes along which the percentiles are computed. The default</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">        is to compute the percentile(s) along a flattened version of the</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">        array.</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">        Alternative output array in which to place the result. It must have</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">        the same shape and buffer length as the expected output, but the</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">        type (of the output) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    overwrite_input : bool, optional</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">        If True, then allow the input array `a` to be modified by</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        intermediate calculations, to save memory. In this case, the</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        contents of the input `a` after this function completes is</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        undefined.</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">        This parameter specifies the method to use for estimating the</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">        percentile.  There are many different methods, some unique to NumPy.</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">        See the notes for explanation.  The options sorted by their R type</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">        as summarized in the H&amp;F paper [1]_ are:</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">        1. &#39;inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">        2. &#39;averaged_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">        3. &#39;closest_observation&#39;</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">        4. &#39;interpolated_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">        5. &#39;hazen&#39;</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">        6. &#39;weibull&#39;</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">        7. &#39;linear&#39;  (default)</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">        8. &#39;median_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">        9. &#39;normal_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        The first three methods are discontinuous.  NumPy further defines the</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">        * &#39;lower&#39;</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">        * &#39;higher&#39;,</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">        * &#39;midpoint&#39;</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">        * &#39;nearest&#39;</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">        .. versionchanged:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">            This argument was previously called &quot;interpolation&quot; and only</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">            offered the &quot;linear&quot; default and last four options.</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left in</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">        the result as dimensions with size one. With this option, the</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">        result will broadcast correctly against the original array `a`.</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">        If this is anything but the default value it will be passed</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">        through (in the special case of an empty array) to the</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">        `mean` function of the underlying array.  If the array is</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">        a sub-class and `mean` does not have the kwarg `keepdims` this</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">        will raise a RuntimeError.</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">    interpolation : str, optional</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">        Deprecated name for the method keyword argument.</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">        .. deprecated:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    percentile : scalar or ndarray</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">        If `q` is a single percentile and `axis=None`, then the result</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">        is a scalar. If multiple percentiles are given, first axis of</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">        the result corresponds to the percentiles. The other axes are</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">        the axes that remain after the reduction of `a`. If the input</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">        contains integers or floats smaller than ``float64``, the output</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">        data-type is ``float64``. Otherwise, the output data-type is the</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">        same as that of the input. If `out` is specified, that array is</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">        returned instead.</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    nanmean</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    nanmedian : equivalent to ``nanpercentile(..., 50)``</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">    percentile, median, mean</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    nanquantile : equivalent to nanpercentile, except q in range [0, 1].</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    For more information please see `numpy.percentile`</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">    &gt;&gt;&gt; a[0][1] = np.nan</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    array([[10.,  nan,   4.],</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">          [ 3.,   2.,   1.]])</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    &gt;&gt;&gt; np.percentile(a, 50)</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    nan</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    &gt;&gt;&gt; np.nanpercentile(a, 50)</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &gt;&gt;&gt; np.nanpercentile(a, 50, axis=0)</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    array([6.5, 2. , 2.5])</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    &gt;&gt;&gt; np.nanpercentile(a, 50, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    array([[7.],</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">           [2.]])</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    &gt;&gt;&gt; m = np.nanpercentile(a, 50, axis=0)</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    &gt;&gt;&gt; out = np.zeros_like(m)</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    &gt;&gt;&gt; np.nanpercentile(a, 50, axis=0, out=out)</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    array([6.5, 2. , 2.5])</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    &gt;&gt;&gt; m</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    array([6.5,  2. ,  2.5])</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    &gt;&gt;&gt; np.nanpercentile(b, 50, axis=1, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    array([7., 2.])</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a==b)</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">    .. [1] R. J. Hyndman and Y. Fan,</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">       &quot;Sample quantiles in statistical packages,&quot;</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">       The American Statistician, 50(4), pp. 361-365, 1996</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1371</span>    <span class="keywordflow">if</span> interpolation <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1372</span>        method = function_base._check_interpolation_as_method(</div>
<div class="line"><span class="lineno"> 1373</span>            method, interpolation, <span class="stringliteral">&quot;nanpercentile&quot;</span>)</div>
<div class="line"><span class="lineno"> 1374</span> </div>
<div class="line"><span class="lineno"> 1375</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 1376</span>    q = np.true_divide(q, 100.0)</div>
<div class="line"><span class="lineno"> 1377</span>    <span class="comment"># undo any decay that the ufunc performed (see gh-13105)</span></div>
<div class="line"><span class="lineno"> 1378</span>    q = np.asanyarray(q)</div>
<div class="line"><span class="lineno"> 1379</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> function_base._quantile_is_valid(q):</div>
<div class="line"><span class="lineno"> 1380</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Percentiles must be in the range [0, 100]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1381</span>    <span class="keywordflow">return</span> _nanquantile_unchecked(</div>
<div class="line"><span class="lineno"> 1382</span>        a, q, axis, out, overwrite_input, method, keepdims)</div>
<div class="line"><span class="lineno"> 1383</span> </div>
<div class="line"><span class="lineno"> 1384</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a50471a3a92bdbb41a9bd4e8733c5ef6c" name="a50471a3a92bdbb41a9bd4e8733c5ef6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50471a3a92bdbb41a9bd4e8733c5ef6c">&#9670;&#160;</a></span>nanprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the product of array elements over a given axis treating Not a
Numbers (NaNs) as ones.

One is returned for slices that are all-NaN or empty.

.. versionadded:: 1.10.0

Parameters
----------
a : array_like
    Array containing numbers whose product is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the product is computed. The default is to compute
    the product of the flattened array.
dtype : data-type, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  By default, the dtype of `a` is used.  An
    exception is when `a` has an integer type with less precision than
    the platform (u)intp. In that case, the default will be either
    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
    bits. For inexact inputs, dtype must be inexact.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``. If provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details. The casting of NaN to integer
    can yield unexpected results.
keepdims : bool, optional
    If True, the axes which are reduced are left in the result as
    dimensions with size one. With this option, the result will
    broadcast correctly against the original `arr`.
initial : scalar, optional
    The starting value for this product. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.22.0
where : array_like of bool, optional
    Elements to include in the product. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.22.0

Returns
-------
nanprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case it is returned.

See Also
--------
numpy.prod : Product across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
&gt;&gt;&gt; np.nanprod(1)
1
&gt;&gt;&gt; np.nanprod([1])
1
&gt;&gt;&gt; np.nanprod([1, np.nan])
1.0
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanprod(a)
6.0
&gt;&gt;&gt; np.nanprod(a, axis=0)
array([3., 2.])</pre> <div class="fragment"><div class="line"><span class="lineno">  734</span>            initial=np._NoValue, where=np._NoValue):</div>
<div class="line"><span class="lineno">  735</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    Return the product of array elements over a given axis treating Not a</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    Numbers (NaNs) as ones.</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    One is returned for slices that are all-NaN or empty.</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        Array containing numbers whose product is desired. If `a` is not an</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        Axis or axes along which the product is computed. The default is to compute</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        the product of the flattened array.</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        The type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        elements are summed.  By default, the dtype of `a` is used.  An</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        exception is when `a` has an integer type with less precision than</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        the platform (u)intp. In that case, the default will be either</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        (u)int32 or (u)int64 depending on whether the platform is 32 or 64</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">        bits. For inexact inputs, dtype must be inexact.</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        is ``None``. If provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        expected output, but the type will be cast if necessary. See</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        :ref:`ufuncs-output-type` for more details. The casting of NaN to integer</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        can yield unexpected results.</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        If True, the axes which are reduced are left in the result as</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        dimensions with size one. With this option, the result will</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        broadcast correctly against the original `arr`.</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">        The starting value for this product. See `~numpy.ufunc.reduce`</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        for details.</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">        Elements to include in the product. See `~numpy.ufunc.reduce`</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">        for details.</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    nanprod : ndarray</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">        A new array holding the result is returned unless `out` is</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        specified, in which case it is returned.</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    numpy.prod : Product across array propagating NaNs.</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">    isnan : Show which elements are NaN.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    &gt;&gt;&gt; np.nanprod(1)</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    &gt;&gt;&gt; np.nanprod([1])</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    &gt;&gt;&gt; np.nanprod([1, np.nan])</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    &gt;&gt;&gt; np.nanprod(a)</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    6.0</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    &gt;&gt;&gt; np.nanprod(a, axis=0)</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    array([3., 2.])</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  805</span>    a, mask = _replace_nan(a, 1)</div>
<div class="line"><span class="lineno">  806</span>    <span class="keywordflow">return</span> np.prod(a, axis=axis, dtype=dtype, out=out, keepdims=keepdims,</div>
<div class="line"><span class="lineno">  807</span>                   initial=initial, where=where)</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb6391c2e655b930a0ec53f1fc51893c" name="aeb6391c2e655b930a0ec53f1fc51893c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6391c2e655b930a0ec53f1fc51893c">&#9670;&#160;</a></span>nanquantile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanquantile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the qth quantile of the data along the specified axis,
while ignoring nan values.
Returns the qth quantile(s) of the array elements.

.. versionadded:: 1.15.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array, containing
    nan values to be ignored
q : array_like of float
    Quantile or sequence of quantiles to compute, which must be between
    0 and 1 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the quantiles are computed. The
    default is to compute the quantile(s) along a flattened
    version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
method : str, optional
    This parameter specifies the method to use for estimating the
    quantile.  There are many different methods, some unique to NumPy.
    See the notes for explanation.  The options sorted by their R type
    as summarized in the H&amp;F paper [1]_ are:

    1. 'inverted_cdf'
    2. 'averaged_inverted_cdf'
    3. 'closest_observation'
    4. 'interpolated_inverted_cdf'
    5. 'hazen'
    6. 'weibull'
    7. 'linear'  (default)
    8. 'median_unbiased'
    9. 'normal_unbiased'

    The first three methods are discontinuous.  NumPy further defines the
    following discontinuous variations of the default 'linear' (7.) option:

    * 'lower'
    * 'higher',
    * 'midpoint'
    * 'nearest'

    .. versionchanged:: 1.22.0
        This argument was previously called "interpolation" and only
        offered the "linear" default and last four options.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

interpolation : str, optional
    Deprecated name for the method keyword argument.

    .. deprecated:: 1.22.0

Returns
-------
quantile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple quantiles are given, first axis of
    the result corresponds to the quantiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
quantile
nanmean, nanmedian
nanmedian : equivalent to ``nanquantile(..., 0.5)``
nanpercentile : same as nanquantile, but with q in the range [0, 100].

Notes
-----
For more information please see `numpy.quantile`

Examples
--------
&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])
&gt;&gt;&gt; a[0][1] = np.nan
&gt;&gt;&gt; a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
&gt;&gt;&gt; np.quantile(a, 0.5)
nan
&gt;&gt;&gt; np.nanquantile(a, 0.5)
3.0
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
&gt;&gt;&gt; m = np.nanquantile(a, 0.5, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0, out=out)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; m
array([6.5,  2. ,  2.5])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanquantile(b, 0.5, axis=1, overwrite_input=True)
array([7., 2.])
&gt;&gt;&gt; assert not np.all(a==b)

References
----------
.. [1] R. J. Hyndman and Y. Fan,
   "Sample quantiles in statistical packages,"
   The American Statistician, 50(4), pp. 361-365, 1996</pre> <div class="fragment"><div class="line"><span class="lineno"> 1401</span>):</div>
<div class="line"><span class="lineno"> 1402</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    Compute the qth quantile of the data along the specified axis,</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    while ignoring nan values.</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    Returns the qth quantile(s) of the array elements.</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">        Input array or object that can be converted to an array, containing</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">        nan values to be ignored</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    q : array_like of float</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">        Quantile or sequence of quantiles to compute, which must be between</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">        0 and 1 inclusive.</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">        Axis or axes along which the quantiles are computed. The</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">        default is to compute the quantile(s) along a flattened</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">        version of the array.</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">        have the same shape and buffer length as the expected output,</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">        but the type (of the output) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    overwrite_input : bool, optional</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">        If True, then allow the input array `a` to be modified by intermediate</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">        calculations, to save memory. In this case, the contents of the input</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">        `a` after this function completes is undefined.</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">        This parameter specifies the method to use for estimating the</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">        quantile.  There are many different methods, some unique to NumPy.</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">        See the notes for explanation.  The options sorted by their R type</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">        as summarized in the H&amp;F paper [1]_ are:</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">        1. &#39;inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">        2. &#39;averaged_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">        3. &#39;closest_observation&#39;</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">        4. &#39;interpolated_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">        5. &#39;hazen&#39;</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">        6. &#39;weibull&#39;</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">        7. &#39;linear&#39;  (default)</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">        8. &#39;median_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">        9. &#39;normal_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">        The first three methods are discontinuous.  NumPy further defines the</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">        * &#39;lower&#39;</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">        * &#39;higher&#39;,</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">        * &#39;midpoint&#39;</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">        * &#39;nearest&#39;</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">        .. versionchanged:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">            This argument was previously called &quot;interpolation&quot; and only</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">            offered the &quot;linear&quot; default and last four options.</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left in</span></div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">        the result as dimensions with size one. With this option, the</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">        result will broadcast correctly against the original array `a`.</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">        If this is anything but the default value it will be passed</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">        through (in the special case of an empty array) to the</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">        `mean` function of the underlying array.  If the array is</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">        a sub-class and `mean` does not have the kwarg `keepdims` this</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">        will raise a RuntimeError.</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">    interpolation : str, optional</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">        Deprecated name for the method keyword argument.</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">        .. deprecated:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    quantile : scalar or ndarray</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">        If `q` is a single percentile and `axis=None`, then the result</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">        is a scalar. If multiple quantiles are given, first axis of</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">        the result corresponds to the quantiles. The other axes are</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">        the axes that remain after the reduction of `a`. If the input</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">        contains integers or floats smaller than ``float64``, the output</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">        data-type is ``float64``. Otherwise, the output data-type is the</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">        same as that of the input. If `out` is specified, that array is</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">        returned instead.</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">    quantile</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">    nanmean, nanmedian</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">    nanmedian : equivalent to ``nanquantile(..., 0.5)``</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">    nanpercentile : same as nanquantile, but with q in the range [0, 100].</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">    For more information please see `numpy.quantile`</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    &gt;&gt;&gt; a[0][1] = np.nan</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    array([[10.,  nan,   4.],</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">          [ 3.,   2.,   1.]])</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    &gt;&gt;&gt; np.quantile(a, 0.5)</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    nan</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    &gt;&gt;&gt; np.nanquantile(a, 0.5)</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    &gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0)</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">    array([6.5, 2. , 2.5])</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    &gt;&gt;&gt; np.nanquantile(a, 0.5, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    array([[7.],</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">           [2.]])</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">    &gt;&gt;&gt; m = np.nanquantile(a, 0.5, axis=0)</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    &gt;&gt;&gt; out = np.zeros_like(m)</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">    &gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0, out=out)</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">    array([6.5, 2. , 2.5])</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">    &gt;&gt;&gt; m</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    array([6.5,  2. ,  2.5])</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">    &gt;&gt;&gt; np.nanquantile(b, 0.5, axis=1, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    array([7., 2.])</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a==b)</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    .. [1] R. J. Hyndman and Y. Fan,</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">       &quot;Sample quantiles in statistical packages,&quot;</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">       The American Statistician, 50(4), pp. 361-365, 1996</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1530</span>    <span class="keywordflow">if</span> interpolation <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1531</span>        method = function_base._check_interpolation_as_method(</div>
<div class="line"><span class="lineno"> 1532</span>            method, interpolation, <span class="stringliteral">&quot;nanquantile&quot;</span>)</div>
<div class="line"><span class="lineno"> 1533</span> </div>
<div class="line"><span class="lineno"> 1534</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 1535</span>    q = np.asanyarray(q)</div>
<div class="line"><span class="lineno"> 1536</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> function_base._quantile_is_valid(q):</div>
<div class="line"><span class="lineno"> 1537</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Quantiles must be in the range [0, 1]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1538</span>    <span class="keywordflow">return</span> _nanquantile_unchecked(</div>
<div class="line"><span class="lineno"> 1539</span>        a, q, axis, out, overwrite_input, method, keepdims)</div>
<div class="line"><span class="lineno"> 1540</span> </div>
<div class="line"><span class="lineno"> 1541</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a73682f653bf46927e2386511e7cb190e" name="a73682f653bf46927e2386511e7cb190e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73682f653bf46927e2386511e7cb190e">&#9670;&#160;</a></span>nanstd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanstd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the standard deviation along the specified axis, while
ignoring NaNs.

Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Calculate the standard deviation of the non-NaN values.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the standard deviation is computed. The default is
    to compute the standard deviation of the flattened array.
dtype : dtype, optional
    Type to use in computing the standard deviation. For arrays of
    integer type the default is float64, for arrays of float types it
    is the same as the array type.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type (of the
    calculated values) will be cast if necessary.
ddof : int, optional
    Means Delta Degrees of Freedom.  The divisor used in calculations
    is ``N - ddof``, where ``N`` represents the number of non-NaN
    elements.  By default `ddof` is zero.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If this value is anything but the default it is passed through
    as-is to the relevant functions of the sub-classes.  If these
    functions do not have a `keepdims` kwarg, a RuntimeError will
    be raised.
where : array_like of bool, optional
    Elements to include in the standard deviation.
    See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.22.0

Returns
-------
standard_deviation : ndarray, see dtype parameter above.
    If `out` is None, return a new array containing the standard
    deviation, otherwise return a reference to the output array. If
    ddof is &gt;= the number of non-NaN elements in a slice or the slice
    contains only NaNs, then the result for that slice is NaN.

See Also
--------
var, mean, std
nanvar, nanmean
:ref:`ufuncs-output-type`

Notes
-----
The standard deviation is the square root of the average of the squared
deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.

The average squared deviation is normally calculated as
``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is
specified, the divisor ``N - ddof`` is used instead. In standard
statistical practice, ``ddof=1`` provides an unbiased estimator of the
variance of the infinite population. ``ddof=0`` provides a maximum
likelihood estimate of the variance for normally distributed variables.
The standard deviation computed in this function is the square root of
the estimated variance, so even with ``ddof=1``, it will not be an
unbiased estimate of the standard deviation per se.

Note that, for complex numbers, `std` takes the absolute value before
squaring, so that the result is always real and nonnegative.

For floating-point input, the *std* is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example
below).  Specifying a higher-accuracy accumulator using the `dtype`
keyword can alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanstd(a)
1.247219128924647
&gt;&gt;&gt; np.nanstd(a, axis=0)
array([1., 0.])
&gt;&gt;&gt; np.nanstd(a, axis=1)
array([0.,  0.5]) # may vary</pre> <div class="fragment"><div class="line"><span class="lineno"> 1773</span>           *, where=np._NoValue):</div>
<div class="line"><span class="lineno"> 1774</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">    Compute the standard deviation along the specified axis, while</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">    ignoring NaNs.</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">    Returns the standard deviation, a measure of the spread of a</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">    distribution, of the non-NaN array elements. The standard deviation is</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    computed for the flattened array by default, otherwise over the</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">    specified axis.</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">    For all-NaN slices or slices with zero degrees of freedom, NaN is</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">    returned and a `RuntimeWarning` is raised.</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">        Calculate the standard deviation of the non-NaN values.</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">        Axis or axes along which the standard deviation is computed. The default is</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">        to compute the standard deviation of the flattened array.</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">        Type to use in computing the standard deviation. For arrays of</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">        integer type the default is float64, for arrays of float types it</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">        is the same as the array type.</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        Alternative output array in which to place the result. It must have</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">        the same shape as the expected output but the type (of the</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        calculated values) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">        Means Delta Degrees of Freedom.  The divisor used in calculations</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">        is ``N - ddof``, where ``N`` represents the number of non-NaN</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">        elements.  By default `ddof` is zero.</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">        If this value is anything but the default it is passed through</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">        as-is to the relevant functions of the sub-classes.  If these</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">        functions do not have a `keepdims` kwarg, a RuntimeError will</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">        be raised.</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">        Elements to include in the standard deviation.</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    standard_deviation : ndarray, see dtype parameter above.</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">        If `out` is None, return a new array containing the standard</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">        deviation, otherwise return a reference to the output array. If</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">        ddof is &gt;= the number of non-NaN elements in a slice or the slice</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        contains only NaNs, then the result for that slice is NaN.</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    var, mean, std</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    nanvar, nanmean</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">    The standard deviation is the square root of the average of the squared</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">    deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">    The average squared deviation is normally calculated as</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">    specified, the divisor ``N - ddof`` is used instead. In standard</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">    statistical practice, ``ddof=1`` provides an unbiased estimator of the</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">    variance of the infinite population. ``ddof=0`` provides a maximum</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">    likelihood estimate of the variance for normally distributed variables.</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    The standard deviation computed in this function is the square root of</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    the estimated variance, so even with ``ddof=1``, it will not be an</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">    unbiased estimate of the standard deviation per se.</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">    Note that, for complex numbers, `std` takes the absolute value before</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    squaring, so that the result is always real and nonnegative.</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    For floating-point input, the *std* is computed using the same</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    precision the input has. Depending on the input data, this can cause</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    the results to be inaccurate, especially for float32 (see example</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral">    below).  Specifying a higher-accuracy accumulator using the `dtype`</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    keyword can alleviate this issue.</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">    &gt;&gt;&gt; np.nanstd(a)</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">    1.247219128924647</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral">    &gt;&gt;&gt; np.nanstd(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">    array([1., 0.])</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">    &gt;&gt;&gt; np.nanstd(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">    array([0.,  0.5]) # may vary</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1872</span>    var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,</div>
<div class="line"><span class="lineno"> 1873</span>                 keepdims=keepdims, where=where)</div>
<div class="line"><span class="lineno"> 1874</span>    <span class="keywordflow">if</span> isinstance(var, np.ndarray):</div>
<div class="line"><span class="lineno"> 1875</span>        std = np.sqrt(var, out=var)</div>
<div class="line"><span class="lineno"> 1876</span>    <span class="keywordflow">elif</span> hasattr(var, <span class="stringliteral">&#39;dtype&#39;</span>):</div>
<div class="line"><span class="lineno"> 1877</span>        std = var.dtype.type(np.sqrt(var))</div>
<div class="line"><span class="lineno"> 1878</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1879</span>        std = np.sqrt(var)</div>
<div class="line"><span class="lineno"> 1880</span>    <span class="keywordflow">return</span> std</div>
</div><!-- fragment -->
</div>
</div>
<a id="abfd31c1b8a284fbcd994e473c6672048" name="abfd31c1b8a284fbcd994e473c6672048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd31c1b8a284fbcd994e473c6672048">&#9670;&#160;</a></span>nansum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nansum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.

In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.

Parameters
----------
a : array_like
    Array containing numbers whose sum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the sum is computed. The default is to compute the
    sum of the flattened array.
dtype : data-type, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  By default, the dtype of `a` is used.  An
    exception is when `a` has an integer type with less precision than
    the platform (u)intp. In that case, the default will be either
    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
    bits. For inexact inputs, dtype must be inexact.

    .. versionadded:: 1.8.0
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``. If provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.  See
    :ref:`ufuncs-output-type` for more details. The casting of NaN to integer
    can yield unexpected results.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.


    If the value is anything but the default, then
    `keepdims` will be passed through to the `mean` or `sum` methods
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0
initial : scalar, optional
    Starting value for the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.22.0
where : array_like of bool, optional
    Elements to include in the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.22.0

Returns
-------
nansum : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which it is returned. The result has the same
    size as `a`, and the same shape as `a` if `axis` is not None
    or `a` is a 1-d array.

See Also
--------
numpy.sum : Sum across array propagating NaNs.
isnan : Show which elements are NaN.
isfinite : Show which elements are not NaN or +/-inf.

Notes
-----
If both positive and negative infinity are present, the sum will be Not
A Number (NaN).

Examples
--------
&gt;&gt;&gt; np.nansum(1)
1
&gt;&gt;&gt; np.nansum([1])
1
&gt;&gt;&gt; np.nansum([1, np.nan])
1.0
&gt;&gt;&gt; a = np.array([[1, 1], [1, np.nan]])
&gt;&gt;&gt; np.nansum(a)
3.0
&gt;&gt;&gt; np.nansum(a, axis=0)
array([2.,  1.])
&gt;&gt;&gt; np.nansum([1, np.nan, np.inf])
inf
&gt;&gt;&gt; np.nansum([1, np.nan, np.NINF])
-inf
&gt;&gt;&gt; from numpy.testing import suppress_warnings
&gt;&gt;&gt; with suppress_warnings() as sup:
...     sup.filter(RuntimeWarning)
...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
nan</pre> <div class="fragment"><div class="line"><span class="lineno">  625</span>           initial=np._NoValue, where=np._NoValue):</div>
<div class="line"><span class="lineno">  626</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    Return the sum of array elements over a given axis treating Not a</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    Numbers (NaNs) as zero.</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    empty. In later versions zero is returned.</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">        Array containing numbers whose sum is desired. If `a` is not an</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">        Axis or axes along which the sum is computed. The default is to compute the</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">        sum of the flattened array.</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        The type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">        elements are summed.  By default, the dtype of `a` is used.  An</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">        exception is when `a` has an integer type with less precision than</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        the platform (u)intp. In that case, the default will be either</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">        (u)int32 or (u)int64 depending on whether the platform is 32 or 64</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        bits. For inexact inputs, dtype must be inexact.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">        Alternate output array in which to place the result.  The default</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        is ``None``. If provided, it must have the same shape as the</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        expected output, but the type will be cast if necessary.  See</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">        :ref:`ufuncs-output-type` for more details. The casting of NaN to integer</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        can yield unexpected results.</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">        If the value is anything but the default, then</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        `keepdims` will be passed through to the `mean` or `sum` methods</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">        of sub-classes of `ndarray`.  If the sub-classes methods</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">        does not implement `keepdims` any exceptions will be raised.</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    initial : scalar, optional</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        Starting value for the sum. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">        Elements to include in the sum. See `~numpy.ufunc.reduce` for details.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    nansum : ndarray.</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">        A new array holding the result is returned unless `out` is</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">        specified, in which it is returned. The result has the same</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">        size as `a`, and the same shape as `a` if `axis` is not None</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        or `a` is a 1-d array.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    numpy.sum : Sum across array propagating NaNs.</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    isnan : Show which elements are NaN.</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    isfinite : Show which elements are not NaN or +/-inf.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    If both positive and negative infinity are present, the sum will be Not</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    A Number (NaN).</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    &gt;&gt;&gt; np.nansum(1)</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    &gt;&gt;&gt; np.nansum([1])</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    &gt;&gt;&gt; np.nansum([1, np.nan])</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 1], [1, np.nan]])</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    &gt;&gt;&gt; np.nansum(a)</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    3.0</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    &gt;&gt;&gt; np.nansum(a, axis=0)</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    array([2.,  1.])</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    &gt;&gt;&gt; np.nansum([1, np.nan, np.inf])</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    inf</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    &gt;&gt;&gt; np.nansum([1, np.nan, np.NINF])</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    -inf</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.testing import suppress_warnings</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    &gt;&gt;&gt; with suppress_warnings() as sup:</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    ...     sup.filter(RuntimeWarning)</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    ...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    nan</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  722</span>    a, mask = _replace_nan(a, 0)</div>
<div class="line"><span class="lineno">  723</span>    <span class="keywordflow">return</span> np.sum(a, axis=axis, dtype=dtype, out=out, keepdims=keepdims,</div>
<div class="line"><span class="lineno">  724</span>                  initial=initial, where=where)</div>
<div class="line"><span class="lineno">  725</span> </div>
<div class="line"><span class="lineno">  726</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f4169784e618dc4d646c2be35efb7cd" name="a2f4169784e618dc4d646c2be35efb7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4169784e618dc4d646c2be35efb7cd">&#9670;&#160;</a></span>nanvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.nanvar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>where</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the variance along the specified axis, while ignoring NaNs.

Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the variance is computed.  The default is to compute
    the variance of the flattened array.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    "Delta Degrees of Freedom": the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of non-NaN
    elements. By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.
where : array_like of bool, optional
    Elements to include in the variance. See `~numpy.ufunc.reduce` for
    details.

    .. versionadded:: 1.22.0

Returns
-------
variance : ndarray, see dtype parameter above
    If `out` is None, return a new array containing the variance,
    otherwise return a reference to the output array. If ddof is &gt;= the
    number of non-NaN elements in a slice or the slice contains only
    NaNs, then the result for that slice is NaN.

See Also
--------
std : Standard deviation
mean : Average
var : Variance while not ignoring NaNs
nanstd, nanmean
:ref:`ufuncs-output-type`

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite
population.  ``ddof=0`` provides a maximum likelihood estimate of the
variance for normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

For this function to work on sub-classes of ndarray, they must define
`sum` with the kwarg `keepdims`

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanvar(a)
1.5555555555555554
&gt;&gt;&gt; np.nanvar(a, axis=0)
array([1.,  0.])
&gt;&gt;&gt; np.nanvar(a, axis=1)
array([0.,  0.25])  # may vary</pre> <div class="fragment"><div class="line"><span class="lineno"> 1612</span>           *, where=np._NoValue):</div>
<div class="line"><span class="lineno"> 1613</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">    Compute the variance along the specified axis, while ignoring NaNs.</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">    Returns the variance of the array elements, a measure of the spread of</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">    a distribution.  The variance is computed for the flattened array by</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">    default, otherwise over the specified axis.</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">    For all-NaN slices or slices with zero degrees of freedom, NaN is</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">    returned and a `RuntimeWarning` is raised.</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">        Array containing numbers whose variance is desired.  If `a` is not an</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">        array, a conversion is attempted.</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">        Axis or axes along which the variance is computed.  The default is to compute</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">        the variance of the flattened array.</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">        Type to use in computing the variance.  For arrays of integer type</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">        the default is `float64`; for arrays of float types it is the same as</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">        the array type.</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">        Alternate output array in which to place the result.  It must have</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">        the same shape as the expected output, but the type is cast if</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">        necessary.</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">        ``N - ddof``, where ``N`` represents the number of non-NaN</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">        elements. By default `ddof` is zero.</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">    where : array_like of bool, optional</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">        Elements to include in the variance. See `~numpy.ufunc.reduce` for</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral">        details.</span></div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">        .. versionadded:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">    variance : ndarray, see dtype parameter above</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">        If `out` is None, return a new array containing the variance,</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">        otherwise return a reference to the output array. If ddof is &gt;= the</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">        number of non-NaN elements in a slice or the slice contains only</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">        NaNs, then the result for that slice is NaN.</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">    std : Standard deviation</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">    mean : Average</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">    var : Variance while not ignoring NaNs</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    nanstd, nanmean</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    :ref:`ufuncs-output-type`</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    The variance is the average of the squared deviations from the mean,</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">    i.e.,  ``var = mean(abs(x - x.mean())**2)``.</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    If, however, `ddof` is specified, the divisor ``N - ddof`` is used</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    instead.  In standard statistical practice, ``ddof=1`` provides an</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">    unbiased estimator of the variance of a hypothetical infinite</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    population.  ``ddof=0`` provides a maximum likelihood estimate of the</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    variance for normally distributed variables.</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">    Note that for complex numbers, the absolute value is taken before</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    squaring, so that the result is always real and nonnegative.</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">    For floating-point input, the variance is computed using the same</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">    precision the input has.  Depending on the input data, this can cause</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">    the results to be inaccurate, especially for `float32` (see example</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">    below).  Specifying a higher-accuracy accumulator using the ``dtype``</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    keyword can alleviate this issue.</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">    For this function to work on sub-classes of ndarray, they must define</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">    `sum` with the kwarg `keepdims`</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">    &gt;&gt;&gt; np.nanvar(a)</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">    1.5555555555555554</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    &gt;&gt;&gt; np.nanvar(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">    array([1.,  0.])</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    &gt;&gt;&gt; np.nanvar(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    array([0.,  0.25])  # may vary</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1706</span>    arr, mask = _replace_nan(a, 0)</div>
<div class="line"><span class="lineno"> 1707</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1708</span>        <span class="keywordflow">return</span> np.var(arr, axis=axis, dtype=dtype, out=out, ddof=ddof,</div>
<div class="line"><span class="lineno"> 1709</span>                      keepdims=keepdims, where=where)</div>
<div class="line"><span class="lineno"> 1710</span> </div>
<div class="line"><span class="lineno"> 1711</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1712</span>        dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno"> 1713</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> issubclass(dtype.type, np.inexact):</div>
<div class="line"><span class="lineno"> 1714</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;If a is inexact, then dtype must be inexact&quot;</span>)</div>
<div class="line"><span class="lineno"> 1715</span>    <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> issubclass(out.dtype.type, np.inexact):</div>
<div class="line"><span class="lineno"> 1716</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;If a is inexact, then out must be inexact&quot;</span>)</div>
<div class="line"><span class="lineno"> 1717</span> </div>
<div class="line"><span class="lineno"> 1718</span>    <span class="comment"># Compute mean</span></div>
<div class="line"><span class="lineno"> 1719</span>    <span class="keywordflow">if</span> type(arr) <span class="keywordflow">is</span> np.matrix:</div>
<div class="line"><span class="lineno"> 1720</span>        _keepdims = np._NoValue</div>
<div class="line"><span class="lineno"> 1721</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1722</span>        _keepdims = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1723</span>    <span class="comment"># we need to special case matrix for reverse compatibility</span></div>
<div class="line"><span class="lineno"> 1724</span>    <span class="comment"># in order for this to work, these sums need to be called with</span></div>
<div class="line"><span class="lineno"> 1725</span>    <span class="comment"># keepdims=True, however matrix now raises an error in this case, but</span></div>
<div class="line"><span class="lineno"> 1726</span>    <span class="comment"># the reason that it drops the keepdims kwarg is to force keepdims=True</span></div>
<div class="line"><span class="lineno"> 1727</span>    <span class="comment"># so this used to work by serendipity.</span></div>
<div class="line"><span class="lineno"> 1728</span>    cnt = np.sum(~mask, axis=axis, dtype=np.intp, keepdims=_keepdims,</div>
<div class="line"><span class="lineno"> 1729</span>                 where=where)</div>
<div class="line"><span class="lineno"> 1730</span>    avg = np.sum(arr, axis=axis, dtype=dtype, keepdims=_keepdims, where=where)</div>
<div class="line"><span class="lineno"> 1731</span>    avg = _divide_by_count(avg, cnt)</div>
<div class="line"><span class="lineno"> 1732</span> </div>
<div class="line"><span class="lineno"> 1733</span>    <span class="comment"># Compute squared deviation from mean.</span></div>
<div class="line"><span class="lineno"> 1734</span>    np.subtract(arr, avg, out=arr, casting=<span class="stringliteral">&#39;unsafe&#39;</span>, where=where)</div>
<div class="line"><span class="lineno"> 1735</span>    arr = _copyto(arr, 0, mask)</div>
<div class="line"><span class="lineno"> 1736</span>    <span class="keywordflow">if</span> issubclass(arr.dtype.type, np.complexfloating):</div>
<div class="line"><span class="lineno"> 1737</span>        sqr = np.multiply(arr, arr.conj(), out=arr, where=where).real</div>
<div class="line"><span class="lineno"> 1738</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1739</span>        sqr = np.multiply(arr, arr, out=arr, where=where)</div>
<div class="line"><span class="lineno"> 1740</span> </div>
<div class="line"><span class="lineno"> 1741</span>    <span class="comment"># Compute variance.</span></div>
<div class="line"><span class="lineno"> 1742</span>    var = np.sum(sqr, axis=axis, dtype=dtype, out=out, keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 1743</span>                 where=where)</div>
<div class="line"><span class="lineno"> 1744</span> </div>
<div class="line"><span class="lineno"> 1745</span>    <span class="comment"># Precaution against reduced object arrays</span></div>
<div class="line"><span class="lineno"> 1746</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1747</span>        var_ndim = var.ndim</div>
<div class="line"><span class="lineno"> 1748</span>    <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 1749</span>        var_ndim = np.ndim(var)</div>
<div class="line"><span class="lineno"> 1750</span>    <span class="keywordflow">if</span> var_ndim &lt; cnt.ndim:</div>
<div class="line"><span class="lineno"> 1751</span>        <span class="comment"># Subclasses of ndarray may ignore keepdims, so check here.</span></div>
<div class="line"><span class="lineno"> 1752</span>        cnt = cnt.squeeze(axis)</div>
<div class="line"><span class="lineno"> 1753</span>    dof = cnt - ddof</div>
<div class="line"><span class="lineno"> 1754</span>    var = _divide_by_count(var, dof)</div>
<div class="line"><span class="lineno"> 1755</span> </div>
<div class="line"><span class="lineno"> 1756</span>    isbad = (dof &lt;= 0)</div>
<div class="line"><span class="lineno"> 1757</span>    <span class="keywordflow">if</span> np.any(isbad):</div>
<div class="line"><span class="lineno"> 1758</span>        warnings.warn(<span class="stringliteral">&quot;Degrees of freedom &lt;= 0 for slice.&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno"> 1759</span>                      stacklevel=3)</div>
<div class="line"><span class="lineno"> 1760</span>        <span class="comment"># NaN, inf, or negative numbers are all possible bad</span></div>
<div class="line"><span class="lineno"> 1761</span>        <span class="comment"># values, so explicitly replace them with NaN.</span></div>
<div class="line"><span class="lineno"> 1762</span>        var = _copyto(var, np.nan, isbad)</div>
<div class="line"><span class="lineno"> 1763</span>    <span class="keywordflow">return</span> var</div>
<div class="line"><span class="lineno"> 1764</span> </div>
<div class="line"><span class="lineno"> 1765</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5d66ace42e50dfe8f961bdaad0c9ff6e" name="a5d66ace42e50dfe8f961bdaad0c9ff6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d66ace42e50dfe8f961bdaad0c9ff6e">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
