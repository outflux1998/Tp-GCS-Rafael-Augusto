<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.stats._morestats Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats.html">stats</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html">_morestats</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.stats._morestats Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1stats_1_1__morestats_1_1___a_b_w.html">_ABW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa18cb0ea658376fef0b14314b7681611" id="r_aa18cb0ea658376fef0b14314b7681611"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#aa18cb0ea658376fef0b14314b7681611">bayes_mvs</a> (data, <a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#ace85b1427e9d22fa1c4faa15812b747d">alpha</a>=0.90)</td></tr>
<tr class="separator:aa18cb0ea658376fef0b14314b7681611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1b41e7416dd9f4537909f6f4fb98f8" id="r_aba1b41e7416dd9f4537909f6f4fb98f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#aba1b41e7416dd9f4537909f6f4fb98f8">mvsdist</a> (data)</td></tr>
<tr class="separator:aba1b41e7416dd9f4537909f6f4fb98f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4240a80fd709860b5a63acf219991dcf" id="r_a4240a80fd709860b5a63acf219991dcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a4240a80fd709860b5a63acf219991dcf">kstat</a> (data, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=2)</td></tr>
<tr class="separator:a4240a80fd709860b5a63acf219991dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a9f133ef967d3f334ef8b7fc573983" id="r_ab8a9f133ef967d3f334ef8b7fc573983"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ab8a9f133ef967d3f334ef8b7fc573983">kstatvar</a> (data, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=2)</td></tr>
<tr class="separator:ab8a9f133ef967d3f334ef8b7fc573983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc50b779d664d1fcc5437ae81b2118" id="r_abcfc50b779d664d1fcc5437ae81b2118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#abcfc50b779d664d1fcc5437ae81b2118">_calc_uniform_order_statistic_medians</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:abcfc50b779d664d1fcc5437ae81b2118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d1e13676d4afb1f3b54f0451af4a54" id="r_a15d1e13676d4afb1f3b54f0451af4a54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a15d1e13676d4afb1f3b54f0451af4a54">_parse_dist_kw</a> (dist, enforce_subclass=True)</td></tr>
<tr class="separator:a15d1e13676d4afb1f3b54f0451af4a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac665132057e03a14ff3bb554fdc27555" id="r_ac665132057e03a14ff3bb554fdc27555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ac665132057e03a14ff3bb554fdc27555">_add_axis_labels_title</a> (plot, xlabel, ylabel, title)</td></tr>
<tr class="separator:ac665132057e03a14ff3bb554fdc27555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a762e91cdcf4bede4a0ace1d96b091" id="r_ad0a762e91cdcf4bede4a0ace1d96b091"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ad0a762e91cdcf4bede4a0ace1d96b091">probplot</a> (x, sparams=(), dist='norm', fit=True, plot=None, rvalue=False)</td></tr>
<tr class="separator:ad0a762e91cdcf4bede4a0ace1d96b091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f28fe29e196c4bfe59e5619f859946f" id="r_a3f28fe29e196c4bfe59e5619f859946f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a3f28fe29e196c4bfe59e5619f859946f">ppcc_max</a> (x, brack=(0.0, 1.0), dist='<a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#a22e5805528fe5ea9fc9962f9a49cf5d9">tukeylambda</a>')</td></tr>
<tr class="separator:a3f28fe29e196c4bfe59e5619f859946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92883d23651fe5aa26beaef7c55a5ce" id="r_ac92883d23651fe5aa26beaef7c55a5ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ac92883d23651fe5aa26beaef7c55a5ce">ppcc_plot</a> (x, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, dist='<a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#a22e5805528fe5ea9fc9962f9a49cf5d9">tukeylambda</a>', plot=None, N=80)</td></tr>
<tr class="separator:ac92883d23651fe5aa26beaef7c55a5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d168816d9c396b378a0d0d15544b56" id="r_a93d168816d9c396b378a0d0d15544b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a93d168816d9c396b378a0d0d15544b56">boxcox_llf</a> (lmb, data)</td></tr>
<tr class="separator:a93d168816d9c396b378a0d0d15544b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8a5a2adc6fc9bd197a0e3109734353" id="r_a9c8a5a2adc6fc9bd197a0e3109734353"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a9c8a5a2adc6fc9bd197a0e3109734353">_boxcox_conf_interval</a> (x, lmax, <a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#ace85b1427e9d22fa1c4faa15812b747d">alpha</a>)</td></tr>
<tr class="separator:a9c8a5a2adc6fc9bd197a0e3109734353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8927cc8608f6decd26a9fe23214071e1" id="r_a8927cc8608f6decd26a9fe23214071e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a8927cc8608f6decd26a9fe23214071e1">boxcox</a> (x, lmbda=None, <a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#ace85b1427e9d22fa1c4faa15812b747d">alpha</a>=None, optimizer=None)</td></tr>
<tr class="separator:a8927cc8608f6decd26a9fe23214071e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e99833f0ddea425698e0590079d2d9" id="r_ae6e99833f0ddea425698e0590079d2d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ae6e99833f0ddea425698e0590079d2d9">boxcox_normmax</a> (x, brack=None, <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='<a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7a080f1bfe9c97c7a3f1e609349e4a6c">pearsonr</a>', optimizer=None)</td></tr>
<tr class="separator:ae6e99833f0ddea425698e0590079d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8b65fc912abb046b5556527b32f09d" id="r_a0a8b65fc912abb046b5556527b32f09d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a0a8b65fc912abb046b5556527b32f09d">_normplot</a> (<a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>, x, la, lb, plot=None, N=80)</td></tr>
<tr class="separator:a0a8b65fc912abb046b5556527b32f09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91186ccc31cc60f13d65ab705c006a4f" id="r_a91186ccc31cc60f13d65ab705c006a4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a91186ccc31cc60f13d65ab705c006a4f">boxcox_normplot</a> (x, la, lb, plot=None, N=80)</td></tr>
<tr class="separator:a91186ccc31cc60f13d65ab705c006a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b302a2d21bd578ba3ff828a99000b6d" id="r_a0b302a2d21bd578ba3ff828a99000b6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a0b302a2d21bd578ba3ff828a99000b6d">yeojohnson</a> (x, lmbda=None)</td></tr>
<tr class="separator:a0b302a2d21bd578ba3ff828a99000b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eddca00d1a762d16c27be928ed4fd2" id="r_a94eddca00d1a762d16c27be928ed4fd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a94eddca00d1a762d16c27be928ed4fd2">_yeojohnson_transform</a> (x, lmbda)</td></tr>
<tr class="separator:a94eddca00d1a762d16c27be928ed4fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07ef1cbf1d88998be1d88789ac21135" id="r_ae07ef1cbf1d88998be1d88789ac21135"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ae07ef1cbf1d88998be1d88789ac21135">yeojohnson_llf</a> (lmb, data)</td></tr>
<tr class="separator:ae07ef1cbf1d88998be1d88789ac21135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e11fd74ac89acf7920558617d8aa708" id="r_a7e11fd74ac89acf7920558617d8aa708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a7e11fd74ac89acf7920558617d8aa708">yeojohnson_normmax</a> (x, brack=(-2, 2))</td></tr>
<tr class="separator:a7e11fd74ac89acf7920558617d8aa708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40ff897f481883c947ea2fe777cb0f1" id="r_ac40ff897f481883c947ea2fe777cb0f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ac40ff897f481883c947ea2fe777cb0f1">yeojohnson_normplot</a> (x, la, lb, plot=None, N=80)</td></tr>
<tr class="separator:ac40ff897f481883c947ea2fe777cb0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada353fe6934760152d3262990c5559c7" id="r_ada353fe6934760152d3262990c5559c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ada353fe6934760152d3262990c5559c7">shapiro</a> (x)</td></tr>
<tr class="separator:ada353fe6934760152d3262990c5559c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff42d8e60ef8d4a2e3e243fed9061df" id="r_a5ff42d8e60ef8d4a2e3e243fed9061df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a5ff42d8e60ef8d4a2e3e243fed9061df">anderson</a> (x, dist='norm')</td></tr>
<tr class="separator:a5ff42d8e60ef8d4a2e3e243fed9061df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8bfd0f7f8a99f24676999a1d6a1081" id="r_a9b8bfd0f7f8a99f24676999a1d6a1081"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a9b8bfd0f7f8a99f24676999a1d6a1081">_anderson_ksamp_midrank</a> (samples, Z, Zstar, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, N)</td></tr>
<tr class="separator:a9b8bfd0f7f8a99f24676999a1d6a1081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f372073d70d2d3a3e33676d615c0d72" id="r_a0f372073d70d2d3a3e33676d615c0d72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a0f372073d70d2d3a3e33676d615c0d72">_anderson_ksamp_right</a> (samples, Z, Zstar, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, N)</td></tr>
<tr class="separator:a0f372073d70d2d3a3e33676d615c0d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e4786d193296d8337d4d138fde02b" id="r_af79e4786d193296d8337d4d138fde02b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#af79e4786d193296d8337d4d138fde02b">anderson_ksamp</a> (samples, midrank=True)</td></tr>
<tr class="separator:af79e4786d193296d8337d4d138fde02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf0b043d4a34d9afcc7b63c4d80757e" id="r_a5cf0b043d4a34d9afcc7b63c4d80757e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a5cf0b043d4a34d9afcc7b63c4d80757e">ansari</a> (x, y, alternative='two-sided')</td></tr>
<tr class="separator:a5cf0b043d4a34d9afcc7b63c4d80757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ab9423e7e286b7c52654cf7333e897" id="r_a96ab9423e7e286b7c52654cf7333e897"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a96ab9423e7e286b7c52654cf7333e897">bartlett</a> (*samples)</td></tr>
<tr class="separator:a96ab9423e7e286b7c52654cf7333e897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23262638e4d8d639649530a5a7cf2d8" id="r_aa23262638e4d8d639649530a5a7cf2d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#aa23262638e4d8d639649530a5a7cf2d8">levene</a> (*samples, center='median', proportiontocut=0.05)</td></tr>
<tr class="separator:aa23262638e4d8d639649530a5a7cf2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9decd286dafd3e07427ade8321b3228c" id="r_a9decd286dafd3e07427ade8321b3228c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a9decd286dafd3e07427ade8321b3228c">binom_test</a> (x, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, p=0.5, alternative='two-sided')</td></tr>
<tr class="separator:a9decd286dafd3e07427ade8321b3228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8927546ed57b93755671f7132e54de2b" id="r_a8927546ed57b93755671f7132e54de2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a8927546ed57b93755671f7132e54de2b">_apply_func</a> (x, <a class="el" href="__lapack__subroutines_8h.html#aeb0d2dd2a2609d5775607acf542b2161">g</a>, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>)</td></tr>
<tr class="separator:a8927546ed57b93755671f7132e54de2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978e827467d79fbfe254eea650472601" id="r_a978e827467d79fbfe254eea650472601"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a978e827467d79fbfe254eea650472601">fligner</a> (*samples, center='median', proportiontocut=0.05)</td></tr>
<tr class="separator:a978e827467d79fbfe254eea650472601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa8d37c155924a7c55dd9b66af6a0b2" id="r_adaa8d37c155924a7c55dd9b66af6a0b2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#adaa8d37c155924a7c55dd9b66af6a0b2">_mood_inner_lc</a> (xy, x, diffs, sorted_xy, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, m, N)</td></tr>
<tr class="separator:adaa8d37c155924a7c55dd9b66af6a0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a8c126360ffed1a47ea5ef24d67463" id="r_aa2a8c126360ffed1a47ea5ef24d67463"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#aa2a8c126360ffed1a47ea5ef24d67463">mood</a> (x, y, axis=0, alternative=&quot;two-sided&quot;)</td></tr>
<tr class="separator:aa2a8c126360ffed1a47ea5ef24d67463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2739e0b0f2ef66fdfd2131664be94b" id="r_a6a2739e0b0f2ef66fdfd2131664be94b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a6a2739e0b0f2ef66fdfd2131664be94b">wilcoxon_result_unpacker</a> (res)</td></tr>
<tr class="separator:a6a2739e0b0f2ef66fdfd2131664be94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cb6178c9c02363490ed746438f8857" id="r_a66cb6178c9c02363490ed746438f8857"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a66cb6178c9c02363490ed746438f8857">wilcoxon_result_object</a> (statistic, pvalue, zstatistic=None)</td></tr>
<tr class="separator:a66cb6178c9c02363490ed746438f8857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6e371f0b3b6c73d4f678f59017343f" id="r_a5e6e371f0b3b6c73d4f678f59017343f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a5e6e371f0b3b6c73d4f678f59017343f">wilcoxon_outputs</a> (kwds)</td></tr>
<tr class="separator:a5e6e371f0b3b6c73d4f678f59017343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6be93729b9052a8ffa98d5a17f96f6" id="r_acf6be93729b9052a8ffa98d5a17f96f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#acf6be93729b9052a8ffa98d5a17f96f6">wilcoxon</a> (x, y=None, zero_method=&quot;wilcox&quot;, correction=False, alternative=&quot;two-sided&quot;, <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='auto')</td></tr>
<tr class="separator:acf6be93729b9052a8ffa98d5a17f96f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d69aee9a069d7a4cec2d2cc5ab55a6" id="r_aa9d69aee9a069d7a4cec2d2cc5ab55a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#aa9d69aee9a069d7a4cec2d2cc5ab55a6">median_test</a> (*samples, ties='below', correction=True, lambda_=1, nan_policy='propagate')</td></tr>
<tr class="separator:aa9d69aee9a069d7a4cec2d2cc5ab55a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12523f3a8245cb3c28fb18704daff0ab" id="r_a12523f3a8245cb3c28fb18704daff0ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a12523f3a8245cb3c28fb18704daff0ab">_circfuncs_common</a> (samples, high, low, nan_policy='propagate')</td></tr>
<tr class="separator:a12523f3a8245cb3c28fb18704daff0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d886f881520f6b73d7bff6f071854" id="r_ad39d886f881520f6b73d7bff6f071854"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ad39d886f881520f6b73d7bff6f071854">circmean</a> (samples, high=2 *pi, low=0, axis=None, nan_policy='propagate')</td></tr>
<tr class="separator:ad39d886f881520f6b73d7bff6f071854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b2d677962cb55b72b6eee1d4e84b79" id="r_ab2b2d677962cb55b72b6eee1d4e84b79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ab2b2d677962cb55b72b6eee1d4e84b79">circvar</a> (samples, high=2 *pi, low=0, axis=None, nan_policy='propagate')</td></tr>
<tr class="separator:ab2b2d677962cb55b72b6eee1d4e84b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7931e19d28601b600e60d91db5e34d51" id="r_a7931e19d28601b600e60d91db5e34d51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a7931e19d28601b600e60d91db5e34d51">circstd</a> (samples, high=2 *pi, low=0, axis=None, nan_policy='propagate', *normalize=False)</td></tr>
<tr class="separator:a7931e19d28601b600e60d91db5e34d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4c7e806ff86e4c65ae6c3bb01070277d" id="r_a4c7e806ff86e4c65ae6c3bb01070277d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a4c7e806ff86e4c65ae6c3bb01070277d">Mean</a> = namedtuple('Mean', ('statistic', 'minmax'))</td></tr>
<tr class="separator:a4c7e806ff86e4c65ae6c3bb01070277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab3ea6ff622d79893687564827860de" id="r_abab3ea6ff622d79893687564827860de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#abab3ea6ff622d79893687564827860de">Variance</a> = namedtuple('Variance', ('statistic', 'minmax'))</td></tr>
<tr class="separator:abab3ea6ff622d79893687564827860de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e0efb5926c36511cd250ae4ad4f517" id="r_ae5e0efb5926c36511cd250ae4ad4f517"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ae5e0efb5926c36511cd250ae4ad4f517">Std_dev</a> = namedtuple('Std_dev', ('statistic', 'minmax'))</td></tr>
<tr class="separator:ae5e0efb5926c36511cd250ae4ad4f517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee599c9ef5b9c5cb6169a4073e4f652d" id="r_aee599c9ef5b9c5cb6169a4073e4f652d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#aee599c9ef5b9c5cb6169a4073e4f652d">ShapiroResult</a> = namedtuple('ShapiroResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:aee599c9ef5b9c5cb6169a4073e4f652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd2ed9760a5b98dbc3fd333fc804528" id="r_a7cd2ed9760a5b98dbc3fd333fc804528"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a7cd2ed9760a5b98dbc3fd333fc804528">_Avals_norm</a> = array([0.576, 0.656, 0.787, 0.918, 1.092])</td></tr>
<tr class="separator:a7cd2ed9760a5b98dbc3fd333fc804528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8549d509c0d1eeba1b065cbdf4639966" id="r_a8549d509c0d1eeba1b065cbdf4639966"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a8549d509c0d1eeba1b065cbdf4639966">_Avals_expon</a> = array([0.922, 1.078, 1.341, 1.606, 1.957])</td></tr>
<tr class="separator:a8549d509c0d1eeba1b065cbdf4639966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e585a2cdac83e1d7baba82b355ecd" id="r_a4a7e585a2cdac83e1d7baba82b355ecd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a4a7e585a2cdac83e1d7baba82b355ecd">_Avals_gumbel</a> = array([0.474, 0.637, 0.757, 0.877, 1.038])</td></tr>
<tr class="separator:a4a7e585a2cdac83e1d7baba82b355ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81d3b78fe67a51c6bea0ef06599d68b" id="r_aa81d3b78fe67a51c6bea0ef06599d68b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#aa81d3b78fe67a51c6bea0ef06599d68b">_Avals_logistic</a> = array([0.426, 0.563, 0.660, 0.769, 0.906, 1.010])</td></tr>
<tr class="separator:aa81d3b78fe67a51c6bea0ef06599d68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2b948cf1b0b7f3e3a89f732d46a158" id="r_a4c2b948cf1b0b7f3e3a89f732d46a158"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a4c2b948cf1b0b7f3e3a89f732d46a158">AndersonResult</a></td></tr>
<tr class="separator:a4c2b948cf1b0b7f3e3a89f732d46a158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff" id="r_a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff">Anderson_ksampResult</a></td></tr>
<tr class="separator:a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ca11a242ed6b7363bbcd987cb99719" id="r_ac2ca11a242ed6b7363bbcd987cb99719"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#ac2ca11a242ed6b7363bbcd987cb99719">AnsariResult</a> = namedtuple('AnsariResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:ac2ca11a242ed6b7363bbcd987cb99719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07abc5dc6f5050cd6d367147d07ceab8" id="r_a07abc5dc6f5050cd6d367147d07ceab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a07abc5dc6f5050cd6d367147d07ceab8">_abw_state</a> = <a class="el" href="classscipy_1_1stats_1_1__morestats_1_1___a_b_w.html">_ABW</a>()</td></tr>
<tr class="separator:a07abc5dc6f5050cd6d367147d07ceab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554d0b4564651ac511f77b4db7cedcbc" id="r_a554d0b4564651ac511f77b4db7cedcbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a554d0b4564651ac511f77b4db7cedcbc">BartlettResult</a> = namedtuple('BartlettResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a554d0b4564651ac511f77b4db7cedcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa85627e72f7e9cfaa3289858b4070b" id="r_a3aa85627e72f7e9cfaa3289858b4070b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a3aa85627e72f7e9cfaa3289858b4070b">LeveneResult</a> = namedtuple('LeveneResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a3aa85627e72f7e9cfaa3289858b4070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5984334ae4ec091c625db36e4df5a0fc" id="r_a5984334ae4ec091c625db36e4df5a0fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a5984334ae4ec091c625db36e4df5a0fc">FlignerResult</a> = namedtuple('FlignerResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a5984334ae4ec091c625db36e4df5a0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dc3765613b9ba274d8c8020459cf47" id="r_a55dc3765613b9ba274d8c8020459cf47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__morestats.html#a55dc3765613b9ba274d8c8020459cf47">WilcoxonResult</a> = _make_tuple_bunch('WilcoxonResult', ['statistic', 'pvalue'])</td></tr>
<tr class="separator:a55dc3765613b9ba274d8c8020459cf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac665132057e03a14ff3bb554fdc27555" name="ac665132057e03a14ff3bb554fdc27555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac665132057e03a14ff3bb554fdc27555">&#9670;&#160;</a></span>_add_axis_labels_title()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._add_axis_labels_title </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xlabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ylabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function to add axes labels and a title to stats plots.</pre> <div class="fragment"><div class="line"><span class="lineno">  463</span><span class="keyword">def </span>_add_axis_labels_title(plot, xlabel, ylabel, title):</div>
<div class="line"><span class="lineno">  464</span>    <span class="stringliteral">&quot;&quot;&quot;Helper function to add axes labels and a title to stats plots.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  465</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  466</span>        <span class="keywordflow">if</span> hasattr(plot, <span class="stringliteral">&#39;set_title&#39;</span>):</div>
<div class="line"><span class="lineno">  467</span>            <span class="comment"># Matplotlib Axes instance or something that looks like it</span></div>
<div class="line"><span class="lineno">  468</span>            plot.set_title(title)</div>
<div class="line"><span class="lineno">  469</span>            plot.set_xlabel(xlabel)</div>
<div class="line"><span class="lineno">  470</span>            plot.set_ylabel(ylabel)</div>
<div class="line"><span class="lineno">  471</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  472</span>            <span class="comment"># matplotlib.pyplot module</span></div>
<div class="line"><span class="lineno">  473</span>            plot.title(title)</div>
<div class="line"><span class="lineno">  474</span>            plot.xlabel(xlabel)</div>
<div class="line"><span class="lineno">  475</span>            plot.ylabel(ylabel)</div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  477</span>        <span class="comment"># Not an MPL object or something that looks (enough) like it.</span></div>
<div class="line"><span class="lineno">  478</span>        <span class="comment"># Don&#39;t crash on adding labels or title</span></div>
<div class="line"><span class="lineno">  479</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  480</span> </div>
<div class="line"><span class="lineno">  481</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b8bfd0f7f8a99f24676999a1d6a1081" name="a9b8bfd0f7f8a99f24676999a1d6a1081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8bfd0f7f8a99f24676999a1d6a1081">&#9670;&#160;</a></span>_anderson_ksamp_midrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._anderson_ksamp_midrank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Zstar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute A2akN equation 7 of Scholz and Stephens.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample arrays.
Z : array_like
    Sorted array of all observations.
Zstar : array_like
    Sorted array of unique observations.
k : int
    Number of samples.
n : array_like
    Number of observations in each sample.
N : int
    Total number of observations.

Returns
-------
A2aKN : float
    The A2aKN statistics of Scholz and Stephens 1987.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1951</span><span class="keyword">def </span>_anderson_ksamp_midrank(samples, Z, Zstar, k, n, N):</div>
<div class="line"><span class="lineno"> 1952</span>    <span class="stringliteral">&quot;&quot;&quot;Compute A2akN equation 7 of Scholz and Stephens.</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral">    samples : sequence of 1-D array_like</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral">        Array of sample arrays.</span></div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">    Z : array_like</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">        Sorted array of all observations.</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">    Zstar : array_like</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">        Sorted array of unique observations.</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">        Number of samples.</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral">    n : array_like</span></div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">        Number of observations in each sample.</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">    N : int</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">        Total number of observations.</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">    A2aKN : float</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">        The A2aKN statistics of Scholz and Stephens 1987.</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1975</span>    A2akN = 0.</div>
<div class="line"><span class="lineno"> 1976</span>    Z_ssorted_left = Z.searchsorted(Zstar, <span class="stringliteral">&#39;left&#39;</span>)</div>
<div class="line"><span class="lineno"> 1977</span>    <span class="keywordflow">if</span> N == Zstar.size:</div>
<div class="line"><span class="lineno"> 1978</span>        lj = 1.</div>
<div class="line"><span class="lineno"> 1979</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1980</span>        lj = Z.searchsorted(Zstar, <span class="stringliteral">&#39;right&#39;</span>) - Z_ssorted_left</div>
<div class="line"><span class="lineno"> 1981</span>    Bj = Z_ssorted_left + lj / 2.</div>
<div class="line"><span class="lineno"> 1982</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> arange(0, k):</div>
<div class="line"><span class="lineno"> 1983</span>        s = np.sort(samples[i])</div>
<div class="line"><span class="lineno"> 1984</span>        s_ssorted_right = s.searchsorted(Zstar, side=<span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno"> 1985</span>        Mij = s_ssorted_right.astype(float)</div>
<div class="line"><span class="lineno"> 1986</span>        fij = s_ssorted_right - s.searchsorted(Zstar, <span class="stringliteral">&#39;left&#39;</span>)</div>
<div class="line"><span class="lineno"> 1987</span>        Mij -= fij / 2.</div>
<div class="line"><span class="lineno"> 1988</span>        inner = lj / float(N) * (N*Mij - Bj*n[i])**2 / (Bj*(N - Bj) - N*lj/4.)</div>
<div class="line"><span class="lineno"> 1989</span>        A2akN += inner.sum() / n[i]</div>
<div class="line"><span class="lineno"> 1990</span>    A2akN *= (N - 1.) / N</div>
<div class="line"><span class="lineno"> 1991</span>    <span class="keywordflow">return</span> A2akN</div>
<div class="line"><span class="lineno"> 1992</span> </div>
<div class="line"><span class="lineno"> 1993</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f372073d70d2d3a3e33676d615c0d72" name="a0f372073d70d2d3a3e33676d615c0d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f372073d70d2d3a3e33676d615c0d72">&#9670;&#160;</a></span>_anderson_ksamp_right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._anderson_ksamp_right </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Zstar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute A2akN equation 6 of Scholz &amp; Stephens.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample arrays.
Z : array_like
    Sorted array of all observations.
Zstar : array_like
    Sorted array of unique observations.
k : int
    Number of samples.
n : array_like
    Number of observations in each sample.
N : int
    Total number of observations.

Returns
-------
A2KN : float
    The A2KN statistics of Scholz and Stephens 1987.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1994</span><span class="keyword">def </span>_anderson_ksamp_right(samples, Z, Zstar, k, n, N):</div>
<div class="line"><span class="lineno"> 1995</span>    <span class="stringliteral">&quot;&quot;&quot;Compute A2akN equation 6 of Scholz &amp; Stephens.</span></div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">    samples : sequence of 1-D array_like</span></div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral">        Array of sample arrays.</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">    Z : array_like</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral">        Sorted array of all observations.</span></div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral">    Zstar : array_like</span></div>
<div class="line"><span class="lineno"> 2004</span><span class="stringliteral">        Sorted array of unique observations.</span></div>
<div class="line"><span class="lineno"> 2005</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno"> 2006</span><span class="stringliteral">        Number of samples.</span></div>
<div class="line"><span class="lineno"> 2007</span><span class="stringliteral">    n : array_like</span></div>
<div class="line"><span class="lineno"> 2008</span><span class="stringliteral">        Number of observations in each sample.</span></div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">    N : int</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral">        Total number of observations.</span></div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral">    A2KN : float</span></div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">        The A2KN statistics of Scholz and Stephens 1987.</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2018</span>    A2kN = 0.</div>
<div class="line"><span class="lineno"> 2019</span>    lj = Z.searchsorted(Zstar[:-1], <span class="stringliteral">&#39;right&#39;</span>) - Z.searchsorted(Zstar[:-1],</div>
<div class="line"><span class="lineno"> 2020</span>                                                              <span class="stringliteral">&#39;left&#39;</span>)</div>
<div class="line"><span class="lineno"> 2021</span>    Bj = lj.cumsum()</div>
<div class="line"><span class="lineno"> 2022</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> arange(0, k):</div>
<div class="line"><span class="lineno"> 2023</span>        s = np.sort(samples[i])</div>
<div class="line"><span class="lineno"> 2024</span>        Mij = s.searchsorted(Zstar[:-1], side=<span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno"> 2025</span>        inner = lj / float(N) * (N * Mij - Bj * n[i])**2 / (Bj * (N - Bj))</div>
<div class="line"><span class="lineno"> 2026</span>        A2kN += inner.sum() / n[i]</div>
<div class="line"><span class="lineno"> 2027</span>    <span class="keywordflow">return</span> A2kN</div>
<div class="line"><span class="lineno"> 2028</span> </div>
<div class="line"><span class="lineno"> 2029</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8927546ed57b93755671f7132e54de2b" name="a8927546ed57b93755671f7132e54de2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8927546ed57b93755671f7132e54de2b">&#9670;&#160;</a></span>_apply_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._apply_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2744</span><span class="keyword">def </span>_apply_func(x, g, func):</div>
<div class="line"><span class="lineno"> 2745</span>    <span class="comment"># g is list of indices into x</span></div>
<div class="line"><span class="lineno"> 2746</span>    <span class="comment">#  separating x into different groups</span></div>
<div class="line"><span class="lineno"> 2747</span>    <span class="comment">#  func should be applied over the groups</span></div>
<div class="line"><span class="lineno"> 2748</span>    g = unique(r_[0, g, len(x)])</div>
<div class="line"><span class="lineno"> 2749</span>    output = [<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(x[g[k]:g[k+1]]) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(len(g) - 1)]</div>
<div class="line"><span class="lineno"> 2750</span> </div>
<div class="line"><span class="lineno"> 2751</span>    <span class="keywordflow">return</span> asarray(output)</div>
<div class="line"><span class="lineno"> 2752</span> </div>
<div class="line"><span class="lineno"> 2753</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c8a5a2adc6fc9bd197a0e3109734353" name="a9c8a5a2adc6fc9bd197a0e3109734353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8a5a2adc6fc9bd197a0e3109734353">&#9670;&#160;</a></span>_boxcox_conf_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._boxcox_conf_interval </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  927</span><span class="keyword">def </span>_boxcox_conf_interval(x, lmax, alpha):</div>
<div class="line"><span class="lineno">  928</span>    <span class="comment"># Need to find the lambda for which</span></div>
<div class="line"><span class="lineno">  929</span>    <span class="comment">#  f(x,lmbda) &gt;= f(x,lmax) - 0.5*chi^2_alpha;1</span></div>
<div class="line"><span class="lineno">  930</span>    fac = 0.5 * distributions.chi2.ppf(1 - alpha, 1)</div>
<div class="line"><span class="lineno">  931</span>    target = boxcox_llf(lmax, x) - fac</div>
<div class="line"><span class="lineno">  932</span> </div>
<div class="line"><span class="lineno">  933</span>    <span class="keyword">def </span>rootfunc(lmbda, data, target):</div>
<div class="line"><span class="lineno">  934</span>        <span class="keywordflow">return</span> boxcox_llf(lmbda, data) - target</div>
<div class="line"><span class="lineno">  935</span> </div>
<div class="line"><span class="lineno">  936</span>    <span class="comment"># Find positive endpoint of interval in which answer is to be found</span></div>
<div class="line"><span class="lineno">  937</span>    newlm = lmax + 0.5</div>
<div class="line"><span class="lineno">  938</span>    N = 0</div>
<div class="line"><span class="lineno">  939</span>    <span class="keywordflow">while</span> (rootfunc(newlm, x, target) &gt; 0.0) <span class="keywordflow">and</span> (N &lt; 500):</div>
<div class="line"><span class="lineno">  940</span>        newlm += 0.1</div>
<div class="line"><span class="lineno">  941</span>        N += 1</div>
<div class="line"><span class="lineno">  942</span> </div>
<div class="line"><span class="lineno">  943</span>    <span class="keywordflow">if</span> N == 500:</div>
<div class="line"><span class="lineno">  944</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;Could not find endpoint.&quot;</span>)</div>
<div class="line"><span class="lineno">  945</span> </div>
<div class="line"><span class="lineno">  946</span>    lmplus = optimize.brentq(rootfunc, lmax, newlm, args=(x, target))</div>
<div class="line"><span class="lineno">  947</span> </div>
<div class="line"><span class="lineno">  948</span>    <span class="comment"># Now find negative interval in the same way</span></div>
<div class="line"><span class="lineno">  949</span>    newlm = lmax - 0.5</div>
<div class="line"><span class="lineno">  950</span>    N = 0</div>
<div class="line"><span class="lineno">  951</span>    <span class="keywordflow">while</span> (rootfunc(newlm, x, target) &gt; 0.0) <span class="keywordflow">and</span> (N &lt; 500):</div>
<div class="line"><span class="lineno">  952</span>        newlm -= 0.1</div>
<div class="line"><span class="lineno">  953</span>        N += 1</div>
<div class="line"><span class="lineno">  954</span> </div>
<div class="line"><span class="lineno">  955</span>    <span class="keywordflow">if</span> N == 500:</div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;Could not find endpoint.&quot;</span>)</div>
<div class="line"><span class="lineno">  957</span> </div>
<div class="line"><span class="lineno">  958</span>    lmminus = optimize.brentq(rootfunc, newlm, lmax, args=(x, target))</div>
<div class="line"><span class="lineno">  959</span>    <span class="keywordflow">return</span> lmminus, lmplus</div>
<div class="line"><span class="lineno">  960</span> </div>
<div class="line"><span class="lineno">  961</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abcfc50b779d664d1fcc5437ae81b2118" name="abcfc50b779d664d1fcc5437ae81b2118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfc50b779d664d1fcc5437ae81b2118">&#9670;&#160;</a></span>_calc_uniform_order_statistic_medians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._calc_uniform_order_statistic_medians </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Approximations of uniform order statistic medians.

Parameters
----------
n : int
    Sample size.

Returns
-------
v : 1d float array
    Approximations of the order statistic medians.

References
----------
.. [1] James J. Filliben, "The Probability Plot Correlation Coefficient
       Test for Normality", Technometrics, Vol. 17, pp. 111-117, 1975.

Examples
--------
Order statistics of the uniform distribution on the unit interval
are marginally distributed according to beta distributions.
The expectations of these order statistic are evenly spaced across
the interval, but the distributions are skewed in a way that
pushes the medians slightly towards the endpoints of the unit interval:

&gt;&gt;&gt; n = 4
&gt;&gt;&gt; k = np.arange(1, n+1)
&gt;&gt;&gt; from scipy.stats import beta
&gt;&gt;&gt; a = k
&gt;&gt;&gt; b = n-k+1
&gt;&gt;&gt; beta.mean(a, b)
array([0.2, 0.4, 0.6, 0.8])
&gt;&gt;&gt; beta.median(a, b)
array([0.15910358, 0.38572757, 0.61427243, 0.84089642])

The Filliben approximation uses the exact medians of the smallest
and greatest order statistics, and the remaining medians are approximated
by points spread evenly across a sub-interval of the unit interval:

&gt;&gt;&gt; from scipy.stats._morestats import _calc_uniform_order_statistic_medians
&gt;&gt;&gt; _calc_uniform_order_statistic_medians(n)
array([0.15910358, 0.38545246, 0.61454754, 0.84089642])

This plot shows the skewed distributions of the order statistics
of a sample of size four from a uniform distribution on the unit interval:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.linspace(0.0, 1.0, num=50, endpoint=True)
&gt;&gt;&gt; pdfs = [beta.pdf(x, a[i], b[i]) for i in range(n)]
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(x, pdfs[0], x, pdfs[1], x, pdfs[2], x, pdfs[3])</pre> <div class="fragment"><div class="line"><span class="lineno">  370</span><span class="keyword">def </span>_calc_uniform_order_statistic_medians(n):</div>
<div class="line"><span class="lineno">  371</span>    <span class="stringliteral">&quot;&quot;&quot;Approximations of uniform order statistic medians.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        Sample size.</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    v : 1d float array</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        Approximations of the order statistic medians.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    .. [1] James J. Filliben, &quot;The Probability Plot Correlation Coefficient</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">           Test for Normality&quot;, Technometrics, Vol. 17, pp. 111-117, 1975.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    Order statistics of the uniform distribution on the unit interval</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    are marginally distributed according to beta distributions.</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    The expectations of these order statistic are evenly spaced across</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    the interval, but the distributions are skewed in a way that</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    pushes the medians slightly towards the endpoints of the unit interval:</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    &gt;&gt;&gt; n = 4</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    &gt;&gt;&gt; k = np.arange(1, n+1)</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import beta</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    &gt;&gt;&gt; a = k</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    &gt;&gt;&gt; b = n-k+1</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    &gt;&gt;&gt; beta.mean(a, b)</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    array([0.2, 0.4, 0.6, 0.8])</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    &gt;&gt;&gt; beta.median(a, b)</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    array([0.15910358, 0.38572757, 0.61427243, 0.84089642])</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    The Filliben approximation uses the exact medians of the smallest</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    and greatest order statistics, and the remaining medians are approximated</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    by points spread evenly across a sub-interval of the unit interval:</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats._morestats import _calc_uniform_order_statistic_medians</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    &gt;&gt;&gt; _calc_uniform_order_statistic_medians(n)</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    array([0.15910358, 0.38545246, 0.61454754, 0.84089642])</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    This plot shows the skewed distributions of the order statistics</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    of a sample of size four from a uniform distribution on the unit interval:</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0.0, 1.0, num=50, endpoint=True)</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; pdfs = [beta.pdf(x, a[i], b[i]) for i in range(n)]</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, pdfs[0], x, pdfs[1], x, pdfs[2], x, pdfs[3])</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  424</span>    v = np.empty(n, dtype=np.float64)</div>
<div class="line"><span class="lineno">  425</span>    v[-1] = 0.5**(1.0 / n)</div>
<div class="line"><span class="lineno">  426</span>    v[0] = 1 - v[-1]</div>
<div class="line"><span class="lineno">  427</span>    i = np.arange(2, n)</div>
<div class="line"><span class="lineno">  428</span>    v[1:-1] = (i - 0.3175) / (n + 0.365)</div>
<div class="line"><span class="lineno">  429</span>    <span class="keywordflow">return</span> v</div>
<div class="line"><span class="lineno">  430</span> </div>
<div class="line"><span class="lineno">  431</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a12523f3a8245cb3c28fb18704daff0ab" name="a12523f3a8245cb3c28fb18704daff0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12523f3a8245cb3c28fb18704daff0ab">&#9670;&#160;</a></span>_circfuncs_common()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._circfuncs_common </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3650</span><span class="keyword">def </span>_circfuncs_common(samples, high, low, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 3651</span>    <span class="comment"># Ensure samples are array-like and size is not zero</span></div>
<div class="line"><span class="lineno"> 3652</span>    samples = np.asarray(samples)</div>
<div class="line"><span class="lineno"> 3653</span>    <span class="keywordflow">if</span> samples.size == 0:</div>
<div class="line"><span class="lineno"> 3654</span>        <span class="keywordflow">return</span> np.nan, np.asarray(np.nan), np.asarray(np.nan), <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3655</span> </div>
<div class="line"><span class="lineno"> 3656</span>    <span class="comment"># Recast samples as radians that range between 0 and 2 pi and calculate</span></div>
<div class="line"><span class="lineno"> 3657</span>    <span class="comment"># the sine and cosine</span></div>
<div class="line"><span class="lineno"> 3658</span>    sin_samp = sin((samples - low)*2.*pi / (high - low))</div>
<div class="line"><span class="lineno"> 3659</span>    cos_samp = cos((samples - low)*2.*pi / (high - low))</div>
<div class="line"><span class="lineno"> 3660</span> </div>
<div class="line"><span class="lineno"> 3661</span>    <span class="comment"># Apply the NaN policy</span></div>
<div class="line"><span class="lineno"> 3662</span>    contains_nan, nan_policy = _contains_nan(samples, nan_policy)</div>
<div class="line"><span class="lineno"> 3663</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 3664</span>        mask = np.isnan(samples)</div>
<div class="line"><span class="lineno"> 3665</span>        <span class="comment"># Set the sines and cosines that are NaN to zero</span></div>
<div class="line"><span class="lineno"> 3666</span>        sin_samp[mask] = 0.0</div>
<div class="line"><span class="lineno"> 3667</span>        cos_samp[mask] = 0.0</div>
<div class="line"><span class="lineno"> 3668</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3669</span>        mask = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3670</span> </div>
<div class="line"><span class="lineno"> 3671</span>    <span class="keywordflow">return</span> samples, sin_samp, cos_samp, mask</div>
<div class="line"><span class="lineno"> 3672</span> </div>
<div class="line"><span class="lineno"> 3673</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adaa8d37c155924a7c55dd9b66af6a0b2" name="adaa8d37c155924a7c55dd9b66af6a0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa8d37c155924a7c55dd9b66af6a0b2">&#9670;&#160;</a></span>_mood_inner_lc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> float scipy.stats._morestats._mood_inner_lc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sorted_xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2889</span><span class="keyword">def </span>_mood_inner_lc(xy, x, diffs, sorted_xy, n, m, N) -&gt; float:</div>
<div class="line"><span class="lineno"> 2890</span>    <span class="comment"># Obtain the unique values and their frequencies from the pooled samples.</span></div>
<div class="line"><span class="lineno"> 2891</span>    <span class="comment"># &quot;a_j, + b_j, = t_j, for j = 1, ... k&quot; where `k` is the number of unique</span></div>
<div class="line"><span class="lineno"> 2892</span>    <span class="comment"># classes, and &quot;[t]he number of values associated with the x&#39;s and y&#39;s in</span></div>
<div class="line"><span class="lineno"> 2893</span>    <span class="comment"># the jth class will be denoted by a_j, and b_j respectively.&quot;</span></div>
<div class="line"><span class="lineno"> 2894</span>    <span class="comment"># (Mielke, 312)</span></div>
<div class="line"><span class="lineno"> 2895</span>    <span class="comment"># Reuse previously computed sorted array and `diff` arrays to obtain the</span></div>
<div class="line"><span class="lineno"> 2896</span>    <span class="comment"># unique values and counts. Prepend `diffs` with a non-zero to indicate</span></div>
<div class="line"><span class="lineno"> 2897</span>    <span class="comment"># that the first element should be marked as not matching what preceded it.</span></div>
<div class="line"><span class="lineno"> 2898</span>    diffs_prep = np.concatenate(([1], diffs))</div>
<div class="line"><span class="lineno"> 2899</span>    <span class="comment"># Unique elements are where the was a difference between elements in the</span></div>
<div class="line"><span class="lineno"> 2900</span>    <span class="comment"># sorted array</span></div>
<div class="line"><span class="lineno"> 2901</span>    uniques = sorted_xy[diffs_prep != 0]</div>
<div class="line"><span class="lineno"> 2902</span>    <span class="comment"># The count of each element is the bin size for each set of consecutive</span></div>
<div class="line"><span class="lineno"> 2903</span>    <span class="comment"># differences where the difference is zero. Replace nonzero differences</span></div>
<div class="line"><span class="lineno"> 2904</span>    <span class="comment"># with 1 and then use the cumulative sum to count the indices.</span></div>
<div class="line"><span class="lineno"> 2905</span>    t = np.bincount(np.cumsum(np.asarray(diffs_prep != 0, dtype=int)))[1:]</div>
<div class="line"><span class="lineno"> 2906</span>    k = len(uniques)</div>
<div class="line"><span class="lineno"> 2907</span>    js = np.arange(1, k + 1, dtype=int)</div>
<div class="line"><span class="lineno"> 2908</span>    <span class="comment"># the `b` array mentioned in the paper is not used, outside of the</span></div>
<div class="line"><span class="lineno"> 2909</span>    <span class="comment"># calculation of `t`, so we do not need to calculate it separately. Here</span></div>
<div class="line"><span class="lineno"> 2910</span>    <span class="comment"># we calculate `a`. In plain language, `a[j]` is the number of values in</span></div>
<div class="line"><span class="lineno"> 2911</span>    <span class="comment"># `x` that equal `uniques[j]`.</span></div>
<div class="line"><span class="lineno"> 2912</span>    sorted_xyx = np.sort(np.concatenate((xy, x)))</div>
<div class="line"><span class="lineno"> 2913</span>    diffs = np.diff(sorted_xyx)</div>
<div class="line"><span class="lineno"> 2914</span>    diffs_prep = np.concatenate(([1], diffs))</div>
<div class="line"><span class="lineno"> 2915</span>    diff_is_zero = np.asarray(diffs_prep != 0, dtype=int)</div>
<div class="line"><span class="lineno"> 2916</span>    xyx_counts = np.bincount(np.cumsum(diff_is_zero))[1:]</div>
<div class="line"><span class="lineno"> 2917</span>    a = xyx_counts - t</div>
<div class="line"><span class="lineno"> 2918</span>    <span class="comment"># &quot;Define .. a_0 = b_0 = t_0 = S_0 = 0&quot; (Mielke 312) so we shift  `a`</span></div>
<div class="line"><span class="lineno"> 2919</span>    <span class="comment"># and `t` arrays over 1 to allow a first element of 0 to accommodate this</span></div>
<div class="line"><span class="lineno"> 2920</span>    <span class="comment"># indexing.</span></div>
<div class="line"><span class="lineno"> 2921</span>    t = np.concatenate(([0], t))</div>
<div class="line"><span class="lineno"> 2922</span>    a = np.concatenate(([0], a))</div>
<div class="line"><span class="lineno"> 2923</span>    <span class="comment"># S is built from `t`, so it does not need a preceding zero added on.</span></div>
<div class="line"><span class="lineno"> 2924</span>    S = np.cumsum(t)</div>
<div class="line"><span class="lineno"> 2925</span>    <span class="comment"># define a copy of `S` with a prepending zero for later use to avoid</span></div>
<div class="line"><span class="lineno"> 2926</span>    <span class="comment"># the need for indexing.</span></div>
<div class="line"><span class="lineno"> 2927</span>    S_i_m1 = np.concatenate(([0], S[:-1]))</div>
<div class="line"><span class="lineno"> 2928</span> </div>
<div class="line"><span class="lineno"> 2929</span>    <span class="comment"># Psi, as defined by the 6th unnumbered equation on page 313 (Mielke).</span></div>
<div class="line"><span class="lineno"> 2930</span>    <span class="comment"># Note that in the paper there is an error where the denominator `2` is</span></div>
<div class="line"><span class="lineno"> 2931</span>    <span class="comment"># squared when it should be the entire equation.</span></div>
<div class="line"><span class="lineno"> 2932</span>    <span class="keyword">def </span>psi(indicator):</div>
<div class="line"><span class="lineno"> 2933</span>        <span class="keywordflow">return</span> (indicator - (N + 1)/2)**2</div>
<div class="line"><span class="lineno"> 2934</span> </div>
<div class="line"><span class="lineno"> 2935</span>    <span class="comment"># define summation range for use in calculation of phi, as seen in sum</span></div>
<div class="line"><span class="lineno"> 2936</span>    <span class="comment"># in the unnumbered equation on the bottom of page 312 (Mielke).</span></div>
<div class="line"><span class="lineno"> 2937</span>    s_lower = S[js - 1] + 1</div>
<div class="line"><span class="lineno"> 2938</span>    s_upper = S[js] + 1</div>
<div class="line"><span class="lineno"> 2939</span>    phi_J = [np.arange(s_lower[idx], s_upper[idx]) <span class="keywordflow">for</span> idx <span class="keywordflow">in</span> range(k)]</div>
<div class="line"><span class="lineno"> 2940</span> </div>
<div class="line"><span class="lineno"> 2941</span>    <span class="comment"># for every range in the above array, determine the sum of psi(I) for</span></div>
<div class="line"><span class="lineno"> 2942</span>    <span class="comment"># every element in the range. Divide all the sums by `t`. Following the</span></div>
<div class="line"><span class="lineno"> 2943</span>    <span class="comment"># last unnumbered equation on page 312.</span></div>
<div class="line"><span class="lineno"> 2944</span>    phis = [np.sum(psi(I_j)) <span class="keywordflow">for</span> I_j <span class="keywordflow">in</span> phi_J] / t[js]</div>
<div class="line"><span class="lineno"> 2945</span> </div>
<div class="line"><span class="lineno"> 2946</span>    <span class="comment"># `T` is equal to a[j] * phi[j], per the first unnumbered equation on</span></div>
<div class="line"><span class="lineno"> 2947</span>    <span class="comment"># page 312. `phis` is already in the order based on `js`, so we index</span></div>
<div class="line"><span class="lineno"> 2948</span>    <span class="comment"># into `a` with `js` as well.</span></div>
<div class="line"><span class="lineno"> 2949</span>    T = sum(phis * a[js])</div>
<div class="line"><span class="lineno"> 2950</span> </div>
<div class="line"><span class="lineno"> 2951</span>    <span class="comment"># The approximate statistic</span></div>
<div class="line"><span class="lineno"> 2952</span>    E_0_T = n * (N * N - 1) / 12</div>
<div class="line"><span class="lineno"> 2953</span> </div>
<div class="line"><span class="lineno"> 2954</span>    varM = (m * n * (N + 1.0) * (N ** 2 - 4) / 180 -</div>
<div class="line"><span class="lineno"> 2955</span>            m * n / (180 * N * (N - 1)) * np.sum(</div>
<div class="line"><span class="lineno"> 2956</span>                t * (t**2 - 1) * (t**2 - 4 + (15 * (N - S - S_i_m1) ** 2))</div>
<div class="line"><span class="lineno"> 2957</span>            ))</div>
<div class="line"><span class="lineno"> 2958</span> </div>
<div class="line"><span class="lineno"> 2959</span>    <span class="keywordflow">return</span> ((T - E_0_T) / np.sqrt(varM),)</div>
<div class="line"><span class="lineno"> 2960</span> </div>
<div class="line"><span class="lineno"> 2961</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a8b65fc912abb046b5556527b32f09d" name="a0a8b65fc912abb046b5556527b32f09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8b65fc912abb046b5556527b32f09d">&#9670;&#160;</a></span>_normplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._normplot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>la</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plot</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute parameters for a Box-Cox or Yeo-Johnson normality plot,
optionally show it.

See `boxcox_normplot` or `yeojohnson_normplot` for details.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1271</span><span class="keyword">def </span>_normplot(method, x, la, lb, plot=None, N=80):</div>
<div class="line"><span class="lineno"> 1272</span>    <span class="stringliteral">&quot;&quot;&quot;Compute parameters for a Box-Cox or Yeo-Johnson normality plot,</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    optionally show it.</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">    See `boxcox_normplot` or `yeojohnson_normplot` for details.</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1277</span> </div>
<div class="line"><span class="lineno"> 1278</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;boxcox&#39;</span>:</div>
<div class="line"><span class="lineno"> 1279</span>        title = <span class="stringliteral">&#39;Box-Cox Normality Plot&#39;</span></div>
<div class="line"><span class="lineno"> 1280</span>        transform_func = boxcox</div>
<div class="line"><span class="lineno"> 1281</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1282</span>        title = <span class="stringliteral">&#39;Yeo-Johnson Normality Plot&#39;</span></div>
<div class="line"><span class="lineno"> 1283</span>        transform_func = yeojohnson</div>
<div class="line"><span class="lineno"> 1284</span> </div>
<div class="line"><span class="lineno"> 1285</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 1286</span>    <span class="keywordflow">if</span> x.size == 0:</div>
<div class="line"><span class="lineno"> 1287</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 1288</span> </div>
<div class="line"><span class="lineno"> 1289</span>    <span class="keywordflow">if</span> lb &lt;= la:</div>
<div class="line"><span class="lineno"> 1290</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`lb` has to be larger than `la`.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1291</span> </div>
<div class="line"><span class="lineno"> 1292</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;boxcox&#39;</span> <span class="keywordflow">and</span> np.any(x &lt;= 0):</div>
<div class="line"><span class="lineno"> 1293</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data must be positive.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1294</span> </div>
<div class="line"><span class="lineno"> 1295</span>    lmbdas = np.linspace(la, lb, num=N)</div>
<div class="line"><span class="lineno"> 1296</span>    ppcc = lmbdas * 0.0</div>
<div class="line"><span class="lineno"> 1297</span>    <span class="keywordflow">for</span> i, val <span class="keywordflow">in</span> enumerate(lmbdas):</div>
<div class="line"><span class="lineno"> 1298</span>        <span class="comment"># Determine for each lmbda the square root of correlation coefficient</span></div>
<div class="line"><span class="lineno"> 1299</span>        <span class="comment"># of transformed x</span></div>
<div class="line"><span class="lineno"> 1300</span>        z = transform_func(x, lmbda=val)</div>
<div class="line"><span class="lineno"> 1301</span>        _, (_, _, r) = probplot(z, dist=<span class="stringliteral">&#39;norm&#39;</span>, fit=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1302</span>        ppcc[i] = r</div>
<div class="line"><span class="lineno"> 1303</span> </div>
<div class="line"><span class="lineno"> 1304</span>    <span class="keywordflow">if</span> plot <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1305</span>        plot.plot(lmbdas, ppcc, <span class="stringliteral">&#39;x&#39;</span>)</div>
<div class="line"><span class="lineno"> 1306</span>        _add_axis_labels_title(plot, xlabel=<span class="stringliteral">&#39;$\\lambda$&#39;</span>,</div>
<div class="line"><span class="lineno"> 1307</span>                               ylabel=<span class="stringliteral">&#39;Prob Plot Corr. Coef.&#39;</span>,</div>
<div class="line"><span class="lineno"> 1308</span>                               title=title)</div>
<div class="line"><span class="lineno"> 1309</span> </div>
<div class="line"><span class="lineno"> 1310</span>    <span class="keywordflow">return</span> lmbdas, ppcc</div>
<div class="line"><span class="lineno"> 1311</span> </div>
<div class="line"><span class="lineno"> 1312</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a15d1e13676d4afb1f3b54f0451af4a54" name="a15d1e13676d4afb1f3b54f0451af4a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d1e13676d4afb1f3b54f0451af4a54">&#9670;&#160;</a></span>_parse_dist_kw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._parse_dist_kw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enforce_subclass</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parse `dist` keyword.

Parameters
----------
dist : str or stats.distributions instance.
    Several functions take `dist` as a keyword, hence this utility
    function.
enforce_subclass : bool, optional
    If True (default), `dist` needs to be a
    `_distn_infrastructure.rv_generic` instance.
    It can sometimes be useful to set this keyword to False, if a function
    wants to accept objects that just look somewhat like such an instance
    (for example, they have a ``ppf`` method).</pre> <div class="fragment"><div class="line"><span class="lineno">  432</span><span class="keyword">def </span>_parse_dist_kw(dist, enforce_subclass=True):</div>
<div class="line"><span class="lineno">  433</span>    <span class="stringliteral">&quot;&quot;&quot;Parse `dist` keyword.</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    dist : str or stats.distributions instance.</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        Several functions take `dist` as a keyword, hence this utility</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        function.</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    enforce_subclass : bool, optional</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">        If True (default), `dist` needs to be a</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        `_distn_infrastructure.rv_generic` instance.</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        It can sometimes be useful to set this keyword to False, if a function</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        wants to accept objects that just look somewhat like such an instance</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        (for example, they have a ``ppf`` method).</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">if</span> isinstance(dist, rv_generic):</div>
<div class="line"><span class="lineno">  449</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordflow">elif</span> isinstance(dist, str):</div>
<div class="line"><span class="lineno">  451</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  452</span>            dist = getattr(distributions, dist)</div>
<div class="line"><span class="lineno">  453</span>        <span class="keywordflow">except</span> AttributeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  454</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;%s is not a valid distribution name&quot;</span> % dist) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  455</span>    <span class="keywordflow">elif</span> enforce_subclass:</div>
<div class="line"><span class="lineno">  456</span>        msg = (<span class="stringliteral">&quot;`dist` should be a stats.distributions instance or a string &quot;</span></div>
<div class="line"><span class="lineno">  457</span>               <span class="stringliteral">&quot;with the name of such a distribution.&quot;</span>)</div>
<div class="line"><span class="lineno">  458</span>        <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">return</span> dist</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a94eddca00d1a762d16c27be928ed4fd2" name="a94eddca00d1a762d16c27be928ed4fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94eddca00d1a762d16c27be928ed4fd2">&#9670;&#160;</a></span>_yeojohnson_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._yeojohnson_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmbda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns `x` transformed by the Yeo-Johnson power transform with given
parameter `lmbda`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1472</span><span class="keyword">def </span>_yeojohnson_transform(x, lmbda):</div>
<div class="line"><span class="lineno"> 1473</span>    <span class="stringliteral">&quot;&quot;&quot;Returns `x` transformed by the Yeo-Johnson power transform with given</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">    parameter `lmbda`.</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1476</span>    out = np.zeros_like(x)</div>
<div class="line"><span class="lineno"> 1477</span>    pos = x &gt;= 0  <span class="comment"># binary mask</span></div>
<div class="line"><span class="lineno"> 1478</span> </div>
<div class="line"><span class="lineno"> 1479</span>    <span class="comment"># when x &gt;= 0</span></div>
<div class="line"><span class="lineno"> 1480</span>    <span class="keywordflow">if</span> abs(lmbda) &lt; np.spacing(1.):</div>
<div class="line"><span class="lineno"> 1481</span>        out[pos] = np.log1p(x[pos])</div>
<div class="line"><span class="lineno"> 1482</span>    <span class="keywordflow">else</span>:  <span class="comment"># lmbda != 0</span></div>
<div class="line"><span class="lineno"> 1483</span>        out[pos] = (np.power(x[pos] + 1, lmbda) - 1) / lmbda</div>
<div class="line"><span class="lineno"> 1484</span> </div>
<div class="line"><span class="lineno"> 1485</span>    <span class="comment"># when x &lt; 0</span></div>
<div class="line"><span class="lineno"> 1486</span>    <span class="keywordflow">if</span> abs(lmbda - 2) &gt; np.spacing(1.):</div>
<div class="line"><span class="lineno"> 1487</span>        out[~pos] = -(np.power(-x[~pos] + 1, 2 - lmbda) - 1) / (2 - lmbda)</div>
<div class="line"><span class="lineno"> 1488</span>    <span class="keywordflow">else</span>:  <span class="comment"># lmbda == 2</span></div>
<div class="line"><span class="lineno"> 1489</span>        out[~pos] = -np.log1p(-x[~pos])</div>
<div class="line"><span class="lineno"> 1490</span> </div>
<div class="line"><span class="lineno"> 1491</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1492</span> </div>
<div class="line"><span class="lineno"> 1493</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ff42d8e60ef8d4a2e3e243fed9061df" name="a5ff42d8e60ef8d4a2e3e243fed9061df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff42d8e60ef8d4a2e3e243fed9061df">&#9670;&#160;</a></span>anderson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.anderson </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em> = <code>'norm'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Anderson-Darling test for data coming from a particular distribution.

The Anderson-Darling test tests the null hypothesis that a sample is
drawn from a population that follows a particular distribution.
For the Anderson-Darling test, the critical values depend on
which distribution is being tested against.  This function works
for normal, exponential, logistic, or Gumbel (Extreme Value
Type I) distributions.

Parameters
----------
x : array_like
    Array of sample data.
dist : {'norm', 'expon', 'logistic', 'gumbel', 'gumbel_l', 'gumbel_r', 'extreme1'}, optional
    The type of distribution to test against.  The default is 'norm'.
    The names 'extreme1', 'gumbel_l' and 'gumbel' are synonyms for the
    same distribution.

Returns
-------
statistic : float
    The Anderson-Darling test statistic.
critical_values : list
    The critical values for this distribution.
significance_level : list
    The significance levels for the corresponding critical values
    in percents.  The function returns critical values for a
    differing set of significance levels depending on the
    distribution that is being tested against.

See Also
--------
kstest : The Kolmogorov-Smirnov test for goodness-of-fit.

Notes
-----
Critical values provided are for the following significance levels:

normal/exponential
    15%, 10%, 5%, 2.5%, 1%
logistic
    25%, 10%, 5%, 2.5%, 1%, 0.5%
Gumbel
    25%, 10%, 5%, 2.5%, 1%

If the returned statistic is larger than these critical values then
for the corresponding significance level, the null hypothesis that
the data come from the chosen distribution can be rejected.
The returned statistic is referred to as 'A2' in the references.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
.. [2] Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and
       Some Comparisons, Journal of the American Statistical Association,
       Vol. 69, pp. 730-737.
.. [3] Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit
       Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,
       pp. 357-369.
.. [4] Stephens, M. A. (1977). Goodness of Fit for the Extreme Value
       Distribution, Biometrika, Vol. 64, pp. 583-588.
.. [5] Stephens, M. A. (1977). Goodness of Fit with Special Reference
       to Tests for Exponentiality , Technical Report No. 262,
       Department of Statistics, Stanford University, Stanford, CA.
.. [6] Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution
       Based on the Empirical Distribution Function, Biometrika, Vol. 66,
       pp. 591-595.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1824</span><span class="keyword">def </span>anderson(x, dist=&#39;norm&#39;):</div>
<div class="line"><span class="lineno"> 1825</span>    <span class="stringliteral">&quot;&quot;&quot;Anderson-Darling test for data coming from a particular distribution.</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    The Anderson-Darling test tests the null hypothesis that a sample is</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    drawn from a population that follows a particular distribution.</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    For the Anderson-Darling test, the critical values depend on</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    which distribution is being tested against.  This function works</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    for normal, exponential, logistic, or Gumbel (Extreme Value</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    Type I) distributions.</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">        Array of sample data.</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    dist : {&#39;norm&#39;, &#39;expon&#39;, &#39;logistic&#39;, &#39;gumbel&#39;, &#39;gumbel_l&#39;, &#39;gumbel_r&#39;, &#39;extreme1&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">        The type of distribution to test against.  The default is &#39;norm&#39;.</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">        The names &#39;extreme1&#39;, &#39;gumbel_l&#39; and &#39;gumbel&#39; are synonyms for the</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">        same distribution.</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">        The Anderson-Darling test statistic.</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">    critical_values : list</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">        The critical values for this distribution.</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    significance_level : list</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">        The significance levels for the corresponding critical values</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">        in percents.  The function returns critical values for a</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">        differing set of significance levels depending on the</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">        distribution that is being tested against.</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    kstest : The Kolmogorov-Smirnov test for goodness-of-fit.</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">    Critical values provided are for the following significance levels:</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    normal/exponential</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">        15%, 10%, 5%, 2.5%, 1%</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">    logistic</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral">        25%, 10%, 5%, 2.5%, 1%, 0.5%</span></div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">    Gumbel</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">        25%, 10%, 5%, 2.5%, 1%</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">    If the returned statistic is larger than these critical values then</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">    for the corresponding significance level, the null hypothesis that</span></div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">    the data come from the chosen distribution can be rejected.</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">    The returned statistic is referred to as &#39;A2&#39; in the references.</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    .. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">    .. [2] Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">           Some Comparisons, Journal of the American Statistical Association,</span></div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral">           Vol. 69, pp. 730-737.</span></div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">    .. [3] Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral">           Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,</span></div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral">           pp. 357-369.</span></div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">    .. [4] Stephens, M. A. (1977). Goodness of Fit for the Extreme Value</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">           Distribution, Biometrika, Vol. 64, pp. 583-588.</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    .. [5] Stephens, M. A. (1977). Goodness of Fit with Special Reference</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral">           to Tests for Exponentiality , Technical Report No. 262,</span></div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">           Department of Statistics, Stanford University, Stanford, CA.</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral">    .. [6] Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution</span></div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">           Based on the Empirical Distribution Function, Biometrika, Vol. 66,</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">           pp. 591-595.</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1894</span>    <span class="keywordflow">if</span> dist <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;norm&#39;</span>, <span class="stringliteral">&#39;expon&#39;</span>, <span class="stringliteral">&#39;gumbel&#39;</span>, <span class="stringliteral">&#39;gumbel_l&#39;</span>,</div>
<div class="line"><span class="lineno"> 1895</span>                    <span class="stringliteral">&#39;gumbel_r&#39;</span>, <span class="stringliteral">&#39;extreme1&#39;</span>, <span class="stringliteral">&#39;logistic&#39;</span>]:</div>
<div class="line"><span class="lineno"> 1896</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid distribution; dist must be &#39;norm&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 1897</span>                         <span class="stringliteral">&quot;&#39;expon&#39;, &#39;gumbel&#39;, &#39;extreme1&#39; or &#39;logistic&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1898</span>    y = sort(x)</div>
<div class="line"><span class="lineno"> 1899</span>    xbar = np.mean(x, axis=0)</div>
<div class="line"><span class="lineno"> 1900</span>    N = len(y)</div>
<div class="line"><span class="lineno"> 1901</span>    <span class="keywordflow">if</span> dist == <span class="stringliteral">&#39;norm&#39;</span>:</div>
<div class="line"><span class="lineno"> 1902</span>        s = np.std(x, ddof=1, axis=0)</div>
<div class="line"><span class="lineno"> 1903</span>        w = (y - xbar) / s</div>
<div class="line"><span class="lineno"> 1904</span>        logcdf = distributions.norm.logcdf(w)</div>
<div class="line"><span class="lineno"> 1905</span>        logsf = distributions.norm.logsf(w)</div>
<div class="line"><span class="lineno"> 1906</span>        sig = array([15, 10, 5, 2.5, 1])</div>
<div class="line"><span class="lineno"> 1907</span>        critical = around(_Avals_norm / (1.0 + 4.0/N - 25.0/N/N), 3)</div>
<div class="line"><span class="lineno"> 1908</span>    <span class="keywordflow">elif</span> dist == <span class="stringliteral">&#39;expon&#39;</span>:</div>
<div class="line"><span class="lineno"> 1909</span>        w = y / xbar</div>
<div class="line"><span class="lineno"> 1910</span>        logcdf = distributions.expon.logcdf(w)</div>
<div class="line"><span class="lineno"> 1911</span>        logsf = distributions.expon.logsf(w)</div>
<div class="line"><span class="lineno"> 1912</span>        sig = array([15, 10, 5, 2.5, 1])</div>
<div class="line"><span class="lineno"> 1913</span>        critical = around(_Avals_expon / (1.0 + 0.6/N), 3)</div>
<div class="line"><span class="lineno"> 1914</span>    <span class="keywordflow">elif</span> dist == <span class="stringliteral">&#39;logistic&#39;</span>:</div>
<div class="line"><span class="lineno"> 1915</span>        <span class="keyword">def </span>rootfunc(ab, xj, N):</div>
<div class="line"><span class="lineno"> 1916</span>            a, b = ab</div>
<div class="line"><span class="lineno"> 1917</span>            tmp = (xj - a) / b</div>
<div class="line"><span class="lineno"> 1918</span>            tmp2 = exp(tmp)</div>
<div class="line"><span class="lineno"> 1919</span>            val = [np.sum(1.0/(1+tmp2), axis=0) - 0.5*N,</div>
<div class="line"><span class="lineno"> 1920</span>                   np.sum(tmp*(1.0-tmp2)/(1+tmp2), axis=0) + N]</div>
<div class="line"><span class="lineno"> 1921</span>            <span class="keywordflow">return</span> array(val)</div>
<div class="line"><span class="lineno"> 1922</span> </div>
<div class="line"><span class="lineno"> 1923</span>        sol0 = array([xbar, np.std(x, ddof=1, axis=0)])</div>
<div class="line"><span class="lineno"> 1924</span>        sol = optimize.fsolve(rootfunc, sol0, args=(x, N), xtol=1e-5)</div>
<div class="line"><span class="lineno"> 1925</span>        w = (y - sol[0]) / sol[1]</div>
<div class="line"><span class="lineno"> 1926</span>        logcdf = distributions.logistic.logcdf(w)</div>
<div class="line"><span class="lineno"> 1927</span>        logsf = distributions.logistic.logsf(w)</div>
<div class="line"><span class="lineno"> 1928</span>        sig = array([25, 10, 5, 2.5, 1, 0.5])</div>
<div class="line"><span class="lineno"> 1929</span>        critical = around(_Avals_logistic / (1.0 + 0.25/N), 3)</div>
<div class="line"><span class="lineno"> 1930</span>    <span class="keywordflow">elif</span> dist == <span class="stringliteral">&#39;gumbel_r&#39;</span>:</div>
<div class="line"><span class="lineno"> 1931</span>        xbar, s = distributions.gumbel_r.fit(x)</div>
<div class="line"><span class="lineno"> 1932</span>        w = (y - xbar) / s</div>
<div class="line"><span class="lineno"> 1933</span>        logcdf = distributions.gumbel_r.logcdf(w)</div>
<div class="line"><span class="lineno"> 1934</span>        logsf = distributions.gumbel_r.logsf(w)</div>
<div class="line"><span class="lineno"> 1935</span>        sig = array([25, 10, 5, 2.5, 1])</div>
<div class="line"><span class="lineno"> 1936</span>        critical = around(_Avals_gumbel / (1.0 + 0.2/sqrt(N)), 3)</div>
<div class="line"><span class="lineno"> 1937</span>    <span class="keywordflow">else</span>:  <span class="comment"># (dist == &#39;gumbel&#39;) or (dist == &#39;gumbel_l&#39;) or (dist == &#39;extreme1&#39;)</span></div>
<div class="line"><span class="lineno"> 1938</span>        xbar, s = distributions.gumbel_l.fit(x)</div>
<div class="line"><span class="lineno"> 1939</span>        w = (y - xbar) / s</div>
<div class="line"><span class="lineno"> 1940</span>        logcdf = distributions.gumbel_l.logcdf(w)</div>
<div class="line"><span class="lineno"> 1941</span>        logsf = distributions.gumbel_l.logsf(w)</div>
<div class="line"><span class="lineno"> 1942</span>        sig = array([25, 10, 5, 2.5, 1])</div>
<div class="line"><span class="lineno"> 1943</span>        critical = around(_Avals_gumbel / (1.0 + 0.2/sqrt(N)), 3)</div>
<div class="line"><span class="lineno"> 1944</span> </div>
<div class="line"><span class="lineno"> 1945</span>    i = arange(1, N + 1)</div>
<div class="line"><span class="lineno"> 1946</span>    A2 = -N - np.sum((2*i - 1.0) / N * (logcdf + logsf[::-1]), axis=0)</div>
<div class="line"><span class="lineno"> 1947</span> </div>
<div class="line"><span class="lineno"> 1948</span>    <span class="keywordflow">return</span> AndersonResult(A2, critical, sig)</div>
<div class="line"><span class="lineno"> 1949</span> </div>
<div class="line"><span class="lineno"> 1950</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af79e4786d193296d8337d4d138fde02b" name="af79e4786d193296d8337d4d138fde02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e4786d193296d8337d4d138fde02b">&#9670;&#160;</a></span>anderson_ksamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.anderson_ksamp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>midrank</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The Anderson-Darling test for k-samples.

The k-sample Anderson-Darling test is a modification of the
one-sample Anderson-Darling test. It tests the null hypothesis
that k-samples are drawn from the same population without having
to specify the distribution function of that population. The
critical values depend on the number of samples.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample data in arrays.
midrank : bool, optional
    Type of Anderson-Darling test which is computed. Default
    (True) is the midrank test applicable to continuous and
    discrete populations. If False, the right side empirical
    distribution is used.

Returns
-------
statistic : float
    Normalized k-sample Anderson-Darling test statistic.
critical_values : array
    The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%,
    0.5%, 0.1%.
significance_level : float
    An approximate significance level at which the null hypothesis for the
    provided samples can be rejected. The value is floored / capped at
    0.1% / 25%.

Raises
------
ValueError
    If less than 2 samples are provided, a sample is empty, or no
    distinct observations are in the samples.

See Also
--------
ks_2samp : 2 sample Kolmogorov-Smirnov test
anderson : 1 sample Anderson-Darling test

Notes
-----
[1]_ defines three versions of the k-sample Anderson-Darling test:
one for continuous distributions and two for discrete
distributions, in which ties between samples may occur. The
default of this routine is to compute the version based on the
midrank empirical distribution function. This test is applicable
to continuous and discrete data. If midrank is set to False, the
right side empirical distribution is used for a test for discrete
data. According to [1]_, the two discrete test statistics differ
only slightly if a few collisions due to round-off errors occur in
the test not adjusted for ties between samples.

The critical values corresponding to the significance levels from 0.01
to 0.25 are taken from [1]_. p-values are floored / capped
at 0.1% / 25%. Since the range of critical values might be extended in
future releases, it is recommended not to test ``p == 0.25``, but rather
``p &gt;= 0.25`` (analogously for the lower bound).

.. versionadded:: 0.14.0

References
----------
.. [1] Scholz, F. W and Stephens, M. A. (1987), K-Sample
       Anderson-Darling Tests, Journal of the American Statistical
       Association, Vol. 82, pp. 918-924.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()

The null hypothesis that the two random samples come from the same
distribution can be rejected at the 5% level because the returned
test value is greater than the critical value for 5% (1.961) but
not at the 2.5% level. The interpolation gives an approximate
significance level of 3.2%:

&gt;&gt;&gt; stats.anderson_ksamp([rng.normal(size=50),
... rng.normal(loc=0.5, size=30)])
(1.974403288713695,
  array([0.325, 1.226, 1.961, 2.718, 3.752, 4.592, 6.546]),
  0.04991293614572478)


The null hypothesis cannot be rejected for three samples from an
identical distribution. The reported p-value (25%) has been capped and
may not be very accurate (since it corresponds to the value 0.449
whereas the statistic is -0.731):

&gt;&gt;&gt; stats.anderson_ksamp([rng.normal(size=50),
... rng.normal(size=30), rng.normal(size=20)])
(-0.29103725200789504,
  array([ 0.44925884,  1.3052767 ,  1.9434184 ,  2.57696569,  3.41634856,
  4.07210043, 5.56419101]),
  0.25)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2035</span><span class="keyword">def </span>anderson_ksamp(samples, midrank=True):</div>
<div class="line"><span class="lineno"> 2036</span>    <span class="stringliteral">&quot;&quot;&quot;The Anderson-Darling test for k-samples.</span></div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral">    The k-sample Anderson-Darling test is a modification of the</span></div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">    one-sample Anderson-Darling test. It tests the null hypothesis</span></div>
<div class="line"><span class="lineno"> 2040</span><span class="stringliteral">    that k-samples are drawn from the same population without having</span></div>
<div class="line"><span class="lineno"> 2041</span><span class="stringliteral">    to specify the distribution function of that population. The</span></div>
<div class="line"><span class="lineno"> 2042</span><span class="stringliteral">    critical values depend on the number of samples.</span></div>
<div class="line"><span class="lineno"> 2043</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2044</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2045</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2046</span><span class="stringliteral">    samples : sequence of 1-D array_like</span></div>
<div class="line"><span class="lineno"> 2047</span><span class="stringliteral">        Array of sample data in arrays.</span></div>
<div class="line"><span class="lineno"> 2048</span><span class="stringliteral">    midrank : bool, optional</span></div>
<div class="line"><span class="lineno"> 2049</span><span class="stringliteral">        Type of Anderson-Darling test which is computed. Default</span></div>
<div class="line"><span class="lineno"> 2050</span><span class="stringliteral">        (True) is the midrank test applicable to continuous and</span></div>
<div class="line"><span class="lineno"> 2051</span><span class="stringliteral">        discrete populations. If False, the right side empirical</span></div>
<div class="line"><span class="lineno"> 2052</span><span class="stringliteral">        distribution is used.</span></div>
<div class="line"><span class="lineno"> 2053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2054</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2055</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2056</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 2057</span><span class="stringliteral">        Normalized k-sample Anderson-Darling test statistic.</span></div>
<div class="line"><span class="lineno"> 2058</span><span class="stringliteral">    critical_values : array</span></div>
<div class="line"><span class="lineno"> 2059</span><span class="stringliteral">        The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%,</span></div>
<div class="line"><span class="lineno"> 2060</span><span class="stringliteral">        0.5%, 0.1%.</span></div>
<div class="line"><span class="lineno"> 2061</span><span class="stringliteral">    significance_level : float</span></div>
<div class="line"><span class="lineno"> 2062</span><span class="stringliteral">        An approximate significance level at which the null hypothesis for the</span></div>
<div class="line"><span class="lineno"> 2063</span><span class="stringliteral">        provided samples can be rejected. The value is floored / capped at</span></div>
<div class="line"><span class="lineno"> 2064</span><span class="stringliteral">        0.1% / 25%.</span></div>
<div class="line"><span class="lineno"> 2065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2066</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 2067</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 2068</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 2069</span><span class="stringliteral">        If less than 2 samples are provided, a sample is empty, or no</span></div>
<div class="line"><span class="lineno"> 2070</span><span class="stringliteral">        distinct observations are in the samples.</span></div>
<div class="line"><span class="lineno"> 2071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2072</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2073</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2074</span><span class="stringliteral">    ks_2samp : 2 sample Kolmogorov-Smirnov test</span></div>
<div class="line"><span class="lineno"> 2075</span><span class="stringliteral">    anderson : 1 sample Anderson-Darling test</span></div>
<div class="line"><span class="lineno"> 2076</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2077</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2078</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2079</span><span class="stringliteral">    [1]_ defines three versions of the k-sample Anderson-Darling test:</span></div>
<div class="line"><span class="lineno"> 2080</span><span class="stringliteral">    one for continuous distributions and two for discrete</span></div>
<div class="line"><span class="lineno"> 2081</span><span class="stringliteral">    distributions, in which ties between samples may occur. The</span></div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">    default of this routine is to compute the version based on the</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral">    midrank empirical distribution function. This test is applicable</span></div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">    to continuous and discrete data. If midrank is set to False, the</span></div>
<div class="line"><span class="lineno"> 2085</span><span class="stringliteral">    right side empirical distribution is used for a test for discrete</span></div>
<div class="line"><span class="lineno"> 2086</span><span class="stringliteral">    data. According to [1]_, the two discrete test statistics differ</span></div>
<div class="line"><span class="lineno"> 2087</span><span class="stringliteral">    only slightly if a few collisions due to round-off errors occur in</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral">    the test not adjusted for ties between samples.</span></div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral">    The critical values corresponding to the significance levels from 0.01</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">    to 0.25 are taken from [1]_. p-values are floored / capped</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral">    at 0.1% / 25%. Since the range of critical values might be extended in</span></div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">    future releases, it is recommended not to test ``p == 0.25``, but rather</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">    ``p &gt;= 0.25`` (analogously for the lower bound).</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral">    .. versionadded:: 0.14.0</span></div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">    .. [1] Scholz, F. W and Stephens, M. A. (1987), K-Sample</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">           Anderson-Darling Tests, Journal of the American Statistical</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral">           Association, Vol. 82, pp. 918-924.</span></div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">    The null hypothesis that the two random samples come from the same</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral">    distribution can be rejected at the 5% level because the returned</span></div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">    test value is greater than the critical value for 5% (1.961) but</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">    not at the 2.5% level. The interpolation gives an approximate</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">    significance level of 3.2%:</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">    &gt;&gt;&gt; stats.anderson_ksamp([rng.normal(size=50),</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral">    ... rng.normal(loc=0.5, size=30)])</span></div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">    (1.974403288713695,</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">      array([0.325, 1.226, 1.961, 2.718, 3.752, 4.592, 6.546]),</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral">      0.04991293614572478)</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral">    The null hypothesis cannot be rejected for three samples from an</span></div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">    identical distribution. The reported p-value (25%) has been capped and</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral">    may not be very accurate (since it corresponds to the value 0.449</span></div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral">    whereas the statistic is -0.731):</span></div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral">    &gt;&gt;&gt; stats.anderson_ksamp([rng.normal(size=50),</span></div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral">    ... rng.normal(size=30), rng.normal(size=20)])</span></div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">    (-0.29103725200789504,</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral">      array([ 0.44925884,  1.3052767 ,  1.9434184 ,  2.57696569,  3.41634856,</span></div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral">      4.07210043, 5.56419101]),</span></div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral">      0.25)</span></div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2135</span>    k = len(samples)</div>
<div class="line"><span class="lineno"> 2136</span>    <span class="keywordflow">if</span> (k &lt; 2):</div>
<div class="line"><span class="lineno"> 2137</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;anderson_ksamp needs at least two samples&quot;</span>)</div>
<div class="line"><span class="lineno"> 2138</span> </div>
<div class="line"><span class="lineno"> 2139</span>    samples = list(map(np.asarray, samples))</div>
<div class="line"><span class="lineno"> 2140</span>    Z = np.sort(np.hstack(samples))</div>
<div class="line"><span class="lineno"> 2141</span>    N = Z.size</div>
<div class="line"><span class="lineno"> 2142</span>    Zstar = np.unique(Z)</div>
<div class="line"><span class="lineno"> 2143</span>    <span class="keywordflow">if</span> Zstar.size &lt; 2:</div>
<div class="line"><span class="lineno"> 2144</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;anderson_ksamp needs more than one distinct &quot;</span></div>
<div class="line"><span class="lineno"> 2145</span>                         <span class="stringliteral">&quot;observation&quot;</span>)</div>
<div class="line"><span class="lineno"> 2146</span> </div>
<div class="line"><span class="lineno"> 2147</span>    n = np.array([sample.size <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples])</div>
<div class="line"><span class="lineno"> 2148</span>    <span class="keywordflow">if</span> np.any(n == 0):</div>
<div class="line"><span class="lineno"> 2149</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;anderson_ksamp encountered sample without &quot;</span></div>
<div class="line"><span class="lineno"> 2150</span>                         <span class="stringliteral">&quot;observations&quot;</span>)</div>
<div class="line"><span class="lineno"> 2151</span> </div>
<div class="line"><span class="lineno"> 2152</span>    <span class="keywordflow">if</span> midrank:</div>
<div class="line"><span class="lineno"> 2153</span>        A2kN = _anderson_ksamp_midrank(samples, Z, Zstar, k, n, N)</div>
<div class="line"><span class="lineno"> 2154</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2155</span>        A2kN = _anderson_ksamp_right(samples, Z, Zstar, k, n, N)</div>
<div class="line"><span class="lineno"> 2156</span> </div>
<div class="line"><span class="lineno"> 2157</span>    H = (1. / n).sum()</div>
<div class="line"><span class="lineno"> 2158</span>    hs_cs = (1. / arange(N - 1, 1, -1)).cumsum()</div>
<div class="line"><span class="lineno"> 2159</span>    h = hs_cs[-1] + 1</div>
<div class="line"><span class="lineno"> 2160</span>    g = (hs_cs / arange(2, N)).sum()</div>
<div class="line"><span class="lineno"> 2161</span> </div>
<div class="line"><span class="lineno"> 2162</span>    a = (4*g - 6) * (k - 1) + (10 - 6*g)*H</div>
<div class="line"><span class="lineno"> 2163</span>    b = (2*g - 4)*k**2 + 8*h*k + (2*g - 14*h - 4)*H - 8*h + 4*g - 6</div>
<div class="line"><span class="lineno"> 2164</span>    c = (6*h + 2*g - 2)*k**2 + (4*h - 4*g + 6)*k + (2*h - 6)*H + 4*h</div>
<div class="line"><span class="lineno"> 2165</span>    d = (2*h + 6)*k**2 - 4*h*k</div>
<div class="line"><span class="lineno"> 2166</span>    sigmasq = (a*N**3 + b*N**2 + c*N + d) / ((N - 1.) * (N - 2.) * (N - 3.))</div>
<div class="line"><span class="lineno"> 2167</span>    m = k - 1</div>
<div class="line"><span class="lineno"> 2168</span>    A2 = (A2kN - m) / math.sqrt(sigmasq)</div>
<div class="line"><span class="lineno"> 2169</span> </div>
<div class="line"><span class="lineno"> 2170</span>    <span class="comment"># The b_i values are the interpolation coefficients from Table 2</span></div>
<div class="line"><span class="lineno"> 2171</span>    <span class="comment"># of Scholz and Stephens 1987</span></div>
<div class="line"><span class="lineno"> 2172</span>    b0 = np.array([0.675, 1.281, 1.645, 1.96, 2.326, 2.573, 3.085])</div>
<div class="line"><span class="lineno"> 2173</span>    b1 = np.array([-0.245, 0.25, 0.678, 1.149, 1.822, 2.364, 3.615])</div>
<div class="line"><span class="lineno"> 2174</span>    b2 = np.array([-0.105, -0.305, -0.362, -0.391, -0.396, -0.345, -0.154])</div>
<div class="line"><span class="lineno"> 2175</span>    critical = b0 + b1 / math.sqrt(m) + b2 / m</div>
<div class="line"><span class="lineno"> 2176</span> </div>
<div class="line"><span class="lineno"> 2177</span>    sig = np.array([0.25, 0.1, 0.05, 0.025, 0.01, 0.005, 0.001])</div>
<div class="line"><span class="lineno"> 2178</span>    <span class="keywordflow">if</span> A2 &lt; critical.min():</div>
<div class="line"><span class="lineno"> 2179</span>        p = sig.max()</div>
<div class="line"><span class="lineno"> 2180</span>        warnings.warn(<span class="stringliteral">&quot;p-value capped: true value larger than {}&quot;</span>.format(p),</div>
<div class="line"><span class="lineno"> 2181</span>                      stacklevel=2)</div>
<div class="line"><span class="lineno"> 2182</span>    <span class="keywordflow">elif</span> A2 &gt; critical.max():</div>
<div class="line"><span class="lineno"> 2183</span>        p = sig.min()</div>
<div class="line"><span class="lineno"> 2184</span>        warnings.warn(<span class="stringliteral">&quot;p-value floored: true value smaller than {}&quot;</span>.format(p),</div>
<div class="line"><span class="lineno"> 2185</span>                      stacklevel=2)</div>
<div class="line"><span class="lineno"> 2186</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2187</span>        <span class="comment"># interpolation of probit of significance level</span></div>
<div class="line"><span class="lineno"> 2188</span>        pf = np.polyfit(critical, log(sig), 2)</div>
<div class="line"><span class="lineno"> 2189</span>        p = math.exp(np.polyval(pf, A2))</div>
<div class="line"><span class="lineno"> 2190</span> </div>
<div class="line"><span class="lineno"> 2191</span>    <span class="keywordflow">return</span> Anderson_ksampResult(A2, critical, p)</div>
<div class="line"><span class="lineno"> 2192</span> </div>
<div class="line"><span class="lineno"> 2193</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5cf0b043d4a34d9afcc7b63c4d80757e" name="a5cf0b043d4a34d9afcc7b63c4d80757e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf0b043d4a34d9afcc7b63c4d80757e">&#9670;&#160;</a></span>ansari()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ansari </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the Ansari-Bradley test for equal scale parameters.

The Ansari-Bradley test ([1]_, [2]_) is a non-parametric test
for the equality of the scale parameter of the distributions
from which two samples were drawn. The null hypothesis states that
the ratio of the scale of the distribution underlying `x` to the scale
of the distribution underlying `y` is 1.

Parameters
----------
x, y : array_like
    Arrays of sample data.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the ratio of scales is not equal to 1.
    * 'less': the ratio of scales is less than 1.
    * 'greater': the ratio of scales is greater than 1.

    .. versionadded:: 1.7.0

Returns
-------
statistic : float
    The Ansari-Bradley test statistic.
pvalue : float
    The p-value of the hypothesis test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
mood : A non-parametric test for the equality of two scale parameters

Notes
-----
The p-value given is exact when the sample sizes are both less than
55 and there are no ties, otherwise a normal approximation for the
p-value is used.

References
----------
.. [1] Ansari, A. R. and Bradley, R. A. (1960) Rank-sum tests for
       dispersions, Annals of Mathematical Statistics, 31, 1174-1189.
.. [2] Sprent, Peter and N.C. Smeeton.  Applied nonparametric
       statistical methods.  3rd ed. Chapman and Hall/CRC. 2001.
       Section 5.8.2.
.. [3] Nathaniel E. Helwig "Nonparametric Dispersion and Equality
       Tests" at http://users.stat.umn.edu/~helwig/notes/npde-Notes.pdf

Examples
--------
&gt;&gt;&gt; from scipy.stats import ansari
&gt;&gt;&gt; rng = np.random.default_rng()

For these examples, we'll create three random data sets.  The first
two, with sizes 35 and 25, are drawn from a normal distribution with
mean 0 and standard deviation 2.  The third data set has size 25 and
is drawn from a normal distribution with standard deviation 1.25.

&gt;&gt;&gt; x1 = rng.normal(loc=0, scale=2, size=35)
&gt;&gt;&gt; x2 = rng.normal(loc=0, scale=2, size=25)
&gt;&gt;&gt; x3 = rng.normal(loc=0, scale=1.25, size=25)

First we apply `ansari` to `x1` and `x2`.  These samples are drawn
from the same distribution, so we expect the Ansari-Bradley test
should not lead us to conclude that the scales of the distributions
are different.

&gt;&gt;&gt; ansari(x1, x2)
AnsariResult(statistic=541.0, pvalue=0.9762532927399098)

With a p-value close to 1, we cannot conclude that there is a
significant difference in the scales (as expected).

Now apply the test to `x1` and `x3`:

&gt;&gt;&gt; ansari(x1, x3)
AnsariResult(statistic=425.0, pvalue=0.0003087020407974518)

The probability of observing such an extreme value of the statistic
under the null hypothesis of equal scales is only 0.03087%. We take this
as evidence against the null hypothesis in favor of the alternative:
the scales of the distributions from which the samples were drawn
are not equal.

We can use the `alternative` parameter to perform a one-tailed test.
In the above example, the scale of `x1` is greater than `x3` and so
the ratio of scales of `x1` and `x3` is greater than 1. This means
that the p-value when ``alternative='greater'`` should be near 0 and
hence we should be able to reject the null hypothesis:

&gt;&gt;&gt; ansari(x1, x3, alternative='greater')
AnsariResult(statistic=425.0, pvalue=0.0001543510203987259)

As we can see, the p-value is indeed quite low. Use of
``alternative='less'`` should thus yield a large p-value:

&gt;&gt;&gt; ansari(x1, x3, alternative='less')
AnsariResult(statistic=425.0, pvalue=0.9998643258449039)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2255</span><span class="keyword">def </span>ansari(x, y, alternative=&#39;two-sided&#39;):</div>
<div class="line"><span class="lineno"> 2256</span>    <span class="stringliteral">&quot;&quot;&quot;Perform the Ansari-Bradley test for equal scale parameters.</span></div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">    The Ansari-Bradley test ([1]_, [2]_) is a non-parametric test</span></div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral">    for the equality of the scale parameter of the distributions</span></div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">    from which two samples were drawn. The null hypothesis states that</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral">    the ratio of the scale of the distribution underlying `x` to the scale</span></div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral">    of the distribution underlying `y` is 1.</span></div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2265</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2266</span><span class="stringliteral">    x, y : array_like</span></div>
<div class="line"><span class="lineno"> 2267</span><span class="stringliteral">        Arrays of sample data.</span></div>
<div class="line"><span class="lineno"> 2268</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2269</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 2270</span><span class="stringliteral">        The following options are available:</span></div>
<div class="line"><span class="lineno"> 2271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2272</span><span class="stringliteral">        * &#39;two-sided&#39;: the ratio of scales is not equal to 1.</span></div>
<div class="line"><span class="lineno"> 2273</span><span class="stringliteral">        * &#39;less&#39;: the ratio of scales is less than 1.</span></div>
<div class="line"><span class="lineno"> 2274</span><span class="stringliteral">        * &#39;greater&#39;: the ratio of scales is greater than 1.</span></div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2276</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2278</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2279</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2280</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 2281</span><span class="stringliteral">        The Ansari-Bradley test statistic.</span></div>
<div class="line"><span class="lineno"> 2282</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 2283</span><span class="stringliteral">        The p-value of the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 2284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2285</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2286</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2287</span><span class="stringliteral">    fligner : A non-parametric test for the equality of k variances</span></div>
<div class="line"><span class="lineno"> 2288</span><span class="stringliteral">    mood : A non-parametric test for the equality of two scale parameters</span></div>
<div class="line"><span class="lineno"> 2289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2290</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2291</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2292</span><span class="stringliteral">    The p-value given is exact when the sample sizes are both less than</span></div>
<div class="line"><span class="lineno"> 2293</span><span class="stringliteral">    55 and there are no ties, otherwise a normal approximation for the</span></div>
<div class="line"><span class="lineno"> 2294</span><span class="stringliteral">    p-value is used.</span></div>
<div class="line"><span class="lineno"> 2295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2296</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2297</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2298</span><span class="stringliteral">    .. [1] Ansari, A. R. and Bradley, R. A. (1960) Rank-sum tests for</span></div>
<div class="line"><span class="lineno"> 2299</span><span class="stringliteral">           dispersions, Annals of Mathematical Statistics, 31, 1174-1189.</span></div>
<div class="line"><span class="lineno"> 2300</span><span class="stringliteral">    .. [2] Sprent, Peter and N.C. Smeeton.  Applied nonparametric</span></div>
<div class="line"><span class="lineno"> 2301</span><span class="stringliteral">           statistical methods.  3rd ed. Chapman and Hall/CRC. 2001.</span></div>
<div class="line"><span class="lineno"> 2302</span><span class="stringliteral">           Section 5.8.2.</span></div>
<div class="line"><span class="lineno"> 2303</span><span class="stringliteral">    .. [3] Nathaniel E. Helwig &quot;Nonparametric Dispersion and Equality</span></div>
<div class="line"><span class="lineno"> 2304</span><span class="stringliteral">           Tests&quot; at http://users.stat.umn.edu/~helwig/notes/npde-Notes.pdf</span></div>
<div class="line"><span class="lineno"> 2305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2306</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2307</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2308</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import ansari</span></div>
<div class="line"><span class="lineno"> 2309</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 2310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2311</span><span class="stringliteral">    For these examples, we&#39;ll create three random data sets.  The first</span></div>
<div class="line"><span class="lineno"> 2312</span><span class="stringliteral">    two, with sizes 35 and 25, are drawn from a normal distribution with</span></div>
<div class="line"><span class="lineno"> 2313</span><span class="stringliteral">    mean 0 and standard deviation 2.  The third data set has size 25 and</span></div>
<div class="line"><span class="lineno"> 2314</span><span class="stringliteral">    is drawn from a normal distribution with standard deviation 1.25.</span></div>
<div class="line"><span class="lineno"> 2315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2316</span><span class="stringliteral">    &gt;&gt;&gt; x1 = rng.normal(loc=0, scale=2, size=35)</span></div>
<div class="line"><span class="lineno"> 2317</span><span class="stringliteral">    &gt;&gt;&gt; x2 = rng.normal(loc=0, scale=2, size=25)</span></div>
<div class="line"><span class="lineno"> 2318</span><span class="stringliteral">    &gt;&gt;&gt; x3 = rng.normal(loc=0, scale=1.25, size=25)</span></div>
<div class="line"><span class="lineno"> 2319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2320</span><span class="stringliteral">    First we apply `ansari` to `x1` and `x2`.  These samples are drawn</span></div>
<div class="line"><span class="lineno"> 2321</span><span class="stringliteral">    from the same distribution, so we expect the Ansari-Bradley test</span></div>
<div class="line"><span class="lineno"> 2322</span><span class="stringliteral">    should not lead us to conclude that the scales of the distributions</span></div>
<div class="line"><span class="lineno"> 2323</span><span class="stringliteral">    are different.</span></div>
<div class="line"><span class="lineno"> 2324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2325</span><span class="stringliteral">    &gt;&gt;&gt; ansari(x1, x2)</span></div>
<div class="line"><span class="lineno"> 2326</span><span class="stringliteral">    AnsariResult(statistic=541.0, pvalue=0.9762532927399098)</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2328</span><span class="stringliteral">    With a p-value close to 1, we cannot conclude that there is a</span></div>
<div class="line"><span class="lineno"> 2329</span><span class="stringliteral">    significant difference in the scales (as expected).</span></div>
<div class="line"><span class="lineno"> 2330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2331</span><span class="stringliteral">    Now apply the test to `x1` and `x3`:</span></div>
<div class="line"><span class="lineno"> 2332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2333</span><span class="stringliteral">    &gt;&gt;&gt; ansari(x1, x3)</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral">    AnsariResult(statistic=425.0, pvalue=0.0003087020407974518)</span></div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">    The probability of observing such an extreme value of the statistic</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral">    under the null hypothesis of equal scales is only 0.03087%. We take this</span></div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral">    as evidence against the null hypothesis in favor of the alternative:</span></div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral">    the scales of the distributions from which the samples were drawn</span></div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral">    are not equal.</span></div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral">    We can use the `alternative` parameter to perform a one-tailed test.</span></div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral">    In the above example, the scale of `x1` is greater than `x3` and so</span></div>
<div class="line"><span class="lineno"> 2344</span><span class="stringliteral">    the ratio of scales of `x1` and `x3` is greater than 1. This means</span></div>
<div class="line"><span class="lineno"> 2345</span><span class="stringliteral">    that the p-value when ``alternative=&#39;greater&#39;`` should be near 0 and</span></div>
<div class="line"><span class="lineno"> 2346</span><span class="stringliteral">    hence we should be able to reject the null hypothesis:</span></div>
<div class="line"><span class="lineno"> 2347</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2348</span><span class="stringliteral">    &gt;&gt;&gt; ansari(x1, x3, alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 2349</span><span class="stringliteral">    AnsariResult(statistic=425.0, pvalue=0.0001543510203987259)</span></div>
<div class="line"><span class="lineno"> 2350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2351</span><span class="stringliteral">    As we can see, the p-value is indeed quite low. Use of</span></div>
<div class="line"><span class="lineno"> 2352</span><span class="stringliteral">    ``alternative=&#39;less&#39;`` should thus yield a large p-value:</span></div>
<div class="line"><span class="lineno"> 2353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2354</span><span class="stringliteral">    &gt;&gt;&gt; ansari(x1, x3, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 2355</span><span class="stringliteral">    AnsariResult(statistic=425.0, pvalue=0.9998643258449039)</span></div>
<div class="line"><span class="lineno"> 2356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2357</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2358</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>}:</div>
<div class="line"><span class="lineno"> 2359</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;alternative&#39; must be &#39;two-sided&#39;,&quot;</span></div>
<div class="line"><span class="lineno"> 2360</span>                         <span class="stringliteral">&quot; &#39;greater&#39;, or &#39;less&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2361</span>    x, y = asarray(x), asarray(y)</div>
<div class="line"><span class="lineno"> 2362</span>    n = len(x)</div>
<div class="line"><span class="lineno"> 2363</span>    m = len(y)</div>
<div class="line"><span class="lineno"> 2364</span>    <span class="keywordflow">if</span> m &lt; 1:</div>
<div class="line"><span class="lineno"> 2365</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Not enough other observations.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2366</span>    <span class="keywordflow">if</span> n &lt; 1:</div>
<div class="line"><span class="lineno"> 2367</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Not enough test observations.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2368</span> </div>
<div class="line"><span class="lineno"> 2369</span>    N = m + n</div>
<div class="line"><span class="lineno"> 2370</span>    xy = r_[x, y]  <span class="comment"># combine</span></div>
<div class="line"><span class="lineno"> 2371</span>    rank = _stats_py.rankdata(xy)</div>
<div class="line"><span class="lineno"> 2372</span>    symrank = amin(array((rank, N - rank + 1)), 0)</div>
<div class="line"><span class="lineno"> 2373</span>    AB = np.sum(symrank[:n], axis=0)</div>
<div class="line"><span class="lineno"> 2374</span>    uxy = unique(xy)</div>
<div class="line"><span class="lineno"> 2375</span>    repeats = (len(uxy) != len(xy))</div>
<div class="line"><span class="lineno"> 2376</span>    exact = ((m &lt; 55) <span class="keywordflow">and</span> (n &lt; 55) <span class="keywordflow">and</span> <span class="keywordflow">not</span> repeats)</div>
<div class="line"><span class="lineno"> 2377</span>    <span class="keywordflow">if</span> repeats <span class="keywordflow">and</span> (m &lt; 55 <span class="keywordflow">or</span> n &lt; 55):</div>
<div class="line"><span class="lineno"> 2378</span>        warnings.warn(<span class="stringliteral">&quot;Ties preclude use of exact statistic.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2379</span>    <span class="keywordflow">if</span> exact:</div>
<div class="line"><span class="lineno"> 2380</span>        <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;two-sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 2381</span>            pval = 2.0 * np.minimum(_abw_state.cdf(AB, n, m),</div>
<div class="line"><span class="lineno"> 2382</span>                                    _abw_state.sf(AB, n, m))</div>
<div class="line"><span class="lineno"> 2383</span>        <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;greater&#39;</span>:</div>
<div class="line"><span class="lineno"> 2384</span>            <span class="comment"># AB statistic is _smaller_ when ratio of scales is larger,</span></div>
<div class="line"><span class="lineno"> 2385</span>            <span class="comment"># so this is the opposite of the usual calculation</span></div>
<div class="line"><span class="lineno"> 2386</span>            pval = _abw_state.cdf(AB, n, m)</div>
<div class="line"><span class="lineno"> 2387</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2388</span>            pval = _abw_state.sf(AB, n, m)</div>
<div class="line"><span class="lineno"> 2389</span>        <span class="keywordflow">return</span> AnsariResult(AB, min(1.0, pval))</div>
<div class="line"><span class="lineno"> 2390</span> </div>
<div class="line"><span class="lineno"> 2391</span>    <span class="comment"># otherwise compute normal approximation</span></div>
<div class="line"><span class="lineno"> 2392</span>    <span class="keywordflow">if</span> N % 2:  <span class="comment"># N odd</span></div>
<div class="line"><span class="lineno"> 2393</span>        mnAB = n * (N+1.0)**2 / 4.0 / N</div>
<div class="line"><span class="lineno"> 2394</span>        varAB = n * m * (N+1.0) * (3+N**2) / (48.0 * N**2)</div>
<div class="line"><span class="lineno"> 2395</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2396</span>        mnAB = n * (N+2.0) / 4.0</div>
<div class="line"><span class="lineno"> 2397</span>        varAB = m * n * (N+2) * (N-2.0) / 48 / (N-1.0)</div>
<div class="line"><span class="lineno"> 2398</span>    <span class="keywordflow">if</span> repeats:   <span class="comment"># adjust variance estimates</span></div>
<div class="line"><span class="lineno"> 2399</span>        <span class="comment"># compute np.sum(tj * rj**2,axis=0)</span></div>
<div class="line"><span class="lineno"> 2400</span>        fac = np.sum(symrank**2, axis=0)</div>
<div class="line"><span class="lineno"> 2401</span>        <span class="keywordflow">if</span> N % 2:  <span class="comment"># N odd</span></div>
<div class="line"><span class="lineno"> 2402</span>            varAB = m * n * (16*N*fac - (N+1)**4) / (16.0 * N**2 * (N-1))</div>
<div class="line"><span class="lineno"> 2403</span>        <span class="keywordflow">else</span>:  <span class="comment"># N even</span></div>
<div class="line"><span class="lineno"> 2404</span>            varAB = m * n * (16*fac - N*(N+2)**2) / (16.0 * N * (N-1))</div>
<div class="line"><span class="lineno"> 2405</span> </div>
<div class="line"><span class="lineno"> 2406</span>    <span class="comment"># Small values of AB indicate larger dispersion for the x sample.</span></div>
<div class="line"><span class="lineno"> 2407</span>    <span class="comment"># Large values of AB indicate larger dispersion for the y sample.</span></div>
<div class="line"><span class="lineno"> 2408</span>    <span class="comment"># This is opposite to the way we define the ratio of scales. see [1]_.</span></div>
<div class="line"><span class="lineno"> 2409</span>    z = (mnAB - AB) / sqrt(varAB)</div>
<div class="line"><span class="lineno"> 2410</span>    z, pval = _normtest_finish(z, alternative)</div>
<div class="line"><span class="lineno"> 2411</span>    <span class="keywordflow">return</span> AnsariResult(AB, pval)</div>
<div class="line"><span class="lineno"> 2412</span> </div>
<div class="line"><span class="lineno"> 2413</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a96ab9423e7e286b7c52654cf7333e897" name="a96ab9423e7e286b7c52654cf7333e897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ab9423e7e286b7c52654cf7333e897">&#9670;&#160;</a></span>bartlett()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.bartlett </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Bartlett's test for equal variances.

Bartlett's test tests the null hypothesis that all input samples
are from populations with equal variances.  For samples
from significantly non-normal populations, Levene's test
`levene` is more robust.

Parameters
----------
sample1, sample2, ... : array_like
    arrays of sample data.  Only 1d arrays are accepted, they may have
    different lengths.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value of the test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
levene : A robust parametric test for equality of k variances

Notes
-----
Conover et al. (1981) examine many of the existing parametric and
nonparametric tests by extensive simulations and they conclude that the
tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
superior in terms of robustness of departures from normality and power
([3]_).

References
----------
.. [1]  https://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm

.. [2]  Snedecor, George W. and Cochran, William G. (1989), Statistical
          Methods, Eighth Edition, Iowa State University Press.

.. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.

.. [4] Bartlett, M. S. (1937). Properties of Sufficiency and Statistical
       Tests. Proceedings of the Royal Society of London. Series A,
       Mathematical and Physical Sciences, Vol. 160, No.901, pp. 268-282.

Examples
--------
Test whether or not the lists `a`, `b` and `c` come from populations
with equal variances.

&gt;&gt;&gt; from scipy.stats import bartlett
&gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
&gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
&gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
&gt;&gt;&gt; stat, p = bartlett(a, b, c)
&gt;&gt;&gt; p
1.1254782518834628e-05

The very small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

&gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]</pre> <div class="fragment"><div class="line"><span class="lineno"> 2417</span><span class="keyword">def </span>bartlett(*samples):</div>
<div class="line"><span class="lineno"> 2418</span>    <span class="stringliteral">&quot;&quot;&quot;Perform Bartlett&#39;s test for equal variances.</span></div>
<div class="line"><span class="lineno"> 2419</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2420</span><span class="stringliteral">    Bartlett&#39;s test tests the null hypothesis that all input samples</span></div>
<div class="line"><span class="lineno"> 2421</span><span class="stringliteral">    are from populations with equal variances.  For samples</span></div>
<div class="line"><span class="lineno"> 2422</span><span class="stringliteral">    from significantly non-normal populations, Levene&#39;s test</span></div>
<div class="line"><span class="lineno"> 2423</span><span class="stringliteral">    `levene` is more robust.</span></div>
<div class="line"><span class="lineno"> 2424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2425</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2426</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2427</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 2428</span><span class="stringliteral">        arrays of sample data.  Only 1d arrays are accepted, they may have</span></div>
<div class="line"><span class="lineno"> 2429</span><span class="stringliteral">        different lengths.</span></div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">        The test statistic.</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">        The p-value of the test.</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral">    fligner : A non-parametric test for the equality of k variances</span></div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    levene : A robust parametric test for equality of k variances</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">    Conover et al. (1981) examine many of the existing parametric and</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral">    nonparametric tests by extensive simulations and they conclude that the</span></div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">    tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral">    superior in terms of robustness of departures from normality and power</span></div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">    ([3]_).</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">    .. [1]  https://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">    .. [2]  Snedecor, George W. and Cochran, William G. (1989), Statistical</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">              Methods, Eighth Edition, Iowa State University Press.</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">    .. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">           Hypothesis Testing based on Quadratic Inference Function. Technical</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral">           Report #99-03, Center for Likelihood Studies, Pennsylvania State</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">           University.</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral">    .. [4] Bartlett, M. S. (1937). Properties of Sufficiency and Statistical</span></div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">           Tests. Proceedings of the Royal Society of London. Series A,</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">           Mathematical and Physical Sciences, Vol. 160, No.901, pp. 268-282.</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">    Test whether or not the lists `a`, `b` and `c` come from populations</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral">    with equal variances.</span></div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import bartlett</span></div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">    &gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral">    &gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]</span></div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">    &gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">    &gt;&gt;&gt; stat, p = bartlett(a, b, c)</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">    1.1254782518834628e-05</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral">    The very small p-value suggests that the populations do not have equal</span></div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">    variances.</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">    This is not surprising, given that the sample variance of `b` is much</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">    larger than that of `a` and `c`:</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">    &gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    [0.007054444444444413, 0.13073888888888888, 0.008890000000000002]</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2490</span>    <span class="comment"># Handle empty input and input that is not 1d</span></div>
<div class="line"><span class="lineno"> 2491</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples:</div>
<div class="line"><span class="lineno"> 2492</span>        <span class="keywordflow">if</span> np.asanyarray(sample).size == 0:</div>
<div class="line"><span class="lineno"> 2493</span>            <span class="keywordflow">return</span> BartlettResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 2494</span>        <span class="keywordflow">if</span> np.asanyarray(sample).ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2495</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Samples must be one-dimensional.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2496</span> </div>
<div class="line"><span class="lineno"> 2497</span>    k = len(samples)</div>
<div class="line"><span class="lineno"> 2498</span>    <span class="keywordflow">if</span> k &lt; 2:</div>
<div class="line"><span class="lineno"> 2499</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Must enter at least two input sample vectors.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2500</span>    Ni = np.empty(k)</div>
<div class="line"><span class="lineno"> 2501</span>    ssq = np.empty(k, <span class="stringliteral">&#39;d&#39;</span>)</div>
<div class="line"><span class="lineno"> 2502</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 2503</span>        Ni[j] = len(samples[j])</div>
<div class="line"><span class="lineno"> 2504</span>        ssq[j] = np.var(samples[j], ddof=1)</div>
<div class="line"><span class="lineno"> 2505</span>    Ntot = np.sum(Ni, axis=0)</div>
<div class="line"><span class="lineno"> 2506</span>    spsq = np.sum((Ni - 1)*ssq, axis=0) / (1.0*(Ntot - k))</div>
<div class="line"><span class="lineno"> 2507</span>    numer = (Ntot*1.0 - k) * log(spsq) - np.sum((Ni - 1.0)*log(ssq), axis=0)</div>
<div class="line"><span class="lineno"> 2508</span>    denom = 1.0 + 1.0/(3*(k - 1)) * ((np.sum(1.0/(Ni - 1.0), axis=0)) -</div>
<div class="line"><span class="lineno"> 2509</span>                                     1.0/(Ntot - k))</div>
<div class="line"><span class="lineno"> 2510</span>    T = numer / denom</div>
<div class="line"><span class="lineno"> 2511</span>    pval = distributions.chi2.sf(T, k - 1)  <span class="comment"># 1 - cdf</span></div>
<div class="line"><span class="lineno"> 2512</span> </div>
<div class="line"><span class="lineno"> 2513</span>    <span class="keywordflow">return</span> BartlettResult(T, pval)</div>
<div class="line"><span class="lineno"> 2514</span> </div>
<div class="line"><span class="lineno"> 2515</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa18cb0ea658376fef0b14314b7681611" name="aa18cb0ea658376fef0b14314b7681611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18cb0ea658376fef0b14314b7681611">&#9670;&#160;</a></span>bayes_mvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.bayes_mvs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.90</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Bayesian confidence intervals for the mean, var, and std.

    Parameters
    ----------
    data : array_like
        Input data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.
        Requires 2 or more data points.
    alpha : float, optional
        Probability that the returned confidence interval contains
        the true parameter.

    Returns
    -------
    mean_cntr, var_cntr, std_cntr : tuple
        The three results are for the mean, variance and standard deviation,
        respectively.  Each result is a tuple of the form::

            (center, (lower, upper))

        with `center` the mean of the conditional pdf of the value given the
        data, and `(lower, upper)` a confidence interval, centered on the
        median, containing the estimate to a probability ``alpha``.

    See Also
    --------
    mvsdist

    Notes
    -----
    Each tuple of mean, variance, and standard deviation estimates represent
    the (center, (lower, upper)) with center the mean of the conditional pdf
    of the value given the data and (lower, upper) is a confidence interval
    centered on the median, containing the estimate to a probability
    ``alpha``.

    Converts data to 1-D and assumes all data has the same mean and variance.
    Uses Jeffrey's prior for variance and std.

    Equivalent to ``tuple((x.mean(), x.interval(alpha)) for x in mvsdist(dat))``

    References
    ----------
    T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
    standard-deviation from data", https://scholarsarchive.byu.edu/facpub/278,
    2006.

    Examples
    --------
    First a basic example to demonstrate the outputs:

    &gt;&gt;&gt; from scipy import stats
    &gt;&gt;&gt; data = [6, 9, 12, 7, 8, 8, 13]
    &gt;&gt;&gt; mean, var, std = stats.bayes_mvs(data)
    &gt;&gt;&gt; mean
    Mean(statistic=9.0, minmax=(7.103650222612533, 10.896349777387467))
    &gt;&gt;&gt; var
    Variance(statistic=10.0, minmax=(3.176724206..., 24.45910382...))
    &gt;&gt;&gt; std
    Std_dev(statistic=2.9724954732045084, minmax=(1.7823367265645143, 4.945614605014631))

    Now we generate some normally distributed random data, and get estimates of
    mean and standard deviation with 95% confidence intervals for those
    estimates:

    &gt;&gt;&gt; n_samples = 100000
    &gt;&gt;&gt; data = stats.norm.rvs(size=n_samples)
    &gt;&gt;&gt; res_mean, res_var, res_std = stats.bayes_mvs(data, alpha=0.95)

    &gt;&gt;&gt; import matplotlib.pyplot as plt
    &gt;&gt;&gt; fig = plt.figure()
    &gt;&gt;&gt; ax = fig.add_subplot(111)
    &gt;&gt;&gt; ax.hist(data, bins=100, density=True, label='Histogram of data')
    &gt;&gt;&gt; ax.vlines(res_mean.statistic, 0, 0.5, colors='r', label='Estimated mean')
    &gt;&gt;&gt; ax.axvspan(res_mean.minmax[0],res_mean.minmax[1], facecolor='r',
    ...            alpha=0.2, label=r'Estimated mean (95% limits)')
    &gt;&gt;&gt; ax.vlines(res_std.statistic, 0, 0.5, colors='g', label='Estimated scale')
    &gt;&gt;&gt; ax.axvspan(res_std.minmax[0],res_std.minmax[1], facecolor='g', alpha=0.2,
    ...            label=r'Estimated scale (95% limits)')

    &gt;&gt;&gt; ax.legend(fontsize=10)
    &gt;&gt;&gt; ax.set_xlim([-4, 4])
    &gt;&gt;&gt; ax.set_ylim([0, 0.5])
    &gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">   43</span><span class="keyword">def </span>bayes_mvs(data, alpha=0.90):</div>
<div class="line"><span class="lineno">   44</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    Bayesian confidence intervals for the mean, var, and std.</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        Input data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        Requires 2 or more data points.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    alpha : float, optional</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        Probability that the returned confidence interval contains</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        the true parameter.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    mean_cntr, var_cntr, std_cntr : tuple</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        The three results are for the mean, variance and standard deviation,</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        respectively.  Each result is a tuple of the form::</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">            (center, (lower, upper))</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">        with `center` the mean of the conditional pdf of the value given the</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        data, and `(lower, upper)` a confidence interval, centered on the</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        median, containing the estimate to a probability ``alpha``.</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    mvsdist</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    Each tuple of mean, variance, and standard deviation estimates represent</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    the (center, (lower, upper)) with center the mean of the conditional pdf</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    of the value given the data and (lower, upper) is a confidence interval</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    centered on the median, containing the estimate to a probability</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    ``alpha``.</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    Converts data to 1-D and assumes all data has the same mean and variance.</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    Uses Jeffrey&#39;s prior for variance and std.</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    Equivalent to ``tuple((x.mean(), x.interval(alpha)) for x in mvsdist(dat))``</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    T.E. Oliphant, &quot;A Bayesian perspective on estimating mean, variance, and</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    standard-deviation from data&quot;, https://scholarsarchive.byu.edu/facpub/278,</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    2006.</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    First a basic example to demonstrate the outputs:</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    &gt;&gt;&gt; data = [6, 9, 12, 7, 8, 8, 13]</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    &gt;&gt;&gt; mean, var, std = stats.bayes_mvs(data)</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    &gt;&gt;&gt; mean</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    Mean(statistic=9.0, minmax=(7.103650222612533, 10.896349777387467))</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    &gt;&gt;&gt; var</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    Variance(statistic=10.0, minmax=(3.176724206..., 24.45910382...))</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    &gt;&gt;&gt; std</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    Std_dev(statistic=2.9724954732045084, minmax=(1.7823367265645143, 4.945614605014631))</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    Now we generate some normally distributed random data, and get estimates of</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    mean and standard deviation with 95% confidence intervals for those</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    estimates:</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    &gt;&gt;&gt; n_samples = 100000</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    &gt;&gt;&gt; data = stats.norm.rvs(size=n_samples)</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    &gt;&gt;&gt; res_mean, res_var, res_std = stats.bayes_mvs(data, alpha=0.95)</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    &gt;&gt;&gt; ax.hist(data, bins=100, density=True, label=&#39;Histogram of data&#39;)</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &gt;&gt;&gt; ax.vlines(res_mean.statistic, 0, 0.5, colors=&#39;r&#39;, label=&#39;Estimated mean&#39;)</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvspan(res_mean.minmax[0],res_mean.minmax[1], facecolor=&#39;r&#39;,</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    ...            alpha=0.2, label=r&#39;Estimated mean (95% limits)&#39;)</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; ax.vlines(res_std.statistic, 0, 0.5, colors=&#39;g&#39;, label=&#39;Estimated scale&#39;)</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvspan(res_std.minmax[0],res_std.minmax[1], facecolor=&#39;g&#39;, alpha=0.2,</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    ...            label=r&#39;Estimated scale (95% limits)&#39;)</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &gt;&gt;&gt; ax.legend(fontsize=10)</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_xlim([-4, 4])</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_ylim([0, 0.5])</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  130</span>    m, v, s = mvsdist(data)</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">if</span> alpha &gt;= 1 <span class="keywordflow">or</span> alpha &lt;= 0:</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;0 &lt; alpha &lt; 1 is required, but alpha=%s was given.&quot;</span></div>
<div class="line"><span class="lineno">  133</span>                         % alpha)</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>    m_res = Mean(m.mean(), m.interval(alpha))</div>
<div class="line"><span class="lineno">  136</span>    v_res = Variance(v.mean(), v.interval(alpha))</div>
<div class="line"><span class="lineno">  137</span>    s_res = Std_dev(s.mean(), s.interval(alpha))</div>
<div class="line"><span class="lineno">  138</span> </div>
<div class="line"><span class="lineno">  139</span>    <span class="keywordflow">return</span> m_res, v_res, s_res</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9decd286dafd3e07427ade8321b3228c" name="a9decd286dafd3e07427ade8321b3228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9decd286dafd3e07427ade8321b3228c">&#9670;&#160;</a></span>binom_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.binom_test </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a test that the probability of success is p.

Note: `binom_test` is deprecated; it is recommended that `binomtest`
be used instead.

This is an exact, two-sided test of the null hypothesis
that the probability of success in a Bernoulli experiment
is `p`.

Parameters
----------
x : int or array_like
    The number of successes, or if x has length 2, it is the
    number of successes and the number of failures.
n : int
    The number of trials.  This is ignored if x gives both the
    number of successes and failures.
p : float, optional
    The hypothesized probability of success.  ``0 &lt;= p &lt;= 1``. The
    default value is ``p = 0.5``.
alternative : {'two-sided', 'greater', 'less'}, optional
    Indicates the alternative hypothesis. The default value is
    'two-sided'.

Returns
-------
p-value : float
    The p-value of the hypothesis test.

References
----------
.. [1] https://en.wikipedia.org/wiki/Binomial_test

Examples
--------
&gt;&gt;&gt; from scipy import stats

A car manufacturer claims that no more than 10% of their cars are unsafe.
15 cars are inspected for safety, 3 were found to be unsafe. Test the
manufacturer's claim:

&gt;&gt;&gt; stats.binom_test(3, n=15, p=0.1, alternative='greater')
0.18406106910639114

The null hypothesis cannot be rejected at the 5% level of significance
because the returned p-value is greater than the critical value of 5%.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2648</span><span class="keyword">def </span>binom_test(x, n=None, p=0.5, alternative=&#39;two-sided&#39;):</div>
<div class="line"><span class="lineno"> 2649</span>    <span class="stringliteral">&quot;&quot;&quot;Perform a test that the probability of success is p.</span></div>
<div class="line"><span class="lineno"> 2650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2651</span><span class="stringliteral">    Note: `binom_test` is deprecated; it is recommended that `binomtest`</span></div>
<div class="line"><span class="lineno"> 2652</span><span class="stringliteral">    be used instead.</span></div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral">    This is an exact, two-sided test of the null hypothesis</span></div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral">    that the probability of success in a Bernoulli experiment</span></div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral">    is `p`.</span></div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2658</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2659</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2660</span><span class="stringliteral">    x : int or array_like</span></div>
<div class="line"><span class="lineno"> 2661</span><span class="stringliteral">        The number of successes, or if x has length 2, it is the</span></div>
<div class="line"><span class="lineno"> 2662</span><span class="stringliteral">        number of successes and the number of failures.</span></div>
<div class="line"><span class="lineno"> 2663</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="stringliteral">        The number of trials.  This is ignored if x gives both the</span></div>
<div class="line"><span class="lineno"> 2665</span><span class="stringliteral">        number of successes and failures.</span></div>
<div class="line"><span class="lineno"> 2666</span><span class="stringliteral">    p : float, optional</span></div>
<div class="line"><span class="lineno"> 2667</span><span class="stringliteral">        The hypothesized probability of success.  ``0 &lt;= p &lt;= 1``. The</span></div>
<div class="line"><span class="lineno"> 2668</span><span class="stringliteral">        default value is ``p = 0.5``.</span></div>
<div class="line"><span class="lineno"> 2669</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;greater&#39;, &#39;less&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral">        Indicates the alternative hypothesis. The default value is</span></div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral">        &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">    p-value : float</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral">        The p-value of the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">    .. [1] https://en.wikipedia.org/wiki/Binomial_test</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral">    A car manufacturer claims that no more than 10% of their cars are unsafe.</span></div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral">    15 cars are inspected for safety, 3 were found to be unsafe. Test the</span></div>
<div class="line"><span class="lineno"> 2688</span><span class="stringliteral">    manufacturer&#39;s claim:</span></div>
<div class="line"><span class="lineno"> 2689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2690</span><span class="stringliteral">    &gt;&gt;&gt; stats.binom_test(3, n=15, p=0.1, alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 2691</span><span class="stringliteral">    0.18406106910639114</span></div>
<div class="line"><span class="lineno"> 2692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2693</span><span class="stringliteral">    The null hypothesis cannot be rejected at the 5% level of significance</span></div>
<div class="line"><span class="lineno"> 2694</span><span class="stringliteral">    because the returned p-value is greater than the critical value of 5%.</span></div>
<div class="line"><span class="lineno"> 2695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2696</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2697</span>    x = atleast_1d(x).astype(np.int_)</div>
<div class="line"><span class="lineno"> 2698</span>    <span class="keywordflow">if</span> len(x) == 2:</div>
<div class="line"><span class="lineno"> 2699</span>        n = x[1] + x[0]</div>
<div class="line"><span class="lineno"> 2700</span>        x = x[0]</div>
<div class="line"><span class="lineno"> 2701</span>    <span class="keywordflow">elif</span> len(x) == 1:</div>
<div class="line"><span class="lineno"> 2702</span>        x = x[0]</div>
<div class="line"><span class="lineno"> 2703</span>        <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> n &lt; x:</div>
<div class="line"><span class="lineno"> 2704</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;n must be &gt;= x&quot;</span>)</div>
<div class="line"><span class="lineno"> 2705</span>        n = np.int_(n)</div>
<div class="line"><span class="lineno"> 2706</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2707</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Incorrect length for x.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2708</span> </div>
<div class="line"><span class="lineno"> 2709</span>    <span class="keywordflow">if</span> (p &gt; 1.0) <span class="keywordflow">or</span> (p &lt; 0.0):</div>
<div class="line"><span class="lineno"> 2710</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;p must be in range [0,1]&quot;</span>)</div>
<div class="line"><span class="lineno"> 2711</span> </div>
<div class="line"><span class="lineno"> 2712</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>):</div>
<div class="line"><span class="lineno"> 2713</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;alternative not recognized\n&quot;</span></div>
<div class="line"><span class="lineno"> 2714</span>                         <span class="stringliteral">&quot;should be &#39;two-sided&#39;, &#39;less&#39; or &#39;greater&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 2715</span> </div>
<div class="line"><span class="lineno"> 2716</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;less&#39;</span>:</div>
<div class="line"><span class="lineno"> 2717</span>        pval = distributions.binom.cdf(x, n, p)</div>
<div class="line"><span class="lineno"> 2718</span>        <span class="keywordflow">return</span> pval</div>
<div class="line"><span class="lineno"> 2719</span> </div>
<div class="line"><span class="lineno"> 2720</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;greater&#39;</span>:</div>
<div class="line"><span class="lineno"> 2721</span>        pval = distributions.binom.sf(x-1, n, p)</div>
<div class="line"><span class="lineno"> 2722</span>        <span class="keywordflow">return</span> pval</div>
<div class="line"><span class="lineno"> 2723</span> </div>
<div class="line"><span class="lineno"> 2724</span>    <span class="comment"># if alternative was neither &#39;less&#39; nor &#39;greater&#39;, then it&#39;s &#39;two-sided&#39;</span></div>
<div class="line"><span class="lineno"> 2725</span>    d = distributions.binom.pmf(x, n, p)</div>
<div class="line"><span class="lineno"> 2726</span>    rerr = 1 + 1e-7</div>
<div class="line"><span class="lineno"> 2727</span>    <span class="keywordflow">if</span> x == p * n:</div>
<div class="line"><span class="lineno"> 2728</span>        <span class="comment"># special case as shortcut, would also be handled by `else` below</span></div>
<div class="line"><span class="lineno"> 2729</span>        pval = 1.</div>
<div class="line"><span class="lineno"> 2730</span>    <span class="keywordflow">elif</span> x &lt; p * n:</div>
<div class="line"><span class="lineno"> 2731</span>        i = np.arange(np.ceil(p * n), n+1)</div>
<div class="line"><span class="lineno"> 2732</span>        y = np.sum(distributions.binom.pmf(i, n, p) &lt;= d*rerr, axis=0)</div>
<div class="line"><span class="lineno"> 2733</span>        pval = (distributions.binom.cdf(x, n, p) +</div>
<div class="line"><span class="lineno"> 2734</span>                distributions.binom.sf(n - y, n, p))</div>
<div class="line"><span class="lineno"> 2735</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2736</span>        i = np.arange(np.floor(p*n) + 1)</div>
<div class="line"><span class="lineno"> 2737</span>        y = np.sum(distributions.binom.pmf(i, n, p) &lt;= d*rerr, axis=0)</div>
<div class="line"><span class="lineno"> 2738</span>        pval = (distributions.binom.cdf(y-1, n, p) +</div>
<div class="line"><span class="lineno"> 2739</span>                distributions.binom.sf(x-1, n, p))</div>
<div class="line"><span class="lineno"> 2740</span> </div>
<div class="line"><span class="lineno"> 2741</span>    <span class="keywordflow">return</span> min(1.0, pval)</div>
<div class="line"><span class="lineno"> 2742</span> </div>
<div class="line"><span class="lineno"> 2743</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8927cc8608f6decd26a9fe23214071e1" name="a8927cc8608f6decd26a9fe23214071e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8927cc8608f6decd26a9fe23214071e1">&#9670;&#160;</a></span>boxcox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmbda</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optimizer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dataset transformed by a Box-Cox power transformation.

Parameters
----------
x : ndarray
    Input array to be transformed.

    If `lmbda` is not None, this is an alias of
    `scipy.special.boxcox`.
    Returns nan if ``x &lt; 0``; returns -inf if ``x == 0 and lmbda &lt; 0``.

    If `lmbda` is None, array must be positive, 1-dimensional, and
    non-constant.

lmbda : scalar, optional
    If `lmbda` is None (default), find the value of `lmbda` that maximizes
    the log-likelihood function and return it as the second output
    argument.

    If `lmbda` is not None, do the transformation for that value.

alpha : float, optional
    If `lmbda` is None and `alpha` is not None (default), return the
    ``100 * (1-alpha)%`` confidence  interval for `lmbda` as the third
    output argument. Must be between 0.0 and 1.0.

    If `lmbda` is not None, `alpha` is ignored.
optimizer : callable, optional
    If `lmbda` is None, `optimizer` is the scalar optimizer used to find
    the value of `lmbda` that minimizes the negative log-likelihood
    function. `optimizer` is a callable that accepts one argument:

    fun : callable
        The objective function, which evaluates the negative
        log-likelihood function at a provided value of `lmbda`

    and returns an object, such as an instance of
    `scipy.optimize.OptimizeResult`, which holds the optimal value of
    `lmbda` in an attribute `x`.

    See the example in `boxcox_normmax` or the documentation of
    `scipy.optimize.minimize_scalar` for more information.

    If `lmbda` is not None, `optimizer` is ignored.

Returns
-------
boxcox : ndarray
    Box-Cox power transformed array.
maxlog : float, optional
    If the `lmbda` parameter is None, the second returned argument is
    the `lmbda` that maximizes the log-likelihood function.
(min_ci, max_ci) : tuple of float, optional
    If `lmbda` parameter is None and `alpha` is not None, this returned
    tuple of floats represents the minimum and maximum confidence limits
    given `alpha`.

See Also
--------
probplot, boxcox_normplot, boxcox_normmax, boxcox_llf

Notes
-----
The Box-Cox transform is given by::

    y = (x**lmbda - 1) / lmbda,  for lmbda != 0
        log(x),                  for lmbda = 0

`boxcox` requires the input data to be positive.  Sometimes a Box-Cox
transformation provides a shift parameter to achieve this; `boxcox` does
not.  Such a shift parameter is equivalent to adding a positive constant to
`x` before calling `boxcox`.

The confidence limits returned when `alpha` is provided give the interval
where:

.. math::

    llf(\hat{\lambda}) - llf(\lambda) &lt; \frac{1}{2}\chi^2(1 - \alpha, 1),

with ``llf`` the log-likelihood function and :math:`\chi^2` the chi-squared
function.

References
----------
G.E.P. Box and D.R. Cox, "An Analysis of Transformations", Journal of the
Royal Statistical Society B, 26, 211-252 (1964).

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

We generate some random variates from a non-normal distribution and make a
probability plot for it, to show it is non-normal in the tails:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(211)
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; prob = stats.probplot(x, dist=stats.norm, plot=ax1)
&gt;&gt;&gt; ax1.set_xlabel('')
&gt;&gt;&gt; ax1.set_title('Probplot against normal distribution')

We now use `boxcox` to transform the data so it's closest to normal:

&gt;&gt;&gt; ax2 = fig.add_subplot(212)
&gt;&gt;&gt; xt, _ = stats.boxcox(x)
&gt;&gt;&gt; prob = stats.probplot(xt, dist=stats.norm, plot=ax2)
&gt;&gt;&gt; ax2.set_title('Probplot after Box-Cox transformation')

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  962</span><span class="keyword">def </span>boxcox(x, lmbda=None, alpha=None, optimizer=None):</div>
<div class="line"><span class="lineno">  963</span>    <span class="stringliteral">r&quot;&quot;&quot;Return a dataset transformed by a Box-Cox power transformation.</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">        Input array to be transformed.</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">        If `lmbda` is not None, this is an alias of</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">        `scipy.special.boxcox`.</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">        Returns nan if ``x &lt; 0``; returns -inf if ``x == 0 and lmbda &lt; 0``.</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        If `lmbda` is None, array must be positive, 1-dimensional, and</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">        non-constant.</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    lmbda : scalar, optional</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">        If `lmbda` is None (default), find the value of `lmbda` that maximizes</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">        the log-likelihood function and return it as the second output</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">        argument.</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">        If `lmbda` is not None, do the transformation for that value.</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    alpha : float, optional</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">        If `lmbda` is None and `alpha` is not None (default), return the</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">        ``100 * (1-alpha)%`` confidence  interval for `lmbda` as the third</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">        output argument. Must be between 0.0 and 1.0.</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">        If `lmbda` is not None, `alpha` is ignored.</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    optimizer : callable, optional</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">        If `lmbda` is None, `optimizer` is the scalar optimizer used to find</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">        the value of `lmbda` that minimizes the negative log-likelihood</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">        function. `optimizer` is a callable that accepts one argument:</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">        fun : callable</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">            The objective function, which evaluates the negative</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">            log-likelihood function at a provided value of `lmbda`</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">        and returns an object, such as an instance of</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        `scipy.optimize.OptimizeResult`, which holds the optimal value of</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">        `lmbda` in an attribute `x`.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">        See the example in `boxcox_normmax` or the documentation of</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">        `scipy.optimize.minimize_scalar` for more information.</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">        If `lmbda` is not None, `optimizer` is ignored.</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    boxcox : ndarray</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">        Box-Cox power transformed array.</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    maxlog : float, optional</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">        If the `lmbda` parameter is None, the second returned argument is</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">        the `lmbda` that maximizes the log-likelihood function.</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    (min_ci, max_ci) : tuple of float, optional</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">        If `lmbda` parameter is None and `alpha` is not None, this returned</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        tuple of floats represents the minimum and maximum confidence limits</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">        given `alpha`.</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    probplot, boxcox_normplot, boxcox_normmax, boxcox_llf</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    The Box-Cox transform is given by::</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">        y = (x**lmbda - 1) / lmbda,  for lmbda != 0</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">            log(x),                  for lmbda = 0</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    `boxcox` requires the input data to be positive.  Sometimes a Box-Cox</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    transformation provides a shift parameter to achieve this; `boxcox` does</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    not.  Such a shift parameter is equivalent to adding a positive constant to</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    `x` before calling `boxcox`.</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    The confidence limits returned when `alpha` is provided give the interval</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    where:</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">        llf(\hat{\lambda}) - llf(\lambda) &lt; \frac{1}{2}\chi^2(1 - \alpha, 1),</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    with ``llf`` the log-likelihood function and :math:`\chi^2` the chi-squared</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">    function.</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">    G.E.P. Box and D.R. Cox, &quot;An Analysis of Transformations&quot;, Journal of the</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    Royal Statistical Society B, 26, 211-252 (1964).</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">    We generate some random variates from a non-normal distribution and make a</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    probability plot for it, to show it is non-normal in the tails:</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    &gt;&gt;&gt; ax1 = fig.add_subplot(211)</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.probplot(x, dist=stats.norm, plot=ax1)</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_xlabel(&#39;&#39;)</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_title(&#39;Probplot against normal distribution&#39;)</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    We now use `boxcox` to transform the data so it&#39;s closest to normal:</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    &gt;&gt;&gt; ax2 = fig.add_subplot(212)</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    &gt;&gt;&gt; xt, _ = stats.boxcox(x)</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.probplot(xt, dist=stats.norm, plot=ax2)</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    &gt;&gt;&gt; ax2.set_title(&#39;Probplot after Box-Cox transformation&#39;)</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1076</span>    <span class="keywordflow">if</span> lmbda <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:  <span class="comment"># single transformation</span></div>
<div class="line"><span class="lineno"> 1077</span>        <span class="keywordflow">return</span> special.boxcox(x, lmbda)</div>
<div class="line"><span class="lineno"> 1078</span> </div>
<div class="line"><span class="lineno"> 1079</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 1080</span>    <span class="keywordflow">if</span> x.ndim != 1:</div>
<div class="line"><span class="lineno"> 1081</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data must be 1-dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1082</span> </div>
<div class="line"><span class="lineno"> 1083</span>    <span class="keywordflow">if</span> x.size == 0:</div>
<div class="line"><span class="lineno"> 1084</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 1085</span> </div>
<div class="line"><span class="lineno"> 1086</span>    <span class="keywordflow">if</span> np.all(x == x[0]):</div>
<div class="line"><span class="lineno"> 1087</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data must not be constant.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1088</span> </div>
<div class="line"><span class="lineno"> 1089</span>    <span class="keywordflow">if</span> np.any(x &lt;= 0):</div>
<div class="line"><span class="lineno"> 1090</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data must be positive.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1091</span> </div>
<div class="line"><span class="lineno"> 1092</span>    <span class="comment"># If lmbda=None, find the lmbda that maximizes the log-likelihood function.</span></div>
<div class="line"><span class="lineno"> 1093</span>    lmax = boxcox_normmax(x, method=<span class="stringliteral">&#39;mle&#39;</span>, optimizer=optimizer)</div>
<div class="line"><span class="lineno"> 1094</span>    y = boxcox(x, lmax)</div>
<div class="line"><span class="lineno"> 1095</span> </div>
<div class="line"><span class="lineno"> 1096</span>    <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1097</span>        <span class="keywordflow">return</span> y, lmax</div>
<div class="line"><span class="lineno"> 1098</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1099</span>        <span class="comment"># Find confidence interval</span></div>
<div class="line"><span class="lineno"> 1100</span>        interval = _boxcox_conf_interval(x, lmax, alpha)</div>
<div class="line"><span class="lineno"> 1101</span>        <span class="keywordflow">return</span> y, lmax, interval</div>
<div class="line"><span class="lineno"> 1102</span> </div>
<div class="line"><span class="lineno"> 1103</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a93d168816d9c396b378a0d0d15544b56" name="a93d168816d9c396b378a0d0d15544b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d168816d9c396b378a0d0d15544b56">&#9670;&#160;</a></span>boxcox_llf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox_llf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The boxcox log-likelihood function.

Parameters
----------
lmb : scalar
    Parameter for Box-Cox transformation.  See `boxcox` for details.
data : array_like
    Data to calculate Box-Cox log-likelihood for.  If `data` is
    multi-dimensional, the log-likelihood is calculated along the first
    axis.

Returns
-------
llf : float or ndarray
    Box-Cox log-likelihood of `data` given `lmb`.  A float for 1-D `data`,
    an array otherwise.

See Also
--------
boxcox, probplot, boxcox_normplot, boxcox_normmax

Notes
-----
The Box-Cox log-likelihood function is defined here as

.. math::

    llf = (\lambda - 1) \sum_i(\log(x_i)) -
          N/2 \log(\sum_i (y_i - \bar{y})^2 / N),

where ``y`` is the Box-Cox transformed input data ``x``.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from mpl_toolkits.axes_grid1.inset_locator import inset_axes

Generate some random variates and calculate Box-Cox log-likelihood values
for them for a range of ``lmbda`` values:

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.loggamma.rvs(5, loc=10, size=1000, random_state=rng)
&gt;&gt;&gt; lmbdas = np.linspace(-2, 10)
&gt;&gt;&gt; llf = np.zeros(lmbdas.shape, dtype=float)
&gt;&gt;&gt; for ii, lmbda in enumerate(lmbdas):
...     llf[ii] = stats.boxcox_llf(lmbda, x)

Also find the optimal lmbda value with `boxcox`:

&gt;&gt;&gt; x_most_normal, lmbda_optimal = stats.boxcox(x)

Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
horizontal line to check that that's really the optimum:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(lmbdas, llf, 'b.-')
&gt;&gt;&gt; ax.axhline(stats.boxcox_llf(lmbda_optimal, x), color='r')
&gt;&gt;&gt; ax.set_xlabel('lmbda parameter')
&gt;&gt;&gt; ax.set_ylabel('Box-Cox log-likelihood')

Now add some probability plots to show that where the log-likelihood is
maximized the data transformed with `boxcox` looks closest to normal:

&gt;&gt;&gt; locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
&gt;&gt;&gt; for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
...     xt = stats.boxcox(x, lmbda=lmbda)
...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
...     ax_inset.set_xticklabels([])
...     ax_inset.set_yticklabels([])
...     ax_inset.set_title(r'$\lambda=%1.2f$' % lmbda)

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  829</span><span class="keyword">def </span>boxcox_llf(lmb, data):</div>
<div class="line"><span class="lineno">  830</span>    <span class="stringliteral">r&quot;&quot;&quot;The boxcox log-likelihood function.</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    lmb : scalar</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">        Parameter for Box-Cox transformation.  See `boxcox` for details.</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">        Data to calculate Box-Cox log-likelihood for.  If `data` is</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">        multi-dimensional, the log-likelihood is calculated along the first</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        axis.</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">    llf : float or ndarray</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        Box-Cox log-likelihood of `data` given `lmb`.  A float for 1-D `data`,</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        an array otherwise.</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    boxcox, probplot, boxcox_normplot, boxcox_normmax</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    The Box-Cox log-likelihood function is defined here as</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">        llf = (\lambda - 1) \sum_i(\log(x_i)) -</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">              N/2 \log(\sum_i (y_i - \bar{y})^2 / N),</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    where ``y`` is the Box-Cox transformed input data ``x``.</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    &gt;&gt;&gt; from mpl_toolkits.axes_grid1.inset_locator import inset_axes</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    Generate some random variates and calculate Box-Cox log-likelihood values</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    for them for a range of ``lmbda`` values:</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, loc=10, size=1000, random_state=rng)</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    &gt;&gt;&gt; lmbdas = np.linspace(-2, 10)</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    &gt;&gt;&gt; llf = np.zeros(lmbdas.shape, dtype=float)</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    &gt;&gt;&gt; for ii, lmbda in enumerate(lmbdas):</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    ...     llf[ii] = stats.boxcox_llf(lmbda, x)</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    Also find the optimal lmbda value with `boxcox`:</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    &gt;&gt;&gt; x_most_normal, lmbda_optimal = stats.boxcox(x)</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    horizontal line to check that that&#39;s really the optimum:</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    &gt;&gt;&gt; ax.plot(lmbdas, llf, &#39;b.-&#39;)</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    &gt;&gt;&gt; ax.axhline(stats.boxcox_llf(lmbda_optimal, x), color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_xlabel(&#39;lmbda parameter&#39;)</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_ylabel(&#39;Box-Cox log-likelihood&#39;)</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    Now add some probability plots to show that where the log-likelihood is</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    maximized the data transformed with `boxcox` looks closest to normal:</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    &gt;&gt;&gt; locs = [3, 10, 4]  # &#39;lower left&#39;, &#39;center&#39;, &#39;lower right&#39;</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    &gt;&gt;&gt; for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    ...     xt = stats.boxcox(x, lmbda=lmbda)</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    ...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    ...     ax_inset = inset_axes(ax, width=&quot;20%&quot;, height=&quot;20%&quot;, loc=loc)</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    ...     ax_inset.plot(osm, osr, &#39;c.&#39;, osm, slope*osm + intercept, &#39;k-&#39;)</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    ...     ax_inset.set_xticklabels([])</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    ...     ax_inset.set_yticklabels([])</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    ...     ax_inset.set_title(r&#39;$\lambda=%1.2f$&#39; % lmbda)</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  908</span>    data = np.asarray(data)</div>
<div class="line"><span class="lineno">  909</span>    N = data.shape[0]</div>
<div class="line"><span class="lineno">  910</span>    <span class="keywordflow">if</span> N == 0:</div>
<div class="line"><span class="lineno">  911</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno">  912</span> </div>
<div class="line"><span class="lineno">  913</span>    logdata = np.log(data)</div>
<div class="line"><span class="lineno">  914</span> </div>
<div class="line"><span class="lineno">  915</span>    <span class="comment"># Compute the variance of the transformed data.</span></div>
<div class="line"><span class="lineno">  916</span>    <span class="keywordflow">if</span> lmb == 0:</div>
<div class="line"><span class="lineno">  917</span>        variance = np.var(logdata, axis=0)</div>
<div class="line"><span class="lineno">  918</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  919</span>        <span class="comment"># Transform without the constant offset 1/lmb.  The offset does</span></div>
<div class="line"><span class="lineno">  920</span>        <span class="comment"># not effect the variance, and the subtraction of the offset can</span></div>
<div class="line"><span class="lineno">  921</span>        <span class="comment"># lead to loss of precision.</span></div>
<div class="line"><span class="lineno">  922</span>        variance = np.var(data**lmb / lmb, axis=0)</div>
<div class="line"><span class="lineno">  923</span> </div>
<div class="line"><span class="lineno">  924</span>    <span class="keywordflow">return</span> (lmb - 1) * np.sum(logdata, axis=0) - N/2 * np.log(variance)</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6e99833f0ddea425698e0590079d2d9" name="ae6e99833f0ddea425698e0590079d2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e99833f0ddea425698e0590079d2d9">&#9670;&#160;</a></span>boxcox_normmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox_normmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>brack</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'<a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7a080f1bfe9c97c7a3f1e609349e4a6c">pearsonr</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optimizer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute optimal Box-Cox transform parameter for input data.

Parameters
----------
x : array_like
    Input array.
brack : 2-tuple, optional, default (-2.0, 2.0)
     The starting interval for a downhill bracket search for the default
     `optimize.brent` solver. Note that this is in most cases not
     critical; the final result is allowed to be outside this bracket.
     If `optimizer` is passed, `brack` must be None.
method : str, optional
    The method to determine the optimal transform parameter (`boxcox`
    ``lmbda`` parameter). Options are:

    'pearsonr'  (default)
        Maximizes the Pearson correlation coefficient between
        ``y = boxcox(x)`` and the expected values for ``y`` if `x` would be
        normally-distributed.

    'mle'
        Minimizes the log-likelihood `boxcox_llf`.  This is the method used
        in `boxcox`.

    'all'
        Use all optimization methods available, and return all results.
        Useful to compare different methods.
optimizer : callable, optional
    `optimizer` is a callable that accepts one argument:

    fun : callable
        The objective function to be optimized. `fun` accepts one argument,
        the Box-Cox transform parameter `lmbda`, and returns the negative
        log-likelihood function at the provided value. The job of `optimizer`
        is to find the value of `lmbda` that minimizes `fun`.

    and returns an object, such as an instance of
    `scipy.optimize.OptimizeResult`, which holds the optimal value of
    `lmbda` in an attribute `x`.

    See the example below or the documentation of
    `scipy.optimize.minimize_scalar` for more information.

Returns
-------
maxlog : float or ndarray
    The optimal transform parameter found.  An array instead of a scalar
    for ``method='all'``.

See Also
--------
boxcox, boxcox_llf, boxcox_normplot, scipy.optimize.minimize_scalar

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

We can generate some data and determine the optimal ``lmbda`` in various
ways:

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5
&gt;&gt;&gt; y, lmax_mle = stats.boxcox(x)
&gt;&gt;&gt; lmax_pearsonr = stats.boxcox_normmax(x)

&gt;&gt;&gt; lmax_mle
2.217563431465757
&gt;&gt;&gt; lmax_pearsonr
2.238318660200961
&gt;&gt;&gt; stats.boxcox_normmax(x, method='all')
array([2.23831866, 2.21756343])

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.boxcox_normplot(x, -10, 10, plot=ax)
&gt;&gt;&gt; ax.axvline(lmax_mle, color='r')
&gt;&gt;&gt; ax.axvline(lmax_pearsonr, color='g', ls='--')

&gt;&gt;&gt; plt.show()

Alternatively, we can define our own `optimizer` function. Suppose we
are only interested in values of `lmbda` on the interval [6, 7], we
want to use `scipy.optimize.minimize_scalar` with ``method='bounded'``,
and we want to use tighter tolerances when optimizing the log-likelihood
function. To do this, we define a function that accepts positional argument
`fun` and uses `scipy.optimize.minimize_scalar` to minimize `fun` subject
to the provided bounds and tolerances:

&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; options = {'xatol': 1e-12}  # absolute tolerance on `x`
&gt;&gt;&gt; def optimizer(fun):
...     return optimize.minimize_scalar(fun, bounds=(6, 7),
...                                     method="bounded", options=options)
&gt;&gt;&gt; stats.boxcox_normmax(x, optimizer=optimizer)
6.000...
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1104</span><span class="keyword">def </span>boxcox_normmax(x, brack=None, method=&#39;pearsonr&#39;, optimizer=None):</div>
<div class="line"><span class="lineno"> 1105</span>    <span class="stringliteral">&quot;&quot;&quot;Compute optimal Box-Cox transform parameter for input data.</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    brack : 2-tuple, optional, default (-2.0, 2.0)</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">         The starting interval for a downhill bracket search for the default</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">         `optimize.brent` solver. Note that this is in most cases not</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">         critical; the final result is allowed to be outside this bracket.</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">         If `optimizer` is passed, `brack` must be None.</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">        The method to determine the optimal transform parameter (`boxcox`</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">        ``lmbda`` parameter). Options are:</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">        &#39;pearsonr&#39;  (default)</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">            Maximizes the Pearson correlation coefficient between</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">            ``y = boxcox(x)`` and the expected values for ``y`` if `x` would be</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">            normally-distributed.</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">        &#39;mle&#39;</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">            Minimizes the log-likelihood `boxcox_llf`.  This is the method used</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">            in `boxcox`.</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">        &#39;all&#39;</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">            Use all optimization methods available, and return all results.</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">            Useful to compare different methods.</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    optimizer : callable, optional</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">        `optimizer` is a callable that accepts one argument:</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">        fun : callable</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">            The objective function to be optimized. `fun` accepts one argument,</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">            the Box-Cox transform parameter `lmbda`, and returns the negative</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">            log-likelihood function at the provided value. The job of `optimizer`</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">            is to find the value of `lmbda` that minimizes `fun`.</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">        and returns an object, such as an instance of</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">        `scipy.optimize.OptimizeResult`, which holds the optimal value of</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">        `lmbda` in an attribute `x`.</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">        See the example below or the documentation of</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">        `scipy.optimize.minimize_scalar` for more information.</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    maxlog : float or ndarray</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">        The optimal transform parameter found.  An array instead of a scalar</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">        for ``method=&#39;all&#39;``.</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    boxcox, boxcox_llf, boxcox_normplot, scipy.optimize.minimize_scalar</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    We can generate some data and determine the optimal ``lmbda`` in various</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    ways:</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    &gt;&gt;&gt; y, lmax_mle = stats.boxcox(x)</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    &gt;&gt;&gt; lmax_pearsonr = stats.boxcox_normmax(x)</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    &gt;&gt;&gt; lmax_mle</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    2.217563431465757</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    &gt;&gt;&gt; lmax_pearsonr</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    2.238318660200961</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    &gt;&gt;&gt; stats.boxcox_normmax(x, method=&#39;all&#39;)</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    array([2.23831866, 2.21756343])</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.boxcox_normplot(x, -10, 10, plot=ax)</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvline(lmax_mle, color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvline(lmax_pearsonr, color=&#39;g&#39;, ls=&#39;--&#39;)</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    Alternatively, we can define our own `optimizer` function. Suppose we</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    are only interested in values of `lmbda` on the interval [6, 7], we</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    want to use `scipy.optimize.minimize_scalar` with ``method=&#39;bounded&#39;``,</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    and we want to use tighter tolerances when optimizing the log-likelihood</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    function. To do this, we define a function that accepts positional argument</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    `fun` and uses `scipy.optimize.minimize_scalar` to minimize `fun` subject</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    to the provided bounds and tolerances:</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import optimize</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    &gt;&gt;&gt; options = {&#39;xatol&#39;: 1e-12}  # absolute tolerance on `x`</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    &gt;&gt;&gt; def optimizer(fun):</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    ...     return optimize.minimize_scalar(fun, bounds=(6, 7),</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    ...                                     method=&quot;bounded&quot;, options=options)</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    &gt;&gt;&gt; stats.boxcox_normmax(x, optimizer=optimizer)</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    6.000...</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1202</span>    <span class="comment"># If optimizer is not given, define default &#39;brent&#39; optimizer.</span></div>
<div class="line"><span class="lineno"> 1203</span>    <span class="keywordflow">if</span> optimizer <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1204</span> </div>
<div class="line"><span class="lineno"> 1205</span>        <span class="comment"># Set default value for `brack`.</span></div>
<div class="line"><span class="lineno"> 1206</span>        <span class="keywordflow">if</span> brack <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1207</span>            brack = (-2.0, 2.0)</div>
<div class="line"><span class="lineno"> 1208</span> </div>
<div class="line"><span class="lineno"> 1209</span>        <span class="keyword">def </span>_optimizer(func, args):</div>
<div class="line"><span class="lineno"> 1210</span>            <span class="keywordflow">return</span> optimize.brent(func, args=args, brack=brack)</div>
<div class="line"><span class="lineno"> 1211</span> </div>
<div class="line"><span class="lineno"> 1212</span>    <span class="comment"># Otherwise check optimizer.</span></div>
<div class="line"><span class="lineno"> 1213</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1214</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(optimizer):</div>
<div class="line"><span class="lineno"> 1215</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`optimizer` must be a callable&quot;</span>)</div>
<div class="line"><span class="lineno"> 1216</span> </div>
<div class="line"><span class="lineno"> 1217</span>        <span class="keywordflow">if</span> brack <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1218</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`brack` must be None if `optimizer` is given&quot;</span>)</div>
<div class="line"><span class="lineno"> 1219</span> </div>
<div class="line"><span class="lineno"> 1220</span>        <span class="comment"># `optimizer` is expected to return a `OptimizeResult` object, we here</span></div>
<div class="line"><span class="lineno"> 1221</span>        <span class="comment"># get the solution to the optimization problem.</span></div>
<div class="line"><span class="lineno"> 1222</span>        <span class="keyword">def </span>_optimizer(func, args):</div>
<div class="line"><span class="lineno"> 1223</span>            <span class="keyword">def </span>func_wrapped(x):</div>
<div class="line"><span class="lineno"> 1224</span>                <span class="keywordflow">return</span> <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(x, *args)</div>
<div class="line"><span class="lineno"> 1225</span>            <span class="keywordflow">return</span> getattr(optimizer(func_wrapped), <span class="stringliteral">&#39;x&#39;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1226</span> </div>
<div class="line"><span class="lineno"> 1227</span>    <span class="keyword">def </span>_pearsonr(x):</div>
<div class="line"><span class="lineno"> 1228</span>        osm_uniform = _calc_uniform_order_statistic_medians(len(x))</div>
<div class="line"><span class="lineno"> 1229</span>        xvals = distributions.norm.ppf(osm_uniform)</div>
<div class="line"><span class="lineno"> 1230</span> </div>
<div class="line"><span class="lineno"> 1231</span>        <span class="keyword">def </span>_eval_pearsonr(lmbda, xvals, samps):</div>
<div class="line"><span class="lineno"> 1232</span>            <span class="comment"># This function computes the x-axis values of the probability plot</span></div>
<div class="line"><span class="lineno"> 1233</span>            <span class="comment"># and computes a linear regression (including the correlation) and</span></div>
<div class="line"><span class="lineno"> 1234</span>            <span class="comment"># returns ``1 - r`` so that a minimization function maximizes the</span></div>
<div class="line"><span class="lineno"> 1235</span>            <span class="comment"># correlation.</span></div>
<div class="line"><span class="lineno"> 1236</span>            y = boxcox(samps, lmbda)</div>
<div class="line"><span class="lineno"> 1237</span>            yvals = np.sort(y)</div>
<div class="line"><span class="lineno"> 1238</span>            r, prob = _stats_py.pearsonr(xvals, yvals)</div>
<div class="line"><span class="lineno"> 1239</span>            <span class="keywordflow">return</span> 1 - r</div>
<div class="line"><span class="lineno"> 1240</span> </div>
<div class="line"><span class="lineno"> 1241</span>        <span class="keywordflow">return</span> _optimizer(_eval_pearsonr, args=(xvals, x))</div>
<div class="line"><span class="lineno"> 1242</span> </div>
<div class="line"><span class="lineno"> 1243</span>    <span class="keyword">def </span>_mle(x):</div>
<div class="line"><span class="lineno"> 1244</span>        <span class="keyword">def </span>_eval_mle(lmb, data):</div>
<div class="line"><span class="lineno"> 1245</span>            <span class="comment"># function to minimize</span></div>
<div class="line"><span class="lineno"> 1246</span>            <span class="keywordflow">return</span> -boxcox_llf(lmb, data)</div>
<div class="line"><span class="lineno"> 1247</span> </div>
<div class="line"><span class="lineno"> 1248</span>        <span class="keywordflow">return</span> _optimizer(_eval_mle, args=(x,))</div>
<div class="line"><span class="lineno"> 1249</span> </div>
<div class="line"><span class="lineno"> 1250</span>    <span class="keyword">def </span>_all(x):</div>
<div class="line"><span class="lineno"> 1251</span>        maxlog = np.empty(2, dtype=float)</div>
<div class="line"><span class="lineno"> 1252</span>        maxlog[0] = _pearsonr(x)</div>
<div class="line"><span class="lineno"> 1253</span>        maxlog[1] = _mle(x)</div>
<div class="line"><span class="lineno"> 1254</span>        <span class="keywordflow">return</span> maxlog</div>
<div class="line"><span class="lineno"> 1255</span> </div>
<div class="line"><span class="lineno"> 1256</span>    methods = {<span class="stringliteral">&#39;pearsonr&#39;</span>: _pearsonr,</div>
<div class="line"><span class="lineno"> 1257</span>               <span class="stringliteral">&#39;mle&#39;</span>: _mle,</div>
<div class="line"><span class="lineno"> 1258</span>               <span class="stringliteral">&#39;all&#39;</span>: _all}</div>
<div class="line"><span class="lineno"> 1259</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> methods.keys():</div>
<div class="line"><span class="lineno"> 1260</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Method %s not recognized.&quot;</span> % method)</div>
<div class="line"><span class="lineno"> 1261</span> </div>
<div class="line"><span class="lineno"> 1262</span>    optimfunc = methods[method]</div>
<div class="line"><span class="lineno"> 1263</span>    res = optimfunc(x)</div>
<div class="line"><span class="lineno"> 1264</span>    <span class="keywordflow">if</span> res <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1265</span>        message = (<span class="stringliteral">&quot;`optimizer` must return an object containing the optimal &quot;</span></div>
<div class="line"><span class="lineno"> 1266</span>                   <span class="stringliteral">&quot;`lmbda` in attribute `x`&quot;</span>)</div>
<div class="line"><span class="lineno"> 1267</span>        <span class="keywordflow">raise</span> ValueError(message)</div>
<div class="line"><span class="lineno"> 1268</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 1269</span> </div>
<div class="line"><span class="lineno"> 1270</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a91186ccc31cc60f13d65ab705c006a4f" name="a91186ccc31cc60f13d65ab705c006a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91186ccc31cc60f13d65ab705c006a4f">&#9670;&#160;</a></span>boxcox_normplot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox_normplot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>la</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plot</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute parameters for a Box-Cox normality plot, optionally show it.

A Box-Cox normality plot shows graphically what the best transformation
parameter is to use in `boxcox` to obtain a distribution that is close
to normal.

Parameters
----------
x : array_like
    Input array.
la, lb : scalar
    The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`
    for Box-Cox transformations.  These are also the limits of the
    horizontal axis of the plot if that is generated.
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `la` to `lb`).

Returns
-------
lmbdas : ndarray
    The ``lmbda`` values for which a Box-Cox transform was done.
ppcc : ndarray
    Probability Plot Correlelation Coefficient, as obtained from `probplot`
    when fitting the Box-Cox transformed input `x` against a normal
    distribution.

See Also
--------
probplot, boxcox, boxcox_normmax, boxcox_llf, ppcc_max

Notes
-----
Even if `plot` is given, the figure is not shown or saved by
`boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
should be used after calling `probplot`.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate some non-normally distributed data, and create a Box-Cox plot:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.boxcox_normplot(x, -20, 20, plot=ax)

Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
the same plot:

&gt;&gt;&gt; _, maxlog = stats.boxcox(x)
&gt;&gt;&gt; ax.axvline(maxlog, color='r')

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1313</span><span class="keyword">def </span>boxcox_normplot(x, la, lb, plot=None, N=80):</div>
<div class="line"><span class="lineno"> 1314</span>    <span class="stringliteral">&quot;&quot;&quot;Compute parameters for a Box-Cox normality plot, optionally show it.</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    A Box-Cox normality plot shows graphically what the best transformation</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    parameter is to use in `boxcox` to obtain a distribution that is close</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">    to normal.</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    la, lb : scalar</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">        The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">        for Box-Cox transformations.  These are also the limits of the</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">        horizontal axis of the plot if that is generated.</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    plot : object, optional</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">        If given, plots the quantiles and least squares fit.</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">        `plot` is an object that has to have methods &quot;plot&quot; and &quot;text&quot;.</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">        The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">        or a custom object with the same methods.</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">        Default is None, which means that no plot is created.</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">        Number of points on the horizontal axis (equally distributed from</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">        `la` to `lb`).</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    lmbdas : ndarray</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        The ``lmbda`` values for which a Box-Cox transform was done.</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    ppcc : ndarray</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">        Probability Plot Correlelation Coefficient, as obtained from `probplot`</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">        when fitting the Box-Cox transformed input `x` against a normal</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">        distribution.</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    probplot, boxcox, boxcox_normmax, boxcox_llf, ppcc_max</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    Even if `plot` is given, the figure is not shown or saved by</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    `boxcox_normplot`; ``plt.show()`` or ``plt.savefig(&#39;figname.png&#39;)``</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    should be used after calling `probplot`.</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    Generate some non-normally distributed data, and create a Box-Cox plot:</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.boxcox_normplot(x, -20, 20, plot=ax)</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    the same plot:</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    &gt;&gt;&gt; _, maxlog = stats.boxcox(x)</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvline(maxlog, color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1378</span>    <span class="keywordflow">return</span> _normplot(<span class="stringliteral">&#39;boxcox&#39;</span>, x, la, lb, plot, N)</div>
<div class="line"><span class="lineno"> 1379</span> </div>
<div class="line"><span class="lineno"> 1380</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad39d886f881520f6b73d7bff6f071854" name="ad39d886f881520f6b73d7bff6f071854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d886f881520f6b73d7bff6f071854">&#9670;&#160;</a></span>circmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.circmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>high</em> = <code>2*pi</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>low</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the circular mean for samples in a range.

Parameters
----------
samples : array_like
    Input array.
high : float or int, optional
    High boundary for the sample range. Default is ``2*pi``.
low : float or int, optional
    Low boundary for the sample range. Default is 0.
axis : int, optional
    Axis along which means are computed. The default is to compute
    the mean of the flattened array.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
circmean : float
    Circular mean.

Examples
--------
&gt;&gt;&gt; from scipy.stats import circmean
&gt;&gt;&gt; circmean([0.1, 2*np.pi+0.2, 6*np.pi+0.3])
0.2

&gt;&gt;&gt; from scipy.stats import circmean
&gt;&gt;&gt; circmean([0.2, 1.4, 2.6], high = 1, low = 0)
0.4</pre> <div class="fragment"><div class="line"><span class="lineno"> 3674</span><span class="keyword">def </span>circmean(samples, high=2*pi, low=0, axis=None, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 3675</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the circular mean for samples in a range.</span></div>
<div class="line"><span class="lineno"> 3676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3677</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3678</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3679</span><span class="stringliteral">    samples : array_like</span></div>
<div class="line"><span class="lineno"> 3680</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 3681</span><span class="stringliteral">    high : float or int, optional</span></div>
<div class="line"><span class="lineno"> 3682</span><span class="stringliteral">        High boundary for the sample range. Default is ``2*pi``.</span></div>
<div class="line"><span class="lineno"> 3683</span><span class="stringliteral">    low : float or int, optional</span></div>
<div class="line"><span class="lineno"> 3684</span><span class="stringliteral">        Low boundary for the sample range. Default is 0.</span></div>
<div class="line"><span class="lineno"> 3685</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3686</span><span class="stringliteral">        Axis along which means are computed. The default is to compute</span></div>
<div class="line"><span class="lineno"> 3687</span><span class="stringliteral">        the mean of the flattened array.</span></div>
<div class="line"><span class="lineno"> 3688</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3689</span><span class="stringliteral">        Defines how to handle when input contains nan. &#39;propagate&#39; returns nan,</span></div>
<div class="line"><span class="lineno"> 3690</span><span class="stringliteral">        &#39;raise&#39; throws an error, &#39;omit&#39; performs the calculations ignoring nan</span></div>
<div class="line"><span class="lineno"> 3691</span><span class="stringliteral">        values. Default is &#39;propagate&#39;.</span></div>
<div class="line"><span class="lineno"> 3692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3693</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3694</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3695</span><span class="stringliteral">    circmean : float</span></div>
<div class="line"><span class="lineno"> 3696</span><span class="stringliteral">        Circular mean.</span></div>
<div class="line"><span class="lineno"> 3697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3698</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3699</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3700</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import circmean</span></div>
<div class="line"><span class="lineno"> 3701</span><span class="stringliteral">    &gt;&gt;&gt; circmean([0.1, 2*np.pi+0.2, 6*np.pi+0.3])</span></div>
<div class="line"><span class="lineno"> 3702</span><span class="stringliteral">    0.2</span></div>
<div class="line"><span class="lineno"> 3703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3704</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import circmean</span></div>
<div class="line"><span class="lineno"> 3705</span><span class="stringliteral">    &gt;&gt;&gt; circmean([0.2, 1.4, 2.6], high = 1, low = 0)</span></div>
<div class="line"><span class="lineno"> 3706</span><span class="stringliteral">    0.4</span></div>
<div class="line"><span class="lineno"> 3707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3708</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3709</span>    samples, sin_samp, cos_samp, nmask = _circfuncs_common(samples, high, low,</div>
<div class="line"><span class="lineno"> 3710</span>                                                           nan_policy=nan_policy)</div>
<div class="line"><span class="lineno"> 3711</span>    sin_sum = sin_samp.sum(axis=axis)</div>
<div class="line"><span class="lineno"> 3712</span>    cos_sum = cos_samp.sum(axis=axis)</div>
<div class="line"><span class="lineno"> 3713</span>    res = arctan2(sin_sum, cos_sum)</div>
<div class="line"><span class="lineno"> 3714</span> </div>
<div class="line"><span class="lineno"> 3715</span>    mask_nan = ~np.isnan(res)</div>
<div class="line"><span class="lineno"> 3716</span>    <span class="keywordflow">if</span> mask_nan.ndim &gt; 0:</div>
<div class="line"><span class="lineno"> 3717</span>        mask = res[mask_nan] &lt; 0</div>
<div class="line"><span class="lineno"> 3718</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3719</span>        mask = res &lt; 0</div>
<div class="line"><span class="lineno"> 3720</span> </div>
<div class="line"><span class="lineno"> 3721</span>    <span class="keywordflow">if</span> mask.ndim &gt; 0:</div>
<div class="line"><span class="lineno"> 3722</span>        mask_nan[mask_nan] = mask</div>
<div class="line"><span class="lineno"> 3723</span>        res[mask_nan] += 2*pi</div>
<div class="line"><span class="lineno"> 3724</span>    <span class="keywordflow">elif</span> mask:</div>
<div class="line"><span class="lineno"> 3725</span>        res += 2*pi</div>
<div class="line"><span class="lineno"> 3726</span> </div>
<div class="line"><span class="lineno"> 3727</span>    <span class="comment"># Set output to NaN if no samples went into the mean</span></div>
<div class="line"><span class="lineno"> 3728</span>    <span class="keywordflow">if</span> nmask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3729</span>        <span class="keywordflow">if</span> nmask.all():</div>
<div class="line"><span class="lineno"> 3730</span>            res = np.full(shape=res.shape, fill_value=np.nan)</div>
<div class="line"><span class="lineno"> 3731</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3732</span>            <span class="comment"># Find out if any of the axis that are being averaged consist</span></div>
<div class="line"><span class="lineno"> 3733</span>            <span class="comment"># entirely of NaN.  If one exists, set the result (res) to NaN</span></div>
<div class="line"><span class="lineno"> 3734</span>            nshape = 0 <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> axis</div>
<div class="line"><span class="lineno"> 3735</span>            smask = nmask.shape[nshape] == nmask.sum(axis=axis)</div>
<div class="line"><span class="lineno"> 3736</span>            <span class="keywordflow">if</span> smask.any():</div>
<div class="line"><span class="lineno"> 3737</span>                res[smask] = np.nan</div>
<div class="line"><span class="lineno"> 3738</span> </div>
<div class="line"><span class="lineno"> 3739</span>    <span class="keywordflow">return</span> res*(high - low)/2.0/pi + low</div>
<div class="line"><span class="lineno"> 3740</span> </div>
<div class="line"><span class="lineno"> 3741</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7931e19d28601b600e60d91db5e34d51" name="a7931e19d28601b600e60d91db5e34d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7931e19d28601b600e60d91db5e34d51">&#9670;&#160;</a></span>circstd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.circstd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>high</em> = <code>2*pi</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>low</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the circular standard deviation for samples assumed to be in the
range [low to high].

Parameters
----------
samples : array_like
    Input array.
high : float or int, optional
    High boundary for the sample range. Default is ``2*pi``.
low : float or int, optional
    Low boundary for the sample range. Default is 0.
axis : int, optional
    Axis along which standard deviations are computed. The default is
    to compute the standard deviation of the flattened array.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.
normalize : boolean, optional
    If True, the returned value is equal to ``sqrt(-2*log(R))`` and does
    not depend on the variable units. If False (default), the returned
    value is scaled by ``((high-low)/(2*pi))``.

Returns
-------
circstd : float
    Circular standard deviation.

Notes
-----
This uses a definition of circular standard deviation from [1]_.
Essentially, the calculation is as follows.

.. code-block:: python

    C = np.cos(samples).mean()
    S = np.sin(samples).mean()
    R = np.sqrt(C**2 + S**2)
    l = 2*np.pi / (high-low)
    circstd = np.sqrt(-2*np.log(R)) / l

In the limit of small angles, it returns a number close to the 'linear'
standard deviation.

References
----------
.. [1] Mardia, K. V. (1972). 2. In *Statistics of Directional Data*
   (pp. 18-24). Academic Press. :doi:`10.1016/C2013-0-07425-7`.

Examples
--------
&gt;&gt;&gt; from scipy.stats import circstd
&gt;&gt;&gt; small_samples = [0, 0.1*np.pi/2, 0.001*np.pi, 0.03*np.pi/2]
&gt;&gt;&gt; circstd(small_samples)
0.06356406330602443
&gt;&gt;&gt; np.std(small_samples)
0.06355419420577858</pre> <div class="fragment"><div class="line"><span class="lineno"> 3805</span>            normalize=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 3806</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3807</span><span class="stringliteral">    Compute the circular standard deviation for samples assumed to be in the</span></div>
<div class="line"><span class="lineno"> 3808</span><span class="stringliteral">    range [low to high].</span></div>
<div class="line"><span class="lineno"> 3809</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3810</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3811</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3812</span><span class="stringliteral">    samples : array_like</span></div>
<div class="line"><span class="lineno"> 3813</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 3814</span><span class="stringliteral">    high : float or int, optional</span></div>
<div class="line"><span class="lineno"> 3815</span><span class="stringliteral">        High boundary for the sample range. Default is ``2*pi``.</span></div>
<div class="line"><span class="lineno"> 3816</span><span class="stringliteral">    low : float or int, optional</span></div>
<div class="line"><span class="lineno"> 3817</span><span class="stringliteral">        Low boundary for the sample range. Default is 0.</span></div>
<div class="line"><span class="lineno"> 3818</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3819</span><span class="stringliteral">        Axis along which standard deviations are computed. The default is</span></div>
<div class="line"><span class="lineno"> 3820</span><span class="stringliteral">        to compute the standard deviation of the flattened array.</span></div>
<div class="line"><span class="lineno"> 3821</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3822</span><span class="stringliteral">        Defines how to handle when input contains nan. &#39;propagate&#39; returns nan,</span></div>
<div class="line"><span class="lineno"> 3823</span><span class="stringliteral">        &#39;raise&#39; throws an error, &#39;omit&#39; performs the calculations ignoring nan</span></div>
<div class="line"><span class="lineno"> 3824</span><span class="stringliteral">        values. Default is &#39;propagate&#39;.</span></div>
<div class="line"><span class="lineno"> 3825</span><span class="stringliteral">    normalize : boolean, optional</span></div>
<div class="line"><span class="lineno"> 3826</span><span class="stringliteral">        If True, the returned value is equal to ``sqrt(-2*log(R))`` and does</span></div>
<div class="line"><span class="lineno"> 3827</span><span class="stringliteral">        not depend on the variable units. If False (default), the returned</span></div>
<div class="line"><span class="lineno"> 3828</span><span class="stringliteral">        value is scaled by ``((high-low)/(2*pi))``.</span></div>
<div class="line"><span class="lineno"> 3829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3830</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3831</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3832</span><span class="stringliteral">    circstd : float</span></div>
<div class="line"><span class="lineno"> 3833</span><span class="stringliteral">        Circular standard deviation.</span></div>
<div class="line"><span class="lineno"> 3834</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3835</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3836</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3837</span><span class="stringliteral">    This uses a definition of circular standard deviation from [1]_.</span></div>
<div class="line"><span class="lineno"> 3838</span><span class="stringliteral">    Essentially, the calculation is as follows.</span></div>
<div class="line"><span class="lineno"> 3839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3840</span><span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><span class="lineno"> 3841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3842</span><span class="stringliteral">        C = np.cos(samples).mean()</span></div>
<div class="line"><span class="lineno"> 3843</span><span class="stringliteral">        S = np.sin(samples).mean()</span></div>
<div class="line"><span class="lineno"> 3844</span><span class="stringliteral">        R = np.sqrt(C**2 + S**2)</span></div>
<div class="line"><span class="lineno"> 3845</span><span class="stringliteral">        l = 2*np.pi / (high-low)</span></div>
<div class="line"><span class="lineno"> 3846</span><span class="stringliteral">        circstd = np.sqrt(-2*np.log(R)) / l</span></div>
<div class="line"><span class="lineno"> 3847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3848</span><span class="stringliteral">    In the limit of small angles, it returns a number close to the &#39;linear&#39;</span></div>
<div class="line"><span class="lineno"> 3849</span><span class="stringliteral">    standard deviation.</span></div>
<div class="line"><span class="lineno"> 3850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3851</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3852</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3853</span><span class="stringliteral">    .. [1] Mardia, K. V. (1972). 2. In *Statistics of Directional Data*</span></div>
<div class="line"><span class="lineno"> 3854</span><span class="stringliteral">       (pp. 18-24). Academic Press. :doi:`10.1016/C2013-0-07425-7`.</span></div>
<div class="line"><span class="lineno"> 3855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3856</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3857</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3858</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import circstd</span></div>
<div class="line"><span class="lineno"> 3859</span><span class="stringliteral">    &gt;&gt;&gt; small_samples = [0, 0.1*np.pi/2, 0.001*np.pi, 0.03*np.pi/2]</span></div>
<div class="line"><span class="lineno"> 3860</span><span class="stringliteral">    &gt;&gt;&gt; circstd(small_samples)</span></div>
<div class="line"><span class="lineno"> 3861</span><span class="stringliteral">    0.06356406330602443</span></div>
<div class="line"><span class="lineno"> 3862</span><span class="stringliteral">    &gt;&gt;&gt; np.std(small_samples)</span></div>
<div class="line"><span class="lineno"> 3863</span><span class="stringliteral">    0.06355419420577858</span></div>
<div class="line"><span class="lineno"> 3864</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3865</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3866</span>    samples, sin_samp, cos_samp, mask = _circfuncs_common(samples, high, low,</div>
<div class="line"><span class="lineno"> 3867</span>                                                          nan_policy=nan_policy)</div>
<div class="line"><span class="lineno"> 3868</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3869</span>        sin_mean = sin_samp.mean(axis=axis)  <span class="comment"># [1] (2.2.3)</span></div>
<div class="line"><span class="lineno"> 3870</span>        cos_mean = cos_samp.mean(axis=axis)  <span class="comment"># [1] (2.2.3)</span></div>
<div class="line"><span class="lineno"> 3871</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3872</span>        nsum = np.asarray(np.sum(~mask, axis=axis).astype(float))</div>
<div class="line"><span class="lineno"> 3873</span>        nsum[nsum == 0] = np.nan</div>
<div class="line"><span class="lineno"> 3874</span>        sin_mean = sin_samp.sum(axis=axis) / nsum</div>
<div class="line"><span class="lineno"> 3875</span>        cos_mean = cos_samp.sum(axis=axis) / nsum</div>
<div class="line"><span class="lineno"> 3876</span>    <span class="comment"># hypot can go slightly above 1 due to rounding errors</span></div>
<div class="line"><span class="lineno"> 3877</span>    <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 3878</span>        R = np.minimum(1, hypot(sin_mean, cos_mean))  <span class="comment"># [1] (2.2.4)</span></div>
<div class="line"><span class="lineno"> 3879</span> </div>
<div class="line"><span class="lineno"> 3880</span>    res = sqrt(-2*log(R))</div>
<div class="line"><span class="lineno"> 3881</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> normalize:</div>
<div class="line"><span class="lineno"> 3882</span>        res *= (high-low)/(2.*pi)  <span class="comment"># [1] (2.3.14) w/ (2.3.7)</span></div>
<div class="line"><span class="lineno"> 3883</span>    <span class="keywordflow">return</span> res</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2b2d677962cb55b72b6eee1d4e84b79" name="ab2b2d677962cb55b72b6eee1d4e84b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b2d677962cb55b72b6eee1d4e84b79">&#9670;&#160;</a></span>circvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.circvar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>high</em> = <code>2*pi</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>low</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the circular variance for samples assumed to be in a range.

Parameters
----------
samples : array_like
    Input array.
high : float or int, optional
    High boundary for the sample range. Default is ``2*pi``.
low : float or int, optional
    Low boundary for the sample range. Default is 0.
axis : int, optional
    Axis along which variances are computed. The default is to compute
    the variance of the flattened array.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
circvar : float
    Circular variance.

Notes
-----
This uses the following definition of circular variance: ``1-R``, where
``R`` is the mean resultant vector. The
returned value is in the range [0, 1], 0 standing for no variance, and 1
for a large variance. In the limit of small angles, this value is similar
to half the 'linear' variance.

References
----------
..[1] Fisher, N.I. *Statistical analysis of circular data*. Cambridge
      University Press, 1993.

Examples
--------
&gt;&gt;&gt; from scipy.stats import circvar
&gt;&gt;&gt; circvar([0, 2*np.pi/3, 5*np.pi/3])
0.6666666666666665</pre> <div class="fragment"><div class="line"><span class="lineno"> 3742</span><span class="keyword">def </span>circvar(samples, high=2*pi, low=0, axis=None, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 3743</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the circular variance for samples assumed to be in a range.</span></div>
<div class="line"><span class="lineno"> 3744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3745</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3746</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3747</span><span class="stringliteral">    samples : array_like</span></div>
<div class="line"><span class="lineno"> 3748</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 3749</span><span class="stringliteral">    high : float or int, optional</span></div>
<div class="line"><span class="lineno"> 3750</span><span class="stringliteral">        High boundary for the sample range. Default is ``2*pi``.</span></div>
<div class="line"><span class="lineno"> 3751</span><span class="stringliteral">    low : float or int, optional</span></div>
<div class="line"><span class="lineno"> 3752</span><span class="stringliteral">        Low boundary for the sample range. Default is 0.</span></div>
<div class="line"><span class="lineno"> 3753</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3754</span><span class="stringliteral">        Axis along which variances are computed. The default is to compute</span></div>
<div class="line"><span class="lineno"> 3755</span><span class="stringliteral">        the variance of the flattened array.</span></div>
<div class="line"><span class="lineno"> 3756</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3757</span><span class="stringliteral">        Defines how to handle when input contains nan. &#39;propagate&#39; returns nan,</span></div>
<div class="line"><span class="lineno"> 3758</span><span class="stringliteral">        &#39;raise&#39; throws an error, &#39;omit&#39; performs the calculations ignoring nan</span></div>
<div class="line"><span class="lineno"> 3759</span><span class="stringliteral">        values. Default is &#39;propagate&#39;.</span></div>
<div class="line"><span class="lineno"> 3760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3761</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3762</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3763</span><span class="stringliteral">    circvar : float</span></div>
<div class="line"><span class="lineno"> 3764</span><span class="stringliteral">        Circular variance.</span></div>
<div class="line"><span class="lineno"> 3765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3766</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3767</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3768</span><span class="stringliteral">    This uses the following definition of circular variance: ``1-R``, where</span></div>
<div class="line"><span class="lineno"> 3769</span><span class="stringliteral">    ``R`` is the mean resultant vector. The</span></div>
<div class="line"><span class="lineno"> 3770</span><span class="stringliteral">    returned value is in the range [0, 1], 0 standing for no variance, and 1</span></div>
<div class="line"><span class="lineno"> 3771</span><span class="stringliteral">    for a large variance. In the limit of small angles, this value is similar</span></div>
<div class="line"><span class="lineno"> 3772</span><span class="stringliteral">    to half the &#39;linear&#39; variance.</span></div>
<div class="line"><span class="lineno"> 3773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3774</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3775</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3776</span><span class="stringliteral">    ..[1] Fisher, N.I. *Statistical analysis of circular data*. Cambridge</span></div>
<div class="line"><span class="lineno"> 3777</span><span class="stringliteral">          University Press, 1993.</span></div>
<div class="line"><span class="lineno"> 3778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3779</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3780</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3781</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import circvar</span></div>
<div class="line"><span class="lineno"> 3782</span><span class="stringliteral">    &gt;&gt;&gt; circvar([0, 2*np.pi/3, 5*np.pi/3])</span></div>
<div class="line"><span class="lineno"> 3783</span><span class="stringliteral">    0.6666666666666665</span></div>
<div class="line"><span class="lineno"> 3784</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3785</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3786</span>    samples, sin_samp, cos_samp, mask = _circfuncs_common(samples, high, low,</div>
<div class="line"><span class="lineno"> 3787</span>                                                          nan_policy=nan_policy)</div>
<div class="line"><span class="lineno"> 3788</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3789</span>        sin_mean = sin_samp.mean(axis=axis)</div>
<div class="line"><span class="lineno"> 3790</span>        cos_mean = cos_samp.mean(axis=axis)</div>
<div class="line"><span class="lineno"> 3791</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3792</span>        nsum = np.asarray(np.sum(~mask, axis=axis).astype(float))</div>
<div class="line"><span class="lineno"> 3793</span>        nsum[nsum == 0] = np.nan</div>
<div class="line"><span class="lineno"> 3794</span>        sin_mean = sin_samp.sum(axis=axis) / nsum</div>
<div class="line"><span class="lineno"> 3795</span>        cos_mean = cos_samp.sum(axis=axis) / nsum</div>
<div class="line"><span class="lineno"> 3796</span>    <span class="comment"># hypot can go slightly above 1 due to rounding errors</span></div>
<div class="line"><span class="lineno"> 3797</span>    <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 3798</span>        R = np.minimum(1, hypot(sin_mean, cos_mean))</div>
<div class="line"><span class="lineno"> 3799</span> </div>
<div class="line"><span class="lineno"> 3800</span>    res = 1. - R</div>
<div class="line"><span class="lineno"> 3801</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 3802</span> </div>
<div class="line"><span class="lineno"> 3803</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a978e827467d79fbfe254eea650472601" name="a978e827467d79fbfe254eea650472601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978e827467d79fbfe254eea650472601">&#9670;&#160;</a></span>fligner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.fligner </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>'median'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proportiontocut</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Fligner-Killeen test for equality of variance.

Fligner's test tests the null hypothesis that all input samples
are from populations with equal variances.  Fligner-Killeen's test is
distribution free when populations are identical [2]_.

Parameters
----------
sample1, sample2, ... : array_like
    Arrays of sample data.  Need not be the same length.
center : {'mean', 'median', 'trimmed'}, optional
    Keyword argument controlling which function of the data is used in
    computing the test statistic.  The default is 'median'.
proportiontocut : float, optional
    When `center` is 'trimmed', this gives the proportion of data points
    to cut from each end. (See `scipy.stats.trim_mean`.)
    Default is 0.05.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value for the hypothesis test.

See Also
--------
bartlett : A parametric test for equality of k variances in normal samples
levene : A robust parametric test for equality of k variances

Notes
-----
As with Levene's test there are three variants of Fligner's test that
differ by the measure of central tendency used in the test.  See `levene`
for more information.

Conover et al. (1981) examine many of the existing parametric and
nonparametric tests by extensive simulations and they conclude that the
tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
superior in terms of robustness of departures from normality and power [3]_.

References
----------
.. [1] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.
       https://cecas.clemson.edu/~cspark/cv/paper/qif/draftqif2.pdf

.. [2] Fligner, M.A. and Killeen, T.J. (1976). Distribution-free two-sample
       tests for scale. 'Journal of the American Statistical Association.'
       71(353), 210-213.

.. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.

.. [4] Conover, W. J., Johnson, M. E. and Johnson M. M. (1981). A
       comparative study of tests for homogeneity of variances, with
       applications to the outer continental shelf biding data.
       Technometrics, 23(4), 351-361.

Examples
--------
Test whether or not the lists `a`, `b` and `c` come from populations
with equal variances.

&gt;&gt;&gt; from scipy.stats import fligner
&gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
&gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
&gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
&gt;&gt;&gt; stat, p = fligner(a, b, c)
&gt;&gt;&gt; p
0.00450826080004775

The small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

&gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]</pre> <div class="fragment"><div class="line"><span class="lineno"> 2757</span><span class="keyword">def </span>fligner(*samples, center=&#39;median&#39;, proportiontocut=0.05):</div>
<div class="line"><span class="lineno"> 2758</span>    <span class="stringliteral">&quot;&quot;&quot;Perform Fligner-Killeen test for equality of variance.</span></div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2760</span><span class="stringliteral">    Fligner&#39;s test tests the null hypothesis that all input samples</span></div>
<div class="line"><span class="lineno"> 2761</span><span class="stringliteral">    are from populations with equal variances.  Fligner-Killeen&#39;s test is</span></div>
<div class="line"><span class="lineno"> 2762</span><span class="stringliteral">    distribution free when populations are identical [2]_.</span></div>
<div class="line"><span class="lineno"> 2763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2764</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2765</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2766</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 2767</span><span class="stringliteral">        Arrays of sample data.  Need not be the same length.</span></div>
<div class="line"><span class="lineno"> 2768</span><span class="stringliteral">    center : {&#39;mean&#39;, &#39;median&#39;, &#39;trimmed&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2769</span><span class="stringliteral">        Keyword argument controlling which function of the data is used in</span></div>
<div class="line"><span class="lineno"> 2770</span><span class="stringliteral">        computing the test statistic.  The default is &#39;median&#39;.</span></div>
<div class="line"><span class="lineno"> 2771</span><span class="stringliteral">    proportiontocut : float, optional</span></div>
<div class="line"><span class="lineno"> 2772</span><span class="stringliteral">        When `center` is &#39;trimmed&#39;, this gives the proportion of data points</span></div>
<div class="line"><span class="lineno"> 2773</span><span class="stringliteral">        to cut from each end. (See `scipy.stats.trim_mean`.)</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="stringliteral">        Default is 0.05.</span></div>
<div class="line"><span class="lineno"> 2775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2776</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2777</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2778</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 2779</span><span class="stringliteral">        The test statistic.</span></div>
<div class="line"><span class="lineno"> 2780</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 2781</span><span class="stringliteral">        The p-value for the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 2782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2783</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2784</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2785</span><span class="stringliteral">    bartlett : A parametric test for equality of k variances in normal samples</span></div>
<div class="line"><span class="lineno"> 2786</span><span class="stringliteral">    levene : A robust parametric test for equality of k variances</span></div>
<div class="line"><span class="lineno"> 2787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">    As with Levene&#39;s test there are three variants of Fligner&#39;s test that</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">    differ by the measure of central tendency used in the test.  See `levene`</span></div>
<div class="line"><span class="lineno"> 2792</span><span class="stringliteral">    for more information.</span></div>
<div class="line"><span class="lineno"> 2793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2794</span><span class="stringliteral">    Conover et al. (1981) examine many of the existing parametric and</span></div>
<div class="line"><span class="lineno"> 2795</span><span class="stringliteral">    nonparametric tests by extensive simulations and they conclude that the</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral">    tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be</span></div>
<div class="line"><span class="lineno"> 2797</span><span class="stringliteral">    superior in terms of robustness of departures from normality and power [3]_.</span></div>
<div class="line"><span class="lineno"> 2798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2799</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2800</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2801</span><span class="stringliteral">    .. [1] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and</span></div>
<div class="line"><span class="lineno"> 2802</span><span class="stringliteral">           Hypothesis Testing based on Quadratic Inference Function. Technical</span></div>
<div class="line"><span class="lineno"> 2803</span><span class="stringliteral">           Report #99-03, Center for Likelihood Studies, Pennsylvania State</span></div>
<div class="line"><span class="lineno"> 2804</span><span class="stringliteral">           University.</span></div>
<div class="line"><span class="lineno"> 2805</span><span class="stringliteral">           https://cecas.clemson.edu/~cspark/cv/paper/qif/draftqif2.pdf</span></div>
<div class="line"><span class="lineno"> 2806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2807</span><span class="stringliteral">    .. [2] Fligner, M.A. and Killeen, T.J. (1976). Distribution-free two-sample</span></div>
<div class="line"><span class="lineno"> 2808</span><span class="stringliteral">           tests for scale. &#39;Journal of the American Statistical Association.&#39;</span></div>
<div class="line"><span class="lineno"> 2809</span><span class="stringliteral">           71(353), 210-213.</span></div>
<div class="line"><span class="lineno"> 2810</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2811</span><span class="stringliteral">    .. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and</span></div>
<div class="line"><span class="lineno"> 2812</span><span class="stringliteral">           Hypothesis Testing based on Quadratic Inference Function. Technical</span></div>
<div class="line"><span class="lineno"> 2813</span><span class="stringliteral">           Report #99-03, Center for Likelihood Studies, Pennsylvania State</span></div>
<div class="line"><span class="lineno"> 2814</span><span class="stringliteral">           University.</span></div>
<div class="line"><span class="lineno"> 2815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2816</span><span class="stringliteral">    .. [4] Conover, W. J., Johnson, M. E. and Johnson M. M. (1981). A</span></div>
<div class="line"><span class="lineno"> 2817</span><span class="stringliteral">           comparative study of tests for homogeneity of variances, with</span></div>
<div class="line"><span class="lineno"> 2818</span><span class="stringliteral">           applications to the outer continental shelf biding data.</span></div>
<div class="line"><span class="lineno"> 2819</span><span class="stringliteral">           Technometrics, 23(4), 351-361.</span></div>
<div class="line"><span class="lineno"> 2820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2821</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2822</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2823</span><span class="stringliteral">    Test whether or not the lists `a`, `b` and `c` come from populations</span></div>
<div class="line"><span class="lineno"> 2824</span><span class="stringliteral">    with equal variances.</span></div>
<div class="line"><span class="lineno"> 2825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2826</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import fligner</span></div>
<div class="line"><span class="lineno"> 2827</span><span class="stringliteral">    &gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]</span></div>
<div class="line"><span class="lineno"> 2828</span><span class="stringliteral">    &gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]</span></div>
<div class="line"><span class="lineno"> 2829</span><span class="stringliteral">    &gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]</span></div>
<div class="line"><span class="lineno"> 2830</span><span class="stringliteral">    &gt;&gt;&gt; stat, p = fligner(a, b, c)</span></div>
<div class="line"><span class="lineno"> 2831</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 2832</span><span class="stringliteral">    0.00450826080004775</span></div>
<div class="line"><span class="lineno"> 2833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2834</span><span class="stringliteral">    The small p-value suggests that the populations do not have equal</span></div>
<div class="line"><span class="lineno"> 2835</span><span class="stringliteral">    variances.</span></div>
<div class="line"><span class="lineno"> 2836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2837</span><span class="stringliteral">    This is not surprising, given that the sample variance of `b` is much</span></div>
<div class="line"><span class="lineno"> 2838</span><span class="stringliteral">    larger than that of `a` and `c`:</span></div>
<div class="line"><span class="lineno"> 2839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2840</span><span class="stringliteral">    &gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]</span></div>
<div class="line"><span class="lineno"> 2841</span><span class="stringliteral">    [0.007054444444444413, 0.13073888888888888, 0.008890000000000002]</span></div>
<div class="line"><span class="lineno"> 2842</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2843</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2844</span>    <span class="keywordflow">if</span> center <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;mean&#39;</span>, <span class="stringliteral">&#39;median&#39;</span>, <span class="stringliteral">&#39;trimmed&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2845</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;center must be &#39;mean&#39;, &#39;median&#39; or &#39;trimmed&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2846</span> </div>
<div class="line"><span class="lineno"> 2847</span>    <span class="comment"># Handle empty input</span></div>
<div class="line"><span class="lineno"> 2848</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples:</div>
<div class="line"><span class="lineno"> 2849</span>        <span class="keywordflow">if</span> np.asanyarray(sample).size == 0:</div>
<div class="line"><span class="lineno"> 2850</span>            <span class="keywordflow">return</span> FlignerResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 2851</span> </div>
<div class="line"><span class="lineno"> 2852</span>    k = len(samples)</div>
<div class="line"><span class="lineno"> 2853</span>    <span class="keywordflow">if</span> k &lt; 2:</div>
<div class="line"><span class="lineno"> 2854</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Must enter at least two input sample vectors.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2855</span> </div>
<div class="line"><span class="lineno"> 2856</span>    <span class="keywordflow">if</span> center == <span class="stringliteral">&#39;median&#39;</span>:</div>
<div class="line"><span class="lineno"> 2857</span>        func = <span class="keyword">lambda</span> x: np.median(x, axis=0)</div>
<div class="line"><span class="lineno"> 2858</span>    <span class="keywordflow">elif</span> center == <span class="stringliteral">&#39;mean&#39;</span>:</div>
<div class="line"><span class="lineno"> 2859</span>        func = <span class="keyword">lambda</span> x: np.mean(x, axis=0)</div>
<div class="line"><span class="lineno"> 2860</span>    <span class="keywordflow">else</span>:  <span class="comment"># center == &#39;trimmed&#39;</span></div>
<div class="line"><span class="lineno"> 2861</span>        samples = tuple(_stats_py.trimboth(sample, proportiontocut)</div>
<div class="line"><span class="lineno"> 2862</span>                        <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples)</div>
<div class="line"><span class="lineno"> 2863</span>        func = <span class="keyword">lambda</span> x: np.mean(x, axis=0)</div>
<div class="line"><span class="lineno"> 2864</span> </div>
<div class="line"><span class="lineno"> 2865</span>    Ni = asarray([len(samples[j]) <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(k)])</div>
<div class="line"><span class="lineno"> 2866</span>    Yci = asarray([<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(samples[j]) <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(k)])</div>
<div class="line"><span class="lineno"> 2867</span>    Ntot = np.sum(Ni, axis=0)</div>
<div class="line"><span class="lineno"> 2868</span>    <span class="comment"># compute Zij&#39;s</span></div>
<div class="line"><span class="lineno"> 2869</span>    Zij = [abs(asarray(samples[i]) - Yci[i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k)]</div>
<div class="line"><span class="lineno"> 2870</span>    allZij = []</div>
<div class="line"><span class="lineno"> 2871</span>    g = [0]</div>
<div class="line"><span class="lineno"> 2872</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 2873</span>        allZij.extend(list(Zij[i]))</div>
<div class="line"><span class="lineno"> 2874</span>        g.append(len(allZij))</div>
<div class="line"><span class="lineno"> 2875</span> </div>
<div class="line"><span class="lineno"> 2876</span>    ranks = _stats_py.rankdata(allZij)</div>
<div class="line"><span class="lineno"> 2877</span>    sample = distributions.norm.ppf(ranks / (2*(Ntot + 1.0)) + 0.5)</div>
<div class="line"><span class="lineno"> 2878</span> </div>
<div class="line"><span class="lineno"> 2879</span>    <span class="comment"># compute Aibar</span></div>
<div class="line"><span class="lineno"> 2880</span>    Aibar = _apply_func(sample, g, np.sum) / Ni</div>
<div class="line"><span class="lineno"> 2881</span>    anbar = np.mean(sample, axis=0)</div>
<div class="line"><span class="lineno"> 2882</span>    varsq = np.var(sample, axis=0, ddof=1)</div>
<div class="line"><span class="lineno"> 2883</span>    Xsq = np.sum(Ni * (asarray(Aibar) - anbar)**2.0, axis=0) / varsq</div>
<div class="line"><span class="lineno"> 2884</span>    pval = distributions.chi2.sf(Xsq, k - 1)  <span class="comment"># 1 - cdf</span></div>
<div class="line"><span class="lineno"> 2885</span>    <span class="keywordflow">return</span> FlignerResult(Xsq, pval)</div>
<div class="line"><span class="lineno"> 2886</span> </div>
<div class="line"><span class="lineno"> 2887</span> </div>
<div class="line"><span class="lineno"> 2888</span><span class="preprocessor">@_axis_nan_policy_factory(lambda x1: (x1,)</span>, n_samples=4, n_outputs=1)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4240a80fd709860b5a63acf219991dcf" name="a4240a80fd709860b5a63acf219991dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4240a80fd709860b5a63acf219991dcf">&#9670;&#160;</a></span>kstat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.kstat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the nth k-statistic (1&lt;=n&lt;=4 so far).

The nth k-statistic k_n is the unique symmetric unbiased estimator of the
nth cumulant kappa_n.

Parameters
----------
data : array_like
    Input array. Note that n-D input gets flattened.
n : int, {1, 2, 3, 4}, optional
    Default is equal to 2.

Returns
-------
kstat : float
    The nth k-statistic.

See Also
--------
kstatvar: Returns an unbiased estimator of the variance of the k-statistic.
moment: Returns the n-th central moment about the mean for a sample.

Notes
-----
For a sample size n, the first few k-statistics are given by:

.. math::

    k_{1} = \mu
    k_{2} = \frac{n}{n-1} m_{2}
    k_{3} = \frac{ n^{2} } {(n-1) (n-2)} m_{3}
    k_{4} = \frac{ n^{2} [(n + 1)m_{4} - 3(n - 1) m^2_{2}]} {(n-1) (n-2) (n-3)}

where :math:`\mu` is the sample mean, :math:`m_2` is the sample
variance, and :math:`m_i` is the i-th sample central moment.

References
----------
http://mathworld.wolfram.com/k-Statistic.html

http://mathworld.wolfram.com/Cumulant.html

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng()

As sample size increases, n-th moment and n-th k-statistic converge to the
same number (although they aren't identical). In the case of the normal
distribution, they converge to zero.

&gt;&gt;&gt; for n in [2, 3, 4, 5, 6, 7]:
...     x = rng.normal(size=10**n)
...     m, k = stats.moment(x, 3), stats.kstat(x, 3)
...     print("%.3g %.3g %.3g" % (m, k, m-k))
-0.631 -0.651 0.0194  # random
0.0282 0.0283 -8.49e-05
-0.0454 -0.0454 1.36e-05
7.53e-05 7.53e-05 -2.26e-09
0.00166 0.00166 -4.99e-09
-2.88e-06 -2.88e-06 8.63e-13
</pre> <div class="fragment"><div class="line"><span class="lineno">  220</span><span class="keyword">def </span>kstat(data, n=2):</div>
<div class="line"><span class="lineno">  221</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    Return the nth k-statistic (1&lt;=n&lt;=4 so far).</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    The nth k-statistic k_n is the unique symmetric unbiased estimator of the</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    nth cumulant kappa_n.</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        Input array. Note that n-D input gets flattened.</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    n : int, {1, 2, 3, 4}, optional</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        Default is equal to 2.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    kstat : float</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        The nth k-statistic.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    kstatvar: Returns an unbiased estimator of the variance of the k-statistic.</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    moment: Returns the n-th central moment about the mean for a sample.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    For a sample size n, the first few k-statistics are given by:</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">        k_{1} = \mu</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        k_{2} = \frac{n}{n-1} m_{2}</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        k_{3} = \frac{ n^{2} } {(n-1) (n-2)} m_{3}</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        k_{4} = \frac{ n^{2} [(n + 1)m_{4} - 3(n - 1) m^2_{2}]} {(n-1) (n-2) (n-3)}</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    where :math:`\mu` is the sample mean, :math:`m_2` is the sample</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    variance, and :math:`m_i` is the i-th sample central moment.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    http://mathworld.wolfram.com/k-Statistic.html</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    http://mathworld.wolfram.com/Cumulant.html</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    As sample size increases, n-th moment and n-th k-statistic converge to the</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    same number (although they aren&#39;t identical). In the case of the normal</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    distribution, they converge to zero.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    &gt;&gt;&gt; for n in [2, 3, 4, 5, 6, 7]:</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    ...     x = rng.normal(size=10**n)</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    ...     m, k = stats.moment(x, 3), stats.kstat(x, 3)</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    ...     print(&quot;%.3g %.3g %.3g&quot; % (m, k, m-k))</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    -0.631 -0.651 0.0194  # random</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    0.0282 0.0283 -8.49e-05</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    -0.0454 -0.0454 1.36e-05</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    7.53e-05 7.53e-05 -2.26e-09</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    0.00166 0.00166 -4.99e-09</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    -2.88e-06 -2.88e-06 8.63e-13</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">if</span> n &gt; 4 <span class="keywordflow">or</span> n &lt; 1:</div>
<div class="line"><span class="lineno">  286</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;k-statistics only supported for 1&lt;=n&lt;=4&quot;</span>)</div>
<div class="line"><span class="lineno">  287</span>    n = int(n)</div>
<div class="line"><span class="lineno">  288</span>    S = np.zeros(n + 1, np.float64)</div>
<div class="line"><span class="lineno">  289</span>    data = ravel(data)</div>
<div class="line"><span class="lineno">  290</span>    N = data.size</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>    <span class="comment"># raise ValueError on empty input</span></div>
<div class="line"><span class="lineno">  293</span>    <span class="keywordflow">if</span> N == 0:</div>
<div class="line"><span class="lineno">  294</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data input must not be empty&quot;</span>)</div>
<div class="line"><span class="lineno">  295</span> </div>
<div class="line"><span class="lineno">  296</span>    <span class="comment"># on nan input, return nan without warning</span></div>
<div class="line"><span class="lineno">  297</span>    <span class="keywordflow">if</span> np.isnan(np.sum(data)):</div>
<div class="line"><span class="lineno">  298</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno">  299</span> </div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(1, n + 1):</div>
<div class="line"><span class="lineno">  301</span>        S[k] = np.sum(data**k, axis=0)</div>
<div class="line"><span class="lineno">  302</span>    <span class="keywordflow">if</span> n == 1:</div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordflow">return</span> S[1] * 1.0/N</div>
<div class="line"><span class="lineno">  304</span>    <span class="keywordflow">elif</span> n == 2:</div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordflow">return</span> (N*S[2] - S[1]**2.0) / (N*(N - 1.0))</div>
<div class="line"><span class="lineno">  306</span>    <span class="keywordflow">elif</span> n == 3:</div>
<div class="line"><span class="lineno">  307</span>        <span class="keywordflow">return</span> (2*S[1]**3 - 3*N*S[1]*S[2] + N*N*S[3]) / (N*(N - 1.0)*(N - 2.0))</div>
<div class="line"><span class="lineno">  308</span>    <span class="keywordflow">elif</span> n == 4:</div>
<div class="line"><span class="lineno">  309</span>        <span class="keywordflow">return</span> ((-6*S[1]**4 + 12*N*S[1]**2 * S[2] - 3*N*(N-1.0)*S[2]**2 -</div>
<div class="line"><span class="lineno">  310</span>                 4*N*(N+1)*S[1]*S[3] + N*N*(N+1)*S[4]) /</div>
<div class="line"><span class="lineno">  311</span>                 (N*(N-1.0)*(N-2.0)*(N-3.0)))</div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  313</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Should not be here.&quot;</span>)</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno">  317</span>    <span class="keyword">lambda</span> x: x, result_to_tuple=<span class="keyword">lambda</span> x: (x,), n_outputs=1, default_axis=<span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  318</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8a9f133ef967d3f334ef8b7fc573983" name="ab8a9f133ef967d3f334ef8b7fc573983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a9f133ef967d3f334ef8b7fc573983">&#9670;&#160;</a></span>kstatvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.kstatvar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an unbiased estimator of the variance of the k-statistic.

See `kstat` for more details of the k-statistic.

Parameters
----------
data : array_like
Input array. Note that n-D input gets flattened.
n : int, {1, 2}, optional
Default is equal to 2.

Returns
-------
kstatvar : float
The nth k-statistic variance.

See Also
--------
kstat: Returns the n-th k-statistic.
moment: Returns the n-th central moment about the mean for a sample.

Notes
-----
The variances of the first few k-statistics are given by:

.. math::

var(k_{1}) = \frac{\kappa^2}{n}
var(k_{2}) = \frac{\kappa^4}{n} + \frac{2\kappa^2_{2}}{n - 1}
var(k_{3}) = \frac{\kappa^6}{n} + \frac{9 \kappa_2 \kappa_4}{n - 1} +
    \frac{9 \kappa^2_{3}}{n - 1} +
    \frac{6 n \kappa^3_{2}}{(n-1) (n-2)}
var(k_{4}) = \frac{\kappa^8}{n} + \frac{16 \kappa_2 \kappa_6}{n - 1} +
    \frac{48 \kappa_{3} \kappa_5}{n - 1} +
    \frac{34 \kappa^2_{4}}{n-1} + \frac{72 n \kappa^2_{2} \kappa_4}{(n - 1) (n - 2)} +
    \frac{144 n \kappa_{2} \kappa^2_{3}}{(n - 1) (n - 2)} +
    \frac{24 (n + 1) n \kappa^4_{2}}{(n - 1) (n - 2) (n - 3)}
</pre> <div class="fragment"><div class="line"><span class="lineno">  319</span><span class="keyword">def </span>kstatvar(data, n=2):</div>
<div class="line"><span class="lineno">  320</span>    <span class="stringliteral">r&quot;&quot;&quot;Return an unbiased estimator of the variance of the k-statistic.</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    See `kstat` for more details of the k-statistic.</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        Input array. Note that n-D input gets flattened.</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    n : int, {1, 2}, optional</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        Default is equal to 2.</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    kstatvar : float</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        The nth k-statistic variance.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    kstat: Returns the n-th k-statistic.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    moment: Returns the n-th central moment about the mean for a sample.</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    The variances of the first few k-statistics are given by:</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">        var(k_{1}) = \frac{\kappa^2}{n}</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        var(k_{2}) = \frac{\kappa^4}{n} + \frac{2\kappa^2_{2}}{n - 1}</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">        var(k_{3}) = \frac{\kappa^6}{n} + \frac{9 \kappa_2 \kappa_4}{n - 1} +</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">                     \frac{9 \kappa^2_{3}}{n - 1} +</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">                     \frac{6 n \kappa^3_{2}}{(n-1) (n-2)}</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        var(k_{4}) = \frac{\kappa^8}{n} + \frac{16 \kappa_2 \kappa_6}{n - 1} +</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">                     \frac{48 \kappa_{3} \kappa_5}{n - 1} +</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">                     \frac{34 \kappa^2_{4}}{n-1} + \frac{72 n \kappa^2_{2} \kappa_4}{(n - 1) (n - 2)} +</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">                     \frac{144 n \kappa_{2} \kappa^2_{3}}{(n - 1) (n - 2)} +</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">                     \frac{24 (n + 1) n \kappa^4_{2}}{(n - 1) (n - 2) (n - 3)}</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  358</span>    data = ravel(data)</div>
<div class="line"><span class="lineno">  359</span>    N = len(data)</div>
<div class="line"><span class="lineno">  360</span>    <span class="keywordflow">if</span> n == 1:</div>
<div class="line"><span class="lineno">  361</span>        <span class="keywordflow">return</span> kstat(data, n=2) * 1.0/N</div>
<div class="line"><span class="lineno">  362</span>    <span class="keywordflow">elif</span> n == 2:</div>
<div class="line"><span class="lineno">  363</span>        k2 = kstat(data, n=2)</div>
<div class="line"><span class="lineno">  364</span>        k4 = kstat(data, n=4)</div>
<div class="line"><span class="lineno">  365</span>        <span class="keywordflow">return</span> (2*N*k2**2 + (N-1)*k4) / (N*(N+1))</div>
<div class="line"><span class="lineno">  366</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  367</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Only n=1 or n=2 supported.&quot;</span>)</div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa23262638e4d8d639649530a5a7cf2d8" name="aa23262638e4d8d639649530a5a7cf2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23262638e4d8d639649530a5a7cf2d8">&#9670;&#160;</a></span>levene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.levene </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>'median'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proportiontocut</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Levene test for equal variances.

The Levene test tests the null hypothesis that all input samples
are from populations with equal variances.  Levene's test is an
alternative to Bartlett's test `bartlett` in the case where
there are significant deviations from normality.

Parameters
----------
sample1, sample2, ... : array_like
    The sample data, possibly with different lengths. Only one-dimensional
    samples are accepted.
center : {'mean', 'median', 'trimmed'}, optional
    Which function of the data to use in the test.  The default
    is 'median'.
proportiontocut : float, optional
    When `center` is 'trimmed', this gives the proportion of data points
    to cut from each end. (See `scipy.stats.trim_mean`.)
    Default is 0.05.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value for the test.

Notes
-----
Three variations of Levene's test are possible.  The possibilities
and their recommended usages are:

  * 'median' : Recommended for skewed (non-normal) distributions&gt;
  * 'mean' : Recommended for symmetric, moderate-tailed distributions.
  * 'trimmed' : Recommended for heavy-tailed distributions.

The test version using the mean was proposed in the original article
of Levene ([2]_) while the median and trimmed mean have been studied by
Brown and Forsythe ([3]_), sometimes also referred to as Brown-Forsythe
test.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm
.. [2] Levene, H. (1960). In Contributions to Probability and Statistics:
       Essays in Honor of Harold Hotelling, I. Olkin et al. eds.,
       Stanford University Press, pp. 278-292.
.. [3] Brown, M. B. and Forsythe, A. B. (1974), Journal of the American
       Statistical Association, 69, 364-367

Examples
--------
Test whether or not the lists `a`, `b` and `c` come from populations
with equal variances.

&gt;&gt;&gt; from scipy.stats import levene
&gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
&gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
&gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
&gt;&gt;&gt; stat, p = levene(a, b, c)
&gt;&gt;&gt; p
0.002431505967249681

The small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

&gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]</pre> <div class="fragment"><div class="line"><span class="lineno"> 2519</span><span class="keyword">def </span>levene(*samples, center=&#39;median&#39;, proportiontocut=0.05):</div>
<div class="line"><span class="lineno"> 2520</span>    <span class="stringliteral">&quot;&quot;&quot;Perform Levene test for equal variances.</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">    The Levene test tests the null hypothesis that all input samples</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral">    are from populations with equal variances.  Levene&#39;s test is an</span></div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">    alternative to Bartlett&#39;s test `bartlett` in the case where</span></div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral">    there are significant deviations from normality.</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">        The sample data, possibly with different lengths. Only one-dimensional</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral">        samples are accepted.</span></div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">    center : {&#39;mean&#39;, &#39;median&#39;, &#39;trimmed&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">        Which function of the data to use in the test.  The default</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">        is &#39;median&#39;.</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">    proportiontocut : float, optional</span></div>
<div class="line"><span class="lineno"> 2536</span><span class="stringliteral">        When `center` is &#39;trimmed&#39;, this gives the proportion of data points</span></div>
<div class="line"><span class="lineno"> 2537</span><span class="stringliteral">        to cut from each end. (See `scipy.stats.trim_mean`.)</span></div>
<div class="line"><span class="lineno"> 2538</span><span class="stringliteral">        Default is 0.05.</span></div>
<div class="line"><span class="lineno"> 2539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2540</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral">        The test statistic.</span></div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral">        The p-value for the test.</span></div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral">    Three variations of Levene&#39;s test are possible.  The possibilities</span></div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral">    and their recommended usages are:</span></div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral">      * &#39;median&#39; : Recommended for skewed (non-normal) distributions&gt;</span></div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral">      * &#39;mean&#39; : Recommended for symmetric, moderate-tailed distributions.</span></div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral">      * &#39;trimmed&#39; : Recommended for heavy-tailed distributions.</span></div>
<div class="line"><span class="lineno"> 2555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2556</span><span class="stringliteral">    The test version using the mean was proposed in the original article</span></div>
<div class="line"><span class="lineno"> 2557</span><span class="stringliteral">    of Levene ([2]_) while the median and trimmed mean have been studied by</span></div>
<div class="line"><span class="lineno"> 2558</span><span class="stringliteral">    Brown and Forsythe ([3]_), sometimes also referred to as Brown-Forsythe</span></div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral">    test.</span></div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">    .. [1] https://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">    .. [2] Levene, H. (1960). In Contributions to Probability and Statistics:</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral">           Essays in Honor of Harold Hotelling, I. Olkin et al. eds.,</span></div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">           Stanford University Press, pp. 278-292.</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">    .. [3] Brown, M. B. and Forsythe, A. B. (1974), Journal of the American</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral">           Statistical Association, 69, 364-367</span></div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral">    Test whether or not the lists `a`, `b` and `c` come from populations</span></div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">    with equal variances.</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import levene</span></div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral">    &gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]</span></div>
<div class="line"><span class="lineno"> 2577</span><span class="stringliteral">    &gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]</span></div>
<div class="line"><span class="lineno"> 2578</span><span class="stringliteral">    &gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]</span></div>
<div class="line"><span class="lineno"> 2579</span><span class="stringliteral">    &gt;&gt;&gt; stat, p = levene(a, b, c)</span></div>
<div class="line"><span class="lineno"> 2580</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 2581</span><span class="stringliteral">    0.002431505967249681</span></div>
<div class="line"><span class="lineno"> 2582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2583</span><span class="stringliteral">    The small p-value suggests that the populations do not have equal</span></div>
<div class="line"><span class="lineno"> 2584</span><span class="stringliteral">    variances.</span></div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral">    This is not surprising, given that the sample variance of `b` is much</span></div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral">    larger than that of `a` and `c`:</span></div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral">    &gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]</span></div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">    [0.007054444444444413, 0.13073888888888888, 0.008890000000000002]</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2593</span>    <span class="keywordflow">if</span> center <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;mean&#39;</span>, <span class="stringliteral">&#39;median&#39;</span>, <span class="stringliteral">&#39;trimmed&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2594</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;center must be &#39;mean&#39;, &#39;median&#39; or &#39;trimmed&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2595</span> </div>
<div class="line"><span class="lineno"> 2596</span>    k = len(samples)</div>
<div class="line"><span class="lineno"> 2597</span>    <span class="keywordflow">if</span> k &lt; 2:</div>
<div class="line"><span class="lineno"> 2598</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Must enter at least two input sample vectors.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2599</span>    <span class="comment"># check for 1d input</span></div>
<div class="line"><span class="lineno"> 2600</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 2601</span>        <span class="keywordflow">if</span> np.asanyarray(samples[j]).ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2602</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Samples must be one-dimensional.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2603</span> </div>
<div class="line"><span class="lineno"> 2604</span>    Ni = np.empty(k)</div>
<div class="line"><span class="lineno"> 2605</span>    Yci = np.empty(k, <span class="stringliteral">&#39;d&#39;</span>)</div>
<div class="line"><span class="lineno"> 2606</span> </div>
<div class="line"><span class="lineno"> 2607</span>    <span class="keywordflow">if</span> center == <span class="stringliteral">&#39;median&#39;</span>:</div>
<div class="line"><span class="lineno"> 2608</span>        func = <span class="keyword">lambda</span> x: np.median(x, axis=0)</div>
<div class="line"><span class="lineno"> 2609</span>    <span class="keywordflow">elif</span> center == <span class="stringliteral">&#39;mean&#39;</span>:</div>
<div class="line"><span class="lineno"> 2610</span>        func = <span class="keyword">lambda</span> x: np.mean(x, axis=0)</div>
<div class="line"><span class="lineno"> 2611</span>    <span class="keywordflow">else</span>:  <span class="comment"># center == &#39;trimmed&#39;</span></div>
<div class="line"><span class="lineno"> 2612</span>        samples = tuple(_stats_py.trimboth(np.sort(sample), proportiontocut)</div>
<div class="line"><span class="lineno"> 2613</span>                        <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples)</div>
<div class="line"><span class="lineno"> 2614</span>        func = <span class="keyword">lambda</span> x: np.mean(x, axis=0)</div>
<div class="line"><span class="lineno"> 2615</span> </div>
<div class="line"><span class="lineno"> 2616</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 2617</span>        Ni[j] = len(samples[j])</div>
<div class="line"><span class="lineno"> 2618</span>        Yci[j] = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(samples[j])</div>
<div class="line"><span class="lineno"> 2619</span>    Ntot = np.sum(Ni, axis=0)</div>
<div class="line"><span class="lineno"> 2620</span> </div>
<div class="line"><span class="lineno"> 2621</span>    <span class="comment"># compute Zij&#39;s</span></div>
<div class="line"><span class="lineno"> 2622</span>    Zij = [<span class="keywordtype">None</span>] * k</div>
<div class="line"><span class="lineno"> 2623</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 2624</span>        Zij[i] = abs(asarray(samples[i]) - Yci[i])</div>
<div class="line"><span class="lineno"> 2625</span> </div>
<div class="line"><span class="lineno"> 2626</span>    <span class="comment"># compute Zbari</span></div>
<div class="line"><span class="lineno"> 2627</span>    Zbari = np.empty(k, <span class="stringliteral">&#39;d&#39;</span>)</div>
<div class="line"><span class="lineno"> 2628</span>    Zbar = 0.0</div>
<div class="line"><span class="lineno"> 2629</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 2630</span>        Zbari[i] = np.mean(Zij[i], axis=0)</div>
<div class="line"><span class="lineno"> 2631</span>        Zbar += Zbari[i] * Ni[i]</div>
<div class="line"><span class="lineno"> 2632</span> </div>
<div class="line"><span class="lineno"> 2633</span>    Zbar /= Ntot</div>
<div class="line"><span class="lineno"> 2634</span>    numer = (Ntot - k) * np.sum(Ni * (Zbari - Zbar)**2, axis=0)</div>
<div class="line"><span class="lineno"> 2635</span> </div>
<div class="line"><span class="lineno"> 2636</span>    <span class="comment"># compute denom_variance</span></div>
<div class="line"><span class="lineno"> 2637</span>    dvar = 0.0</div>
<div class="line"><span class="lineno"> 2638</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno"> 2639</span>        dvar += np.sum((Zij[i] - Zbari[i])**2, axis=0)</div>
<div class="line"><span class="lineno"> 2640</span> </div>
<div class="line"><span class="lineno"> 2641</span>    denom = (k - 1.0) * dvar</div>
<div class="line"><span class="lineno"> 2642</span> </div>
<div class="line"><span class="lineno"> 2643</span>    W = numer / denom</div>
<div class="line"><span class="lineno"> 2644</span>    pval = distributions.f.sf(W, k-1, Ntot-k)  <span class="comment"># 1 - cdf</span></div>
<div class="line"><span class="lineno"> 2645</span>    <span class="keywordflow">return</span> LeveneResult(W, pval)</div>
<div class="line"><span class="lineno"> 2646</span> </div>
<div class="line"><span class="lineno"> 2647</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9d69aee9a069d7a4cec2d2cc5ab55a6" name="aa9d69aee9a069d7a4cec2d2cc5ab55a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d69aee9a069d7a4cec2d2cc5ab55a6">&#9670;&#160;</a></span>median_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.median_test </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ties</em> = <code>'below'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>correction</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lambda_</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a Mood's median test.

Test that two or more samples come from populations with the same median.

Let ``n = len(samples)`` be the number of samples.  The "grand median" of
all the data is computed, and a contingency table is formed by
classifying the values in each sample as being above or below the grand
median.  The contingency table, along with `correction` and `lambda_`,
are passed to `scipy.stats.chi2_contingency` to compute the test statistic
and p-value.

Parameters
----------
sample1, sample2, ... : array_like
    The set of samples.  There must be at least two samples.
    Each sample must be a one-dimensional sequence containing at least
    one value.  The samples are not required to have the same length.
ties : str, optional
    Determines how values equal to the grand median are classified in
    the contingency table.  The string must be one of::

        "below":
            Values equal to the grand median are counted as "below".
        "above":
            Values equal to the grand median are counted as "above".
        "ignore":
            Values equal to the grand median are not counted.

    The default is "below".
correction : bool, optional
    If True, *and* there are just two samples, apply Yates' correction
    for continuity when computing the test statistic associated with
    the contingency table.  Default is True.
lambda_ : float or str, optional
    By default, the statistic computed in this test is Pearson's
    chi-squared statistic.  `lambda_` allows a statistic from the
    Cressie-Read power divergence family to be used instead.  See
    `power_divergence` for details.
    Default is 1 (Pearson's chi-squared statistic).
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
stat : float
    The test statistic.  The statistic that is returned is determined by
    `lambda_`.  The default is Pearson's chi-squared statistic.
p : float
    The p-value of the test.
m : float
    The grand median.
table : ndarray
    The contingency table.  The shape of the table is (2, n), where
    n is the number of samples.  The first row holds the counts of the
    values above the grand median, and the second row holds the counts
    of the values below the grand median.  The table allows further
    analysis with, for example, `scipy.stats.chi2_contingency`, or with
    `scipy.stats.fisher_exact` if there are two samples, without having
    to recompute the table.  If ``nan_policy`` is "propagate" and there
    are nans in the input, the return value for ``table`` is ``None``.

See Also
--------
kruskal : Compute the Kruskal-Wallis H-test for independent samples.
mannwhitneyu : Computes the Mann-Whitney rank test on samples x and y.

Notes
-----
.. versionadded:: 0.15.0

References
----------
.. [1] Mood, A. M., Introduction to the Theory of Statistics. McGraw-Hill
    (1950), pp. 394-399.
.. [2] Zar, J. H., Biostatistical Analysis, 5th ed. Prentice Hall (2010).
    See Sections 8.12 and 10.15.

Examples
--------
A biologist runs an experiment in which there are three groups of plants.
Group 1 has 16 plants, group 2 has 15 plants, and group 3 has 17 plants.
Each plant produces a number of seeds.  The seed counts for each group
are::

    Group 1: 10 14 14 18 20 22 24 25 31 31 32 39 43 43 48 49
    Group 2: 28 30 31 33 34 35 36 40 44 55 57 61 91 92 99
    Group 3:  0  3  9 22 23 25 25 33 34 34 40 45 46 48 62 67 84

The following code applies Mood's median test to these samples.

&gt;&gt;&gt; g1 = [10, 14, 14, 18, 20, 22, 24, 25, 31, 31, 32, 39, 43, 43, 48, 49]
&gt;&gt;&gt; g2 = [28, 30, 31, 33, 34, 35, 36, 40, 44, 55, 57, 61, 91, 92, 99]
&gt;&gt;&gt; g3 = [0, 3, 9, 22, 23, 25, 25, 33, 34, 34, 40, 45, 46, 48, 62, 67, 84]
&gt;&gt;&gt; from scipy.stats import median_test
&gt;&gt;&gt; stat, p, med, tbl = median_test(g1, g2, g3)

The median is

&gt;&gt;&gt; med
34.0

and the contingency table is

&gt;&gt;&gt; tbl
array([[ 5, 10,  7],
       [11,  5, 10]])

`p` is too large to conclude that the medians are not the same:

&gt;&gt;&gt; p
0.12609082774093244

The "G-test" can be performed by passing ``lambda_="log-likelihood"`` to
`median_test`.

&gt;&gt;&gt; g, p, med, tbl = median_test(g1, g2, g3, lambda_="log-likelihood")
&gt;&gt;&gt; p
0.12224779737117837

The median occurs several times in the data, so we'll get a different
result if, for example, ``ties="above"`` is used:

&gt;&gt;&gt; stat, p, med, tbl = median_test(g1, g2, g3, ties="above")
&gt;&gt;&gt; p
0.063873276069553273

&gt;&gt;&gt; tbl
array([[ 5, 11,  9],
       [11,  4,  8]])

This example demonstrates that if the data set is not large and there
are values equal to the median, the p-value can be sensitive to the
choice of `ties`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3437</span>                nan_policy=<span class="stringliteral">&#39;propagate&#39;</span>):</div>
<div class="line"><span class="lineno"> 3438</span>    <span class="stringliteral">&quot;&quot;&quot;Perform a Mood&#39;s median test.</span></div>
<div class="line"><span class="lineno"> 3439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3440</span><span class="stringliteral">    Test that two or more samples come from populations with the same median.</span></div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral">    Let ``n = len(samples)`` be the number of samples.  The &quot;grand median&quot; of</span></div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral">    all the data is computed, and a contingency table is formed by</span></div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral">    classifying the values in each sample as being above or below the grand</span></div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">    median.  The contingency table, along with `correction` and `lambda_`,</span></div>
<div class="line"><span class="lineno"> 3446</span><span class="stringliteral">    are passed to `scipy.stats.chi2_contingency` to compute the test statistic</span></div>
<div class="line"><span class="lineno"> 3447</span><span class="stringliteral">    and p-value.</span></div>
<div class="line"><span class="lineno"> 3448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3449</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3450</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3451</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 3452</span><span class="stringliteral">        The set of samples.  There must be at least two samples.</span></div>
<div class="line"><span class="lineno"> 3453</span><span class="stringliteral">        Each sample must be a one-dimensional sequence containing at least</span></div>
<div class="line"><span class="lineno"> 3454</span><span class="stringliteral">        one value.  The samples are not required to have the same length.</span></div>
<div class="line"><span class="lineno"> 3455</span><span class="stringliteral">    ties : str, optional</span></div>
<div class="line"><span class="lineno"> 3456</span><span class="stringliteral">        Determines how values equal to the grand median are classified in</span></div>
<div class="line"><span class="lineno"> 3457</span><span class="stringliteral">        the contingency table.  The string must be one of::</span></div>
<div class="line"><span class="lineno"> 3458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3459</span><span class="stringliteral">            &quot;below&quot;:</span></div>
<div class="line"><span class="lineno"> 3460</span><span class="stringliteral">                Values equal to the grand median are counted as &quot;below&quot;.</span></div>
<div class="line"><span class="lineno"> 3461</span><span class="stringliteral">            &quot;above&quot;:</span></div>
<div class="line"><span class="lineno"> 3462</span><span class="stringliteral">                Values equal to the grand median are counted as &quot;above&quot;.</span></div>
<div class="line"><span class="lineno"> 3463</span><span class="stringliteral">            &quot;ignore&quot;:</span></div>
<div class="line"><span class="lineno"> 3464</span><span class="stringliteral">                Values equal to the grand median are not counted.</span></div>
<div class="line"><span class="lineno"> 3465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3466</span><span class="stringliteral">        The default is &quot;below&quot;.</span></div>
<div class="line"><span class="lineno"> 3467</span><span class="stringliteral">    correction : bool, optional</span></div>
<div class="line"><span class="lineno"> 3468</span><span class="stringliteral">        If True, *and* there are just two samples, apply Yates&#39; correction</span></div>
<div class="line"><span class="lineno"> 3469</span><span class="stringliteral">        for continuity when computing the test statistic associated with</span></div>
<div class="line"><span class="lineno"> 3470</span><span class="stringliteral">        the contingency table.  Default is True.</span></div>
<div class="line"><span class="lineno"> 3471</span><span class="stringliteral">    lambda_ : float or str, optional</span></div>
<div class="line"><span class="lineno"> 3472</span><span class="stringliteral">        By default, the statistic computed in this test is Pearson&#39;s</span></div>
<div class="line"><span class="lineno"> 3473</span><span class="stringliteral">        chi-squared statistic.  `lambda_` allows a statistic from the</span></div>
<div class="line"><span class="lineno"> 3474</span><span class="stringliteral">        Cressie-Read power divergence family to be used instead.  See</span></div>
<div class="line"><span class="lineno"> 3475</span><span class="stringliteral">        `power_divergence` for details.</span></div>
<div class="line"><span class="lineno"> 3476</span><span class="stringliteral">        Default is 1 (Pearson&#39;s chi-squared statistic).</span></div>
<div class="line"><span class="lineno"> 3477</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3478</span><span class="stringliteral">        Defines how to handle when input contains nan. &#39;propagate&#39; returns nan,</span></div>
<div class="line"><span class="lineno"> 3479</span><span class="stringliteral">        &#39;raise&#39; throws an error, &#39;omit&#39; performs the calculations ignoring nan</span></div>
<div class="line"><span class="lineno"> 3480</span><span class="stringliteral">        values. Default is &#39;propagate&#39;.</span></div>
<div class="line"><span class="lineno"> 3481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3482</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3483</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3484</span><span class="stringliteral">    stat : float</span></div>
<div class="line"><span class="lineno"> 3485</span><span class="stringliteral">        The test statistic.  The statistic that is returned is determined by</span></div>
<div class="line"><span class="lineno"> 3486</span><span class="stringliteral">        `lambda_`.  The default is Pearson&#39;s chi-squared statistic.</span></div>
<div class="line"><span class="lineno"> 3487</span><span class="stringliteral">    p : float</span></div>
<div class="line"><span class="lineno"> 3488</span><span class="stringliteral">        The p-value of the test.</span></div>
<div class="line"><span class="lineno"> 3489</span><span class="stringliteral">    m : float</span></div>
<div class="line"><span class="lineno"> 3490</span><span class="stringliteral">        The grand median.</span></div>
<div class="line"><span class="lineno"> 3491</span><span class="stringliteral">    table : ndarray</span></div>
<div class="line"><span class="lineno"> 3492</span><span class="stringliteral">        The contingency table.  The shape of the table is (2, n), where</span></div>
<div class="line"><span class="lineno"> 3493</span><span class="stringliteral">        n is the number of samples.  The first row holds the counts of the</span></div>
<div class="line"><span class="lineno"> 3494</span><span class="stringliteral">        values above the grand median, and the second row holds the counts</span></div>
<div class="line"><span class="lineno"> 3495</span><span class="stringliteral">        of the values below the grand median.  The table allows further</span></div>
<div class="line"><span class="lineno"> 3496</span><span class="stringliteral">        analysis with, for example, `scipy.stats.chi2_contingency`, or with</span></div>
<div class="line"><span class="lineno"> 3497</span><span class="stringliteral">        `scipy.stats.fisher_exact` if there are two samples, without having</span></div>
<div class="line"><span class="lineno"> 3498</span><span class="stringliteral">        to recompute the table.  If ``nan_policy`` is &quot;propagate&quot; and there</span></div>
<div class="line"><span class="lineno"> 3499</span><span class="stringliteral">        are nans in the input, the return value for ``table`` is ``None``.</span></div>
<div class="line"><span class="lineno"> 3500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3501</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3502</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3503</span><span class="stringliteral">    kruskal : Compute the Kruskal-Wallis H-test for independent samples.</span></div>
<div class="line"><span class="lineno"> 3504</span><span class="stringliteral">    mannwhitneyu : Computes the Mann-Whitney rank test on samples x and y.</span></div>
<div class="line"><span class="lineno"> 3505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3506</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3507</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3508</span><span class="stringliteral">    .. versionadded:: 0.15.0</span></div>
<div class="line"><span class="lineno"> 3509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3510</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3511</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3512</span><span class="stringliteral">    .. [1] Mood, A. M., Introduction to the Theory of Statistics. McGraw-Hill</span></div>
<div class="line"><span class="lineno"> 3513</span><span class="stringliteral">        (1950), pp. 394-399.</span></div>
<div class="line"><span class="lineno"> 3514</span><span class="stringliteral">    .. [2] Zar, J. H., Biostatistical Analysis, 5th ed. Prentice Hall (2010).</span></div>
<div class="line"><span class="lineno"> 3515</span><span class="stringliteral">        See Sections 8.12 and 10.15.</span></div>
<div class="line"><span class="lineno"> 3516</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3517</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3518</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3519</span><span class="stringliteral">    A biologist runs an experiment in which there are three groups of plants.</span></div>
<div class="line"><span class="lineno"> 3520</span><span class="stringliteral">    Group 1 has 16 plants, group 2 has 15 plants, and group 3 has 17 plants.</span></div>
<div class="line"><span class="lineno"> 3521</span><span class="stringliteral">    Each plant produces a number of seeds.  The seed counts for each group</span></div>
<div class="line"><span class="lineno"> 3522</span><span class="stringliteral">    are::</span></div>
<div class="line"><span class="lineno"> 3523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3524</span><span class="stringliteral">        Group 1: 10 14 14 18 20 22 24 25 31 31 32 39 43 43 48 49</span></div>
<div class="line"><span class="lineno"> 3525</span><span class="stringliteral">        Group 2: 28 30 31 33 34 35 36 40 44 55 57 61 91 92 99</span></div>
<div class="line"><span class="lineno"> 3526</span><span class="stringliteral">        Group 3:  0  3  9 22 23 25 25 33 34 34 40 45 46 48 62 67 84</span></div>
<div class="line"><span class="lineno"> 3527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3528</span><span class="stringliteral">    The following code applies Mood&#39;s median test to these samples.</span></div>
<div class="line"><span class="lineno"> 3529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3530</span><span class="stringliteral">    &gt;&gt;&gt; g1 = [10, 14, 14, 18, 20, 22, 24, 25, 31, 31, 32, 39, 43, 43, 48, 49]</span></div>
<div class="line"><span class="lineno"> 3531</span><span class="stringliteral">    &gt;&gt;&gt; g2 = [28, 30, 31, 33, 34, 35, 36, 40, 44, 55, 57, 61, 91, 92, 99]</span></div>
<div class="line"><span class="lineno"> 3532</span><span class="stringliteral">    &gt;&gt;&gt; g3 = [0, 3, 9, 22, 23, 25, 25, 33, 34, 34, 40, 45, 46, 48, 62, 67, 84]</span></div>
<div class="line"><span class="lineno"> 3533</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import median_test</span></div>
<div class="line"><span class="lineno"> 3534</span><span class="stringliteral">    &gt;&gt;&gt; stat, p, med, tbl = median_test(g1, g2, g3)</span></div>
<div class="line"><span class="lineno"> 3535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3536</span><span class="stringliteral">    The median is</span></div>
<div class="line"><span class="lineno"> 3537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3538</span><span class="stringliteral">    &gt;&gt;&gt; med</span></div>
<div class="line"><span class="lineno"> 3539</span><span class="stringliteral">    34.0</span></div>
<div class="line"><span class="lineno"> 3540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3541</span><span class="stringliteral">    and the contingency table is</span></div>
<div class="line"><span class="lineno"> 3542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3543</span><span class="stringliteral">    &gt;&gt;&gt; tbl</span></div>
<div class="line"><span class="lineno"> 3544</span><span class="stringliteral">    array([[ 5, 10,  7],</span></div>
<div class="line"><span class="lineno"> 3545</span><span class="stringliteral">           [11,  5, 10]])</span></div>
<div class="line"><span class="lineno"> 3546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral">    `p` is too large to conclude that the medians are not the same:</span></div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 3550</span><span class="stringliteral">    0.12609082774093244</span></div>
<div class="line"><span class="lineno"> 3551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3552</span><span class="stringliteral">    The &quot;G-test&quot; can be performed by passing ``lambda_=&quot;log-likelihood&quot;`` to</span></div>
<div class="line"><span class="lineno"> 3553</span><span class="stringliteral">    `median_test`.</span></div>
<div class="line"><span class="lineno"> 3554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3555</span><span class="stringliteral">    &gt;&gt;&gt; g, p, med, tbl = median_test(g1, g2, g3, lambda_=&quot;log-likelihood&quot;)</span></div>
<div class="line"><span class="lineno"> 3556</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 3557</span><span class="stringliteral">    0.12224779737117837</span></div>
<div class="line"><span class="lineno"> 3558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3559</span><span class="stringliteral">    The median occurs several times in the data, so we&#39;ll get a different</span></div>
<div class="line"><span class="lineno"> 3560</span><span class="stringliteral">    result if, for example, ``ties=&quot;above&quot;`` is used:</span></div>
<div class="line"><span class="lineno"> 3561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3562</span><span class="stringliteral">    &gt;&gt;&gt; stat, p, med, tbl = median_test(g1, g2, g3, ties=&quot;above&quot;)</span></div>
<div class="line"><span class="lineno"> 3563</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 3564</span><span class="stringliteral">    0.063873276069553273</span></div>
<div class="line"><span class="lineno"> 3565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral">    &gt;&gt;&gt; tbl</span></div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">    array([[ 5, 11,  9],</span></div>
<div class="line"><span class="lineno"> 3568</span><span class="stringliteral">           [11,  4,  8]])</span></div>
<div class="line"><span class="lineno"> 3569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3570</span><span class="stringliteral">    This example demonstrates that if the data set is not large and there</span></div>
<div class="line"><span class="lineno"> 3571</span><span class="stringliteral">    are values equal to the median, the p-value can be sensitive to the</span></div>
<div class="line"><span class="lineno"> 3572</span><span class="stringliteral">    choice of `ties`.</span></div>
<div class="line"><span class="lineno"> 3573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3575</span>    <span class="keywordflow">if</span> len(samples) &lt; 2:</div>
<div class="line"><span class="lineno"> 3576</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;median_test requires two or more samples.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3577</span> </div>
<div class="line"><span class="lineno"> 3578</span>    ties_options = [<span class="stringliteral">&#39;below&#39;</span>, <span class="stringliteral">&#39;above&#39;</span>, <span class="stringliteral">&#39;ignore&#39;</span>]</div>
<div class="line"><span class="lineno"> 3579</span>    <span class="keywordflow">if</span> ties <span class="keywordflow">not</span> <span class="keywordflow">in</span> ties_options:</div>
<div class="line"><span class="lineno"> 3580</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;invalid &#39;ties&#39; option &#39;%s&#39;; &#39;ties&#39; must be one &quot;</span></div>
<div class="line"><span class="lineno"> 3581</span>                         <span class="stringliteral">&quot;of: %s&quot;</span> % (ties, str(ties_options)[1:-1]))</div>
<div class="line"><span class="lineno"> 3582</span> </div>
<div class="line"><span class="lineno"> 3583</span>    data = [np.asarray(sample) <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples]</div>
<div class="line"><span class="lineno"> 3584</span> </div>
<div class="line"><span class="lineno"> 3585</span>    <span class="comment"># Validate the sizes and shapes of the arguments.</span></div>
<div class="line"><span class="lineno"> 3586</span>    <span class="keywordflow">for</span> k, d <span class="keywordflow">in</span> enumerate(data):</div>
<div class="line"><span class="lineno"> 3587</span>        <span class="keywordflow">if</span> d.size == 0:</div>
<div class="line"><span class="lineno"> 3588</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Sample %d is empty. All samples must &quot;</span></div>
<div class="line"><span class="lineno"> 3589</span>                             <span class="stringliteral">&quot;contain at least one value.&quot;</span> % (k + 1))</div>
<div class="line"><span class="lineno"> 3590</span>        <span class="keywordflow">if</span> d.ndim != 1:</div>
<div class="line"><span class="lineno"> 3591</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Sample %d has %d dimensions.  All &quot;</span></div>
<div class="line"><span class="lineno"> 3592</span>                             <span class="stringliteral">&quot;samples must be one-dimensional sequences.&quot;</span> %</div>
<div class="line"><span class="lineno"> 3593</span>                             (k + 1, d.ndim))</div>
<div class="line"><span class="lineno"> 3594</span> </div>
<div class="line"><span class="lineno"> 3595</span>    cdata = np.concatenate(data)</div>
<div class="line"><span class="lineno"> 3596</span>    contains_nan, nan_policy = _contains_nan(cdata, nan_policy)</div>
<div class="line"><span class="lineno"> 3597</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;propagate&#39;</span>:</div>
<div class="line"><span class="lineno"> 3598</span>        <span class="keywordflow">return</span> np.nan, np.nan, np.nan, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3599</span> </div>
<div class="line"><span class="lineno"> 3600</span>    <span class="keywordflow">if</span> contains_nan:</div>
<div class="line"><span class="lineno"> 3601</span>        grand_median = np.median(cdata[~np.isnan(cdata)])</div>
<div class="line"><span class="lineno"> 3602</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3603</span>        grand_median = np.median(cdata)</div>
<div class="line"><span class="lineno"> 3604</span>    <span class="comment"># When the minimum version of numpy supported by scipy is 1.9.0,</span></div>
<div class="line"><span class="lineno"> 3605</span>    <span class="comment"># the above if/else statement can be replaced by the single line:</span></div>
<div class="line"><span class="lineno"> 3606</span>    <span class="comment">#     grand_median = np.nanmedian(cdata)</span></div>
<div class="line"><span class="lineno"> 3607</span> </div>
<div class="line"><span class="lineno"> 3608</span>    <span class="comment"># Create the contingency table.</span></div>
<div class="line"><span class="lineno"> 3609</span>    table = np.zeros((2, len(data)), dtype=np.int64)</div>
<div class="line"><span class="lineno"> 3610</span>    <span class="keywordflow">for</span> k, sample <span class="keywordflow">in</span> enumerate(data):</div>
<div class="line"><span class="lineno"> 3611</span>        sample = sample[~np.isnan(sample)]</div>
<div class="line"><span class="lineno"> 3612</span> </div>
<div class="line"><span class="lineno"> 3613</span>        nabove = count_nonzero(sample &gt; grand_median)</div>
<div class="line"><span class="lineno"> 3614</span>        nbelow = count_nonzero(sample &lt; grand_median)</div>
<div class="line"><span class="lineno"> 3615</span>        nequal = sample.size - (nabove + nbelow)</div>
<div class="line"><span class="lineno"> 3616</span>        table[0, k] += nabove</div>
<div class="line"><span class="lineno"> 3617</span>        table[1, k] += nbelow</div>
<div class="line"><span class="lineno"> 3618</span>        <span class="keywordflow">if</span> ties == <span class="stringliteral">&quot;below&quot;</span>:</div>
<div class="line"><span class="lineno"> 3619</span>            table[1, k] += nequal</div>
<div class="line"><span class="lineno"> 3620</span>        <span class="keywordflow">elif</span> ties == <span class="stringliteral">&quot;above&quot;</span>:</div>
<div class="line"><span class="lineno"> 3621</span>            table[0, k] += nequal</div>
<div class="line"><span class="lineno"> 3622</span> </div>
<div class="line"><span class="lineno"> 3623</span>    <span class="comment"># Check that no row or column of the table is all zero.</span></div>
<div class="line"><span class="lineno"> 3624</span>    <span class="comment"># Such a table can not be given to chi2_contingency, because it would have</span></div>
<div class="line"><span class="lineno"> 3625</span>    <span class="comment"># a zero in the table of expected frequencies.</span></div>
<div class="line"><span class="lineno"> 3626</span>    rowsums = table.sum(axis=1)</div>
<div class="line"><span class="lineno"> 3627</span>    <span class="keywordflow">if</span> rowsums[0] == 0:</div>
<div class="line"><span class="lineno"> 3628</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All values are below the grand median (%r).&quot;</span> %</div>
<div class="line"><span class="lineno"> 3629</span>                         grand_median)</div>
<div class="line"><span class="lineno"> 3630</span>    <span class="keywordflow">if</span> rowsums[1] == 0:</div>
<div class="line"><span class="lineno"> 3631</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All values are above the grand median (%r).&quot;</span> %</div>
<div class="line"><span class="lineno"> 3632</span>                         grand_median)</div>
<div class="line"><span class="lineno"> 3633</span>    <span class="keywordflow">if</span> ties == <span class="stringliteral">&quot;ignore&quot;</span>:</div>
<div class="line"><span class="lineno"> 3634</span>        <span class="comment"># We already checked that each sample has at least one value, but it</span></div>
<div class="line"><span class="lineno"> 3635</span>        <span class="comment"># is possible that all those values equal the grand median.  If `ties`</span></div>
<div class="line"><span class="lineno"> 3636</span>        <span class="comment"># is &quot;ignore&quot;, that would result in a column of zeros in `table`.  We</span></div>
<div class="line"><span class="lineno"> 3637</span>        <span class="comment"># check for that case here.</span></div>
<div class="line"><span class="lineno"> 3638</span>        zero_cols = np.nonzero((table == 0).all(axis=0))[0]</div>
<div class="line"><span class="lineno"> 3639</span>        <span class="keywordflow">if</span> len(zero_cols) &gt; 0:</div>
<div class="line"><span class="lineno"> 3640</span>            msg = (<span class="stringliteral">&quot;All values in sample %d are equal to the grand &quot;</span></div>
<div class="line"><span class="lineno"> 3641</span>                   <span class="stringliteral">&quot;median (%r), so they are ignored, resulting in an &quot;</span></div>
<div class="line"><span class="lineno"> 3642</span>                   <span class="stringliteral">&quot;empty sample.&quot;</span> % (zero_cols[0] + 1, grand_median))</div>
<div class="line"><span class="lineno"> 3643</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 3644</span> </div>
<div class="line"><span class="lineno"> 3645</span>    stat, p, dof, expected = chi2_contingency(table, lambda_=lambda_,</div>
<div class="line"><span class="lineno"> 3646</span>                                              correction=correction)</div>
<div class="line"><span class="lineno"> 3647</span>    <span class="keywordflow">return</span> stat, p, grand_median, table</div>
<div class="line"><span class="lineno"> 3648</span> </div>
<div class="line"><span class="lineno"> 3649</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2a8c126360ffed1a47ea5ef24d67463" name="aa2a8c126360ffed1a47ea5ef24d67463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a8c126360ffed1a47ea5ef24d67463">&#9670;&#160;</a></span>mood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.mood </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Mood's test for equal scale parameters.

Mood's two-sample test for scale parameters is a non-parametric
test for the null hypothesis that two samples are drawn from the
same distribution with the same scale parameter.

Parameters
----------
x, y : array_like
    Arrays of sample data.
axis : int, optional
    The axis along which the samples are tested.  `x` and `y` can be of
    different length along `axis`.
    If `axis` is None, `x` and `y` are flattened and the test is done on
    all values in the flattened arrays.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the scales of the distributions underlying `x` and `y`
      are different.
    * 'less': the scale of the distribution underlying `x` is less than
      the scale of the distribution underlying `y`.
    * 'greater': the scale of the distribution underlying `x` is greater
      than the scale of the distribution underlying `y`.

    .. versionadded:: 1.7.0

Returns
-------
z : scalar or ndarray
    The z-score for the hypothesis test.  For 1-D inputs a scalar is
    returned.
p-value : scalar ndarray
    The p-value for the hypothesis test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
ansari : A non-parametric test for the equality of 2 variances
bartlett : A parametric test for equality of k variances in normal samples
levene : A parametric test for equality of k variances

Notes
-----
The data are assumed to be drawn from probability distributions ``f(x)``
and ``f(x/s) / s`` respectively, for some probability density function f.
The null hypothesis is that ``s == 1``.

For multi-dimensional arrays, if the inputs are of shapes
``(n0, n1, n2, n3)``  and ``(n0, m1, n2, n3)``, then if ``axis=1``, the
resulting z and p values will have shape ``(n0, n2, n3)``.  Note that
``n1`` and ``m1`` don't have to be equal, but the other dimensions do.

References
----------
[1] Mielke, Paul W. "Note on Some Squared Rank Tests with Existing Ties."
    Technometrics, vol. 9, no. 2, 1967, pp. 312-14. JSTOR,
    https://doi.org/10.2307/1266427. Accessed 18 May 2022.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x2 = rng.standard_normal((2, 45, 6, 7))
&gt;&gt;&gt; x1 = rng.standard_normal((2, 30, 6, 7))
&gt;&gt;&gt; z, p = stats.mood(x1, x2, axis=1)
&gt;&gt;&gt; p.shape
(2, 6, 7)

Find the number of points where the difference in scale is not significant:

&gt;&gt;&gt; (p &gt; 0.1).sum()
78

Perform the test with different scales:

&gt;&gt;&gt; x1 = rng.standard_normal((2, 30))
&gt;&gt;&gt; x2 = rng.standard_normal((2, 35)) * 10.0
&gt;&gt;&gt; stats.mood(x1, x2, axis=1)
(array([-5.76174136, -6.12650783]), array([8.32505043e-09, 8.98287869e-10]))</pre> <div class="fragment"><div class="line"><span class="lineno"> 2962</span><span class="keyword">def </span>mood(x, y, axis=0, alternative=&quot;two-sided&quot;):</div>
<div class="line"><span class="lineno"> 2963</span>    <span class="stringliteral">&quot;&quot;&quot;Perform Mood&#39;s test for equal scale parameters.</span></div>
<div class="line"><span class="lineno"> 2964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2965</span><span class="stringliteral">    Mood&#39;s two-sample test for scale parameters is a non-parametric</span></div>
<div class="line"><span class="lineno"> 2966</span><span class="stringliteral">    test for the null hypothesis that two samples are drawn from the</span></div>
<div class="line"><span class="lineno"> 2967</span><span class="stringliteral">    same distribution with the same scale parameter.</span></div>
<div class="line"><span class="lineno"> 2968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2969</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2970</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2971</span><span class="stringliteral">    x, y : array_like</span></div>
<div class="line"><span class="lineno"> 2972</span><span class="stringliteral">        Arrays of sample data.</span></div>
<div class="line"><span class="lineno"> 2973</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 2974</span><span class="stringliteral">        The axis along which the samples are tested.  `x` and `y` can be of</span></div>
<div class="line"><span class="lineno"> 2975</span><span class="stringliteral">        different length along `axis`.</span></div>
<div class="line"><span class="lineno"> 2976</span><span class="stringliteral">        If `axis` is None, `x` and `y` are flattened and the test is done on</span></div>
<div class="line"><span class="lineno"> 2977</span><span class="stringliteral">        all values in the flattened arrays.</span></div>
<div class="line"><span class="lineno"> 2978</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2979</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 2980</span><span class="stringliteral">        The following options are available:</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2982</span><span class="stringliteral">        * &#39;two-sided&#39;: the scales of the distributions underlying `x` and `y`</span></div>
<div class="line"><span class="lineno"> 2983</span><span class="stringliteral">          are different.</span></div>
<div class="line"><span class="lineno"> 2984</span><span class="stringliteral">        * &#39;less&#39;: the scale of the distribution underlying `x` is less than</span></div>
<div class="line"><span class="lineno"> 2985</span><span class="stringliteral">          the scale of the distribution underlying `y`.</span></div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">        * &#39;greater&#39;: the scale of the distribution underlying `x` is greater</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral">          than the scale of the distribution underlying `y`.</span></div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2993</span><span class="stringliteral">    z : scalar or ndarray</span></div>
<div class="line"><span class="lineno"> 2994</span><span class="stringliteral">        The z-score for the hypothesis test.  For 1-D inputs a scalar is</span></div>
<div class="line"><span class="lineno"> 2995</span><span class="stringliteral">        returned.</span></div>
<div class="line"><span class="lineno"> 2996</span><span class="stringliteral">    p-value : scalar ndarray</span></div>
<div class="line"><span class="lineno"> 2997</span><span class="stringliteral">        The p-value for the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3001</span><span class="stringliteral">    fligner : A non-parametric test for the equality of k variances</span></div>
<div class="line"><span class="lineno"> 3002</span><span class="stringliteral">    ansari : A non-parametric test for the equality of 2 variances</span></div>
<div class="line"><span class="lineno"> 3003</span><span class="stringliteral">    bartlett : A parametric test for equality of k variances in normal samples</span></div>
<div class="line"><span class="lineno"> 3004</span><span class="stringliteral">    levene : A parametric test for equality of k variances</span></div>
<div class="line"><span class="lineno"> 3005</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3006</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3007</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3008</span><span class="stringliteral">    The data are assumed to be drawn from probability distributions ``f(x)``</span></div>
<div class="line"><span class="lineno"> 3009</span><span class="stringliteral">    and ``f(x/s) / s`` respectively, for some probability density function f.</span></div>
<div class="line"><span class="lineno"> 3010</span><span class="stringliteral">    The null hypothesis is that ``s == 1``.</span></div>
<div class="line"><span class="lineno"> 3011</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3012</span><span class="stringliteral">    For multi-dimensional arrays, if the inputs are of shapes</span></div>
<div class="line"><span class="lineno"> 3013</span><span class="stringliteral">    ``(n0, n1, n2, n3)``  and ``(n0, m1, n2, n3)``, then if ``axis=1``, the</span></div>
<div class="line"><span class="lineno"> 3014</span><span class="stringliteral">    resulting z and p values will have shape ``(n0, n2, n3)``.  Note that</span></div>
<div class="line"><span class="lineno"> 3015</span><span class="stringliteral">    ``n1`` and ``m1`` don&#39;t have to be equal, but the other dimensions do.</span></div>
<div class="line"><span class="lineno"> 3016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3017</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3018</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3019</span><span class="stringliteral">    [1] Mielke, Paul W. &quot;Note on Some Squared Rank Tests with Existing Ties.&quot;</span></div>
<div class="line"><span class="lineno"> 3020</span><span class="stringliteral">        Technometrics, vol. 9, no. 2, 1967, pp. 312-14. JSTOR,</span></div>
<div class="line"><span class="lineno"> 3021</span><span class="stringliteral">        https://doi.org/10.2307/1266427. Accessed 18 May 2022.</span></div>
<div class="line"><span class="lineno"> 3022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3023</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3024</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3025</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 3026</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 3027</span><span class="stringliteral">    &gt;&gt;&gt; x2 = rng.standard_normal((2, 45, 6, 7))</span></div>
<div class="line"><span class="lineno"> 3028</span><span class="stringliteral">    &gt;&gt;&gt; x1 = rng.standard_normal((2, 30, 6, 7))</span></div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral">    &gt;&gt;&gt; z, p = stats.mood(x1, x2, axis=1)</span></div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral">    &gt;&gt;&gt; p.shape</span></div>
<div class="line"><span class="lineno"> 3031</span><span class="stringliteral">    (2, 6, 7)</span></div>
<div class="line"><span class="lineno"> 3032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3033</span><span class="stringliteral">    Find the number of points where the difference in scale is not significant:</span></div>
<div class="line"><span class="lineno"> 3034</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3035</span><span class="stringliteral">    &gt;&gt;&gt; (p &gt; 0.1).sum()</span></div>
<div class="line"><span class="lineno"> 3036</span><span class="stringliteral">    78</span></div>
<div class="line"><span class="lineno"> 3037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3038</span><span class="stringliteral">    Perform the test with different scales:</span></div>
<div class="line"><span class="lineno"> 3039</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3040</span><span class="stringliteral">    &gt;&gt;&gt; x1 = rng.standard_normal((2, 30))</span></div>
<div class="line"><span class="lineno"> 3041</span><span class="stringliteral">    &gt;&gt;&gt; x2 = rng.standard_normal((2, 35)) * 10.0</span></div>
<div class="line"><span class="lineno"> 3042</span><span class="stringliteral">    &gt;&gt;&gt; stats.mood(x1, x2, axis=1)</span></div>
<div class="line"><span class="lineno"> 3043</span><span class="stringliteral">    (array([-5.76174136, -6.12650783]), array([8.32505043e-09, 8.98287869e-10]))</span></div>
<div class="line"><span class="lineno"> 3044</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3045</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3046</span>    x = np.asarray(x, dtype=float)</div>
<div class="line"><span class="lineno"> 3047</span>    y = np.asarray(y, dtype=float)</div>
<div class="line"><span class="lineno"> 3048</span> </div>
<div class="line"><span class="lineno"> 3049</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3050</span>        x = x.flatten()</div>
<div class="line"><span class="lineno"> 3051</span>        y = y.flatten()</div>
<div class="line"><span class="lineno"> 3052</span>        axis = 0</div>
<div class="line"><span class="lineno"> 3053</span> </div>
<div class="line"><span class="lineno"> 3054</span>    <span class="keywordflow">if</span> axis &lt; 0:</div>
<div class="line"><span class="lineno"> 3055</span>        axis = x.ndim + axis</div>
<div class="line"><span class="lineno"> 3056</span> </div>
<div class="line"><span class="lineno"> 3057</span>    <span class="comment"># Determine shape of the result arrays</span></div>
<div class="line"><span class="lineno"> 3058</span>    res_shape = tuple([x.shape[ax] <span class="keywordflow">for</span> ax <span class="keywordflow">in</span> range(len(x.shape)) <span class="keywordflow">if</span> ax != axis])</div>
<div class="line"><span class="lineno"> 3059</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (res_shape == tuple([y.shape[ax] <span class="keywordflow">for</span> ax <span class="keywordflow">in</span> range(len(y.shape)) <span class="keywordflow">if</span></div>
<div class="line"><span class="lineno"> 3060</span>                                ax != axis])):</div>
<div class="line"><span class="lineno"> 3061</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Dimensions of x and y on all axes except `axis` &quot;</span></div>
<div class="line"><span class="lineno"> 3062</span>                         <span class="stringliteral">&quot;should match&quot;</span>)</div>
<div class="line"><span class="lineno"> 3063</span> </div>
<div class="line"><span class="lineno"> 3064</span>    n = x.shape[axis]</div>
<div class="line"><span class="lineno"> 3065</span>    m = y.shape[axis]</div>
<div class="line"><span class="lineno"> 3066</span>    N = m + n</div>
<div class="line"><span class="lineno"> 3067</span>    <span class="keywordflow">if</span> N &lt; 3:</div>
<div class="line"><span class="lineno"> 3068</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Not enough observations.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3069</span> </div>
<div class="line"><span class="lineno"> 3070</span>    xy = np.concatenate((x, y), axis=axis)</div>
<div class="line"><span class="lineno"> 3071</span>    <span class="comment"># determine if any of the samples contain ties</span></div>
<div class="line"><span class="lineno"> 3072</span>    sorted_xy = np.sort(xy, axis=axis)</div>
<div class="line"><span class="lineno"> 3073</span>    diffs = np.diff(sorted_xy, axis=axis)</div>
<div class="line"><span class="lineno"> 3074</span>    <span class="keywordflow">if</span> 0 <span class="keywordflow">in</span> diffs:</div>
<div class="line"><span class="lineno"> 3075</span>        z = np.asarray(_mood_inner_lc(xy, x, diffs, sorted_xy, n, m, N,</div>
<div class="line"><span class="lineno"> 3076</span>                                      axis=axis))</div>
<div class="line"><span class="lineno"> 3077</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3078</span>        <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3079</span>            xy = np.moveaxis(xy, axis, 0)</div>
<div class="line"><span class="lineno"> 3080</span> </div>
<div class="line"><span class="lineno"> 3081</span>        xy = xy.reshape(xy.shape[0], -1)</div>
<div class="line"><span class="lineno"> 3082</span>        <span class="comment"># Generalized to the n-dimensional case by adding the axis argument,</span></div>
<div class="line"><span class="lineno"> 3083</span>        <span class="comment"># and using for loops, since rankdata is not vectorized.  For improving</span></div>
<div class="line"><span class="lineno"> 3084</span>        <span class="comment"># performance consider vectorizing rankdata function.</span></div>
<div class="line"><span class="lineno"> 3085</span>        all_ranks = np.empty_like(xy)</div>
<div class="line"><span class="lineno"> 3086</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(xy.shape[1]):</div>
<div class="line"><span class="lineno"> 3087</span>            all_ranks[:, j] = _stats_py.rankdata(xy[:, j])</div>
<div class="line"><span class="lineno"> 3088</span> </div>
<div class="line"><span class="lineno"> 3089</span>        Ri = all_ranks[:n]</div>
<div class="line"><span class="lineno"> 3090</span>        M = np.sum((Ri - (N + 1.0) / 2) ** 2, axis=0)</div>
<div class="line"><span class="lineno"> 3091</span>        <span class="comment"># Approx stat.</span></div>
<div class="line"><span class="lineno"> 3092</span>        mnM = n * (N * N - 1.0) / 12</div>
<div class="line"><span class="lineno"> 3093</span>        varM = m * n * (N + 1.0) * (N + 2) * (N - 2) / 180</div>
<div class="line"><span class="lineno"> 3094</span>        z = (M - mnM) / sqrt(varM)</div>
<div class="line"><span class="lineno"> 3095</span>    z, pval = _normtest_finish(z, alternative)</div>
<div class="line"><span class="lineno"> 3096</span> </div>
<div class="line"><span class="lineno"> 3097</span>    <span class="keywordflow">if</span> res_shape == ():</div>
<div class="line"><span class="lineno"> 3098</span>        <span class="comment"># Return scalars, not 0-D arrays</span></div>
<div class="line"><span class="lineno"> 3099</span>        z = z[0]</div>
<div class="line"><span class="lineno"> 3100</span>        pval = pval[0]</div>
<div class="line"><span class="lineno"> 3101</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3102</span>        z.shape = res_shape</div>
<div class="line"><span class="lineno"> 3103</span>        pval.shape = res_shape</div>
<div class="line"><span class="lineno"> 3104</span>    <span class="keywordflow">return</span> z, pval</div>
<div class="line"><span class="lineno"> 3105</span> </div>
<div class="line"><span class="lineno"> 3106</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aba1b41e7416dd9f4537909f6f4fb98f8" name="aba1b41e7416dd9f4537909f6f4fb98f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1b41e7416dd9f4537909f6f4fb98f8">&#9670;&#160;</a></span>mvsdist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.mvsdist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">'Frozen' distributions for mean, variance, and standard deviation of data.

Parameters
----------
data : array_like
    Input array. Converted to 1-D using ravel.
    Requires 2 or more data-points.

Returns
-------
mdist : "frozen" distribution object
    Distribution object representing the mean of the data.
vdist : "frozen" distribution object
    Distribution object representing the variance of the data.
sdist : "frozen" distribution object
    Distribution object representing the standard deviation of the data.

See Also
--------
bayes_mvs

Notes
-----
The return values from ``bayes_mvs(data)`` is equivalent to
``tuple((x.mean(), x.interval(0.90)) for x in mvsdist(data))``.

In other words, calling ``&lt;dist&gt;.mean()`` and ``&lt;dist&gt;.interval(0.90)``
on the three distribution objects returned from this function will give
the same results that are returned from `bayes_mvs`.

References
----------
T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
standard-deviation from data", https://scholarsarchive.byu.edu/facpub/278,
2006.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; data = [6, 9, 12, 7, 8, 8, 13]
&gt;&gt;&gt; mean, var, std = stats.mvsdist(data)

We now have frozen distribution objects "mean", "var" and "std" that we can
examine:

&gt;&gt;&gt; mean.mean()
9.0
&gt;&gt;&gt; mean.interval(0.95)
(6.6120585482655692, 11.387941451734431)
&gt;&gt;&gt; mean.std()
1.1952286093343936</pre> <div class="fragment"><div class="line"><span class="lineno">  142</span><span class="keyword">def </span>mvsdist(data):</div>
<div class="line"><span class="lineno">  143</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    &#39;Frozen&#39; distributions for mean, variance, and standard deviation of data.</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        Input array. Converted to 1-D using ravel.</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">        Requires 2 or more data-points.</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    mdist : &quot;frozen&quot; distribution object</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        Distribution object representing the mean of the data.</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    vdist : &quot;frozen&quot; distribution object</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">        Distribution object representing the variance of the data.</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    sdist : &quot;frozen&quot; distribution object</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">        Distribution object representing the standard deviation of the data.</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    bayes_mvs</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    The return values from ``bayes_mvs(data)`` is equivalent to</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    ``tuple((x.mean(), x.interval(0.90)) for x in mvsdist(data))``.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    In other words, calling ``&lt;dist&gt;.mean()`` and ``&lt;dist&gt;.interval(0.90)``</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    on the three distribution objects returned from this function will give</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    the same results that are returned from `bayes_mvs`.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    T.E. Oliphant, &quot;A Bayesian perspective on estimating mean, variance, and</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    standard-deviation from data&quot;, https://scholarsarchive.byu.edu/facpub/278,</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    2006.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    &gt;&gt;&gt; data = [6, 9, 12, 7, 8, 8, 13]</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    &gt;&gt;&gt; mean, var, std = stats.mvsdist(data)</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    We now have frozen distribution objects &quot;mean&quot;, &quot;var&quot; and &quot;std&quot; that we can</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    examine:</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    &gt;&gt;&gt; mean.mean()</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    9.0</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    &gt;&gt;&gt; mean.interval(0.95)</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    (6.6120585482655692, 11.387941451734431)</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    &gt;&gt;&gt; mean.std()</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    1.1952286093343936</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  197</span>    x = ravel(data)</div>
<div class="line"><span class="lineno">  198</span>    n = len(x)</div>
<div class="line"><span class="lineno">  199</span>    <span class="keywordflow">if</span> n &lt; 2:</div>
<div class="line"><span class="lineno">  200</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Need at least 2 data-points.&quot;</span>)</div>
<div class="line"><span class="lineno">  201</span>    xbar = x.mean()</div>
<div class="line"><span class="lineno">  202</span>    C = x.var()</div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">if</span> n &gt; 1000:  <span class="comment"># gaussian approximations for large n</span></div>
<div class="line"><span class="lineno">  204</span>        mdist = distributions.norm(loc=xbar, scale=math.sqrt(C / n))</div>
<div class="line"><span class="lineno">  205</span>        sdist = distributions.norm(loc=math.sqrt(C), scale=math.sqrt(C / (2. * n)))</div>
<div class="line"><span class="lineno">  206</span>        vdist = distributions.norm(loc=C, scale=math.sqrt(2.0 / n) * C)</div>
<div class="line"><span class="lineno">  207</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  208</span>        nm1 = n - 1</div>
<div class="line"><span class="lineno">  209</span>        fac = n * C / 2.</div>
<div class="line"><span class="lineno">  210</span>        val = nm1 / 2.</div>
<div class="line"><span class="lineno">  211</span>        mdist = distributions.t(nm1, loc=xbar, scale=math.sqrt(C / nm1))</div>
<div class="line"><span class="lineno">  212</span>        sdist = distributions.gengamma(val, -2, scale=math.sqrt(fac))</div>
<div class="line"><span class="lineno">  213</span>        vdist = distributions.invgamma(val, scale=fac)</div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">return</span> mdist, vdist, sdist</div>
<div class="line"><span class="lineno">  215</span> </div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno">  218</span>    <span class="keyword">lambda</span> x: x, result_to_tuple=<span class="keyword">lambda</span> x: (x,), n_outputs=1, default_axis=<span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  219</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f28fe29e196c4bfe59e5619f859946f" name="a3f28fe29e196c4bfe59e5619f859946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f28fe29e196c4bfe59e5619f859946f">&#9670;&#160;</a></span>ppcc_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ppcc_max </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>brack</em> = <code>(0.0,&#160;1.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em> = <code>'<a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#a22e5805528fe5ea9fc9962f9a49cf5d9">tukeylambda</a>'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the shape parameter that maximizes the PPCC.

The probability plot correlation coefficient (PPCC) plot can be used
to determine the optimal shape parameter for a one-parameter family
of distributions. ``ppcc_max`` returns the shape parameter that would
maximize the probability plot correlation coefficient for the given
data to a one-parameter family of distributions.

Parameters
----------
x : array_like
    Input array.
brack : tuple, optional
    Triple (a,b,c) where (a&lt;b&lt;c). If bracket consists of two numbers (a, c)
    then they are assumed to be a starting interval for a downhill bracket
    search (see `scipy.optimize.brent`).
dist : str or stats.distributions instance, optional
    Distribution or distribution function name.  Objects that look enough
    like a stats.distributions instance (i.e. they have a ``ppf`` method)
    are also accepted.  The default is ``'tukeylambda'``.

Returns
-------
shape_value : float
    The shape parameter at which the probability plot correlation
    coefficient reaches its max value.

See Also
--------
ppcc_plot, probplot, boxcox

Notes
-----
The brack keyword serves as a starting point which is useful in corner
cases. One can use a plot to obtain a rough visual estimate of the location
for the maximum to start the search near it.

References
----------
.. [1] J.J. Filliben, "The Probability Plot Correlation Coefficient Test
       for Normality", Technometrics, Vol. 17, pp. 111-117, 1975.
.. [2] Engineering Statistics Handbook, NIST/SEMATEC,
       https://www.itl.nist.gov/div898/handbook/eda/section3/ppccplot.htm

Examples
--------
First we generate some random data from a Weibull distribution
with shape parameter 2.5:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; c = 2.5
&gt;&gt;&gt; x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)

Generate the PPCC plot for this data with the Weibull distribution.

&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 6))
&gt;&gt;&gt; res = stats.ppcc_plot(x, c/2, 2*c, dist='weibull_min', plot=ax)

We calculate the value where the shape should reach its maximum and a
red line is drawn there. The line should coincide with the highest
point in the PPCC graph.

&gt;&gt;&gt; cmax = stats.ppcc_max(x, brack=(c/2, 2*c), dist='weibull_min')
&gt;&gt;&gt; ax.axvline(cmax, color='r')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  640</span><span class="keyword">def </span>ppcc_max(x, brack=(0.0, 1.0), dist=<span class="stringliteral">&#39;tukeylambda&#39;</span>):</div>
<div class="line"><span class="lineno">  641</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the shape parameter that maximizes the PPCC.</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    The probability plot correlation coefficient (PPCC) plot can be used</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    to determine the optimal shape parameter for a one-parameter family</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    of distributions. ``ppcc_max`` returns the shape parameter that would</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    maximize the probability plot correlation coefficient for the given</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    data to a one-parameter family of distributions.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    brack : tuple, optional</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">        Triple (a,b,c) where (a&lt;b&lt;c). If bracket consists of two numbers (a, c)</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        then they are assumed to be a starting interval for a downhill bracket</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        search (see `scipy.optimize.brent`).</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    dist : str or stats.distributions instance, optional</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        Distribution or distribution function name.  Objects that look enough</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        like a stats.distributions instance (i.e. they have a ``ppf`` method)</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        are also accepted.  The default is ``&#39;tukeylambda&#39;``.</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    shape_value : float</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        The shape parameter at which the probability plot correlation</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">        coefficient reaches its max value.</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    ppcc_plot, probplot, boxcox</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    The brack keyword serves as a starting point which is useful in corner</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    cases. One can use a plot to obtain a rough visual estimate of the location</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    for the maximum to start the search near it.</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    .. [1] J.J. Filliben, &quot;The Probability Plot Correlation Coefficient Test</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">           for Normality&quot;, Technometrics, Vol. 17, pp. 111-117, 1975.</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    .. [2] Engineering Statistics Handbook, NIST/SEMATEC,</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">           https://www.itl.nist.gov/div898/handbook/eda/section3/ppccplot.htm</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    First we generate some random data from a Weibull distribution</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    with shape parameter 2.5:</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    &gt;&gt;&gt; c = 2.5</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    Generate the PPCC plot for this data with the Weibull distribution.</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 6))</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.ppcc_plot(x, c/2, 2*c, dist=&#39;weibull_min&#39;, plot=ax)</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    We calculate the value where the shape should reach its maximum and a</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    red line is drawn there. The line should coincide with the highest</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    point in the PPCC graph.</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    &gt;&gt;&gt; cmax = stats.ppcc_max(x, brack=(c/2, 2*c), dist=&#39;weibull_min&#39;)</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvline(cmax, color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  710</span>    dist = _parse_dist_kw(dist)</div>
<div class="line"><span class="lineno">  711</span>    osm_uniform = _calc_uniform_order_statistic_medians(len(x))</div>
<div class="line"><span class="lineno">  712</span>    osr = sort(x)</div>
<div class="line"><span class="lineno">  713</span> </div>
<div class="line"><span class="lineno">  714</span>    <span class="comment"># this function computes the x-axis values of the probability plot</span></div>
<div class="line"><span class="lineno">  715</span>    <span class="comment">#  and computes a linear regression (including the correlation)</span></div>
<div class="line"><span class="lineno">  716</span>    <span class="comment">#  and returns 1-r so that a minimization function maximizes the</span></div>
<div class="line"><span class="lineno">  717</span>    <span class="comment">#  correlation</span></div>
<div class="line"><span class="lineno">  718</span>    <span class="keyword">def </span>tempfunc(shape, mi, yvals, func):</div>
<div class="line"><span class="lineno">  719</span>        xvals = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(mi, shape)</div>
<div class="line"><span class="lineno">  720</span>        r, prob = _stats_py.pearsonr(xvals, yvals)</div>
<div class="line"><span class="lineno">  721</span>        <span class="keywordflow">return</span> 1 - r</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span>    <span class="keywordflow">return</span> optimize.brent(tempfunc, brack=brack,</div>
<div class="line"><span class="lineno">  724</span>                          args=(osm_uniform, osr, dist.ppf))</div>
<div class="line"><span class="lineno">  725</span> </div>
<div class="line"><span class="lineno">  726</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac92883d23651fe5aa26beaef7c55a5ce" name="ac92883d23651fe5aa26beaef7c55a5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92883d23651fe5aa26beaef7c55a5ce">&#9670;&#160;</a></span>ppcc_plot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ppcc_plot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em> = <code>'<a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#a22e5805528fe5ea9fc9962f9a49cf5d9">tukeylambda</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plot</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate and optionally plot probability plot correlation coefficient.

The probability plot correlation coefficient (PPCC) plot can be used to
determine the optimal shape parameter for a one-parameter family of
distributions.  It cannot be used for distributions without shape
parameters
(like the normal distribution) or with multiple shape parameters.

By default a Tukey-Lambda distribution (`stats.tukeylambda`) is used. A
Tukey-Lambda PPCC plot interpolates from long-tailed to short-tailed
distributions via an approximately normal one, and is therefore
particularly useful in practice.

Parameters
----------
x : array_like
    Input array.
a, b : scalar
    Lower and upper bounds of the shape parameter to use.
dist : str or stats.distributions instance, optional
    Distribution or distribution function name.  Objects that look enough
    like a stats.distributions instance (i.e. they have a ``ppf`` method)
    are also accepted.  The default is ``'tukeylambda'``.
plot : object, optional
    If given, plots PPCC against the shape parameter.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `a` to `b`).

Returns
-------
svals : ndarray
    The shape values for which `ppcc` was calculated.
ppcc : ndarray
    The calculated probability plot correlation coefficient values.

See Also
--------
ppcc_max, probplot, boxcox_normplot, tukeylambda

References
----------
J.J. Filliben, "The Probability Plot Correlation Coefficient Test for
Normality", Technometrics, Vol. 17, pp. 111-117, 1975.

Examples
--------
First we generate some random data from a Weibull distribution
with shape parameter 2.5, and plot the histogram of the data:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; c = 2.5
&gt;&gt;&gt; x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)

Take a look at the histogram of the data.

&gt;&gt;&gt; fig1, ax = plt.subplots(figsize=(9, 4))
&gt;&gt;&gt; ax.hist(x, bins=50)
&gt;&gt;&gt; ax.set_title('Histogram of x')
&gt;&gt;&gt; plt.show()

Now we explore this data with a PPCC plot as well as the related
probability plot and Box-Cox normplot.  A red line is drawn where we
expect the PPCC value to be maximal (at the shape parameter ``c``
used above):

&gt;&gt;&gt; fig2 = plt.figure(figsize=(12, 4))
&gt;&gt;&gt; ax1 = fig2.add_subplot(1, 3, 1)
&gt;&gt;&gt; ax2 = fig2.add_subplot(1, 3, 2)
&gt;&gt;&gt; ax3 = fig2.add_subplot(1, 3, 3)
&gt;&gt;&gt; res = stats.probplot(x, plot=ax1)
&gt;&gt;&gt; res = stats.boxcox_normplot(x, -4, 4, plot=ax2)
&gt;&gt;&gt; res = stats.ppcc_plot(x, c/2, 2*c, dist='weibull_min', plot=ax3)
&gt;&gt;&gt; ax3.axvline(c, color='r')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  727</span><span class="keyword">def </span>ppcc_plot(x, a, b, dist=&#39;tukeylambda&#39;, plot=None, N=80):</div>
<div class="line"><span class="lineno">  728</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate and optionally plot probability plot correlation coefficient.</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    The probability plot correlation coefficient (PPCC) plot can be used to</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    determine the optimal shape parameter for a one-parameter family of</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    distributions.  It cannot be used for distributions without shape</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    parameters</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    (like the normal distribution) or with multiple shape parameters.</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    By default a Tukey-Lambda distribution (`stats.tukeylambda`) is used. A</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    Tukey-Lambda PPCC plot interpolates from long-tailed to short-tailed</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    distributions via an approximately normal one, and is therefore</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    particularly useful in practice.</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    a, b : scalar</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        Lower and upper bounds of the shape parameter to use.</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    dist : str or stats.distributions instance, optional</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        Distribution or distribution function name.  Objects that look enough</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        like a stats.distributions instance (i.e. they have a ``ppf`` method)</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        are also accepted.  The default is ``&#39;tukeylambda&#39;``.</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    plot : object, optional</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        If given, plots PPCC against the shape parameter.</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        `plot` is an object that has to have methods &quot;plot&quot; and &quot;text&quot;.</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        or a custom object with the same methods.</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        Default is None, which means that no plot is created.</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">        Number of points on the horizontal axis (equally distributed from</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        `a` to `b`).</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    svals : ndarray</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        The shape values for which `ppcc` was calculated.</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    ppcc : ndarray</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        The calculated probability plot correlation coefficient values.</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    ppcc_max, probplot, boxcox_normplot, tukeylambda</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    J.J. Filliben, &quot;The Probability Plot Correlation Coefficient Test for</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    Normality&quot;, Technometrics, Vol. 17, pp. 111-117, 1975.</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    First we generate some random data from a Weibull distribution</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    with shape parameter 2.5, and plot the histogram of the data:</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    &gt;&gt;&gt; c = 2.5</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">    Take a look at the histogram of the data.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    &gt;&gt;&gt; fig1, ax = plt.subplots(figsize=(9, 4))</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    &gt;&gt;&gt; ax.hist(x, bins=50)</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_title(&#39;Histogram of x&#39;)</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    Now we explore this data with a PPCC plot as well as the related</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    probability plot and Box-Cox normplot.  A red line is drawn where we</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    expect the PPCC value to be maximal (at the shape parameter ``c``</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    used above):</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    &gt;&gt;&gt; fig2 = plt.figure(figsize=(12, 4))</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    &gt;&gt;&gt; ax1 = fig2.add_subplot(1, 3, 1)</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    &gt;&gt;&gt; ax2 = fig2.add_subplot(1, 3, 2)</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    &gt;&gt;&gt; ax3 = fig2.add_subplot(1, 3, 3)</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.probplot(x, plot=ax1)</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.boxcox_normplot(x, -4, 4, plot=ax2)</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.ppcc_plot(x, c/2, 2*c, dist=&#39;weibull_min&#39;, plot=ax3)</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    &gt;&gt;&gt; ax3.axvline(c, color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  811</span>    <span class="keywordflow">if</span> b &lt;= a:</div>
<div class="line"><span class="lineno">  812</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`b` has to be larger than `a`.&quot;</span>)</div>
<div class="line"><span class="lineno">  813</span> </div>
<div class="line"><span class="lineno">  814</span>    svals = np.linspace(a, b, num=N)</div>
<div class="line"><span class="lineno">  815</span>    ppcc = np.empty_like(svals)</div>
<div class="line"><span class="lineno">  816</span>    <span class="keywordflow">for</span> k, sval <span class="keywordflow">in</span> enumerate(svals):</div>
<div class="line"><span class="lineno">  817</span>        _, r2 = probplot(x, sval, dist=dist, fit=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  818</span>        ppcc[k] = r2[-1]</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>    <span class="keywordflow">if</span> plot <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  821</span>        plot.plot(svals, ppcc, <span class="stringliteral">&#39;x&#39;</span>)</div>
<div class="line"><span class="lineno">  822</span>        _add_axis_labels_title(plot, xlabel=<span class="stringliteral">&#39;Shape Values&#39;</span>,</div>
<div class="line"><span class="lineno">  823</span>                               ylabel=<span class="stringliteral">&#39;Prob Plot Corr. Coef.&#39;</span>,</div>
<div class="line"><span class="lineno">  824</span>                               title=<span class="stringliteral">&#39;(%s) PPCC Plot&#39;</span> % dist)</div>
<div class="line"><span class="lineno">  825</span> </div>
<div class="line"><span class="lineno">  826</span>    <span class="keywordflow">return</span> svals, ppcc</div>
<div class="line"><span class="lineno">  827</span> </div>
<div class="line"><span class="lineno">  828</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0a762e91cdcf4bede4a0ace1d96b091" name="ad0a762e91cdcf4bede4a0ace1d96b091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a762e91cdcf4bede4a0ace1d96b091">&#9670;&#160;</a></span>probplot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.probplot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparams</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em> = <code>'norm'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plot</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rvalue</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate quantiles for a probability plot, and optionally show the plot.

Generates a probability plot of sample data against the quantiles of a
specified theoretical distribution (the normal distribution by default).
`probplot` optionally calculates a best-fit line for the data and plots the
results using Matplotlib or a given plot function.

Parameters
----------
x : array_like
    Sample/response data from which `probplot` creates the plot.
sparams : tuple, optional
    Distribution-specific shape parameters (shape parameters plus location
    and scale).
dist : str or stats.distributions instance, optional
    Distribution or distribution function name. The default is 'norm' for a
    normal probability plot.  Objects that look enough like a
    stats.distributions instance (i.e. they have a ``ppf`` method) are also
    accepted.
fit : bool, optional
    Fit a least-squares regression (best-fit) line to the sample data if
    True (default).
plot : object, optional
    If given, plots the quantiles.
    If given and `fit` is True, also plots the least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.

Returns
-------
(osm, osr) : tuple of ndarrays
    Tuple of theoretical quantiles (osm, or order statistic medians) and
    ordered responses (osr).  `osr` is simply sorted input `x`.
    For details on how `osm` is calculated see the Notes section.
(slope, intercept, r) : tuple of floats, optional
    Tuple  containing the result of the least-squares fit, if that is
    performed by `probplot`. `r` is the square root of the coefficient of
    determination.  If ``fit=False`` and ``plot=None``, this tuple is not
    returned.

Notes
-----
Even if `plot` is given, the figure is not shown or saved by `probplot`;
``plt.show()`` or ``plt.savefig('figname.png')`` should be used after
calling `probplot`.

`probplot` generates a probability plot, which should not be confused with
a Q-Q or a P-P plot.  Statsmodels has more extensive functionality of this
type, see ``statsmodels.api.ProbPlot``.

The formula used for the theoretical quantiles (horizontal axis of the
probability plot) is Filliben's estimate::

    quantiles = dist.ppf(val), for

            0.5**(1/n),                  for i = n
      val = (i - 0.3175) / (n + 0.365),  for i = 2, ..., n-1
            1 - 0.5**(1/n),              for i = 1

where ``i`` indicates the i-th ordered value and ``n`` is the total number
of values.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; nsample = 100
&gt;&gt;&gt; rng = np.random.default_rng()

A t distribution with small degrees of freedom:

&gt;&gt;&gt; ax1 = plt.subplot(221)
&gt;&gt;&gt; x = stats.t.rvs(3, size=nsample, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A t distribution with larger degrees of freedom:

&gt;&gt;&gt; ax2 = plt.subplot(222)
&gt;&gt;&gt; x = stats.t.rvs(25, size=nsample, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A mixture of two normal distributions with broadcasting:

&gt;&gt;&gt; ax3 = plt.subplot(223)
&gt;&gt;&gt; x = stats.norm.rvs(loc=[0,5], scale=[1,1.5],
...                    size=(nsample//2,2), random_state=rng).ravel()
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A standard normal distribution:

&gt;&gt;&gt; ax4 = plt.subplot(224)
&gt;&gt;&gt; x = stats.norm.rvs(loc=0, scale=1, size=nsample, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

Produce a new figure with a loggamma distribution, using the ``dist`` and
``sparams`` keywords:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; x = stats.loggamma.rvs(c=2.5, size=500, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, dist=stats.loggamma, sparams=(2.5,), plot=ax)
&gt;&gt;&gt; ax.set_title("Probplot for loggamma dist with shape parameter 2.5")

Show the results with Matplotlib:

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  482</span><span class="keyword">def </span>probplot(x, sparams=(), dist=<span class="stringliteral">&#39;norm&#39;</span>, fit=<span class="keyword">True</span>, plot=<span class="keywordtype">None</span>, rvalue=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  483</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    Calculate quantiles for a probability plot, and optionally show the plot.</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    Generates a probability plot of sample data against the quantiles of a</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    specified theoretical distribution (the normal distribution by default).</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    `probplot` optionally calculates a best-fit line for the data and plots the</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    results using Matplotlib or a given plot function.</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        Sample/response data from which `probplot` creates the plot.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    sparams : tuple, optional</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        Distribution-specific shape parameters (shape parameters plus location</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">        and scale).</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    dist : str or stats.distributions instance, optional</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        Distribution or distribution function name. The default is &#39;norm&#39; for a</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        normal probability plot.  Objects that look enough like a</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        stats.distributions instance (i.e. they have a ``ppf`` method) are also</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        accepted.</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    fit : bool, optional</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        Fit a least-squares regression (best-fit) line to the sample data if</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        True (default).</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    plot : object, optional</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        If given, plots the quantiles.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        If given and `fit` is True, also plots the least squares fit.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        `plot` is an object that has to have methods &quot;plot&quot; and &quot;text&quot;.</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        or a custom object with the same methods.</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        Default is None, which means that no plot is created.</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    (osm, osr) : tuple of ndarrays</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        Tuple of theoretical quantiles (osm, or order statistic medians) and</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">        ordered responses (osr).  `osr` is simply sorted input `x`.</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        For details on how `osm` is calculated see the Notes section.</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    (slope, intercept, r) : tuple of floats, optional</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        Tuple  containing the result of the least-squares fit, if that is</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        performed by `probplot`. `r` is the square root of the coefficient of</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        determination.  If ``fit=False`` and ``plot=None``, this tuple is not</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        returned.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    Even if `plot` is given, the figure is not shown or saved by `probplot`;</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    ``plt.show()`` or ``plt.savefig(&#39;figname.png&#39;)`` should be used after</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    calling `probplot`.</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    `probplot` generates a probability plot, which should not be confused with</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    a Q-Q or a P-P plot.  Statsmodels has more extensive functionality of this</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    type, see ``statsmodels.api.ProbPlot``.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    The formula used for the theoretical quantiles (horizontal axis of the</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    probability plot) is Filliben&#39;s estimate::</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">        quantiles = dist.ppf(val), for</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">                0.5**(1/n),                  for i = n</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">          val = (i - 0.3175) / (n + 0.365),  for i = 2, ..., n-1</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">                1 - 0.5**(1/n),              for i = 1</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    where ``i`` indicates the i-th ordered value and ``n`` is the total number</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    of values.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    &gt;&gt;&gt; nsample = 100</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    A t distribution with small degrees of freedom:</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    &gt;&gt;&gt; ax1 = plt.subplot(221)</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.t.rvs(3, size=nsample, random_state=rng)</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.probplot(x, plot=plt)</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    A t distribution with larger degrees of freedom:</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    &gt;&gt;&gt; ax2 = plt.subplot(222)</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.t.rvs(25, size=nsample, random_state=rng)</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.probplot(x, plot=plt)</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    A mixture of two normal distributions with broadcasting:</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    &gt;&gt;&gt; ax3 = plt.subplot(223)</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(loc=[0,5], scale=[1,1.5],</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    ...                    size=(nsample//2,2), random_state=rng).ravel()</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.probplot(x, plot=plt)</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    A standard normal distribution:</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    &gt;&gt;&gt; ax4 = plt.subplot(224)</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(loc=0, scale=1, size=nsample, random_state=rng)</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.probplot(x, plot=plt)</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    Produce a new figure with a loggamma distribution, using the ``dist`` and</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    ``sparams`` keywords:</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(c=2.5, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.probplot(x, dist=stats.loggamma, sparams=(2.5,), plot=ax)</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_title(&quot;Probplot for loggamma dist with shape parameter 2.5&quot;)</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    Show the results with Matplotlib:</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  594</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno">  595</span>    <span class="keywordflow">if</span> x.size == 0:</div>
<div class="line"><span class="lineno">  596</span>        <span class="keywordflow">if</span> fit:</div>
<div class="line"><span class="lineno">  597</span>            <span class="keywordflow">return</span> (x, x), (np.nan, np.nan, 0.0)</div>
<div class="line"><span class="lineno">  598</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  599</span>            <span class="keywordflow">return</span> x, x</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>    osm_uniform = _calc_uniform_order_statistic_medians(len(x))</div>
<div class="line"><span class="lineno">  602</span>    dist = _parse_dist_kw(dist, enforce_subclass=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  603</span>    <span class="keywordflow">if</span> sparams <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  604</span>        sparams = ()</div>
<div class="line"><span class="lineno">  605</span>    <span class="keywordflow">if</span> isscalar(sparams):</div>
<div class="line"><span class="lineno">  606</span>        sparams = (sparams,)</div>
<div class="line"><span class="lineno">  607</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(sparams, tuple):</div>
<div class="line"><span class="lineno">  608</span>        sparams = tuple(sparams)</div>
<div class="line"><span class="lineno">  609</span> </div>
<div class="line"><span class="lineno">  610</span>    osm = dist.ppf(osm_uniform, *sparams)</div>
<div class="line"><span class="lineno">  611</span>    osr = sort(x)</div>
<div class="line"><span class="lineno">  612</span>    <span class="keywordflow">if</span> fit:</div>
<div class="line"><span class="lineno">  613</span>        <span class="comment"># perform a linear least squares fit.</span></div>
<div class="line"><span class="lineno">  614</span>        slope, intercept, r, prob, _ = _stats_py.linregress(osm, osr)</div>
<div class="line"><span class="lineno">  615</span> </div>
<div class="line"><span class="lineno">  616</span>    <span class="keywordflow">if</span> plot <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  617</span>        plot.plot(osm, osr, <span class="stringliteral">&#39;bo&#39;</span>)</div>
<div class="line"><span class="lineno">  618</span>        <span class="keywordflow">if</span> fit:</div>
<div class="line"><span class="lineno">  619</span>            plot.plot(osm, slope*osm + intercept, <span class="stringliteral">&#39;r-&#39;</span>)</div>
<div class="line"><span class="lineno">  620</span>        _add_axis_labels_title(plot, xlabel=<span class="stringliteral">&#39;Theoretical quantiles&#39;</span>,</div>
<div class="line"><span class="lineno">  621</span>                               ylabel=<span class="stringliteral">&#39;Ordered Values&#39;</span>,</div>
<div class="line"><span class="lineno">  622</span>                               title=<span class="stringliteral">&#39;Probability Plot&#39;</span>)</div>
<div class="line"><span class="lineno">  623</span> </div>
<div class="line"><span class="lineno">  624</span>        <span class="comment"># Add R^2 value to the plot as text</span></div>
<div class="line"><span class="lineno">  625</span>        <span class="keywordflow">if</span> rvalue:</div>
<div class="line"><span class="lineno">  626</span>            xmin = amin(osm)</div>
<div class="line"><span class="lineno">  627</span>            xmax = amax(osm)</div>
<div class="line"><span class="lineno">  628</span>            ymin = amin(x)</div>
<div class="line"><span class="lineno">  629</span>            ymax = amax(x)</div>
<div class="line"><span class="lineno">  630</span>            posx = xmin + 0.70 * (xmax - xmin)</div>
<div class="line"><span class="lineno">  631</span>            posy = ymin + 0.01 * (ymax - ymin)</div>
<div class="line"><span class="lineno">  632</span>            plot.text(posx, posy, <span class="stringliteral">&quot;$R^2=%1.4f$&quot;</span> % r**2)</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span>    <span class="keywordflow">if</span> fit:</div>
<div class="line"><span class="lineno">  635</span>        <span class="keywordflow">return</span> (osm, osr), (slope, intercept, r)</div>
<div class="line"><span class="lineno">  636</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  637</span>        <span class="keywordflow">return</span> osm, osr</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ada353fe6934760152d3262990c5559c7" name="ada353fe6934760152d3262990c5559c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada353fe6934760152d3262990c5559c7">&#9670;&#160;</a></span>shapiro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.shapiro </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the Shapiro-Wilk test for normality.

The Shapiro-Wilk test tests the null hypothesis that the
data was drawn from a normal distribution.

Parameters
----------
x : array_like
    Array of sample data.

Returns
-------
statistic : float
    The test statistic.
p-value : float
    The p-value for the hypothesis test.

See Also
--------
anderson : The Anderson-Darling test for normality
kstest : The Kolmogorov-Smirnov test for goodness of fit.

Notes
-----
The algorithm used is described in [4]_ but censoring parameters as
described are not implemented. For N &gt; 5000 the W test statistic is accurate
but the p-value may not be.

The chance of rejecting the null hypothesis when it is true is close to 5%
regardless of sample size.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
.. [2] Shapiro, S. S. &amp; Wilk, M.B (1965). An analysis of variance test for
       normality (complete samples), Biometrika, Vol. 52, pp. 591-611.
.. [3] Razali, N. M. &amp; Wah, Y. B. (2011) Power comparisons of Shapiro-Wilk,
       Kolmogorov-Smirnov, Lilliefors and Anderson-Darling tests, Journal of
       Statistical Modeling and Analytics, Vol. 2, pp. 21-33.
.. [4] ALGORITHM AS R94 APPL. STATIST. (1995) VOL. 44, NO. 4.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.norm.rvs(loc=5, scale=3, size=100, random_state=rng)
&gt;&gt;&gt; shapiro_test = stats.shapiro(x)
&gt;&gt;&gt; shapiro_test
ShapiroResult(statistic=0.9813305735588074, pvalue=0.16855233907699585)
&gt;&gt;&gt; shapiro_test.statistic
0.9813305735588074
&gt;&gt;&gt; shapiro_test.pvalue
0.16855233907699585</pre> <div class="fragment"><div class="line"><span class="lineno"> 1727</span><span class="keyword">def </span>shapiro(x):</div>
<div class="line"><span class="lineno"> 1728</span>    <span class="stringliteral">&quot;&quot;&quot;Perform the Shapiro-Wilk test for normality.</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">    The Shapiro-Wilk test tests the null hypothesis that the</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">    data was drawn from a normal distribution.</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral">        Array of sample data.</span></div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">        The test statistic.</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">    p-value : float</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">        The p-value for the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral">    anderson : The Anderson-Darling test for normality</span></div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">    kstest : The Kolmogorov-Smirnov test for goodness of fit.</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">    The algorithm used is described in [4]_ but censoring parameters as</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">    described are not implemented. For N &gt; 5000 the W test statistic is accurate</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">    but the p-value may not be.</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral">    The chance of rejecting the null hypothesis when it is true is close to 5%</span></div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">    regardless of sample size.</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">    .. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">    .. [2] Shapiro, S. S. &amp; Wilk, M.B (1965). An analysis of variance test for</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">           normality (complete samples), Biometrika, Vol. 52, pp. 591-611.</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">    .. [3] Razali, N. M. &amp; Wah, Y. B. (2011) Power comparisons of Shapiro-Wilk,</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">           Kolmogorov-Smirnov, Lilliefors and Anderson-Darling tests, Journal of</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">           Statistical Modeling and Analytics, Vol. 2, pp. 21-33.</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">    .. [4] ALGORITHM AS R94 APPL. STATIST. (1995) VOL. 44, NO. 4.</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(loc=5, scale=3, size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">    &gt;&gt;&gt; shapiro_test = stats.shapiro(x)</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">    &gt;&gt;&gt; shapiro_test</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">    ShapiroResult(statistic=0.9813305735588074, pvalue=0.16855233907699585)</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">    &gt;&gt;&gt; shapiro_test.statistic</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">    0.9813305735588074</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">    &gt;&gt;&gt; shapiro_test.pvalue</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    0.16855233907699585</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1783</span>    x = np.ravel(x)</div>
<div class="line"><span class="lineno"> 1784</span> </div>
<div class="line"><span class="lineno"> 1785</span>    N = len(x)</div>
<div class="line"><span class="lineno"> 1786</span>    <span class="keywordflow">if</span> N &lt; 3:</div>
<div class="line"><span class="lineno"> 1787</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data must be at least length 3.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1788</span> </div>
<div class="line"><span class="lineno"> 1789</span>    x = x - np.median(x)</div>
<div class="line"><span class="lineno"> 1790</span> </div>
<div class="line"><span class="lineno"> 1791</span>    a = zeros(N, <span class="stringliteral">&#39;f&#39;</span>)</div>
<div class="line"><span class="lineno"> 1792</span>    init = 0</div>
<div class="line"><span class="lineno"> 1793</span> </div>
<div class="line"><span class="lineno"> 1794</span>    y = sort(x)</div>
<div class="line"><span class="lineno"> 1795</span>    a, w, pw, ifault = _statlib.swilk(y, a[:N//2], init)</div>
<div class="line"><span class="lineno"> 1796</span>    <span class="keywordflow">if</span> ifault <span class="keywordflow">not</span> <span class="keywordflow">in</span> [0, 2]:</div>
<div class="line"><span class="lineno"> 1797</span>        warnings.warn(<span class="stringliteral">&quot;Input data for shapiro has range zero. The results &quot;</span></div>
<div class="line"><span class="lineno"> 1798</span>                      <span class="stringliteral">&quot;may not be accurate.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1799</span>    <span class="keywordflow">if</span> N &gt; 5000:</div>
<div class="line"><span class="lineno"> 1800</span>        warnings.warn(<span class="stringliteral">&quot;p-value may not be accurate for N &gt; 5000.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1801</span> </div>
<div class="line"><span class="lineno"> 1802</span>    <span class="keywordflow">return</span> ShapiroResult(w, pw)</div>
<div class="line"><span class="lineno"> 1803</span> </div>
<div class="line"><span class="lineno"> 1804</span> </div>
<div class="line"><span class="lineno"> 1805</span><span class="comment"># Values from Stephens, M A, &quot;EDF Statistics for Goodness of Fit and</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="comment">#             Some Comparisons&quot;, Journal of the American Statistical</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="comment">#             Association, Vol. 69, Issue 347, Sept. 1974, pp 730-737</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="acf6be93729b9052a8ffa98d5a17f96f6" name="acf6be93729b9052a8ffa98d5a17f96f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6be93729b9052a8ffa98d5a17f96f6">&#9670;&#160;</a></span>wilcoxon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zero_method</em> = <code>&quot;wilcox&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>correction</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the Wilcoxon signed-rank test.

The Wilcoxon signed-rank test tests the null hypothesis that two
related paired samples come from the same distribution. In particular,
it tests whether the distribution of the differences ``x - y`` is symmetric
about zero. It is a non-parametric version of the paired T-test.

Parameters
----------
x : array_like
    Either the first set of measurements (in which case ``y`` is the second
    set of measurements), or the differences between two sets of
    measurements (in which case ``y`` is not to be specified.)  Must be
    one-dimensional.
y : array_like, optional
    Either the second set of measurements (if ``x`` is the first set of
    measurements), or not specified (if ``x`` is the differences between
    two sets of measurements.)  Must be one-dimensional.
zero_method : {"wilcox", "pratt", "zsplit"}, optional
    There are different conventions for handling pairs of observations
    with equal values ("zero-differences", or "zeros").

    * "wilcox": Discards all zero-differences (default); see [4]_.
    * "pratt": Includes zero-differences in the ranking process,
      but drops the ranks of the zeros (more conservative); see [3]_.
      In this case, the normal approximation is adjusted as in [5]_.
    * "zsplit": Includes zero-differences in the ranking process and
      splits the zero rank between positive and negative ones.

correction : bool, optional
    If True, apply continuity correction by adjusting the Wilcoxon rank
    statistic by 0.5 towards the mean value when computing the
    z-statistic if a normal approximation is used.  Default is False.
alternative : {"two-sided", "greater", "less"}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    In the following, let ``d`` represent the difference between the paired
    samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or
    ``d = x`` otherwise.

    * 'two-sided': the distribution underlying ``d`` is not symmetric
      about zero.
    * 'less': the distribution underlying ``d`` is stochastically less
      than a distribution symmetric about zero.
    * 'greater': the distribution underlying ``d`` is stochastically
      greater than a distribution symmetric about zero.

method : {"auto", "exact", "approx"}, optional
    Method to calculate the p-value, see Notes. Default is "auto".

Returns
-------
An object with the following attributes.

statistic : array_like
    If `alternative` is "two-sided", the sum of the ranks of the
    differences above or below zero, whichever is smaller.
    Otherwise the sum of the ranks of the differences above zero.
pvalue : array_like
    The p-value for the test depending on `alternative` and `method`.
zstatistic : array_like
    When ``method = 'approx'``, this is the normalized z-statistic::

        z = (T - mn - d) / se

    where ``T`` is `statistic` as defined above, ``mn`` is the mean of the
    distribution under the null hypothesis, ``d`` is a continuity
    correction, and ``se`` is the standard error.
    When ``method != 'approx'``, this attribute is not available.

See Also
--------
kruskal, mannwhitneyu

Notes
-----
In the following, let ``d`` represent the difference between the paired
samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or ``d = x``
otherwise. Assume that all elements of ``d`` are independent and
identically distributed observations, and all are distinct and nonzero.

- When ``len(d)`` is sufficiently large, the null distribution of the
  normalized test statistic (`zstatistic` above) is approximately normal,
  and ``method = 'approx'`` can be used to compute the p-value.

- When ``len(d)`` is small, the normal approximation may not be accurate,
  and ``method='exact'`` is preferred (at the cost of additional
  execution time).

- The default, ``method='auto'``, selects between the two: when
  ``len(d) &lt;= 50``, the exact method is used; otherwise, the approximate
  method is used.

The presence of "ties" (i.e. not all elements of ``d`` are unique) and
"zeros" (i.e. elements of ``d`` are zero) changes the null distribution
of the test statistic, and ``method='exact'`` no longer calculates
the exact p-value. If ``method='approx'``, the z-statistic is adjusted
for more accurate comparison against the standard normal, but still,
for finite sample sizes, the standard normal is only an approximation of
the true null distribution of the z-statistic. There is no clear
consensus among references on which method most accurately approximates
the p-value for small samples in the presence of zeros and/or ties. In any
case, this is the behavior of `wilcoxon` when ``method='auto':
``method='exact'`` is used when ``len(d) &lt;= 50`` *and there are no zeros*;
otherwise, ``method='approx'`` is used.

References
----------
.. [1] https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test
.. [2] Conover, W.J., Practical Nonparametric Statistics, 1971.
.. [3] Pratt, J.W., Remarks on Zeros and Ties in the Wilcoxon Signed
   Rank Procedures, Journal of the American Statistical Association,
   Vol. 54, 1959, pp. 655-667. :doi:`10.1080/01621459.1959.10501526`
.. [4] Wilcoxon, F., Individual Comparisons by Ranking Methods,
   Biometrics Bulletin, Vol. 1, 1945, pp. 80-83. :doi:`10.2307/3001968`
.. [5] Cureton, E.E., The Normal Approximation to the Signed-Rank
   Sampling Distribution When Zero Differences are Present,
   Journal of the American Statistical Association, Vol. 62, 1967,
   pp. 1068-1069. :doi:`10.1080/01621459.1967.10500917`

Examples
--------
In [4]_, the differences in height between cross- and self-fertilized
corn plants is given as follows:

&gt;&gt;&gt; d = [6, 8, 14, 16, 23, 24, 28, 29, 41, -48, 49, 56, 60, -67, 75]

Cross-fertilized plants appear to be be higher. To test the null
hypothesis that there is no height difference, we can apply the
two-sided test:

&gt;&gt;&gt; from scipy.stats import wilcoxon
&gt;&gt;&gt; res = wilcoxon(d)
&gt;&gt;&gt; res.statistic, res.pvalue
(24.0, 0.041259765625)

Hence, we would reject the null hypothesis at a confidence level of 5%,
concluding that there is a difference in height between the groups.
To confirm that the median of the differences can be assumed to be
positive, we use:

&gt;&gt;&gt; res = wilcoxon(d, alternative='greater')
&gt;&gt;&gt; res.statistic, res.pvalue
(96.0, 0.0206298828125)

This shows that the null hypothesis that the median is negative can be
rejected at a confidence level of 5% in favor of the alternative that
the median is greater than zero. The p-values above are exact. Using the
normal approximation gives very similar values:

&gt;&gt;&gt; res = wilcoxon(d, method='approx')
&gt;&gt;&gt; res.statistic, res.pvalue
(24.0, 0.04088813291185591)

Note that the statistic changed to 96 in the one-sided case (the sum
of ranks of positive differences) whereas it is 24 in the two-sided
case (the minimum of sum of ranks above and below zero).</pre> <div class="fragment"><div class="line"><span class="lineno"> 3138</span>             alternative=<span class="stringliteral">&quot;two-sided&quot;</span>, method=<span class="stringliteral">&#39;auto&#39;</span>):</div>
<div class="line"><span class="lineno"> 3139</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the Wilcoxon signed-rank test.</span></div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral">    The Wilcoxon signed-rank test tests the null hypothesis that two</span></div>
<div class="line"><span class="lineno"> 3142</span><span class="stringliteral">    related paired samples come from the same distribution. In particular,</span></div>
<div class="line"><span class="lineno"> 3143</span><span class="stringliteral">    it tests whether the distribution of the differences ``x - y`` is symmetric</span></div>
<div class="line"><span class="lineno"> 3144</span><span class="stringliteral">    about zero. It is a non-parametric version of the paired T-test.</span></div>
<div class="line"><span class="lineno"> 3145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3146</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3147</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3148</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 3149</span><span class="stringliteral">        Either the first set of measurements (in which case ``y`` is the second</span></div>
<div class="line"><span class="lineno"> 3150</span><span class="stringliteral">        set of measurements), or the differences between two sets of</span></div>
<div class="line"><span class="lineno"> 3151</span><span class="stringliteral">        measurements (in which case ``y`` is not to be specified.)  Must be</span></div>
<div class="line"><span class="lineno"> 3152</span><span class="stringliteral">        one-dimensional.</span></div>
<div class="line"><span class="lineno"> 3153</span><span class="stringliteral">    y : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3154</span><span class="stringliteral">        Either the second set of measurements (if ``x`` is the first set of</span></div>
<div class="line"><span class="lineno"> 3155</span><span class="stringliteral">        measurements), or not specified (if ``x`` is the differences between</span></div>
<div class="line"><span class="lineno"> 3156</span><span class="stringliteral">        two sets of measurements.)  Must be one-dimensional.</span></div>
<div class="line"><span class="lineno"> 3157</span><span class="stringliteral">    zero_method : {&quot;wilcox&quot;, &quot;pratt&quot;, &quot;zsplit&quot;}, optional</span></div>
<div class="line"><span class="lineno"> 3158</span><span class="stringliteral">        There are different conventions for handling pairs of observations</span></div>
<div class="line"><span class="lineno"> 3159</span><span class="stringliteral">        with equal values (&quot;zero-differences&quot;, or &quot;zeros&quot;).</span></div>
<div class="line"><span class="lineno"> 3160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3161</span><span class="stringliteral">        * &quot;wilcox&quot;: Discards all zero-differences (default); see [4]_.</span></div>
<div class="line"><span class="lineno"> 3162</span><span class="stringliteral">        * &quot;pratt&quot;: Includes zero-differences in the ranking process,</span></div>
<div class="line"><span class="lineno"> 3163</span><span class="stringliteral">          but drops the ranks of the zeros (more conservative); see [3]_.</span></div>
<div class="line"><span class="lineno"> 3164</span><span class="stringliteral">          In this case, the normal approximation is adjusted as in [5]_.</span></div>
<div class="line"><span class="lineno"> 3165</span><span class="stringliteral">        * &quot;zsplit&quot;: Includes zero-differences in the ranking process and</span></div>
<div class="line"><span class="lineno"> 3166</span><span class="stringliteral">          splits the zero rank between positive and negative ones.</span></div>
<div class="line"><span class="lineno"> 3167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3168</span><span class="stringliteral">    correction : bool, optional</span></div>
<div class="line"><span class="lineno"> 3169</span><span class="stringliteral">        If True, apply continuity correction by adjusting the Wilcoxon rank</span></div>
<div class="line"><span class="lineno"> 3170</span><span class="stringliteral">        statistic by 0.5 towards the mean value when computing the</span></div>
<div class="line"><span class="lineno"> 3171</span><span class="stringliteral">        z-statistic if a normal approximation is used.  Default is False.</span></div>
<div class="line"><span class="lineno"> 3172</span><span class="stringliteral">    alternative : {&quot;two-sided&quot;, &quot;greater&quot;, &quot;less&quot;}, optional</span></div>
<div class="line"><span class="lineno"> 3173</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 3174</span><span class="stringliteral">        In the following, let ``d`` represent the difference between the paired</span></div>
<div class="line"><span class="lineno"> 3175</span><span class="stringliteral">        samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or</span></div>
<div class="line"><span class="lineno"> 3176</span><span class="stringliteral">        ``d = x`` otherwise.</span></div>
<div class="line"><span class="lineno"> 3177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3178</span><span class="stringliteral">        * &#39;two-sided&#39;: the distribution underlying ``d`` is not symmetric</span></div>
<div class="line"><span class="lineno"> 3179</span><span class="stringliteral">          about zero.</span></div>
<div class="line"><span class="lineno"> 3180</span><span class="stringliteral">        * &#39;less&#39;: the distribution underlying ``d`` is stochastically less</span></div>
<div class="line"><span class="lineno"> 3181</span><span class="stringliteral">          than a distribution symmetric about zero.</span></div>
<div class="line"><span class="lineno"> 3182</span><span class="stringliteral">        * &#39;greater&#39;: the distribution underlying ``d`` is stochastically</span></div>
<div class="line"><span class="lineno"> 3183</span><span class="stringliteral">          greater than a distribution symmetric about zero.</span></div>
<div class="line"><span class="lineno"> 3184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3185</span><span class="stringliteral">    method : {&quot;auto&quot;, &quot;exact&quot;, &quot;approx&quot;}, optional</span></div>
<div class="line"><span class="lineno"> 3186</span><span class="stringliteral">        Method to calculate the p-value, see Notes. Default is &quot;auto&quot;.</span></div>
<div class="line"><span class="lineno"> 3187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3188</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3189</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3190</span><span class="stringliteral">    An object with the following attributes.</span></div>
<div class="line"><span class="lineno"> 3191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3192</span><span class="stringliteral">    statistic : array_like</span></div>
<div class="line"><span class="lineno"> 3193</span><span class="stringliteral">        If `alternative` is &quot;two-sided&quot;, the sum of the ranks of the</span></div>
<div class="line"><span class="lineno"> 3194</span><span class="stringliteral">        differences above or below zero, whichever is smaller.</span></div>
<div class="line"><span class="lineno"> 3195</span><span class="stringliteral">        Otherwise the sum of the ranks of the differences above zero.</span></div>
<div class="line"><span class="lineno"> 3196</span><span class="stringliteral">    pvalue : array_like</span></div>
<div class="line"><span class="lineno"> 3197</span><span class="stringliteral">        The p-value for the test depending on `alternative` and `method`.</span></div>
<div class="line"><span class="lineno"> 3198</span><span class="stringliteral">    zstatistic : array_like</span></div>
<div class="line"><span class="lineno"> 3199</span><span class="stringliteral">        When ``method = &#39;approx&#39;``, this is the normalized z-statistic::</span></div>
<div class="line"><span class="lineno"> 3200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral">            z = (T - mn - d) / se</span></div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">        where ``T`` is `statistic` as defined above, ``mn`` is the mean of the</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral">        distribution under the null hypothesis, ``d`` is a continuity</span></div>
<div class="line"><span class="lineno"> 3205</span><span class="stringliteral">        correction, and ``se`` is the standard error.</span></div>
<div class="line"><span class="lineno"> 3206</span><span class="stringliteral">        When ``method != &#39;approx&#39;``, this attribute is not available.</span></div>
<div class="line"><span class="lineno"> 3207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3208</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3209</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3210</span><span class="stringliteral">    kruskal, mannwhitneyu</span></div>
<div class="line"><span class="lineno"> 3211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3212</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3213</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3214</span><span class="stringliteral">    In the following, let ``d`` represent the difference between the paired</span></div>
<div class="line"><span class="lineno"> 3215</span><span class="stringliteral">    samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or ``d = x``</span></div>
<div class="line"><span class="lineno"> 3216</span><span class="stringliteral">    otherwise. Assume that all elements of ``d`` are independent and</span></div>
<div class="line"><span class="lineno"> 3217</span><span class="stringliteral">    identically distributed observations, and all are distinct and nonzero.</span></div>
<div class="line"><span class="lineno"> 3218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3219</span><span class="stringliteral">    - When ``len(d)`` is sufficiently large, the null distribution of the</span></div>
<div class="line"><span class="lineno"> 3220</span><span class="stringliteral">      normalized test statistic (`zstatistic` above) is approximately normal,</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral">      and ``method = &#39;approx&#39;`` can be used to compute the p-value.</span></div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral">    - When ``len(d)`` is small, the normal approximation may not be accurate,</span></div>
<div class="line"><span class="lineno"> 3224</span><span class="stringliteral">      and ``method=&#39;exact&#39;`` is preferred (at the cost of additional</span></div>
<div class="line"><span class="lineno"> 3225</span><span class="stringliteral">      execution time).</span></div>
<div class="line"><span class="lineno"> 3226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3227</span><span class="stringliteral">    - The default, ``method=&#39;auto&#39;``, selects between the two: when</span></div>
<div class="line"><span class="lineno"> 3228</span><span class="stringliteral">      ``len(d) &lt;= 50``, the exact method is used; otherwise, the approximate</span></div>
<div class="line"><span class="lineno"> 3229</span><span class="stringliteral">      method is used.</span></div>
<div class="line"><span class="lineno"> 3230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3231</span><span class="stringliteral">    The presence of &quot;ties&quot; (i.e. not all elements of ``d`` are unique) and</span></div>
<div class="line"><span class="lineno"> 3232</span><span class="stringliteral">    &quot;zeros&quot; (i.e. elements of ``d`` are zero) changes the null distribution</span></div>
<div class="line"><span class="lineno"> 3233</span><span class="stringliteral">    of the test statistic, and ``method=&#39;exact&#39;`` no longer calculates</span></div>
<div class="line"><span class="lineno"> 3234</span><span class="stringliteral">    the exact p-value. If ``method=&#39;approx&#39;``, the z-statistic is adjusted</span></div>
<div class="line"><span class="lineno"> 3235</span><span class="stringliteral">    for more accurate comparison against the standard normal, but still,</span></div>
<div class="line"><span class="lineno"> 3236</span><span class="stringliteral">    for finite sample sizes, the standard normal is only an approximation of</span></div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral">    the true null distribution of the z-statistic. There is no clear</span></div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral">    consensus among references on which method most accurately approximates</span></div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral">    the p-value for small samples in the presence of zeros and/or ties. In any</span></div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">    case, this is the behavior of `wilcoxon` when ``method=&#39;auto&#39;:</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral">    ``method=&#39;exact&#39;`` is used when ``len(d) &lt;= 50`` *and there are no zeros*;</span></div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral">    otherwise, ``method=&#39;approx&#39;`` is used.</span></div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral">    .. [1] https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test</span></div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">    .. [2] Conover, W.J., Practical Nonparametric Statistics, 1971.</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">    .. [3] Pratt, J.W., Remarks on Zeros and Ties in the Wilcoxon Signed</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral">       Rank Procedures, Journal of the American Statistical Association,</span></div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">       Vol. 54, 1959, pp. 655-667. :doi:`10.1080/01621459.1959.10501526`</span></div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral">    .. [4] Wilcoxon, F., Individual Comparisons by Ranking Methods,</span></div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral">       Biometrics Bulletin, Vol. 1, 1945, pp. 80-83. :doi:`10.2307/3001968`</span></div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral">    .. [5] Cureton, E.E., The Normal Approximation to the Signed-Rank</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">       Sampling Distribution When Zero Differences are Present,</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">       Journal of the American Statistical Association, Vol. 62, 1967,</span></div>
<div class="line"><span class="lineno"> 3256</span><span class="stringliteral">       pp. 1068-1069. :doi:`10.1080/01621459.1967.10500917`</span></div>
<div class="line"><span class="lineno"> 3257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3258</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3259</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3260</span><span class="stringliteral">    In [4]_, the differences in height between cross- and self-fertilized</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">    corn plants is given as follows:</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral">    &gt;&gt;&gt; d = [6, 8, 14, 16, 23, 24, 28, 29, 41, -48, 49, 56, 60, -67, 75]</span></div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3265</span><span class="stringliteral">    Cross-fertilized plants appear to be be higher. To test the null</span></div>
<div class="line"><span class="lineno"> 3266</span><span class="stringliteral">    hypothesis that there is no height difference, we can apply the</span></div>
<div class="line"><span class="lineno"> 3267</span><span class="stringliteral">    two-sided test:</span></div>
<div class="line"><span class="lineno"> 3268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import wilcoxon</span></div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral">    &gt;&gt;&gt; res = wilcoxon(d)</span></div>
<div class="line"><span class="lineno"> 3271</span><span class="stringliteral">    &gt;&gt;&gt; res.statistic, res.pvalue</span></div>
<div class="line"><span class="lineno"> 3272</span><span class="stringliteral">    (24.0, 0.041259765625)</span></div>
<div class="line"><span class="lineno"> 3273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3274</span><span class="stringliteral">    Hence, we would reject the null hypothesis at a confidence level of 5%,</span></div>
<div class="line"><span class="lineno"> 3275</span><span class="stringliteral">    concluding that there is a difference in height between the groups.</span></div>
<div class="line"><span class="lineno"> 3276</span><span class="stringliteral">    To confirm that the median of the differences can be assumed to be</span></div>
<div class="line"><span class="lineno"> 3277</span><span class="stringliteral">    positive, we use:</span></div>
<div class="line"><span class="lineno"> 3278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3279</span><span class="stringliteral">    &gt;&gt;&gt; res = wilcoxon(d, alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 3280</span><span class="stringliteral">    &gt;&gt;&gt; res.statistic, res.pvalue</span></div>
<div class="line"><span class="lineno"> 3281</span><span class="stringliteral">    (96.0, 0.0206298828125)</span></div>
<div class="line"><span class="lineno"> 3282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3283</span><span class="stringliteral">    This shows that the null hypothesis that the median is negative can be</span></div>
<div class="line"><span class="lineno"> 3284</span><span class="stringliteral">    rejected at a confidence level of 5% in favor of the alternative that</span></div>
<div class="line"><span class="lineno"> 3285</span><span class="stringliteral">    the median is greater than zero. The p-values above are exact. Using the</span></div>
<div class="line"><span class="lineno"> 3286</span><span class="stringliteral">    normal approximation gives very similar values:</span></div>
<div class="line"><span class="lineno"> 3287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3288</span><span class="stringliteral">    &gt;&gt;&gt; res = wilcoxon(d, method=&#39;approx&#39;)</span></div>
<div class="line"><span class="lineno"> 3289</span><span class="stringliteral">    &gt;&gt;&gt; res.statistic, res.pvalue</span></div>
<div class="line"><span class="lineno"> 3290</span><span class="stringliteral">    (24.0, 0.04088813291185591)</span></div>
<div class="line"><span class="lineno"> 3291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3292</span><span class="stringliteral">    Note that the statistic changed to 96 in the one-sided case (the sum</span></div>
<div class="line"><span class="lineno"> 3293</span><span class="stringliteral">    of ranks of positive differences) whereas it is 24 in the two-sided</span></div>
<div class="line"><span class="lineno"> 3294</span><span class="stringliteral">    case (the minimum of sum of ranks above and below zero).</span></div>
<div class="line"><span class="lineno"> 3295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3296</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3297</span>    mode = method</div>
<div class="line"><span class="lineno"> 3298</span> </div>
<div class="line"><span class="lineno"> 3299</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;approx&quot;</span>, <span class="stringliteral">&quot;exact&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3300</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;mode must be either &#39;auto&#39;, &#39;approx&#39; or &#39;exact&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 3301</span> </div>
<div class="line"><span class="lineno"> 3302</span>    <span class="keywordflow">if</span> zero_method <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;wilcox&quot;</span>, <span class="stringliteral">&quot;pratt&quot;</span>, <span class="stringliteral">&quot;zsplit&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3303</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Zero method must be either &#39;wilcox&#39; &quot;</span></div>
<div class="line"><span class="lineno"> 3304</span>                         <span class="stringliteral">&quot;or &#39;pratt&#39; or &#39;zsplit&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 3305</span> </div>
<div class="line"><span class="lineno"> 3306</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;two-sided&quot;</span>, <span class="stringliteral">&quot;less&quot;</span>, <span class="stringliteral">&quot;greater&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3307</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Alternative must be either &#39;two-sided&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 3308</span>                         <span class="stringliteral">&quot;&#39;greater&#39; or &#39;less&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 3309</span> </div>
<div class="line"><span class="lineno"> 3310</span>    <span class="keywordflow">if</span> y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3311</span>        d = asarray(x)</div>
<div class="line"><span class="lineno"> 3312</span>        <span class="keywordflow">if</span> d.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 3313</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Sample x must be one-dimensional.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3314</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3315</span>        x, y = map(asarray, (x, y))</div>
<div class="line"><span class="lineno"> 3316</span>        <span class="keywordflow">if</span> x.ndim &gt; 1 <span class="keywordflow">or</span> y.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 3317</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Samples x and y must be one-dimensional.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3318</span>        <span class="keywordflow">if</span> len(x) != len(y):</div>
<div class="line"><span class="lineno"> 3319</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The samples x and y must have the same length.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3320</span>        d = x - y</div>
<div class="line"><span class="lineno"> 3321</span> </div>
<div class="line"><span class="lineno"> 3322</span>    <span class="keywordflow">if</span> len(d) == 0:</div>
<div class="line"><span class="lineno"> 3323</span>        res = WilcoxonResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 3324</span>        <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;approx&#39;</span>:</div>
<div class="line"><span class="lineno"> 3325</span>            res.zstatistic = np.nan</div>
<div class="line"><span class="lineno"> 3326</span>        <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 3327</span> </div>
<div class="line"><span class="lineno"> 3328</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;auto&quot;</span>:</div>
<div class="line"><span class="lineno"> 3329</span>        <span class="keywordflow">if</span> len(d) &lt;= 50:</div>
<div class="line"><span class="lineno"> 3330</span>            mode = <span class="stringliteral">&quot;exact&quot;</span></div>
<div class="line"><span class="lineno"> 3331</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3332</span>            mode = <span class="stringliteral">&quot;approx&quot;</span></div>
<div class="line"><span class="lineno"> 3333</span> </div>
<div class="line"><span class="lineno"> 3334</span>    n_zero = np.sum(d == 0)</div>
<div class="line"><span class="lineno"> 3335</span>    <span class="keywordflow">if</span> n_zero &gt; 0 <span class="keywordflow">and</span> mode == <span class="stringliteral">&quot;exact&quot;</span>:</div>
<div class="line"><span class="lineno"> 3336</span>        mode = <span class="stringliteral">&quot;approx&quot;</span></div>
<div class="line"><span class="lineno"> 3337</span>        warnings.warn(<span class="stringliteral">&quot;Exact p-value calculation does not work if there are &quot;</span></div>
<div class="line"><span class="lineno"> 3338</span>                      <span class="stringliteral">&quot;zeros. Switching to normal approximation.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3339</span> </div>
<div class="line"><span class="lineno"> 3340</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;approx&quot;</span>:</div>
<div class="line"><span class="lineno"> 3341</span>        <span class="keywordflow">if</span> zero_method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;wilcox&quot;</span>, <span class="stringliteral">&quot;pratt&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3342</span>            <span class="keywordflow">if</span> n_zero == len(d):</div>
<div class="line"><span class="lineno"> 3343</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;zero_method &#39;wilcox&#39; and &#39;pratt&#39; do not &quot;</span></div>
<div class="line"><span class="lineno"> 3344</span>                                 <span class="stringliteral">&quot;work if x - y is zero for all elements.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3345</span>        <span class="keywordflow">if</span> zero_method == <span class="stringliteral">&quot;wilcox&quot;</span>:</div>
<div class="line"><span class="lineno"> 3346</span>            <span class="comment"># Keep all non-zero differences</span></div>
<div class="line"><span class="lineno"> 3347</span>            d = compress(np.not_equal(d, 0), d)</div>
<div class="line"><span class="lineno"> 3348</span> </div>
<div class="line"><span class="lineno"> 3349</span>    count = len(d)</div>
<div class="line"><span class="lineno"> 3350</span>    <span class="keywordflow">if</span> count &lt; 10 <span class="keywordflow">and</span> mode == <span class="stringliteral">&quot;approx&quot;</span>:</div>
<div class="line"><span class="lineno"> 3351</span>        warnings.warn(<span class="stringliteral">&quot;Sample size too small for normal approximation.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3352</span> </div>
<div class="line"><span class="lineno"> 3353</span>    r = _stats_py.rankdata(abs(d))</div>
<div class="line"><span class="lineno"> 3354</span>    r_plus = np.sum((d &gt; 0) * r)</div>
<div class="line"><span class="lineno"> 3355</span>    r_minus = np.sum((d &lt; 0) * r)</div>
<div class="line"><span class="lineno"> 3356</span> </div>
<div class="line"><span class="lineno"> 3357</span>    <span class="keywordflow">if</span> zero_method == <span class="stringliteral">&quot;zsplit&quot;</span>:</div>
<div class="line"><span class="lineno"> 3358</span>        r_zero = np.sum((d == 0) * r)</div>
<div class="line"><span class="lineno"> 3359</span>        r_plus += r_zero / 2.</div>
<div class="line"><span class="lineno"> 3360</span>        r_minus += r_zero / 2.</div>
<div class="line"><span class="lineno"> 3361</span> </div>
<div class="line"><span class="lineno"> 3362</span>    <span class="comment"># return min for two-sided test, but r_plus for one-sided test</span></div>
<div class="line"><span class="lineno"> 3363</span>    <span class="comment"># the literature is not consistent here</span></div>
<div class="line"><span class="lineno"> 3364</span>    <span class="comment"># r_plus is more informative since r_plus + r_minus = count*(count+1)/2,</span></div>
<div class="line"><span class="lineno"> 3365</span>    <span class="comment"># i.e. the sum of the ranks, so r_minus and the min can be inferred</span></div>
<div class="line"><span class="lineno"> 3366</span>    <span class="comment"># (If alternative=&#39;pratt&#39;, r_plus + r_minus = count*(count+1)/2 - r_zero.)</span></div>
<div class="line"><span class="lineno"> 3367</span>    <span class="comment"># [3] uses the r_plus for the one-sided test, keep min for two-sided test</span></div>
<div class="line"><span class="lineno"> 3368</span>    <span class="comment"># to keep backwards compatibility</span></div>
<div class="line"><span class="lineno"> 3369</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&quot;two-sided&quot;</span>:</div>
<div class="line"><span class="lineno"> 3370</span>        T = min(r_plus, r_minus)</div>
<div class="line"><span class="lineno"> 3371</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3372</span>        T = r_plus</div>
<div class="line"><span class="lineno"> 3373</span> </div>
<div class="line"><span class="lineno"> 3374</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;approx&quot;</span>:</div>
<div class="line"><span class="lineno"> 3375</span>        mn = count * (count + 1.) * 0.25</div>
<div class="line"><span class="lineno"> 3376</span>        se = count * (count + 1.) * (2. * count + 1.)</div>
<div class="line"><span class="lineno"> 3377</span> </div>
<div class="line"><span class="lineno"> 3378</span>        <span class="keywordflow">if</span> zero_method == <span class="stringliteral">&quot;pratt&quot;</span>:</div>
<div class="line"><span class="lineno"> 3379</span>            r = r[d != 0]</div>
<div class="line"><span class="lineno"> 3380</span>            <span class="comment"># normal approximation needs to be adjusted, see Cureton (1967)</span></div>
<div class="line"><span class="lineno"> 3381</span>            mn -= n_zero * (n_zero + 1.) * 0.25</div>
<div class="line"><span class="lineno"> 3382</span>            se -= n_zero * (n_zero + 1.) * (2. * n_zero + 1.)</div>
<div class="line"><span class="lineno"> 3383</span> </div>
<div class="line"><span class="lineno"> 3384</span>        replist, repnum = find_repeats(r)</div>
<div class="line"><span class="lineno"> 3385</span>        <span class="keywordflow">if</span> repnum.size != 0:</div>
<div class="line"><span class="lineno"> 3386</span>            <span class="comment"># Correction for repeated elements.</span></div>
<div class="line"><span class="lineno"> 3387</span>            se -= 0.5 * (repnum * (repnum * repnum - 1)).sum()</div>
<div class="line"><span class="lineno"> 3388</span> </div>
<div class="line"><span class="lineno"> 3389</span>        se = sqrt(se / 24)</div>
<div class="line"><span class="lineno"> 3390</span> </div>
<div class="line"><span class="lineno"> 3391</span>        <span class="comment"># apply continuity correction if applicable</span></div>
<div class="line"><span class="lineno"> 3392</span>        d = 0</div>
<div class="line"><span class="lineno"> 3393</span>        <span class="keywordflow">if</span> correction:</div>
<div class="line"><span class="lineno"> 3394</span>            <span class="keywordflow">if</span> alternative == <span class="stringliteral">&quot;two-sided&quot;</span>:</div>
<div class="line"><span class="lineno"> 3395</span>                d = 0.5 * np.sign(T - mn)</div>
<div class="line"><span class="lineno"> 3396</span>            <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&quot;less&quot;</span>:</div>
<div class="line"><span class="lineno"> 3397</span>                d = -0.5</div>
<div class="line"><span class="lineno"> 3398</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3399</span>                d = 0.5</div>
<div class="line"><span class="lineno"> 3400</span> </div>
<div class="line"><span class="lineno"> 3401</span>        <span class="comment"># compute statistic and p-value using normal approximation</span></div>
<div class="line"><span class="lineno"> 3402</span>        z = (T - mn - d) / se</div>
<div class="line"><span class="lineno"> 3403</span>        <span class="keywordflow">if</span> alternative == <span class="stringliteral">&quot;two-sided&quot;</span>:</div>
<div class="line"><span class="lineno"> 3404</span>            prob = 2. * distributions.norm.sf(abs(z))</div>
<div class="line"><span class="lineno"> 3405</span>        <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&quot;greater&quot;</span>:</div>
<div class="line"><span class="lineno"> 3406</span>            <span class="comment"># large T = r_plus indicates x is greater than y; i.e.</span></div>
<div class="line"><span class="lineno"> 3407</span>            <span class="comment"># accept alternative in that case and return small p-value (sf)</span></div>
<div class="line"><span class="lineno"> 3408</span>            prob = distributions.norm.sf(z)</div>
<div class="line"><span class="lineno"> 3409</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3410</span>            prob = distributions.norm.cdf(z)</div>
<div class="line"><span class="lineno"> 3411</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;exact&quot;</span>:</div>
<div class="line"><span class="lineno"> 3412</span>        <span class="comment"># get pmf of the possible positive ranksums r_plus</span></div>
<div class="line"><span class="lineno"> 3413</span>        pmf = _get_wilcoxon_distr(count)</div>
<div class="line"><span class="lineno"> 3414</span>        <span class="comment"># note: r_plus is int (ties not allowed), need int for slices below</span></div>
<div class="line"><span class="lineno"> 3415</span>        r_plus = int(r_plus)</div>
<div class="line"><span class="lineno"> 3416</span>        <span class="keywordflow">if</span> alternative == <span class="stringliteral">&quot;two-sided&quot;</span>:</div>
<div class="line"><span class="lineno"> 3417</span>            <span class="keywordflow">if</span> r_plus == (len(pmf) - 1) // 2:</div>
<div class="line"><span class="lineno"> 3418</span>                <span class="comment"># r_plus is the center of the distribution.</span></div>
<div class="line"><span class="lineno"> 3419</span>                prob = 1.0</div>
<div class="line"><span class="lineno"> 3420</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3421</span>                p_less = np.sum(pmf[:r_plus + 1])</div>
<div class="line"><span class="lineno"> 3422</span>                p_greater = np.sum(pmf[r_plus:])</div>
<div class="line"><span class="lineno"> 3423</span>                prob = 2*min(p_greater, p_less)</div>
<div class="line"><span class="lineno"> 3424</span>        <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&quot;greater&quot;</span>:</div>
<div class="line"><span class="lineno"> 3425</span>            prob = np.sum(pmf[r_plus:])</div>
<div class="line"><span class="lineno"> 3426</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3427</span>            prob = np.sum(pmf[:r_plus + 1])</div>
<div class="line"><span class="lineno"> 3428</span>        prob = np.clip(prob, 0, 1)</div>
<div class="line"><span class="lineno"> 3429</span> </div>
<div class="line"><span class="lineno"> 3430</span>    res = WilcoxonResult(T, prob)</div>
<div class="line"><span class="lineno"> 3431</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;approx&#39;</span>:</div>
<div class="line"><span class="lineno"> 3432</span>        res.zstatistic = z</div>
<div class="line"><span class="lineno"> 3433</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 3434</span> </div>
<div class="line"><span class="lineno"> 3435</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e6e371f0b3b6c73d4f678f59017343f" name="a5e6e371f0b3b6c73d4f678f59017343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6e371f0b3b6c73d4f678f59017343f">&#9670;&#160;</a></span>wilcoxon_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon_outputs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3124</span><span class="keyword">def </span>wilcoxon_outputs(kwds):</div>
<div class="line"><span class="lineno"> 3125</span>    method = kwds.get(<span class="stringliteral">&#39;method&#39;</span>, <span class="stringliteral">&#39;auto&#39;</span>)</div>
<div class="line"><span class="lineno"> 3126</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;approx&#39;</span>:</div>
<div class="line"><span class="lineno"> 3127</span>        <span class="keywordflow">return</span> 3</div>
<div class="line"><span class="lineno"> 3128</span>    <span class="keywordflow">return</span> 2</div>
<div class="line"><span class="lineno"> 3129</span> </div>
<div class="line"><span class="lineno"> 3130</span> </div>
<div class="line"><span class="lineno"> 3131</span><span class="preprocessor">@_rename_parameter(&quot;mode&quot;, &quot;method&quot;)</span></div>
<div class="line"><span class="lineno"> 3132</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno"> 3133</span>    wilcoxon_result_object, paired=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 3134</span>    n_samples=<span class="keyword">lambda</span> kwds: 2 <span class="keywordflow">if</span> kwds.get(<span class="stringliteral">&#39;y&#39;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> 1,</div>
<div class="line"><span class="lineno"> 3135</span>    result_to_tuple=wilcoxon_result_unpacker, n_outputs=wilcoxon_outputs,</div>
<div class="line"><span class="lineno"> 3136</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a66cb6178c9c02363490ed746438f8857" name="a66cb6178c9c02363490ed746438f8857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cb6178c9c02363490ed746438f8857">&#9670;&#160;</a></span>wilcoxon_result_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon_result_object </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zstatistic</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3117</span><span class="keyword">def </span>wilcoxon_result_object(statistic, pvalue, zstatistic=None):</div>
<div class="line"><span class="lineno"> 3118</span>    res = WilcoxonResult(statistic, pvalue)</div>
<div class="line"><span class="lineno"> 3119</span>    <span class="keywordflow">if</span> zstatistic <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3120</span>        res.zstatistic = zstatistic</div>
<div class="line"><span class="lineno"> 3121</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 3122</span> </div>
<div class="line"><span class="lineno"> 3123</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a2739e0b0f2ef66fdfd2131664be94b" name="a6a2739e0b0f2ef66fdfd2131664be94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2739e0b0f2ef66fdfd2131664be94b">&#9670;&#160;</a></span>wilcoxon_result_unpacker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon_result_unpacker </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3110</span><span class="keyword">def </span>wilcoxon_result_unpacker(res):</div>
<div class="line"><span class="lineno"> 3111</span>    <span class="keywordflow">if</span> hasattr(res, <span class="stringliteral">&#39;zstatistic&#39;</span>):</div>
<div class="line"><span class="lineno"> 3112</span>        <span class="keywordflow">return</span> res.statistic, res.pvalue, res.zstatistic</div>
<div class="line"><span class="lineno"> 3113</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3114</span>        <span class="keywordflow">return</span> res.statistic, res.pvalue</div>
<div class="line"><span class="lineno"> 3115</span> </div>
<div class="line"><span class="lineno"> 3116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b302a2d21bd578ba3ff828a99000b6d" name="a0b302a2d21bd578ba3ff828a99000b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b302a2d21bd578ba3ff828a99000b6d">&#9670;&#160;</a></span>yeojohnson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmbda</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dataset transformed by a Yeo-Johnson power transformation.

Parameters
----------
x : ndarray
    Input array.  Should be 1-dimensional.
lmbda : float, optional
    If ``lmbda`` is ``None``, find the lambda that maximizes the
    log-likelihood function and return it as the second output argument.
    Otherwise the transformation is done for the given value.

Returns
-------
yeojohnson: ndarray
    Yeo-Johnson power transformed array.
maxlog : float, optional
    If the `lmbda` parameter is None, the second returned argument is
    the lambda that maximizes the log-likelihood function.

See Also
--------
probplot, yeojohnson_normplot, yeojohnson_normmax, yeojohnson_llf, boxcox

Notes
-----
The Yeo-Johnson transform is given by::

    y = ((x + 1)**lmbda - 1) / lmbda,                for x &gt;= 0, lmbda != 0
        log(x + 1),                                  for x &gt;= 0, lmbda = 0
        -((-x + 1)**(2 - lmbda) - 1) / (2 - lmbda),  for x &lt; 0, lmbda != 2
        -log(-x + 1),                                for x &lt; 0, lmbda = 2

Unlike `boxcox`, `yeojohnson` does not require the input data to be
positive.

.. versionadded:: 1.2.0


References
----------
I. Yeo and R.A. Johnson, "A New Family of Power Transformations to
Improve Normality or Symmetry", Biometrika 87.4 (2000):


Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

We generate some random variates from a non-normal distribution and make a
probability plot for it, to show it is non-normal in the tails:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(211)
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; prob = stats.probplot(x, dist=stats.norm, plot=ax1)
&gt;&gt;&gt; ax1.set_xlabel('')
&gt;&gt;&gt; ax1.set_title('Probplot against normal distribution')

We now use `yeojohnson` to transform the data so it's closest to normal:

&gt;&gt;&gt; ax2 = fig.add_subplot(212)
&gt;&gt;&gt; xt, lmbda = stats.yeojohnson(x)
&gt;&gt;&gt; prob = stats.probplot(xt, dist=stats.norm, plot=ax2)
&gt;&gt;&gt; ax2.set_title('Probplot after Yeo-Johnson transformation')

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1381</span><span class="keyword">def </span>yeojohnson(x, lmbda=None):</div>
<div class="line"><span class="lineno"> 1382</span>    <span class="stringliteral">r&quot;&quot;&quot;Return a dataset transformed by a Yeo-Johnson power transformation.</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">        Input array.  Should be 1-dimensional.</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    lmbda : float, optional</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">        If ``lmbda`` is ``None``, find the lambda that maximizes the</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">        log-likelihood function and return it as the second output argument.</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">        Otherwise the transformation is done for the given value.</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    yeojohnson: ndarray</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">        Yeo-Johnson power transformed array.</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    maxlog : float, optional</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">        If the `lmbda` parameter is None, the second returned argument is</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">        the lambda that maximizes the log-likelihood function.</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    probplot, yeojohnson_normplot, yeojohnson_normmax, yeojohnson_llf, boxcox</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    The Yeo-Johnson transform is given by::</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">        y = ((x + 1)**lmbda - 1) / lmbda,                for x &gt;= 0, lmbda != 0</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">            log(x + 1),                                  for x &gt;= 0, lmbda = 0</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">            -((-x + 1)**(2 - lmbda) - 1) / (2 - lmbda),  for x &lt; 0, lmbda != 2</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">            -log(-x + 1),                                for x &lt; 0, lmbda = 2</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    Unlike `boxcox`, `yeojohnson` does not require the input data to be</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">    positive.</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">    I. Yeo and R.A. Johnson, &quot;A New Family of Power Transformations to</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    Improve Normality or Symmetry&quot;, Biometrika 87.4 (2000):</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">    We generate some random variates from a non-normal distribution and make a</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">    probability plot for it, to show it is non-normal in the tails:</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    &gt;&gt;&gt; ax1 = fig.add_subplot(211)</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.probplot(x, dist=stats.norm, plot=ax1)</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_xlabel(&#39;&#39;)</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_title(&#39;Probplot against normal distribution&#39;)</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    We now use `yeojohnson` to transform the data so it&#39;s closest to normal:</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    &gt;&gt;&gt; ax2 = fig.add_subplot(212)</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    &gt;&gt;&gt; xt, lmbda = stats.yeojohnson(x)</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.probplot(xt, dist=stats.norm, plot=ax2)</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    &gt;&gt;&gt; ax2.set_title(&#39;Probplot after Yeo-Johnson transformation&#39;)</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1451</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 1452</span>    <span class="keywordflow">if</span> x.size == 0:</div>
<div class="line"><span class="lineno"> 1453</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 1454</span> </div>
<div class="line"><span class="lineno"> 1455</span>    <span class="keywordflow">if</span> np.issubdtype(x.dtype, np.complexfloating):</div>
<div class="line"><span class="lineno"> 1456</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Yeo-Johnson transformation is not defined for &#39;</span></div>
<div class="line"><span class="lineno"> 1457</span>                         <span class="stringliteral">&#39;complex numbers.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1458</span> </div>
<div class="line"><span class="lineno"> 1459</span>    <span class="keywordflow">if</span> np.issubdtype(x.dtype, np.integer):</div>
<div class="line"><span class="lineno"> 1460</span>        x = x.astype(np.float64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1461</span> </div>
<div class="line"><span class="lineno"> 1462</span>    <span class="keywordflow">if</span> lmbda <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1463</span>        <span class="keywordflow">return</span> _yeojohnson_transform(x, lmbda)</div>
<div class="line"><span class="lineno"> 1464</span> </div>
<div class="line"><span class="lineno"> 1465</span>    <span class="comment"># if lmbda=None, find the lmbda that maximizes the log-likelihood function.</span></div>
<div class="line"><span class="lineno"> 1466</span>    lmax = yeojohnson_normmax(x)</div>
<div class="line"><span class="lineno"> 1467</span>    y = _yeojohnson_transform(x, lmax)</div>
<div class="line"><span class="lineno"> 1468</span> </div>
<div class="line"><span class="lineno"> 1469</span>    <span class="keywordflow">return</span> y, lmax</div>
<div class="line"><span class="lineno"> 1470</span> </div>
<div class="line"><span class="lineno"> 1471</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae07ef1cbf1d88998be1d88789ac21135" name="ae07ef1cbf1d88998be1d88789ac21135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07ef1cbf1d88998be1d88789ac21135">&#9670;&#160;</a></span>yeojohnson_llf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson_llf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The yeojohnson log-likelihood function.

Parameters
----------
lmb : scalar
    Parameter for Yeo-Johnson transformation. See `yeojohnson` for
    details.
data : array_like
    Data to calculate Yeo-Johnson log-likelihood for. If `data` is
    multi-dimensional, the log-likelihood is calculated along the first
    axis.

Returns
-------
llf : float
    Yeo-Johnson log-likelihood of `data` given `lmb`.

See Also
--------
yeojohnson, probplot, yeojohnson_normplot, yeojohnson_normmax

Notes
-----
The Yeo-Johnson log-likelihood function is defined here as

.. math::

    llf = -N/2 \log(\hat{\sigma}^2) + (\lambda - 1)
          \sum_i \text{ sign }(x_i)\log(|x_i| + 1)

where :math:`\hat{\sigma}^2` is estimated variance of the the Yeo-Johnson
transformed input data ``x``.

.. versionadded:: 1.2.0

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from mpl_toolkits.axes_grid1.inset_locator import inset_axes

Generate some random variates and calculate Yeo-Johnson log-likelihood
values for them for a range of ``lmbda`` values:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, loc=10, size=1000)
&gt;&gt;&gt; lmbdas = np.linspace(-2, 10)
&gt;&gt;&gt; llf = np.zeros(lmbdas.shape, dtype=float)
&gt;&gt;&gt; for ii, lmbda in enumerate(lmbdas):
...     llf[ii] = stats.yeojohnson_llf(lmbda, x)

Also find the optimal lmbda value with `yeojohnson`:

&gt;&gt;&gt; x_most_normal, lmbda_optimal = stats.yeojohnson(x)

Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
horizontal line to check that that's really the optimum:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(lmbdas, llf, 'b.-')
&gt;&gt;&gt; ax.axhline(stats.yeojohnson_llf(lmbda_optimal, x), color='r')
&gt;&gt;&gt; ax.set_xlabel('lmbda parameter')
&gt;&gt;&gt; ax.set_ylabel('Yeo-Johnson log-likelihood')

Now add some probability plots to show that where the log-likelihood is
maximized the data transformed with `yeojohnson` looks closest to normal:

&gt;&gt;&gt; locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
&gt;&gt;&gt; for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
...     xt = stats.yeojohnson(x, lmbda=lmbda)
...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
...     ax_inset.set_xticklabels([])
...     ax_inset.set_yticklabels([])
...     ax_inset.set_title(r'$\lambda=%1.2f$' % lmbda)

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1494</span><span class="keyword">def </span>yeojohnson_llf(lmb, data):</div>
<div class="line"><span class="lineno"> 1495</span>    <span class="stringliteral">r&quot;&quot;&quot;The yeojohnson log-likelihood function.</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    lmb : scalar</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">        Parameter for Yeo-Johnson transformation. See `yeojohnson` for</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">        details.</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">        Data to calculate Yeo-Johnson log-likelihood for. If `data` is</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">        multi-dimensional, the log-likelihood is calculated along the first</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">        axis.</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    llf : float</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        Yeo-Johnson log-likelihood of `data` given `lmb`.</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">    yeojohnson, probplot, yeojohnson_normplot, yeojohnson_normmax</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">    The Yeo-Johnson log-likelihood function is defined here as</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">        llf = -N/2 \log(\hat{\sigma}^2) + (\lambda - 1)</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">              \sum_i \text{ sign }(x_i)\log(|x_i| + 1)</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    where :math:`\hat{\sigma}^2` is estimated variance of the the Yeo-Johnson</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">    transformed input data ``x``.</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">    &gt;&gt;&gt; from mpl_toolkits.axes_grid1.inset_locator import inset_axes</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">    Generate some random variates and calculate Yeo-Johnson log-likelihood</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    values for them for a range of ``lmbda`` values:</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, loc=10, size=1000)</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    &gt;&gt;&gt; lmbdas = np.linspace(-2, 10)</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    &gt;&gt;&gt; llf = np.zeros(lmbdas.shape, dtype=float)</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    &gt;&gt;&gt; for ii, lmbda in enumerate(lmbdas):</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    ...     llf[ii] = stats.yeojohnson_llf(lmbda, x)</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    Also find the optimal lmbda value with `yeojohnson`:</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    &gt;&gt;&gt; x_most_normal, lmbda_optimal = stats.yeojohnson(x)</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    horizontal line to check that that&#39;s really the optimum:</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    &gt;&gt;&gt; ax.plot(lmbdas, llf, &#39;b.-&#39;)</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    &gt;&gt;&gt; ax.axhline(stats.yeojohnson_llf(lmbda_optimal, x), color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_xlabel(&#39;lmbda parameter&#39;)</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_ylabel(&#39;Yeo-Johnson log-likelihood&#39;)</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    Now add some probability plots to show that where the log-likelihood is</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">    maximized the data transformed with `yeojohnson` looks closest to normal:</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">    &gt;&gt;&gt; locs = [3, 10, 4]  # &#39;lower left&#39;, &#39;center&#39;, &#39;lower right&#39;</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    &gt;&gt;&gt; for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">    ...     xt = stats.yeojohnson(x, lmbda=lmbda)</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">    ...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">    ...     ax_inset = inset_axes(ax, width=&quot;20%&quot;, height=&quot;20%&quot;, loc=loc)</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">    ...     ax_inset.plot(osm, osr, &#39;c.&#39;, osm, slope*osm + intercept, &#39;k-&#39;)</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral">    ...     ax_inset.set_xticklabels([])</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">    ...     ax_inset.set_yticklabels([])</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">    ...     ax_inset.set_title(r&#39;$\lambda=%1.2f$&#39; % lmbda)</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1575</span>    data = np.asarray(data)</div>
<div class="line"><span class="lineno"> 1576</span>    n_samples = data.shape[0]</div>
<div class="line"><span class="lineno"> 1577</span> </div>
<div class="line"><span class="lineno"> 1578</span>    <span class="keywordflow">if</span> n_samples == 0:</div>
<div class="line"><span class="lineno"> 1579</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 1580</span> </div>
<div class="line"><span class="lineno"> 1581</span>    trans = _yeojohnson_transform(data, lmb)</div>
<div class="line"><span class="lineno"> 1582</span>    trans_var = trans.var(axis=0)</div>
<div class="line"><span class="lineno"> 1583</span>    loglike = np.empty_like(trans_var)</div>
<div class="line"><span class="lineno"> 1584</span> </div>
<div class="line"><span class="lineno"> 1585</span>    <span class="comment"># Avoid RuntimeWarning raised by np.log when the variance is too low</span></div>
<div class="line"><span class="lineno"> 1586</span>    tiny_variance = trans_var &lt; np.finfo(trans_var.dtype).tiny</div>
<div class="line"><span class="lineno"> 1587</span>    loglike[tiny_variance] = np.inf</div>
<div class="line"><span class="lineno"> 1588</span> </div>
<div class="line"><span class="lineno"> 1589</span>    loglike[~tiny_variance] = (</div>
<div class="line"><span class="lineno"> 1590</span>        -n_samples / 2 * np.log(trans_var[~tiny_variance]))</div>
<div class="line"><span class="lineno"> 1591</span>    loglike[~tiny_variance] += (</div>
<div class="line"><span class="lineno"> 1592</span>        (lmb - 1) * (np.sign(data) * np.log(np.abs(data) + 1)).sum(axis=0))</div>
<div class="line"><span class="lineno"> 1593</span>    <span class="keywordflow">return</span> loglike</div>
<div class="line"><span class="lineno"> 1594</span> </div>
<div class="line"><span class="lineno"> 1595</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e11fd74ac89acf7920558617d8aa708" name="a7e11fd74ac89acf7920558617d8aa708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e11fd74ac89acf7920558617d8aa708">&#9670;&#160;</a></span>yeojohnson_normmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson_normmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>brack</em> = <code>(-2,&#160;2)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute optimal Yeo-Johnson transform parameter.

Compute optimal Yeo-Johnson transform parameter for input data, using
maximum likelihood estimation.

Parameters
----------
x : array_like
    Input array.
brack : 2-tuple, optional
    The starting interval for a downhill bracket search with
    `optimize.brent`. Note that this is in most cases not critical; the
    final result is allowed to be outside this bracket.

Returns
-------
maxlog : float
    The optimal transform parameter found.

See Also
--------
yeojohnson, yeojohnson_llf, yeojohnson_normplot

Notes
-----
.. versionadded:: 1.2.0

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate some data and determine optimal ``lmbda``

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5
&gt;&gt;&gt; lmax = stats.yeojohnson_normmax(x)

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.yeojohnson_normplot(x, -10, 10, plot=ax)
&gt;&gt;&gt; ax.axvline(lmax, color='r')

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1596</span><span class="keyword">def </span>yeojohnson_normmax(x, brack=(-2, 2)):</div>
<div class="line"><span class="lineno"> 1597</span>    <span class="stringliteral">&quot;&quot;&quot;Compute optimal Yeo-Johnson transform parameter.</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    Compute optimal Yeo-Johnson transform parameter for input data, using</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">    maximum likelihood estimation.</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">    brack : 2-tuple, optional</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">        The starting interval for a downhill bracket search with</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">        `optimize.brent`. Note that this is in most cases not critical; the</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">        final result is allowed to be outside this bracket.</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">    maxlog : float</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">        The optimal transform parameter found.</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">    yeojohnson, yeojohnson_llf, yeojohnson_normplot</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    Generate some data and determine optimal ``lmbda``</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">    &gt;&gt;&gt; lmax = stats.yeojohnson_normmax(x)</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.yeojohnson_normplot(x, -10, 10, plot=ax)</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvline(lmax, color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1643</span>    <span class="keyword">def </span>_neg_llf(lmbda, data):</div>
<div class="line"><span class="lineno"> 1644</span>        llf = yeojohnson_llf(lmbda, data)</div>
<div class="line"><span class="lineno"> 1645</span>        <span class="comment"># reject likelihoods that are inf which are likely due to small</span></div>
<div class="line"><span class="lineno"> 1646</span>        <span class="comment"># variance in the transformed space</span></div>
<div class="line"><span class="lineno"> 1647</span>        llf[np.isinf(llf)] = -np.inf</div>
<div class="line"><span class="lineno"> 1648</span>        <span class="keywordflow">return</span> -llf</div>
<div class="line"><span class="lineno"> 1649</span> </div>
<div class="line"><span class="lineno"> 1650</span>    <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 1651</span>        <span class="keywordflow">return</span> optimize.brent(_neg_llf, brack=brack, args=(x,))</div>
<div class="line"><span class="lineno"> 1652</span> </div>
<div class="line"><span class="lineno"> 1653</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac40ff897f481883c947ea2fe777cb0f1" name="ac40ff897f481883c947ea2fe777cb0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40ff897f481883c947ea2fe777cb0f1">&#9670;&#160;</a></span>yeojohnson_normplot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson_normplot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>la</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plot</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute parameters for a Yeo-Johnson normality plot, optionally show it.

A Yeo-Johnson normality plot shows graphically what the best
transformation parameter is to use in `yeojohnson` to obtain a
distribution that is close to normal.

Parameters
----------
x : array_like
    Input array.
la, lb : scalar
    The lower and upper bounds for the ``lmbda`` values to pass to
    `yeojohnson` for Yeo-Johnson transformations. These are also the
    limits of the horizontal axis of the plot if that is generated.
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `la` to `lb`).

Returns
-------
lmbdas : ndarray
    The ``lmbda`` values for which a Yeo-Johnson transform was done.
ppcc : ndarray
    Probability Plot Correlelation Coefficient, as obtained from `probplot`
    when fitting the Box-Cox transformed input `x` against a normal
    distribution.

See Also
--------
probplot, yeojohnson, yeojohnson_normmax, yeojohnson_llf, ppcc_max

Notes
-----
Even if `plot` is given, the figure is not shown or saved by
`boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
should be used after calling `probplot`.

.. versionadded:: 1.2.0

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate some non-normally distributed data, and create a Yeo-Johnson plot:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.yeojohnson_normplot(x, -20, 20, plot=ax)

Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
the same plot:

&gt;&gt;&gt; _, maxlog = stats.yeojohnson(x)
&gt;&gt;&gt; ax.axvline(maxlog, color='r')

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1654</span><span class="keyword">def </span>yeojohnson_normplot(x, la, lb, plot=None, N=80):</div>
<div class="line"><span class="lineno"> 1655</span>    <span class="stringliteral">&quot;&quot;&quot;Compute parameters for a Yeo-Johnson normality plot, optionally show it.</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">    A Yeo-Johnson normality plot shows graphically what the best</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">    transformation parameter is to use in `yeojohnson` to obtain a</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">    distribution that is close to normal.</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">    la, lb : scalar</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">        The lower and upper bounds for the ``lmbda`` values to pass to</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">        `yeojohnson` for Yeo-Johnson transformations. These are also the</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">        limits of the horizontal axis of the plot if that is generated.</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    plot : object, optional</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">        If given, plots the quantiles and least squares fit.</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">        `plot` is an object that has to have methods &quot;plot&quot; and &quot;text&quot;.</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">        The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">        or a custom object with the same methods.</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">        Default is None, which means that no plot is created.</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">        Number of points on the horizontal axis (equally distributed from</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">        `la` to `lb`).</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    lmbdas : ndarray</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">        The ``lmbda`` values for which a Yeo-Johnson transform was done.</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">    ppcc : ndarray</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">        Probability Plot Correlelation Coefficient, as obtained from `probplot`</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">        when fitting the Box-Cox transformed input `x` against a normal</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        distribution.</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    probplot, yeojohnson, yeojohnson_normmax, yeojohnson_llf, ppcc_max</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">    Even if `plot` is given, the figure is not shown or saved by</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    `boxcox_normplot`; ``plt.show()`` or ``plt.savefig(&#39;figname.png&#39;)``</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    should be used after calling `probplot`.</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">    .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    Generate some non-normally distributed data, and create a Yeo-Johnson plot:</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">    &gt;&gt;&gt; prob = stats.yeojohnson_normplot(x, -20, 20, plot=ax)</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">    Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in</span></div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">    the same plot:</span></div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral">    &gt;&gt;&gt; _, maxlog = stats.yeojohnson(x)</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">    &gt;&gt;&gt; ax.axvline(maxlog, color=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1721</span>    <span class="keywordflow">return</span> _normplot(<span class="stringliteral">&#39;yeojohnson&#39;</span>, x, la, lb, plot, N)</div>
<div class="line"><span class="lineno"> 1722</span> </div>
<div class="line"><span class="lineno"> 1723</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a07abc5dc6f5050cd6d367147d07ceab8" name="a07abc5dc6f5050cd6d367147d07ceab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07abc5dc6f5050cd6d367147d07ceab8">&#9670;&#160;</a></span>_abw_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._abw_state = <a class="el" href="classscipy_1_1stats_1_1__morestats_1_1___a_b_w.html">_ABW</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8549d509c0d1eeba1b065cbdf4639966" name="a8549d509c0d1eeba1b065cbdf4639966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8549d509c0d1eeba1b065cbdf4639966">&#9670;&#160;</a></span>_Avals_expon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_expon = array([0.922, 1.078, 1.341, 1.606, 1.957])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a7e585a2cdac83e1d7baba82b355ecd" name="a4a7e585a2cdac83e1d7baba82b355ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7e585a2cdac83e1d7baba82b355ecd">&#9670;&#160;</a></span>_Avals_gumbel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_gumbel = array([0.474, 0.637, 0.757, 0.877, 1.038])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa81d3b78fe67a51c6bea0ef06599d68b" name="aa81d3b78fe67a51c6bea0ef06599d68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81d3b78fe67a51c6bea0ef06599d68b">&#9670;&#160;</a></span>_Avals_logistic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_logistic = array([0.426, 0.563, 0.660, 0.769, 0.906, 1.010])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cd2ed9760a5b98dbc3fd333fc804528" name="a7cd2ed9760a5b98dbc3fd333fc804528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd2ed9760a5b98dbc3fd333fc804528">&#9670;&#160;</a></span>_Avals_norm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_norm = array([0.576, 0.656, 0.787, 0.918, 1.092])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff" name="a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff">&#9670;&#160;</a></span>Anderson_ksampResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Anderson_ksampResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;Anderson_ksampResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                  (<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;critical_values&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                                   <span class="stringliteral">&#39;significance_level&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c2b948cf1b0b7f3e3a89f732d46a158" name="a4c2b948cf1b0b7f3e3a89f732d46a158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2b948cf1b0b7f3e3a89f732d46a158">&#9670;&#160;</a></span>AndersonResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.AndersonResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;AndersonResult&#39;</span>, (<span class="stringliteral">&#39;statistic&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                               <span class="stringliteral">&#39;critical_values&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                                               <span class="stringliteral">&#39;significance_level&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2ca11a242ed6b7363bbcd987cb99719" name="ac2ca11a242ed6b7363bbcd987cb99719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ca11a242ed6b7363bbcd987cb99719">&#9670;&#160;</a></span>AnsariResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.AnsariResult = namedtuple('AnsariResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a554d0b4564651ac511f77b4db7cedcbc" name="a554d0b4564651ac511f77b4db7cedcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554d0b4564651ac511f77b4db7cedcbc">&#9670;&#160;</a></span>BartlettResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.BartlettResult = namedtuple('BartlettResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5984334ae4ec091c625db36e4df5a0fc" name="a5984334ae4ec091c625db36e4df5a0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5984334ae4ec091c625db36e4df5a0fc">&#9670;&#160;</a></span>FlignerResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.FlignerResult = namedtuple('FlignerResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aa85627e72f7e9cfaa3289858b4070b" name="a3aa85627e72f7e9cfaa3289858b4070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa85627e72f7e9cfaa3289858b4070b">&#9670;&#160;</a></span>LeveneResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.LeveneResult = namedtuple('LeveneResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c7e806ff86e4c65ae6c3bb01070277d" name="a4c7e806ff86e4c65ae6c3bb01070277d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7e806ff86e4c65ae6c3bb01070277d">&#9670;&#160;</a></span>Mean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Mean = namedtuple('Mean', ('statistic', 'minmax'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee599c9ef5b9c5cb6169a4073e4f652d" name="aee599c9ef5b9c5cb6169a4073e4f652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee599c9ef5b9c5cb6169a4073e4f652d">&#9670;&#160;</a></span>ShapiroResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ShapiroResult = namedtuple('ShapiroResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e0efb5926c36511cd250ae4ad4f517" name="ae5e0efb5926c36511cd250ae4ad4f517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e0efb5926c36511cd250ae4ad4f517">&#9670;&#160;</a></span>Std_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Std_dev = namedtuple('Std_dev', ('statistic', 'minmax'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abab3ea6ff622d79893687564827860de" name="abab3ea6ff622d79893687564827860de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab3ea6ff622d79893687564827860de">&#9670;&#160;</a></span>Variance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Variance = namedtuple('Variance', ('statistic', 'minmax'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55dc3765613b9ba274d8c8020459cf47" name="a55dc3765613b9ba274d8c8020459cf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dc3765613b9ba274d8c8020459cf47">&#9670;&#160;</a></span>WilcoxonResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.WilcoxonResult = _make_tuple_bunch('WilcoxonResult', ['statistic', 'pvalue'])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
